// Code generated by protoc-gen-go. DO NOT EDIT.
// source: acl.proto

/*
Package halproto is a generated protocol buffer package.

It is generated from these files:
	acl.proto
	endpoint.proto
	interface.proto
	l2segment.proto
	l4lb.proto
	multicast.proto
	nic.proto
	nw.proto
	nwsec.proto
	qos.proto
	session.proto
	tcp_proxy_cb.proto
	telemetry.proto
	tenant.proto
	tls_proxy_cb.proto
	types.proto

It has these top-level messages:
	AclHandle
	AclKeyHandle
	EthSelector
	UDPSelector
	TCPSelector
	ICMPSelector
	IPSelector
	AclSelector
	AclActionInfo
	AclSpec
	AclRequestMsg
	AclStatus
	AclResponse
	AclResponseMsg
	AclDeleteRequest
	AclDeleteRequestMsg
	AclDeleteResponseMsg
	AclGetRequest
	AclGetRequestMsg
	AclStats
	AclGetResponse
	AclGetResponseMsg
	EndpointSpec
	EndpointRequestMsg
	EndpointStatus
	EndpointResponse
	EndpointResponseMsg
	EndpointL2Key
	EndpointL3Key
	EndpointKey
	EndpointKeyHandle
	EndpointFilter
	EndpointDeleteRequest
	EndpointDeleteRequestMsg
	EndpointDeleteResponseMsg
	EndpointGetRequest
	EndpointGetRequestMsg
	EndpointGetByInterfaceRequestMsg
	EndpointGetAllRequestMsg
	EndpointStats
	EndpointGetResponse
	EndpointGetResponseMsg
	LifQueueInfo
	LifKeyHandle
	LifSpec
	LifRequestMsg
	LifStatus
	LifResponse
	LifResponseMsg
	LifDeleteRequest
	LifDeleteRequestMsg
	LifDeleteResponseMsg
	LifTxStats
	LifRxStats
	LifStats
	LifGetRequest
	LifGetRequestMsg
	LifGetResponse
	LifGetResponseMsg
	IfEnicInfo
	TrafficClassInfo
	IfUplinkInfo
	IfUplinkPCInfo
	InterfaceKeyHandle
	IfTunnelVxlanInfo
	IfTunnelInfo
	InterfaceSpec
	InterfaceRequestMsg
	InterfaceStatus
	InterfaceResponse
	InterfaceResponseMsg
	InterfaceDeleteRequest
	InterfaceDeleteRequestMsg
	InterfaceDeleteResponseMsg
	InterfaceStats
	InterfaceGetRequest
	InterfaceGetRequestMsg
	InterfaceGetResponse
	InterfaceGetResponseMsg
	InterfaceL2SegmentSpec
	InterfaceL2SegmentRequestMsg
	InterfaceL2SegmentResponse
	InterfaceL2SegmentResponseMsg
	L2SegmentKeyHandle
	L2SegmentSpec
	L2SegmentRequestMsg
	L2SegmentStatus
	L2SegmentResponse
	L2SegmentResponseMsg
	L2SegmentDeleteRequest
	L2SegmentDeleteRequestMsg
	L2SegmentDeleteResponseMsg
	L2SegmentGetRequest
	L2SegmentGetRequestMsg
	L2SegmentStats
	L2SegmentGetResponse
	L2SegmentGetResponseMsg
	LBMethod
	HealthCheck
	L4LbServiceKey
	L4LbServiceKeyHandle
	L4LbServiceSpec
	L4LbServiceRequestMsg
	L4LbServiceStatus
	L4LbServiceResponse
	L4LbServiceResponseMsg
	L4LbServiceDeleteRequest
	L4LbServiceDeleteRequestMsg
	L4LbServiceDeleteResponseMsg
	L4LbServiceStats
	L4LbBackendKey
	L4LbBackendKeyHandle
	L4LbBackendSpec
	L4LbBackendRequestMsg
	L4LbBackendStatus
	L4LbBackendResponse
	L4LbBackendResponseMsg
	L4LbBackendDeleteRequest
	L4LbBackendDeleteRequestMsg
	L4LbBackendDeleteResponseMsg
	L4LbBackendStats
	L4LbBackendGetRequest
	L4LbBackendGetRequestMsg
	L4LbBackendGetResponse
	L4LbBackendGetResponseMsg
	L4LbServiceGetRequest
	L4LbServiceGetRequestMsg
	L4LbServiceGetResponse
	L4LbServiceGetResponseMsg
	MulticastEntryKeyIP
	MulticastEntryKeyMac
	MulticastEntryKey
	MulticastEntryKeyHandle
	MulticastEntrySpec
	MulticastEntryRequestMsg
	MulticastEntryStatus
	MulticastEntryResponse
	MulticastEntryResponseMsg
	MulticastEntryDeleteRequest
	MulticastEntryDeleteRequestMsg
	MulticastEntryDeleteResponseMsg
	MulticastEntryGetRequest
	MulticastEntryGetRequestMsg
	MulticastEntryGetResponse
	MulticastEntryGetResponseMsg
	RootConfig
	NetworkKeyHandle
	NetworkSpec
	NetworkRequestMsg
	NetworkStatus
	NetworkResponse
	NetworkResponseMsg
	NetworkDeleteRequest
	NetworkDeleteRequestMsg
	NetworkDeleteResponseMsg
	NetworkStats
	NetworkGetRequest
	NetworkGetRequestMsg
	NetworkGetResponse
	NetworkGetResponseMsg
	SecurityProfileKeyHandle
	SecurityProfileSpec
	SecurityProfileRequestMsg
	SecurityProfileStatus
	SecurityProfileResponse
	SecurityProfileResponseMsg
	SecurityProfileDeleteRequest
	SecurityProfileDeleteRequestMsg
	SecurityProfileDeleteResponseMsg
	SecurityProfileGetRequest
	SecurityProfileGetRequestMsg
	SecurityProfileStats
	SecurityProfileGetResponse
	SecurityProfileGetResponseMsg
	Service
	ALG
	FirewallRuleSpec
	DoSSessionLimits
	DoSPolicer
	DoSFloodLimits
	DoSProtectionSpec
	IngressSGPolicy
	EgressSGPolicy
	SecurityGroupKeyHandle
	SecurityGroupSpec
	SecurityGroupRequestMsg
	SecurityGroupStatus
	SecurityGroupResponse
	SecurityGroupResponseMsg
	SecurityGroupDeleteRequest
	SecurityGroupDeleteRequestMsg
	SecurityGroupDeleteResponseMsg
	SecurityGroupGetRequest
	SecurityGroupGetRequestMsg
	SecurityGroupStats
	SecurityGroupGetResponse
	SecurityGroupGetResponseMsg
	MarkingActionSpec
	QOSActions
	TrafficClass
	TrafficClassQueueMap
	BufPoolHandle
	BufPoolKeyHandle
	BufPoolSpec
	BufPoolRequestMsg
	BufPoolStatus
	BufPoolResponse
	BufPoolResponseMsg
	BufPoolDeleteRequest
	BufPoolDeleteRequestMsg
	BufPoolDeleteResponseMsg
	BufPoolStats
	BufPoolGetRequest
	BufPoolGetRequestMsg
	BufPoolGetResponse
	BufPoolGetResponseMsg
	QueueHandle
	QueueKeyHandle
	DWRRInfo
	StrictPriorityInfo
	QueueSchedulerNode
	QueueInfo
	QueueSpec
	QueueRequestMsg
	QueueStatus
	QueueResponse
	QueueResponseMsg
	QueueDeleteRequest
	QueueDeleteRequestMsg
	QueueDeleteResponseMsg
	QueueStats
	QueueGetRequest
	QueueGetRequestMsg
	QueueGetResponse
	QueueGetResponseMsg
	PolicerHandle
	PolicerKeyHandle
	PolicerSpec
	PolicerRequestMsg
	PolicerStatus
	PolicerResponse
	PolicerResponseMsg
	PolicerDeleteRequest
	PolicerDeleteRequestMsg
	PolicerDeleteResponseMsg
	PolicerGetRequest
	PolicerGetRequestMsg
	PolicerStats
	PolicerGetResponse
	PolicerGetResponseMsg
	FlowKeyL2
	FlowKeyTcpUdpInfo
	FlowKeyICMPInfo
	FlowKeyV4
	FlowKeyV6
	FlowKey
	FlowInfo
	ConnTrackInfo
	FlowData
	FlowSpec
	SessionSpec
	SessionRequestMsg
	FlowStatus
	SessionStatus
	SessionResponse
	SessionResponseMsg
	SessionDeleteRequest
	SessionDeleteRequestMsg
	SessionDeleteResponseMsg
	SessionGetRequest
	SessionGetRequestMsg
	FlowStats
	SessionStats
	SessionGetResponse
	SessionGetResponseMsg
	TcpCbKeyHandle
	TcpCbSpec
	TcpCbRequestMsg
	TcpCbStatus
	TcpCbResponse
	TcpCbResponseMsg
	TcpCbDeleteRequest
	TcpCbDeleteRequestMsg
	TcpCbDeleteResponseMsg
	TcpCbGetRequest
	TcpCbGetRequestMsg
	TcpCbStats
	TcpCbGetResponse
	TcpCbGetResponseMsg
	L4Port
	MacAddress
	CollectorSpec
	CollectorStatus
	Collector
	CollectorConfigMsg
	CollectorResponseMsg
	ExportControlId
	ExportControlSpec
	ExportControlStatus
	ExportControl
	ExportControlConfigMsg
	ExportControlResponseMsg
	MonitorAction
	FlowMonitorRuleSpec
	FlowMonitorRuleStatus
	FlowMonitorRule
	FlowMonitorRuleConfigMsg
	FlowMonitorRuleResponseMsg
	RSpanSpec
	ERSpanSpec
	MirrorSessionId
	MirrorSessionSpec
	MirrorSessionStatus
	MirrorSession
	MirrorSessionConfigMsg
	MirrorSessionResponseMsg
	TenantKeyHandle
	TenantSpec
	TenantRequestMsg
	TenantStatus
	TenantResponse
	TenantResponseMsg
	TenantDeleteRequest
	TenantDeleteRequestMsg
	TenantDeleteResponseMsg
	TenantGetRequest
	TenantGetRequestMsg
	TenantStats
	TenantGetResponse
	TenantGetResponseMsg
	TlsCbKeyHandle
	TlsCbSpec
	TlsCbRequestMsg
	TlsCbStatus
	TlsCbResponse
	TlsCbResponseMsg
	TlsCbDeleteRequest
	TlsCbDeleteRequestMsg
	TlsCbDeleteResponseMsg
	TlsCbGetRequest
	TlsCbGetRequestMsg
	TlsCbStats
	TlsCbGetResponse
	TlsCbGetResponseMsg
	ObjectMeta
	EncapInfo
	IPAddress
	IPPrefix
	L4PortRange
*/
package halproto

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// AclAction specifies all possible actions for ACL entries
type AclAction int32

const (
	AclAction_ACL_ACTION_NONE   AclAction = 0
	AclAction_ACL_ACTION_PERMIT AclAction = 1
	AclAction_ACL_ACTION_LOG    AclAction = 2
	AclAction_ACL_ACTION_DENY   AclAction = 3
)

var AclAction_name = map[int32]string{
	0: "ACL_ACTION_NONE",
	1: "ACL_ACTION_PERMIT",
	2: "ACL_ACTION_LOG",
	3: "ACL_ACTION_DENY",
}
var AclAction_value = map[string]int32{
	"ACL_ACTION_NONE":   0,
	"ACL_ACTION_PERMIT": 1,
	"ACL_ACTION_LOG":    2,
	"ACL_ACTION_DENY":   3,
}

func (x AclAction) String() string {
	return proto.EnumName(AclAction_name, int32(x))
}
func (AclAction) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

// Handle of the acl
type AclHandle struct {
	Handle uint64 `protobuf:"fixed64,1,opt,name=handle" json:"handle,omitempty"`
}

func (m *AclHandle) Reset()                    { *m = AclHandle{} }
func (m *AclHandle) String() string            { return proto.CompactTextString(m) }
func (*AclHandle) ProtoMessage()               {}
func (*AclHandle) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *AclHandle) GetHandle() uint64 {
	if m != nil {
		return m.Handle
	}
	return 0
}

// AclKeyHandle uniquely identifies a Acl
type AclKeyHandle struct {
	// Types that are valid to be assigned to KeyOrHandle:
	//	*AclKeyHandle_AclId
	//	*AclKeyHandle_AclHandle
	KeyOrHandle isAclKeyHandle_KeyOrHandle `protobuf_oneof:"key_or_handle"`
}

func (m *AclKeyHandle) Reset()                    { *m = AclKeyHandle{} }
func (m *AclKeyHandle) String() string            { return proto.CompactTextString(m) }
func (*AclKeyHandle) ProtoMessage()               {}
func (*AclKeyHandle) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

type isAclKeyHandle_KeyOrHandle interface {
	isAclKeyHandle_KeyOrHandle()
}

type AclKeyHandle_AclId struct {
	AclId uint32 `protobuf:"fixed32,1,opt,name=acl_id,json=aclId,oneof"`
}
type AclKeyHandle_AclHandle struct {
	AclHandle *AclHandle `protobuf:"bytes,2,opt,name=acl_handle,json=aclHandle,oneof"`
}

func (*AclKeyHandle_AclId) isAclKeyHandle_KeyOrHandle()     {}
func (*AclKeyHandle_AclHandle) isAclKeyHandle_KeyOrHandle() {}

func (m *AclKeyHandle) GetKeyOrHandle() isAclKeyHandle_KeyOrHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

func (m *AclKeyHandle) GetAclId() uint32 {
	if x, ok := m.GetKeyOrHandle().(*AclKeyHandle_AclId); ok {
		return x.AclId
	}
	return 0
}

func (m *AclKeyHandle) GetAclHandle() *AclHandle {
	if x, ok := m.GetKeyOrHandle().(*AclKeyHandle_AclHandle); ok {
		return x.AclHandle
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*AclKeyHandle) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _AclKeyHandle_OneofMarshaler, _AclKeyHandle_OneofUnmarshaler, _AclKeyHandle_OneofSizer, []interface{}{
		(*AclKeyHandle_AclId)(nil),
		(*AclKeyHandle_AclHandle)(nil),
	}
}

func _AclKeyHandle_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*AclKeyHandle)
	// key_or_handle
	switch x := m.KeyOrHandle.(type) {
	case *AclKeyHandle_AclId:
		b.EncodeVarint(1<<3 | proto.WireFixed32)
		b.EncodeFixed32(uint64(x.AclId))
	case *AclKeyHandle_AclHandle:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.AclHandle); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("AclKeyHandle.KeyOrHandle has unexpected type %T", x)
	}
	return nil
}

func _AclKeyHandle_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*AclKeyHandle)
	switch tag {
	case 1: // key_or_handle.acl_id
		if wire != proto.WireFixed32 {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeFixed32()
		m.KeyOrHandle = &AclKeyHandle_AclId{uint32(x)}
		return true, err
	case 2: // key_or_handle.acl_handle
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(AclHandle)
		err := b.DecodeMessage(msg)
		m.KeyOrHandle = &AclKeyHandle_AclHandle{msg}
		return true, err
	default:
		return false, nil
	}
}

func _AclKeyHandle_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*AclKeyHandle)
	// key_or_handle
	switch x := m.KeyOrHandle.(type) {
	case *AclKeyHandle_AclId:
		n += proto.SizeVarint(1<<3 | proto.WireFixed32)
		n += 4
	case *AclKeyHandle_AclHandle:
		s := proto.Size(x.AclHandle)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// EthSelector has match criteria for non-IP packets
type EthSelector struct {
	EthType    uint32 `protobuf:"varint,1,opt,name=eth_type,json=ethType" json:"eth_type,omitempty"`
	SrcMac     uint64 `protobuf:"varint,2,opt,name=src_mac,json=srcMac" json:"src_mac,omitempty"`
	SrcMacMask uint64 `protobuf:"varint,3,opt,name=src_mac_mask,json=srcMacMask" json:"src_mac_mask,omitempty"`
	DstMac     uint64 `protobuf:"varint,4,opt,name=dst_mac,json=dstMac" json:"dst_mac,omitempty"`
	DstMacMask uint64 `protobuf:"varint,5,opt,name=dst_mac_mask,json=dstMacMask" json:"dst_mac_mask,omitempty"`
}

func (m *EthSelector) Reset()                    { *m = EthSelector{} }
func (m *EthSelector) String() string            { return proto.CompactTextString(m) }
func (*EthSelector) ProtoMessage()               {}
func (*EthSelector) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *EthSelector) GetEthType() uint32 {
	if m != nil {
		return m.EthType
	}
	return 0
}

func (m *EthSelector) GetSrcMac() uint64 {
	if m != nil {
		return m.SrcMac
	}
	return 0
}

func (m *EthSelector) GetSrcMacMask() uint64 {
	if m != nil {
		return m.SrcMacMask
	}
	return 0
}

func (m *EthSelector) GetDstMac() uint64 {
	if m != nil {
		return m.DstMac
	}
	return 0
}

func (m *EthSelector) GetDstMacMask() uint64 {
	if m != nil {
		return m.DstMacMask
	}
	return 0
}

// UDPSelector is used to specify match criteria for UDP traffic
type UDPSelector struct {
	PortRange *L4PortRange `protobuf:"bytes,1,opt,name=port_range,json=portRange" json:"port_range,omitempty"`
}

func (m *UDPSelector) Reset()                    { *m = UDPSelector{} }
func (m *UDPSelector) String() string            { return proto.CompactTextString(m) }
func (*UDPSelector) ProtoMessage()               {}
func (*UDPSelector) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *UDPSelector) GetPortRange() *L4PortRange {
	if m != nil {
		return m.PortRange
	}
	return nil
}

// TCPSelector is used to specify match criteria for TCP traffic
type TCPSelector struct {
	TcpSyn    bool         `protobuf:"varint,1,opt,name=tcp_syn,json=tcpSyn" json:"tcp_syn,omitempty"`
	TcpAck    bool         `protobuf:"varint,2,opt,name=tcp_ack,json=tcpAck" json:"tcp_ack,omitempty"`
	TcpFin    bool         `protobuf:"varint,3,opt,name=tcp_fin,json=tcpFin" json:"tcp_fin,omitempty"`
	TcpRst    bool         `protobuf:"varint,4,opt,name=tcp_rst,json=tcpRst" json:"tcp_rst,omitempty"`
	TcpUrg    bool         `protobuf:"varint,5,opt,name=tcp_urg,json=tcpUrg" json:"tcp_urg,omitempty"`
	PortRange *L4PortRange `protobuf:"bytes,6,opt,name=port_range,json=portRange" json:"port_range,omitempty"`
}

func (m *TCPSelector) Reset()                    { *m = TCPSelector{} }
func (m *TCPSelector) String() string            { return proto.CompactTextString(m) }
func (*TCPSelector) ProtoMessage()               {}
func (*TCPSelector) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *TCPSelector) GetTcpSyn() bool {
	if m != nil {
		return m.TcpSyn
	}
	return false
}

func (m *TCPSelector) GetTcpAck() bool {
	if m != nil {
		return m.TcpAck
	}
	return false
}

func (m *TCPSelector) GetTcpFin() bool {
	if m != nil {
		return m.TcpFin
	}
	return false
}

func (m *TCPSelector) GetTcpRst() bool {
	if m != nil {
		return m.TcpRst
	}
	return false
}

func (m *TCPSelector) GetTcpUrg() bool {
	if m != nil {
		return m.TcpUrg
	}
	return false
}

func (m *TCPSelector) GetPortRange() *L4PortRange {
	if m != nil {
		return m.PortRange
	}
	return nil
}

// ICMPSelector has match criteria for ICMP packets
type ICMPSelector struct {
	IcmpCode uint32 `protobuf:"varint,1,opt,name=icmp_code,json=icmpCode" json:"icmp_code,omitempty"`
	IcmpType uint32 `protobuf:"varint,2,opt,name=icmp_type,json=icmpType" json:"icmp_type,omitempty"`
}

func (m *ICMPSelector) Reset()                    { *m = ICMPSelector{} }
func (m *ICMPSelector) String() string            { return proto.CompactTextString(m) }
func (*ICMPSelector) ProtoMessage()               {}
func (*ICMPSelector) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *ICMPSelector) GetIcmpCode() uint32 {
	if m != nil {
		return m.IcmpCode
	}
	return 0
}

func (m *ICMPSelector) GetIcmpType() uint32 {
	if m != nil {
		return m.IcmpType
	}
	return 0
}

// IPSelector has match criteria for selecting IP packets
type IPSelector struct {
	SrcPrefix *IPPrefix  `protobuf:"bytes,1,opt,name=src_prefix,json=srcPrefix" json:"src_prefix,omitempty"`
	DstPrefix *IPPrefix  `protobuf:"bytes,2,opt,name=dst_prefix,json=dstPrefix" json:"dst_prefix,omitempty"`
	Protocol  IPProtocol `protobuf:"varint,3,opt,name=protocol,enum=types.IPProtocol" json:"protocol,omitempty"`
	// Types that are valid to be assigned to L4Selectors:
	//	*IPSelector_IcmpSelector
	//	*IPSelector_UdpSelector
	//	*IPSelector_TcpSelector
	L4Selectors isIPSelector_L4Selectors `protobuf_oneof:"l4_selectors"`
}

func (m *IPSelector) Reset()                    { *m = IPSelector{} }
func (m *IPSelector) String() string            { return proto.CompactTextString(m) }
func (*IPSelector) ProtoMessage()               {}
func (*IPSelector) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

type isIPSelector_L4Selectors interface {
	isIPSelector_L4Selectors()
}

type IPSelector_IcmpSelector struct {
	IcmpSelector *ICMPSelector `protobuf:"bytes,4,opt,name=icmp_selector,json=icmpSelector,oneof"`
}
type IPSelector_UdpSelector struct {
	UdpSelector *UDPSelector `protobuf:"bytes,5,opt,name=udp_selector,json=udpSelector,oneof"`
}
type IPSelector_TcpSelector struct {
	TcpSelector *TCPSelector `protobuf:"bytes,6,opt,name=tcp_selector,json=tcpSelector,oneof"`
}

func (*IPSelector_IcmpSelector) isIPSelector_L4Selectors() {}
func (*IPSelector_UdpSelector) isIPSelector_L4Selectors()  {}
func (*IPSelector_TcpSelector) isIPSelector_L4Selectors()  {}

func (m *IPSelector) GetL4Selectors() isIPSelector_L4Selectors {
	if m != nil {
		return m.L4Selectors
	}
	return nil
}

func (m *IPSelector) GetSrcPrefix() *IPPrefix {
	if m != nil {
		return m.SrcPrefix
	}
	return nil
}

func (m *IPSelector) GetDstPrefix() *IPPrefix {
	if m != nil {
		return m.DstPrefix
	}
	return nil
}

func (m *IPSelector) GetProtocol() IPProtocol {
	if m != nil {
		return m.Protocol
	}
	return IPProtocol_IP_PROTO_NONE
}

func (m *IPSelector) GetIcmpSelector() *ICMPSelector {
	if x, ok := m.GetL4Selectors().(*IPSelector_IcmpSelector); ok {
		return x.IcmpSelector
	}
	return nil
}

func (m *IPSelector) GetUdpSelector() *UDPSelector {
	if x, ok := m.GetL4Selectors().(*IPSelector_UdpSelector); ok {
		return x.UdpSelector
	}
	return nil
}

func (m *IPSelector) GetTcpSelector() *TCPSelector {
	if x, ok := m.GetL4Selectors().(*IPSelector_TcpSelector); ok {
		return x.TcpSelector
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*IPSelector) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _IPSelector_OneofMarshaler, _IPSelector_OneofUnmarshaler, _IPSelector_OneofSizer, []interface{}{
		(*IPSelector_IcmpSelector)(nil),
		(*IPSelector_UdpSelector)(nil),
		(*IPSelector_TcpSelector)(nil),
	}
}

func _IPSelector_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*IPSelector)
	// l4_selectors
	switch x := m.L4Selectors.(type) {
	case *IPSelector_IcmpSelector:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.IcmpSelector); err != nil {
			return err
		}
	case *IPSelector_UdpSelector:
		b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.UdpSelector); err != nil {
			return err
		}
	case *IPSelector_TcpSelector:
		b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.TcpSelector); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("IPSelector.L4Selectors has unexpected type %T", x)
	}
	return nil
}

func _IPSelector_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*IPSelector)
	switch tag {
	case 4: // l4_selectors.icmp_selector
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ICMPSelector)
		err := b.DecodeMessage(msg)
		m.L4Selectors = &IPSelector_IcmpSelector{msg}
		return true, err
	case 5: // l4_selectors.udp_selector
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(UDPSelector)
		err := b.DecodeMessage(msg)
		m.L4Selectors = &IPSelector_UdpSelector{msg}
		return true, err
	case 6: // l4_selectors.tcp_selector
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TCPSelector)
		err := b.DecodeMessage(msg)
		m.L4Selectors = &IPSelector_TcpSelector{msg}
		return true, err
	default:
		return false, nil
	}
}

func _IPSelector_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*IPSelector)
	// l4_selectors
	switch x := m.L4Selectors.(type) {
	case *IPSelector_IcmpSelector:
		s := proto.Size(x.IcmpSelector)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *IPSelector_UdpSelector:
		s := proto.Size(x.UdpSelector)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *IPSelector_TcpSelector:
		s := proto.Size(x.TcpSelector)
		n += proto.SizeVarint(6<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// AclSelector has all the match criteria for an ACL entry
type AclSelector struct {
	SrcLifKeyHandle    *LifKeyHandle       `protobuf:"bytes,1,opt,name=src_lif_key_handle,json=srcLifKeyHandle" json:"src_lif_key_handle,omitempty"`
	DstLifKeyHandle    *LifKeyHandle       `protobuf:"bytes,2,opt,name=dst_lif_key_handle,json=dstLifKeyHandle" json:"dst_lif_key_handle,omitempty"`
	L2SegmentKeyHandle *L2SegmentKeyHandle `protobuf:"bytes,3,opt,name=l2_segment_key_handle,json=l2SegmentKeyHandle" json:"l2_segment_key_handle,omitempty"`
	// Types that are valid to be assigned to PktSelector:
	//	*AclSelector_EthSelector
	//	*AclSelector_IpSelector
	PktSelector isAclSelector_PktSelector `protobuf_oneof:"pkt_selector"`
}

func (m *AclSelector) Reset()                    { *m = AclSelector{} }
func (m *AclSelector) String() string            { return proto.CompactTextString(m) }
func (*AclSelector) ProtoMessage()               {}
func (*AclSelector) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

type isAclSelector_PktSelector interface {
	isAclSelector_PktSelector()
}

type AclSelector_EthSelector struct {
	EthSelector *EthSelector `protobuf:"bytes,4,opt,name=eth_selector,json=ethSelector,oneof"`
}
type AclSelector_IpSelector struct {
	IpSelector *IPSelector `protobuf:"bytes,5,opt,name=ip_selector,json=ipSelector,oneof"`
}

func (*AclSelector_EthSelector) isAclSelector_PktSelector() {}
func (*AclSelector_IpSelector) isAclSelector_PktSelector()  {}

func (m *AclSelector) GetPktSelector() isAclSelector_PktSelector {
	if m != nil {
		return m.PktSelector
	}
	return nil
}

func (m *AclSelector) GetSrcLifKeyHandle() *LifKeyHandle {
	if m != nil {
		return m.SrcLifKeyHandle
	}
	return nil
}

func (m *AclSelector) GetDstLifKeyHandle() *LifKeyHandle {
	if m != nil {
		return m.DstLifKeyHandle
	}
	return nil
}

func (m *AclSelector) GetL2SegmentKeyHandle() *L2SegmentKeyHandle {
	if m != nil {
		return m.L2SegmentKeyHandle
	}
	return nil
}

func (m *AclSelector) GetEthSelector() *EthSelector {
	if x, ok := m.GetPktSelector().(*AclSelector_EthSelector); ok {
		return x.EthSelector
	}
	return nil
}

func (m *AclSelector) GetIpSelector() *IPSelector {
	if x, ok := m.GetPktSelector().(*AclSelector_IpSelector); ok {
		return x.IpSelector
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*AclSelector) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _AclSelector_OneofMarshaler, _AclSelector_OneofUnmarshaler, _AclSelector_OneofSizer, []interface{}{
		(*AclSelector_EthSelector)(nil),
		(*AclSelector_IpSelector)(nil),
	}
}

func _AclSelector_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*AclSelector)
	// pkt_selector
	switch x := m.PktSelector.(type) {
	case *AclSelector_EthSelector:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.EthSelector); err != nil {
			return err
		}
	case *AclSelector_IpSelector:
		b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.IpSelector); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("AclSelector.PktSelector has unexpected type %T", x)
	}
	return nil
}

func _AclSelector_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*AclSelector)
	switch tag {
	case 4: // pkt_selector.eth_selector
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(EthSelector)
		err := b.DecodeMessage(msg)
		m.PktSelector = &AclSelector_EthSelector{msg}
		return true, err
	case 5: // pkt_selector.ip_selector
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(IPSelector)
		err := b.DecodeMessage(msg)
		m.PktSelector = &AclSelector_IpSelector{msg}
		return true, err
	default:
		return false, nil
	}
}

func _AclSelector_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*AclSelector)
	// pkt_selector
	switch x := m.PktSelector.(type) {
	case *AclSelector_EthSelector:
		s := proto.Size(x.EthSelector)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *AclSelector_IpSelector:
		s := proto.Size(x.IpSelector)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type AclActionInfo struct {
	Action                 AclAction `protobuf:"varint,1,opt,name=action,enum=acl.AclAction" json:"action,omitempty"`
	IngMirrorEn            bool      `protobuf:"varint,2,opt,name=ing_mirror_en,json=ingMirrorEn" json:"ing_mirror_en,omitempty"`
	IngMirrorSessionHandle uint64    `protobuf:"fixed64,3,opt,name=ing_mirror_session_handle,json=ingMirrorSessionHandle" json:"ing_mirror_session_handle,omitempty"`
	EgrMirrorEn            bool      `protobuf:"varint,4,opt,name=egr_mirror_en,json=egrMirrorEn" json:"egr_mirror_en,omitempty"`
	EgrMirrorSessionHandle uint64    `protobuf:"fixed64,5,opt,name=egr_mirror_session_handle,json=egrMirrorSessionHandle" json:"egr_mirror_session_handle,omitempty"`
	CoppPolicerHandle      uint64    `protobuf:"fixed64,6,opt,name=copp_policer_handle,json=coppPolicerHandle" json:"copp_policer_handle,omitempty"`
}

func (m *AclActionInfo) Reset()                    { *m = AclActionInfo{} }
func (m *AclActionInfo) String() string            { return proto.CompactTextString(m) }
func (*AclActionInfo) ProtoMessage()               {}
func (*AclActionInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *AclActionInfo) GetAction() AclAction {
	if m != nil {
		return m.Action
	}
	return AclAction_ACL_ACTION_NONE
}

func (m *AclActionInfo) GetIngMirrorEn() bool {
	if m != nil {
		return m.IngMirrorEn
	}
	return false
}

func (m *AclActionInfo) GetIngMirrorSessionHandle() uint64 {
	if m != nil {
		return m.IngMirrorSessionHandle
	}
	return 0
}

func (m *AclActionInfo) GetEgrMirrorEn() bool {
	if m != nil {
		return m.EgrMirrorEn
	}
	return false
}

func (m *AclActionInfo) GetEgrMirrorSessionHandle() uint64 {
	if m != nil {
		return m.EgrMirrorSessionHandle
	}
	return 0
}

func (m *AclActionInfo) GetCoppPolicerHandle() uint64 {
	if m != nil {
		return m.CoppPolicerHandle
	}
	return 0
}

// ACL entry configuration
type AclSpec struct {
	Meta        *ObjectMeta   `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	KeyOrHandle *AclKeyHandle `protobuf:"bytes,2,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty"`
	Priority    uint32        `protobuf:"varint,3,opt,name=priority" json:"priority,omitempty"`
	// TBD: is this per-tenant priority ? or global ?
	Match  *AclSelector   `protobuf:"bytes,4,opt,name=match" json:"match,omitempty"`
	Action *AclActionInfo `protobuf:"bytes,5,opt,name=action" json:"action,omitempty"`
}

func (m *AclSpec) Reset()                    { *m = AclSpec{} }
func (m *AclSpec) String() string            { return proto.CompactTextString(m) }
func (*AclSpec) ProtoMessage()               {}
func (*AclSpec) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *AclSpec) GetMeta() *ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *AclSpec) GetKeyOrHandle() *AclKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

func (m *AclSpec) GetPriority() uint32 {
	if m != nil {
		return m.Priority
	}
	return 0
}

func (m *AclSpec) GetMatch() *AclSelector {
	if m != nil {
		return m.Match
	}
	return nil
}

func (m *AclSpec) GetAction() *AclActionInfo {
	if m != nil {
		return m.Action
	}
	return nil
}

// Batched requests to create/update acls
type AclRequestMsg struct {
	Request []*AclSpec `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *AclRequestMsg) Reset()                    { *m = AclRequestMsg{} }
func (m *AclRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*AclRequestMsg) ProtoMessage()               {}
func (*AclRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *AclRequestMsg) GetRequest() []*AclSpec {
	if m != nil {
		return m.Request
	}
	return nil
}

// AclStatus represents the operational status of an ACL entry
type AclStatus struct {
	AclHandle *AclHandle `protobuf:"bytes,1,opt,name=acl_handle,json=aclHandle" json:"acl_handle,omitempty"`
}

func (m *AclStatus) Reset()                    { *m = AclStatus{} }
func (m *AclStatus) String() string            { return proto.CompactTextString(m) }
func (*AclStatus) ProtoMessage()               {}
func (*AclStatus) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *AclStatus) GetAclHandle() *AclHandle {
	if m != nil {
		return m.AclHandle
	}
	return nil
}

// AclResponse is response to one Acl
type AclResponse struct {
	ApiStatus ApiStatus  `protobuf:"varint,1,opt,name=api_status,json=apiStatus,enum=types.ApiStatus" json:"api_status,omitempty"`
	Status    *AclStatus `protobuf:"bytes,2,opt,name=status" json:"status,omitempty"`
}

func (m *AclResponse) Reset()                    { *m = AclResponse{} }
func (m *AclResponse) String() string            { return proto.CompactTextString(m) }
func (*AclResponse) ProtoMessage()               {}
func (*AclResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *AclResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *AclResponse) GetStatus() *AclStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

// Batched responses to create/update acls
type AclResponseMsg struct {
	Response []*AclResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *AclResponseMsg) Reset()                    { *m = AclResponseMsg{} }
func (m *AclResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*AclResponseMsg) ProtoMessage()               {}
func (*AclResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *AclResponseMsg) GetResponse() []*AclResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

type AclDeleteRequest struct {
	Meta        *ObjectMeta   `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	KeyOrHandle *AclKeyHandle `protobuf:"bytes,2,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty"`
}

func (m *AclDeleteRequest) Reset()                    { *m = AclDeleteRequest{} }
func (m *AclDeleteRequest) String() string            { return proto.CompactTextString(m) }
func (*AclDeleteRequest) ProtoMessage()               {}
func (*AclDeleteRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *AclDeleteRequest) GetMeta() *ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *AclDeleteRequest) GetKeyOrHandle() *AclKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

// Batched requests to delete acls
type AclDeleteRequestMsg struct {
	Request []*AclDeleteRequest `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *AclDeleteRequestMsg) Reset()                    { *m = AclDeleteRequestMsg{} }
func (m *AclDeleteRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*AclDeleteRequestMsg) ProtoMessage()               {}
func (*AclDeleteRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

func (m *AclDeleteRequestMsg) GetRequest() []*AclDeleteRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

// AclDeleteResponseMsg is batched response to AclDeleteRequestMsg
type AclDeleteResponseMsg struct {
	ApiStatus []ApiStatus `protobuf:"varint,1,rep,packed,name=api_status,json=apiStatus,enum=types.ApiStatus" json:"api_status,omitempty"`
}

func (m *AclDeleteResponseMsg) Reset()                    { *m = AclDeleteResponseMsg{} }
func (m *AclDeleteResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*AclDeleteResponseMsg) ProtoMessage()               {}
func (*AclDeleteResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

func (m *AclDeleteResponseMsg) GetApiStatus() []ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return nil
}

// AclGetRequest is used to get information about a acl
type AclGetRequest struct {
	Meta        *ObjectMeta   `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	KeyOrHandle *AclKeyHandle `protobuf:"bytes,2,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty"`
}

func (m *AclGetRequest) Reset()                    { *m = AclGetRequest{} }
func (m *AclGetRequest) String() string            { return proto.CompactTextString(m) }
func (*AclGetRequest) ProtoMessage()               {}
func (*AclGetRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

func (m *AclGetRequest) GetMeta() *ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *AclGetRequest) GetKeyOrHandle() *AclKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

type AclGetRequestMsg struct {
	Request []*AclGetRequest `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *AclGetRequestMsg) Reset()                    { *m = AclGetRequestMsg{} }
func (m *AclGetRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*AclGetRequestMsg) ProtoMessage()               {}
func (*AclGetRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{18} }

func (m *AclGetRequestMsg) GetRequest() []*AclGetRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

// AclStats captures all the statistics of a acl
type AclStats struct {
}

func (m *AclStats) Reset()                    { *m = AclStats{} }
func (m *AclStats) String() string            { return proto.CompactTextString(m) }
func (*AclStats) ProtoMessage()               {}
func (*AclStats) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{19} }

// AclGetResponse captures all the information about a acl
type AclGetResponse struct {
	Spec   *AclSpec   `protobuf:"bytes,1,opt,name=spec" json:"spec,omitempty"`
	Status *AclStatus `protobuf:"bytes,2,opt,name=status" json:"status,omitempty"`
	Stats  *AclStats  `protobuf:"bytes,3,opt,name=stats" json:"stats,omitempty"`
}

func (m *AclGetResponse) Reset()                    { *m = AclGetResponse{} }
func (m *AclGetResponse) String() string            { return proto.CompactTextString(m) }
func (*AclGetResponse) ProtoMessage()               {}
func (*AclGetResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{20} }

func (m *AclGetResponse) GetSpec() *AclSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *AclGetResponse) GetStatus() *AclStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *AclGetResponse) GetStats() *AclStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

// AclGetResponseMsg is response to AclGetRequestMsg
type AclGetResponseMsg struct {
	Response []*AclGetResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *AclGetResponseMsg) Reset()                    { *m = AclGetResponseMsg{} }
func (m *AclGetResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*AclGetResponseMsg) ProtoMessage()               {}
func (*AclGetResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{21} }

func (m *AclGetResponseMsg) GetResponse() []*AclGetResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

func init() {
	proto.RegisterType((*AclHandle)(nil), "acl.AclHandle")
	proto.RegisterType((*AclKeyHandle)(nil), "acl.AclKeyHandle")
	proto.RegisterType((*EthSelector)(nil), "acl.EthSelector")
	proto.RegisterType((*UDPSelector)(nil), "acl.UDPSelector")
	proto.RegisterType((*TCPSelector)(nil), "acl.TCPSelector")
	proto.RegisterType((*ICMPSelector)(nil), "acl.ICMPSelector")
	proto.RegisterType((*IPSelector)(nil), "acl.IPSelector")
	proto.RegisterType((*AclSelector)(nil), "acl.AclSelector")
	proto.RegisterType((*AclActionInfo)(nil), "acl.AclActionInfo")
	proto.RegisterType((*AclSpec)(nil), "acl.AclSpec")
	proto.RegisterType((*AclRequestMsg)(nil), "acl.AclRequestMsg")
	proto.RegisterType((*AclStatus)(nil), "acl.AclStatus")
	proto.RegisterType((*AclResponse)(nil), "acl.AclResponse")
	proto.RegisterType((*AclResponseMsg)(nil), "acl.AclResponseMsg")
	proto.RegisterType((*AclDeleteRequest)(nil), "acl.AclDeleteRequest")
	proto.RegisterType((*AclDeleteRequestMsg)(nil), "acl.AclDeleteRequestMsg")
	proto.RegisterType((*AclDeleteResponseMsg)(nil), "acl.AclDeleteResponseMsg")
	proto.RegisterType((*AclGetRequest)(nil), "acl.AclGetRequest")
	proto.RegisterType((*AclGetRequestMsg)(nil), "acl.AclGetRequestMsg")
	proto.RegisterType((*AclStats)(nil), "acl.AclStats")
	proto.RegisterType((*AclGetResponse)(nil), "acl.AclGetResponse")
	proto.RegisterType((*AclGetResponseMsg)(nil), "acl.AclGetResponseMsg")
	proto.RegisterEnum("acl.AclAction", AclAction_name, AclAction_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Acl service

type AclClient interface {
	// Acl related APIs
	AclCreate(ctx context.Context, in *AclRequestMsg, opts ...grpc.CallOption) (*AclResponseMsg, error)
	AclUpdate(ctx context.Context, in *AclRequestMsg, opts ...grpc.CallOption) (*AclResponseMsg, error)
	AclDelete(ctx context.Context, in *AclDeleteRequestMsg, opts ...grpc.CallOption) (*AclDeleteResponseMsg, error)
	AclGet(ctx context.Context, in *AclGetRequestMsg, opts ...grpc.CallOption) (*AclGetResponseMsg, error)
}

type aclClient struct {
	cc *grpc.ClientConn
}

func NewAclClient(cc *grpc.ClientConn) AclClient {
	return &aclClient{cc}
}

func (c *aclClient) AclCreate(ctx context.Context, in *AclRequestMsg, opts ...grpc.CallOption) (*AclResponseMsg, error) {
	out := new(AclResponseMsg)
	err := grpc.Invoke(ctx, "/acl.Acl/AclCreate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aclClient) AclUpdate(ctx context.Context, in *AclRequestMsg, opts ...grpc.CallOption) (*AclResponseMsg, error) {
	out := new(AclResponseMsg)
	err := grpc.Invoke(ctx, "/acl.Acl/AclUpdate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aclClient) AclDelete(ctx context.Context, in *AclDeleteRequestMsg, opts ...grpc.CallOption) (*AclDeleteResponseMsg, error) {
	out := new(AclDeleteResponseMsg)
	err := grpc.Invoke(ctx, "/acl.Acl/AclDelete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aclClient) AclGet(ctx context.Context, in *AclGetRequestMsg, opts ...grpc.CallOption) (*AclGetResponseMsg, error) {
	out := new(AclGetResponseMsg)
	err := grpc.Invoke(ctx, "/acl.Acl/AclGet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Acl service

type AclServer interface {
	// Acl related APIs
	AclCreate(context.Context, *AclRequestMsg) (*AclResponseMsg, error)
	AclUpdate(context.Context, *AclRequestMsg) (*AclResponseMsg, error)
	AclDelete(context.Context, *AclDeleteRequestMsg) (*AclDeleteResponseMsg, error)
	AclGet(context.Context, *AclGetRequestMsg) (*AclGetResponseMsg, error)
}

func RegisterAclServer(s *grpc.Server, srv AclServer) {
	s.RegisterService(&_Acl_serviceDesc, srv)
}

func _Acl_AclCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AclRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AclServer).AclCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/acl.Acl/AclCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AclServer).AclCreate(ctx, req.(*AclRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Acl_AclUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AclRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AclServer).AclUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/acl.Acl/AclUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AclServer).AclUpdate(ctx, req.(*AclRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Acl_AclDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AclDeleteRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AclServer).AclDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/acl.Acl/AclDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AclServer).AclDelete(ctx, req.(*AclDeleteRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Acl_AclGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AclGetRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AclServer).AclGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/acl.Acl/AclGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AclServer).AclGet(ctx, req.(*AclGetRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

var _Acl_serviceDesc = grpc.ServiceDesc{
	ServiceName: "acl.Acl",
	HandlerType: (*AclServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AclCreate",
			Handler:    _Acl_AclCreate_Handler,
		},
		{
			MethodName: "AclUpdate",
			Handler:    _Acl_AclUpdate_Handler,
		},
		{
			MethodName: "AclDelete",
			Handler:    _Acl_AclDelete_Handler,
		},
		{
			MethodName: "AclGet",
			Handler:    _Acl_AclGet_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "acl.proto",
}

func init() { proto.RegisterFile("acl.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 1246 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x56, 0xcd, 0x72, 0x1b, 0x45,
	0x17, 0xb5, 0x24, 0x4b, 0x96, 0xef, 0x48, 0xb6, 0xdc, 0xfe, 0x9c, 0x38, 0xfe, 0x8a, 0x2a, 0xd7,
	0xa4, 0x48, 0xa5, 0x52, 0x44, 0x29, 0x44, 0x02, 0x84, 0x05, 0x44, 0x96, 0x9d, 0x48, 0x85, 0x65,
	0xab, 0xda, 0xce, 0x02, 0x36, 0xc3, 0xa4, 0xa7, 0x25, 0x0d, 0x1a, 0xcd, 0x0c, 0xdd, 0xed, 0x2a,
	0xb4, 0xe2, 0x4d, 0xd8, 0xf1, 0x18, 0x3c, 0x05, 0x0b, 0x36, 0x3c, 0x06, 0x0f, 0x40, 0xf5, 0xcf,
	0xcc, 0xb4, 0x26, 0x4e, 0x11, 0x16, 0xb0, 0xd2, 0x74, 0x9f, 0x7b, 0x6e, 0xdf, 0x9f, 0x73, 0xbb,
	0x05, 0xdb, 0x3e, 0x89, 0xba, 0x29, 0x4b, 0x44, 0x82, 0x6a, 0x3e, 0x89, 0x8e, 0x1c, 0xb1, 0x4a,
	0x29, 0xd7, 0x3b, 0x47, 0xbb, 0x61, 0x2c, 0x28, 0x9b, 0xfa, 0x84, 0x66, 0x1b, 0x51, 0x8f, 0xd3,
	0xd9, 0x92, 0xc6, 0x42, 0x6f, 0xb8, 0xf7, 0x61, 0xbb, 0x4f, 0xa2, 0xa1, 0x1f, 0x07, 0x11, 0x45,
	0x77, 0xa0, 0x31, 0x57, 0x5f, 0x87, 0x95, 0xe3, 0xca, 0xc3, 0x06, 0x36, 0x2b, 0x37, 0x84, 0x56,
	0x9f, 0x44, 0x5f, 0xd3, 0x95, 0xb1, 0xbb, 0x0b, 0x0d, 0x9f, 0x44, 0x5e, 0x18, 0x28, 0xbb, 0xad,
	0xe1, 0x06, 0xae, 0xfb, 0x24, 0x1a, 0x05, 0xe8, 0x09, 0x80, 0x04, 0x8c, 0x93, 0xea, 0x71, 0xe5,
	0xa1, 0xd3, 0xdb, 0xe9, 0xca, 0x08, 0xf3, 0x43, 0x86, 0x1b, 0x58, 0x86, 0xac, 0x17, 0x27, 0xbb,
	0xd0, 0x5e, 0xd0, 0x95, 0x97, 0x30, 0xc3, 0x71, 0x7f, 0xae, 0x80, 0x73, 0x26, 0xe6, 0x57, 0x34,
	0xa2, 0x44, 0x24, 0x0c, 0xdd, 0x83, 0x26, 0x15, 0x73, 0x4f, 0x26, 0xa5, 0x0e, 0x6b, 0xe3, 0x2d,
	0x2a, 0xe6, 0xd7, 0xab, 0x54, 0x46, 0xb1, 0xc5, 0x19, 0xf1, 0x96, 0x3e, 0x51, 0x27, 0x6d, 0xe2,
	0x06, 0x67, 0x64, 0xec, 0x13, 0x74, 0x0c, 0x2d, 0x03, 0x78, 0x4b, 0x9f, 0x2f, 0x0e, 0x6b, 0x0a,
	0x05, 0x8d, 0x8e, 0x7d, 0xbe, 0x90, 0xd4, 0x80, 0x0b, 0x45, 0xdd, 0xd4, 0xd4, 0x80, 0x0b, 0x43,
	0x35, 0x80, 0xa6, 0xd6, 0x35, 0x55, 0xa3, 0x92, 0xea, 0xbe, 0x00, 0xe7, 0xf5, 0xe9, 0x24, 0x8f,
	0xef, 0x63, 0x80, 0x34, 0x61, 0xc2, 0x63, 0x7e, 0x3c, 0xd3, 0x11, 0x3a, 0x3d, 0xd4, 0xd5, 0x3d,
	0x38, 0x7f, 0x3a, 0x49, 0x98, 0xc0, 0x12, 0xc1, 0xdb, 0x69, 0xf6, 0xe9, 0xfe, 0x5a, 0x01, 0xe7,
	0x7a, 0x50, 0xb8, 0xb8, 0x0b, 0x5b, 0x82, 0xa4, 0x1e, 0x5f, 0xc5, 0x8a, 0xdf, 0xc4, 0x0d, 0x41,
	0xd2, 0xab, 0x55, 0x9c, 0x01, 0x3e, 0x59, 0xa8, 0x04, 0x35, 0xd0, 0x27, 0x8b, 0x0c, 0x98, 0x86,
	0xb1, 0xca, 0x4d, 0x03, 0x2f, 0xc3, 0x9c, 0xc1, 0xb8, 0x50, 0x79, 0x69, 0x00, 0x73, 0x91, 0x01,
	0x37, 0x6c, 0xa6, 0x52, 0xd2, 0xc0, 0x6b, 0x36, 0x2b, 0xc5, 0xdf, 0x78, 0x9f, 0xf8, 0x87, 0xd0,
	0x1a, 0x0d, 0xc6, 0x45, 0xfc, 0xff, 0x87, 0xed, 0x90, 0x2c, 0x53, 0x8f, 0x24, 0x41, 0xd6, 0xa3,
	0xa6, 0xdc, 0x18, 0x24, 0x01, 0xcd, 0x41, 0xd5, 0xc0, 0x6a, 0x01, 0xca, 0x0e, 0xba, 0xbf, 0x55,
	0x01, 0x46, 0x85, 0xa3, 0x2e, 0xc8, 0x1e, 0x79, 0x29, 0xa3, 0xd3, 0xf0, 0x47, 0x53, 0xcb, 0x5d,
	0x13, 0xcb, 0x68, 0x32, 0x51, 0xdb, 0x78, 0x9b, 0x33, 0xa2, 0x3f, 0xa5, 0xbd, 0x6c, 0x96, 0xb1,
	0xaf, 0xbe, 0xc3, 0x3e, 0xe0, 0xc2, 0xd8, 0x3f, 0x86, 0xa6, 0x12, 0x3d, 0x49, 0x22, 0x55, 0xb7,
	0x9d, 0xde, 0x9e, 0x65, 0xad, 0x01, 0x9c, 0x9b, 0xa0, 0xcf, 0xa1, 0xad, 0x42, 0xe7, 0x26, 0x3e,
	0x55, 0x52, 0xa7, 0xb7, 0xa7, 0xf4, 0x6c, 0x57, 0x60, 0xb8, 0x81, 0x5b, 0xd2, 0x32, 0x4f, 0xe4,
	0x19, 0xb4, 0x6e, 0x02, 0x8b, 0x58, 0x57, 0xc4, 0x8e, 0x22, 0x5a, 0xe2, 0x19, 0x6e, 0x60, 0xe7,
	0x26, 0x58, 0xa3, 0x29, 0x21, 0x64, 0xb4, 0x86, 0x45, 0xb3, 0x04, 0x23, 0x69, 0x52, 0x21, 0x66,
	0x79, 0xb2, 0x03, 0xad, 0xe8, 0x69, 0xce, 0xe2, 0xee, 0x1f, 0x55, 0x70, 0xfa, 0x24, 0xca, 0xdd,
	0x7e, 0x05, 0x48, 0x96, 0x35, 0x0a, 0xa7, 0x9e, 0x9c, 0x35, 0x6b, 0xc2, 0x65, 0xab, 0xc3, 0x58,
	0x4c, 0xbb, 0xe7, 0xe1, 0x34, 0x9f, 0x6e, 0xbc, 0xcb, 0x19, 0xb1, 0x37, 0xa4, 0x03, 0x59, 0xe7,
	0x92, 0x83, 0xea, 0xbb, 0x1d, 0x04, 0x5c, 0xac, 0x39, 0x98, 0xc0, 0x41, 0xd4, 0xf3, 0xcc, 0xc5,
	0x63, 0xfb, 0xa8, 0x29, 0x1f, 0x1f, 0x74, 0x8b, 0x5b, 0xe9, 0xbc, 0x77, 0xa5, 0xbf, 0x0a, 0x77,
	0x28, 0x7a, 0x6b, 0x4f, 0x96, 0x4a, 0x5e, 0x0b, 0xa5, 0xd6, 0xe8, 0x52, 0x59, 0xd7, 0x87, 0x2c,
	0x15, 0xb5, 0x6e, 0x93, 0x1e, 0x38, 0xe1, 0x5b, 0x7d, 0xd9, 0xd5, 0x0d, 0xb5, 0xeb, 0x0b, 0xe1,
	0x5a, 0x79, 0xd3, 0x85, 0xc8, 0x49, 0xee, 0x2f, 0x55, 0x68, 0xf7, 0x49, 0xd4, 0x27, 0x22, 0x4c,
	0xe2, 0x51, 0x3c, 0x4d, 0xd0, 0x03, 0x79, 0x1d, 0xca, 0x95, 0x2a, 0xea, 0x4e, 0x71, 0xe3, 0x69,
	0x1b, 0x6c, 0x50, 0xe4, 0x42, 0x3b, 0x8c, 0x67, 0xde, 0x32, 0x64, 0x2c, 0x61, 0x1e, 0x8d, 0xcd,
	0x54, 0x3b, 0x61, 0x3c, 0x1b, 0xab, 0xbd, 0xb3, 0x18, 0x3d, 0x87, 0x7b, 0x96, 0x0d, 0xa7, 0x9c,
	0x87, 0x49, 0x6c, 0x97, 0xab, 0x81, 0xef, 0xe4, 0xf6, 0x57, 0x1a, 0x36, 0x35, 0x71, 0xa1, 0x4d,
	0x67, 0xcc, 0x72, 0xaf, 0xaf, 0x00, 0x87, 0xce, 0x98, 0xed, 0xde, 0xb2, 0x29, 0xb9, 0xaf, 0x6b,
	0xf7, 0xb9, 0xfd, 0xba, 0xfb, 0x2e, 0xec, 0x93, 0x24, 0x4d, 0xbd, 0x34, 0x89, 0x42, 0x42, 0xb3,
	0x0b, 0x5b, 0x89, 0xb4, 0x81, 0xf7, 0x24, 0x34, 0xd1, 0x88, 0xb6, 0x77, 0x7f, 0xaf, 0xc0, 0x96,
	0x94, 0x61, 0x4a, 0x09, 0xfa, 0x10, 0x36, 0x97, 0x54, 0xf8, 0x46, 0x74, 0xd9, 0xd4, 0x5d, 0xbe,
	0xf9, 0x9e, 0x12, 0x31, 0xa6, 0xc2, 0xc7, 0x0a, 0x46, 0xcf, 0x4a, 0xaf, 0x81, 0xd1, 0xd8, 0x5e,
	0x56, 0xcf, 0x42, 0x13, 0xce, 0x82, 0xae, 0x2e, 0xcd, 0x49, 0xe8, 0x48, 0xce, 0x75, 0x98, 0xb0,
	0x50, 0xac, 0x54, 0x89, 0xda, 0x38, 0x5f, 0xa3, 0x07, 0x50, 0x5f, 0xfa, 0x82, 0xcc, 0xd7, 0x14,
	0x62, 0x4d, 0x07, 0xd6, 0x30, 0x7a, 0x94, 0xf7, 0xb0, 0x6e, 0x74, 0xbd, 0xd6, 0x43, 0xd9, 0xe7,
	0xac, 0x8f, 0xee, 0x67, 0x4a, 0x00, 0x98, 0xfe, 0x70, 0x43, 0xb9, 0x18, 0xf3, 0x19, 0x7a, 0x00,
	0x5b, 0x4c, 0xaf, 0x0e, 0x2b, 0xc7, 0xb5, 0x87, 0x4e, 0xaf, 0x95, 0x1f, 0x93, 0x52, 0x82, 0x33,
	0xd0, 0xfd, 0x42, 0x3d, 0xb6, 0x57, 0xc2, 0x17, 0x37, 0x1c, 0x3d, 0x5e, 0x7b, 0x2b, 0x2b, 0xb7,
	0xbd, 0x95, 0xd6, 0x4b, 0xe9, 0x4e, 0xd5, 0x50, 0x63, 0xca, 0xd3, 0x24, 0xe6, 0x54, 0xbd, 0xb4,
	0x69, 0xe8, 0x71, 0xe5, 0xcb, 0xe8, 0xae, 0x63, 0xea, 0xda, 0x4f, 0x43, 0x7d, 0x06, 0xde, 0xf6,
	0xb3, 0x4f, 0x29, 0x52, 0x63, 0x5c, 0x7a, 0x96, 0x8d, 0xa9, 0x41, 0xdd, 0x2f, 0x61, 0xc7, 0x3a,
	0x47, 0x66, 0xf7, 0x11, 0x34, 0x99, 0x59, 0x9a, 0xf4, 0xf2, 0x2a, 0x66, 0x66, 0x38, 0xb7, 0x70,
	0x53, 0xe8, 0xf4, 0x49, 0x74, 0x4a, 0x23, 0x2a, 0xa8, 0x29, 0xd1, 0xbf, 0xdb, 0x7e, 0xf7, 0x25,
	0xec, 0x97, 0x4f, 0x94, 0x61, 0x3f, 0x29, 0x37, 0xe5, 0x20, 0xf3, 0xb3, 0x66, 0x5a, 0x74, 0xe7,
	0x15, 0xfc, 0xcf, 0x02, 0x8b, 0xfc, 0xcb, 0xa5, 0xae, 0xfd, 0x4d, 0xa9, 0xdd, 0xa5, 0xd2, 0xc7,
	0x2b, 0x2a, 0xfe, 0x9b, 0xfc, 0x5f, 0xa8, 0x8a, 0x17, 0xc7, 0xe9, 0x9e, 0x95, 0x92, 0xcf, 0xf5,
	0x5c, 0xd8, 0x15, 0x99, 0x03, 0x34, 0x8d, 0x10, 0xb8, 0xfb, 0x93, 0xea, 0xbf, 0xb2, 0x32, 0x52,
	0x3b, 0x86, 0x4d, 0x9e, 0x52, 0x62, 0xa2, 0x5f, 0x97, 0xb6, 0x42, 0xde, 0x57, 0x5b, 0xe8, 0x3e,
	0xd4, 0xe5, 0x17, 0x37, 0xf7, 0x7e, 0xdb, 0x36, 0xe3, 0x58, 0x63, 0xee, 0x29, 0xec, 0xad, 0x07,
	0xa0, 0x7b, 0x50, 0xd6, 0xe0, 0xfe, 0x5a, 0x42, 0x65, 0x19, 0x3e, 0xfa, 0x4e, 0x8d, 0x9a, 0x1e,
	0x5e, 0xb4, 0x0f, 0xbb, 0xfd, 0xc1, 0xb9, 0xd7, 0x1f, 0x5c, 0x8f, 0x2e, 0x2f, 0xbc, 0x8b, 0xcb,
	0x8b, 0xb3, 0xce, 0x06, 0x3a, 0x80, 0x3d, 0x6b, 0x73, 0x72, 0x86, 0xc7, 0xa3, 0xeb, 0x4e, 0x05,
	0x21, 0xd8, 0xb1, 0xb6, 0xcf, 0x2f, 0x5f, 0x75, 0xaa, 0x25, 0xfe, 0xe9, 0xd9, 0xc5, 0x37, 0x9d,
	0x5a, 0xef, 0xcf, 0x0a, 0xd4, 0xfa, 0x24, 0x42, 0x9f, 0xaa, 0x93, 0x06, 0x8c, 0xfa, 0x82, 0x22,
	0x54, 0x4c, 0x46, 0xd6, 0x8b, 0xa3, 0xfd, 0xf2, 0xb4, 0x8c, 0xf9, 0xcc, 0xdd, 0x30, 0xbc, 0xd7,
	0x69, 0xf0, 0x0f, 0x79, 0x27, 0x8a, 0xa7, 0x65, 0x8a, 0x0e, 0x6f, 0xd5, 0xb4, 0x64, 0xdf, 0x2b,
	0x23, 0xb6, 0x8f, 0xe7, 0xd0, 0xd0, 0x95, 0x43, 0x07, 0x6f, 0xeb, 0x42, 0xb2, 0xef, 0xdc, 0x52,
	0x5d, 0x45, 0x3d, 0x81, 0x6f, 0x9b, 0x73, 0x3f, 0x52, 0x7f, 0x92, 0xde, 0x34, 0xd4, 0xcf, 0x27,
	0x7f, 0x05, 0x00, 0x00, 0xff, 0xff, 0x9d, 0x41, 0xc6, 0x73, 0x84, 0x0c, 0x00, 0x00,
}
