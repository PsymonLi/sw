// Code generated by protoc-gen-go.
// source: endpoint.proto
// DO NOT EDIT!

/*
Package halproto is a generated protocol buffer package.

It is generated from these files:
	endpoint.proto
	interface.proto
	l2segment.proto
	l4lb.proto
	nwsec.proto
	session.proto
	tenant.proto

It has these top-level messages:
	EndpointSpec
	EndpointRequestMsg
	EndpointStatus
	EndpointResponse
	EndpointResponseMsg
	EndpointL2Key
	EndpointL3Key
	EndpointKey
	EndpointKeyHandle
	EndpointFilter
	EndpointDeleteRequest
	EndpointDeleteRequestMsg
	EndpointDeleteResponseMsg
	EndpointGetRequest
	EndpointGetRequestMsg
	EndpointGetByInterfaceRequestMsg
	EndpointGetAllRequestMsg
	EndpointStats
	EndpointGetResponse
	EndpointGetResponseMsg
	LifQueueInfo
	LifKeyHandle
	LifSpec
	LifRequestMsg
	LifStatus
	LifResponse
	LifResponseMsg
	LifDeleteRequest
	LifDeleteRequestMsg
	LifDeleteResponseMsg
	LifStats
	LifGetRequest
	LifGetRequestMsg
	LifGetResponse
	LifGetResponseMsg
	IfEnicUsegInfo
	IfEnicPVLANInfo
	IfEnicDirectInfo
	IfEnicInfo
	IfUplinkInfo
	IfUplinkPCInfo
	InterfaceKeyHandle
	InterfaceSpec
	InterfaceRequestMsg
	InterfaceStatus
	InterfaceResponse
	InterfaceResponseMsg
	InterfaceDeleteRequest
	InterfaceDeleteRequestMsg
	InterfaceDeleteResponseMsg
	InterfaceStats
	InterfaceGetRequest
	InterfaceGetRequestMsg
	InterfaceGetResponse
	InterfaceGetResponseMsg
	L2SegmentKeyHandle
	L2SegmentSpec
	L2SegmentRequestMsg
	L2SegmentStatus
	L2SegmentResponse
	L2SegmentResponseMsg
	L2SegmentDeleteRequest
	L2SegmentDeleteRequestMsg
	L2SegmentDeleteResponseMsg
	L2SegmentGetRequest
	L2SegmentGetRequestMsg
	L2SegmentStats
	L2SegmentGetResponse
	L2SegmentGetResponseMsg
	LBMethod
	HealthCheck
	L4LbServiceKey
	L4LbServiceKeyHandle
	L4LbServiceSpec
	L4LbServiceRequestMsg
	L4LbServiceStatus
	L4LbServiceResponse
	L4LbServiceResponseMsg
	L4LbServiceDeleteRequest
	L4LbServiceDeleteRequestMsg
	L4LbServiceDeleteResponseMsg
	L4LbServiceStats
	L4LbBackendKey
	L4LbBackendKeyHandle
	L4LbBackendSpec
	L4LbBackendRequestMsg
	L4LbBackendStatus
	L4LbBackendResponse
	L4LbBackendResponseMsg
	L4LbBackendDeleteRequest
	L4LbBackendDeleteRequestMsg
	L4LbBackendDeleteResponseMsg
	L4LbBackendStats
	L4LbBackendGetRequest
	L4LbBackendGetRequestMsg
	L4LbBackendGetResponse
	L4LbBackendGetResponseMsg
	L4LbServiceGetRequest
	L4LbServiceGetRequestMsg
	L4LbServiceGetResponse
	L4LbServiceGetResponseMsg
	SecurityProfileKeyHandle
	SecurityProfileSpec
	SecurityProfileRequestMsg
	SecurityProfileStatus
	SecurityProfileResponse
	SecurityProfileResponseMsg
	SecurityProfileDeleteRequest
	SecurityProfileDeleteRequestMsg
	SecurityProfileDeleteResponseMsg
	SecurityProfileGetRequest
	SecurityProfileGetRequestMsg
	SecurityProfileStats
	SecurityProfileGetResponse
	SecurityProfileGetResponseMsg
	SecurityGroupSpec
	SecurityGroupMsg
	SecurityGroupStatus
	SecurityGroupResponse
	SecurityGroupResponseMsg
	Service
	SecurityPolicyRuleSpec
	SecurityPolicyRuleMsg
	SecurityPolicyRuleStatus
	SecurityPolicyRuleResponse
	SecurityPolicyRuleResponseMsg
	FlowKeyL2
	FlowKeyTcpUdpInfo
	FlowKeyICMPInfo
	FlowKeyV4
	FlowKeyV6
	FlowKey
	FlowInfo
	ConnTrackInfo
	FlowData
	FlowSpec
	SessionSpec
	SessionRequestMsg
	FlowStatus
	SessionStatus
	SessionResponse
	SessionResponseMsg
	SessionDeleteRequest
	SessionDeleteRequestMsg
	SessionDeleteResponseMsg
	SessionGetRequest
	SessionGetRequestMsg
	FlowStats
	SessionStats
	SessionGetResponse
	SessionGetResponseMsg
	TenantKeyHandle
	TenantSpec
	TenantRequestMsg
	TenantStatus
	TenantResponse
	TenantResponseMsg
	TenantDeleteRequest
	TenantDeleteRequestMsg
	TenantDeleteResponseMsg
	TenantGetRequest
	TenantGetRequestMsg
	TenantStats
	TenantGetResponse
	TenantGetResponseMsg
*/
package halproto

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import types "github.com/pensando/sw/agent/netagent/datapath/halproto/types"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// EndpointSpec is used to add or update an endpoint
type EndpointSpec struct {
	Meta            *types.ObjectMeta  `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	L2SegmentHandle uint64             `protobuf:"fixed64,2,opt,name=l2_segment_handle,json=l2SegmentHandle" json:"l2_segment_handle,omitempty"`
	MacAddress      uint64             `protobuf:"varint,3,opt,name=mac_address,json=macAddress" json:"mac_address,omitempty"`
	InterfaceHandle uint64             `protobuf:"fixed64,4,opt,name=interface_handle,json=interfaceHandle" json:"interface_handle,omitempty"`
	UsegVlan        uint32             `protobuf:"varint,5,opt,name=useg_vlan,json=usegVlan" json:"useg_vlan,omitempty"`
	IpAddress       []*types.IPAddress `protobuf:"bytes,6,rep,name=ip_address,json=ipAddress" json:"ip_address,omitempty"`
	SecurityGroup   []uint32           `protobuf:"varint,7,rep,packed,name=security_group,json=securityGroup" json:"security_group,omitempty"`
}

func (m *EndpointSpec) Reset()                    { *m = EndpointSpec{} }
func (m *EndpointSpec) String() string            { return proto.CompactTextString(m) }
func (*EndpointSpec) ProtoMessage()               {}
func (*EndpointSpec) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *EndpointSpec) GetMeta() *types.ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *EndpointSpec) GetL2SegmentHandle() uint64 {
	if m != nil {
		return m.L2SegmentHandle
	}
	return 0
}

func (m *EndpointSpec) GetMacAddress() uint64 {
	if m != nil {
		return m.MacAddress
	}
	return 0
}

func (m *EndpointSpec) GetInterfaceHandle() uint64 {
	if m != nil {
		return m.InterfaceHandle
	}
	return 0
}

func (m *EndpointSpec) GetUsegVlan() uint32 {
	if m != nil {
		return m.UsegVlan
	}
	return 0
}

func (m *EndpointSpec) GetIpAddress() []*types.IPAddress {
	if m != nil {
		return m.IpAddress
	}
	return nil
}

func (m *EndpointSpec) GetSecurityGroup() []uint32 {
	if m != nil {
		return m.SecurityGroup
	}
	return nil
}

// EndpointRequestMsg is batched add or modify endpoint request
type EndpointRequestMsg struct {
	Request []*EndpointSpec `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *EndpointRequestMsg) Reset()                    { *m = EndpointRequestMsg{} }
func (m *EndpointRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*EndpointRequestMsg) ProtoMessage()               {}
func (*EndpointRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *EndpointRequestMsg) GetRequest() []*EndpointSpec {
	if m != nil {
		return m.Request
	}
	return nil
}

// EndpointStatus has the current status of an endpoint
// TODO: capturing aging information, if any
type EndpointStatus struct {
	EndpointHandle    uint64             `protobuf:"fixed64,1,opt,name=endpoint_handle,json=endpointHandle" json:"endpoint_handle,omitempty"`
	IpAddress         []*types.IPAddress `protobuf:"bytes,2,rep,name=ip_address,json=ipAddress" json:"ip_address,omitempty"`
	LearnSourceDhcp   bool               `protobuf:"varint,3,opt,name=learn_source_dhcp,json=learnSourceDhcp" json:"learn_source_dhcp,omitempty"`
	LearnSourceArp    bool               `protobuf:"varint,4,opt,name=learn_source_arp,json=learnSourceArp" json:"learn_source_arp,omitempty"`
	LearnSourceRarp   bool               `protobuf:"varint,5,opt,name=learn_source_rarp,json=learnSourceRarp" json:"learn_source_rarp,omitempty"`
	LearnSourceConfig bool               `protobuf:"varint,6,opt,name=learn_source_config,json=learnSourceConfig" json:"learn_source_config,omitempty"`
	IsEndpointLocal   bool               `protobuf:"varint,7,opt,name=is_endpoint_local,json=isEndpointLocal" json:"is_endpoint_local,omitempty"`
}

func (m *EndpointStatus) Reset()                    { *m = EndpointStatus{} }
func (m *EndpointStatus) String() string            { return proto.CompactTextString(m) }
func (*EndpointStatus) ProtoMessage()               {}
func (*EndpointStatus) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *EndpointStatus) GetEndpointHandle() uint64 {
	if m != nil {
		return m.EndpointHandle
	}
	return 0
}

func (m *EndpointStatus) GetIpAddress() []*types.IPAddress {
	if m != nil {
		return m.IpAddress
	}
	return nil
}

func (m *EndpointStatus) GetLearnSourceDhcp() bool {
	if m != nil {
		return m.LearnSourceDhcp
	}
	return false
}

func (m *EndpointStatus) GetLearnSourceArp() bool {
	if m != nil {
		return m.LearnSourceArp
	}
	return false
}

func (m *EndpointStatus) GetLearnSourceRarp() bool {
	if m != nil {
		return m.LearnSourceRarp
	}
	return false
}

func (m *EndpointStatus) GetLearnSourceConfig() bool {
	if m != nil {
		return m.LearnSourceConfig
	}
	return false
}

func (m *EndpointStatus) GetIsEndpointLocal() bool {
	if m != nil {
		return m.IsEndpointLocal
	}
	return false
}

// EndpointResponse is response to EndpointSpec
type EndpointResponse struct {
	ApiStatus      types.ApiStatus `protobuf:"varint,1,opt,name=api_status,json=apiStatus,enum=types.ApiStatus" json:"api_status,omitempty"`
	EndpointStatus *EndpointStatus `protobuf:"bytes,2,opt,name=endpoint_status,json=endpointStatus" json:"endpoint_status,omitempty"`
}

func (m *EndpointResponse) Reset()                    { *m = EndpointResponse{} }
func (m *EndpointResponse) String() string            { return proto.CompactTextString(m) }
func (*EndpointResponse) ProtoMessage()               {}
func (*EndpointResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *EndpointResponse) GetApiStatus() types.ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return types.ApiStatus_API_STATUS_OK
}

func (m *EndpointResponse) GetEndpointStatus() *EndpointStatus {
	if m != nil {
		return m.EndpointStatus
	}
	return nil
}

// EndpointResponseMsg is batched response to EndpointRequestMsg
type EndpointResponseMsg struct {
	Response []*EndpointResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *EndpointResponseMsg) Reset()                    { *m = EndpointResponseMsg{} }
func (m *EndpointResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*EndpointResponseMsg) ProtoMessage()               {}
func (*EndpointResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *EndpointResponseMsg) GetResponse() []*EndpointResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

// EndpointL2Key is L2 key of the endpoint
// NOTE: An endpoint can have only one L2 key
type EndpointL2Key struct {
	L2SegmentHandle uint64 `protobuf:"fixed64,1,opt,name=l2_segment_handle,json=l2SegmentHandle" json:"l2_segment_handle,omitempty"`
	MacAddress      uint64 `protobuf:"varint,2,opt,name=mac_address,json=macAddress" json:"mac_address,omitempty"`
}

func (m *EndpointL2Key) Reset()                    { *m = EndpointL2Key{} }
func (m *EndpointL2Key) String() string            { return proto.CompactTextString(m) }
func (*EndpointL2Key) ProtoMessage()               {}
func (*EndpointL2Key) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *EndpointL2Key) GetL2SegmentHandle() uint64 {
	if m != nil {
		return m.L2SegmentHandle
	}
	return 0
}

func (m *EndpointL2Key) GetMacAddress() uint64 {
	if m != nil {
		return m.MacAddress
	}
	return 0
}

// EndpointL3Key is the L3 key of the endpoint
// NOTE: An endpoint can have many L3 keys
type EndpointL3Key struct {
	IpAddress *types.IPAddress `protobuf:"bytes,1,opt,name=ip_address,json=ipAddress" json:"ip_address,omitempty"`
}

func (m *EndpointL3Key) Reset()                    { *m = EndpointL3Key{} }
func (m *EndpointL3Key) String() string            { return proto.CompactTextString(m) }
func (*EndpointL3Key) ProtoMessage()               {}
func (*EndpointL3Key) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *EndpointL3Key) GetIpAddress() *types.IPAddress {
	if m != nil {
		return m.IpAddress
	}
	return nil
}

// Endpoint can be uniquely identified by its L2 or one of its L3 keys
type EndpointKey struct {
	// Types that are valid to be assigned to EndpointL2L3Key:
	//	*EndpointKey_L2Key
	//	*EndpointKey_L3Key
	EndpointL2L3Key isEndpointKey_EndpointL2L3Key `protobuf_oneof:"endpoint_l2_l3_key"`
}

func (m *EndpointKey) Reset()                    { *m = EndpointKey{} }
func (m *EndpointKey) String() string            { return proto.CompactTextString(m) }
func (*EndpointKey) ProtoMessage()               {}
func (*EndpointKey) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

type isEndpointKey_EndpointL2L3Key interface {
	isEndpointKey_EndpointL2L3Key()
}

type EndpointKey_L2Key struct {
	L2Key *EndpointL2Key `protobuf:"bytes,1,opt,name=l2_key,json=l2Key,oneof"`
}
type EndpointKey_L3Key struct {
	L3Key *EndpointL3Key `protobuf:"bytes,2,opt,name=l3_key,json=l3Key,oneof"`
}

func (*EndpointKey_L2Key) isEndpointKey_EndpointL2L3Key() {}
func (*EndpointKey_L3Key) isEndpointKey_EndpointL2L3Key() {}

func (m *EndpointKey) GetEndpointL2L3Key() isEndpointKey_EndpointL2L3Key {
	if m != nil {
		return m.EndpointL2L3Key
	}
	return nil
}

func (m *EndpointKey) GetL2Key() *EndpointL2Key {
	if x, ok := m.GetEndpointL2L3Key().(*EndpointKey_L2Key); ok {
		return x.L2Key
	}
	return nil
}

func (m *EndpointKey) GetL3Key() *EndpointL3Key {
	if x, ok := m.GetEndpointL2L3Key().(*EndpointKey_L3Key); ok {
		return x.L3Key
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*EndpointKey) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _EndpointKey_OneofMarshaler, _EndpointKey_OneofUnmarshaler, _EndpointKey_OneofSizer, []interface{}{
		(*EndpointKey_L2Key)(nil),
		(*EndpointKey_L3Key)(nil),
	}
}

func _EndpointKey_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*EndpointKey)
	// endpoint_l2_l3_key
	switch x := m.EndpointL2L3Key.(type) {
	case *EndpointKey_L2Key:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.L2Key); err != nil {
			return err
		}
	case *EndpointKey_L3Key:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.L3Key); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("EndpointKey.EndpointL2L3Key has unexpected type %T", x)
	}
	return nil
}

func _EndpointKey_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*EndpointKey)
	switch tag {
	case 1: // endpoint_l2_l3_key.l2_key
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(EndpointL2Key)
		err := b.DecodeMessage(msg)
		m.EndpointL2L3Key = &EndpointKey_L2Key{msg}
		return true, err
	case 2: // endpoint_l2_l3_key.l3_key
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(EndpointL3Key)
		err := b.DecodeMessage(msg)
		m.EndpointL2L3Key = &EndpointKey_L3Key{msg}
		return true, err
	default:
		return false, nil
	}
}

func _EndpointKey_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*EndpointKey)
	// endpoint_l2_l3_key
	switch x := m.EndpointL2L3Key.(type) {
	case *EndpointKey_L2Key:
		s := proto.Size(x.L2Key)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *EndpointKey_L3Key:
		s := proto.Size(x.L3Key)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Endpoint is accessible via its key or handle
type EndpointKeyHandle struct {
	// Types that are valid to be assigned to KeyOrHandle:
	//	*EndpointKeyHandle_EndpointKey
	//	*EndpointKeyHandle_EndpointHandle
	KeyOrHandle isEndpointKeyHandle_KeyOrHandle `protobuf_oneof:"key_or_handle"`
}

func (m *EndpointKeyHandle) Reset()                    { *m = EndpointKeyHandle{} }
func (m *EndpointKeyHandle) String() string            { return proto.CompactTextString(m) }
func (*EndpointKeyHandle) ProtoMessage()               {}
func (*EndpointKeyHandle) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

type isEndpointKeyHandle_KeyOrHandle interface {
	isEndpointKeyHandle_KeyOrHandle()
}

type EndpointKeyHandle_EndpointKey struct {
	EndpointKey *EndpointKey `protobuf:"bytes,1,opt,name=endpoint_key,json=endpointKey,oneof"`
}
type EndpointKeyHandle_EndpointHandle struct {
	EndpointHandle uint64 `protobuf:"fixed64,2,opt,name=endpoint_handle,json=endpointHandle,oneof"`
}

func (*EndpointKeyHandle_EndpointKey) isEndpointKeyHandle_KeyOrHandle()    {}
func (*EndpointKeyHandle_EndpointHandle) isEndpointKeyHandle_KeyOrHandle() {}

func (m *EndpointKeyHandle) GetKeyOrHandle() isEndpointKeyHandle_KeyOrHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

func (m *EndpointKeyHandle) GetEndpointKey() *EndpointKey {
	if x, ok := m.GetKeyOrHandle().(*EndpointKeyHandle_EndpointKey); ok {
		return x.EndpointKey
	}
	return nil
}

func (m *EndpointKeyHandle) GetEndpointHandle() uint64 {
	if x, ok := m.GetKeyOrHandle().(*EndpointKeyHandle_EndpointHandle); ok {
		return x.EndpointHandle
	}
	return 0
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*EndpointKeyHandle) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _EndpointKeyHandle_OneofMarshaler, _EndpointKeyHandle_OneofUnmarshaler, _EndpointKeyHandle_OneofSizer, []interface{}{
		(*EndpointKeyHandle_EndpointKey)(nil),
		(*EndpointKeyHandle_EndpointHandle)(nil),
	}
}

func _EndpointKeyHandle_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*EndpointKeyHandle)
	// key_or_handle
	switch x := m.KeyOrHandle.(type) {
	case *EndpointKeyHandle_EndpointKey:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.EndpointKey); err != nil {
			return err
		}
	case *EndpointKeyHandle_EndpointHandle:
		b.EncodeVarint(2<<3 | proto.WireFixed64)
		b.EncodeFixed64(uint64(x.EndpointHandle))
	case nil:
	default:
		return fmt.Errorf("EndpointKeyHandle.KeyOrHandle has unexpected type %T", x)
	}
	return nil
}

func _EndpointKeyHandle_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*EndpointKeyHandle)
	switch tag {
	case 1: // key_or_handle.endpoint_key
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(EndpointKey)
		err := b.DecodeMessage(msg)
		m.KeyOrHandle = &EndpointKeyHandle_EndpointKey{msg}
		return true, err
	case 2: // key_or_handle.endpoint_handle
		if wire != proto.WireFixed64 {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeFixed64()
		m.KeyOrHandle = &EndpointKeyHandle_EndpointHandle{x}
		return true, err
	default:
		return false, nil
	}
}

func _EndpointKeyHandle_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*EndpointKeyHandle)
	// key_or_handle
	switch x := m.KeyOrHandle.(type) {
	case *EndpointKeyHandle_EndpointKey:
		s := proto.Size(x.EndpointKey)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *EndpointKeyHandle_EndpointHandle:
		n += proto.SizeVarint(2<<3 | proto.WireFixed64)
		n += 8
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// EndpointFilter is attributes by which endpoints can be manipulated
// or queried. As the endpoint database can be huge, this is provided
// so that agent and HAL are less chatty when doing bulk deletes (e.g.
// when a L2 segment is deleted or interfae goes down etc.)
type EndpointFilter struct {
	L2SegmentHandle uint64 `protobuf:"fixed64,1,opt,name=l2_segment_handle,json=l2SegmentHandle" json:"l2_segment_handle,omitempty"`
	InterfaceHandle uint64 `protobuf:"fixed64,2,opt,name=interface_handle,json=interfaceHandle" json:"interface_handle,omitempty"`
}

func (m *EndpointFilter) Reset()                    { *m = EndpointFilter{} }
func (m *EndpointFilter) String() string            { return proto.CompactTextString(m) }
func (*EndpointFilter) ProtoMessage()               {}
func (*EndpointFilter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *EndpointFilter) GetL2SegmentHandle() uint64 {
	if m != nil {
		return m.L2SegmentHandle
	}
	return 0
}

func (m *EndpointFilter) GetInterfaceHandle() uint64 {
	if m != nil {
		return m.InterfaceHandle
	}
	return 0
}

// EndpointDeleteRequest is used to delete an endpoint
type EndpointDeleteRequest struct {
	Meta *types.ObjectMeta `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	// Types that are valid to be assigned to DeleteBy:
	//	*EndpointDeleteRequest_KeyOrHandle
	//	*EndpointDeleteRequest_Filter
	DeleteBy isEndpointDeleteRequest_DeleteBy `protobuf_oneof:"delete_by"`
}

func (m *EndpointDeleteRequest) Reset()                    { *m = EndpointDeleteRequest{} }
func (m *EndpointDeleteRequest) String() string            { return proto.CompactTextString(m) }
func (*EndpointDeleteRequest) ProtoMessage()               {}
func (*EndpointDeleteRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

type isEndpointDeleteRequest_DeleteBy interface {
	isEndpointDeleteRequest_DeleteBy()
}

type EndpointDeleteRequest_KeyOrHandle struct {
	KeyOrHandle *EndpointKeyHandle `protobuf:"bytes,2,opt,name=key_or_handle,json=keyOrHandle,oneof"`
}
type EndpointDeleteRequest_Filter struct {
	Filter *EndpointFilter `protobuf:"bytes,3,opt,name=filter,oneof"`
}

func (*EndpointDeleteRequest_KeyOrHandle) isEndpointDeleteRequest_DeleteBy() {}
func (*EndpointDeleteRequest_Filter) isEndpointDeleteRequest_DeleteBy()      {}

func (m *EndpointDeleteRequest) GetDeleteBy() isEndpointDeleteRequest_DeleteBy {
	if m != nil {
		return m.DeleteBy
	}
	return nil
}

func (m *EndpointDeleteRequest) GetMeta() *types.ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *EndpointDeleteRequest) GetKeyOrHandle() *EndpointKeyHandle {
	if x, ok := m.GetDeleteBy().(*EndpointDeleteRequest_KeyOrHandle); ok {
		return x.KeyOrHandle
	}
	return nil
}

func (m *EndpointDeleteRequest) GetFilter() *EndpointFilter {
	if x, ok := m.GetDeleteBy().(*EndpointDeleteRequest_Filter); ok {
		return x.Filter
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*EndpointDeleteRequest) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _EndpointDeleteRequest_OneofMarshaler, _EndpointDeleteRequest_OneofUnmarshaler, _EndpointDeleteRequest_OneofSizer, []interface{}{
		(*EndpointDeleteRequest_KeyOrHandle)(nil),
		(*EndpointDeleteRequest_Filter)(nil),
	}
}

func _EndpointDeleteRequest_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*EndpointDeleteRequest)
	// delete_by
	switch x := m.DeleteBy.(type) {
	case *EndpointDeleteRequest_KeyOrHandle:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.KeyOrHandle); err != nil {
			return err
		}
	case *EndpointDeleteRequest_Filter:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Filter); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("EndpointDeleteRequest.DeleteBy has unexpected type %T", x)
	}
	return nil
}

func _EndpointDeleteRequest_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*EndpointDeleteRequest)
	switch tag {
	case 2: // delete_by.key_or_handle
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(EndpointKeyHandle)
		err := b.DecodeMessage(msg)
		m.DeleteBy = &EndpointDeleteRequest_KeyOrHandle{msg}
		return true, err
	case 3: // delete_by.filter
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(EndpointFilter)
		err := b.DecodeMessage(msg)
		m.DeleteBy = &EndpointDeleteRequest_Filter{msg}
		return true, err
	default:
		return false, nil
	}
}

func _EndpointDeleteRequest_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*EndpointDeleteRequest)
	// delete_by
	switch x := m.DeleteBy.(type) {
	case *EndpointDeleteRequest_KeyOrHandle:
		s := proto.Size(x.KeyOrHandle)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *EndpointDeleteRequest_Filter:
		s := proto.Size(x.Filter)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// EndpointDeleteRequestMsg is batched endpoint delete request
type EndpointDeleteRequestMsg struct {
	Request []*EndpointDeleteRequest `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *EndpointDeleteRequestMsg) Reset()                    { *m = EndpointDeleteRequestMsg{} }
func (m *EndpointDeleteRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*EndpointDeleteRequestMsg) ProtoMessage()               {}
func (*EndpointDeleteRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *EndpointDeleteRequestMsg) GetRequest() []*EndpointDeleteRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

// EndpointDeleteResponseMsg is used to delete a batch of Endpoints
type EndpointDeleteResponseMsg struct {
	ApiStatus []types.ApiStatus `protobuf:"varint,1,rep,packed,name=api_status,json=apiStatus,enum=types.ApiStatus" json:"api_status,omitempty"`
}

func (m *EndpointDeleteResponseMsg) Reset()                    { *m = EndpointDeleteResponseMsg{} }
func (m *EndpointDeleteResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*EndpointDeleteResponseMsg) ProtoMessage()               {}
func (*EndpointDeleteResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *EndpointDeleteResponseMsg) GetApiStatus() []types.ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return nil
}

// EndpointGetRequest is used to get information about an endpoint
type EndpointGetRequest struct {
	Meta        *types.ObjectMeta  `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	KeyOrHandle *EndpointKeyHandle `protobuf:"bytes,2,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty"`
}

func (m *EndpointGetRequest) Reset()                    { *m = EndpointGetRequest{} }
func (m *EndpointGetRequest) String() string            { return proto.CompactTextString(m) }
func (*EndpointGetRequest) ProtoMessage()               {}
func (*EndpointGetRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *EndpointGetRequest) GetMeta() *types.ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *EndpointGetRequest) GetKeyOrHandle() *EndpointKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

// EndpointGetRequestMsg is batched GET request for endpoints
type EndpointGetRequestMsg struct {
	Request []*EndpointGetRequest `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *EndpointGetRequestMsg) Reset()                    { *m = EndpointGetRequestMsg{} }
func (m *EndpointGetRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*EndpointGetRequestMsg) ProtoMessage()               {}
func (*EndpointGetRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *EndpointGetRequestMsg) GetRequest() []*EndpointGetRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

// EndpointGetByInterfaceRequestMsg is used to GET endpoints by interface
type EndpointGetByInterfaceRequestMsg struct {
	Meta            *types.ObjectMeta `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	InterfaceHandle uint64            `protobuf:"fixed64,2,opt,name=interface_handle,json=interfaceHandle" json:"interface_handle,omitempty"`
}

func (m *EndpointGetByInterfaceRequestMsg) Reset()         { *m = EndpointGetByInterfaceRequestMsg{} }
func (m *EndpointGetByInterfaceRequestMsg) String() string { return proto.CompactTextString(m) }
func (*EndpointGetByInterfaceRequestMsg) ProtoMessage()    {}
func (*EndpointGetByInterfaceRequestMsg) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{15}
}

func (m *EndpointGetByInterfaceRequestMsg) GetMeta() *types.ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *EndpointGetByInterfaceRequestMsg) GetInterfaceHandle() uint64 {
	if m != nil {
		return m.InterfaceHandle
	}
	return 0
}

// EndpointGetAllRequestMsg is used to GET all the endpoints
type EndpointGetAllRequestMsg struct {
}

func (m *EndpointGetAllRequestMsg) Reset()                    { *m = EndpointGetAllRequestMsg{} }
func (m *EndpointGetAllRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*EndpointGetAllRequestMsg) ProtoMessage()               {}
func (*EndpointGetAllRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

// EndpointStats is the statistics object for each Endpoint
type EndpointStats struct {
}

func (m *EndpointStats) Reset()                    { *m = EndpointStats{} }
func (m *EndpointStats) String() string            { return proto.CompactTextString(m) }
func (*EndpointStats) ProtoMessage()               {}
func (*EndpointStats) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

// EndpointGetResponse captures all the information about one Endpoint
type EndpointGetResponse struct {
	Spec   *EndpointSpec   `protobuf:"bytes,1,opt,name=spec" json:"spec,omitempty"`
	Status *EndpointStatus `protobuf:"bytes,2,opt,name=status" json:"status,omitempty"`
	Stats  *EndpointStats  `protobuf:"bytes,3,opt,name=stats" json:"stats,omitempty"`
}

func (m *EndpointGetResponse) Reset()                    { *m = EndpointGetResponse{} }
func (m *EndpointGetResponse) String() string            { return proto.CompactTextString(m) }
func (*EndpointGetResponse) ProtoMessage()               {}
func (*EndpointGetResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{18} }

func (m *EndpointGetResponse) GetSpec() *EndpointSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *EndpointGetResponse) GetStatus() *EndpointStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *EndpointGetResponse) GetStats() *EndpointStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

// EndpointGetResponseMsg is batched response to EndpointGetRequestMsg
type EndpointGetResponseMsg struct {
	ApiStatus types.ApiStatus        `protobuf:"varint,1,opt,name=api_status,json=apiStatus,enum=types.ApiStatus" json:"api_status,omitempty"`
	Response  []*EndpointGetResponse `protobuf:"bytes,2,rep,name=response" json:"response,omitempty"`
}

func (m *EndpointGetResponseMsg) Reset()                    { *m = EndpointGetResponseMsg{} }
func (m *EndpointGetResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*EndpointGetResponseMsg) ProtoMessage()               {}
func (*EndpointGetResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{19} }

func (m *EndpointGetResponseMsg) GetApiStatus() types.ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return types.ApiStatus_API_STATUS_OK
}

func (m *EndpointGetResponseMsg) GetResponse() []*EndpointGetResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

func init() {
	proto.RegisterType((*EndpointSpec)(nil), "halproto.EndpointSpec")
	proto.RegisterType((*EndpointRequestMsg)(nil), "halproto.EndpointRequestMsg")
	proto.RegisterType((*EndpointStatus)(nil), "halproto.EndpointStatus")
	proto.RegisterType((*EndpointResponse)(nil), "halproto.EndpointResponse")
	proto.RegisterType((*EndpointResponseMsg)(nil), "halproto.EndpointResponseMsg")
	proto.RegisterType((*EndpointL2Key)(nil), "halproto.EndpointL2Key")
	proto.RegisterType((*EndpointL3Key)(nil), "halproto.EndpointL3Key")
	proto.RegisterType((*EndpointKey)(nil), "halproto.EndpointKey")
	proto.RegisterType((*EndpointKeyHandle)(nil), "halproto.EndpointKeyHandle")
	proto.RegisterType((*EndpointFilter)(nil), "halproto.EndpointFilter")
	proto.RegisterType((*EndpointDeleteRequest)(nil), "halproto.EndpointDeleteRequest")
	proto.RegisterType((*EndpointDeleteRequestMsg)(nil), "halproto.EndpointDeleteRequestMsg")
	proto.RegisterType((*EndpointDeleteResponseMsg)(nil), "halproto.EndpointDeleteResponseMsg")
	proto.RegisterType((*EndpointGetRequest)(nil), "halproto.EndpointGetRequest")
	proto.RegisterType((*EndpointGetRequestMsg)(nil), "halproto.EndpointGetRequestMsg")
	proto.RegisterType((*EndpointGetByInterfaceRequestMsg)(nil), "halproto.EndpointGetByInterfaceRequestMsg")
	proto.RegisterType((*EndpointGetAllRequestMsg)(nil), "halproto.EndpointGetAllRequestMsg")
	proto.RegisterType((*EndpointStats)(nil), "halproto.EndpointStats")
	proto.RegisterType((*EndpointGetResponse)(nil), "halproto.EndpointGetResponse")
	proto.RegisterType((*EndpointGetResponseMsg)(nil), "halproto.EndpointGetResponseMsg")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Endpoint service

type EndpointClient interface {
	EndpointCreate(ctx context.Context, in *EndpointRequestMsg, opts ...grpc.CallOption) (*EndpointResponseMsg, error)
	EndpointUpdate(ctx context.Context, in *EndpointRequestMsg, opts ...grpc.CallOption) (*EndpointResponseMsg, error)
	EndpointDelete(ctx context.Context, in *EndpointDeleteRequestMsg, opts ...grpc.CallOption) (*EndpointDeleteResponseMsg, error)
	EndpointGet(ctx context.Context, in *EndpointGetRequestMsg, opts ...grpc.CallOption) (*EndpointGetResponseMsg, error)
	EndpointGetAll(ctx context.Context, in *EndpointGetAllRequestMsg, opts ...grpc.CallOption) (*EndpointGetResponseMsg, error)
	EndpointGetByInterface(ctx context.Context, in *EndpointGetByInterfaceRequestMsg, opts ...grpc.CallOption) (*EndpointGetResponseMsg, error)
}

type endpointClient struct {
	cc *grpc.ClientConn
}

func NewEndpointClient(cc *grpc.ClientConn) EndpointClient {
	return &endpointClient{cc}
}

func (c *endpointClient) EndpointCreate(ctx context.Context, in *EndpointRequestMsg, opts ...grpc.CallOption) (*EndpointResponseMsg, error) {
	out := new(EndpointResponseMsg)
	err := grpc.Invoke(ctx, "/halproto.Endpoint/EndpointCreate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *endpointClient) EndpointUpdate(ctx context.Context, in *EndpointRequestMsg, opts ...grpc.CallOption) (*EndpointResponseMsg, error) {
	out := new(EndpointResponseMsg)
	err := grpc.Invoke(ctx, "/halproto.Endpoint/EndpointUpdate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *endpointClient) EndpointDelete(ctx context.Context, in *EndpointDeleteRequestMsg, opts ...grpc.CallOption) (*EndpointDeleteResponseMsg, error) {
	out := new(EndpointDeleteResponseMsg)
	err := grpc.Invoke(ctx, "/halproto.Endpoint/EndpointDelete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *endpointClient) EndpointGet(ctx context.Context, in *EndpointGetRequestMsg, opts ...grpc.CallOption) (*EndpointGetResponseMsg, error) {
	out := new(EndpointGetResponseMsg)
	err := grpc.Invoke(ctx, "/halproto.Endpoint/EndpointGet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *endpointClient) EndpointGetAll(ctx context.Context, in *EndpointGetAllRequestMsg, opts ...grpc.CallOption) (*EndpointGetResponseMsg, error) {
	out := new(EndpointGetResponseMsg)
	err := grpc.Invoke(ctx, "/halproto.Endpoint/EndpointGetAll", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *endpointClient) EndpointGetByInterface(ctx context.Context, in *EndpointGetByInterfaceRequestMsg, opts ...grpc.CallOption) (*EndpointGetResponseMsg, error) {
	out := new(EndpointGetResponseMsg)
	err := grpc.Invoke(ctx, "/halproto.Endpoint/EndpointGetByInterface", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Endpoint service

type EndpointServer interface {
	EndpointCreate(context.Context, *EndpointRequestMsg) (*EndpointResponseMsg, error)
	EndpointUpdate(context.Context, *EndpointRequestMsg) (*EndpointResponseMsg, error)
	EndpointDelete(context.Context, *EndpointDeleteRequestMsg) (*EndpointDeleteResponseMsg, error)
	EndpointGet(context.Context, *EndpointGetRequestMsg) (*EndpointGetResponseMsg, error)
	EndpointGetAll(context.Context, *EndpointGetAllRequestMsg) (*EndpointGetResponseMsg, error)
	EndpointGetByInterface(context.Context, *EndpointGetByInterfaceRequestMsg) (*EndpointGetResponseMsg, error)
}

func RegisterEndpointServer(s *grpc.Server, srv EndpointServer) {
	s.RegisterService(&_Endpoint_serviceDesc, srv)
}

func _Endpoint_EndpointCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EndpointRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EndpointServer).EndpointCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/halproto.Endpoint/EndpointCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EndpointServer).EndpointCreate(ctx, req.(*EndpointRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Endpoint_EndpointUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EndpointRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EndpointServer).EndpointUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/halproto.Endpoint/EndpointUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EndpointServer).EndpointUpdate(ctx, req.(*EndpointRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Endpoint_EndpointDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EndpointDeleteRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EndpointServer).EndpointDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/halproto.Endpoint/EndpointDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EndpointServer).EndpointDelete(ctx, req.(*EndpointDeleteRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Endpoint_EndpointGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EndpointGetRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EndpointServer).EndpointGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/halproto.Endpoint/EndpointGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EndpointServer).EndpointGet(ctx, req.(*EndpointGetRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Endpoint_EndpointGetAll_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EndpointGetAllRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EndpointServer).EndpointGetAll(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/halproto.Endpoint/EndpointGetAll",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EndpointServer).EndpointGetAll(ctx, req.(*EndpointGetAllRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Endpoint_EndpointGetByInterface_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EndpointGetByInterfaceRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EndpointServer).EndpointGetByInterface(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/halproto.Endpoint/EndpointGetByInterface",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EndpointServer).EndpointGetByInterface(ctx, req.(*EndpointGetByInterfaceRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

var _Endpoint_serviceDesc = grpc.ServiceDesc{
	ServiceName: "halproto.Endpoint",
	HandlerType: (*EndpointServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "EndpointCreate",
			Handler:    _Endpoint_EndpointCreate_Handler,
		},
		{
			MethodName: "EndpointUpdate",
			Handler:    _Endpoint_EndpointUpdate_Handler,
		},
		{
			MethodName: "EndpointDelete",
			Handler:    _Endpoint_EndpointDelete_Handler,
		},
		{
			MethodName: "EndpointGet",
			Handler:    _Endpoint_EndpointGet_Handler,
		},
		{
			MethodName: "EndpointGetAll",
			Handler:    _Endpoint_EndpointGetAll_Handler,
		},
		{
			MethodName: "EndpointGetByInterface",
			Handler:    _Endpoint_EndpointGetByInterface_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "endpoint.proto",
}

func init() { proto.RegisterFile("endpoint.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 982 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xac, 0x55, 0x5d, 0x6b, 0x1b, 0x47,
	0x17, 0xf6, 0xca, 0xb2, 0x2c, 0x1f, 0x45, 0x92, 0x35, 0x79, 0x93, 0xec, 0xeb, 0x24, 0x58, 0x6c,
	0x09, 0x55, 0x0c, 0x55, 0xc2, 0x1a, 0x0a, 0xe9, 0x4d, 0x2b, 0x27, 0x8d, 0x1d, 0x1a, 0xe3, 0xb2,
	0x26, 0xa5, 0xd0, 0xc2, 0x32, 0x5e, 0x8d, 0xa5, 0xad, 0xd7, 0xbb, 0xdb, 0x9d, 0x51, 0x41, 0xd0,
	0xcb, 0xd2, 0x5e, 0xf4, 0x57, 0x34, 0x3f, 0xa5, 0x57, 0xfd, 0x59, 0x65, 0xbe, 0x76, 0x56, 0xab,
	0x95, 0x2d, 0x43, 0x6f, 0xc4, 0x6a, 0xe6, 0x39, 0xcf, 0x39, 0xe7, 0x39, 0x1f, 0x03, 0x1d, 0x12,
	0x8f, 0xd3, 0x24, 0x8c, 0xd9, 0x30, 0xcd, 0x12, 0x96, 0xa0, 0xe6, 0x14, 0x47, 0xe2, 0x6b, 0xaf,
	0xc7, 0xe6, 0x29, 0xa1, 0x2f, 0xc4, 0xaf, 0xbc, 0x74, 0x3e, 0xd6, 0xe0, 0xde, 0xd7, 0x0a, 0x7f,
	0x9e, 0x92, 0x00, 0x3d, 0x83, 0xfa, 0x35, 0x61, 0xd8, 0xb6, 0xfa, 0xd6, 0xa0, 0xe5, 0xf6, 0x86,
	0x12, 0x7c, 0x76, 0xf1, 0x13, 0x09, 0xd8, 0x29, 0x61, 0xd8, 0x13, 0xd7, 0xe8, 0x00, 0x7a, 0x91,
	0xeb, 0x53, 0x32, 0xb9, 0x26, 0x31, 0xf3, 0xa7, 0x38, 0x1e, 0x47, 0xc4, 0xae, 0xf5, 0xad, 0x41,
	0xc3, 0xeb, 0x46, 0xee, 0xb9, 0x3c, 0x3f, 0x11, 0xc7, 0x68, 0x1f, 0x5a, 0xd7, 0x38, 0xf0, 0xf1,
	0x78, 0x9c, 0x11, 0x4a, 0xed, 0xcd, 0xbe, 0x35, 0xa8, 0x7b, 0x70, 0x8d, 0x83, 0x91, 0x3c, 0x41,
	0xcf, 0x61, 0x37, 0x8c, 0x19, 0xc9, 0x2e, 0x71, 0x40, 0x34, 0x57, 0x5d, 0x72, 0xe5, 0xe7, 0x8a,
	0xeb, 0x31, 0xec, 0xcc, 0x28, 0x99, 0xf8, 0xbf, 0x44, 0x38, 0xb6, 0xb7, 0xfa, 0xd6, 0xa0, 0xed,
	0x35, 0xf9, 0xc1, 0x77, 0x11, 0x8e, 0xd1, 0x0b, 0x80, 0x30, 0xcd, 0xfd, 0x34, 0xfa, 0x9b, 0x83,
	0x96, 0xbb, 0xab, 0x32, 0x78, 0xf7, 0xad, 0xf2, 0xe6, 0xed, 0x84, 0xa9, 0x76, 0xfc, 0x0c, 0x3a,
	0x94, 0x04, 0xb3, 0x2c, 0x64, 0x73, 0x7f, 0x92, 0x25, 0xb3, 0xd4, 0xde, 0xee, 0x6f, 0x0e, 0xda,
	0x5e, 0x5b, 0x9f, 0x1e, 0xf3, 0x43, 0xe7, 0x2d, 0x20, 0xad, 0x91, 0x47, 0x7e, 0x9e, 0x11, 0xca,
	0x4e, 0xe9, 0x04, 0xbd, 0x84, 0xed, 0x4c, 0xfe, 0xb3, 0x2d, 0xe1, 0xea, 0xe1, 0x50, 0x2b, 0x3d,
	0x2c, 0x4a, 0xea, 0x69, 0x98, 0xf3, 0x4f, 0x0d, 0x3a, 0xf9, 0x0d, 0xc3, 0x6c, 0x46, 0xd1, 0xa7,
	0xd0, 0xd5, 0xe5, 0xd2, 0x99, 0x5b, 0x22, 0xf3, 0xbc, 0x8a, 0x2a, 0xf1, 0xc5, 0xdc, 0x6a, 0xb7,
	0xe7, 0xc6, 0x2b, 0x44, 0x70, 0x16, 0xfb, 0x34, 0x99, 0x65, 0x01, 0xf1, 0xc7, 0xd3, 0x20, 0x15,
	0xda, 0x37, 0xbd, 0xae, 0xb8, 0x38, 0x17, 0xe7, 0x6f, 0xa6, 0x41, 0x8a, 0x06, 0xb0, 0xbb, 0x80,
	0xc5, 0x59, 0x2a, 0x0a, 0xd0, 0xf4, 0x3a, 0x05, 0xe8, 0x28, 0x4b, 0x97, 0x58, 0x33, 0x0e, 0xdd,
	0x5a, 0x62, 0xf5, 0x70, 0x96, 0xa2, 0x21, 0xdc, 0x5f, 0xc0, 0x06, 0x49, 0x7c, 0x19, 0x4e, 0xec,
	0x86, 0x40, 0xf7, 0x0a, 0xe8, 0xd7, 0xe2, 0x82, 0x73, 0x87, 0xd4, 0xcf, 0xe5, 0x88, 0x92, 0x00,
	0x47, 0xf6, 0xb6, 0xe4, 0x0e, 0xa9, 0x16, 0xee, 0x3d, 0x3f, 0x76, 0x7e, 0xb7, 0x60, 0xd7, 0xd4,
	0x84, 0xa6, 0x49, 0x4c, 0x85, 0x46, 0x38, 0x0d, 0x7d, 0x2a, 0xa4, 0x15, 0x3a, 0x76, 0x72, 0x8d,
	0x46, 0x69, 0x28, 0x25, 0xf7, 0x76, 0xb0, 0xfe, 0x44, 0xa3, 0x82, 0xfa, 0xca, 0xaa, 0x26, 0xfa,
	0xde, 0xae, 0x28, 0xa5, 0xb4, 0xce, 0xeb, 0x22, 0xff, 0x3b, 0xa7, 0x70, 0xbf, 0x1c, 0x07, 0x6f,
	0x8e, 0xcf, 0xa1, 0x99, 0xa9, 0xbf, 0xaa, 0x3b, 0xf6, 0x96, 0x29, 0xb5, 0x81, 0x97, 0x63, 0x9d,
	0x1f, 0xa1, 0x9d, 0x27, 0xea, 0x7e, 0x43, 0xe6, 0xd5, 0x83, 0x66, 0xad, 0x35, 0x68, 0xb5, 0xf2,
	0xa0, 0x39, 0x5f, 0x15, 0xd8, 0x0f, 0x39, 0xfb, 0x62, 0x57, 0xc9, 0x99, 0xbf, 0xa9, 0xab, 0x9c,
	0x3f, 0x2c, 0x68, 0x69, 0x0a, 0x4e, 0xf0, 0x12, 0x1a, 0x91, 0xeb, 0x5f, 0x91, 0xb9, 0x32, 0x7e,
	0xb4, 0x9c, 0xa5, 0xc8, 0xe3, 0x64, 0xc3, 0xdb, 0x8a, 0x5c, 0x6d, 0x71, 0x28, 0x2c, 0x6a, 0x2b,
	0x2d, 0x0e, 0xb5, 0x05, 0xff, 0x38, 0xfa, 0x1f, 0x20, 0xd3, 0x14, 0xae, 0x2f, 0xad, 0x9d, 0x3f,
	0x2d, 0xe8, 0x15, 0x22, 0x51, 0x12, 0x7c, 0x01, 0xf7, 0x72, 0xac, 0x89, 0xea, 0xc1, 0xb2, 0x0f,
	0xe9, 0xa1, 0x45, 0x0a, 0xb9, 0x3c, 0x5f, 0x9e, 0x45, 0xb1, 0xd1, 0x4e, 0x36, 0xca, 0xd3, 0x78,
	0xd4, 0x85, 0xf6, 0x15, 0x99, 0xfb, 0x49, 0xa6, 0x80, 0xce, 0xc4, 0x4c, 0xf6, 0xdb, 0x30, 0x62,
	0x24, 0xbb, 0x53, 0xe1, 0xaa, 0x16, 0x60, 0xad, 0x72, 0x01, 0x3a, 0x7f, 0x5b, 0xf0, 0x40, 0x7b,
	0x7a, 0x43, 0x22, 0xc2, 0x88, 0x5a, 0x49, 0xeb, 0x6e, 0xee, 0x51, 0x29, 0x74, 0x55, 0x86, 0xc7,
	0xd5, 0x12, 0x09, 0x08, 0x17, 0xea, 0x8a, 0xcc, 0xcf, 0x32, 0x15, 0xae, 0x0b, 0x8d, 0x4b, 0x91,
	0xa4, 0xd8, 0x27, 0x95, 0xd3, 0x22, 0x45, 0x38, 0xd9, 0xf0, 0x14, 0xf2, 0xa8, 0x05, 0x3b, 0x63,
	0x11, 0xae, 0x7f, 0x31, 0x77, 0x3e, 0x80, 0x5d, 0x99, 0x03, 0x9f, 0x9c, 0x57, 0xe5, 0xb5, 0xba,
	0xbf, 0xcc, 0xbe, 0x60, 0x64, 0xf6, 0xeb, 0x7b, 0xf8, 0x7f, 0x19, 0x61, 0x26, 0xb2, 0xbc, 0x1c,
	0x36, 0x6f, 0x59, 0x0e, 0xce, 0xaf, 0x66, 0xeb, 0x1f, 0x13, 0x76, 0x47, 0x95, 0xbf, 0xbc, 0xbb,
	0xca, 0x0b, 0x1a, 0x3b, 0x67, 0xa6, 0xcc, 0xc6, 0xbb, 0xdc, 0x2c, 0x25, 0x7d, 0x9e, 0x2c, 0x73,
	0x1a, 0x0b, 0x23, 0x0e, 0x83, 0x7e, 0xe1, 0xfa, 0x68, 0xfe, 0x4e, 0x37, 0x56, 0x81, 0x7b, 0xcd,
	0xe4, 0xee, 0xd0, 0xae, 0x7b, 0xa6, 0xd2, 0xc7, 0x84, 0x8d, 0xa2, 0xc8, 0x78, 0x73, 0xba, 0x66,
	0x1b, 0x71, 0xc9, 0xa9, 0xf3, 0xd1, 0x32, 0xcb, 0x54, 0xa4, 0xa0, 0xf6, 0xfa, 0x01, 0xd4, 0x69,
	0x4a, 0x02, 0x15, 0xd6, 0xaa, 0x67, 0x56, 0x60, 0xf8, 0x7a, 0x59, 0x73, 0x93, 0x2b, 0x1c, 0xfa,
	0x0c, 0xb6, 0xf8, 0x17, 0x55, 0xcd, 0xfc, 0xa8, 0xda, 0x80, 0x7a, 0x12, 0xe5, 0xfc, 0x66, 0xc1,
	0xc3, 0x8a, 0x20, 0xab, 0x5a, 0xec, 0xd6, 0xf7, 0xe7, 0x55, 0xe1, 0x95, 0x90, 0x4f, 0xfa, 0xd3,
	0x15, 0xc5, 0x2c, 0x3f, 0x14, 0xee, 0x5f, 0x75, 0x68, 0x6a, 0x04, 0x3a, 0x33, 0xdb, 0xe7, 0x75,
	0x46, 0x30, 0x23, 0xe8, 0x49, 0xd5, 0x6b, 0xa3, 0x95, 0xdf, 0x7b, 0xba, 0xfa, 0x2d, 0xe2, 0x85,
	0xd9, 0x28, 0x12, 0x7e, 0x48, 0xc7, 0xff, 0x01, 0xe1, 0x0f, 0x86, 0x50, 0x8e, 0x26, 0x72, 0x6e,
	0x19, 0x6b, 0x4e, 0xfb, 0xc9, 0x6a, 0x4c, 0x91, 0xdc, 0x33, 0x6f, 0xd2, 0x31, 0x61, 0x68, 0xff,
	0xa6, 0x81, 0xe0, 0xb4, 0xfd, 0x1b, 0x45, 0x96, 0x9c, 0xdf, 0x9b, 0x80, 0x65, 0xe3, 0x56, 0x05,
	0x5c, 0x6e, 0xe9, 0xb5, 0x98, 0xa7, 0x0b, 0xfd, 0x53, 0x18, 0x44, 0x74, 0x50, 0x69, 0x5d, 0x39,
	0xaa, 0xeb, 0x78, 0xba, 0x68, 0x88, 0xfb, 0xc3, 0x7f, 0x03, 0x00, 0x00, 0xff, 0xff, 0x26, 0xab,
	0x79, 0xba, 0x12, 0x0c, 0x00, 0x00,
}
