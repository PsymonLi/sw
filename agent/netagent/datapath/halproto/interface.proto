//------------------------------------------------------------------------------
// protobuf specification for Interface HAL APIs
//------------------------------------------------------------------------------

syntax = "proto3";

import "types/types.proto";

package halproto;

// Interface service definition
service Interface {
  // LIF related APIs
  rpc LifCreate(LifRequestMsg) returns (LifResponseMsg) {}
  rpc LifUpdate(LifRequestMsg) returns (LifResponseMsg) {}
  rpc LifDelete(LifDeleteRequestMsg) returns (LifDeleteResponseMsg) {}
  rpc LifGet(LifGetRequestMsg) returns (LifGetResponseMsg) {}

  // APIs for all other interfaces
  rpc InterfaceCreate (InterfaceRequestMsg) returns (InterfaceResponseMsg) {}
  rpc InterfaceUpdate (InterfaceRequestMsg) returns (InterfaceResponseMsg) {}
  rpc InterfaceDelete (InterfaceDeleteRequestMsg) returns (InterfaceDeleteResponseMsg) {}
  rpc InterfaceGet (InterfaceGetRequestMsg) returns (InterfaceGetResponseMsg) {}
}

// IfStatus status reflects the current status of Interface
enum IfStatus {
  IF_STATUS_NONE    = 0;
  IF_STATUS_UP      = 1;
  IF_STATUS_DOWN    = 2;
}

//------------------------------------------------------------------------------
// LIF represents a connection point to ASIC, every connection to ASIC is
// exposed as a LIF (both uplinks and southbound links towards either workloads
// or host or VSS/DVS etc. Before creating any other kind of interface. LIFs are
// associated with a number of queues of different types and how to carve them
// is upto software. First LIFs need to be created and other interface types are
// tied to corresponding LIF. There is a many-to-1 relation between other types
// of interfaces and a LIF.
//------------------------------------------------------------------------------

// different types of LIF queues
enum LifQType {
  LIF_QUEUE_TYPE_NONE      = 0;
  LIF_QUEUE_TYPE_ADMIN     = 1;    // Admin Queue
  LIF_QUEUE_TYPE_TX        = 2;    // Tx Queue
  LIF_QUEUE_TYPE_RX        = 3;    // Rx Queue
  LIF_QUEUE_TYPE_RDMA_SEND = 4;    // RDMA send Queue
  LIF_QUEUE_TYPE_RDMA_RECV = 5;    // RDMA receive Queue
  LIF_QUEUE_TYPE_CQ        = 6;    // Completion Queue
  LIF_QUEUE_TYPE_EQ        = 7;    // Event Queue
}

// Types of LIF ports
enum LifPortType {
  LIF_PORT_TYPE_NONE       = 0;
  LIF_PORT_TYPE_UPLINK     = 1;    // LIF for uplink port
  LIF_PORT_TYPE_DMA        = 2;    // LIF towards workloads
  LIF_PORT_TYPE_P4_INGRESS = 3;    // LIF for P4 ingress
  LIF_PORT_TYPE_P4_EGRESS  = 4;    // LIF for P4 egress
  LIF_PORT_TYPE_NCSI       = 5;    // LIF for mgmt port
}

// LIF can have many queues of different types
message LifQueueInfo {
    LifQType    qtype       = 1;    // queue type
    uint32      queue_id    = 2;    // queue identifier
}

// LifKeyHandle uniquely identifies a LIF
message LifKeyHandle {
  oneof key_or_handle {
    fixed32         lif_id     = 1;     // app allocated unique LIF id
    fixed64         lif_handle = 2;     // id of interface returned by HAL
  }
}

// LIF object
message LifSpec {
  types.ObjectMeta         meta          = 1;    // object meta
  LifKeyHandle             key_or_handle = 2;    // LIF's key or handle
  uint64                   mac_addr      = 3;    // link MAC address, if any
  LifPortType              port_type     = 4;    // LIF port type
  uint32                   port_num      = 5;    // LIF port number (TM oport#)
  LifKeyHandle             peer_lif      = 6;    // peer LIF in case this LIF is pinned to another LIF
  IfStatus                 admin_status  = 7;    // admin status of the interface
  repeated LifQueueInfo    queues        = 8;    // LIF queue information
}

// LifRequestMsg is batched request used to create/update of LIFs
message LifRequestMsg {
  repeated LifSpec    request = 1;    // batch of requests
}

// LifStatus represents the operational status of LIF
message LifStatus {
  IfStatus    lif_status = 1;    // currrent status of the interface
  fixed64     lif_handle = 2;    // id of the interface returned by HAL
}

// LifResponse s response to one LifSpec
message LifResponse {
  types.ApiStatus    api_status  = 1;    // API status code
  LifStatus          status      = 2;    // operational status
}

// LifResponseMsg is response to LifRequestMsg
message LifResponseMsg {
  repeated LifResponse    response = 1;    // batch of responses
}

// LifDeleteRequest  is used to delete a LIF object
message LifDeleteRequest {
  types.ObjectMeta    meta          = 1;    // object meta
  LifKeyHandle        key_or_handle = 2;    // LIF being deleted
}

// LifDeleteRequestMsg is used to delete a batch of LIFs
message LifDeleteRequestMsg {
  repeated LifDeleteRequest    request = 1;    // batched delete request
}

// LifDeleteResponseMsg is batched response to LifDeleteRequestMsg
message LifDeleteResponseMsg {
  repeated types.ApiStatus    api_status = 1;    // API status code
}

// LifStats captures all the statistics of given LIF
message LifStats {
}

// LifGetRequest is used to get information about a LIF
message LifGetRequest {
  types.ObjectMeta    meta          = 1;    // object meta
  LifKeyHandle        key_or_handle = 2;    // key or handle
}

message LifGetRequestMsg {
  repeated LifGetRequest    request = 1;    // batched get request
}

// LifGetResponse captures all the information about a LIF
message LifGetResponse {
  LifSpec      spec   = 1;    // LIF configuration
  LifStatus    status = 2;    // LIF operational status
  LifStats     stats  = 3;    // LIF statistics
}

// LifGetResponseMsg is response to LifGetRequestMsg
message LifGetResponseMsg {
  repeated LifGetResponse    response = 1;    // batched get response
}

// types of interfaces
enum IfType {
  IF_TYPE_NONE         = 0;
  IF_TYPE_ENIC         = 1;    // interface connected to workload/endpoint(s)
  IF_TYPE_UPLINK       = 2;    // interface representing NIC uplink(s)
  IF_TYPE_UPLINK_PC    = 3;    // interface representing NIC uplink port channel
  IF_TYPE_TUNNEL       = 4;    // interface representing tunnel
}

//------------------------------------------------------------------------------
// if interface type is IF_TYPE_ENIC, one of the following vnic types must be
// set. IF_ENIC_TYPE_XXX identifies how a workload is attached to asic
//------------------------------------------------------------------------------
enum IfEnicType {
  IF_ENIC_TYPE_NONE     = 0;
  IF_ENIC_TYPE_USEG     = 1;    // workload interface used in inline useg mode
  IF_ENIC_TYPE_PVLAN    = 2;    // workload attachment used in PVLAN mode
  IF_ENIC_TYPE_DIRECT   = 3;    // workload attachment used for SR-IOV,
                                // VSS/DVS connectivity etc.
}

//------------------------------------------------------------------------------
// mandatory attributes expected if enic type is IF_ENIC_TYPE_USEG or
// IF_ENIC_TYPE_SRIOV
//------------------------------------------------------------------------------
message IfEnicUsegInfo {
  uint32    useg_vlan_id  = 1;    // useg VLAN id/encap
  uint32    l2segment_id  = 2;    // user (external) vlan
}

// mandatory attributes expected if enic type is IF_ENIC_TYPE_PVLAN
message IfEnicPVLANInfo {
  fixed64    mac_address      = 1;    // MAC address of the endpoint
  uint32     isolated_vlan_id = 2;    // isolated VLAN
  uint32     l2segment_id     = 3;    // user (external) vlan
}

// mandatory attributes expected if enic type is IF_ENIC_TYPE_DIRECT
// multiple user vlans on this implies that this is trunk interface
message IfEnicDirectInfo {
  uint32             native_l2segment_id = 1;    // L2 segment to map the packets to, if they are untagged
  bool               sriov               = 2;    // TRUE if SR-IOV is enabled
  repeated uint32    l2segment_id        = 3;    // user (external) vlans
}

// mandatory attributes expected if interface type is IF_TYPE_ENIC
message IfEnicInfo {
  IfEnicType            enic_type    = 1;    // type of enic interface
  oneof enic_info {
    IfEnicUsegInfo      useg_info    = 2;    // useg enic specific info
    IfEnicPVLANInfo     pvlan_info   = 3;    // pvlan enic specific info
    IfEnicDirectInfo    direct_info  = 4;    // direct enic specific info
  }
}

// mandatory attributes expected if interface type is IF_TYPE_UPLINK
message IfUplinkInfo {
  uint32             port_num            = 1;    // uplink port number
  uint32             native_l2segment_id = 2;    // L2 segment to map the packets to, if they are untagged
  repeated uint32    l2segment_id        = 3;    // user (external) vlans
}

// mandatory attributes expected if interface type is IF_TYPE_UPLINK_PC
message IfUplinkPCInfo {
  uint32             uplink_pc_num       = 1;    // uplink port channel number
  uint32             native_l2segment_id = 2;    // L2 segment to map the packets to, if they are untagged
  repeated uint32    l2segment_id        = 3;    // user (external) vlans
}

// InterfaceKeyHandle uniquely identifies a Interface
message InterfaceKeyHandle {
  oneof key_or_handle {
    fixed64         interface_id = 1;     // app allocated unique (across all interface types) interface id
    fixed64         if_handle    = 2;     // id of interface returned by HAL
  }
}

// InterfaceSpec is used to add or update of an interface
// TODO: Add QoS, Policer etc. config as well
message InterfaceSpec {
  types.ObjectMeta      meta                = 1;    // object meta
  InterfaceKeyHandle    key_or_handle       = 2;    // interface being created/updated
  IfType                type                = 3;    // type of interface
  IfStatus              admin_status        = 4;    // admin status of the interface
  LifKeyHandle          lif_key_or_handle   = 5;    // LIF identifier for this interface
  oneof if_info {
    IfEnicInfo          if_enic_info        = 6;    // enic data if interface type is IF_TYPE_ENIC
    IfUplinkInfo        if_uplink_info      = 7;    // uplink port number if interface type is IF_TYPE_UPLINK
    IfUplinkPCInfo      if_uplink_pc_info   = 8;    // uplink port channel number if interface type is IF_TYPE_UPLINK_PC
  }
}

// InterfaceRequestMsg is batched request message that is used to do
// create/update of interface(s)
message InterfaceRequestMsg {
  repeated InterfaceSpec    request = 1;    // batch of requests
}

// InterfaceStatus represents the current status of the interface
message InterfaceStatus {
  IfStatus    if_status    = 1;    // current status of the interface
  fixed64     if_handle    = 2;    // id of the interface returned by HAL
}

// InterfaceResponse is response to one InterfaceSpec
message InterfaceResponse {
  types.ApiStatus    api_status  = 1;    // API status code
  InterfaceStatus    status      = 2;    // operational status
}

// InterfaceResponseMsg is response to InterfaceRequestMsg
message InterfaceResponseMsg {
  repeated InterfaceResponse    response = 1;    // batch of responses
}

// InterfaceDeleteRequest is used to delete a interface object
message InterfaceDeleteRequest {
  types.ObjectMeta      meta             = 1;    // object meta
  InterfaceKeyHandle    key_or_handle    = 2;    // interface being deleted
}

// InterfaceDeleteRequestMsg is used to delete a batch of interfaces
message InterfaceDeleteRequestMsg {
  repeated InterfaceDeleteRequest    request = 1;   // batched delete request
}

// InterfaceDeleteResponseMsg is batched response to InterfaceDeleteRequestMsg
message InterfaceDeleteResponseMsg {
  repeated types.ApiStatus    api_status = 1;      // API status code
}

// InterfaceStats captures all the statistics of given interface
message InterfaceStats {
  fixed32    num_tx_packets            = 1;    // Tx Packets from this interface
  fixed32    num_tx_bytes              = 2;    // Tx Bytes from this interface
  fixed32    num_rx_packets            = 3;    // Rx Packets to this interface
  fixed32    num_rx_bytes              = 4;    // Rx Bytes to this interface
  fixed32    num_sessions_initated     = 5;    // Sessions initated
  fixed32    num_sessions_responded    = 6;    // Sessions responded
}

// InterfaceGetRequest is used to get information about a interface
message InterfaceGetRequest {
  types.ObjectMeta      meta          = 1;    // object meta
  InterfaceKeyHandle    key_or_handle = 2;    // interface key or handle
}

// InterfaceGetRequestMsg is batched GET request for interfaces
message InterfaceGetRequestMsg {
  repeated InterfaceGetRequest    request = 1;    // batched get request
}

// InterfaceGetResponse captures all the information about a interface
message InterfaceGetResponse {
  InterfaceSpec      spec     = 1;    // interface specification/configuration
  InterfaceStatus    status   = 2;    // interface status
  InterfaceStats     stats    = 3;    // interface statistics
}

// InterfaceGetResponseMsg is response to InterfaceGetRequestMsg
message InterfaceGetResponseMsg {
  repeated InterfaceGetResponse    response = 1;    // batched get response
}
