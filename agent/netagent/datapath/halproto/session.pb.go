// Code generated by protoc-gen-go.
// source: session.proto
// DO NOT EDIT!

package halproto

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import types "github.com/pensando/sw/agent/netagent/datapath/halproto/types"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// Types of NAT
type NatType int32

const (
	NatType_NAT_TYPE_NONE      NatType = 0
	NatType_NAT_TYPE_SNAT      NatType = 1
	NatType_NAT_TYPE_DNAT      NatType = 2
	NatType_NAT_TYPE_TWICE_NAT NatType = 3
)

var NatType_name = map[int32]string{
	0: "NAT_TYPE_NONE",
	1: "NAT_TYPE_SNAT",
	2: "NAT_TYPE_DNAT",
	3: "NAT_TYPE_TWICE_NAT",
}
var NatType_value = map[string]int32{
	"NAT_TYPE_NONE":      0,
	"NAT_TYPE_SNAT":      1,
	"NAT_TYPE_DNAT":      2,
	"NAT_TYPE_TWICE_NAT": 3,
}

func (x NatType) String() string {
	return proto.EnumName(NatType_name, int32(x))
}
func (NatType) EnumDescriptor() ([]byte, []int) { return fileDescriptor5, []int{0} }

// Flow actions
type FlowAction int32

const (
	FlowAction_FLOW_ACTION_NONE  FlowAction = 0
	FlowAction_FLOW_ACTION_ALLOW FlowAction = 1
	FlowAction_FLOW_ACTION_DROP  FlowAction = 2
)

var FlowAction_name = map[int32]string{
	0: "FLOW_ACTION_NONE",
	1: "FLOW_ACTION_ALLOW",
	2: "FLOW_ACTION_DROP",
}
var FlowAction_value = map[string]int32{
	"FLOW_ACTION_NONE":  0,
	"FLOW_ACTION_ALLOW": 1,
	"FLOW_ACTION_DROP":  2,
}

func (x FlowAction) String() string {
	return proto.EnumName(FlowAction_name, int32(x))
}
func (FlowAction) EnumDescriptor() ([]byte, []int) { return fileDescriptor5, []int{1} }

// Flow TCP states
// TODO: Srini, please define all other states
type FlowTCPState int32

const (
	FlowTCPState_FLOW_TCP_STATE_NONE         FlowTCPState = 0
	FlowTCPState_FLOW_TCP_STATE_INIT         FlowTCPState = 1
	FlowTCPState_FLOW_TCP_STATE_SYN_SENT     FlowTCPState = 2
	FlowTCPState_FLOW_TCP_STATE_SYN_ACK_RCVD FlowTCPState = 3
	FlowTCPState_FLOW_TCP_STATE_CLOSING      FlowTCPState = 4
	FlowTCPState_FLOW_TCP_STATE_CLOSE_WAIT   FlowTCPState = 5
	FlowTCPState_FLOW_TCP_STATE_ESTABLISHED  FlowTCPState = 6
	FlowTCPState_FLOW_TCP_STATE_CLOSED       FlowTCPState = 7
)

var FlowTCPState_name = map[int32]string{
	0: "FLOW_TCP_STATE_NONE",
	1: "FLOW_TCP_STATE_INIT",
	2: "FLOW_TCP_STATE_SYN_SENT",
	3: "FLOW_TCP_STATE_SYN_ACK_RCVD",
	4: "FLOW_TCP_STATE_CLOSING",
	5: "FLOW_TCP_STATE_CLOSE_WAIT",
	6: "FLOW_TCP_STATE_ESTABLISHED",
	7: "FLOW_TCP_STATE_CLOSED",
}
var FlowTCPState_value = map[string]int32{
	"FLOW_TCP_STATE_NONE":         0,
	"FLOW_TCP_STATE_INIT":         1,
	"FLOW_TCP_STATE_SYN_SENT":     2,
	"FLOW_TCP_STATE_SYN_ACK_RCVD": 3,
	"FLOW_TCP_STATE_CLOSING":      4,
	"FLOW_TCP_STATE_CLOSE_WAIT":   5,
	"FLOW_TCP_STATE_ESTABLISHED":  6,
	"FLOW_TCP_STATE_CLOSED":       7,
}

func (x FlowTCPState) String() string {
	return proto.EnumName(FlowTCPState_name, int32(x))
}
func (FlowTCPState) EnumDescriptor() ([]byte, []int) { return fileDescriptor5, []int{2} }

// Key for L2 flows (i.e, non-IP flows)
type FlowKeyL2 struct {
	Smac        uint64 `protobuf:"fixed64,1,opt,name=smac" json:"smac,omitempty"`
	Dmac        uint64 `protobuf:"fixed64,2,opt,name=dmac" json:"dmac,omitempty"`
	L2SegmentId uint32 `protobuf:"varint,3,opt,name=l2_segment_id,json=l2SegmentId" json:"l2_segment_id,omitempty"`
}

func (m *FlowKeyL2) Reset()                    { *m = FlowKeyL2{} }
func (m *FlowKeyL2) String() string            { return proto.CompactTextString(m) }
func (*FlowKeyL2) ProtoMessage()               {}
func (*FlowKeyL2) Descriptor() ([]byte, []int) { return fileDescriptor5, []int{0} }

func (m *FlowKeyL2) GetSmac() uint64 {
	if m != nil {
		return m.Smac
	}
	return 0
}

func (m *FlowKeyL2) GetDmac() uint64 {
	if m != nil {
		return m.Dmac
	}
	return 0
}

func (m *FlowKeyL2) GetL2SegmentId() uint32 {
	if m != nil {
		return m.L2SegmentId
	}
	return 0
}

type FlowKeyTcpUdpInfo struct {
	Sport uint32 `protobuf:"varint,1,opt,name=sport" json:"sport,omitempty"`
	Dport uint32 `protobuf:"varint,2,opt,name=dport" json:"dport,omitempty"`
}

func (m *FlowKeyTcpUdpInfo) Reset()                    { *m = FlowKeyTcpUdpInfo{} }
func (m *FlowKeyTcpUdpInfo) String() string            { return proto.CompactTextString(m) }
func (*FlowKeyTcpUdpInfo) ProtoMessage()               {}
func (*FlowKeyTcpUdpInfo) Descriptor() ([]byte, []int) { return fileDescriptor5, []int{1} }

func (m *FlowKeyTcpUdpInfo) GetSport() uint32 {
	if m != nil {
		return m.Sport
	}
	return 0
}

func (m *FlowKeyTcpUdpInfo) GetDport() uint32 {
	if m != nil {
		return m.Dport
	}
	return 0
}

type FlowKeyICMPInfo struct {
	Type uint32 `protobuf:"varint,1,opt,name=type" json:"type,omitempty"`
	Code uint32 `protobuf:"varint,2,opt,name=code" json:"code,omitempty"`
	Id   uint32 `protobuf:"varint,3,opt,name=id" json:"id,omitempty"`
}

func (m *FlowKeyICMPInfo) Reset()                    { *m = FlowKeyICMPInfo{} }
func (m *FlowKeyICMPInfo) String() string            { return proto.CompactTextString(m) }
func (*FlowKeyICMPInfo) ProtoMessage()               {}
func (*FlowKeyICMPInfo) Descriptor() ([]byte, []int) { return fileDescriptor5, []int{2} }

func (m *FlowKeyICMPInfo) GetType() uint32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *FlowKeyICMPInfo) GetCode() uint32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *FlowKeyICMPInfo) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

// Key for IPv4 flows
type FlowKeyV4 struct {
	Sip     uint32           `protobuf:"fixed32,1,opt,name=sip" json:"sip,omitempty"`
	Dip     uint32           `protobuf:"fixed32,2,opt,name=dip" json:"dip,omitempty"`
	IpProto types.IPProtocol `protobuf:"varint,3,opt,name=ip_proto,json=ipProto,enum=types.IPProtocol" json:"ip_proto,omitempty"`
	// TODO: add ICMP, AH, ESP etc. here
	//
	// Types that are valid to be assigned to L4Fields:
	//	*FlowKeyV4_TcpUdp
	//	*FlowKeyV4_Icmp
	L4Fields isFlowKeyV4_L4Fields `protobuf_oneof:"l4_fields"`
}

func (m *FlowKeyV4) Reset()                    { *m = FlowKeyV4{} }
func (m *FlowKeyV4) String() string            { return proto.CompactTextString(m) }
func (*FlowKeyV4) ProtoMessage()               {}
func (*FlowKeyV4) Descriptor() ([]byte, []int) { return fileDescriptor5, []int{3} }

type isFlowKeyV4_L4Fields interface {
	isFlowKeyV4_L4Fields()
}

type FlowKeyV4_TcpUdp struct {
	TcpUdp *FlowKeyTcpUdpInfo `protobuf:"bytes,4,opt,name=tcp_udp,json=tcpUdp,oneof"`
}
type FlowKeyV4_Icmp struct {
	Icmp *FlowKeyICMPInfo `protobuf:"bytes,5,opt,name=icmp,oneof"`
}

func (*FlowKeyV4_TcpUdp) isFlowKeyV4_L4Fields() {}
func (*FlowKeyV4_Icmp) isFlowKeyV4_L4Fields()   {}

func (m *FlowKeyV4) GetL4Fields() isFlowKeyV4_L4Fields {
	if m != nil {
		return m.L4Fields
	}
	return nil
}

func (m *FlowKeyV4) GetSip() uint32 {
	if m != nil {
		return m.Sip
	}
	return 0
}

func (m *FlowKeyV4) GetDip() uint32 {
	if m != nil {
		return m.Dip
	}
	return 0
}

func (m *FlowKeyV4) GetIpProto() types.IPProtocol {
	if m != nil {
		return m.IpProto
	}
	return types.IPProtocol_IP_PROTO_NONE
}

func (m *FlowKeyV4) GetTcpUdp() *FlowKeyTcpUdpInfo {
	if x, ok := m.GetL4Fields().(*FlowKeyV4_TcpUdp); ok {
		return x.TcpUdp
	}
	return nil
}

func (m *FlowKeyV4) GetIcmp() *FlowKeyICMPInfo {
	if x, ok := m.GetL4Fields().(*FlowKeyV4_Icmp); ok {
		return x.Icmp
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*FlowKeyV4) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _FlowKeyV4_OneofMarshaler, _FlowKeyV4_OneofUnmarshaler, _FlowKeyV4_OneofSizer, []interface{}{
		(*FlowKeyV4_TcpUdp)(nil),
		(*FlowKeyV4_Icmp)(nil),
	}
}

func _FlowKeyV4_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*FlowKeyV4)
	// l4_fields
	switch x := m.L4Fields.(type) {
	case *FlowKeyV4_TcpUdp:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.TcpUdp); err != nil {
			return err
		}
	case *FlowKeyV4_Icmp:
		b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Icmp); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("FlowKeyV4.L4Fields has unexpected type %T", x)
	}
	return nil
}

func _FlowKeyV4_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*FlowKeyV4)
	switch tag {
	case 4: // l4_fields.tcp_udp
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(FlowKeyTcpUdpInfo)
		err := b.DecodeMessage(msg)
		m.L4Fields = &FlowKeyV4_TcpUdp{msg}
		return true, err
	case 5: // l4_fields.icmp
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(FlowKeyICMPInfo)
		err := b.DecodeMessage(msg)
		m.L4Fields = &FlowKeyV4_Icmp{msg}
		return true, err
	default:
		return false, nil
	}
}

func _FlowKeyV4_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*FlowKeyV4)
	// l4_fields
	switch x := m.L4Fields.(type) {
	case *FlowKeyV4_TcpUdp:
		s := proto.Size(x.TcpUdp)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *FlowKeyV4_Icmp:
		s := proto.Size(x.Icmp)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Key for IPv6 flows
type FlowKeyV6 struct {
	Sip     *types.IPAddress `protobuf:"bytes,1,opt,name=sip" json:"sip,omitempty"`
	Dip     *types.IPAddress `protobuf:"bytes,2,opt,name=dip" json:"dip,omitempty"`
	IpProto types.IPProtocol `protobuf:"varint,3,opt,name=ip_proto,json=ipProto,enum=types.IPProtocol" json:"ip_proto,omitempty"`
	// TODO: add ICMPv6, AH, ESP etc. here
	//
	// Types that are valid to be assigned to L4Fields:
	//	*FlowKeyV6_TcpUdp
	//	*FlowKeyV6_Icmp
	L4Fields isFlowKeyV6_L4Fields `protobuf_oneof:"l4_fields"`
}

func (m *FlowKeyV6) Reset()                    { *m = FlowKeyV6{} }
func (m *FlowKeyV6) String() string            { return proto.CompactTextString(m) }
func (*FlowKeyV6) ProtoMessage()               {}
func (*FlowKeyV6) Descriptor() ([]byte, []int) { return fileDescriptor5, []int{4} }

type isFlowKeyV6_L4Fields interface {
	isFlowKeyV6_L4Fields()
}

type FlowKeyV6_TcpUdp struct {
	TcpUdp *FlowKeyTcpUdpInfo `protobuf:"bytes,4,opt,name=tcp_udp,json=tcpUdp,oneof"`
}
type FlowKeyV6_Icmp struct {
	Icmp *FlowKeyICMPInfo `protobuf:"bytes,5,opt,name=icmp,oneof"`
}

func (*FlowKeyV6_TcpUdp) isFlowKeyV6_L4Fields() {}
func (*FlowKeyV6_Icmp) isFlowKeyV6_L4Fields()   {}

func (m *FlowKeyV6) GetL4Fields() isFlowKeyV6_L4Fields {
	if m != nil {
		return m.L4Fields
	}
	return nil
}

func (m *FlowKeyV6) GetSip() *types.IPAddress {
	if m != nil {
		return m.Sip
	}
	return nil
}

func (m *FlowKeyV6) GetDip() *types.IPAddress {
	if m != nil {
		return m.Dip
	}
	return nil
}

func (m *FlowKeyV6) GetIpProto() types.IPProtocol {
	if m != nil {
		return m.IpProto
	}
	return types.IPProtocol_IP_PROTO_NONE
}

func (m *FlowKeyV6) GetTcpUdp() *FlowKeyTcpUdpInfo {
	if x, ok := m.GetL4Fields().(*FlowKeyV6_TcpUdp); ok {
		return x.TcpUdp
	}
	return nil
}

func (m *FlowKeyV6) GetIcmp() *FlowKeyICMPInfo {
	if x, ok := m.GetL4Fields().(*FlowKeyV6_Icmp); ok {
		return x.Icmp
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*FlowKeyV6) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _FlowKeyV6_OneofMarshaler, _FlowKeyV6_OneofUnmarshaler, _FlowKeyV6_OneofSizer, []interface{}{
		(*FlowKeyV6_TcpUdp)(nil),
		(*FlowKeyV6_Icmp)(nil),
	}
}

func _FlowKeyV6_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*FlowKeyV6)
	// l4_fields
	switch x := m.L4Fields.(type) {
	case *FlowKeyV6_TcpUdp:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.TcpUdp); err != nil {
			return err
		}
	case *FlowKeyV6_Icmp:
		b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Icmp); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("FlowKeyV6.L4Fields has unexpected type %T", x)
	}
	return nil
}

func _FlowKeyV6_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*FlowKeyV6)
	switch tag {
	case 4: // l4_fields.tcp_udp
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(FlowKeyTcpUdpInfo)
		err := b.DecodeMessage(msg)
		m.L4Fields = &FlowKeyV6_TcpUdp{msg}
		return true, err
	case 5: // l4_fields.icmp
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(FlowKeyICMPInfo)
		err := b.DecodeMessage(msg)
		m.L4Fields = &FlowKeyV6_Icmp{msg}
		return true, err
	default:
		return false, nil
	}
}

func _FlowKeyV6_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*FlowKeyV6)
	// l4_fields
	switch x := m.L4Fields.(type) {
	case *FlowKeyV6_TcpUdp:
		s := proto.Size(x.TcpUdp)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *FlowKeyV6_Icmp:
		s := proto.Size(x.Icmp)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// FlowKey is the key for uni-directional flow
type FlowKey struct {
	// Types that are valid to be assigned to FlowKey:
	//	*FlowKey_L2Key
	//	*FlowKey_V4Key
	//	*FlowKey_V6Key
	FlowKey isFlowKey_FlowKey `protobuf_oneof:"flow_key"`
}

func (m *FlowKey) Reset()                    { *m = FlowKey{} }
func (m *FlowKey) String() string            { return proto.CompactTextString(m) }
func (*FlowKey) ProtoMessage()               {}
func (*FlowKey) Descriptor() ([]byte, []int) { return fileDescriptor5, []int{5} }

type isFlowKey_FlowKey interface {
	isFlowKey_FlowKey()
}

type FlowKey_L2Key struct {
	L2Key *FlowKeyL2 `protobuf:"bytes,1,opt,name=l2_key,json=l2Key,oneof"`
}
type FlowKey_V4Key struct {
	V4Key *FlowKeyV4 `protobuf:"bytes,2,opt,name=v4_key,json=v4Key,oneof"`
}
type FlowKey_V6Key struct {
	V6Key *FlowKeyV6 `protobuf:"bytes,3,opt,name=v6_key,json=v6Key,oneof"`
}

func (*FlowKey_L2Key) isFlowKey_FlowKey() {}
func (*FlowKey_V4Key) isFlowKey_FlowKey() {}
func (*FlowKey_V6Key) isFlowKey_FlowKey() {}

func (m *FlowKey) GetFlowKey() isFlowKey_FlowKey {
	if m != nil {
		return m.FlowKey
	}
	return nil
}

func (m *FlowKey) GetL2Key() *FlowKeyL2 {
	if x, ok := m.GetFlowKey().(*FlowKey_L2Key); ok {
		return x.L2Key
	}
	return nil
}

func (m *FlowKey) GetV4Key() *FlowKeyV4 {
	if x, ok := m.GetFlowKey().(*FlowKey_V4Key); ok {
		return x.V4Key
	}
	return nil
}

func (m *FlowKey) GetV6Key() *FlowKeyV6 {
	if x, ok := m.GetFlowKey().(*FlowKey_V6Key); ok {
		return x.V6Key
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*FlowKey) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _FlowKey_OneofMarshaler, _FlowKey_OneofUnmarshaler, _FlowKey_OneofSizer, []interface{}{
		(*FlowKey_L2Key)(nil),
		(*FlowKey_V4Key)(nil),
		(*FlowKey_V6Key)(nil),
	}
}

func _FlowKey_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*FlowKey)
	// flow_key
	switch x := m.FlowKey.(type) {
	case *FlowKey_L2Key:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.L2Key); err != nil {
			return err
		}
	case *FlowKey_V4Key:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.V4Key); err != nil {
			return err
		}
	case *FlowKey_V6Key:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.V6Key); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("FlowKey.FlowKey has unexpected type %T", x)
	}
	return nil
}

func _FlowKey_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*FlowKey)
	switch tag {
	case 1: // flow_key.l2_key
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(FlowKeyL2)
		err := b.DecodeMessage(msg)
		m.FlowKey = &FlowKey_L2Key{msg}
		return true, err
	case 2: // flow_key.v4_key
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(FlowKeyV4)
		err := b.DecodeMessage(msg)
		m.FlowKey = &FlowKey_V4Key{msg}
		return true, err
	case 3: // flow_key.v6_key
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(FlowKeyV6)
		err := b.DecodeMessage(msg)
		m.FlowKey = &FlowKey_V6Key{msg}
		return true, err
	default:
		return false, nil
	}
}

func _FlowKey_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*FlowKey)
	// flow_key
	switch x := m.FlowKey.(type) {
	case *FlowKey_L2Key:
		s := proto.Size(x.L2Key)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *FlowKey_V4Key:
		s := proto.Size(x.V4Key)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *FlowKey_V6Key:
		s := proto.Size(x.V6Key)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// FlowInfo contains flow information like counters, forwarding information,
// NAT rewrite information etc.
type FlowInfo struct {
	FlowAction FlowAction       `protobuf:"varint,1,opt,name=flow_action,json=flowAction,enum=halproto.FlowAction" json:"flow_action,omitempty"`
	NatType    NatType          `protobuf:"varint,2,opt,name=nat_type,json=natType,enum=halproto.NatType" json:"nat_type,omitempty"`
	NatSip     *types.IPAddress `protobuf:"bytes,3,opt,name=nat_sip,json=natSip" json:"nat_sip,omitempty"`
	NatSport   uint32           `protobuf:"varint,4,opt,name=nat_sport,json=natSport" json:"nat_sport,omitempty"`
	NatDip     *types.IPAddress `protobuf:"bytes,5,opt,name=nat_dip,json=natDip" json:"nat_dip,omitempty"`
	NatDport   uint32           `protobuf:"varint,6,opt,name=nat_dport,json=natDport" json:"nat_dport,omitempty"`
	TcpState   FlowTCPState     `protobuf:"varint,7,opt,name=tcp_state,json=tcpState,enum=halproto.FlowTCPState" json:"tcp_state,omitempty"`
}

func (m *FlowInfo) Reset()                    { *m = FlowInfo{} }
func (m *FlowInfo) String() string            { return proto.CompactTextString(m) }
func (*FlowInfo) ProtoMessage()               {}
func (*FlowInfo) Descriptor() ([]byte, []int) { return fileDescriptor5, []int{6} }

func (m *FlowInfo) GetFlowAction() FlowAction {
	if m != nil {
		return m.FlowAction
	}
	return FlowAction_FLOW_ACTION_NONE
}

func (m *FlowInfo) GetNatType() NatType {
	if m != nil {
		return m.NatType
	}
	return NatType_NAT_TYPE_NONE
}

func (m *FlowInfo) GetNatSip() *types.IPAddress {
	if m != nil {
		return m.NatSip
	}
	return nil
}

func (m *FlowInfo) GetNatSport() uint32 {
	if m != nil {
		return m.NatSport
	}
	return 0
}

func (m *FlowInfo) GetNatDip() *types.IPAddress {
	if m != nil {
		return m.NatDip
	}
	return nil
}

func (m *FlowInfo) GetNatDport() uint32 {
	if m != nil {
		return m.NatDport
	}
	return 0
}

func (m *FlowInfo) GetTcpState() FlowTCPState {
	if m != nil {
		return m.TcpState
	}
	return FlowTCPState_FLOW_TCP_STATE_NONE
}

// ConnTrackInfo contains dynamic information that was recorded due to connection tracking
type ConnTrackInfo struct {
	FlowCreateTs  uint64 `protobuf:"fixed64,1,opt,name=flow_create_ts,json=flowCreateTs" json:"flow_create_ts,omitempty"`
	FlowBytes     uint64 `protobuf:"fixed64,2,opt,name=flow_bytes,json=flowBytes" json:"flow_bytes,omitempty"`
	FlowPackets   uint32 `protobuf:"fixed32,3,opt,name=flow_packets,json=flowPackets" json:"flow_packets,omitempty"`
	ExceptionBits uint32 `protobuf:"fixed32,4,opt,name=exception_bits,json=exceptionBits" json:"exception_bits,omitempty"`
	TcpSeqNum     uint32 `protobuf:"fixed32,5,opt,name=tcp_seq_num,json=tcpSeqNum" json:"tcp_seq_num,omitempty"`
	TcpSeqDelta   int32  `protobuf:"fixed32,6,opt,name=tcp_seq_delta,json=tcpSeqDelta" json:"tcp_seq_delta,omitempty"`
	TcpAckNum     uint32 `protobuf:"fixed32,7,opt,name=tcp_ack_num,json=tcpAckNum" json:"tcp_ack_num,omitempty"`
	TcpAckDelta   int32  `protobuf:"fixed32,8,opt,name=tcp_ack_delta,json=tcpAckDelta" json:"tcp_ack_delta,omitempty"`
	TcpWinSz      uint32 `protobuf:"varint,9,opt,name=tcp_win_sz,json=tcpWinSz" json:"tcp_win_sz,omitempty"`
	TcpWinScale   uint32 `protobuf:"varint,10,opt,name=tcp_win_scale,json=tcpWinScale" json:"tcp_win_scale,omitempty"`
	TcpMss        uint32 `protobuf:"varint,11,opt,name=tcp_mss,json=tcpMss" json:"tcp_mss,omitempty"`
	TcpTsOption   bool   `protobuf:"varint,12,opt,name=tcp_ts_option,json=tcpTsOption" json:"tcp_ts_option,omitempty"`
}

func (m *ConnTrackInfo) Reset()                    { *m = ConnTrackInfo{} }
func (m *ConnTrackInfo) String() string            { return proto.CompactTextString(m) }
func (*ConnTrackInfo) ProtoMessage()               {}
func (*ConnTrackInfo) Descriptor() ([]byte, []int) { return fileDescriptor5, []int{7} }

func (m *ConnTrackInfo) GetFlowCreateTs() uint64 {
	if m != nil {
		return m.FlowCreateTs
	}
	return 0
}

func (m *ConnTrackInfo) GetFlowBytes() uint64 {
	if m != nil {
		return m.FlowBytes
	}
	return 0
}

func (m *ConnTrackInfo) GetFlowPackets() uint32 {
	if m != nil {
		return m.FlowPackets
	}
	return 0
}

func (m *ConnTrackInfo) GetExceptionBits() uint32 {
	if m != nil {
		return m.ExceptionBits
	}
	return 0
}

func (m *ConnTrackInfo) GetTcpSeqNum() uint32 {
	if m != nil {
		return m.TcpSeqNum
	}
	return 0
}

func (m *ConnTrackInfo) GetTcpSeqDelta() int32 {
	if m != nil {
		return m.TcpSeqDelta
	}
	return 0
}

func (m *ConnTrackInfo) GetTcpAckNum() uint32 {
	if m != nil {
		return m.TcpAckNum
	}
	return 0
}

func (m *ConnTrackInfo) GetTcpAckDelta() int32 {
	if m != nil {
		return m.TcpAckDelta
	}
	return 0
}

func (m *ConnTrackInfo) GetTcpWinSz() uint32 {
	if m != nil {
		return m.TcpWinSz
	}
	return 0
}

func (m *ConnTrackInfo) GetTcpWinScale() uint32 {
	if m != nil {
		return m.TcpWinScale
	}
	return 0
}

func (m *ConnTrackInfo) GetTcpMss() uint32 {
	if m != nil {
		return m.TcpMss
	}
	return 0
}

func (m *ConnTrackInfo) GetTcpTsOption() bool {
	if m != nil {
		return m.TcpTsOption
	}
	return false
}

// FlowData captures all the flow information
type FlowData struct {
	FlowInfo      *FlowInfo      `protobuf:"bytes,1,opt,name=flow_info,json=flowInfo" json:"flow_info,omitempty"`
	ConnTrackInfo *ConnTrackInfo `protobuf:"bytes,2,opt,name=conn_track_info,json=connTrackInfo" json:"conn_track_info,omitempty"`
}

func (m *FlowData) Reset()                    { *m = FlowData{} }
func (m *FlowData) String() string            { return proto.CompactTextString(m) }
func (*FlowData) ProtoMessage()               {}
func (*FlowData) Descriptor() ([]byte, []int) { return fileDescriptor5, []int{8} }

func (m *FlowData) GetFlowInfo() *FlowInfo {
	if m != nil {
		return m.FlowInfo
	}
	return nil
}

func (m *FlowData) GetConnTrackInfo() *ConnTrackInfo {
	if m != nil {
		return m.ConnTrackInfo
	}
	return nil
}

// FlowSpec contains all information needed to install a uni-directional flow
//   - FlowKey is the key to uniquely identify a flow
//   - FlowInfo contains flow information like counters, forwarding information,
//     NAT rewrite information etc.
//   - ConnTrackInfo contains all the information gathered so far about the flow
//     when connection tracking is enabled. In vMotion case, this will be
//     carried from old location to new location
type FlowSpec struct {
	FlowKey  *FlowKey  `protobuf:"bytes,1,opt,name=flow_key,json=flowKey" json:"flow_key,omitempty"`
	FlowData *FlowData `protobuf:"bytes,2,opt,name=flow_data,json=flowData" json:"flow_data,omitempty"`
}

func (m *FlowSpec) Reset()                    { *m = FlowSpec{} }
func (m *FlowSpec) String() string            { return proto.CompactTextString(m) }
func (*FlowSpec) ProtoMessage()               {}
func (*FlowSpec) Descriptor() ([]byte, []int) { return fileDescriptor5, []int{9} }

func (m *FlowSpec) GetFlowKey() *FlowKey {
	if m != nil {
		return m.FlowKey
	}
	return nil
}

func (m *FlowSpec) GetFlowData() *FlowData {
	if m != nil {
		return m.FlowData
	}
	return nil
}

// SessionSpec represents a full session with forward and reverse flow
// It is possible to have a session with just one flow (for L2 mcast/bcast)
type SessionSpec struct {
	Meta          *types.ObjectMeta `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	SessionId     uint32            `protobuf:"fixed32,2,opt,name=session_id,json=sessionId" json:"session_id,omitempty"`
	ConnTrackEn   bool              `protobuf:"varint,3,opt,name=conn_track_en,json=connTrackEn" json:"conn_track_en,omitempty"`
	InitiatorFlow *FlowSpec         `protobuf:"bytes,4,opt,name=initiator_flow,json=initiatorFlow" json:"initiator_flow,omitempty"`
	ResponderFlow *FlowSpec         `protobuf:"bytes,5,opt,name=responder_flow,json=responderFlow" json:"responder_flow,omitempty"`
}

func (m *SessionSpec) Reset()                    { *m = SessionSpec{} }
func (m *SessionSpec) String() string            { return proto.CompactTextString(m) }
func (*SessionSpec) ProtoMessage()               {}
func (*SessionSpec) Descriptor() ([]byte, []int) { return fileDescriptor5, []int{10} }

func (m *SessionSpec) GetMeta() *types.ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *SessionSpec) GetSessionId() uint32 {
	if m != nil {
		return m.SessionId
	}
	return 0
}

func (m *SessionSpec) GetConnTrackEn() bool {
	if m != nil {
		return m.ConnTrackEn
	}
	return false
}

func (m *SessionSpec) GetInitiatorFlow() *FlowSpec {
	if m != nil {
		return m.InitiatorFlow
	}
	return nil
}

func (m *SessionSpec) GetResponderFlow() *FlowSpec {
	if m != nil {
		return m.ResponderFlow
	}
	return nil
}

// SessionRequestMsg is batched session request message
type SessionRequestMsg struct {
	Request []*SessionSpec `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *SessionRequestMsg) Reset()                    { *m = SessionRequestMsg{} }
func (m *SessionRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*SessionRequestMsg) ProtoMessage()               {}
func (*SessionRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptor5, []int{11} }

func (m *SessionRequestMsg) GetRequest() []*SessionSpec {
	if m != nil {
		return m.Request
	}
	return nil
}

// FlowStatus captures the operational status of flows
// TODO - add all the indices we allocated internally - rewrite indices,
// dst lif or mcast replication index, rtt info etc.
type FlowStatus struct {
	FlowHandle    uint64         `protobuf:"fixed64,1,opt,name=flow_handle,json=flowHandle" json:"flow_handle,omitempty"`
	ConnTrackInfo *ConnTrackInfo `protobuf:"bytes,2,opt,name=conn_track_info,json=connTrackInfo" json:"conn_track_info,omitempty"`
}

func (m *FlowStatus) Reset()                    { *m = FlowStatus{} }
func (m *FlowStatus) String() string            { return proto.CompactTextString(m) }
func (*FlowStatus) ProtoMessage()               {}
func (*FlowStatus) Descriptor() ([]byte, []int) { return fileDescriptor5, []int{12} }

func (m *FlowStatus) GetFlowHandle() uint64 {
	if m != nil {
		return m.FlowHandle
	}
	return 0
}

func (m *FlowStatus) GetConnTrackInfo() *ConnTrackInfo {
	if m != nil {
		return m.ConnTrackInfo
	}
	return nil
}

// SessionStatus captures the operational status of the session
type SessionStatus struct {
	SessionHandle uint64      `protobuf:"fixed64,1,opt,name=session_handle,json=sessionHandle" json:"session_handle,omitempty"`
	IflowStatus   *FlowStatus `protobuf:"bytes,2,opt,name=iflow_status,json=iflowStatus" json:"iflow_status,omitempty"`
	RflowStatus   *FlowStatus `protobuf:"bytes,3,opt,name=rflow_status,json=rflowStatus" json:"rflow_status,omitempty"`
}

func (m *SessionStatus) Reset()                    { *m = SessionStatus{} }
func (m *SessionStatus) String() string            { return proto.CompactTextString(m) }
func (*SessionStatus) ProtoMessage()               {}
func (*SessionStatus) Descriptor() ([]byte, []int) { return fileDescriptor5, []int{13} }

func (m *SessionStatus) GetSessionHandle() uint64 {
	if m != nil {
		return m.SessionHandle
	}
	return 0
}

func (m *SessionStatus) GetIflowStatus() *FlowStatus {
	if m != nil {
		return m.IflowStatus
	}
	return nil
}

func (m *SessionStatus) GetRflowStatus() *FlowStatus {
	if m != nil {
		return m.RflowStatus
	}
	return nil
}

// SessionResponse is the response to one SessionSpec
type SessionResponse struct {
	ApiStatus types.ApiStatus `protobuf:"varint,1,opt,name=api_status,json=apiStatus,enum=types.ApiStatus" json:"api_status,omitempty"`
	Status    *SessionStatus  `protobuf:"bytes,2,opt,name=status" json:"status,omitempty"`
}

func (m *SessionResponse) Reset()                    { *m = SessionResponse{} }
func (m *SessionResponse) String() string            { return proto.CompactTextString(m) }
func (*SessionResponse) ProtoMessage()               {}
func (*SessionResponse) Descriptor() ([]byte, []int) { return fileDescriptor5, []int{14} }

func (m *SessionResponse) GetApiStatus() types.ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return types.ApiStatus_API_STATUS_OK
}

func (m *SessionResponse) GetStatus() *SessionStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

// SessionResponseMsg is the response to SessionRequestMsg
type SessionResponseMsg struct {
	Response []*SessionResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *SessionResponseMsg) Reset()                    { *m = SessionResponseMsg{} }
func (m *SessionResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*SessionResponseMsg) ProtoMessage()               {}
func (*SessionResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptor5, []int{15} }

func (m *SessionResponseMsg) GetResponse() []*SessionResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

// SessionDeleteRequest is used to delete a session
type SessionDeleteRequest struct {
	Meta          *types.ObjectMeta `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	SessionHandle uint64            `protobuf:"fixed64,2,opt,name=session_handle,json=sessionHandle" json:"session_handle,omitempty"`
}

func (m *SessionDeleteRequest) Reset()                    { *m = SessionDeleteRequest{} }
func (m *SessionDeleteRequest) String() string            { return proto.CompactTextString(m) }
func (*SessionDeleteRequest) ProtoMessage()               {}
func (*SessionDeleteRequest) Descriptor() ([]byte, []int) { return fileDescriptor5, []int{16} }

func (m *SessionDeleteRequest) GetMeta() *types.ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *SessionDeleteRequest) GetSessionHandle() uint64 {
	if m != nil {
		return m.SessionHandle
	}
	return 0
}

// SessionDeleteRequestMsg is batched session delete request
type SessionDeleteRequestMsg struct {
	Request []*SessionDeleteRequest `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *SessionDeleteRequestMsg) Reset()                    { *m = SessionDeleteRequestMsg{} }
func (m *SessionDeleteRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*SessionDeleteRequestMsg) ProtoMessage()               {}
func (*SessionDeleteRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptor5, []int{17} }

func (m *SessionDeleteRequestMsg) GetRequest() []*SessionDeleteRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

// SessionDeleteResponseMsg is batched response to SessionDeleteRequestMsg
type SessionDeleteResponseMsg struct {
	ApiStatus []types.ApiStatus `protobuf:"varint,1,rep,packed,name=api_status,json=apiStatus,enum=types.ApiStatus" json:"api_status,omitempty"`
}

func (m *SessionDeleteResponseMsg) Reset()                    { *m = SessionDeleteResponseMsg{} }
func (m *SessionDeleteResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*SessionDeleteResponseMsg) ProtoMessage()               {}
func (*SessionDeleteResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptor5, []int{18} }

func (m *SessionDeleteResponseMsg) GetApiStatus() []types.ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return nil
}

// SessionGetRequest  is used to get information about a session
type SessionGetRequest struct {
	Meta          *types.ObjectMeta `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	SessionHandle uint64            `protobuf:"fixed64,2,opt,name=session_handle,json=sessionHandle" json:"session_handle,omitempty"`
}

func (m *SessionGetRequest) Reset()                    { *m = SessionGetRequest{} }
func (m *SessionGetRequest) String() string            { return proto.CompactTextString(m) }
func (*SessionGetRequest) ProtoMessage()               {}
func (*SessionGetRequest) Descriptor() ([]byte, []int) { return fileDescriptor5, []int{19} }

func (m *SessionGetRequest) GetMeta() *types.ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *SessionGetRequest) GetSessionHandle() uint64 {
	if m != nil {
		return m.SessionHandle
	}
	return 0
}

// SessionGetRequestMsg  is batched get request
type SessionGetRequestMsg struct {
	Request []*SessionGetRequest `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *SessionGetRequestMsg) Reset()                    { *m = SessionGetRequestMsg{} }
func (m *SessionGetRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*SessionGetRequestMsg) ProtoMessage()               {}
func (*SessionGetRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptor5, []int{20} }

func (m *SessionGetRequestMsg) GetRequest() []*SessionGetRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

// FlowStats contains all the stats collected per flow
// TODO - Srini please add all that we have in P4 for now
type FlowStats struct {
	FlowPackets   uint32 `protobuf:"fixed32,1,opt,name=flow_packets,json=flowPackets" json:"flow_packets,omitempty"`
	FlowBytes     uint64 `protobuf:"fixed64,2,opt,name=flow_bytes,json=flowBytes" json:"flow_bytes,omitempty"`
	RexmitPackets uint32 `protobuf:"fixed32,3,opt,name=rexmit_packets,json=rexmitPackets" json:"rexmit_packets,omitempty"`
}

func (m *FlowStats) Reset()                    { *m = FlowStats{} }
func (m *FlowStats) String() string            { return proto.CompactTextString(m) }
func (*FlowStats) ProtoMessage()               {}
func (*FlowStats) Descriptor() ([]byte, []int) { return fileDescriptor5, []int{21} }

func (m *FlowStats) GetFlowPackets() uint32 {
	if m != nil {
		return m.FlowPackets
	}
	return 0
}

func (m *FlowStats) GetFlowBytes() uint64 {
	if m != nil {
		return m.FlowBytes
	}
	return 0
}

func (m *FlowStats) GetRexmitPackets() uint32 {
	if m != nil {
		return m.RexmitPackets
	}
	return 0
}

// SessionStats captures statistics of all its constituent flows
type SessionStats struct {
	FlowStats []*FlowStats `protobuf:"bytes,1,rep,name=flow_stats,json=flowStats" json:"flow_stats,omitempty"`
}

func (m *SessionStats) Reset()                    { *m = SessionStats{} }
func (m *SessionStats) String() string            { return proto.CompactTextString(m) }
func (*SessionStats) ProtoMessage()               {}
func (*SessionStats) Descriptor() ([]byte, []int) { return fileDescriptor5, []int{22} }

func (m *SessionStats) GetFlowStats() []*FlowStats {
	if m != nil {
		return m.FlowStats
	}
	return nil
}

// SessionGetResponse is response to one SessionGetRequest
type SessionGetResponse struct {
	SessionSpec   *SessionSpec   `protobuf:"bytes,1,opt,name=session_spec,json=sessionSpec" json:"session_spec,omitempty"`
	SessionStatus *SessionStatus `protobuf:"bytes,2,opt,name=session_status,json=sessionStatus" json:"session_status,omitempty"`
	SessionStats  *SessionStats  `protobuf:"bytes,3,opt,name=session_stats,json=sessionStats" json:"session_stats,omitempty"`
}

func (m *SessionGetResponse) Reset()                    { *m = SessionGetResponse{} }
func (m *SessionGetResponse) String() string            { return proto.CompactTextString(m) }
func (*SessionGetResponse) ProtoMessage()               {}
func (*SessionGetResponse) Descriptor() ([]byte, []int) { return fileDescriptor5, []int{23} }

func (m *SessionGetResponse) GetSessionSpec() *SessionSpec {
	if m != nil {
		return m.SessionSpec
	}
	return nil
}

func (m *SessionGetResponse) GetSessionStatus() *SessionStatus {
	if m != nil {
		return m.SessionStatus
	}
	return nil
}

func (m *SessionGetResponse) GetSessionStats() *SessionStats {
	if m != nil {
		return m.SessionStats
	}
	return nil
}

// SesssionGetResponseMsg is batched response to SesssionGetRequestMsg
type SessionGetResponseMsg struct {
	Response []*SessionGetResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *SessionGetResponseMsg) Reset()                    { *m = SessionGetResponseMsg{} }
func (m *SessionGetResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*SessionGetResponseMsg) ProtoMessage()               {}
func (*SessionGetResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptor5, []int{24} }

func (m *SessionGetResponseMsg) GetResponse() []*SessionGetResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

func init() {
	proto.RegisterType((*FlowKeyL2)(nil), "halproto.FlowKeyL2")
	proto.RegisterType((*FlowKeyTcpUdpInfo)(nil), "halproto.FlowKeyTcpUdpInfo")
	proto.RegisterType((*FlowKeyICMPInfo)(nil), "halproto.FlowKeyICMPInfo")
	proto.RegisterType((*FlowKeyV4)(nil), "halproto.FlowKeyV4")
	proto.RegisterType((*FlowKeyV6)(nil), "halproto.FlowKeyV6")
	proto.RegisterType((*FlowKey)(nil), "halproto.FlowKey")
	proto.RegisterType((*FlowInfo)(nil), "halproto.FlowInfo")
	proto.RegisterType((*ConnTrackInfo)(nil), "halproto.ConnTrackInfo")
	proto.RegisterType((*FlowData)(nil), "halproto.FlowData")
	proto.RegisterType((*FlowSpec)(nil), "halproto.FlowSpec")
	proto.RegisterType((*SessionSpec)(nil), "halproto.SessionSpec")
	proto.RegisterType((*SessionRequestMsg)(nil), "halproto.SessionRequestMsg")
	proto.RegisterType((*FlowStatus)(nil), "halproto.FlowStatus")
	proto.RegisterType((*SessionStatus)(nil), "halproto.SessionStatus")
	proto.RegisterType((*SessionResponse)(nil), "halproto.SessionResponse")
	proto.RegisterType((*SessionResponseMsg)(nil), "halproto.SessionResponseMsg")
	proto.RegisterType((*SessionDeleteRequest)(nil), "halproto.SessionDeleteRequest")
	proto.RegisterType((*SessionDeleteRequestMsg)(nil), "halproto.SessionDeleteRequestMsg")
	proto.RegisterType((*SessionDeleteResponseMsg)(nil), "halproto.SessionDeleteResponseMsg")
	proto.RegisterType((*SessionGetRequest)(nil), "halproto.SessionGetRequest")
	proto.RegisterType((*SessionGetRequestMsg)(nil), "halproto.SessionGetRequestMsg")
	proto.RegisterType((*FlowStats)(nil), "halproto.FlowStats")
	proto.RegisterType((*SessionStats)(nil), "halproto.SessionStats")
	proto.RegisterType((*SessionGetResponse)(nil), "halproto.SessionGetResponse")
	proto.RegisterType((*SessionGetResponseMsg)(nil), "halproto.SessionGetResponseMsg")
	proto.RegisterEnum("halproto.NatType", NatType_name, NatType_value)
	proto.RegisterEnum("halproto.FlowAction", FlowAction_name, FlowAction_value)
	proto.RegisterEnum("halproto.FlowTCPState", FlowTCPState_name, FlowTCPState_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Session service

type SessionClient interface {
	SessionCreate(ctx context.Context, in *SessionRequestMsg, opts ...grpc.CallOption) (*SessionResponseMsg, error)
	SessionDelete(ctx context.Context, in *SessionDeleteRequestMsg, opts ...grpc.CallOption) (*SessionDeleteResponseMsg, error)
	SessionGet(ctx context.Context, in *SessionGetRequestMsg, opts ...grpc.CallOption) (*SessionGetResponseMsg, error)
}

type sessionClient struct {
	cc *grpc.ClientConn
}

func NewSessionClient(cc *grpc.ClientConn) SessionClient {
	return &sessionClient{cc}
}

func (c *sessionClient) SessionCreate(ctx context.Context, in *SessionRequestMsg, opts ...grpc.CallOption) (*SessionResponseMsg, error) {
	out := new(SessionResponseMsg)
	err := grpc.Invoke(ctx, "/halproto.Session/SessionCreate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sessionClient) SessionDelete(ctx context.Context, in *SessionDeleteRequestMsg, opts ...grpc.CallOption) (*SessionDeleteResponseMsg, error) {
	out := new(SessionDeleteResponseMsg)
	err := grpc.Invoke(ctx, "/halproto.Session/SessionDelete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sessionClient) SessionGet(ctx context.Context, in *SessionGetRequestMsg, opts ...grpc.CallOption) (*SessionGetResponseMsg, error) {
	out := new(SessionGetResponseMsg)
	err := grpc.Invoke(ctx, "/halproto.Session/SessionGet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Session service

type SessionServer interface {
	SessionCreate(context.Context, *SessionRequestMsg) (*SessionResponseMsg, error)
	SessionDelete(context.Context, *SessionDeleteRequestMsg) (*SessionDeleteResponseMsg, error)
	SessionGet(context.Context, *SessionGetRequestMsg) (*SessionGetResponseMsg, error)
}

func RegisterSessionServer(s *grpc.Server, srv SessionServer) {
	s.RegisterService(&_Session_serviceDesc, srv)
}

func _Session_SessionCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SessionRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SessionServer).SessionCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/halproto.Session/SessionCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SessionServer).SessionCreate(ctx, req.(*SessionRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Session_SessionDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SessionDeleteRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SessionServer).SessionDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/halproto.Session/SessionDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SessionServer).SessionDelete(ctx, req.(*SessionDeleteRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Session_SessionGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SessionGetRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SessionServer).SessionGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/halproto.Session/SessionGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SessionServer).SessionGet(ctx, req.(*SessionGetRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

var _Session_serviceDesc = grpc.ServiceDesc{
	ServiceName: "halproto.Session",
	HandlerType: (*SessionServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SessionCreate",
			Handler:    _Session_SessionCreate_Handler,
		},
		{
			MethodName: "SessionDelete",
			Handler:    _Session_SessionDelete_Handler,
		},
		{
			MethodName: "SessionGet",
			Handler:    _Session_SessionGet_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "session.proto",
}

func init() { proto.RegisterFile("session.proto", fileDescriptor5) }

var fileDescriptor5 = []byte{
	// 1585 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xd4, 0x57, 0x4d, 0x4f, 0x1b, 0xdd,
	0x15, 0xc6, 0x36, 0x78, 0xec, 0x63, 0x1b, 0xcc, 0x0d, 0x1f, 0x06, 0xf2, 0x12, 0xde, 0x51, 0x91,
	0x68, 0xf4, 0x0a, 0x24, 0x87, 0x90, 0x54, 0x95, 0x1a, 0x19, 0xdb, 0x09, 0x16, 0xc6, 0x76, 0x67,
	0xa6, 0xa1, 0xe9, 0x66, 0x34, 0xcc, 0x5c, 0x92, 0x29, 0xf6, 0xcc, 0xc4, 0xf7, 0x92, 0x84, 0xa8,
	0xab, 0xfe, 0x91, 0xae, 0x2a, 0xf5, 0x07, 0xf4, 0x5f, 0x74, 0xd9, 0xdf, 0xd1, 0x5d, 0xa5, 0x6e,
	0xab, 0x7b, 0xee, 0x9d, 0xf1, 0x27, 0x24, 0x52, 0xd5, 0xc5, 0xbb, 0x41, 0xc7, 0xe7, 0xe3, 0x39,
	0xdf, 0xe7, 0x0e, 0x50, 0x62, 0x94, 0x31, 0x3f, 0x0c, 0x0e, 0xa3, 0x61, 0xc8, 0x43, 0x92, 0xfb,
	0xe0, 0xf4, 0x91, 0xda, 0x5e, 0xe5, 0x77, 0x11, 0x65, 0x47, 0xf8, 0x57, 0x0a, 0xf5, 0x4b, 0xc8,
	0xbf, 0xee, 0x87, 0x9f, 0xcf, 0xe9, 0x5d, 0xbb, 0x4a, 0x08, 0x2c, 0xb2, 0x81, 0xe3, 0x56, 0x52,
	0x7b, 0xa9, 0x83, 0xac, 0x81, 0xb4, 0xe0, 0x79, 0x82, 0x97, 0x96, 0x3c, 0x41, 0x13, 0x1d, 0x4a,
	0xfd, 0xaa, 0xcd, 0xe8, 0xfb, 0x01, 0x0d, 0xb8, 0xed, 0x7b, 0x95, 0xcc, 0x5e, 0xea, 0xa0, 0x64,
	0x14, 0xfa, 0x55, 0x53, 0xf2, 0x5a, 0x9e, 0xfe, 0x0a, 0x56, 0x15, 0xb0, 0xe5, 0x46, 0xbf, 0xf3,
	0xa2, 0x56, 0x70, 0x1d, 0x92, 0x35, 0x58, 0x62, 0x51, 0x38, 0xe4, 0xe8, 0xa1, 0x64, 0xc8, 0x1f,
	0x82, 0xeb, 0x21, 0x37, 0x2d, 0xb9, 0xf8, 0x43, 0x6f, 0xc1, 0x8a, 0x02, 0x68, 0xd5, 0x2f, 0x7a,
	0x68, 0x4e, 0x60, 0x51, 0xc4, 0xae, 0xac, 0x91, 0x16, 0x3c, 0x37, 0xf4, 0xa8, 0xb2, 0x45, 0x9a,
	0x2c, 0x43, 0x3a, 0x09, 0x2a, 0xed, 0x7b, 0xfa, 0x3f, 0x53, 0x49, 0x96, 0x6f, 0x8f, 0x49, 0x19,
	0x32, 0xcc, 0x8f, 0x10, 0x44, 0x33, 0x04, 0x29, 0x38, 0x9e, 0x1f, 0x21, 0x84, 0x66, 0x08, 0x92,
	0xfc, 0x04, 0x39, 0x3f, 0xb2, 0xb1, 0x44, 0x88, 0xb3, 0x5c, 0x5d, 0x3d, 0x94, 0x65, 0x6b, 0xf5,
	0x7a, 0x82, 0xeb, 0x86, 0x7d, 0x43, 0xf3, 0x23, 0xa4, 0xc9, 0x09, 0x68, 0xdc, 0x8d, 0xec, 0x5b,
	0x2f, 0xaa, 0x2c, 0xee, 0xa5, 0x0e, 0x0a, 0xd5, 0x9d, 0xc3, 0xb8, 0xe6, 0x87, 0x33, 0x45, 0x38,
	0x5b, 0x30, 0xb2, 0x1c, 0x7f, 0x91, 0x23, 0x58, 0xf4, 0xdd, 0x41, 0x54, 0x59, 0x42, 0xa3, 0xad,
	0x19, 0xa3, 0x38, 0xf1, 0xb3, 0x05, 0x03, 0x15, 0x4f, 0x0b, 0x90, 0xef, 0x1f, 0xdb, 0xd7, 0x3e,
	0xed, 0x7b, 0x4c, 0xff, 0xcf, 0x58, 0x56, 0x27, 0x44, 0x1f, 0x65, 0x55, 0xa8, 0x96, 0x93, 0x60,
	0x6b, 0x9e, 0x37, 0xa4, 0x8c, 0xc9, 0x3c, 0xf5, 0x51, 0x9e, 0x73, 0x75, 0x7e, 0x2e, 0x99, 0xff,
	0x25, 0x05, 0x9a, 0x52, 0x24, 0x3f, 0x41, 0xb6, 0x5f, 0xb5, 0x6f, 0xe8, 0x9d, 0x4a, 0xfd, 0xd1,
	0x0c, 0x56, 0xbb, 0x7a, 0xb6, 0x60, 0x2c, 0xf5, 0xab, 0x4a, 0xfb, 0xd3, 0x31, 0x6a, 0xa7, 0xef,
	0xd1, 0x7e, 0x7b, 0x2c, 0xb4, 0x3f, 0x1d, 0xc7, 0xda, 0x27, 0xa8, 0x9d, 0xb9, 0x4f, 0xfb, 0x04,
	0xb5, 0x4f, 0xce, 0xe9, 0xdd, 0x29, 0x40, 0xee, 0xba, 0x1f, 0x7e, 0x16, 0xfa, 0xfa, 0xdf, 0xd3,
	0x90, 0x13, 0x2a, 0x38, 0xb6, 0xcf, 0xa1, 0x80, 0x02, 0xc7, 0xe5, 0x7e, 0x18, 0x60, 0x9c, 0xcb,
	0xd5, 0xb5, 0x49, 0xac, 0x1a, 0xca, 0x0c, 0xb8, 0x4e, 0x68, 0xd1, 0x89, 0xc0, 0xe1, 0x36, 0x4e,
	0x7c, 0x5a, 0x75, 0x22, 0xb1, 0xe9, 0x38, 0xdc, 0xba, 0x8b, 0xa8, 0xa1, 0x05, 0x92, 0x20, 0xbf,
	0x04, 0x41, 0xda, 0x62, 0x06, 0x32, 0xf7, 0xf4, 0x37, 0x1b, 0x38, 0xdc, 0xf4, 0x23, 0xb2, 0x03,
	0x79, 0x54, 0xc5, 0x9d, 0x5b, 0xc4, 0x2d, 0x11, 0x9e, 0x4c, 0x5c, 0x46, 0x85, 0x23, 0xe6, 0x64,
	0xe9, 0x01, 0x9c, 0xc6, 0x08, 0x47, 0xee, 0x6e, 0x36, 0xc1, 0x69, 0x20, 0xce, 0x33, 0xc8, 0x8b,
	0xc9, 0x60, 0xdc, 0xe1, 0xb4, 0xa2, 0x61, 0xf8, 0x1b, 0x93, 0x29, 0x5b, 0xf5, 0x9e, 0x29, 0xa4,
	0x46, 0x8e, 0xbb, 0x11, 0x52, 0xfa, 0x5f, 0x33, 0x50, 0xaa, 0x87, 0x41, 0x60, 0x0d, 0x1d, 0xf7,
	0x06, 0x6b, 0xf7, 0x0b, 0x58, 0xc6, 0xda, 0xb9, 0x43, 0xea, 0x70, 0x6a, 0x73, 0xa6, 0x8e, 0x53,
	0x51, 0x70, 0xeb, 0xc8, 0xb4, 0x18, 0xf9, 0x01, 0xb0, 0x70, 0xf6, 0xd5, 0x1d, 0xa7, 0x4c, 0x9d,
	0xaa, 0xbc, 0xe0, 0x9c, 0x0a, 0x06, 0xf9, 0x11, 0x50, 0xdd, 0x8e, 0x1c, 0xf7, 0x86, 0x72, 0x86,
	0x05, 0xd2, 0x0c, 0x6c, 0x4a, 0x4f, 0xb2, 0xc8, 0x3e, 0x2c, 0xd3, 0x2f, 0x2e, 0x8d, 0x44, 0xe5,
	0xed, 0x2b, 0x9f, 0x33, 0x2c, 0x8c, 0x66, 0x94, 0x12, 0xee, 0xa9, 0xcf, 0x19, 0xd9, 0x85, 0x02,
	0x66, 0x45, 0x3f, 0xda, 0xc1, 0xed, 0x00, 0x2b, 0xa4, 0x19, 0x22, 0x51, 0x93, 0x7e, 0xec, 0xdc,
	0x0e, 0xc4, 0x65, 0x8c, 0xe5, 0x1e, 0xed, 0x73, 0x07, 0xcb, 0xb2, 0x62, 0x14, 0xa4, 0x46, 0x43,
	0xb0, 0x62, 0x0c, 0xc7, 0xbd, 0x41, 0x0c, 0x2d, 0xc1, 0xa8, 0xb9, 0x37, 0x63, 0x18, 0x42, 0x2e,
	0x31, 0x72, 0x09, 0x46, 0xcd, 0xbd, 0x91, 0x18, 0x8f, 0x01, 0x84, 0xce, 0x67, 0x3f, 0xb0, 0xd9,
	0xd7, 0x4a, 0x5e, 0xd6, 0x9e, 0xbb, 0xd1, 0xa5, 0x1f, 0x98, 0x5f, 0x63, 0x04, 0x94, 0xba, 0x4e,
	0x9f, 0x56, 0x40, 0xde, 0x67, 0xa5, 0x20, 0x58, 0x64, 0x53, 0x6e, 0xee, 0x80, 0xb1, 0x4a, 0x01,
	0xa5, 0x62, 0x35, 0x2f, 0x18, 0x8b, 0x8d, 0x39, 0xb3, 0x43, 0xcc, 0xbb, 0x52, 0xdc, 0x4b, 0x1d,
	0xe4, 0xd0, 0xd8, 0x62, 0x5d, 0x64, 0xe9, 0x7f, 0x92, 0xd3, 0xdd, 0x70, 0xb8, 0x43, 0x8e, 0x00,
	0x2b, 0x6d, 0xfb, 0xc1, 0x75, 0xa8, 0x76, 0x90, 0x4c, 0x36, 0x5a, 0x34, 0xd2, 0xc0, 0xdd, 0xc0,
	0x96, 0xbe, 0x82, 0x15, 0x37, 0x0c, 0x02, 0x9b, 0x8b, 0x26, 0x4b, 0x33, 0xb9, 0x8c, 0x9b, 0x23,
	0xb3, 0x89, 0x21, 0x30, 0x4a, 0xee, 0xf8, 0x4f, 0xdd, 0x97, 0xde, 0xcd, 0x88, 0xba, 0x62, 0x49,
	0xe2, 0xa5, 0x53, 0xce, 0x57, 0x67, 0x96, 0xd4, 0xd0, 0xae, 0xd5, 0xb1, 0x88, 0x63, 0xf5, 0x1c,
	0xee, 0x28, 0xa7, 0x53, 0xb1, 0x8a, 0x94, 0x64, 0xac, 0x82, 0xd2, 0xff, 0x95, 0x82, 0x82, 0x29,
	0x5f, 0x53, 0x74, 0xb7, 0x0f, 0x8b, 0x03, 0xca, 0x9d, 0xc4, 0x95, 0x5c, 0x8d, 0xee, 0xd5, 0x1f,
	0xa9, 0xcb, 0x2f, 0x28, 0x77, 0x0c, 0x14, 0x8b, 0x79, 0x54, 0x6f, 0xb0, 0x78, 0x1d, 0xe5, 0xbb,
	0x92, 0x57, 0x9c, 0x96, 0x27, 0x4a, 0x3c, 0x56, 0x01, 0x1a, 0xe0, 0x40, 0xe6, 0x8c, 0x42, 0x92,
	0x66, 0x33, 0x20, 0xbf, 0x82, 0x65, 0x3f, 0xf0, 0xb9, 0xef, 0xf0, 0x70, 0x68, 0x8b, 0x78, 0xd4,
	0x81, 0x9d, 0x8a, 0x57, 0x44, 0x65, 0x94, 0x12, 0x4d, 0xc1, 0x12, 0xa6, 0x43, 0xca, 0xa2, 0x30,
	0xf0, 0xa8, 0x32, 0x5d, 0xba, 0xdf, 0x34, 0xd1, 0x14, 0x2c, 0xbd, 0x01, 0xab, 0x2a, 0x5d, 0x83,
	0x7e, 0xbc, 0xa5, 0x8c, 0x5f, 0xb0, 0xf7, 0xe4, 0x08, 0xb4, 0xa1, 0xfc, 0x55, 0x49, 0xed, 0x65,
	0x0e, 0x0a, 0xd5, 0xf5, 0x11, 0xd0, 0x58, 0x71, 0x8c, 0x58, 0x4b, 0x0f, 0x00, 0xd0, 0x01, 0x77,
	0xf8, 0x2d, 0x23, 0x4f, 0xd4, 0xf9, 0xfb, 0xe0, 0x04, 0x5e, 0x9f, 0xaa, 0xfd, 0xc5, 0x7d, 0x3d,
	0x43, 0xce, 0xff, 0x3e, 0x10, 0x7f, 0x4b, 0x41, 0x29, 0x0e, 0x44, 0xfa, 0xdc, 0x87, 0xe5, 0xb8,
	0x01, 0x13, 0x6e, 0xe3, 0x4f, 0x23, 0xe5, 0xf9, 0x05, 0x14, 0x7d, 0x8c, 0x8d, 0xa1, 0x99, 0x72,
	0x3b, 0x75, 0x9a, 0x25, 0xa4, 0x51, 0x40, 0x4d, 0x85, 0xff, 0x02, 0x8a, 0xc3, 0x71, 0xc3, 0xcc,
	0x43, 0x86, 0xc3, 0x91, 0xa1, 0xce, 0x60, 0x25, 0x29, 0xb0, 0x28, 0x3c, 0xa3, 0xe4, 0x08, 0xc0,
	0x89, 0xfc, 0x18, 0x49, 0xbe, 0x0e, 0xf1, 0xd1, 0xad, 0x45, 0xbe, 0x42, 0xc9, 0x3b, 0x31, 0x49,
	0x8e, 0x20, 0x3b, 0x11, 0xef, 0xe6, 0x6c, 0x3b, 0xa4, 0x8d, 0x52, 0xd3, 0xcf, 0x81, 0x4c, 0x39,
	0x15, 0x6d, 0x7d, 0x0e, 0xb9, 0xa1, 0xfa, 0xa9, 0xfa, 0xba, 0x35, 0x03, 0x14, 0xeb, 0x1b, 0x89,
	0xaa, 0xee, 0xc1, 0x9a, 0x12, 0x36, 0x68, 0x9f, 0x72, 0xaa, 0x06, 0xe5, 0x7b, 0x57, 0x63, 0xb6,
	0x33, 0xe9, 0x39, 0x9d, 0xd1, 0x4d, 0xd8, 0x9c, 0xe7, 0x45, 0xc4, 0xfd, 0x72, 0x7a, 0x1c, 0x77,
	0x67, 0xc2, 0x9e, 0xb0, 0x19, 0xcd, 0xe5, 0x39, 0x54, 0xa6, 0x14, 0x46, 0xd5, 0x98, 0xee, 0x42,
	0xe6, 0x1b, 0x5d, 0xd0, 0x9d, 0x64, 0x55, 0xde, 0x50, 0xfe, 0xff, 0x29, 0xc2, 0x45, 0x52, 0xea,
	0x91, 0x0b, 0xd9, 0xb9, 0xa9, 0x0a, 0xec, 0xcc, 0x54, 0x60, 0x64, 0x30, 0x4a, 0x9f, 0xcb, 0xef,
	0x45, 0x11, 0xff, 0xec, 0x9b, 0x98, 0x9a, 0x7d, 0x13, 0xbf, 0xf1, 0xaa, 0xee, 0x8b, 0x33, 0xf3,
	0x65, 0xe0, 0xf3, 0xa9, 0x77, 0xb5, 0x24, 0xb9, 0x0a, 0x45, 0x3f, 0x85, 0xe2, 0xd8, 0x54, 0x32,
	0x52, 0x55, 0xa8, 0xa2, 0xd2, 0x4c, 0xc5, 0xff, 0x68, 0x76, 0x71, 0x98, 0x74, 0x85, 0xa4, 0xfe,
	0x8f, 0x54, 0x32, 0xc1, 0x98, 0x98, 0xda, 0x9c, 0x97, 0x50, 0x8c, 0xcb, 0xc8, 0x22, 0xea, 0xaa,
	0xaa, 0xdf, 0x73, 0x9d, 0x0a, 0x6c, 0xec, 0x8e, 0xff, 0x66, 0xd4, 0x80, 0xef, 0x5b, 0xa5, 0xb8,
	0x33, 0x6a, 0x05, 0x7f, 0x9d, 0xfc, 0x93, 0xa5, 0xf2, 0x90, 0x07, 0x60, 0x63, 0xae, 0x39, 0x33,
	0x8a, 0x63, 0xd6, 0x4c, 0xff, 0x2d, 0xac, 0xcf, 0x26, 0x23, 0x27, 0x7b, 0x7a, 0x23, 0x1f, 0xcf,
	0x6f, 0xec, 0xf4, 0x52, 0x3e, 0xfd, 0x03, 0x68, 0xea, 0x8b, 0x90, 0xac, 0x42, 0xa9, 0x53, 0xb3,
	0x6c, 0xeb, 0x5d, 0xaf, 0x69, 0x77, 0xba, 0x9d, 0x66, 0x79, 0x61, 0x82, 0x65, 0x76, 0x6a, 0x56,
	0x39, 0x35, 0xc1, 0x6a, 0x08, 0x56, 0x9a, 0x6c, 0x00, 0x49, 0x58, 0xd6, 0x65, 0xab, 0xde, 0xb4,
	0x05, 0x3f, 0xf3, 0xb4, 0x2b, 0xaf, 0xb9, 0xfa, 0x2a, 0x5d, 0x83, 0xf2, 0xeb, 0x76, 0xf7, 0xd2,
	0xae, 0xd5, 0xad, 0x56, 0xb7, 0x13, 0x7b, 0x58, 0x87, 0xd5, 0x71, 0x6e, 0xad, 0xdd, 0xee, 0x5e,
	0x96, 0x53, 0xd3, 0xca, 0x0d, 0xa3, 0xdb, 0x2b, 0xa7, 0x9f, 0xfe, 0x3b, 0x05, 0xc5, 0xf1, 0x0f,
	0x40, 0xb2, 0x09, 0x8f, 0x50, 0xcd, 0xaa, 0xf7, 0x6c, 0xd3, 0xaa, 0x59, 0x49, 0xe0, 0xb3, 0x82,
	0x56, 0xa7, 0x25, 0xc2, 0xdf, 0x81, 0xcd, 0x29, 0x81, 0xf9, 0xae, 0x63, 0x9b, 0xcd, 0x8e, 0x48,
	0xe4, 0x09, 0xec, 0xcc, 0x11, 0xd6, 0xea, 0xe7, 0xb6, 0x51, 0x7f, 0xdb, 0x28, 0x67, 0xc8, 0x36,
	0x6c, 0x4c, 0x29, 0xd4, 0xdb, 0x5d, 0xb3, 0xd5, 0x79, 0x53, 0x5e, 0x24, 0x3f, 0xc0, 0xd6, 0x1c,
	0x59, 0xd3, 0xbe, 0xac, 0xb5, 0xac, 0xf2, 0x12, 0xd9, 0x85, 0xed, 0x29, 0x71, 0xd3, 0xb4, 0x6a,
	0xa7, 0xed, 0x96, 0x79, 0xd6, 0x6c, 0x94, 0xb3, 0x64, 0x0b, 0xd6, 0xe7, 0x99, 0x37, 0xca, 0x5a,
	0xf5, 0xcf, 0x69, 0xd0, 0x54, 0x13, 0x49, 0x3b, 0x79, 0xb0, 0xe4, 0x37, 0x2c, 0xd9, 0x99, 0x73,
	0x7a, 0xe3, 0x7d, 0xdf, 0x7e, 0x7c, 0xef, 0x5d, 0xbe, 0x60, 0xef, 0xf5, 0x05, 0xf2, 0xfb, 0x04,
	0x4d, 0xde, 0x35, 0xf2, 0xe3, 0xc3, 0x17, 0x51, 0x60, 0xea, 0xf7, 0xaa, 0x8c, 0x23, 0x77, 0x01,
	0x46, 0x73, 0x47, 0x76, 0x1f, 0x38, 0x33, 0x02, 0xf3, 0xc9, 0x43, 0xd3, 0x8a, 0x80, 0x57, 0x59,
	0x14, 0x3f, 0xfb, 0x6f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x8a, 0xd3, 0x92, 0xa4, 0x10, 0x00,
	0x00,
}
