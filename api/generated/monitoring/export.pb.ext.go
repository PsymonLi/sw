// Code generated by protoc-gen-grpc-pensando DO NOT EDIT.

/*
Package monitoring is a auto generated package.
Input file: export.proto
*/
package monitoring

import (
	fmt "fmt"
	"strings"

	listerwatcher "github.com/pensando/sw/api/listerwatcher"
	"github.com/pensando/sw/venice/utils/kvstore"
	"github.com/pensando/sw/venice/utils/log"

	validators "github.com/pensando/sw/venice/utils/apigen/validators"

	"github.com/pensando/sw/api/interfaces"
	"github.com/pensando/sw/venice/utils/runtime"
)

// Dummy definitions to suppress nonused warnings
var _ kvstore.Interface
var _ log.Logger
var _ listerwatcher.WatcherClient

// AuthConfig_Algos_normal is a map of normalized values for the enum
var AuthConfig_Algos_normal = map[string]string{
	"MD5":  "MD5",
	"SHA1": "SHA1",
	"md5":  "MD5",
	"sha1": "SHA1",
}

// PrivacyConfig_Algos_normal is a map of normalized values for the enum
var PrivacyConfig_Algos_normal = map[string]string{
	"AES128": "AES128",
	"DES56":  "DES56",
	"aes128": "AES128",
	"des56":  "DES56",
}

// SNMPTrapServer_SNMPVersions_normal is a map of normalized values for the enum
var SNMPTrapServer_SNMPVersions_normal = map[string]string{
	"V2C": "V2C",
	"V3":  "V3",
	"v2c": "V2C",
	"v3":  "V3",
}

// ExportAuthType_normal is a map of normalized values for the enum
var ExportAuthType_normal = map[string]string{
	"AUTHTYPE_CERTS":            "AUTHTYPE_CERTS",
	"AUTHTYPE_NONE":             "AUTHTYPE_NONE",
	"AUTHTYPE_TOKEN":            "AUTHTYPE_TOKEN",
	"AUTHTYPE_USERNAMEPASSWORD": "AUTHTYPE_USERNAMEPASSWORD",
	"authtype_certs":            "AUTHTYPE_CERTS",
	"authtype_none":             "AUTHTYPE_NONE",
	"authtype_token":            "AUTHTYPE_TOKEN",
	"authtype_usernamepassword": "AUTHTYPE_USERNAMEPASSWORD",
}

// SyslogFacility_normal is a map of normalized values for the enum
var SyslogFacility_normal = map[string]string{
	"LOG_AUTH":     "LOG_AUTH",
	"LOG_AUTHPRIV": "LOG_AUTHPRIV",
	"LOG_CRON":     "LOG_CRON",
	"LOG_DAEMON":   "LOG_DAEMON",
	"LOG_FTP":      "LOG_FTP",
	"LOG_KERN":     "LOG_KERN",
	"LOG_LOCAL0":   "LOG_LOCAL0",
	"LOG_LOCAL1":   "LOG_LOCAL1",
	"LOG_LOCAL2":   "LOG_LOCAL2",
	"LOG_LOCAL3":   "LOG_LOCAL3",
	"LOG_LOCAL4":   "LOG_LOCAL4",
	"LOG_LOCAL5":   "LOG_LOCAL5",
	"LOG_LOCAL6":   "LOG_LOCAL6",
	"LOG_LOCAL7":   "LOG_LOCAL7",
	"LOG_LPR":      "LOG_LPR",
	"LOG_MAIL":     "LOG_MAIL",
	"LOG_NEWS":     "LOG_NEWS",
	"LOG_SYSLOG":   "LOG_SYSLOG",
	"LOG_USER":     "LOG_USER",
	"LOG_UUCP":     "LOG_UUCP",
	"log_auth":     "LOG_AUTH",
	"log_authpriv": "LOG_AUTHPRIV",
	"log_cron":     "LOG_CRON",
	"log_daemon":   "LOG_DAEMON",
	"log_ftp":      "LOG_FTP",
	"log_kern":     "LOG_KERN",
	"log_local0":   "LOG_LOCAL0",
	"log_local1":   "LOG_LOCAL1",
	"log_local2":   "LOG_LOCAL2",
	"log_local3":   "LOG_LOCAL3",
	"log_local4":   "LOG_LOCAL4",
	"log_local5":   "LOG_LOCAL5",
	"log_local6":   "LOG_LOCAL6",
	"log_local7":   "LOG_LOCAL7",
	"log_lpr":      "LOG_LPR",
	"log_mail":     "LOG_MAIL",
	"log_news":     "LOG_NEWS",
	"log_syslog":   "LOG_SYSLOG",
	"log_user":     "LOG_USER",
	"log_uucp":     "LOG_UUCP",
}

var _ validators.DummyVar
var validatorMapExport = make(map[string]map[string][]func(string, interface{}) error)

// Clone clones the object into into or creates one of into is nil
func (m *AuthConfig) Clone(into interface{}) (interface{}, error) {
	var out *AuthConfig
	var ok bool
	if into == nil {
		out = &AuthConfig{}
	} else {
		out, ok = into.(*AuthConfig)
		if !ok {
			return nil, fmt.Errorf("mismatched object types")
		}
	}
	*out = *m
	return out, nil
}

// Default sets up the defaults for the object
func (m *AuthConfig) Defaults(ver string) bool {
	var ret bool
	ret = true
	switch ver {
	default:
		m.Algo = "MD5"
	}
	return ret
}

// Clone clones the object into into or creates one of into is nil
func (m *ExportConfig) Clone(into interface{}) (interface{}, error) {
	var out *ExportConfig
	var ok bool
	if into == nil {
		out = &ExportConfig{}
	} else {
		out, ok = into.(*ExportConfig)
		if !ok {
			return nil, fmt.Errorf("mismatched object types")
		}
	}
	*out = *m
	return out, nil
}

// Default sets up the defaults for the object
func (m *ExportConfig) Defaults(ver string) bool {
	var ret bool
	if m.Credentials != nil {
		ret = m.Credentials.Defaults(ver) || ret
	}
	return ret
}

// Clone clones the object into into or creates one of into is nil
func (m *ExternalCred) Clone(into interface{}) (interface{}, error) {
	var out *ExternalCred
	var ok bool
	if into == nil {
		out = &ExternalCred{}
	} else {
		out, ok = into.(*ExternalCred)
		if !ok {
			return nil, fmt.Errorf("mismatched object types")
		}
	}
	*out = *m
	return out, nil
}

// Default sets up the defaults for the object
func (m *ExternalCred) Defaults(ver string) bool {
	var ret bool
	ret = true
	switch ver {
	default:
		m.AuthType = "AUTHTYPE_NONE"
	}
	return ret
}

// Clone clones the object into into or creates one of into is nil
func (m *PrivacyConfig) Clone(into interface{}) (interface{}, error) {
	var out *PrivacyConfig
	var ok bool
	if into == nil {
		out = &PrivacyConfig{}
	} else {
		out, ok = into.(*PrivacyConfig)
		if !ok {
			return nil, fmt.Errorf("mismatched object types")
		}
	}
	*out = *m
	return out, nil
}

// Default sets up the defaults for the object
func (m *PrivacyConfig) Defaults(ver string) bool {
	var ret bool
	ret = true
	switch ver {
	default:
		m.Algo = "DES56"
	}
	return ret
}

// Clone clones the object into into or creates one of into is nil
func (m *SNMPTrapServer) Clone(into interface{}) (interface{}, error) {
	var out *SNMPTrapServer
	var ok bool
	if into == nil {
		out = &SNMPTrapServer{}
	} else {
		out, ok = into.(*SNMPTrapServer)
		if !ok {
			return nil, fmt.Errorf("mismatched object types")
		}
	}
	*out = *m
	return out, nil
}

// Default sets up the defaults for the object
func (m *SNMPTrapServer) Defaults(ver string) bool {
	var ret bool
	if m.AuthConfig != nil {
		ret = m.AuthConfig.Defaults(ver) || ret
	}
	if m.PrivacyConfig != nil {
		ret = m.PrivacyConfig.Defaults(ver) || ret
	}
	ret = true
	switch ver {
	default:
		m.Port = "162"
		m.Version = "V2C"
	}
	return ret
}

// Clone clones the object into into or creates one of into is nil
func (m *SyslogExportConfig) Clone(into interface{}) (interface{}, error) {
	var out *SyslogExportConfig
	var ok bool
	if into == nil {
		out = &SyslogExportConfig{}
	} else {
		out, ok = into.(*SyslogExportConfig)
		if !ok {
			return nil, fmt.Errorf("mismatched object types")
		}
	}
	*out = *m
	return out, nil
}

// Default sets up the defaults for the object
func (m *SyslogExportConfig) Defaults(ver string) bool {
	var ret bool
	ret = true
	switch ver {
	default:
		m.FacilityOverride = "LOG_USER"
	}
	return ret
}

// Validators and Requirements

func (m *AuthConfig) References(tenant string, path string, resp map[string]apiintf.ReferenceObj) {

}

func (m *AuthConfig) Validate(ver, path string, ignoreStatus bool) []error {
	var ret []error
	if vs, ok := validatorMapExport["AuthConfig"][ver]; ok {
		for _, v := range vs {
			if err := v(path, m); err != nil {
				ret = append(ret, err)
			}
		}
	} else if vs, ok := validatorMapExport["AuthConfig"]["all"]; ok {
		for _, v := range vs {
			if err := v(path, m); err != nil {
				ret = append(ret, err)
			}
		}
	}
	return ret
}

func (m *AuthConfig) Normalize() {

	m.Algo = AuthConfig_Algos_normal[strings.ToLower(m.Algo)]

}

func (m *ExportConfig) References(tenant string, path string, resp map[string]apiintf.ReferenceObj) {

}

func (m *ExportConfig) Validate(ver, path string, ignoreStatus bool) []error {
	var ret []error
	if m.Credentials != nil {
		{
			dlmtr := "."
			if path == "" {
				dlmtr = ""
			}
			npath := path + dlmtr + "Credentials"
			if errs := m.Credentials.Validate(ver, npath, ignoreStatus); errs != nil {
				ret = append(ret, errs...)
			}
		}
	}
	if vs, ok := validatorMapExport["ExportConfig"][ver]; ok {
		for _, v := range vs {
			if err := v(path, m); err != nil {
				ret = append(ret, err)
			}
		}
	} else if vs, ok := validatorMapExport["ExportConfig"]["all"]; ok {
		for _, v := range vs {
			if err := v(path, m); err != nil {
				ret = append(ret, err)
			}
		}
	}
	return ret
}

func (m *ExportConfig) Normalize() {

	if m.Credentials != nil {
		m.Credentials.Normalize()
	}

}

func (m *ExternalCred) References(tenant string, path string, resp map[string]apiintf.ReferenceObj) {

}

func (m *ExternalCred) Validate(ver, path string, ignoreStatus bool) []error {
	var ret []error
	if vs, ok := validatorMapExport["ExternalCred"][ver]; ok {
		for _, v := range vs {
			if err := v(path, m); err != nil {
				ret = append(ret, err)
			}
		}
	} else if vs, ok := validatorMapExport["ExternalCred"]["all"]; ok {
		for _, v := range vs {
			if err := v(path, m); err != nil {
				ret = append(ret, err)
			}
		}
	}
	return ret
}

func (m *ExternalCred) Normalize() {

	m.AuthType = ExportAuthType_normal[strings.ToLower(m.AuthType)]

}

func (m *PrivacyConfig) References(tenant string, path string, resp map[string]apiintf.ReferenceObj) {

}

func (m *PrivacyConfig) Validate(ver, path string, ignoreStatus bool) []error {
	var ret []error
	if vs, ok := validatorMapExport["PrivacyConfig"][ver]; ok {
		for _, v := range vs {
			if err := v(path, m); err != nil {
				ret = append(ret, err)
			}
		}
	} else if vs, ok := validatorMapExport["PrivacyConfig"]["all"]; ok {
		for _, v := range vs {
			if err := v(path, m); err != nil {
				ret = append(ret, err)
			}
		}
	}
	return ret
}

func (m *PrivacyConfig) Normalize() {

	m.Algo = PrivacyConfig_Algos_normal[strings.ToLower(m.Algo)]

}

func (m *SNMPTrapServer) References(tenant string, path string, resp map[string]apiintf.ReferenceObj) {

}

func (m *SNMPTrapServer) Validate(ver, path string, ignoreStatus bool) []error {
	var ret []error
	if m.AuthConfig != nil {
		{
			dlmtr := "."
			if path == "" {
				dlmtr = ""
			}
			npath := path + dlmtr + "AuthConfig"
			if errs := m.AuthConfig.Validate(ver, npath, ignoreStatus); errs != nil {
				ret = append(ret, errs...)
			}
		}
	}
	if m.PrivacyConfig != nil {
		{
			dlmtr := "."
			if path == "" {
				dlmtr = ""
			}
			npath := path + dlmtr + "PrivacyConfig"
			if errs := m.PrivacyConfig.Validate(ver, npath, ignoreStatus); errs != nil {
				ret = append(ret, errs...)
			}
		}
	}
	if vs, ok := validatorMapExport["SNMPTrapServer"][ver]; ok {
		for _, v := range vs {
			if err := v(path, m); err != nil {
				ret = append(ret, err)
			}
		}
	} else if vs, ok := validatorMapExport["SNMPTrapServer"]["all"]; ok {
		for _, v := range vs {
			if err := v(path, m); err != nil {
				ret = append(ret, err)
			}
		}
	}
	return ret
}

func (m *SNMPTrapServer) Normalize() {

	if m.AuthConfig != nil {
		m.AuthConfig.Normalize()
	}

	if m.PrivacyConfig != nil {
		m.PrivacyConfig.Normalize()
	}

	m.Version = SNMPTrapServer_SNMPVersions_normal[strings.ToLower(m.Version)]

}

func (m *SyslogExportConfig) References(tenant string, path string, resp map[string]apiintf.ReferenceObj) {

}

func (m *SyslogExportConfig) Validate(ver, path string, ignoreStatus bool) []error {
	var ret []error
	if vs, ok := validatorMapExport["SyslogExportConfig"][ver]; ok {
		for _, v := range vs {
			if err := v(path, m); err != nil {
				ret = append(ret, err)
			}
		}
	} else if vs, ok := validatorMapExport["SyslogExportConfig"]["all"]; ok {
		for _, v := range vs {
			if err := v(path, m); err != nil {
				ret = append(ret, err)
			}
		}
	}
	return ret
}

func (m *SyslogExportConfig) Normalize() {

	m.FacilityOverride = SyslogFacility_normal[strings.ToLower(m.FacilityOverride)]

}

// Transformers

func init() {
	scheme := runtime.GetDefaultScheme()
	scheme.AddKnownTypes()

	validatorMapExport = make(map[string]map[string][]func(string, interface{}) error)

	validatorMapExport["AuthConfig"] = make(map[string][]func(string, interface{}) error)
	validatorMapExport["AuthConfig"]["all"] = append(validatorMapExport["AuthConfig"]["all"], func(path string, i interface{}) error {
		m := i.(*AuthConfig)

		if _, ok := AuthConfig_Algos_value[m.Algo]; !ok {
			vals := []string{}
			for k1, _ := range AuthConfig_Algos_value {
				vals = append(vals, k1)
			}
			return fmt.Errorf("%v did not match allowed strings %v", path+"."+"Algo", vals)
		}
		return nil
	})

	validatorMapExport["ExportConfig"] = make(map[string][]func(string, interface{}) error)
	validatorMapExport["ExportConfig"]["all"] = append(validatorMapExport["ExportConfig"]["all"], func(path string, i interface{}) error {
		m := i.(*ExportConfig)
		args := make([]string, 0)
		args = append(args, "1")
		args = append(args, "2048")

		if err := validators.StrLen(m.Destination, args); err != nil {
			return fmt.Errorf("%v failed validation: %s", path+"."+"Destination", err.Error())
		}
		return nil
	})

	validatorMapExport["ExportConfig"]["all"] = append(validatorMapExport["ExportConfig"]["all"], func(path string, i interface{}) error {
		m := i.(*ExportConfig)
		if err := validators.EmptyOr(validators.ProtoPort, m.Transport, nil); err != nil {
			return fmt.Errorf("%v failed validation: %s", path+"."+"Transport", err.Error())
		}
		return nil
	})

	validatorMapExport["ExternalCred"] = make(map[string][]func(string, interface{}) error)
	validatorMapExport["ExternalCred"]["all"] = append(validatorMapExport["ExternalCred"]["all"], func(path string, i interface{}) error {
		m := i.(*ExternalCred)

		if _, ok := ExportAuthType_value[m.AuthType]; !ok {
			vals := []string{}
			for k1, _ := range ExportAuthType_value {
				vals = append(vals, k1)
			}
			return fmt.Errorf("%v did not match allowed strings %v", path+"."+"AuthType", vals)
		}
		return nil
	})

	validatorMapExport["PrivacyConfig"] = make(map[string][]func(string, interface{}) error)
	validatorMapExport["PrivacyConfig"]["all"] = append(validatorMapExport["PrivacyConfig"]["all"], func(path string, i interface{}) error {
		m := i.(*PrivacyConfig)

		if _, ok := PrivacyConfig_Algos_value[m.Algo]; !ok {
			vals := []string{}
			for k1, _ := range PrivacyConfig_Algos_value {
				vals = append(vals, k1)
			}
			return fmt.Errorf("%v did not match allowed strings %v", path+"."+"Algo", vals)
		}
		return nil
	})

	validatorMapExport["SNMPTrapServer"] = make(map[string][]func(string, interface{}) error)
	validatorMapExport["SNMPTrapServer"]["all"] = append(validatorMapExport["SNMPTrapServer"]["all"], func(path string, i interface{}) error {
		m := i.(*SNMPTrapServer)

		if _, ok := SNMPTrapServer_SNMPVersions_value[m.Version]; !ok {
			vals := []string{}
			for k1, _ := range SNMPTrapServer_SNMPVersions_value {
				vals = append(vals, k1)
			}
			return fmt.Errorf("%v did not match allowed strings %v", path+"."+"Version", vals)
		}
		return nil
	})

	validatorMapExport["SyslogExportConfig"] = make(map[string][]func(string, interface{}) error)
	validatorMapExport["SyslogExportConfig"]["all"] = append(validatorMapExport["SyslogExportConfig"]["all"], func(path string, i interface{}) error {
		m := i.(*SyslogExportConfig)

		if _, ok := SyslogFacility_value[m.FacilityOverride]; !ok {
			vals := []string{}
			for k1, _ := range SyslogFacility_value {
				vals = append(vals, k1)
			}
			return fmt.Errorf("%v did not match allowed strings %v", path+"."+"FacilityOverride", vals)
		}
		return nil
	})

}
