// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: export.proto

package monitoring

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/pensando/grpc-gateway/third_party/googleapis/google/api"
import _ "github.com/pensando/sw/venice/utils/apigen/annotations"
import _ "github.com/gogo/protobuf/gogoproto"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

//
type ExportAuthType int32

const (
	// ui-hint: None
	ExportAuthType_AUTHTYPE_NONE ExportAuthType = 0
	// ui-hint: Username/Password
	ExportAuthType_AUTHTYPE_USERNAMEPASSWORD ExportAuthType = 1
	// ui-hint: Token
	ExportAuthType_AUTHTYPE_TOKEN ExportAuthType = 2
	// ui-hint: Certs
	ExportAuthType_AUTHTYPE_CERTS ExportAuthType = 3
)

var ExportAuthType_name = map[int32]string{
	0: "AUTHTYPE_NONE",
	1: "AUTHTYPE_USERNAMEPASSWORD",
	2: "AUTHTYPE_TOKEN",
	3: "AUTHTYPE_CERTS",
}
var ExportAuthType_value = map[string]int32{
	"AUTHTYPE_NONE":             0,
	"AUTHTYPE_USERNAMEPASSWORD": 1,
	"AUTHTYPE_TOKEN":            2,
	"AUTHTYPE_CERTS":            3,
}

func (ExportAuthType) EnumDescriptor() ([]byte, []int) { return fileDescriptorExport, []int{0} }

//
type SyslogFacility int32

const (
	// kernel messages
	// ui-hint: Kernel
	SyslogFacility_LOG_KERN SyslogFacility = 0
	// user-level messages
	// ui-hint: User
	SyslogFacility_LOG_USER SyslogFacility = 8
	// mail system
	// ui-hint: Mail
	SyslogFacility_LOG_MAIL SyslogFacility = 16
	// system daemons
	// ui-hint: Daemon
	SyslogFacility_LOG_DAEMON SyslogFacility = 24
	// security/authorization messages
	// ui-hint: Auth
	SyslogFacility_LOG_AUTH SyslogFacility = 32
	// messages generated internally by syslogd
	// ui-hint: Syslog
	SyslogFacility_LOG_SYSLOG SyslogFacility = 40
	// line printer subsystem
	// ui-hint: LPR
	SyslogFacility_LOG_LPR SyslogFacility = 48
	// network news subsystem
	// ui-hint: News
	SyslogFacility_LOG_NEWS SyslogFacility = 56
	// UUCP subsystem
	// ui-hint: UUCP
	SyslogFacility_LOG_UUCP SyslogFacility = 64
	// clock daemon
	// ui-hint: CRON
	SyslogFacility_LOG_CRON SyslogFacility = 72
	// security/authorization messages (private)
	// ui-hint: Private Auth
	SyslogFacility_LOG_AUTHPRIV SyslogFacility = 80
	// ui-hint: FTP
	SyslogFacility_LOG_FTP SyslogFacility = 88
	// reserved for local use
	// ui-hint: local 0
	SyslogFacility_LOG_LOCAL0 SyslogFacility = 128
	// reserved for local use
	// ui-hint: local 1
	SyslogFacility_LOG_LOCAL1 SyslogFacility = 136
	// reserved for local use
	// ui-hint: local 2
	SyslogFacility_LOG_LOCAL2 SyslogFacility = 144
	// reserved for local use
	// ui-hint: local 3
	SyslogFacility_LOG_LOCAL3 SyslogFacility = 152
	// reserved for local use
	// ui-hint: local 4
	SyslogFacility_LOG_LOCAL4 SyslogFacility = 160
	// reserved for local use
	// ui-hint: local 5
	SyslogFacility_LOG_LOCAL5 SyslogFacility = 168
	// reserved for local use
	// ui-hint: local 6
	SyslogFacility_LOG_LOCAL6 SyslogFacility = 176
	// reserved for local use
	// ui-hint: local 7
	SyslogFacility_LOG_LOCAL7 SyslogFacility = 184
)

var SyslogFacility_name = map[int32]string{
	0:   "LOG_KERN",
	8:   "LOG_USER",
	16:  "LOG_MAIL",
	24:  "LOG_DAEMON",
	32:  "LOG_AUTH",
	40:  "LOG_SYSLOG",
	48:  "LOG_LPR",
	56:  "LOG_NEWS",
	64:  "LOG_UUCP",
	72:  "LOG_CRON",
	80:  "LOG_AUTHPRIV",
	88:  "LOG_FTP",
	128: "LOG_LOCAL0",
	136: "LOG_LOCAL1",
	144: "LOG_LOCAL2",
	152: "LOG_LOCAL3",
	160: "LOG_LOCAL4",
	168: "LOG_LOCAL5",
	176: "LOG_LOCAL6",
	184: "LOG_LOCAL7",
}
var SyslogFacility_value = map[string]int32{
	"LOG_KERN":     0,
	"LOG_USER":     8,
	"LOG_MAIL":     16,
	"LOG_DAEMON":   24,
	"LOG_AUTH":     32,
	"LOG_SYSLOG":   40,
	"LOG_LPR":      48,
	"LOG_NEWS":     56,
	"LOG_UUCP":     64,
	"LOG_CRON":     72,
	"LOG_AUTHPRIV": 80,
	"LOG_FTP":      88,
	"LOG_LOCAL0":   128,
	"LOG_LOCAL1":   136,
	"LOG_LOCAL2":   144,
	"LOG_LOCAL3":   152,
	"LOG_LOCAL4":   160,
	"LOG_LOCAL5":   168,
	"LOG_LOCAL6":   176,
	"LOG_LOCAL7":   184,
}

func (SyslogFacility) EnumDescriptor() ([]byte, []int) { return fileDescriptorExport, []int{1} }

// Algos contains the authentication algorithm to be used when SecurityMethod
// has AUTH.
type AuthConfig_Algos int32

const (
	//
	AuthConfig_MD5 AuthConfig_Algos = 0
	//
	AuthConfig_SHA1 AuthConfig_Algos = 1
)

var AuthConfig_Algos_name = map[int32]string{
	0: "MD5",
	1: "SHA1",
}
var AuthConfig_Algos_value = map[string]int32{
	"MD5":  0,
	"SHA1": 1,
}

func (AuthConfig_Algos) EnumDescriptor() ([]byte, []int) { return fileDescriptorExport, []int{0, 0} }

// Algos contains the encryption algorithm to be used when SecurityMethod
// has PRIVACY.
type PrivacyConfig_Algos int32

const (
	//
	PrivacyConfig_DES56 PrivacyConfig_Algos = 0
	//
	PrivacyConfig_AES128 PrivacyConfig_Algos = 1
)

var PrivacyConfig_Algos_name = map[int32]string{
	0: "DES56",
	1: "AES128",
}
var PrivacyConfig_Algos_value = map[string]int32{
	"DES56":  0,
	"AES128": 1,
}

func (PrivacyConfig_Algos) EnumDescriptor() ([]byte, []int) { return fileDescriptorExport, []int{4, 0} }

// Version of SNMP to use to send the traps (v1 is not supported).
type SNMPTrapServer_SNMPVersions int32

const (
	//
	SNMPTrapServer_V2C SNMPTrapServer_SNMPVersions = 0
	//
	SNMPTrapServer_V3 SNMPTrapServer_SNMPVersions = 1
)

var SNMPTrapServer_SNMPVersions_name = map[int32]string{
	0: "V2C",
	1: "V3",
}
var SNMPTrapServer_SNMPVersions_value = map[string]int32{
	"V2C": 0,
	"V3":  1,
}

func (SNMPTrapServer_SNMPVersions) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorExport, []int{5, 0}
}

// AuthConfig contains the configuration for SNMP Trap authentication.
type AuthConfig struct {
	//
	Algo string `protobuf:"bytes,1,opt,name=Algo,json=algo, omitempty,proto3" json:"algo, omitempty"`
	// Password contains the authentication password.
	Password string `protobuf:"bytes,2,opt,name=Password,json=password, omitempty,proto3" json:"password, omitempty"`
}

func (m *AuthConfig) Reset()                    { *m = AuthConfig{} }
func (m *AuthConfig) String() string            { return proto.CompactTextString(m) }
func (*AuthConfig) ProtoMessage()               {}
func (*AuthConfig) Descriptor() ([]byte, []int) { return fileDescriptorExport, []int{0} }

func (m *AuthConfig) GetAlgo() string {
	if m != nil {
		return m.Algo
	}
	return ""
}

func (m *AuthConfig) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

// Export Config specifies server address and user credentials
type ExportConfig struct {
	// IP address or URL of the collector/entity to which the data is to be exported
	Destination string `protobuf:"bytes,1,opt,name=Destination,json=destination,omitempty,proto3" json:"destination,omitempty"`
	// Gateway of the dest IP address or URL of the collector/entity to which the data is to be exported
	Gateway string `protobuf:"bytes,2,opt,name=Gateway,json=gateway,omitempty,proto3" json:"gateway,omitempty"`
	// protocol and Port number where an external collector is gathering the data
	// example "UDP/2055"
	Transport string `protobuf:"bytes,3,opt,name=Transport,json=transport,omitempty,proto3" json:"transport,omitempty"`
	// Credentials provide secure access to the collector
	Credentials *ExternalCred `protobuf:"bytes,4,opt,name=Credentials,json=credentials,omitempty" json:"credentials,omitempty"`
}

func (m *ExportConfig) Reset()                    { *m = ExportConfig{} }
func (m *ExportConfig) String() string            { return proto.CompactTextString(m) }
func (*ExportConfig) ProtoMessage()               {}
func (*ExportConfig) Descriptor() ([]byte, []int) { return fileDescriptorExport, []int{1} }

func (m *ExportConfig) GetDestination() string {
	if m != nil {
		return m.Destination
	}
	return ""
}

func (m *ExportConfig) GetGateway() string {
	if m != nil {
		return m.Gateway
	}
	return ""
}

func (m *ExportConfig) GetTransport() string {
	if m != nil {
		return m.Transport
	}
	return ""
}

func (m *ExportConfig) GetCredentials() *ExternalCred {
	if m != nil {
		return m.Credentials
	}
	return nil
}

// ExternalCred defines credentials required to access an external entity, such as
// a stats collector, compute orchestration entity, or a syslog server.
// External entity may support a variety of methods, like username/password,
// TLS Client authentication, or Bearer Token based authentication. User is
// expected to configure one of the methods
type ExternalCred struct {
	// AuthType is the authentication type used in this config
	AuthType string `protobuf:"bytes,1,opt,name=AuthType,json=auth-type,proto3" json:"auth-type"`
	// UserName is the login id to be used towards the external entity
	UserName string `protobuf:"bytes,2,opt,name=UserName,json=username,omitempty,proto3" json:"username,omitempty"`
	// Password is one time specified, not visibile on read operations
	// Only valid when UserName is defined
	// TBD: need to add (venice.secret) = "true" support for this
	Password string `protobuf:"bytes,3,opt,name=Password,json=password,omitempty,proto3" json:"password,omitempty"`
	// External entity supports bearer tokens for authentication and authorization
	// Token refresh is not supported using OAuth2
	// TBD: need to add (venice.secret) = "true" support for this
	BearerToken string `protobuf:"bytes,4,opt,name=BearerToken,json=bearer-token,omitempty,proto3" json:"bearer-token,omitempty"`
	// CertData holds PEM-encoded bytes (typically read from a client certificate file).
	CertData string `protobuf:"bytes,5,opt,name=CertData,json=cert-data,omitempty,proto3" json:"cert-data,omitempty"`
	// KeyData holds PEM-encoded bytes (typically read from a client certificate key file).
	// TBD: need to add (venice.secret) = "true" support for this
	KeyData string `protobuf:"bytes,6,opt,name=KeyData,json=key-data,omitempty,proto3" json:"key-data,omitempty"`
	// CaData holds PEM-encoded bytes (typically read from a root certificates bundle).
	// CaData is used by client to autheticate external server. This is applicable to all authentication methods
	CaData string `protobuf:"bytes,7,opt,name=CaData,json=ca-data,omitempty,proto3" json:"ca-data,omitempty"`
	// DisableServerAuthentication flag can be used when a client does not want to authenticate a server
	DisableServerAuthentication bool `protobuf:"varint,8,opt,name=DisableServerAuthentication,json=disable-server-authentication,omitempty,proto3" json:"disable-server-authentication,omitempty"`
}

func (m *ExternalCred) Reset()                    { *m = ExternalCred{} }
func (m *ExternalCred) String() string            { return proto.CompactTextString(m) }
func (*ExternalCred) ProtoMessage()               {}
func (*ExternalCred) Descriptor() ([]byte, []int) { return fileDescriptorExport, []int{2} }

func (m *ExternalCred) GetAuthType() string {
	if m != nil {
		return m.AuthType
	}
	return ""
}

func (m *ExternalCred) GetUserName() string {
	if m != nil {
		return m.UserName
	}
	return ""
}

func (m *ExternalCred) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

func (m *ExternalCred) GetBearerToken() string {
	if m != nil {
		return m.BearerToken
	}
	return ""
}

func (m *ExternalCred) GetCertData() string {
	if m != nil {
		return m.CertData
	}
	return ""
}

func (m *ExternalCred) GetKeyData() string {
	if m != nil {
		return m.KeyData
	}
	return ""
}

func (m *ExternalCred) GetCaData() string {
	if m != nil {
		return m.CaData
	}
	return ""
}

func (m *ExternalCred) GetDisableServerAuthentication() bool {
	if m != nil {
		return m.DisableServerAuthentication
	}
	return false
}

// PSMExportTarget represents PSM used as a log export target.
type PSMExportTarget struct {
	// Enable is for enabling the log export. Its default value is false.
	Enable bool `protobuf:"varint,1,opt,name=Enable,json=enable, omitempty,proto3" json:"enable, omitempty"`
}

func (m *PSMExportTarget) Reset()                    { *m = PSMExportTarget{} }
func (m *PSMExportTarget) String() string            { return proto.CompactTextString(m) }
func (*PSMExportTarget) ProtoMessage()               {}
func (*PSMExportTarget) Descriptor() ([]byte, []int) { return fileDescriptorExport, []int{3} }

func (m *PSMExportTarget) GetEnable() bool {
	if m != nil {
		return m.Enable
	}
	return false
}

// PrivacyConfig contains the configuration for SNMP Trap encryption.
type PrivacyConfig struct {
	//
	Algo string `protobuf:"bytes,1,opt,name=Algo,json=algo, omitempty,proto3" json:"algo, omitempty"`
	// Password contains the privacy password.
	Password string `protobuf:"bytes,2,opt,name=Password,json=password, omitempty,proto3" json:"password, omitempty"`
}

func (m *PrivacyConfig) Reset()                    { *m = PrivacyConfig{} }
func (m *PrivacyConfig) String() string            { return proto.CompactTextString(m) }
func (*PrivacyConfig) ProtoMessage()               {}
func (*PrivacyConfig) Descriptor() ([]byte, []int) { return fileDescriptorExport, []int{4} }

func (m *PrivacyConfig) GetAlgo() string {
	if m != nil {
		return m.Algo
	}
	return ""
}

func (m *PrivacyConfig) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

// SNMPTrapServer contains the configuration for sending SNMP traps to a receiver.
type SNMPTrapServer struct {
	// Host where the trap needs to be sent.
	Host string `protobuf:"bytes,1,opt,name=Host,json=host, omitempty,proto3" json:"host, omitempty"`
	// Port on the Host where the trap needs to be sent, default is 162.
	Port string `protobuf:"bytes,2,opt,name=Port,json=port, omitempty,proto3" json:"port, omitempty"`
	//
	Version string `protobuf:"bytes,3,opt,name=Version,json=version, omitempty,proto3" json:"version, omitempty"`
	// CommunityOrUser contains community string for v2c, user for v3.
	CommunityOrUser string `protobuf:"bytes,4,opt,name=CommunityOrUser,json=community-or-user, omitempty,proto3" json:"community-or-user, omitempty"`
	// AuthConfig contains the configuration for authentication, valid only for v3.
	AuthConfig *AuthConfig `protobuf:"bytes,5,opt,name=AuthConfig,json=auth-config, omitempty" json:"auth-config, omitempty"`
	// PrivacyConfig contains the configuration for encryption, valid only for v3.
	PrivacyConfig *PrivacyConfig `protobuf:"bytes,6,opt,name=PrivacyConfig,json=privacy-config, omitempty" json:"privacy-config, omitempty"`
}

func (m *SNMPTrapServer) Reset()                    { *m = SNMPTrapServer{} }
func (m *SNMPTrapServer) String() string            { return proto.CompactTextString(m) }
func (*SNMPTrapServer) ProtoMessage()               {}
func (*SNMPTrapServer) Descriptor() ([]byte, []int) { return fileDescriptorExport, []int{5} }

func (m *SNMPTrapServer) GetHost() string {
	if m != nil {
		return m.Host
	}
	return ""
}

func (m *SNMPTrapServer) GetPort() string {
	if m != nil {
		return m.Port
	}
	return ""
}

func (m *SNMPTrapServer) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *SNMPTrapServer) GetCommunityOrUser() string {
	if m != nil {
		return m.CommunityOrUser
	}
	return ""
}

func (m *SNMPTrapServer) GetAuthConfig() *AuthConfig {
	if m != nil {
		return m.AuthConfig
	}
	return nil
}

func (m *SNMPTrapServer) GetPrivacyConfig() *PrivacyConfig {
	if m != nil {
		return m.PrivacyConfig
	}
	return nil
}

// syslog export configurations
type SyslogExportConfig struct {
	// override default facility with this in exported logs
	FacilityOverride string `protobuf:"bytes,1,opt,name=FacilityOverride,json=facility-override,omitempty,proto3" json:"facility-override,omitempty"`
	// add prefix in exported logs
	Prefix string `protobuf:"bytes,2,opt,name=Prefix,json=prefix,omitempty,proto3" json:"prefix,omitempty"`
}

func (m *SyslogExportConfig) Reset()                    { *m = SyslogExportConfig{} }
func (m *SyslogExportConfig) String() string            { return proto.CompactTextString(m) }
func (*SyslogExportConfig) ProtoMessage()               {}
func (*SyslogExportConfig) Descriptor() ([]byte, []int) { return fileDescriptorExport, []int{6} }

func (m *SyslogExportConfig) GetFacilityOverride() string {
	if m != nil {
		return m.FacilityOverride
	}
	return ""
}

func (m *SyslogExportConfig) GetPrefix() string {
	if m != nil {
		return m.Prefix
	}
	return ""
}

func init() {
	proto.RegisterType((*AuthConfig)(nil), "monitoring.AuthConfig")
	proto.RegisterType((*ExportConfig)(nil), "monitoring.ExportConfig")
	proto.RegisterType((*ExternalCred)(nil), "monitoring.ExternalCred")
	proto.RegisterType((*PSMExportTarget)(nil), "monitoring.PSMExportTarget")
	proto.RegisterType((*PrivacyConfig)(nil), "monitoring.PrivacyConfig")
	proto.RegisterType((*SNMPTrapServer)(nil), "monitoring.SNMPTrapServer")
	proto.RegisterType((*SyslogExportConfig)(nil), "monitoring.SyslogExportConfig")
	proto.RegisterEnum("monitoring.ExportAuthType", ExportAuthType_name, ExportAuthType_value)
	proto.RegisterEnum("monitoring.SyslogFacility", SyslogFacility_name, SyslogFacility_value)
	proto.RegisterEnum("monitoring.AuthConfig_Algos", AuthConfig_Algos_name, AuthConfig_Algos_value)
	proto.RegisterEnum("monitoring.PrivacyConfig_Algos", PrivacyConfig_Algos_name, PrivacyConfig_Algos_value)
	proto.RegisterEnum("monitoring.SNMPTrapServer_SNMPVersions", SNMPTrapServer_SNMPVersions_name, SNMPTrapServer_SNMPVersions_value)
}
func (m *AuthConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuthConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Algo) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintExport(dAtA, i, uint64(len(m.Algo)))
		i += copy(dAtA[i:], m.Algo)
	}
	if len(m.Password) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintExport(dAtA, i, uint64(len(m.Password)))
		i += copy(dAtA[i:], m.Password)
	}
	return i, nil
}

func (m *ExportConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExportConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Destination) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintExport(dAtA, i, uint64(len(m.Destination)))
		i += copy(dAtA[i:], m.Destination)
	}
	if len(m.Gateway) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintExport(dAtA, i, uint64(len(m.Gateway)))
		i += copy(dAtA[i:], m.Gateway)
	}
	if len(m.Transport) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintExport(dAtA, i, uint64(len(m.Transport)))
		i += copy(dAtA[i:], m.Transport)
	}
	if m.Credentials != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintExport(dAtA, i, uint64(m.Credentials.Size()))
		n1, err := m.Credentials.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	return i, nil
}

func (m *ExternalCred) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExternalCred) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AuthType) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintExport(dAtA, i, uint64(len(m.AuthType)))
		i += copy(dAtA[i:], m.AuthType)
	}
	if len(m.UserName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintExport(dAtA, i, uint64(len(m.UserName)))
		i += copy(dAtA[i:], m.UserName)
	}
	if len(m.Password) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintExport(dAtA, i, uint64(len(m.Password)))
		i += copy(dAtA[i:], m.Password)
	}
	if len(m.BearerToken) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintExport(dAtA, i, uint64(len(m.BearerToken)))
		i += copy(dAtA[i:], m.BearerToken)
	}
	if len(m.CertData) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintExport(dAtA, i, uint64(len(m.CertData)))
		i += copy(dAtA[i:], m.CertData)
	}
	if len(m.KeyData) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintExport(dAtA, i, uint64(len(m.KeyData)))
		i += copy(dAtA[i:], m.KeyData)
	}
	if len(m.CaData) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintExport(dAtA, i, uint64(len(m.CaData)))
		i += copy(dAtA[i:], m.CaData)
	}
	if m.DisableServerAuthentication {
		dAtA[i] = 0x40
		i++
		if m.DisableServerAuthentication {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *PSMExportTarget) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PSMExportTarget) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Enable {
		dAtA[i] = 0x8
		i++
		if m.Enable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *PrivacyConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PrivacyConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Algo) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintExport(dAtA, i, uint64(len(m.Algo)))
		i += copy(dAtA[i:], m.Algo)
	}
	if len(m.Password) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintExport(dAtA, i, uint64(len(m.Password)))
		i += copy(dAtA[i:], m.Password)
	}
	return i, nil
}

func (m *SNMPTrapServer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SNMPTrapServer) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Host) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintExport(dAtA, i, uint64(len(m.Host)))
		i += copy(dAtA[i:], m.Host)
	}
	if len(m.Port) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintExport(dAtA, i, uint64(len(m.Port)))
		i += copy(dAtA[i:], m.Port)
	}
	if len(m.Version) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintExport(dAtA, i, uint64(len(m.Version)))
		i += copy(dAtA[i:], m.Version)
	}
	if len(m.CommunityOrUser) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintExport(dAtA, i, uint64(len(m.CommunityOrUser)))
		i += copy(dAtA[i:], m.CommunityOrUser)
	}
	if m.AuthConfig != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintExport(dAtA, i, uint64(m.AuthConfig.Size()))
		n2, err := m.AuthConfig.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.PrivacyConfig != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintExport(dAtA, i, uint64(m.PrivacyConfig.Size()))
		n3, err := m.PrivacyConfig.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}

func (m *SyslogExportConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SyslogExportConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.FacilityOverride) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintExport(dAtA, i, uint64(len(m.FacilityOverride)))
		i += copy(dAtA[i:], m.FacilityOverride)
	}
	if len(m.Prefix) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintExport(dAtA, i, uint64(len(m.Prefix)))
		i += copy(dAtA[i:], m.Prefix)
	}
	return i, nil
}

func encodeVarintExport(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *AuthConfig) Size() (n int) {
	var l int
	_ = l
	l = len(m.Algo)
	if l > 0 {
		n += 1 + l + sovExport(uint64(l))
	}
	l = len(m.Password)
	if l > 0 {
		n += 1 + l + sovExport(uint64(l))
	}
	return n
}

func (m *ExportConfig) Size() (n int) {
	var l int
	_ = l
	l = len(m.Destination)
	if l > 0 {
		n += 1 + l + sovExport(uint64(l))
	}
	l = len(m.Gateway)
	if l > 0 {
		n += 1 + l + sovExport(uint64(l))
	}
	l = len(m.Transport)
	if l > 0 {
		n += 1 + l + sovExport(uint64(l))
	}
	if m.Credentials != nil {
		l = m.Credentials.Size()
		n += 1 + l + sovExport(uint64(l))
	}
	return n
}

func (m *ExternalCred) Size() (n int) {
	var l int
	_ = l
	l = len(m.AuthType)
	if l > 0 {
		n += 1 + l + sovExport(uint64(l))
	}
	l = len(m.UserName)
	if l > 0 {
		n += 1 + l + sovExport(uint64(l))
	}
	l = len(m.Password)
	if l > 0 {
		n += 1 + l + sovExport(uint64(l))
	}
	l = len(m.BearerToken)
	if l > 0 {
		n += 1 + l + sovExport(uint64(l))
	}
	l = len(m.CertData)
	if l > 0 {
		n += 1 + l + sovExport(uint64(l))
	}
	l = len(m.KeyData)
	if l > 0 {
		n += 1 + l + sovExport(uint64(l))
	}
	l = len(m.CaData)
	if l > 0 {
		n += 1 + l + sovExport(uint64(l))
	}
	if m.DisableServerAuthentication {
		n += 2
	}
	return n
}

func (m *PSMExportTarget) Size() (n int) {
	var l int
	_ = l
	if m.Enable {
		n += 2
	}
	return n
}

func (m *PrivacyConfig) Size() (n int) {
	var l int
	_ = l
	l = len(m.Algo)
	if l > 0 {
		n += 1 + l + sovExport(uint64(l))
	}
	l = len(m.Password)
	if l > 0 {
		n += 1 + l + sovExport(uint64(l))
	}
	return n
}

func (m *SNMPTrapServer) Size() (n int) {
	var l int
	_ = l
	l = len(m.Host)
	if l > 0 {
		n += 1 + l + sovExport(uint64(l))
	}
	l = len(m.Port)
	if l > 0 {
		n += 1 + l + sovExport(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovExport(uint64(l))
	}
	l = len(m.CommunityOrUser)
	if l > 0 {
		n += 1 + l + sovExport(uint64(l))
	}
	if m.AuthConfig != nil {
		l = m.AuthConfig.Size()
		n += 1 + l + sovExport(uint64(l))
	}
	if m.PrivacyConfig != nil {
		l = m.PrivacyConfig.Size()
		n += 1 + l + sovExport(uint64(l))
	}
	return n
}

func (m *SyslogExportConfig) Size() (n int) {
	var l int
	_ = l
	l = len(m.FacilityOverride)
	if l > 0 {
		n += 1 + l + sovExport(uint64(l))
	}
	l = len(m.Prefix)
	if l > 0 {
		n += 1 + l + sovExport(uint64(l))
	}
	return n
}

func sovExport(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozExport(x uint64) (n int) {
	return sovExport(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *AuthConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuthConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuthConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Algo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExport
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Algo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Password", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExport
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Password = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipExport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthExport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExportConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExportConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExportConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Destination", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExport
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Destination = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gateway", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExport
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Gateway = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Transport", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExport
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Transport = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Credentials", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExport
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Credentials == nil {
				m.Credentials = &ExternalCred{}
			}
			if err := m.Credentials.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipExport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthExport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExternalCred) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExternalCred: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExternalCred: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExport
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuthType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExport
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Password", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExport
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Password = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BearerToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExport
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BearerToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CertData", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExport
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CertData = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyData", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExport
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyData = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CaData", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExport
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CaData = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableServerAuthentication", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DisableServerAuthentication = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipExport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthExport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PSMExportTarget) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PSMExportTarget: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PSMExportTarget: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enable = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipExport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthExport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PrivacyConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PrivacyConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PrivacyConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Algo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExport
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Algo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Password", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExport
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Password = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipExport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthExport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SNMPTrapServer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SNMPTrapServer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SNMPTrapServer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Host", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExport
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Host = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExport
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Port = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExport
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommunityOrUser", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExport
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CommunityOrUser = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExport
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AuthConfig == nil {
				m.AuthConfig = &AuthConfig{}
			}
			if err := m.AuthConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrivacyConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExport
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PrivacyConfig == nil {
				m.PrivacyConfig = &PrivacyConfig{}
			}
			if err := m.PrivacyConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipExport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthExport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SyslogExportConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SyslogExportConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SyslogExportConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FacilityOverride", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExport
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FacilityOverride = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExport
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Prefix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipExport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthExport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipExport(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowExport
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowExport
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowExport
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthExport
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowExport
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipExport(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthExport = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowExport   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("export.proto", fileDescriptorExport) }

var fileDescriptorExport = []byte{
	// 1410 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x56, 0xcd, 0x4f, 0x1b, 0x47,
	0x1b, 0x67, 0xc1, 0x80, 0x19, 0x08, 0x99, 0x4c, 0x12, 0xe2, 0x35, 0x79, 0x6d, 0x5e, 0x2b, 0x7a,
	0x63, 0x92, 0x18, 0x83, 0xf9, 0x08, 0x87, 0xf7, 0x7d, 0x55, 0xdb, 0x6c, 0x20, 0x02, 0x6c, 0xcb,
	0x6b, 0xa0, 0x51, 0x0f, 0xd1, 0xb0, 0x1e, 0xcc, 0x2a, 0xeb, 0x1d, 0x6b, 0x76, 0x0c, 0xf1, 0xad,
	0x27, 0x8b, 0x63, 0x8f, 0x3d, 0xb6, 0x97, 0xaa, 0xe2, 0x54, 0xe5, 0x54, 0xf5, 0x50, 0xa9, 0xa7,
	0x46, 0xea, 0xa5, 0x7f, 0x01, 0xaa, 0x7c, 0xaa, 0x38, 0x54, 0xfd, 0x13, 0xaa, 0xd9, 0x0f, 0x3c,
	0x0b, 0x4e, 0xd4, 0x5b, 0x6f, 0xde, 0xdf, 0xef, 0x79, 0x7e, 0xcf, 0xc7, 0x3c, 0xf3, 0x8c, 0xc1,
	0x14, 0x79, 0xdb, 0xa2, 0x8c, 0x2f, 0xb4, 0x18, 0xe5, 0x14, 0x81, 0x26, 0xb5, 0x4d, 0x4e, 0x99,
	0x69, 0x37, 0xe2, 0x0f, 0x1b, 0x94, 0x36, 0x2c, 0x92, 0xc5, 0x2d, 0x33, 0x8b, 0x6d, 0x9b, 0x72,
	0xcc, 0x4d, 0x6a, 0x3b, 0x9e, 0x65, 0x5c, 0x6b, 0x98, 0xfc, 0xb8, 0x7d, 0xb8, 0x60, 0xd0, 0x66,
	0xb6, 0x45, 0x6c, 0x07, 0xdb, 0x75, 0x9a, 0x75, 0x4e, 0xb3, 0x27, 0xc4, 0x36, 0x0d, 0x92, 0x6d,
	0x73, 0xd3, 0x72, 0x84, 0x6b, 0x83, 0xd8, 0xb2, 0x77, 0xd6, 0xb4, 0x0d, 0xab, 0x5d, 0x27, 0x81,
	0x4c, 0x46, 0x92, 0x69, 0xd0, 0x06, 0xcd, 0xba, 0xf0, 0x61, 0xfb, 0xc8, 0xfd, 0x72, 0x3f, 0xdc,
	0x5f, 0x9e, 0x79, 0xea, 0x27, 0x05, 0x80, 0x7c, 0x9b, 0x1f, 0x17, 0xa9, 0x7d, 0x64, 0x36, 0x90,
	0x0e, 0x22, 0x79, 0xab, 0x41, 0x63, 0xca, 0x9c, 0x92, 0x9e, 0x28, 0xac, 0x9c, 0x77, 0x55, 0x55,
	0xe7, 0x4c, 0xb3, 0xdb, 0xcd, 0x74, 0xdf, 0x6a, 0x41, 0x98, 0x38, 0xf3, 0xef, 0x2f, 0x92, 0xca,
	0xe5, 0x45, 0xf2, 0x36, 0xb6, 0x1a, 0xf4, 0xd9, 0x1c, 0x6d, 0x9a, 0x9c, 0x34, 0x5b, 0xbc, 0x53,
	0xbd, 0x0e, 0xa0, 0x02, 0x88, 0x56, 0xb0, 0xe3, 0x9c, 0x52, 0x56, 0x8f, 0x0d, 0xbb, 0xc2, 0xb3,
	0xbe, 0xef, 0xdd, 0x96, 0x8f, 0xcb, 0xfe, 0x83, 0xc0, 0x54, 0x1c, 0x8c, 0xba, 0x51, 0xd1, 0x38,
	0x18, 0xd9, 0xdd, 0x58, 0x85, 0x43, 0x28, 0x0a, 0x22, 0xfa, 0x56, 0x7e, 0x09, 0x2a, 0xa9, 0x3f,
	0x86, 0xc1, 0x94, 0xe6, 0x36, 0xdd, 0xaf, 0xe2, 0x00, 0x4c, 0x6e, 0x10, 0x87, 0x9b, 0xb6, 0xdb,
	0x22, 0xbf, 0x98, 0xa7, 0xe7, 0x5d, 0x75, 0x5a, 0xe7, 0x6c, 0x87, 0xd8, 0xe9, 0xa5, 0x67, 0xb9,
	0xc5, 0x95, 0xf5, 0xf9, 0xcb, 0x8b, 0xe4, 0xfd, 0x7a, 0xdf, 0xf0, 0x59, 0x3f, 0x87, 0xc1, 0x30,
	0xda, 0x06, 0xe3, 0x9b, 0x98, 0x93, 0x53, 0xdc, 0xf1, 0x0b, 0x79, 0x2c, 0x89, 0x2e, 0x5e, 0x89,
	0xde, 0x69, 0x78, 0x46, 0x92, 0xe0, 0x4d, 0x08, 0x1d, 0x80, 0x89, 0x1a, 0xc3, 0xb6, 0x23, 0x12,
	0x8f, 0x8d, 0xb8, 0x72, 0xd9, 0xf3, 0xae, 0x7a, 0x4f, 0x13, 0x6c, 0x99, 0xa5, 0x2b, 0xe2, 0x80,
	0x2a, 0x94, 0xf1, 0xf4, 0xbc, 0x10, 0xbd, 0xcb, 0x03, 0x63, 0x49, 0x76, 0x10, 0x88, 0x5e, 0x83,
	0xc9, 0x22, 0x23, 0x75, 0x62, 0x73, 0x13, 0x5b, 0x4e, 0x2c, 0x32, 0xa7, 0xa4, 0x27, 0x73, 0xb1,
	0x85, 0xfe, 0x24, 0x2e, 0x68, 0x6f, 0x39, 0x61, 0x36, 0xb6, 0x84, 0x59, 0x41, 0x15, 0x6d, 0x30,
	0xfa, 0x0e, 0x72, 0x1b, 0x06, 0xc2, 0xa9, 0x3f, 0x23, 0xa2, 0xe1, 0x7d, 0x09, 0xa4, 0x81, 0xa8,
	0x18, 0x8f, 0x5a, 0xa7, 0x45, 0xfc, 0x6e, 0xa7, 0xcf, 0xbb, 0xea, 0x83, 0x60, 0x74, 0xbc, 0xc3,
	0x09, 0x2c, 0x44, 0x31, 0x13, 0xb8, 0xcd, 0x8f, 0x33, 0xbc, 0xd3, 0x22, 0xd5, 0xfe, 0x4f, 0xf4,
	0x5f, 0x10, 0xdd, 0x73, 0x08, 0x2b, 0xe1, 0x26, 0xf1, 0xfb, 0x3b, 0x73, 0x79, 0x91, 0x44, 0x6d,
	0x47, 0x44, 0x6a, 0x12, 0x29, 0xb1, 0x01, 0x18, 0xda, 0x92, 0xc6, 0xcc, 0x6b, 0x67, 0xea, 0x87,
	0xae, 0x1a, 0xd5, 0x89, 0xc1, 0x08, 0x4f, 0x8b, 0xa8, 0xe8, 0x6a, 0xb2, 0x24, 0xa5, 0x9b, 0x18,
	0xd2, 0xc1, 0x64, 0x81, 0x60, 0x46, 0x58, 0x8d, 0xbe, 0x21, 0xb6, 0xdb, 0xc0, 0x89, 0xc2, 0x7f,
	0xae, 0x89, 0xcd, 0x1c, 0xba, 0x26, 0x19, 0x2e, 0x6c, 0x24, 0xc1, 0x0f, 0xe0, 0xe8, 0xff, 0x20,
	0x5a, 0x24, 0x8c, 0x6f, 0x60, 0x8e, 0x63, 0xa3, 0xae, 0xe2, 0x03, 0x71, 0xaa, 0x06, 0x61, 0x3c,
	0x53, 0xc7, 0x1c, 0xcb, 0xa7, 0x3a, 0x00, 0x44, 0x9b, 0x60, 0x7c, 0x9b, 0x74, 0x5c, 0xf7, 0xb1,
	0xc1, 0xd5, 0xbd, 0x21, 0x9d, 0xeb, 0x4a, 0x03, 0x30, 0xb4, 0x0e, 0xc6, 0x8a, 0xd8, 0xd5, 0x19,
	0x77, 0x75, 0xee, 0x8b, 0x89, 0x35, 0xf0, 0x75, 0xd7, 0x9b, 0x10, 0xea, 0x80, 0xd9, 0x0d, 0xd3,
	0xc1, 0x87, 0x16, 0xd1, 0x09, 0x3b, 0x21, 0x4c, 0x9c, 0xa8, 0x98, 0x0e, 0xc3, 0xbb, 0x67, 0xd1,
	0x39, 0x25, 0x1d, 0x2d, 0x3c, 0xbd, 0xbc, 0x48, 0x3e, 0xae, 0x7b, 0x66, 0x19, 0xc7, 0xb5, 0xcb,
	0xe0, 0x90, 0xa1, 0x14, 0xe4, 0xef, 0x1a, 0xa6, 0xb6, 0xc1, 0xed, 0x8a, 0xbe, 0xeb, 0x0d, 0x52,
	0x0d, 0xb3, 0x06, 0xe1, 0xa2, 0x0e, 0xcd, 0x16, 0xce, 0xee, 0xc8, 0x45, 0xbd, 0x3a, 0x88, 0x8b,
	0xc8, 0xeb, 0xe4, 0x26, 0x94, 0xfa, 0x45, 0x01, 0xb7, 0x2a, 0xcc, 0x3c, 0xc1, 0x46, 0xc7, 0xdf,
	0x18, 0xfb, 0xa1, 0xbd, 0xf7, 0xfc, 0xbc, 0xab, 0x3e, 0x0c, 0x86, 0x37, 0x64, 0xf8, 0x4f, 0xac,
	0xbe, 0x44, 0xb0, 0xfa, 0x26, 0xc0, 0xe8, 0x86, 0xa6, 0xaf, 0xae, 0xc1, 0x21, 0x04, 0xc0, 0x58,
	0x5e, 0xd3, 0x97, 0x72, 0xeb, 0x50, 0x49, 0xfd, 0x18, 0x01, 0xd3, 0x7a, 0x69, 0xb7, 0x52, 0x63,
	0xb8, 0xe5, 0x9d, 0x0b, 0xca, 0x81, 0xc8, 0x16, 0x75, 0xb8, 0x5f, 0xce, 0x5d, 0x91, 0xea, 0x31,
	0x75, 0x78, 0x28, 0xd5, 0x6b, 0x00, 0xfa, 0x1f, 0x88, 0x88, 0x65, 0xe3, 0xa7, 0x99, 0x78, 0xd7,
	0x55, 0x47, 0x96, 0xd6, 0x72, 0x41, 0xa5, 0xee, 0x8a, 0x91, 0xdd, 0xaf, 0x01, 0xa8, 0x01, 0xc6,
	0xf7, 0x09, 0x73, 0xc4, 0x1c, 0x78, 0x97, 0xaf, 0x70, 0xde, 0x55, 0x1f, 0x05, 0x4d, 0x0c, 0xe7,
	0xb7, 0x20, 0x3e, 0x7d, 0xeb, 0xab, 0x66, 0xa2, 0x13, 0x0f, 0x90, 0xa3, 0x0c, 0xc0, 0xd0, 0x67,
	0xe0, 0x76, 0x91, 0x36, 0x9b, 0x6d, 0xdb, 0x14, 0x5b, 0x52, 0xec, 0x0b, 0xff, 0x82, 0x3e, 0xf2,
	0x85, 0x1e, 0x1a, 0x01, 0x9d, 0xa1, 0x2c, 0x23, 0x16, 0x85, 0x2c, 0xf9, 0x51, 0x16, 0x1d, 0xca,
	0xaf, 0xa1, 0x7b, 0x4d, 0x27, 0x73, 0x33, 0xf2, 0xe6, 0xec, 0xb3, 0x85, 0x84, 0x1f, 0x6f, 0xc6,
	0x5d, 0x60, 0x86, 0x0b, 0xca, 0x91, 0x3e, 0x80, 0x23, 0xfb, 0xda, 0xf0, 0xb9, 0xd7, 0x79, 0x32,
	0xa7, 0xca, 0x61, 0x42, 0x06, 0x85, 0x7f, 0xfb, 0x91, 0xd4, 0x96, 0x07, 0x0f, 0x08, 0xf6, 0x61,
	0x2a, 0x95, 0x04, 0x53, 0x72, 0xbf, 0xc5, 0x0b, 0xba, 0x9f, 0x2b, 0xc2, 0x21, 0x34, 0x06, 0x86,
	0xf7, 0x97, 0xa1, 0x92, 0xfa, 0x59, 0x01, 0x48, 0xef, 0x38, 0x16, 0x6d, 0x84, 0x5e, 0xd1, 0x0e,
	0x80, 0x2f, 0xb0, 0x61, 0x5a, 0xa2, 0xcf, 0x27, 0x84, 0x31, 0xb3, 0x1e, 0x2c, 0xf7, 0x82, 0xbc,
	0xdc, 0x3d, 0xcf, 0xc0, 0x72, 0xfe, 0x5d, 0x57, 0x8d, 0x88, 0xae, 0x5e, 0x5e, 0x24, 0x67, 0x8f,
	0x7c, 0x30, 0x43, 0x7d, 0x7f, 0xe9, 0xe6, 0x7f, 0x8c, 0x44, 0x6b, 0x60, 0xac, 0xc2, 0xc8, 0x91,
	0xf9, 0xd6, 0x9f, 0xc6, 0x7b, 0x97, 0x17, 0x49, 0xd8, 0x72, 0x11, 0x49, 0xe2, 0x06, 0xf2, 0xe4,
	0x6b, 0x05, 0x4c, 0x87, 0x1f, 0x1b, 0x34, 0x0b, 0x6e, 0xe5, 0xf7, 0x6a, 0x5b, 0xb5, 0x57, 0x15,
	0xed, 0x75, 0xa9, 0x5c, 0xd2, 0xe0, 0x50, 0x3c, 0xda, 0x3b, 0x53, 0x23, 0x36, 0xb5, 0x09, 0x5a,
	0x01, 0xea, 0x15, 0xb9, 0xa7, 0x6b, 0xd5, 0x52, 0x7e, 0x57, 0xab, 0xe4, 0x75, 0xfd, 0xa0, 0x5c,
	0xdd, 0x80, 0x4a, 0xfc, 0x7e, 0xef, 0x4c, 0xbd, 0x13, 0xbc, 0x34, 0x99, 0xe0, 0x6e, 0xa2, 0x7f,
	0x81, 0xe9, 0x2b, 0xaf, 0x5a, 0x79, 0x5b, 0x2b, 0xc1, 0xe1, 0xf8, 0x44, 0xef, 0x4c, 0x1d, 0x75,
	0x57, 0x7e, 0x88, 0x2e, 0x6a, 0xd5, 0x9a, 0x0e, 0x47, 0x3c, 0x5a, 0x6c, 0x75, 0xe7, 0xc9, 0x37,
	0xe2, 0xba, 0x86, 0x7a, 0x86, 0x62, 0x20, 0xba, 0x53, 0xde, 0x7c, 0xbd, 0xad, 0x55, 0x4b, 0x70,
	0x28, 0x0e, 0x7a, 0x67, 0xea, 0xd8, 0x1b, 0xc2, 0x6c, 0x62, 0xa1, 0x19, 0x8f, 0x11, 0xb9, 0xc1,
	0xa8, 0x97, 0xb8, 0xc8, 0x27, 0xc0, 0x77, 0xf3, 0x2f, 0x77, 0x20, 0xf4, 0xf0, 0x26, 0x36, 0x2d,
	0x14, 0x07, 0x40, 0xe0, 0x1b, 0x79, 0x6d, 0xb7, 0x5c, 0x82, 0x31, 0x4f, 0xab, 0x8e, 0x49, 0x93,
	0xda, 0x81, 0x8f, 0xc8, 0x0d, 0xce, 0x79, 0x3e, 0x62, 0x42, 0x03, 0x1f, 0xfd, 0x95, 0xbe, 0x53,
	0xde, 0x84, 0x69, 0xcf, 0xc7, 0x71, 0x33, 0x44, 0xf7, 0xc0, 0xb8, 0xe0, 0x76, 0x2a, 0x55, 0xb8,
	0x18, 0x1f, 0xef, 0x9d, 0xa9, 0x23, 0x56, 0xeb, 0x2a, 0x7a, 0x49, 0x3b, 0xd0, 0xe1, 0xba, 0xdf,
	0x4e, 0x72, 0xea, 0x5c, 0x65, 0xbb, 0x57, 0xac, 0xc0, 0x4f, 0xfc, 0x6c, 0xdb, 0x46, 0x2b, 0xc0,
	0x8b, 0xd5, 0x72, 0x09, 0x6e, 0x79, 0xb8, 0xc1, 0xa8, 0x8d, 0x12, 0x60, 0x2a, 0xc8, 0xa8, 0x52,
	0x7d, 0xb9, 0x0f, 0x2b, 0xf1, 0xa9, 0xde, 0x99, 0x1a, 0x15, 0x59, 0x89, 0x71, 0x0e, 0xa2, 0xbf,
	0xa8, 0x55, 0xe0, 0xa7, 0x5e, 0xf4, 0x23, 0xde, 0x42, 0xb3, 0x5e, 0xbe, 0x3b, 0xe5, 0x62, 0x7e,
	0x67, 0x11, 0x7e, 0xae, 0x78, 0x09, 0x5b, 0xd4, 0xc0, 0xd6, 0x62, 0x88, 0x5c, 0x82, 0x67, 0x32,
	0xb9, 0x14, 0x22, 0x73, 0xf0, 0x0b, 0x99, 0xcc, 0x85, 0xc8, 0x65, 0xf8, 0xa5, 0x4c, 0x2e, 0x87,
	0xc8, 0x15, 0xf8, 0x95, 0x4c, 0xae, 0x84, 0xc8, 0x55, 0xf8, 0xad, 0x4c, 0xae, 0x86, 0xc8, 0x35,
	0xf8, 0x9d, 0x4c, 0xae, 0x85, 0xc8, 0xe7, 0xf0, 0x7b, 0x99, 0x7c, 0x5e, 0x80, 0xef, 0x7b, 0x09,
	0xe5, 0xd7, 0x5e, 0x42, 0xf9, 0xad, 0x97, 0x50, 0x7e, 0xef, 0x25, 0x86, 0x2a, 0xca, 0xe1, 0x98,
	0xfb, 0xaf, 0x7d, 0xf9, 0xaf, 0x00, 0x00, 0x00, 0xff, 0xff, 0x3f, 0x9c, 0x02, 0x1e, 0x65, 0x0c,
	0x00, 0x00,
}
