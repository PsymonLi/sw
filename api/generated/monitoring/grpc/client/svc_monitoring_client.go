// Code generated by protoc-gen-grpc-pensando DO NOT EDIT.

package grpcclient

import (
	"context"
	"errors"
	oldlog "log"
	"net/http"

	"github.com/go-kit/kit/endpoint"
	grpctransport "github.com/go-kit/kit/transport/grpc"
	"google.golang.org/grpc"

	api "github.com/pensando/sw/api"
	monitoring "github.com/pensando/sw/api/generated/monitoring"
	"github.com/pensando/sw/api/interfaces"
	listerwatcher "github.com/pensando/sw/api/listerwatcher"
	"github.com/pensando/sw/venice/globals"
	"github.com/pensando/sw/venice/utils/kvstore"
	"github.com/pensando/sw/venice/utils/log"
	"github.com/pensando/sw/venice/utils/trace"
)

// Dummy vars to suppress import errors
var _ api.TypeMeta
var _ listerwatcher.WatcherClient
var _ kvstore.Interface

// NewMonitoringV1 sets up a new client for MonitoringV1
func NewMonitoringV1(conn *grpc.ClientConn, logger log.Logger) monitoring.ServiceMonitoringV1Client {

	var lAutoAddAlertEndpoint endpoint.Endpoint
	{
		lAutoAddAlertEndpoint = grpctransport.NewClient(
			conn,
			"monitoring.MonitoringV1",
			"AutoAddAlert",
			monitoring.EncodeGrpcReqAlert,
			monitoring.DecodeGrpcRespAlert,
			&monitoring.Alert{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoAddAlertEndpoint = trace.ClientEndPoint("MonitoringV1:AutoAddAlert")(lAutoAddAlertEndpoint)
	}
	var lAutoAddAlertDestinationEndpoint endpoint.Endpoint
	{
		lAutoAddAlertDestinationEndpoint = grpctransport.NewClient(
			conn,
			"monitoring.MonitoringV1",
			"AutoAddAlertDestination",
			monitoring.EncodeGrpcReqAlertDestination,
			monitoring.DecodeGrpcRespAlertDestination,
			&monitoring.AlertDestination{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoAddAlertDestinationEndpoint = trace.ClientEndPoint("MonitoringV1:AutoAddAlertDestination")(lAutoAddAlertDestinationEndpoint)
	}
	var lAutoAddAlertPolicyEndpoint endpoint.Endpoint
	{
		lAutoAddAlertPolicyEndpoint = grpctransport.NewClient(
			conn,
			"monitoring.MonitoringV1",
			"AutoAddAlertPolicy",
			monitoring.EncodeGrpcReqAlertPolicy,
			monitoring.DecodeGrpcRespAlertPolicy,
			&monitoring.AlertPolicy{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoAddAlertPolicyEndpoint = trace.ClientEndPoint("MonitoringV1:AutoAddAlertPolicy")(lAutoAddAlertPolicyEndpoint)
	}
	var lAutoAddArchiveRequestEndpoint endpoint.Endpoint
	{
		lAutoAddArchiveRequestEndpoint = grpctransport.NewClient(
			conn,
			"monitoring.MonitoringV1",
			"AutoAddArchiveRequest",
			monitoring.EncodeGrpcReqArchiveRequest,
			monitoring.DecodeGrpcRespArchiveRequest,
			&monitoring.ArchiveRequest{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoAddArchiveRequestEndpoint = trace.ClientEndPoint("MonitoringV1:AutoAddArchiveRequest")(lAutoAddArchiveRequestEndpoint)
	}
	var lAutoAddAuditPolicyEndpoint endpoint.Endpoint
	{
		lAutoAddAuditPolicyEndpoint = grpctransport.NewClient(
			conn,
			"monitoring.MonitoringV1",
			"AutoAddAuditPolicy",
			monitoring.EncodeGrpcReqAuditPolicy,
			monitoring.DecodeGrpcRespAuditPolicy,
			&monitoring.AuditPolicy{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoAddAuditPolicyEndpoint = trace.ClientEndPoint("MonitoringV1:AutoAddAuditPolicy")(lAutoAddAuditPolicyEndpoint)
	}
	var lAutoAddEventPolicyEndpoint endpoint.Endpoint
	{
		lAutoAddEventPolicyEndpoint = grpctransport.NewClient(
			conn,
			"monitoring.MonitoringV1",
			"AutoAddEventPolicy",
			monitoring.EncodeGrpcReqEventPolicy,
			monitoring.DecodeGrpcRespEventPolicy,
			&monitoring.EventPolicy{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoAddEventPolicyEndpoint = trace.ClientEndPoint("MonitoringV1:AutoAddEventPolicy")(lAutoAddEventPolicyEndpoint)
	}
	var lAutoAddFlowExportPolicyEndpoint endpoint.Endpoint
	{
		lAutoAddFlowExportPolicyEndpoint = grpctransport.NewClient(
			conn,
			"monitoring.MonitoringV1",
			"AutoAddFlowExportPolicy",
			monitoring.EncodeGrpcReqFlowExportPolicy,
			monitoring.DecodeGrpcRespFlowExportPolicy,
			&monitoring.FlowExportPolicy{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoAddFlowExportPolicyEndpoint = trace.ClientEndPoint("MonitoringV1:AutoAddFlowExportPolicy")(lAutoAddFlowExportPolicyEndpoint)
	}
	var lAutoAddFwlogPolicyEndpoint endpoint.Endpoint
	{
		lAutoAddFwlogPolicyEndpoint = grpctransport.NewClient(
			conn,
			"monitoring.MonitoringV1",
			"AutoAddFwlogPolicy",
			monitoring.EncodeGrpcReqFwlogPolicy,
			monitoring.DecodeGrpcRespFwlogPolicy,
			&monitoring.FwlogPolicy{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoAddFwlogPolicyEndpoint = trace.ClientEndPoint("MonitoringV1:AutoAddFwlogPolicy")(lAutoAddFwlogPolicyEndpoint)
	}
	var lAutoAddMirrorSessionEndpoint endpoint.Endpoint
	{
		lAutoAddMirrorSessionEndpoint = grpctransport.NewClient(
			conn,
			"monitoring.MonitoringV1",
			"AutoAddMirrorSession",
			monitoring.EncodeGrpcReqMirrorSession,
			monitoring.DecodeGrpcRespMirrorSession,
			&monitoring.MirrorSession{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoAddMirrorSessionEndpoint = trace.ClientEndPoint("MonitoringV1:AutoAddMirrorSession")(lAutoAddMirrorSessionEndpoint)
	}
	var lAutoAddTechSupportRequestEndpoint endpoint.Endpoint
	{
		lAutoAddTechSupportRequestEndpoint = grpctransport.NewClient(
			conn,
			"monitoring.MonitoringV1",
			"AutoAddTechSupportRequest",
			monitoring.EncodeGrpcReqTechSupportRequest,
			monitoring.DecodeGrpcRespTechSupportRequest,
			&monitoring.TechSupportRequest{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoAddTechSupportRequestEndpoint = trace.ClientEndPoint("MonitoringV1:AutoAddTechSupportRequest")(lAutoAddTechSupportRequestEndpoint)
	}
	var lAutoAddTroubleshootingSessionEndpoint endpoint.Endpoint
	{
		lAutoAddTroubleshootingSessionEndpoint = grpctransport.NewClient(
			conn,
			"monitoring.MonitoringV1",
			"AutoAddTroubleshootingSession",
			monitoring.EncodeGrpcReqTroubleshootingSession,
			monitoring.DecodeGrpcRespTroubleshootingSession,
			&monitoring.TroubleshootingSession{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoAddTroubleshootingSessionEndpoint = trace.ClientEndPoint("MonitoringV1:AutoAddTroubleshootingSession")(lAutoAddTroubleshootingSessionEndpoint)
	}
	var lAutoDeleteAlertEndpoint endpoint.Endpoint
	{
		lAutoDeleteAlertEndpoint = grpctransport.NewClient(
			conn,
			"monitoring.MonitoringV1",
			"AutoDeleteAlert",
			monitoring.EncodeGrpcReqAlert,
			monitoring.DecodeGrpcRespAlert,
			&monitoring.Alert{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoDeleteAlertEndpoint = trace.ClientEndPoint("MonitoringV1:AutoDeleteAlert")(lAutoDeleteAlertEndpoint)
	}
	var lAutoDeleteAlertDestinationEndpoint endpoint.Endpoint
	{
		lAutoDeleteAlertDestinationEndpoint = grpctransport.NewClient(
			conn,
			"monitoring.MonitoringV1",
			"AutoDeleteAlertDestination",
			monitoring.EncodeGrpcReqAlertDestination,
			monitoring.DecodeGrpcRespAlertDestination,
			&monitoring.AlertDestination{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoDeleteAlertDestinationEndpoint = trace.ClientEndPoint("MonitoringV1:AutoDeleteAlertDestination")(lAutoDeleteAlertDestinationEndpoint)
	}
	var lAutoDeleteAlertPolicyEndpoint endpoint.Endpoint
	{
		lAutoDeleteAlertPolicyEndpoint = grpctransport.NewClient(
			conn,
			"monitoring.MonitoringV1",
			"AutoDeleteAlertPolicy",
			monitoring.EncodeGrpcReqAlertPolicy,
			monitoring.DecodeGrpcRespAlertPolicy,
			&monitoring.AlertPolicy{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoDeleteAlertPolicyEndpoint = trace.ClientEndPoint("MonitoringV1:AutoDeleteAlertPolicy")(lAutoDeleteAlertPolicyEndpoint)
	}
	var lAutoDeleteArchiveRequestEndpoint endpoint.Endpoint
	{
		lAutoDeleteArchiveRequestEndpoint = grpctransport.NewClient(
			conn,
			"monitoring.MonitoringV1",
			"AutoDeleteArchiveRequest",
			monitoring.EncodeGrpcReqArchiveRequest,
			monitoring.DecodeGrpcRespArchiveRequest,
			&monitoring.ArchiveRequest{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoDeleteArchiveRequestEndpoint = trace.ClientEndPoint("MonitoringV1:AutoDeleteArchiveRequest")(lAutoDeleteArchiveRequestEndpoint)
	}
	var lAutoDeleteAuditPolicyEndpoint endpoint.Endpoint
	{
		lAutoDeleteAuditPolicyEndpoint = grpctransport.NewClient(
			conn,
			"monitoring.MonitoringV1",
			"AutoDeleteAuditPolicy",
			monitoring.EncodeGrpcReqAuditPolicy,
			monitoring.DecodeGrpcRespAuditPolicy,
			&monitoring.AuditPolicy{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoDeleteAuditPolicyEndpoint = trace.ClientEndPoint("MonitoringV1:AutoDeleteAuditPolicy")(lAutoDeleteAuditPolicyEndpoint)
	}
	var lAutoDeleteEventPolicyEndpoint endpoint.Endpoint
	{
		lAutoDeleteEventPolicyEndpoint = grpctransport.NewClient(
			conn,
			"monitoring.MonitoringV1",
			"AutoDeleteEventPolicy",
			monitoring.EncodeGrpcReqEventPolicy,
			monitoring.DecodeGrpcRespEventPolicy,
			&monitoring.EventPolicy{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoDeleteEventPolicyEndpoint = trace.ClientEndPoint("MonitoringV1:AutoDeleteEventPolicy")(lAutoDeleteEventPolicyEndpoint)
	}
	var lAutoDeleteFlowExportPolicyEndpoint endpoint.Endpoint
	{
		lAutoDeleteFlowExportPolicyEndpoint = grpctransport.NewClient(
			conn,
			"monitoring.MonitoringV1",
			"AutoDeleteFlowExportPolicy",
			monitoring.EncodeGrpcReqFlowExportPolicy,
			monitoring.DecodeGrpcRespFlowExportPolicy,
			&monitoring.FlowExportPolicy{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoDeleteFlowExportPolicyEndpoint = trace.ClientEndPoint("MonitoringV1:AutoDeleteFlowExportPolicy")(lAutoDeleteFlowExportPolicyEndpoint)
	}
	var lAutoDeleteFwlogPolicyEndpoint endpoint.Endpoint
	{
		lAutoDeleteFwlogPolicyEndpoint = grpctransport.NewClient(
			conn,
			"monitoring.MonitoringV1",
			"AutoDeleteFwlogPolicy",
			monitoring.EncodeGrpcReqFwlogPolicy,
			monitoring.DecodeGrpcRespFwlogPolicy,
			&monitoring.FwlogPolicy{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoDeleteFwlogPolicyEndpoint = trace.ClientEndPoint("MonitoringV1:AutoDeleteFwlogPolicy")(lAutoDeleteFwlogPolicyEndpoint)
	}
	var lAutoDeleteMirrorSessionEndpoint endpoint.Endpoint
	{
		lAutoDeleteMirrorSessionEndpoint = grpctransport.NewClient(
			conn,
			"monitoring.MonitoringV1",
			"AutoDeleteMirrorSession",
			monitoring.EncodeGrpcReqMirrorSession,
			monitoring.DecodeGrpcRespMirrorSession,
			&monitoring.MirrorSession{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoDeleteMirrorSessionEndpoint = trace.ClientEndPoint("MonitoringV1:AutoDeleteMirrorSession")(lAutoDeleteMirrorSessionEndpoint)
	}
	var lAutoDeleteTechSupportRequestEndpoint endpoint.Endpoint
	{
		lAutoDeleteTechSupportRequestEndpoint = grpctransport.NewClient(
			conn,
			"monitoring.MonitoringV1",
			"AutoDeleteTechSupportRequest",
			monitoring.EncodeGrpcReqTechSupportRequest,
			monitoring.DecodeGrpcRespTechSupportRequest,
			&monitoring.TechSupportRequest{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoDeleteTechSupportRequestEndpoint = trace.ClientEndPoint("MonitoringV1:AutoDeleteTechSupportRequest")(lAutoDeleteTechSupportRequestEndpoint)
	}
	var lAutoDeleteTroubleshootingSessionEndpoint endpoint.Endpoint
	{
		lAutoDeleteTroubleshootingSessionEndpoint = grpctransport.NewClient(
			conn,
			"monitoring.MonitoringV1",
			"AutoDeleteTroubleshootingSession",
			monitoring.EncodeGrpcReqTroubleshootingSession,
			monitoring.DecodeGrpcRespTroubleshootingSession,
			&monitoring.TroubleshootingSession{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoDeleteTroubleshootingSessionEndpoint = trace.ClientEndPoint("MonitoringV1:AutoDeleteTroubleshootingSession")(lAutoDeleteTroubleshootingSessionEndpoint)
	}
	var lAutoGetAlertEndpoint endpoint.Endpoint
	{
		lAutoGetAlertEndpoint = grpctransport.NewClient(
			conn,
			"monitoring.MonitoringV1",
			"AutoGetAlert",
			monitoring.EncodeGrpcReqAlert,
			monitoring.DecodeGrpcRespAlert,
			&monitoring.Alert{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoGetAlertEndpoint = trace.ClientEndPoint("MonitoringV1:AutoGetAlert")(lAutoGetAlertEndpoint)
	}
	var lAutoGetAlertDestinationEndpoint endpoint.Endpoint
	{
		lAutoGetAlertDestinationEndpoint = grpctransport.NewClient(
			conn,
			"monitoring.MonitoringV1",
			"AutoGetAlertDestination",
			monitoring.EncodeGrpcReqAlertDestination,
			monitoring.DecodeGrpcRespAlertDestination,
			&monitoring.AlertDestination{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoGetAlertDestinationEndpoint = trace.ClientEndPoint("MonitoringV1:AutoGetAlertDestination")(lAutoGetAlertDestinationEndpoint)
	}
	var lAutoGetAlertPolicyEndpoint endpoint.Endpoint
	{
		lAutoGetAlertPolicyEndpoint = grpctransport.NewClient(
			conn,
			"monitoring.MonitoringV1",
			"AutoGetAlertPolicy",
			monitoring.EncodeGrpcReqAlertPolicy,
			monitoring.DecodeGrpcRespAlertPolicy,
			&monitoring.AlertPolicy{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoGetAlertPolicyEndpoint = trace.ClientEndPoint("MonitoringV1:AutoGetAlertPolicy")(lAutoGetAlertPolicyEndpoint)
	}
	var lAutoGetArchiveRequestEndpoint endpoint.Endpoint
	{
		lAutoGetArchiveRequestEndpoint = grpctransport.NewClient(
			conn,
			"monitoring.MonitoringV1",
			"AutoGetArchiveRequest",
			monitoring.EncodeGrpcReqArchiveRequest,
			monitoring.DecodeGrpcRespArchiveRequest,
			&monitoring.ArchiveRequest{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoGetArchiveRequestEndpoint = trace.ClientEndPoint("MonitoringV1:AutoGetArchiveRequest")(lAutoGetArchiveRequestEndpoint)
	}
	var lAutoGetAuditPolicyEndpoint endpoint.Endpoint
	{
		lAutoGetAuditPolicyEndpoint = grpctransport.NewClient(
			conn,
			"monitoring.MonitoringV1",
			"AutoGetAuditPolicy",
			monitoring.EncodeGrpcReqAuditPolicy,
			monitoring.DecodeGrpcRespAuditPolicy,
			&monitoring.AuditPolicy{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoGetAuditPolicyEndpoint = trace.ClientEndPoint("MonitoringV1:AutoGetAuditPolicy")(lAutoGetAuditPolicyEndpoint)
	}
	var lAutoGetEventPolicyEndpoint endpoint.Endpoint
	{
		lAutoGetEventPolicyEndpoint = grpctransport.NewClient(
			conn,
			"monitoring.MonitoringV1",
			"AutoGetEventPolicy",
			monitoring.EncodeGrpcReqEventPolicy,
			monitoring.DecodeGrpcRespEventPolicy,
			&monitoring.EventPolicy{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoGetEventPolicyEndpoint = trace.ClientEndPoint("MonitoringV1:AutoGetEventPolicy")(lAutoGetEventPolicyEndpoint)
	}
	var lAutoGetFlowExportPolicyEndpoint endpoint.Endpoint
	{
		lAutoGetFlowExportPolicyEndpoint = grpctransport.NewClient(
			conn,
			"monitoring.MonitoringV1",
			"AutoGetFlowExportPolicy",
			monitoring.EncodeGrpcReqFlowExportPolicy,
			monitoring.DecodeGrpcRespFlowExportPolicy,
			&monitoring.FlowExportPolicy{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoGetFlowExportPolicyEndpoint = trace.ClientEndPoint("MonitoringV1:AutoGetFlowExportPolicy")(lAutoGetFlowExportPolicyEndpoint)
	}
	var lAutoGetFwlogPolicyEndpoint endpoint.Endpoint
	{
		lAutoGetFwlogPolicyEndpoint = grpctransport.NewClient(
			conn,
			"monitoring.MonitoringV1",
			"AutoGetFwlogPolicy",
			monitoring.EncodeGrpcReqFwlogPolicy,
			monitoring.DecodeGrpcRespFwlogPolicy,
			&monitoring.FwlogPolicy{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoGetFwlogPolicyEndpoint = trace.ClientEndPoint("MonitoringV1:AutoGetFwlogPolicy")(lAutoGetFwlogPolicyEndpoint)
	}
	var lAutoGetMirrorSessionEndpoint endpoint.Endpoint
	{
		lAutoGetMirrorSessionEndpoint = grpctransport.NewClient(
			conn,
			"monitoring.MonitoringV1",
			"AutoGetMirrorSession",
			monitoring.EncodeGrpcReqMirrorSession,
			monitoring.DecodeGrpcRespMirrorSession,
			&monitoring.MirrorSession{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoGetMirrorSessionEndpoint = trace.ClientEndPoint("MonitoringV1:AutoGetMirrorSession")(lAutoGetMirrorSessionEndpoint)
	}
	var lAutoGetTechSupportRequestEndpoint endpoint.Endpoint
	{
		lAutoGetTechSupportRequestEndpoint = grpctransport.NewClient(
			conn,
			"monitoring.MonitoringV1",
			"AutoGetTechSupportRequest",
			monitoring.EncodeGrpcReqTechSupportRequest,
			monitoring.DecodeGrpcRespTechSupportRequest,
			&monitoring.TechSupportRequest{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoGetTechSupportRequestEndpoint = trace.ClientEndPoint("MonitoringV1:AutoGetTechSupportRequest")(lAutoGetTechSupportRequestEndpoint)
	}
	var lAutoGetTroubleshootingSessionEndpoint endpoint.Endpoint
	{
		lAutoGetTroubleshootingSessionEndpoint = grpctransport.NewClient(
			conn,
			"monitoring.MonitoringV1",
			"AutoGetTroubleshootingSession",
			monitoring.EncodeGrpcReqTroubleshootingSession,
			monitoring.DecodeGrpcRespTroubleshootingSession,
			&monitoring.TroubleshootingSession{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoGetTroubleshootingSessionEndpoint = trace.ClientEndPoint("MonitoringV1:AutoGetTroubleshootingSession")(lAutoGetTroubleshootingSessionEndpoint)
	}
	var lAutoLabelAlertEndpoint endpoint.Endpoint
	{
		lAutoLabelAlertEndpoint = grpctransport.NewClient(
			conn,
			"monitoring.MonitoringV1",
			"AutoLabelAlert",
			monitoring.EncodeGrpcReqLabel,
			monitoring.DecodeGrpcRespAlert,
			&monitoring.Alert{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoLabelAlertEndpoint = trace.ClientEndPoint("MonitoringV1:AutoLabelAlert")(lAutoLabelAlertEndpoint)
	}
	var lAutoLabelAlertDestinationEndpoint endpoint.Endpoint
	{
		lAutoLabelAlertDestinationEndpoint = grpctransport.NewClient(
			conn,
			"monitoring.MonitoringV1",
			"AutoLabelAlertDestination",
			monitoring.EncodeGrpcReqLabel,
			monitoring.DecodeGrpcRespAlertDestination,
			&monitoring.AlertDestination{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoLabelAlertDestinationEndpoint = trace.ClientEndPoint("MonitoringV1:AutoLabelAlertDestination")(lAutoLabelAlertDestinationEndpoint)
	}
	var lAutoLabelAlertPolicyEndpoint endpoint.Endpoint
	{
		lAutoLabelAlertPolicyEndpoint = grpctransport.NewClient(
			conn,
			"monitoring.MonitoringV1",
			"AutoLabelAlertPolicy",
			monitoring.EncodeGrpcReqLabel,
			monitoring.DecodeGrpcRespAlertPolicy,
			&monitoring.AlertPolicy{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoLabelAlertPolicyEndpoint = trace.ClientEndPoint("MonitoringV1:AutoLabelAlertPolicy")(lAutoLabelAlertPolicyEndpoint)
	}
	var lAutoLabelArchiveRequestEndpoint endpoint.Endpoint
	{
		lAutoLabelArchiveRequestEndpoint = grpctransport.NewClient(
			conn,
			"monitoring.MonitoringV1",
			"AutoLabelArchiveRequest",
			monitoring.EncodeGrpcReqLabel,
			monitoring.DecodeGrpcRespArchiveRequest,
			&monitoring.ArchiveRequest{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoLabelArchiveRequestEndpoint = trace.ClientEndPoint("MonitoringV1:AutoLabelArchiveRequest")(lAutoLabelArchiveRequestEndpoint)
	}
	var lAutoLabelAuditPolicyEndpoint endpoint.Endpoint
	{
		lAutoLabelAuditPolicyEndpoint = grpctransport.NewClient(
			conn,
			"monitoring.MonitoringV1",
			"AutoLabelAuditPolicy",
			monitoring.EncodeGrpcReqLabel,
			monitoring.DecodeGrpcRespAuditPolicy,
			&monitoring.AuditPolicy{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoLabelAuditPolicyEndpoint = trace.ClientEndPoint("MonitoringV1:AutoLabelAuditPolicy")(lAutoLabelAuditPolicyEndpoint)
	}
	var lAutoLabelEventPolicyEndpoint endpoint.Endpoint
	{
		lAutoLabelEventPolicyEndpoint = grpctransport.NewClient(
			conn,
			"monitoring.MonitoringV1",
			"AutoLabelEventPolicy",
			monitoring.EncodeGrpcReqLabel,
			monitoring.DecodeGrpcRespEventPolicy,
			&monitoring.EventPolicy{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoLabelEventPolicyEndpoint = trace.ClientEndPoint("MonitoringV1:AutoLabelEventPolicy")(lAutoLabelEventPolicyEndpoint)
	}
	var lAutoLabelFlowExportPolicyEndpoint endpoint.Endpoint
	{
		lAutoLabelFlowExportPolicyEndpoint = grpctransport.NewClient(
			conn,
			"monitoring.MonitoringV1",
			"AutoLabelFlowExportPolicy",
			monitoring.EncodeGrpcReqLabel,
			monitoring.DecodeGrpcRespFlowExportPolicy,
			&monitoring.FlowExportPolicy{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoLabelFlowExportPolicyEndpoint = trace.ClientEndPoint("MonitoringV1:AutoLabelFlowExportPolicy")(lAutoLabelFlowExportPolicyEndpoint)
	}
	var lAutoLabelFwlogPolicyEndpoint endpoint.Endpoint
	{
		lAutoLabelFwlogPolicyEndpoint = grpctransport.NewClient(
			conn,
			"monitoring.MonitoringV1",
			"AutoLabelFwlogPolicy",
			monitoring.EncodeGrpcReqLabel,
			monitoring.DecodeGrpcRespFwlogPolicy,
			&monitoring.FwlogPolicy{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoLabelFwlogPolicyEndpoint = trace.ClientEndPoint("MonitoringV1:AutoLabelFwlogPolicy")(lAutoLabelFwlogPolicyEndpoint)
	}
	var lAutoLabelMirrorSessionEndpoint endpoint.Endpoint
	{
		lAutoLabelMirrorSessionEndpoint = grpctransport.NewClient(
			conn,
			"monitoring.MonitoringV1",
			"AutoLabelMirrorSession",
			monitoring.EncodeGrpcReqLabel,
			monitoring.DecodeGrpcRespMirrorSession,
			&monitoring.MirrorSession{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoLabelMirrorSessionEndpoint = trace.ClientEndPoint("MonitoringV1:AutoLabelMirrorSession")(lAutoLabelMirrorSessionEndpoint)
	}
	var lAutoLabelTechSupportRequestEndpoint endpoint.Endpoint
	{
		lAutoLabelTechSupportRequestEndpoint = grpctransport.NewClient(
			conn,
			"monitoring.MonitoringV1",
			"AutoLabelTechSupportRequest",
			monitoring.EncodeGrpcReqLabel,
			monitoring.DecodeGrpcRespTechSupportRequest,
			&monitoring.TechSupportRequest{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoLabelTechSupportRequestEndpoint = trace.ClientEndPoint("MonitoringV1:AutoLabelTechSupportRequest")(lAutoLabelTechSupportRequestEndpoint)
	}
	var lAutoLabelTroubleshootingSessionEndpoint endpoint.Endpoint
	{
		lAutoLabelTroubleshootingSessionEndpoint = grpctransport.NewClient(
			conn,
			"monitoring.MonitoringV1",
			"AutoLabelTroubleshootingSession",
			monitoring.EncodeGrpcReqLabel,
			monitoring.DecodeGrpcRespTroubleshootingSession,
			&monitoring.TroubleshootingSession{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoLabelTroubleshootingSessionEndpoint = trace.ClientEndPoint("MonitoringV1:AutoLabelTroubleshootingSession")(lAutoLabelTroubleshootingSessionEndpoint)
	}
	var lAutoListAlertEndpoint endpoint.Endpoint
	{
		lAutoListAlertEndpoint = grpctransport.NewClient(
			conn,
			"monitoring.MonitoringV1",
			"AutoListAlert",
			monitoring.EncodeGrpcReqListWatchOptions,
			monitoring.DecodeGrpcRespAlertList,
			&monitoring.AlertList{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoListAlertEndpoint = trace.ClientEndPoint("MonitoringV1:AutoListAlert")(lAutoListAlertEndpoint)
	}
	var lAutoListAlertDestinationEndpoint endpoint.Endpoint
	{
		lAutoListAlertDestinationEndpoint = grpctransport.NewClient(
			conn,
			"monitoring.MonitoringV1",
			"AutoListAlertDestination",
			monitoring.EncodeGrpcReqListWatchOptions,
			monitoring.DecodeGrpcRespAlertDestinationList,
			&monitoring.AlertDestinationList{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoListAlertDestinationEndpoint = trace.ClientEndPoint("MonitoringV1:AutoListAlertDestination")(lAutoListAlertDestinationEndpoint)
	}
	var lAutoListAlertPolicyEndpoint endpoint.Endpoint
	{
		lAutoListAlertPolicyEndpoint = grpctransport.NewClient(
			conn,
			"monitoring.MonitoringV1",
			"AutoListAlertPolicy",
			monitoring.EncodeGrpcReqListWatchOptions,
			monitoring.DecodeGrpcRespAlertPolicyList,
			&monitoring.AlertPolicyList{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoListAlertPolicyEndpoint = trace.ClientEndPoint("MonitoringV1:AutoListAlertPolicy")(lAutoListAlertPolicyEndpoint)
	}
	var lAutoListArchiveRequestEndpoint endpoint.Endpoint
	{
		lAutoListArchiveRequestEndpoint = grpctransport.NewClient(
			conn,
			"monitoring.MonitoringV1",
			"AutoListArchiveRequest",
			monitoring.EncodeGrpcReqListWatchOptions,
			monitoring.DecodeGrpcRespArchiveRequestList,
			&monitoring.ArchiveRequestList{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoListArchiveRequestEndpoint = trace.ClientEndPoint("MonitoringV1:AutoListArchiveRequest")(lAutoListArchiveRequestEndpoint)
	}
	var lAutoListAuditPolicyEndpoint endpoint.Endpoint
	{
		lAutoListAuditPolicyEndpoint = grpctransport.NewClient(
			conn,
			"monitoring.MonitoringV1",
			"AutoListAuditPolicy",
			monitoring.EncodeGrpcReqListWatchOptions,
			monitoring.DecodeGrpcRespAuditPolicyList,
			&monitoring.AuditPolicyList{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoListAuditPolicyEndpoint = trace.ClientEndPoint("MonitoringV1:AutoListAuditPolicy")(lAutoListAuditPolicyEndpoint)
	}
	var lAutoListEventPolicyEndpoint endpoint.Endpoint
	{
		lAutoListEventPolicyEndpoint = grpctransport.NewClient(
			conn,
			"monitoring.MonitoringV1",
			"AutoListEventPolicy",
			monitoring.EncodeGrpcReqListWatchOptions,
			monitoring.DecodeGrpcRespEventPolicyList,
			&monitoring.EventPolicyList{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoListEventPolicyEndpoint = trace.ClientEndPoint("MonitoringV1:AutoListEventPolicy")(lAutoListEventPolicyEndpoint)
	}
	var lAutoListFlowExportPolicyEndpoint endpoint.Endpoint
	{
		lAutoListFlowExportPolicyEndpoint = grpctransport.NewClient(
			conn,
			"monitoring.MonitoringV1",
			"AutoListFlowExportPolicy",
			monitoring.EncodeGrpcReqListWatchOptions,
			monitoring.DecodeGrpcRespFlowExportPolicyList,
			&monitoring.FlowExportPolicyList{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoListFlowExportPolicyEndpoint = trace.ClientEndPoint("MonitoringV1:AutoListFlowExportPolicy")(lAutoListFlowExportPolicyEndpoint)
	}
	var lAutoListFwlogPolicyEndpoint endpoint.Endpoint
	{
		lAutoListFwlogPolicyEndpoint = grpctransport.NewClient(
			conn,
			"monitoring.MonitoringV1",
			"AutoListFwlogPolicy",
			monitoring.EncodeGrpcReqListWatchOptions,
			monitoring.DecodeGrpcRespFwlogPolicyList,
			&monitoring.FwlogPolicyList{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoListFwlogPolicyEndpoint = trace.ClientEndPoint("MonitoringV1:AutoListFwlogPolicy")(lAutoListFwlogPolicyEndpoint)
	}
	var lAutoListMirrorSessionEndpoint endpoint.Endpoint
	{
		lAutoListMirrorSessionEndpoint = grpctransport.NewClient(
			conn,
			"monitoring.MonitoringV1",
			"AutoListMirrorSession",
			monitoring.EncodeGrpcReqListWatchOptions,
			monitoring.DecodeGrpcRespMirrorSessionList,
			&monitoring.MirrorSessionList{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoListMirrorSessionEndpoint = trace.ClientEndPoint("MonitoringV1:AutoListMirrorSession")(lAutoListMirrorSessionEndpoint)
	}
	var lAutoListTechSupportRequestEndpoint endpoint.Endpoint
	{
		lAutoListTechSupportRequestEndpoint = grpctransport.NewClient(
			conn,
			"monitoring.MonitoringV1",
			"AutoListTechSupportRequest",
			monitoring.EncodeGrpcReqListWatchOptions,
			monitoring.DecodeGrpcRespTechSupportRequestList,
			&monitoring.TechSupportRequestList{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoListTechSupportRequestEndpoint = trace.ClientEndPoint("MonitoringV1:AutoListTechSupportRequest")(lAutoListTechSupportRequestEndpoint)
	}
	var lAutoListTroubleshootingSessionEndpoint endpoint.Endpoint
	{
		lAutoListTroubleshootingSessionEndpoint = grpctransport.NewClient(
			conn,
			"monitoring.MonitoringV1",
			"AutoListTroubleshootingSession",
			monitoring.EncodeGrpcReqListWatchOptions,
			monitoring.DecodeGrpcRespTroubleshootingSessionList,
			&monitoring.TroubleshootingSessionList{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoListTroubleshootingSessionEndpoint = trace.ClientEndPoint("MonitoringV1:AutoListTroubleshootingSession")(lAutoListTroubleshootingSessionEndpoint)
	}
	var lAutoUpdateAlertEndpoint endpoint.Endpoint
	{
		lAutoUpdateAlertEndpoint = grpctransport.NewClient(
			conn,
			"monitoring.MonitoringV1",
			"AutoUpdateAlert",
			monitoring.EncodeGrpcReqAlert,
			monitoring.DecodeGrpcRespAlert,
			&monitoring.Alert{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoUpdateAlertEndpoint = trace.ClientEndPoint("MonitoringV1:AutoUpdateAlert")(lAutoUpdateAlertEndpoint)
	}
	var lAutoUpdateAlertDestinationEndpoint endpoint.Endpoint
	{
		lAutoUpdateAlertDestinationEndpoint = grpctransport.NewClient(
			conn,
			"monitoring.MonitoringV1",
			"AutoUpdateAlertDestination",
			monitoring.EncodeGrpcReqAlertDestination,
			monitoring.DecodeGrpcRespAlertDestination,
			&monitoring.AlertDestination{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoUpdateAlertDestinationEndpoint = trace.ClientEndPoint("MonitoringV1:AutoUpdateAlertDestination")(lAutoUpdateAlertDestinationEndpoint)
	}
	var lAutoUpdateAlertPolicyEndpoint endpoint.Endpoint
	{
		lAutoUpdateAlertPolicyEndpoint = grpctransport.NewClient(
			conn,
			"monitoring.MonitoringV1",
			"AutoUpdateAlertPolicy",
			monitoring.EncodeGrpcReqAlertPolicy,
			monitoring.DecodeGrpcRespAlertPolicy,
			&monitoring.AlertPolicy{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoUpdateAlertPolicyEndpoint = trace.ClientEndPoint("MonitoringV1:AutoUpdateAlertPolicy")(lAutoUpdateAlertPolicyEndpoint)
	}
	var lAutoUpdateArchiveRequestEndpoint endpoint.Endpoint
	{
		lAutoUpdateArchiveRequestEndpoint = grpctransport.NewClient(
			conn,
			"monitoring.MonitoringV1",
			"AutoUpdateArchiveRequest",
			monitoring.EncodeGrpcReqArchiveRequest,
			monitoring.DecodeGrpcRespArchiveRequest,
			&monitoring.ArchiveRequest{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoUpdateArchiveRequestEndpoint = trace.ClientEndPoint("MonitoringV1:AutoUpdateArchiveRequest")(lAutoUpdateArchiveRequestEndpoint)
	}
	var lAutoUpdateAuditPolicyEndpoint endpoint.Endpoint
	{
		lAutoUpdateAuditPolicyEndpoint = grpctransport.NewClient(
			conn,
			"monitoring.MonitoringV1",
			"AutoUpdateAuditPolicy",
			monitoring.EncodeGrpcReqAuditPolicy,
			monitoring.DecodeGrpcRespAuditPolicy,
			&monitoring.AuditPolicy{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoUpdateAuditPolicyEndpoint = trace.ClientEndPoint("MonitoringV1:AutoUpdateAuditPolicy")(lAutoUpdateAuditPolicyEndpoint)
	}
	var lAutoUpdateEventPolicyEndpoint endpoint.Endpoint
	{
		lAutoUpdateEventPolicyEndpoint = grpctransport.NewClient(
			conn,
			"monitoring.MonitoringV1",
			"AutoUpdateEventPolicy",
			monitoring.EncodeGrpcReqEventPolicy,
			monitoring.DecodeGrpcRespEventPolicy,
			&monitoring.EventPolicy{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoUpdateEventPolicyEndpoint = trace.ClientEndPoint("MonitoringV1:AutoUpdateEventPolicy")(lAutoUpdateEventPolicyEndpoint)
	}
	var lAutoUpdateFlowExportPolicyEndpoint endpoint.Endpoint
	{
		lAutoUpdateFlowExportPolicyEndpoint = grpctransport.NewClient(
			conn,
			"monitoring.MonitoringV1",
			"AutoUpdateFlowExportPolicy",
			monitoring.EncodeGrpcReqFlowExportPolicy,
			monitoring.DecodeGrpcRespFlowExportPolicy,
			&monitoring.FlowExportPolicy{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoUpdateFlowExportPolicyEndpoint = trace.ClientEndPoint("MonitoringV1:AutoUpdateFlowExportPolicy")(lAutoUpdateFlowExportPolicyEndpoint)
	}
	var lAutoUpdateFwlogPolicyEndpoint endpoint.Endpoint
	{
		lAutoUpdateFwlogPolicyEndpoint = grpctransport.NewClient(
			conn,
			"monitoring.MonitoringV1",
			"AutoUpdateFwlogPolicy",
			monitoring.EncodeGrpcReqFwlogPolicy,
			monitoring.DecodeGrpcRespFwlogPolicy,
			&monitoring.FwlogPolicy{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoUpdateFwlogPolicyEndpoint = trace.ClientEndPoint("MonitoringV1:AutoUpdateFwlogPolicy")(lAutoUpdateFwlogPolicyEndpoint)
	}
	var lAutoUpdateMirrorSessionEndpoint endpoint.Endpoint
	{
		lAutoUpdateMirrorSessionEndpoint = grpctransport.NewClient(
			conn,
			"monitoring.MonitoringV1",
			"AutoUpdateMirrorSession",
			monitoring.EncodeGrpcReqMirrorSession,
			monitoring.DecodeGrpcRespMirrorSession,
			&monitoring.MirrorSession{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoUpdateMirrorSessionEndpoint = trace.ClientEndPoint("MonitoringV1:AutoUpdateMirrorSession")(lAutoUpdateMirrorSessionEndpoint)
	}
	var lAutoUpdateTechSupportRequestEndpoint endpoint.Endpoint
	{
		lAutoUpdateTechSupportRequestEndpoint = grpctransport.NewClient(
			conn,
			"monitoring.MonitoringV1",
			"AutoUpdateTechSupportRequest",
			monitoring.EncodeGrpcReqTechSupportRequest,
			monitoring.DecodeGrpcRespTechSupportRequest,
			&monitoring.TechSupportRequest{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoUpdateTechSupportRequestEndpoint = trace.ClientEndPoint("MonitoringV1:AutoUpdateTechSupportRequest")(lAutoUpdateTechSupportRequestEndpoint)
	}
	var lAutoUpdateTroubleshootingSessionEndpoint endpoint.Endpoint
	{
		lAutoUpdateTroubleshootingSessionEndpoint = grpctransport.NewClient(
			conn,
			"monitoring.MonitoringV1",
			"AutoUpdateTroubleshootingSession",
			monitoring.EncodeGrpcReqTroubleshootingSession,
			monitoring.DecodeGrpcRespTroubleshootingSession,
			&monitoring.TroubleshootingSession{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoUpdateTroubleshootingSessionEndpoint = trace.ClientEndPoint("MonitoringV1:AutoUpdateTroubleshootingSession")(lAutoUpdateTroubleshootingSessionEndpoint)
	}
	var lCancelEndpoint endpoint.Endpoint
	{
		lCancelEndpoint = grpctransport.NewClient(
			conn,
			"monitoring.MonitoringV1",
			"Cancel",
			monitoring.EncodeGrpcReqCancelArchiveRequest,
			monitoring.DecodeGrpcRespArchiveRequest,
			&monitoring.ArchiveRequest{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lCancelEndpoint = trace.ClientEndPoint("MonitoringV1:Cancel")(lCancelEndpoint)
	}
	return monitoring.EndpointsMonitoringV1Client{
		Client: monitoring.NewMonitoringV1Client(conn),

		AutoAddAlertEndpoint:                     lAutoAddAlertEndpoint,
		AutoAddAlertDestinationEndpoint:          lAutoAddAlertDestinationEndpoint,
		AutoAddAlertPolicyEndpoint:               lAutoAddAlertPolicyEndpoint,
		AutoAddArchiveRequestEndpoint:            lAutoAddArchiveRequestEndpoint,
		AutoAddAuditPolicyEndpoint:               lAutoAddAuditPolicyEndpoint,
		AutoAddEventPolicyEndpoint:               lAutoAddEventPolicyEndpoint,
		AutoAddFlowExportPolicyEndpoint:          lAutoAddFlowExportPolicyEndpoint,
		AutoAddFwlogPolicyEndpoint:               lAutoAddFwlogPolicyEndpoint,
		AutoAddMirrorSessionEndpoint:             lAutoAddMirrorSessionEndpoint,
		AutoAddTechSupportRequestEndpoint:        lAutoAddTechSupportRequestEndpoint,
		AutoAddTroubleshootingSessionEndpoint:    lAutoAddTroubleshootingSessionEndpoint,
		AutoDeleteAlertEndpoint:                  lAutoDeleteAlertEndpoint,
		AutoDeleteAlertDestinationEndpoint:       lAutoDeleteAlertDestinationEndpoint,
		AutoDeleteAlertPolicyEndpoint:            lAutoDeleteAlertPolicyEndpoint,
		AutoDeleteArchiveRequestEndpoint:         lAutoDeleteArchiveRequestEndpoint,
		AutoDeleteAuditPolicyEndpoint:            lAutoDeleteAuditPolicyEndpoint,
		AutoDeleteEventPolicyEndpoint:            lAutoDeleteEventPolicyEndpoint,
		AutoDeleteFlowExportPolicyEndpoint:       lAutoDeleteFlowExportPolicyEndpoint,
		AutoDeleteFwlogPolicyEndpoint:            lAutoDeleteFwlogPolicyEndpoint,
		AutoDeleteMirrorSessionEndpoint:          lAutoDeleteMirrorSessionEndpoint,
		AutoDeleteTechSupportRequestEndpoint:     lAutoDeleteTechSupportRequestEndpoint,
		AutoDeleteTroubleshootingSessionEndpoint: lAutoDeleteTroubleshootingSessionEndpoint,
		AutoGetAlertEndpoint:                     lAutoGetAlertEndpoint,
		AutoGetAlertDestinationEndpoint:          lAutoGetAlertDestinationEndpoint,
		AutoGetAlertPolicyEndpoint:               lAutoGetAlertPolicyEndpoint,
		AutoGetArchiveRequestEndpoint:            lAutoGetArchiveRequestEndpoint,
		AutoGetAuditPolicyEndpoint:               lAutoGetAuditPolicyEndpoint,
		AutoGetEventPolicyEndpoint:               lAutoGetEventPolicyEndpoint,
		AutoGetFlowExportPolicyEndpoint:          lAutoGetFlowExportPolicyEndpoint,
		AutoGetFwlogPolicyEndpoint:               lAutoGetFwlogPolicyEndpoint,
		AutoGetMirrorSessionEndpoint:             lAutoGetMirrorSessionEndpoint,
		AutoGetTechSupportRequestEndpoint:        lAutoGetTechSupportRequestEndpoint,
		AutoGetTroubleshootingSessionEndpoint:    lAutoGetTroubleshootingSessionEndpoint,
		AutoLabelAlertEndpoint:                   lAutoLabelAlertEndpoint,
		AutoLabelAlertDestinationEndpoint:        lAutoLabelAlertDestinationEndpoint,
		AutoLabelAlertPolicyEndpoint:             lAutoLabelAlertPolicyEndpoint,
		AutoLabelArchiveRequestEndpoint:          lAutoLabelArchiveRequestEndpoint,
		AutoLabelAuditPolicyEndpoint:             lAutoLabelAuditPolicyEndpoint,
		AutoLabelEventPolicyEndpoint:             lAutoLabelEventPolicyEndpoint,
		AutoLabelFlowExportPolicyEndpoint:        lAutoLabelFlowExportPolicyEndpoint,
		AutoLabelFwlogPolicyEndpoint:             lAutoLabelFwlogPolicyEndpoint,
		AutoLabelMirrorSessionEndpoint:           lAutoLabelMirrorSessionEndpoint,
		AutoLabelTechSupportRequestEndpoint:      lAutoLabelTechSupportRequestEndpoint,
		AutoLabelTroubleshootingSessionEndpoint:  lAutoLabelTroubleshootingSessionEndpoint,
		AutoListAlertEndpoint:                    lAutoListAlertEndpoint,
		AutoListAlertDestinationEndpoint:         lAutoListAlertDestinationEndpoint,
		AutoListAlertPolicyEndpoint:              lAutoListAlertPolicyEndpoint,
		AutoListArchiveRequestEndpoint:           lAutoListArchiveRequestEndpoint,
		AutoListAuditPolicyEndpoint:              lAutoListAuditPolicyEndpoint,
		AutoListEventPolicyEndpoint:              lAutoListEventPolicyEndpoint,
		AutoListFlowExportPolicyEndpoint:         lAutoListFlowExportPolicyEndpoint,
		AutoListFwlogPolicyEndpoint:              lAutoListFwlogPolicyEndpoint,
		AutoListMirrorSessionEndpoint:            lAutoListMirrorSessionEndpoint,
		AutoListTechSupportRequestEndpoint:       lAutoListTechSupportRequestEndpoint,
		AutoListTroubleshootingSessionEndpoint:   lAutoListTroubleshootingSessionEndpoint,
		AutoUpdateAlertEndpoint:                  lAutoUpdateAlertEndpoint,
		AutoUpdateAlertDestinationEndpoint:       lAutoUpdateAlertDestinationEndpoint,
		AutoUpdateAlertPolicyEndpoint:            lAutoUpdateAlertPolicyEndpoint,
		AutoUpdateArchiveRequestEndpoint:         lAutoUpdateArchiveRequestEndpoint,
		AutoUpdateAuditPolicyEndpoint:            lAutoUpdateAuditPolicyEndpoint,
		AutoUpdateEventPolicyEndpoint:            lAutoUpdateEventPolicyEndpoint,
		AutoUpdateFlowExportPolicyEndpoint:       lAutoUpdateFlowExportPolicyEndpoint,
		AutoUpdateFwlogPolicyEndpoint:            lAutoUpdateFwlogPolicyEndpoint,
		AutoUpdateMirrorSessionEndpoint:          lAutoUpdateMirrorSessionEndpoint,
		AutoUpdateTechSupportRequestEndpoint:     lAutoUpdateTechSupportRequestEndpoint,
		AutoUpdateTroubleshootingSessionEndpoint: lAutoUpdateTroubleshootingSessionEndpoint,
		CancelEndpoint:                           lCancelEndpoint,
	}
}

// NewMonitoringV1Backend creates an instrumented client with middleware
func NewMonitoringV1Backend(conn *grpc.ClientConn, logger log.Logger) monitoring.ServiceMonitoringV1Client {
	cl := NewMonitoringV1(conn, logger)
	cl = monitoring.LoggingMonitoringV1MiddlewareClient(logger)(cl)
	return cl
}

type grpcObjMonitoringV1EventPolicy struct {
	logger log.Logger
	client monitoring.ServiceMonitoringV1Client
}

func (a *grpcObjMonitoringV1EventPolicy) Create(ctx context.Context, in *monitoring.EventPolicy) (*monitoring.EventPolicy, error) {
	a.logger.DebugLog("msg", "received call", "object", "EventPolicy", "oper", "create")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoAddEventPolicy(nctx, in)
}

func (a *grpcObjMonitoringV1EventPolicy) Update(ctx context.Context, in *monitoring.EventPolicy) (*monitoring.EventPolicy, error) {
	a.logger.DebugLog("msg", "received call", "object", "EventPolicy", "oper", "update")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoUpdateEventPolicy(nctx, in)
}

func (a *grpcObjMonitoringV1EventPolicy) UpdateStatus(ctx context.Context, in *monitoring.EventPolicy) (*monitoring.EventPolicy, error) {
	a.logger.DebugLog("msg", "received call", "object", "EventPolicy", "oper", "update")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	nctx = addStatusUpd(nctx)
	return a.client.AutoUpdateEventPolicy(nctx, in)
}

func (a *grpcObjMonitoringV1EventPolicy) Label(ctx context.Context, in *api.Label) (*monitoring.EventPolicy, error) {
	a.logger.DebugLog("msg", "received call", "object", "EventPolicy", "oper", "label")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoLabelEventPolicy(nctx, in)
}

func (a *grpcObjMonitoringV1EventPolicy) Get(ctx context.Context, objMeta *api.ObjectMeta) (*monitoring.EventPolicy, error) {
	a.logger.DebugLog("msg", "received call", "object", "EventPolicy", "oper", "get")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := monitoring.EventPolicy{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoGetEventPolicy(nctx, &in)
}

func (a *grpcObjMonitoringV1EventPolicy) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*monitoring.EventPolicy, error) {
	a.logger.DebugLog("msg", "received call", "object", "EventPolicy", "oper", "delete")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := monitoring.EventPolicy{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoDeleteEventPolicy(nctx, &in)
}

func (a *grpcObjMonitoringV1EventPolicy) List(ctx context.Context, options *api.ListWatchOptions) ([]*monitoring.EventPolicy, error) {
	a.logger.DebugLog("msg", "received call", "object", "EventPolicy", "oper", "list")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	r, err := a.client.AutoListEventPolicy(nctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *grpcObjMonitoringV1EventPolicy) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	a.logger.DebugLog("msg", "received call", "object", "EventPolicy", "oper", "WatchOper")
	nctx := addVersion(ctx, "v1")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	stream, err := a.client.AutoWatchEventPolicy(nctx, options)
	if err != nil {
		return nil, err
	}
	wstream := stream.(monitoring.MonitoringV1_AutoWatchEventPolicyClient)
	bridgefn := func(lw *listerwatcher.WatcherClient) {
		for {
			r, err := wstream.Recv()
			if err != nil {
				a.logger.ErrorLog("msg", "error on receive", "err", err)
				close(lw.OutCh)
				return
			}
			for _, e := range r.Events {
				ev := kvstore.WatchEvent{
					Type:   kvstore.WatchEventType(e.Type),
					Object: e.Object,
				}
				select {
				case lw.OutCh <- &ev:
				case <-wstream.Context().Done():
					close(lw.OutCh)
					return
				}
			}
		}
	}
	lw := listerwatcher.NewWatcherClient(wstream, bridgefn)
	lw.Run()
	return lw, nil
}

func (a *grpcObjMonitoringV1EventPolicy) Allowed(oper apiintf.APIOperType) bool {
	return true
}

type restObjMonitoringV1EventPolicy struct {
	endpoints monitoring.EndpointsMonitoringV1RestClient
	instance  string
}

func (a *restObjMonitoringV1EventPolicy) Create(ctx context.Context, in *monitoring.EventPolicy) (*monitoring.EventPolicy, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoAddEventPolicy(ctx, in)
}

func (a *restObjMonitoringV1EventPolicy) Update(ctx context.Context, in *monitoring.EventPolicy) (*monitoring.EventPolicy, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoUpdateEventPolicy(ctx, in)
}

func (a *restObjMonitoringV1EventPolicy) UpdateStatus(ctx context.Context, in *monitoring.EventPolicy) (*monitoring.EventPolicy, error) {
	return nil, errors.New("not supported for REST")
}

func (a *restObjMonitoringV1EventPolicy) Label(ctx context.Context, in *api.Label) (*monitoring.EventPolicy, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoLabelEventPolicy(ctx, in)
}

func (a *restObjMonitoringV1EventPolicy) Get(ctx context.Context, objMeta *api.ObjectMeta) (*monitoring.EventPolicy, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := monitoring.EventPolicy{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoGetEventPolicy(ctx, &in)
}

func (a *restObjMonitoringV1EventPolicy) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*monitoring.EventPolicy, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := monitoring.EventPolicy{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoDeleteEventPolicy(ctx, &in)
}

func (a *restObjMonitoringV1EventPolicy) List(ctx context.Context, options *api.ListWatchOptions) ([]*monitoring.EventPolicy, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}

	if options.Tenant == "" {
		options.Tenant = globals.DefaultTenant
	}
	r, err := a.endpoints.AutoListEventPolicy(ctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *restObjMonitoringV1EventPolicy) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoWatchEventPolicy(ctx, options)
}

func (a *restObjMonitoringV1EventPolicy) Allowed(oper apiintf.APIOperType) bool {
	switch oper {
	case apiintf.CreateOper:
		return true
	case apiintf.UpdateOper:
		return true
	case apiintf.GetOper:
		return true
	case apiintf.DeleteOper:
		return true
	case apiintf.ListOper:
		return true
	case apiintf.WatchOper:
		return true
	default:
		return false
	}
}

type grpcObjMonitoringV1FwlogPolicy struct {
	logger log.Logger
	client monitoring.ServiceMonitoringV1Client
}

func (a *grpcObjMonitoringV1FwlogPolicy) Create(ctx context.Context, in *monitoring.FwlogPolicy) (*monitoring.FwlogPolicy, error) {
	a.logger.DebugLog("msg", "received call", "object", "FwlogPolicy", "oper", "create")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoAddFwlogPolicy(nctx, in)
}

func (a *grpcObjMonitoringV1FwlogPolicy) Update(ctx context.Context, in *monitoring.FwlogPolicy) (*monitoring.FwlogPolicy, error) {
	a.logger.DebugLog("msg", "received call", "object", "FwlogPolicy", "oper", "update")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoUpdateFwlogPolicy(nctx, in)
}

func (a *grpcObjMonitoringV1FwlogPolicy) UpdateStatus(ctx context.Context, in *monitoring.FwlogPolicy) (*monitoring.FwlogPolicy, error) {
	a.logger.DebugLog("msg", "received call", "object", "FwlogPolicy", "oper", "update")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	nctx = addStatusUpd(nctx)
	return a.client.AutoUpdateFwlogPolicy(nctx, in)
}

func (a *grpcObjMonitoringV1FwlogPolicy) Label(ctx context.Context, in *api.Label) (*monitoring.FwlogPolicy, error) {
	a.logger.DebugLog("msg", "received call", "object", "FwlogPolicy", "oper", "label")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoLabelFwlogPolicy(nctx, in)
}

func (a *grpcObjMonitoringV1FwlogPolicy) Get(ctx context.Context, objMeta *api.ObjectMeta) (*monitoring.FwlogPolicy, error) {
	a.logger.DebugLog("msg", "received call", "object", "FwlogPolicy", "oper", "get")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := monitoring.FwlogPolicy{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoGetFwlogPolicy(nctx, &in)
}

func (a *grpcObjMonitoringV1FwlogPolicy) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*monitoring.FwlogPolicy, error) {
	a.logger.DebugLog("msg", "received call", "object", "FwlogPolicy", "oper", "delete")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := monitoring.FwlogPolicy{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoDeleteFwlogPolicy(nctx, &in)
}

func (a *grpcObjMonitoringV1FwlogPolicy) List(ctx context.Context, options *api.ListWatchOptions) ([]*monitoring.FwlogPolicy, error) {
	a.logger.DebugLog("msg", "received call", "object", "FwlogPolicy", "oper", "list")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	r, err := a.client.AutoListFwlogPolicy(nctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *grpcObjMonitoringV1FwlogPolicy) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	a.logger.DebugLog("msg", "received call", "object", "FwlogPolicy", "oper", "WatchOper")
	nctx := addVersion(ctx, "v1")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	stream, err := a.client.AutoWatchFwlogPolicy(nctx, options)
	if err != nil {
		return nil, err
	}
	wstream := stream.(monitoring.MonitoringV1_AutoWatchFwlogPolicyClient)
	bridgefn := func(lw *listerwatcher.WatcherClient) {
		for {
			r, err := wstream.Recv()
			if err != nil {
				a.logger.ErrorLog("msg", "error on receive", "err", err)
				close(lw.OutCh)
				return
			}
			for _, e := range r.Events {
				ev := kvstore.WatchEvent{
					Type:   kvstore.WatchEventType(e.Type),
					Object: e.Object,
				}
				select {
				case lw.OutCh <- &ev:
				case <-wstream.Context().Done():
					close(lw.OutCh)
					return
				}
			}
		}
	}
	lw := listerwatcher.NewWatcherClient(wstream, bridgefn)
	lw.Run()
	return lw, nil
}

func (a *grpcObjMonitoringV1FwlogPolicy) Allowed(oper apiintf.APIOperType) bool {
	return true
}

type restObjMonitoringV1FwlogPolicy struct {
	endpoints monitoring.EndpointsMonitoringV1RestClient
	instance  string
}

func (a *restObjMonitoringV1FwlogPolicy) Create(ctx context.Context, in *monitoring.FwlogPolicy) (*monitoring.FwlogPolicy, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoAddFwlogPolicy(ctx, in)
}

func (a *restObjMonitoringV1FwlogPolicy) Update(ctx context.Context, in *monitoring.FwlogPolicy) (*monitoring.FwlogPolicy, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoUpdateFwlogPolicy(ctx, in)
}

func (a *restObjMonitoringV1FwlogPolicy) UpdateStatus(ctx context.Context, in *monitoring.FwlogPolicy) (*monitoring.FwlogPolicy, error) {
	return nil, errors.New("not supported for REST")
}

func (a *restObjMonitoringV1FwlogPolicy) Label(ctx context.Context, in *api.Label) (*monitoring.FwlogPolicy, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoLabelFwlogPolicy(ctx, in)
}

func (a *restObjMonitoringV1FwlogPolicy) Get(ctx context.Context, objMeta *api.ObjectMeta) (*monitoring.FwlogPolicy, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := monitoring.FwlogPolicy{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoGetFwlogPolicy(ctx, &in)
}

func (a *restObjMonitoringV1FwlogPolicy) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*monitoring.FwlogPolicy, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := monitoring.FwlogPolicy{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoDeleteFwlogPolicy(ctx, &in)
}

func (a *restObjMonitoringV1FwlogPolicy) List(ctx context.Context, options *api.ListWatchOptions) ([]*monitoring.FwlogPolicy, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}

	if options.Tenant == "" {
		options.Tenant = globals.DefaultTenant
	}
	r, err := a.endpoints.AutoListFwlogPolicy(ctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *restObjMonitoringV1FwlogPolicy) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoWatchFwlogPolicy(ctx, options)
}

func (a *restObjMonitoringV1FwlogPolicy) Allowed(oper apiintf.APIOperType) bool {
	switch oper {
	case apiintf.CreateOper:
		return true
	case apiintf.UpdateOper:
		return true
	case apiintf.GetOper:
		return true
	case apiintf.DeleteOper:
		return true
	case apiintf.ListOper:
		return true
	case apiintf.WatchOper:
		return true
	default:
		return false
	}
}

type grpcObjMonitoringV1FlowExportPolicy struct {
	logger log.Logger
	client monitoring.ServiceMonitoringV1Client
}

func (a *grpcObjMonitoringV1FlowExportPolicy) Create(ctx context.Context, in *monitoring.FlowExportPolicy) (*monitoring.FlowExportPolicy, error) {
	a.logger.DebugLog("msg", "received call", "object", "FlowExportPolicy", "oper", "create")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoAddFlowExportPolicy(nctx, in)
}

func (a *grpcObjMonitoringV1FlowExportPolicy) Update(ctx context.Context, in *monitoring.FlowExportPolicy) (*monitoring.FlowExportPolicy, error) {
	a.logger.DebugLog("msg", "received call", "object", "FlowExportPolicy", "oper", "update")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoUpdateFlowExportPolicy(nctx, in)
}

func (a *grpcObjMonitoringV1FlowExportPolicy) UpdateStatus(ctx context.Context, in *monitoring.FlowExportPolicy) (*monitoring.FlowExportPolicy, error) {
	a.logger.DebugLog("msg", "received call", "object", "FlowExportPolicy", "oper", "update")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	nctx = addStatusUpd(nctx)
	return a.client.AutoUpdateFlowExportPolicy(nctx, in)
}

func (a *grpcObjMonitoringV1FlowExportPolicy) Label(ctx context.Context, in *api.Label) (*monitoring.FlowExportPolicy, error) {
	a.logger.DebugLog("msg", "received call", "object", "FlowExportPolicy", "oper", "label")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoLabelFlowExportPolicy(nctx, in)
}

func (a *grpcObjMonitoringV1FlowExportPolicy) Get(ctx context.Context, objMeta *api.ObjectMeta) (*monitoring.FlowExportPolicy, error) {
	a.logger.DebugLog("msg", "received call", "object", "FlowExportPolicy", "oper", "get")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := monitoring.FlowExportPolicy{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoGetFlowExportPolicy(nctx, &in)
}

func (a *grpcObjMonitoringV1FlowExportPolicy) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*monitoring.FlowExportPolicy, error) {
	a.logger.DebugLog("msg", "received call", "object", "FlowExportPolicy", "oper", "delete")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := monitoring.FlowExportPolicy{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoDeleteFlowExportPolicy(nctx, &in)
}

func (a *grpcObjMonitoringV1FlowExportPolicy) List(ctx context.Context, options *api.ListWatchOptions) ([]*monitoring.FlowExportPolicy, error) {
	a.logger.DebugLog("msg", "received call", "object", "FlowExportPolicy", "oper", "list")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	r, err := a.client.AutoListFlowExportPolicy(nctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *grpcObjMonitoringV1FlowExportPolicy) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	a.logger.DebugLog("msg", "received call", "object", "FlowExportPolicy", "oper", "WatchOper")
	nctx := addVersion(ctx, "v1")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	stream, err := a.client.AutoWatchFlowExportPolicy(nctx, options)
	if err != nil {
		return nil, err
	}
	wstream := stream.(monitoring.MonitoringV1_AutoWatchFlowExportPolicyClient)
	bridgefn := func(lw *listerwatcher.WatcherClient) {
		for {
			r, err := wstream.Recv()
			if err != nil {
				a.logger.ErrorLog("msg", "error on receive", "err", err)
				close(lw.OutCh)
				return
			}
			for _, e := range r.Events {
				ev := kvstore.WatchEvent{
					Type:   kvstore.WatchEventType(e.Type),
					Object: e.Object,
				}
				select {
				case lw.OutCh <- &ev:
				case <-wstream.Context().Done():
					close(lw.OutCh)
					return
				}
			}
		}
	}
	lw := listerwatcher.NewWatcherClient(wstream, bridgefn)
	lw.Run()
	return lw, nil
}

func (a *grpcObjMonitoringV1FlowExportPolicy) Allowed(oper apiintf.APIOperType) bool {
	return true
}

type restObjMonitoringV1FlowExportPolicy struct {
	endpoints monitoring.EndpointsMonitoringV1RestClient
	instance  string
}

func (a *restObjMonitoringV1FlowExportPolicy) Create(ctx context.Context, in *monitoring.FlowExportPolicy) (*monitoring.FlowExportPolicy, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoAddFlowExportPolicy(ctx, in)
}

func (a *restObjMonitoringV1FlowExportPolicy) Update(ctx context.Context, in *monitoring.FlowExportPolicy) (*monitoring.FlowExportPolicy, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoUpdateFlowExportPolicy(ctx, in)
}

func (a *restObjMonitoringV1FlowExportPolicy) UpdateStatus(ctx context.Context, in *monitoring.FlowExportPolicy) (*monitoring.FlowExportPolicy, error) {
	return nil, errors.New("not supported for REST")
}

func (a *restObjMonitoringV1FlowExportPolicy) Label(ctx context.Context, in *api.Label) (*monitoring.FlowExportPolicy, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoLabelFlowExportPolicy(ctx, in)
}

func (a *restObjMonitoringV1FlowExportPolicy) Get(ctx context.Context, objMeta *api.ObjectMeta) (*monitoring.FlowExportPolicy, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := monitoring.FlowExportPolicy{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoGetFlowExportPolicy(ctx, &in)
}

func (a *restObjMonitoringV1FlowExportPolicy) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*monitoring.FlowExportPolicy, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := monitoring.FlowExportPolicy{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoDeleteFlowExportPolicy(ctx, &in)
}

func (a *restObjMonitoringV1FlowExportPolicy) List(ctx context.Context, options *api.ListWatchOptions) ([]*monitoring.FlowExportPolicy, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}

	if options.Tenant == "" {
		options.Tenant = globals.DefaultTenant
	}
	r, err := a.endpoints.AutoListFlowExportPolicy(ctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *restObjMonitoringV1FlowExportPolicy) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoWatchFlowExportPolicy(ctx, options)
}

func (a *restObjMonitoringV1FlowExportPolicy) Allowed(oper apiintf.APIOperType) bool {
	switch oper {
	case apiintf.CreateOper:
		return true
	case apiintf.UpdateOper:
		return true
	case apiintf.GetOper:
		return true
	case apiintf.DeleteOper:
		return true
	case apiintf.ListOper:
		return true
	case apiintf.WatchOper:
		return true
	default:
		return false
	}
}

type grpcObjMonitoringV1Alert struct {
	logger log.Logger
	client monitoring.ServiceMonitoringV1Client
}

func (a *grpcObjMonitoringV1Alert) Create(ctx context.Context, in *monitoring.Alert) (*monitoring.Alert, error) {
	a.logger.DebugLog("msg", "received call", "object", "Alert", "oper", "create")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoAddAlert(nctx, in)
}

func (a *grpcObjMonitoringV1Alert) Update(ctx context.Context, in *monitoring.Alert) (*monitoring.Alert, error) {
	a.logger.DebugLog("msg", "received call", "object", "Alert", "oper", "update")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoUpdateAlert(nctx, in)
}

func (a *grpcObjMonitoringV1Alert) UpdateStatus(ctx context.Context, in *monitoring.Alert) (*monitoring.Alert, error) {
	a.logger.DebugLog("msg", "received call", "object", "Alert", "oper", "update")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	nctx = addStatusUpd(nctx)
	return a.client.AutoUpdateAlert(nctx, in)
}

func (a *grpcObjMonitoringV1Alert) Label(ctx context.Context, in *api.Label) (*monitoring.Alert, error) {
	a.logger.DebugLog("msg", "received call", "object", "Alert", "oper", "label")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoLabelAlert(nctx, in)
}

func (a *grpcObjMonitoringV1Alert) Get(ctx context.Context, objMeta *api.ObjectMeta) (*monitoring.Alert, error) {
	a.logger.DebugLog("msg", "received call", "object", "Alert", "oper", "get")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := monitoring.Alert{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoGetAlert(nctx, &in)
}

func (a *grpcObjMonitoringV1Alert) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*monitoring.Alert, error) {
	a.logger.DebugLog("msg", "received call", "object", "Alert", "oper", "delete")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := monitoring.Alert{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoDeleteAlert(nctx, &in)
}

func (a *grpcObjMonitoringV1Alert) List(ctx context.Context, options *api.ListWatchOptions) ([]*monitoring.Alert, error) {
	a.logger.DebugLog("msg", "received call", "object", "Alert", "oper", "list")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	r, err := a.client.AutoListAlert(nctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *grpcObjMonitoringV1Alert) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	a.logger.DebugLog("msg", "received call", "object", "Alert", "oper", "WatchOper")
	nctx := addVersion(ctx, "v1")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	stream, err := a.client.AutoWatchAlert(nctx, options)
	if err != nil {
		return nil, err
	}
	wstream := stream.(monitoring.MonitoringV1_AutoWatchAlertClient)
	bridgefn := func(lw *listerwatcher.WatcherClient) {
		for {
			r, err := wstream.Recv()
			if err != nil {
				a.logger.ErrorLog("msg", "error on receive", "err", err)
				close(lw.OutCh)
				return
			}
			for _, e := range r.Events {
				ev := kvstore.WatchEvent{
					Type:   kvstore.WatchEventType(e.Type),
					Object: e.Object,
				}
				select {
				case lw.OutCh <- &ev:
				case <-wstream.Context().Done():
					close(lw.OutCh)
					return
				}
			}
		}
	}
	lw := listerwatcher.NewWatcherClient(wstream, bridgefn)
	lw.Run()
	return lw, nil
}

func (a *grpcObjMonitoringV1Alert) Allowed(oper apiintf.APIOperType) bool {
	return true
}

type restObjMonitoringV1Alert struct {
	endpoints monitoring.EndpointsMonitoringV1RestClient
	instance  string
}

func (a *restObjMonitoringV1Alert) Create(ctx context.Context, in *monitoring.Alert) (*monitoring.Alert, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoAddAlert(ctx, in)
}

func (a *restObjMonitoringV1Alert) Update(ctx context.Context, in *monitoring.Alert) (*monitoring.Alert, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoUpdateAlert(ctx, in)
}

func (a *restObjMonitoringV1Alert) UpdateStatus(ctx context.Context, in *monitoring.Alert) (*monitoring.Alert, error) {
	return nil, errors.New("not supported for REST")
}

func (a *restObjMonitoringV1Alert) Label(ctx context.Context, in *api.Label) (*monitoring.Alert, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoLabelAlert(ctx, in)
}

func (a *restObjMonitoringV1Alert) Get(ctx context.Context, objMeta *api.ObjectMeta) (*monitoring.Alert, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := monitoring.Alert{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoGetAlert(ctx, &in)
}

func (a *restObjMonitoringV1Alert) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*monitoring.Alert, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := monitoring.Alert{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoDeleteAlert(ctx, &in)
}

func (a *restObjMonitoringV1Alert) List(ctx context.Context, options *api.ListWatchOptions) ([]*monitoring.Alert, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}

	if options.Tenant == "" {
		options.Tenant = globals.DefaultTenant
	}
	r, err := a.endpoints.AutoListAlert(ctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *restObjMonitoringV1Alert) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoWatchAlert(ctx, options)
}

func (a *restObjMonitoringV1Alert) Allowed(oper apiintf.APIOperType) bool {
	switch oper {
	case apiintf.CreateOper:
		return false
	case apiintf.UpdateOper:
		return true
	case apiintf.GetOper:
		return true
	case apiintf.DeleteOper:
		return false
	case apiintf.ListOper:
		return true
	case apiintf.WatchOper:
		return true
	default:
		return false
	}
}

type grpcObjMonitoringV1AlertPolicy struct {
	logger log.Logger
	client monitoring.ServiceMonitoringV1Client
}

func (a *grpcObjMonitoringV1AlertPolicy) Create(ctx context.Context, in *monitoring.AlertPolicy) (*monitoring.AlertPolicy, error) {
	a.logger.DebugLog("msg", "received call", "object", "AlertPolicy", "oper", "create")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoAddAlertPolicy(nctx, in)
}

func (a *grpcObjMonitoringV1AlertPolicy) Update(ctx context.Context, in *monitoring.AlertPolicy) (*monitoring.AlertPolicy, error) {
	a.logger.DebugLog("msg", "received call", "object", "AlertPolicy", "oper", "update")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoUpdateAlertPolicy(nctx, in)
}

func (a *grpcObjMonitoringV1AlertPolicy) UpdateStatus(ctx context.Context, in *monitoring.AlertPolicy) (*monitoring.AlertPolicy, error) {
	a.logger.DebugLog("msg", "received call", "object", "AlertPolicy", "oper", "update")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	nctx = addStatusUpd(nctx)
	return a.client.AutoUpdateAlertPolicy(nctx, in)
}

func (a *grpcObjMonitoringV1AlertPolicy) Label(ctx context.Context, in *api.Label) (*monitoring.AlertPolicy, error) {
	a.logger.DebugLog("msg", "received call", "object", "AlertPolicy", "oper", "label")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoLabelAlertPolicy(nctx, in)
}

func (a *grpcObjMonitoringV1AlertPolicy) Get(ctx context.Context, objMeta *api.ObjectMeta) (*monitoring.AlertPolicy, error) {
	a.logger.DebugLog("msg", "received call", "object", "AlertPolicy", "oper", "get")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := monitoring.AlertPolicy{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoGetAlertPolicy(nctx, &in)
}

func (a *grpcObjMonitoringV1AlertPolicy) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*monitoring.AlertPolicy, error) {
	a.logger.DebugLog("msg", "received call", "object", "AlertPolicy", "oper", "delete")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := monitoring.AlertPolicy{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoDeleteAlertPolicy(nctx, &in)
}

func (a *grpcObjMonitoringV1AlertPolicy) List(ctx context.Context, options *api.ListWatchOptions) ([]*monitoring.AlertPolicy, error) {
	a.logger.DebugLog("msg", "received call", "object", "AlertPolicy", "oper", "list")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	r, err := a.client.AutoListAlertPolicy(nctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *grpcObjMonitoringV1AlertPolicy) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	a.logger.DebugLog("msg", "received call", "object", "AlertPolicy", "oper", "WatchOper")
	nctx := addVersion(ctx, "v1")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	stream, err := a.client.AutoWatchAlertPolicy(nctx, options)
	if err != nil {
		return nil, err
	}
	wstream := stream.(monitoring.MonitoringV1_AutoWatchAlertPolicyClient)
	bridgefn := func(lw *listerwatcher.WatcherClient) {
		for {
			r, err := wstream.Recv()
			if err != nil {
				a.logger.ErrorLog("msg", "error on receive", "err", err)
				close(lw.OutCh)
				return
			}
			for _, e := range r.Events {
				ev := kvstore.WatchEvent{
					Type:   kvstore.WatchEventType(e.Type),
					Object: e.Object,
				}
				select {
				case lw.OutCh <- &ev:
				case <-wstream.Context().Done():
					close(lw.OutCh)
					return
				}
			}
		}
	}
	lw := listerwatcher.NewWatcherClient(wstream, bridgefn)
	lw.Run()
	return lw, nil
}

func (a *grpcObjMonitoringV1AlertPolicy) Allowed(oper apiintf.APIOperType) bool {
	return true
}

type restObjMonitoringV1AlertPolicy struct {
	endpoints monitoring.EndpointsMonitoringV1RestClient
	instance  string
}

func (a *restObjMonitoringV1AlertPolicy) Create(ctx context.Context, in *monitoring.AlertPolicy) (*monitoring.AlertPolicy, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoAddAlertPolicy(ctx, in)
}

func (a *restObjMonitoringV1AlertPolicy) Update(ctx context.Context, in *monitoring.AlertPolicy) (*monitoring.AlertPolicy, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoUpdateAlertPolicy(ctx, in)
}

func (a *restObjMonitoringV1AlertPolicy) UpdateStatus(ctx context.Context, in *monitoring.AlertPolicy) (*monitoring.AlertPolicy, error) {
	return nil, errors.New("not supported for REST")
}

func (a *restObjMonitoringV1AlertPolicy) Label(ctx context.Context, in *api.Label) (*monitoring.AlertPolicy, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoLabelAlertPolicy(ctx, in)
}

func (a *restObjMonitoringV1AlertPolicy) Get(ctx context.Context, objMeta *api.ObjectMeta) (*monitoring.AlertPolicy, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := monitoring.AlertPolicy{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoGetAlertPolicy(ctx, &in)
}

func (a *restObjMonitoringV1AlertPolicy) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*monitoring.AlertPolicy, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := monitoring.AlertPolicy{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoDeleteAlertPolicy(ctx, &in)
}

func (a *restObjMonitoringV1AlertPolicy) List(ctx context.Context, options *api.ListWatchOptions) ([]*monitoring.AlertPolicy, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}

	if options.Tenant == "" {
		options.Tenant = globals.DefaultTenant
	}
	r, err := a.endpoints.AutoListAlertPolicy(ctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *restObjMonitoringV1AlertPolicy) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoWatchAlertPolicy(ctx, options)
}

func (a *restObjMonitoringV1AlertPolicy) Allowed(oper apiintf.APIOperType) bool {
	switch oper {
	case apiintf.CreateOper:
		return true
	case apiintf.UpdateOper:
		return true
	case apiintf.GetOper:
		return true
	case apiintf.DeleteOper:
		return true
	case apiintf.ListOper:
		return true
	case apiintf.WatchOper:
		return true
	default:
		return false
	}
}

type grpcObjMonitoringV1AlertDestination struct {
	logger log.Logger
	client monitoring.ServiceMonitoringV1Client
}

func (a *grpcObjMonitoringV1AlertDestination) Create(ctx context.Context, in *monitoring.AlertDestination) (*monitoring.AlertDestination, error) {
	a.logger.DebugLog("msg", "received call", "object", "AlertDestination", "oper", "create")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoAddAlertDestination(nctx, in)
}

func (a *grpcObjMonitoringV1AlertDestination) Update(ctx context.Context, in *monitoring.AlertDestination) (*monitoring.AlertDestination, error) {
	a.logger.DebugLog("msg", "received call", "object", "AlertDestination", "oper", "update")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoUpdateAlertDestination(nctx, in)
}

func (a *grpcObjMonitoringV1AlertDestination) UpdateStatus(ctx context.Context, in *monitoring.AlertDestination) (*monitoring.AlertDestination, error) {
	a.logger.DebugLog("msg", "received call", "object", "AlertDestination", "oper", "update")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	nctx = addStatusUpd(nctx)
	return a.client.AutoUpdateAlertDestination(nctx, in)
}

func (a *grpcObjMonitoringV1AlertDestination) Label(ctx context.Context, in *api.Label) (*monitoring.AlertDestination, error) {
	a.logger.DebugLog("msg", "received call", "object", "AlertDestination", "oper", "label")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoLabelAlertDestination(nctx, in)
}

func (a *grpcObjMonitoringV1AlertDestination) Get(ctx context.Context, objMeta *api.ObjectMeta) (*monitoring.AlertDestination, error) {
	a.logger.DebugLog("msg", "received call", "object", "AlertDestination", "oper", "get")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := monitoring.AlertDestination{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoGetAlertDestination(nctx, &in)
}

func (a *grpcObjMonitoringV1AlertDestination) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*monitoring.AlertDestination, error) {
	a.logger.DebugLog("msg", "received call", "object", "AlertDestination", "oper", "delete")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := monitoring.AlertDestination{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoDeleteAlertDestination(nctx, &in)
}

func (a *grpcObjMonitoringV1AlertDestination) List(ctx context.Context, options *api.ListWatchOptions) ([]*monitoring.AlertDestination, error) {
	a.logger.DebugLog("msg", "received call", "object", "AlertDestination", "oper", "list")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	r, err := a.client.AutoListAlertDestination(nctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *grpcObjMonitoringV1AlertDestination) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	a.logger.DebugLog("msg", "received call", "object", "AlertDestination", "oper", "WatchOper")
	nctx := addVersion(ctx, "v1")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	stream, err := a.client.AutoWatchAlertDestination(nctx, options)
	if err != nil {
		return nil, err
	}
	wstream := stream.(monitoring.MonitoringV1_AutoWatchAlertDestinationClient)
	bridgefn := func(lw *listerwatcher.WatcherClient) {
		for {
			r, err := wstream.Recv()
			if err != nil {
				a.logger.ErrorLog("msg", "error on receive", "err", err)
				close(lw.OutCh)
				return
			}
			for _, e := range r.Events {
				ev := kvstore.WatchEvent{
					Type:   kvstore.WatchEventType(e.Type),
					Object: e.Object,
				}
				select {
				case lw.OutCh <- &ev:
				case <-wstream.Context().Done():
					close(lw.OutCh)
					return
				}
			}
		}
	}
	lw := listerwatcher.NewWatcherClient(wstream, bridgefn)
	lw.Run()
	return lw, nil
}

func (a *grpcObjMonitoringV1AlertDestination) Allowed(oper apiintf.APIOperType) bool {
	return true
}

type restObjMonitoringV1AlertDestination struct {
	endpoints monitoring.EndpointsMonitoringV1RestClient
	instance  string
}

func (a *restObjMonitoringV1AlertDestination) Create(ctx context.Context, in *monitoring.AlertDestination) (*monitoring.AlertDestination, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoAddAlertDestination(ctx, in)
}

func (a *restObjMonitoringV1AlertDestination) Update(ctx context.Context, in *monitoring.AlertDestination) (*monitoring.AlertDestination, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoUpdateAlertDestination(ctx, in)
}

func (a *restObjMonitoringV1AlertDestination) UpdateStatus(ctx context.Context, in *monitoring.AlertDestination) (*monitoring.AlertDestination, error) {
	return nil, errors.New("not supported for REST")
}

func (a *restObjMonitoringV1AlertDestination) Label(ctx context.Context, in *api.Label) (*monitoring.AlertDestination, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoLabelAlertDestination(ctx, in)
}

func (a *restObjMonitoringV1AlertDestination) Get(ctx context.Context, objMeta *api.ObjectMeta) (*monitoring.AlertDestination, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := monitoring.AlertDestination{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoGetAlertDestination(ctx, &in)
}

func (a *restObjMonitoringV1AlertDestination) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*monitoring.AlertDestination, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := monitoring.AlertDestination{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoDeleteAlertDestination(ctx, &in)
}

func (a *restObjMonitoringV1AlertDestination) List(ctx context.Context, options *api.ListWatchOptions) ([]*monitoring.AlertDestination, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}

	if options.Tenant == "" {
		options.Tenant = globals.DefaultTenant
	}
	r, err := a.endpoints.AutoListAlertDestination(ctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *restObjMonitoringV1AlertDestination) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoWatchAlertDestination(ctx, options)
}

func (a *restObjMonitoringV1AlertDestination) Allowed(oper apiintf.APIOperType) bool {
	switch oper {
	case apiintf.CreateOper:
		return true
	case apiintf.UpdateOper:
		return true
	case apiintf.GetOper:
		return true
	case apiintf.DeleteOper:
		return true
	case apiintf.ListOper:
		return true
	case apiintf.WatchOper:
		return true
	default:
		return false
	}
}

type grpcObjMonitoringV1MirrorSession struct {
	logger log.Logger
	client monitoring.ServiceMonitoringV1Client
}

func (a *grpcObjMonitoringV1MirrorSession) Create(ctx context.Context, in *monitoring.MirrorSession) (*monitoring.MirrorSession, error) {
	a.logger.DebugLog("msg", "received call", "object", "MirrorSession", "oper", "create")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoAddMirrorSession(nctx, in)
}

func (a *grpcObjMonitoringV1MirrorSession) Update(ctx context.Context, in *monitoring.MirrorSession) (*monitoring.MirrorSession, error) {
	a.logger.DebugLog("msg", "received call", "object", "MirrorSession", "oper", "update")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoUpdateMirrorSession(nctx, in)
}

func (a *grpcObjMonitoringV1MirrorSession) UpdateStatus(ctx context.Context, in *monitoring.MirrorSession) (*monitoring.MirrorSession, error) {
	a.logger.DebugLog("msg", "received call", "object", "MirrorSession", "oper", "update")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	nctx = addStatusUpd(nctx)
	return a.client.AutoUpdateMirrorSession(nctx, in)
}

func (a *grpcObjMonitoringV1MirrorSession) Label(ctx context.Context, in *api.Label) (*monitoring.MirrorSession, error) {
	a.logger.DebugLog("msg", "received call", "object", "MirrorSession", "oper", "label")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoLabelMirrorSession(nctx, in)
}

func (a *grpcObjMonitoringV1MirrorSession) Get(ctx context.Context, objMeta *api.ObjectMeta) (*monitoring.MirrorSession, error) {
	a.logger.DebugLog("msg", "received call", "object", "MirrorSession", "oper", "get")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := monitoring.MirrorSession{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoGetMirrorSession(nctx, &in)
}

func (a *grpcObjMonitoringV1MirrorSession) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*monitoring.MirrorSession, error) {
	a.logger.DebugLog("msg", "received call", "object", "MirrorSession", "oper", "delete")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := monitoring.MirrorSession{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoDeleteMirrorSession(nctx, &in)
}

func (a *grpcObjMonitoringV1MirrorSession) List(ctx context.Context, options *api.ListWatchOptions) ([]*monitoring.MirrorSession, error) {
	a.logger.DebugLog("msg", "received call", "object", "MirrorSession", "oper", "list")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	r, err := a.client.AutoListMirrorSession(nctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *grpcObjMonitoringV1MirrorSession) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	a.logger.DebugLog("msg", "received call", "object", "MirrorSession", "oper", "WatchOper")
	nctx := addVersion(ctx, "v1")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	stream, err := a.client.AutoWatchMirrorSession(nctx, options)
	if err != nil {
		return nil, err
	}
	wstream := stream.(monitoring.MonitoringV1_AutoWatchMirrorSessionClient)
	bridgefn := func(lw *listerwatcher.WatcherClient) {
		for {
			r, err := wstream.Recv()
			if err != nil {
				a.logger.ErrorLog("msg", "error on receive", "err", err)
				close(lw.OutCh)
				return
			}
			for _, e := range r.Events {
				ev := kvstore.WatchEvent{
					Type:   kvstore.WatchEventType(e.Type),
					Object: e.Object,
				}
				select {
				case lw.OutCh <- &ev:
				case <-wstream.Context().Done():
					close(lw.OutCh)
					return
				}
			}
		}
	}
	lw := listerwatcher.NewWatcherClient(wstream, bridgefn)
	lw.Run()
	return lw, nil
}

func (a *grpcObjMonitoringV1MirrorSession) Allowed(oper apiintf.APIOperType) bool {
	return true
}

type restObjMonitoringV1MirrorSession struct {
	endpoints monitoring.EndpointsMonitoringV1RestClient
	instance  string
}

func (a *restObjMonitoringV1MirrorSession) Create(ctx context.Context, in *monitoring.MirrorSession) (*monitoring.MirrorSession, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoAddMirrorSession(ctx, in)
}

func (a *restObjMonitoringV1MirrorSession) Update(ctx context.Context, in *monitoring.MirrorSession) (*monitoring.MirrorSession, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoUpdateMirrorSession(ctx, in)
}

func (a *restObjMonitoringV1MirrorSession) UpdateStatus(ctx context.Context, in *monitoring.MirrorSession) (*monitoring.MirrorSession, error) {
	return nil, errors.New("not supported for REST")
}

func (a *restObjMonitoringV1MirrorSession) Label(ctx context.Context, in *api.Label) (*monitoring.MirrorSession, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoLabelMirrorSession(ctx, in)
}

func (a *restObjMonitoringV1MirrorSession) Get(ctx context.Context, objMeta *api.ObjectMeta) (*monitoring.MirrorSession, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := monitoring.MirrorSession{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoGetMirrorSession(ctx, &in)
}

func (a *restObjMonitoringV1MirrorSession) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*monitoring.MirrorSession, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := monitoring.MirrorSession{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoDeleteMirrorSession(ctx, &in)
}

func (a *restObjMonitoringV1MirrorSession) List(ctx context.Context, options *api.ListWatchOptions) ([]*monitoring.MirrorSession, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}

	if options.Tenant == "" {
		options.Tenant = globals.DefaultTenant
	}
	r, err := a.endpoints.AutoListMirrorSession(ctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *restObjMonitoringV1MirrorSession) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoWatchMirrorSession(ctx, options)
}

func (a *restObjMonitoringV1MirrorSession) Allowed(oper apiintf.APIOperType) bool {
	switch oper {
	case apiintf.CreateOper:
		return true
	case apiintf.UpdateOper:
		return true
	case apiintf.GetOper:
		return true
	case apiintf.DeleteOper:
		return true
	case apiintf.ListOper:
		return true
	case apiintf.WatchOper:
		return true
	default:
		return false
	}
}

type grpcObjMonitoringV1TroubleshootingSession struct {
	logger log.Logger
	client monitoring.ServiceMonitoringV1Client
}

func (a *grpcObjMonitoringV1TroubleshootingSession) Create(ctx context.Context, in *monitoring.TroubleshootingSession) (*monitoring.TroubleshootingSession, error) {
	a.logger.DebugLog("msg", "received call", "object", "TroubleshootingSession", "oper", "create")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoAddTroubleshootingSession(nctx, in)
}

func (a *grpcObjMonitoringV1TroubleshootingSession) Update(ctx context.Context, in *monitoring.TroubleshootingSession) (*monitoring.TroubleshootingSession, error) {
	a.logger.DebugLog("msg", "received call", "object", "TroubleshootingSession", "oper", "update")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoUpdateTroubleshootingSession(nctx, in)
}

func (a *grpcObjMonitoringV1TroubleshootingSession) UpdateStatus(ctx context.Context, in *monitoring.TroubleshootingSession) (*monitoring.TroubleshootingSession, error) {
	a.logger.DebugLog("msg", "received call", "object", "TroubleshootingSession", "oper", "update")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	nctx = addStatusUpd(nctx)
	return a.client.AutoUpdateTroubleshootingSession(nctx, in)
}

func (a *grpcObjMonitoringV1TroubleshootingSession) Label(ctx context.Context, in *api.Label) (*monitoring.TroubleshootingSession, error) {
	a.logger.DebugLog("msg", "received call", "object", "TroubleshootingSession", "oper", "label")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoLabelTroubleshootingSession(nctx, in)
}

func (a *grpcObjMonitoringV1TroubleshootingSession) Get(ctx context.Context, objMeta *api.ObjectMeta) (*monitoring.TroubleshootingSession, error) {
	a.logger.DebugLog("msg", "received call", "object", "TroubleshootingSession", "oper", "get")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := monitoring.TroubleshootingSession{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoGetTroubleshootingSession(nctx, &in)
}

func (a *grpcObjMonitoringV1TroubleshootingSession) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*monitoring.TroubleshootingSession, error) {
	a.logger.DebugLog("msg", "received call", "object", "TroubleshootingSession", "oper", "delete")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := monitoring.TroubleshootingSession{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoDeleteTroubleshootingSession(nctx, &in)
}

func (a *grpcObjMonitoringV1TroubleshootingSession) List(ctx context.Context, options *api.ListWatchOptions) ([]*monitoring.TroubleshootingSession, error) {
	a.logger.DebugLog("msg", "received call", "object", "TroubleshootingSession", "oper", "list")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	r, err := a.client.AutoListTroubleshootingSession(nctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *grpcObjMonitoringV1TroubleshootingSession) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	a.logger.DebugLog("msg", "received call", "object", "TroubleshootingSession", "oper", "WatchOper")
	nctx := addVersion(ctx, "v1")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	stream, err := a.client.AutoWatchTroubleshootingSession(nctx, options)
	if err != nil {
		return nil, err
	}
	wstream := stream.(monitoring.MonitoringV1_AutoWatchTroubleshootingSessionClient)
	bridgefn := func(lw *listerwatcher.WatcherClient) {
		for {
			r, err := wstream.Recv()
			if err != nil {
				a.logger.ErrorLog("msg", "error on receive", "err", err)
				close(lw.OutCh)
				return
			}
			for _, e := range r.Events {
				ev := kvstore.WatchEvent{
					Type:   kvstore.WatchEventType(e.Type),
					Object: e.Object,
				}
				select {
				case lw.OutCh <- &ev:
				case <-wstream.Context().Done():
					close(lw.OutCh)
					return
				}
			}
		}
	}
	lw := listerwatcher.NewWatcherClient(wstream, bridgefn)
	lw.Run()
	return lw, nil
}

func (a *grpcObjMonitoringV1TroubleshootingSession) Allowed(oper apiintf.APIOperType) bool {
	return true
}

type restObjMonitoringV1TroubleshootingSession struct {
	endpoints monitoring.EndpointsMonitoringV1RestClient
	instance  string
}

func (a *restObjMonitoringV1TroubleshootingSession) Create(ctx context.Context, in *monitoring.TroubleshootingSession) (*monitoring.TroubleshootingSession, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoAddTroubleshootingSession(ctx, in)
}

func (a *restObjMonitoringV1TroubleshootingSession) Update(ctx context.Context, in *monitoring.TroubleshootingSession) (*monitoring.TroubleshootingSession, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoUpdateTroubleshootingSession(ctx, in)
}

func (a *restObjMonitoringV1TroubleshootingSession) UpdateStatus(ctx context.Context, in *monitoring.TroubleshootingSession) (*monitoring.TroubleshootingSession, error) {
	return nil, errors.New("not supported for REST")
}

func (a *restObjMonitoringV1TroubleshootingSession) Label(ctx context.Context, in *api.Label) (*monitoring.TroubleshootingSession, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoLabelTroubleshootingSession(ctx, in)
}

func (a *restObjMonitoringV1TroubleshootingSession) Get(ctx context.Context, objMeta *api.ObjectMeta) (*monitoring.TroubleshootingSession, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := monitoring.TroubleshootingSession{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoGetTroubleshootingSession(ctx, &in)
}

func (a *restObjMonitoringV1TroubleshootingSession) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*monitoring.TroubleshootingSession, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := monitoring.TroubleshootingSession{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoDeleteTroubleshootingSession(ctx, &in)
}

func (a *restObjMonitoringV1TroubleshootingSession) List(ctx context.Context, options *api.ListWatchOptions) ([]*monitoring.TroubleshootingSession, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}

	if options.Tenant == "" {
		options.Tenant = globals.DefaultTenant
	}
	r, err := a.endpoints.AutoListTroubleshootingSession(ctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *restObjMonitoringV1TroubleshootingSession) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoWatchTroubleshootingSession(ctx, options)
}

func (a *restObjMonitoringV1TroubleshootingSession) Allowed(oper apiintf.APIOperType) bool {
	switch oper {
	case apiintf.CreateOper:
		return true
	case apiintf.UpdateOper:
		return true
	case apiintf.GetOper:
		return true
	case apiintf.DeleteOper:
		return true
	case apiintf.ListOper:
		return true
	case apiintf.WatchOper:
		return false
	default:
		return false
	}
}

type grpcObjMonitoringV1TechSupportRequest struct {
	logger log.Logger
	client monitoring.ServiceMonitoringV1Client
}

func (a *grpcObjMonitoringV1TechSupportRequest) Create(ctx context.Context, in *monitoring.TechSupportRequest) (*monitoring.TechSupportRequest, error) {
	a.logger.DebugLog("msg", "received call", "object", "TechSupportRequest", "oper", "create")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoAddTechSupportRequest(nctx, in)
}

func (a *grpcObjMonitoringV1TechSupportRequest) Update(ctx context.Context, in *monitoring.TechSupportRequest) (*monitoring.TechSupportRequest, error) {
	a.logger.DebugLog("msg", "received call", "object", "TechSupportRequest", "oper", "update")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoUpdateTechSupportRequest(nctx, in)
}

func (a *grpcObjMonitoringV1TechSupportRequest) UpdateStatus(ctx context.Context, in *monitoring.TechSupportRequest) (*monitoring.TechSupportRequest, error) {
	a.logger.DebugLog("msg", "received call", "object", "TechSupportRequest", "oper", "update")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	nctx = addStatusUpd(nctx)
	return a.client.AutoUpdateTechSupportRequest(nctx, in)
}

func (a *grpcObjMonitoringV1TechSupportRequest) Label(ctx context.Context, in *api.Label) (*monitoring.TechSupportRequest, error) {
	a.logger.DebugLog("msg", "received call", "object", "TechSupportRequest", "oper", "label")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoLabelTechSupportRequest(nctx, in)
}

func (a *grpcObjMonitoringV1TechSupportRequest) Get(ctx context.Context, objMeta *api.ObjectMeta) (*monitoring.TechSupportRequest, error) {
	a.logger.DebugLog("msg", "received call", "object", "TechSupportRequest", "oper", "get")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := monitoring.TechSupportRequest{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoGetTechSupportRequest(nctx, &in)
}

func (a *grpcObjMonitoringV1TechSupportRequest) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*monitoring.TechSupportRequest, error) {
	a.logger.DebugLog("msg", "received call", "object", "TechSupportRequest", "oper", "delete")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := monitoring.TechSupportRequest{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoDeleteTechSupportRequest(nctx, &in)
}

func (a *grpcObjMonitoringV1TechSupportRequest) List(ctx context.Context, options *api.ListWatchOptions) ([]*monitoring.TechSupportRequest, error) {
	a.logger.DebugLog("msg", "received call", "object", "TechSupportRequest", "oper", "list")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	r, err := a.client.AutoListTechSupportRequest(nctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *grpcObjMonitoringV1TechSupportRequest) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	a.logger.DebugLog("msg", "received call", "object", "TechSupportRequest", "oper", "WatchOper")
	nctx := addVersion(ctx, "v1")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	stream, err := a.client.AutoWatchTechSupportRequest(nctx, options)
	if err != nil {
		return nil, err
	}
	wstream := stream.(monitoring.MonitoringV1_AutoWatchTechSupportRequestClient)
	bridgefn := func(lw *listerwatcher.WatcherClient) {
		for {
			r, err := wstream.Recv()
			if err != nil {
				a.logger.ErrorLog("msg", "error on receive", "err", err)
				close(lw.OutCh)
				return
			}
			for _, e := range r.Events {
				ev := kvstore.WatchEvent{
					Type:   kvstore.WatchEventType(e.Type),
					Object: e.Object,
				}
				select {
				case lw.OutCh <- &ev:
				case <-wstream.Context().Done():
					close(lw.OutCh)
					return
				}
			}
		}
	}
	lw := listerwatcher.NewWatcherClient(wstream, bridgefn)
	lw.Run()
	return lw, nil
}

func (a *grpcObjMonitoringV1TechSupportRequest) Allowed(oper apiintf.APIOperType) bool {
	return true
}

type restObjMonitoringV1TechSupportRequest struct {
	endpoints monitoring.EndpointsMonitoringV1RestClient
	instance  string
}

func (a *restObjMonitoringV1TechSupportRequest) Create(ctx context.Context, in *monitoring.TechSupportRequest) (*monitoring.TechSupportRequest, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoAddTechSupportRequest(ctx, in)
}

func (a *restObjMonitoringV1TechSupportRequest) Update(ctx context.Context, in *monitoring.TechSupportRequest) (*monitoring.TechSupportRequest, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoUpdateTechSupportRequest(ctx, in)
}

func (a *restObjMonitoringV1TechSupportRequest) UpdateStatus(ctx context.Context, in *monitoring.TechSupportRequest) (*monitoring.TechSupportRequest, error) {
	return nil, errors.New("not supported for REST")
}

func (a *restObjMonitoringV1TechSupportRequest) Label(ctx context.Context, in *api.Label) (*monitoring.TechSupportRequest, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoLabelTechSupportRequest(ctx, in)
}

func (a *restObjMonitoringV1TechSupportRequest) Get(ctx context.Context, objMeta *api.ObjectMeta) (*monitoring.TechSupportRequest, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := monitoring.TechSupportRequest{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoGetTechSupportRequest(ctx, &in)
}

func (a *restObjMonitoringV1TechSupportRequest) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*monitoring.TechSupportRequest, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := monitoring.TechSupportRequest{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoDeleteTechSupportRequest(ctx, &in)
}

func (a *restObjMonitoringV1TechSupportRequest) List(ctx context.Context, options *api.ListWatchOptions) ([]*monitoring.TechSupportRequest, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}

	r, err := a.endpoints.AutoListTechSupportRequest(ctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *restObjMonitoringV1TechSupportRequest) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoWatchTechSupportRequest(ctx, options)
}

func (a *restObjMonitoringV1TechSupportRequest) Allowed(oper apiintf.APIOperType) bool {
	switch oper {
	case apiintf.CreateOper:
		return true
	case apiintf.UpdateOper:
		return false
	case apiintf.GetOper:
		return true
	case apiintf.DeleteOper:
		return true
	case apiintf.ListOper:
		return true
	case apiintf.WatchOper:
		return true
	default:
		return false
	}
}

type grpcObjMonitoringV1ArchiveRequest struct {
	logger log.Logger
	client monitoring.ServiceMonitoringV1Client
}

func (a *grpcObjMonitoringV1ArchiveRequest) Create(ctx context.Context, in *monitoring.ArchiveRequest) (*monitoring.ArchiveRequest, error) {
	a.logger.DebugLog("msg", "received call", "object", "ArchiveRequest", "oper", "create")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoAddArchiveRequest(nctx, in)
}

func (a *grpcObjMonitoringV1ArchiveRequest) Update(ctx context.Context, in *monitoring.ArchiveRequest) (*monitoring.ArchiveRequest, error) {
	a.logger.DebugLog("msg", "received call", "object", "ArchiveRequest", "oper", "update")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoUpdateArchiveRequest(nctx, in)
}

func (a *grpcObjMonitoringV1ArchiveRequest) UpdateStatus(ctx context.Context, in *monitoring.ArchiveRequest) (*monitoring.ArchiveRequest, error) {
	a.logger.DebugLog("msg", "received call", "object", "ArchiveRequest", "oper", "update")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	nctx = addStatusUpd(nctx)
	return a.client.AutoUpdateArchiveRequest(nctx, in)
}

func (a *grpcObjMonitoringV1ArchiveRequest) Label(ctx context.Context, in *api.Label) (*monitoring.ArchiveRequest, error) {
	a.logger.DebugLog("msg", "received call", "object", "ArchiveRequest", "oper", "label")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoLabelArchiveRequest(nctx, in)
}

func (a *grpcObjMonitoringV1ArchiveRequest) Get(ctx context.Context, objMeta *api.ObjectMeta) (*monitoring.ArchiveRequest, error) {
	a.logger.DebugLog("msg", "received call", "object", "ArchiveRequest", "oper", "get")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := monitoring.ArchiveRequest{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoGetArchiveRequest(nctx, &in)
}

func (a *grpcObjMonitoringV1ArchiveRequest) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*monitoring.ArchiveRequest, error) {
	a.logger.DebugLog("msg", "received call", "object", "ArchiveRequest", "oper", "delete")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := monitoring.ArchiveRequest{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoDeleteArchiveRequest(nctx, &in)
}

func (a *grpcObjMonitoringV1ArchiveRequest) List(ctx context.Context, options *api.ListWatchOptions) ([]*monitoring.ArchiveRequest, error) {
	a.logger.DebugLog("msg", "received call", "object", "ArchiveRequest", "oper", "list")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	r, err := a.client.AutoListArchiveRequest(nctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *grpcObjMonitoringV1ArchiveRequest) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	a.logger.DebugLog("msg", "received call", "object", "ArchiveRequest", "oper", "WatchOper")
	nctx := addVersion(ctx, "v1")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	stream, err := a.client.AutoWatchArchiveRequest(nctx, options)
	if err != nil {
		return nil, err
	}
	wstream := stream.(monitoring.MonitoringV1_AutoWatchArchiveRequestClient)
	bridgefn := func(lw *listerwatcher.WatcherClient) {
		for {
			r, err := wstream.Recv()
			if err != nil {
				a.logger.ErrorLog("msg", "error on receive", "err", err)
				close(lw.OutCh)
				return
			}
			for _, e := range r.Events {
				ev := kvstore.WatchEvent{
					Type:   kvstore.WatchEventType(e.Type),
					Object: e.Object,
				}
				select {
				case lw.OutCh <- &ev:
				case <-wstream.Context().Done():
					close(lw.OutCh)
					return
				}
			}
		}
	}
	lw := listerwatcher.NewWatcherClient(wstream, bridgefn)
	lw.Run()
	return lw, nil
}

func (a *grpcObjMonitoringV1ArchiveRequest) Cancel(ctx context.Context, in *monitoring.CancelArchiveRequest) (*monitoring.ArchiveRequest, error) {
	a.logger.DebugLog("msg", "received call", "object", "{Cancel CancelArchiveRequest ArchiveRequest}", "oper", "Cancel")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.Cancel(nctx, in)
}

func (a *grpcObjMonitoringV1ArchiveRequest) Allowed(oper apiintf.APIOperType) bool {
	return true
}

type restObjMonitoringV1ArchiveRequest struct {
	endpoints monitoring.EndpointsMonitoringV1RestClient
	instance  string
}

func (a *restObjMonitoringV1ArchiveRequest) Create(ctx context.Context, in *monitoring.ArchiveRequest) (*monitoring.ArchiveRequest, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoAddArchiveRequest(ctx, in)
}

func (a *restObjMonitoringV1ArchiveRequest) Update(ctx context.Context, in *monitoring.ArchiveRequest) (*monitoring.ArchiveRequest, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoUpdateArchiveRequest(ctx, in)
}

func (a *restObjMonitoringV1ArchiveRequest) UpdateStatus(ctx context.Context, in *monitoring.ArchiveRequest) (*monitoring.ArchiveRequest, error) {
	return nil, errors.New("not supported for REST")
}

func (a *restObjMonitoringV1ArchiveRequest) Label(ctx context.Context, in *api.Label) (*monitoring.ArchiveRequest, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoLabelArchiveRequest(ctx, in)
}

func (a *restObjMonitoringV1ArchiveRequest) Get(ctx context.Context, objMeta *api.ObjectMeta) (*monitoring.ArchiveRequest, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := monitoring.ArchiveRequest{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoGetArchiveRequest(ctx, &in)
}

func (a *restObjMonitoringV1ArchiveRequest) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*monitoring.ArchiveRequest, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := monitoring.ArchiveRequest{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoDeleteArchiveRequest(ctx, &in)
}

func (a *restObjMonitoringV1ArchiveRequest) List(ctx context.Context, options *api.ListWatchOptions) ([]*monitoring.ArchiveRequest, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}

	if options.Tenant == "" {
		options.Tenant = globals.DefaultTenant
	}
	r, err := a.endpoints.AutoListArchiveRequest(ctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *restObjMonitoringV1ArchiveRequest) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoWatchArchiveRequest(ctx, options)
}

func (a *restObjMonitoringV1ArchiveRequest) Allowed(oper apiintf.APIOperType) bool {
	switch oper {
	case apiintf.CreateOper:
		return true
	case apiintf.UpdateOper:
		return false
	case apiintf.GetOper:
		return true
	case apiintf.DeleteOper:
		return true
	case apiintf.ListOper:
		return true
	case apiintf.WatchOper:
		return true
	default:
		return false
	}
}

func (a *restObjMonitoringV1ArchiveRequest) Cancel(ctx context.Context, in *monitoring.CancelArchiveRequest) (*monitoring.ArchiveRequest, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.CancelArchiveRequest(ctx, in)
}

type grpcObjMonitoringV1AuditPolicy struct {
	logger log.Logger
	client monitoring.ServiceMonitoringV1Client
}

func (a *grpcObjMonitoringV1AuditPolicy) Create(ctx context.Context, in *monitoring.AuditPolicy) (*monitoring.AuditPolicy, error) {
	a.logger.DebugLog("msg", "received call", "object", "AuditPolicy", "oper", "create")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoAddAuditPolicy(nctx, in)
}

func (a *grpcObjMonitoringV1AuditPolicy) Update(ctx context.Context, in *monitoring.AuditPolicy) (*monitoring.AuditPolicy, error) {
	a.logger.DebugLog("msg", "received call", "object", "AuditPolicy", "oper", "update")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoUpdateAuditPolicy(nctx, in)
}

func (a *grpcObjMonitoringV1AuditPolicy) UpdateStatus(ctx context.Context, in *monitoring.AuditPolicy) (*monitoring.AuditPolicy, error) {
	a.logger.DebugLog("msg", "received call", "object", "AuditPolicy", "oper", "update")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	nctx = addStatusUpd(nctx)
	return a.client.AutoUpdateAuditPolicy(nctx, in)
}

func (a *grpcObjMonitoringV1AuditPolicy) Label(ctx context.Context, in *api.Label) (*monitoring.AuditPolicy, error) {
	a.logger.DebugLog("msg", "received call", "object", "AuditPolicy", "oper", "label")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoLabelAuditPolicy(nctx, in)
}

func (a *grpcObjMonitoringV1AuditPolicy) Get(ctx context.Context, objMeta *api.ObjectMeta) (*monitoring.AuditPolicy, error) {
	a.logger.DebugLog("msg", "received call", "object", "AuditPolicy", "oper", "get")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := monitoring.AuditPolicy{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoGetAuditPolicy(nctx, &in)
}

func (a *grpcObjMonitoringV1AuditPolicy) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*monitoring.AuditPolicy, error) {
	a.logger.DebugLog("msg", "received call", "object", "AuditPolicy", "oper", "delete")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := monitoring.AuditPolicy{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoDeleteAuditPolicy(nctx, &in)
}

func (a *grpcObjMonitoringV1AuditPolicy) List(ctx context.Context, options *api.ListWatchOptions) ([]*monitoring.AuditPolicy, error) {
	a.logger.DebugLog("msg", "received call", "object", "AuditPolicy", "oper", "list")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	r, err := a.client.AutoListAuditPolicy(nctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *grpcObjMonitoringV1AuditPolicy) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	a.logger.DebugLog("msg", "received call", "object", "AuditPolicy", "oper", "WatchOper")
	nctx := addVersion(ctx, "v1")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	stream, err := a.client.AutoWatchAuditPolicy(nctx, options)
	if err != nil {
		return nil, err
	}
	wstream := stream.(monitoring.MonitoringV1_AutoWatchAuditPolicyClient)
	bridgefn := func(lw *listerwatcher.WatcherClient) {
		for {
			r, err := wstream.Recv()
			if err != nil {
				a.logger.ErrorLog("msg", "error on receive", "err", err)
				close(lw.OutCh)
				return
			}
			for _, e := range r.Events {
				ev := kvstore.WatchEvent{
					Type:   kvstore.WatchEventType(e.Type),
					Object: e.Object,
				}
				select {
				case lw.OutCh <- &ev:
				case <-wstream.Context().Done():
					close(lw.OutCh)
					return
				}
			}
		}
	}
	lw := listerwatcher.NewWatcherClient(wstream, bridgefn)
	lw.Run()
	return lw, nil
}

func (a *grpcObjMonitoringV1AuditPolicy) Allowed(oper apiintf.APIOperType) bool {
	return true
}

type restObjMonitoringV1AuditPolicy struct {
	endpoints monitoring.EndpointsMonitoringV1RestClient
	instance  string
}

func (a *restObjMonitoringV1AuditPolicy) Create(ctx context.Context, in *monitoring.AuditPolicy) (*monitoring.AuditPolicy, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoAddAuditPolicy(ctx, in)
}

func (a *restObjMonitoringV1AuditPolicy) Update(ctx context.Context, in *monitoring.AuditPolicy) (*monitoring.AuditPolicy, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoUpdateAuditPolicy(ctx, in)
}

func (a *restObjMonitoringV1AuditPolicy) UpdateStatus(ctx context.Context, in *monitoring.AuditPolicy) (*monitoring.AuditPolicy, error) {
	return nil, errors.New("not supported for REST")
}

func (a *restObjMonitoringV1AuditPolicy) Label(ctx context.Context, in *api.Label) (*monitoring.AuditPolicy, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoLabelAuditPolicy(ctx, in)
}

func (a *restObjMonitoringV1AuditPolicy) Get(ctx context.Context, objMeta *api.ObjectMeta) (*monitoring.AuditPolicy, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := monitoring.AuditPolicy{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoGetAuditPolicy(ctx, &in)
}

func (a *restObjMonitoringV1AuditPolicy) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*monitoring.AuditPolicy, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := monitoring.AuditPolicy{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoDeleteAuditPolicy(ctx, &in)
}

func (a *restObjMonitoringV1AuditPolicy) List(ctx context.Context, options *api.ListWatchOptions) ([]*monitoring.AuditPolicy, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}

	if options.Tenant == "" {
		options.Tenant = globals.DefaultTenant
	}
	r, err := a.endpoints.AutoListAuditPolicy(ctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *restObjMonitoringV1AuditPolicy) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoWatchAuditPolicy(ctx, options)
}

func (a *restObjMonitoringV1AuditPolicy) Allowed(oper apiintf.APIOperType) bool {
	switch oper {
	case apiintf.CreateOper:
		return true
	case apiintf.UpdateOper:
		return true
	case apiintf.GetOper:
		return true
	case apiintf.DeleteOper:
		return true
	case apiintf.ListOper:
		return false
	case apiintf.WatchOper:
		return true
	default:
		return false
	}
}

type crudClientMonitoringV1 struct {
	logger log.Logger
	client monitoring.ServiceMonitoringV1Client

	grpcEventPolicy            monitoring.MonitoringV1EventPolicyInterface
	grpcFwlogPolicy            monitoring.MonitoringV1FwlogPolicyInterface
	grpcFlowExportPolicy       monitoring.MonitoringV1FlowExportPolicyInterface
	grpcAlert                  monitoring.MonitoringV1AlertInterface
	grpcAlertPolicy            monitoring.MonitoringV1AlertPolicyInterface
	grpcAlertDestination       monitoring.MonitoringV1AlertDestinationInterface
	grpcMirrorSession          monitoring.MonitoringV1MirrorSessionInterface
	grpcTroubleshootingSession monitoring.MonitoringV1TroubleshootingSessionInterface
	grpcTechSupportRequest     monitoring.MonitoringV1TechSupportRequestInterface
	grpcArchiveRequest         monitoring.MonitoringV1ArchiveRequestInterface
	grpcAuditPolicy            monitoring.MonitoringV1AuditPolicyInterface
}

// NewGrpcCrudClientMonitoringV1 creates a GRPC client for the service
func NewGrpcCrudClientMonitoringV1(conn *grpc.ClientConn, logger log.Logger) monitoring.MonitoringV1Interface {
	client := NewMonitoringV1Backend(conn, logger)
	return &crudClientMonitoringV1{
		logger: logger,
		client: client,

		grpcEventPolicy:            &grpcObjMonitoringV1EventPolicy{client: client, logger: logger},
		grpcFwlogPolicy:            &grpcObjMonitoringV1FwlogPolicy{client: client, logger: logger},
		grpcFlowExportPolicy:       &grpcObjMonitoringV1FlowExportPolicy{client: client, logger: logger},
		grpcAlert:                  &grpcObjMonitoringV1Alert{client: client, logger: logger},
		grpcAlertPolicy:            &grpcObjMonitoringV1AlertPolicy{client: client, logger: logger},
		grpcAlertDestination:       &grpcObjMonitoringV1AlertDestination{client: client, logger: logger},
		grpcMirrorSession:          &grpcObjMonitoringV1MirrorSession{client: client, logger: logger},
		grpcTroubleshootingSession: &grpcObjMonitoringV1TroubleshootingSession{client: client, logger: logger},
		grpcTechSupportRequest:     &grpcObjMonitoringV1TechSupportRequest{client: client, logger: logger},
		grpcArchiveRequest:         &grpcObjMonitoringV1ArchiveRequest{client: client, logger: logger},
		grpcAuditPolicy:            &grpcObjMonitoringV1AuditPolicy{client: client, logger: logger},
	}
}

func (a *crudClientMonitoringV1) EventPolicy() monitoring.MonitoringV1EventPolicyInterface {
	return a.grpcEventPolicy
}

func (a *crudClientMonitoringV1) FwlogPolicy() monitoring.MonitoringV1FwlogPolicyInterface {
	return a.grpcFwlogPolicy
}

func (a *crudClientMonitoringV1) FlowExportPolicy() monitoring.MonitoringV1FlowExportPolicyInterface {
	return a.grpcFlowExportPolicy
}

func (a *crudClientMonitoringV1) Alert() monitoring.MonitoringV1AlertInterface {
	return a.grpcAlert
}

func (a *crudClientMonitoringV1) AlertPolicy() monitoring.MonitoringV1AlertPolicyInterface {
	return a.grpcAlertPolicy
}

func (a *crudClientMonitoringV1) AlertDestination() monitoring.MonitoringV1AlertDestinationInterface {
	return a.grpcAlertDestination
}

func (a *crudClientMonitoringV1) MirrorSession() monitoring.MonitoringV1MirrorSessionInterface {
	return a.grpcMirrorSession
}

func (a *crudClientMonitoringV1) TroubleshootingSession() monitoring.MonitoringV1TroubleshootingSessionInterface {
	return a.grpcTroubleshootingSession
}

func (a *crudClientMonitoringV1) TechSupportRequest() monitoring.MonitoringV1TechSupportRequestInterface {
	return a.grpcTechSupportRequest
}

func (a *crudClientMonitoringV1) ArchiveRequest() monitoring.MonitoringV1ArchiveRequestInterface {
	return a.grpcArchiveRequest
}

func (a *crudClientMonitoringV1) AuditPolicy() monitoring.MonitoringV1AuditPolicyInterface {
	return a.grpcAuditPolicy
}

func (a *crudClientMonitoringV1) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	a.logger.DebugLog("msg", "received call", "object", "MonitoringV1", "oper", "WatchOper")
	nctx := addVersion(ctx, "v1")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	stream, err := a.client.AutoWatchSvcMonitoringV1(nctx, options)
	if err != nil {
		return nil, err
	}
	wstream := stream.(monitoring.MonitoringV1_AutoWatchSvcMonitoringV1Client)
	bridgefn := func(lw *listerwatcher.WatcherClient) {
		for {
			r, err := wstream.Recv()
			if err != nil {
				a.logger.ErrorLog("msg", "error on receive", "err", err)
				close(lw.OutCh)
				return
			}
			for _, e := range r.Events {
				ev := kvstore.WatchEvent{Type: kvstore.WatchEventType(e.Type)}
				robj, err := listerwatcher.GetObject(e)
				if err != nil {
					a.logger.ErrorLog("msg", "error on receive unmarshall", "err", err)
					close(lw.OutCh)
					return
				}
				ev.Object = robj
				select {
				case lw.OutCh <- &ev:
				case <-wstream.Context().Done():
					close(lw.OutCh)
					return
				}
			}
		}
	}
	lw := listerwatcher.NewWatcherClient(wstream, bridgefn)
	lw.Run()
	return lw, nil
}

type crudRestClientMonitoringV1 struct {
	restEventPolicy            monitoring.MonitoringV1EventPolicyInterface
	restFwlogPolicy            monitoring.MonitoringV1FwlogPolicyInterface
	restFlowExportPolicy       monitoring.MonitoringV1FlowExportPolicyInterface
	restAlert                  monitoring.MonitoringV1AlertInterface
	restAlertPolicy            monitoring.MonitoringV1AlertPolicyInterface
	restAlertDestination       monitoring.MonitoringV1AlertDestinationInterface
	restMirrorSession          monitoring.MonitoringV1MirrorSessionInterface
	restTroubleshootingSession monitoring.MonitoringV1TroubleshootingSessionInterface
	restTechSupportRequest     monitoring.MonitoringV1TechSupportRequestInterface
	restArchiveRequest         monitoring.MonitoringV1ArchiveRequestInterface
	restAuditPolicy            monitoring.MonitoringV1AuditPolicyInterface
}

// NewRestCrudClientMonitoringV1 creates a REST client for the service.
func NewRestCrudClientMonitoringV1(url string, httpClient *http.Client) monitoring.MonitoringV1Interface {
	endpoints, err := monitoring.MakeMonitoringV1RestClientEndpoints(url, httpClient)
	if err != nil {
		oldlog.Fatal("failed to create client")
	}
	return &crudRestClientMonitoringV1{

		restEventPolicy:            &restObjMonitoringV1EventPolicy{endpoints: endpoints, instance: url},
		restFwlogPolicy:            &restObjMonitoringV1FwlogPolicy{endpoints: endpoints, instance: url},
		restFlowExportPolicy:       &restObjMonitoringV1FlowExportPolicy{endpoints: endpoints, instance: url},
		restAlert:                  &restObjMonitoringV1Alert{endpoints: endpoints, instance: url},
		restAlertPolicy:            &restObjMonitoringV1AlertPolicy{endpoints: endpoints, instance: url},
		restAlertDestination:       &restObjMonitoringV1AlertDestination{endpoints: endpoints, instance: url},
		restMirrorSession:          &restObjMonitoringV1MirrorSession{endpoints: endpoints, instance: url},
		restTroubleshootingSession: &restObjMonitoringV1TroubleshootingSession{endpoints: endpoints, instance: url},
		restTechSupportRequest:     &restObjMonitoringV1TechSupportRequest{endpoints: endpoints, instance: url},
		restArchiveRequest:         &restObjMonitoringV1ArchiveRequest{endpoints: endpoints, instance: url},
		restAuditPolicy:            &restObjMonitoringV1AuditPolicy{endpoints: endpoints, instance: url},
	}
}

// NewStagedRestCrudClientMonitoringV1 creates a REST client for the service.
func NewStagedRestCrudClientMonitoringV1(url string, id string, httpClient *http.Client) monitoring.MonitoringV1Interface {
	endpoints, err := monitoring.MakeMonitoringV1StagedRestClientEndpoints(url, id, httpClient)
	if err != nil {
		oldlog.Fatal("failed to create client")
	}
	return &crudRestClientMonitoringV1{

		restEventPolicy:            &restObjMonitoringV1EventPolicy{endpoints: endpoints, instance: url},
		restFwlogPolicy:            &restObjMonitoringV1FwlogPolicy{endpoints: endpoints, instance: url},
		restFlowExportPolicy:       &restObjMonitoringV1FlowExportPolicy{endpoints: endpoints, instance: url},
		restAlert:                  &restObjMonitoringV1Alert{endpoints: endpoints, instance: url},
		restAlertPolicy:            &restObjMonitoringV1AlertPolicy{endpoints: endpoints, instance: url},
		restAlertDestination:       &restObjMonitoringV1AlertDestination{endpoints: endpoints, instance: url},
		restMirrorSession:          &restObjMonitoringV1MirrorSession{endpoints: endpoints, instance: url},
		restTroubleshootingSession: &restObjMonitoringV1TroubleshootingSession{endpoints: endpoints, instance: url},
		restTechSupportRequest:     &restObjMonitoringV1TechSupportRequest{endpoints: endpoints, instance: url},
		restArchiveRequest:         &restObjMonitoringV1ArchiveRequest{endpoints: endpoints, instance: url},
		restAuditPolicy:            &restObjMonitoringV1AuditPolicy{endpoints: endpoints, instance: url},
	}
}

func (a *crudRestClientMonitoringV1) EventPolicy() monitoring.MonitoringV1EventPolicyInterface {
	return a.restEventPolicy
}

func (a *crudRestClientMonitoringV1) FwlogPolicy() monitoring.MonitoringV1FwlogPolicyInterface {
	return a.restFwlogPolicy
}

func (a *crudRestClientMonitoringV1) FlowExportPolicy() monitoring.MonitoringV1FlowExportPolicyInterface {
	return a.restFlowExportPolicy
}

func (a *crudRestClientMonitoringV1) Alert() monitoring.MonitoringV1AlertInterface {
	return a.restAlert
}

func (a *crudRestClientMonitoringV1) AlertPolicy() monitoring.MonitoringV1AlertPolicyInterface {
	return a.restAlertPolicy
}

func (a *crudRestClientMonitoringV1) AlertDestination() monitoring.MonitoringV1AlertDestinationInterface {
	return a.restAlertDestination
}

func (a *crudRestClientMonitoringV1) MirrorSession() monitoring.MonitoringV1MirrorSessionInterface {
	return a.restMirrorSession
}

func (a *crudRestClientMonitoringV1) TroubleshootingSession() monitoring.MonitoringV1TroubleshootingSessionInterface {
	return a.restTroubleshootingSession
}

func (a *crudRestClientMonitoringV1) TechSupportRequest() monitoring.MonitoringV1TechSupportRequestInterface {
	return a.restTechSupportRequest
}

func (a *crudRestClientMonitoringV1) ArchiveRequest() monitoring.MonitoringV1ArchiveRequestInterface {
	return a.restArchiveRequest
}

func (a *crudRestClientMonitoringV1) AuditPolicy() monitoring.MonitoringV1AuditPolicyInterface {
	return a.restAuditPolicy
}

func (a *crudRestClientMonitoringV1) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	return nil, errors.New("method unimplemented")
}
