// Code generated by protoc-gen-grpc-pensando DO NOT EDIT.

package grpcclient

import (
	"context"
	"errors"
	oldlog "log"

	"github.com/go-kit/kit/endpoint"
	grpctransport "github.com/go-kit/kit/transport/grpc"
	"google.golang.org/grpc"

	api "github.com/pensando/sw/api"
	monitoring "github.com/pensando/sw/api/generated/monitoring"
	listerwatcher "github.com/pensando/sw/api/listerwatcher"
	apiserver "github.com/pensando/sw/venice/apiserver"
	"github.com/pensando/sw/venice/utils/kvstore"
	"github.com/pensando/sw/venice/utils/log"
	"github.com/pensando/sw/venice/utils/trace"
)

// Dummy vars to suppress import errors
var _ api.TypeMeta
var _ listerwatcher.WatcherClient
var _ kvstore.Interface

// NewMirrorSessionV1 sets up a new client for MirrorSessionV1
func NewMirrorSessionV1(conn *grpc.ClientConn, logger log.Logger) monitoring.ServiceMirrorSessionV1Client {

	var lAutoAddMirrorSessionEndpoint endpoint.Endpoint
	{
		lAutoAddMirrorSessionEndpoint = grpctransport.NewClient(
			conn,
			"monitoring.MirrorSessionV1",
			"AutoAddMirrorSession",
			monitoring.EncodeGrpcReqMirrorSession,
			monitoring.DecodeGrpcRespMirrorSession,
			&monitoring.MirrorSession{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoAddMirrorSessionEndpoint = trace.ClientEndPoint("MirrorSessionV1:AutoAddMirrorSession")(lAutoAddMirrorSessionEndpoint)
	}
	var lAutoDeleteMirrorSessionEndpoint endpoint.Endpoint
	{
		lAutoDeleteMirrorSessionEndpoint = grpctransport.NewClient(
			conn,
			"monitoring.MirrorSessionV1",
			"AutoDeleteMirrorSession",
			monitoring.EncodeGrpcReqMirrorSession,
			monitoring.DecodeGrpcRespMirrorSession,
			&monitoring.MirrorSession{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoDeleteMirrorSessionEndpoint = trace.ClientEndPoint("MirrorSessionV1:AutoDeleteMirrorSession")(lAutoDeleteMirrorSessionEndpoint)
	}
	var lAutoGetMirrorSessionEndpoint endpoint.Endpoint
	{
		lAutoGetMirrorSessionEndpoint = grpctransport.NewClient(
			conn,
			"monitoring.MirrorSessionV1",
			"AutoGetMirrorSession",
			monitoring.EncodeGrpcReqMirrorSession,
			monitoring.DecodeGrpcRespMirrorSession,
			&monitoring.MirrorSession{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoGetMirrorSessionEndpoint = trace.ClientEndPoint("MirrorSessionV1:AutoGetMirrorSession")(lAutoGetMirrorSessionEndpoint)
	}
	var lAutoListMirrorSessionEndpoint endpoint.Endpoint
	{
		lAutoListMirrorSessionEndpoint = grpctransport.NewClient(
			conn,
			"monitoring.MirrorSessionV1",
			"AutoListMirrorSession",
			monitoring.EncodeGrpcReqListWatchOptions,
			monitoring.DecodeGrpcRespMirrorSessionList,
			&monitoring.MirrorSessionList{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoListMirrorSessionEndpoint = trace.ClientEndPoint("MirrorSessionV1:AutoListMirrorSession")(lAutoListMirrorSessionEndpoint)
	}
	var lAutoUpdateMirrorSessionEndpoint endpoint.Endpoint
	{
		lAutoUpdateMirrorSessionEndpoint = grpctransport.NewClient(
			conn,
			"monitoring.MirrorSessionV1",
			"AutoUpdateMirrorSession",
			monitoring.EncodeGrpcReqMirrorSession,
			monitoring.DecodeGrpcRespMirrorSession,
			&monitoring.MirrorSession{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoUpdateMirrorSessionEndpoint = trace.ClientEndPoint("MirrorSessionV1:AutoUpdateMirrorSession")(lAutoUpdateMirrorSessionEndpoint)
	}
	return monitoring.EndpointsMirrorSessionV1Client{
		Client: monitoring.NewMirrorSessionV1Client(conn),

		AutoAddMirrorSessionEndpoint:    lAutoAddMirrorSessionEndpoint,
		AutoDeleteMirrorSessionEndpoint: lAutoDeleteMirrorSessionEndpoint,
		AutoGetMirrorSessionEndpoint:    lAutoGetMirrorSessionEndpoint,
		AutoListMirrorSessionEndpoint:   lAutoListMirrorSessionEndpoint,
		AutoUpdateMirrorSessionEndpoint: lAutoUpdateMirrorSessionEndpoint,
	}
}

// NewMirrorSessionV1Backend creates an instrumented client with middleware
func NewMirrorSessionV1Backend(conn *grpc.ClientConn, logger log.Logger) monitoring.ServiceMirrorSessionV1Client {
	cl := NewMirrorSessionV1(conn, logger)
	cl = monitoring.LoggingMirrorSessionV1MiddlewareClient(logger)(cl)
	return cl
}

type grpcObjMirrorSessionV1MirrorSession struct {
	logger log.Logger
	client monitoring.ServiceMirrorSessionV1Client
}

func (a *grpcObjMirrorSessionV1MirrorSession) Create(ctx context.Context, in *monitoring.MirrorSession) (*monitoring.MirrorSession, error) {
	a.logger.DebugLog("msg", "received call", "object", "MirrorSession", "oper", "create")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoAddMirrorSession(nctx, in)
}

func (a *grpcObjMirrorSessionV1MirrorSession) Update(ctx context.Context, in *monitoring.MirrorSession) (*monitoring.MirrorSession, error) {
	a.logger.DebugLog("msg", "received call", "object", "MirrorSession", "oper", "update")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoUpdateMirrorSession(nctx, in)
}

func (a *grpcObjMirrorSessionV1MirrorSession) Get(ctx context.Context, objMeta *api.ObjectMeta) (*monitoring.MirrorSession, error) {
	a.logger.DebugLog("msg", "received call", "object", "MirrorSession", "oper", "get")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := monitoring.MirrorSession{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoGetMirrorSession(nctx, &in)
}

func (a *grpcObjMirrorSessionV1MirrorSession) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*monitoring.MirrorSession, error) {
	a.logger.DebugLog("msg", "received call", "object", "MirrorSession", "oper", "delete")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := monitoring.MirrorSession{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoDeleteMirrorSession(nctx, &in)
}

func (a *grpcObjMirrorSessionV1MirrorSession) List(ctx context.Context, options *api.ListWatchOptions) ([]*monitoring.MirrorSession, error) {
	a.logger.DebugLog("msg", "received call", "object", "MirrorSession", "oper", "list")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	r, err := a.client.AutoListMirrorSession(nctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *grpcObjMirrorSessionV1MirrorSession) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	a.logger.DebugLog("msg", "received call", "object", "MirrorSession", "oper", "WatchOper")
	nctx := addVersion(ctx, "v1")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	stream, err := a.client.AutoWatchMirrorSession(nctx, options)
	if err != nil {
		return nil, err
	}
	wstream := stream.(monitoring.MirrorSessionV1_AutoWatchMirrorSessionClient)
	bridgefn := func(lw *listerwatcher.WatcherClient) {
		for {
			r, err := wstream.Recv()
			if err != nil {
				a.logger.ErrorLog("msg", "error on receive", "error", err)
				close(lw.OutCh)
				return
			}
			ev := kvstore.WatchEvent{
				Type:   kvstore.WatchEventType(r.Type),
				Object: r.Object,
			}
			select {
			case lw.OutCh <- &ev:
			case <-wstream.Context().Done():
				close(lw.OutCh)
				return
			}
		}
	}
	lw := listerwatcher.NewWatcherClient(wstream, bridgefn)
	lw.Run()
	return lw, nil
}

func (a *grpcObjMirrorSessionV1MirrorSession) Allowed(oper apiserver.APIOperType) bool {
	return true
}

type restObjMirrorSessionV1MirrorSession struct {
	endpoints monitoring.EndpointsMirrorSessionV1RestClient
	instance  string
}

func (a *restObjMirrorSessionV1MirrorSession) Create(ctx context.Context, in *monitoring.MirrorSession) (*monitoring.MirrorSession, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoAddMirrorSession(ctx, in)
}

func (a *restObjMirrorSessionV1MirrorSession) Update(ctx context.Context, in *monitoring.MirrorSession) (*monitoring.MirrorSession, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoUpdateMirrorSession(ctx, in)
}

func (a *restObjMirrorSessionV1MirrorSession) Get(ctx context.Context, objMeta *api.ObjectMeta) (*monitoring.MirrorSession, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := monitoring.MirrorSession{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoGetMirrorSession(ctx, &in)
}

func (a *restObjMirrorSessionV1MirrorSession) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*monitoring.MirrorSession, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := monitoring.MirrorSession{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoDeleteMirrorSession(ctx, &in)
}

func (a *restObjMirrorSessionV1MirrorSession) List(ctx context.Context, options *api.ListWatchOptions) ([]*monitoring.MirrorSession, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}
	r, err := a.endpoints.AutoListMirrorSession(ctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *restObjMirrorSessionV1MirrorSession) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	return nil, errors.New("not allowed")
}

func (a *restObjMirrorSessionV1MirrorSession) Allowed(oper apiserver.APIOperType) bool {
	switch oper {
	case apiserver.CreateOper:
		return true
	case apiserver.UpdateOper:
		return true
	case apiserver.GetOper:
		return true
	case apiserver.DeleteOper:
		return true
	case apiserver.ListOper:
		return true
	case apiserver.WatchOper:
		return false
	default:
		return false
	}
}

type crudClientMirrorSessionV1 struct {
	grpcMirrorSession monitoring.MirrorSessionV1MirrorSessionInterface
}

// NewGrpcCrudClientMirrorSessionV1 creates a GRPC client for the service
func NewGrpcCrudClientMirrorSessionV1(conn *grpc.ClientConn, logger log.Logger) monitoring.MirrorSessionV1Interface {
	client := NewMirrorSessionV1Backend(conn, logger)
	return &crudClientMirrorSessionV1{

		grpcMirrorSession: &grpcObjMirrorSessionV1MirrorSession{client: client, logger: logger},
	}
}

func (a *crudClientMirrorSessionV1) MirrorSession() monitoring.MirrorSessionV1MirrorSessionInterface {
	return a.grpcMirrorSession
}

type crudRestClientMirrorSessionV1 struct {
	restMirrorSession monitoring.MirrorSessionV1MirrorSessionInterface
}

// NewRestCrudClientMirrorSessionV1 creates a REST client for the service.
func NewRestCrudClientMirrorSessionV1(url string) monitoring.MirrorSessionV1Interface {
	endpoints, err := monitoring.MakeMirrorSessionV1RestClientEndpoints(url)
	if err != nil {
		oldlog.Fatal("failed to create client")
	}
	return &crudRestClientMirrorSessionV1{

		restMirrorSession: &restObjMirrorSessionV1MirrorSession{endpoints: endpoints, instance: url},
	}
}

func (a *crudRestClientMirrorSessionV1) MirrorSession() monitoring.MirrorSessionV1MirrorSessionInterface {
	return a.restMirrorSession
}
