// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: troubleshooting.proto

package monitoring

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/pensando/grpc-gateway/third_party/googleapis/google/api"
import _ "github.com/pensando/sw/venice/utils/apigen/annotations"
import _ "github.com/gogo/protobuf/gogoproto"
import api "github.com/pensando/sw/api"
import events "github.com/pensando/sw/api/generated/events"
import security "github.com/pensando/sw/api/generated/security"

import encoding_binary "encoding/binary"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

//
type TroubleshootingSessionState int32

const (
	// ui-hint: Running
	TroubleshootingSessionState_TS_RUNNING TroubleshootingSessionState = 0
	// ui-hint: Stopped
	TroubleshootingSessionState_TS_STOPPED TroubleshootingSessionState = 1
	// ui-hint: Scheduled
	TroubleshootingSessionState_TS_SCHEDULED TroubleshootingSessionState = 2
)

var TroubleshootingSessionState_name = map[int32]string{
	0: "TS_RUNNING",
	1: "TS_STOPPED",
	2: "TS_SCHEDULED",
}
var TroubleshootingSessionState_value = map[string]int32{
	"TS_RUNNING":   0,
	"TS_STOPPED":   1,
	"TS_SCHEDULED": 2,
}

func (TroubleshootingSessionState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorTroubleshooting, []int{0}
}

//
type PingPktStats struct {
	//
	NoResp bool `protobuf:"varint,1,opt,name=NoResp,json=no-response,inline,proto3" json:"no-response,inline"`
	//
	RttMs uint32 `protobuf:"varint,2,opt,name=RttMs,json=round-trip-time,inline,proto3" json:"round-trip-time,inline"`
}

func (m *PingPktStats) Reset()                    { *m = PingPktStats{} }
func (m *PingPktStats) String() string            { return proto.CompactTextString(m) }
func (*PingPktStats) ProtoMessage()               {}
func (*PingPktStats) Descriptor() ([]byte, []int) { return fileDescriptorTroubleshooting, []int{0} }

func (m *PingPktStats) GetNoResp() bool {
	if m != nil {
		return m.NoResp
	}
	return false
}

func (m *PingPktStats) GetRttMs() uint32 {
	if m != nil {
		return m.RttMs
	}
	return 0
}

//
type PingStats struct {
	//
	SmartNIC string `protobuf:"bytes,1,opt,name=SmartNIC,json=smart-nic,inline,proto3" json:"smart-nic,inline"`
	//
	PacketsTx uint32 `protobuf:"varint,2,opt,name=PacketsTx,json=packets-sent,inline,proto3" json:"packets-sent,inline"`
	//
	PacketsRx uint32 `protobuf:"varint,3,opt,name=PacketsRx,json=packets-received,inline,proto3" json:"packets-received,inline"`
	//
	PacketLoss uint32 `protobuf:"varint,4,opt,name=PacketLoss,json=packet-loss,inline,proto3" json:"packet-loss,inline"`
	//
	MinRttMs float32 `protobuf:"fixed32,5,opt,name=MinRttMs,json=min-round-trip-time,inline,proto3" json:"min-round-trip-time,inline"`
	//
	MaxRttMs float32 `protobuf:"fixed32,6,opt,name=MaxRttMs,json=max-round-trip-time,inline,proto3" json:"max-round-trip-time,inline"`
	//
	AvgRttMs float32 `protobuf:"fixed32,7,opt,name=AvgRttMs,json=avg-round-trip-time,inline,proto3" json:"avg-round-trip-time,inline"`
	// Per packet stats
	PktStats []*PingPktStats `protobuf:"bytes,8,rep,name=PktStats,json=per-packet-stats,inline" json:"per-packet-stats,inline"`
}

func (m *PingStats) Reset()                    { *m = PingStats{} }
func (m *PingStats) String() string            { return proto.CompactTextString(m) }
func (*PingStats) ProtoMessage()               {}
func (*PingStats) Descriptor() ([]byte, []int) { return fileDescriptorTroubleshooting, []int{1} }

func (m *PingStats) GetSmartNIC() string {
	if m != nil {
		return m.SmartNIC
	}
	return ""
}

func (m *PingStats) GetPacketsTx() uint32 {
	if m != nil {
		return m.PacketsTx
	}
	return 0
}

func (m *PingStats) GetPacketsRx() uint32 {
	if m != nil {
		return m.PacketsRx
	}
	return 0
}

func (m *PingStats) GetPacketLoss() uint32 {
	if m != nil {
		return m.PacketLoss
	}
	return 0
}

func (m *PingStats) GetMinRttMs() float32 {
	if m != nil {
		return m.MinRttMs
	}
	return 0
}

func (m *PingStats) GetMaxRttMs() float32 {
	if m != nil {
		return m.MaxRttMs
	}
	return 0
}

func (m *PingStats) GetAvgRttMs() float32 {
	if m != nil {
		return m.AvgRttMs
	}
	return 0
}

func (m *PingStats) GetPktStats() []*PingPktStats {
	if m != nil {
		return m.PktStats
	}
	return nil
}

//
type TimeWindow struct {
	// Start/Stop Time - when start time is not specified, it implies start NOW.
	StartTime *api.Timestamp `protobuf:"bytes,1,opt,name=StartTime,json=start-time,omitempty" json:"start-time,omitempty"`
	// Stop time - when not specified, default will be used
	StopTime *api.Timestamp `protobuf:"bytes,2,opt,name=StopTime,json=stop-time,omitempty" json:"stop-time,omitempty"`
}

func (m *TimeWindow) Reset()                    { *m = TimeWindow{} }
func (m *TimeWindow) String() string            { return proto.CompactTextString(m) }
func (*TimeWindow) ProtoMessage()               {}
func (*TimeWindow) Descriptor() ([]byte, []int) { return fileDescriptorTroubleshooting, []int{2} }

func (m *TimeWindow) GetStartTime() *api.Timestamp {
	if m != nil {
		return m.StartTime
	}
	return nil
}

func (m *TimeWindow) GetStopTime() *api.Timestamp {
	if m != nil {
		return m.StopTime
	}
	return nil
}

//
type TraceRouteInfo struct {
}

func (m *TraceRouteInfo) Reset()                    { *m = TraceRouteInfo{} }
func (m *TraceRouteInfo) String() string            { return proto.CompactTextString(m) }
func (*TraceRouteInfo) ProtoMessage()               {}
func (*TraceRouteInfo) Descriptor() ([]byte, []int) { return fileDescriptorTroubleshooting, []int{3} }

// ----- Troubleshooting session object
type TroubleshootingSession struct {
	//
	api.TypeMeta `protobuf:"bytes,1,opt,name=T,json=,inline,embedded=T" json:",inline"`
	//
	api.ObjectMeta `protobuf:"bytes,2,opt,name=O,json=meta,omitempty,embedded=O" json:"meta,omitempty"`
	//
	Spec TroubleshootingSessionSpec `protobuf:"bytes,3,opt,name=Spec,json=spec,inline" json:"spec,inline"`
	//
	Status TroubleshootingSessionStatus `protobuf:"bytes,4,opt,name=Status,json=status,omitempty" json:"status,omitempty"`
}

func (m *TroubleshootingSession) Reset()         { *m = TroubleshootingSession{} }
func (m *TroubleshootingSession) String() string { return proto.CompactTextString(m) }
func (*TroubleshootingSession) ProtoMessage()    {}
func (*TroubleshootingSession) Descriptor() ([]byte, []int) {
	return fileDescriptorTroubleshooting, []int{4}
}

func (m *TroubleshootingSession) GetSpec() TroubleshootingSessionSpec {
	if m != nil {
		return m.Spec
	}
	return TroubleshootingSessionSpec{}
}

func (m *TroubleshootingSession) GetStatus() TroubleshootingSessionStatus {
	if m != nil {
		return m.Status
	}
	return TroubleshootingSessionStatus{}
}

// ----- Troubleshooting Session Spec
type TroubleshootingSessionSpec struct {
	//
	FlowSelector MatchRule `protobuf:"bytes,1,opt,name=FlowSelector,json=flow-selector,inline" json:"flow-selector,inline"`
	//
	TimeWindow *TimeWindow `protobuf:"bytes,2,opt,name=TimeWindow,json=time-window,omitempty" json:"time-window,omitempty"`
	//
	RepeatEvery string `protobuf:"bytes,3,opt,name=RepeatEvery,json=repeat-every,omitempty,proto3" json:"repeat-every,omitempty"`
	// If packet capture is enabled, a mirror-session will be internally created
	EnableMirroring bool `protobuf:"varint,4,opt,name=EnableMirroring,json=enable-mirroring,omitempty,proto3" json:"enable-mirroring,omitempty"`
}

func (m *TroubleshootingSessionSpec) Reset()         { *m = TroubleshootingSessionSpec{} }
func (m *TroubleshootingSessionSpec) String() string { return proto.CompactTextString(m) }
func (*TroubleshootingSessionSpec) ProtoMessage()    {}
func (*TroubleshootingSessionSpec) Descriptor() ([]byte, []int) {
	return fileDescriptorTroubleshooting, []int{5}
}

func (m *TroubleshootingSessionSpec) GetFlowSelector() MatchRule {
	if m != nil {
		return m.FlowSelector
	}
	return MatchRule{}
}

func (m *TroubleshootingSessionSpec) GetTimeWindow() *TimeWindow {
	if m != nil {
		return m.TimeWindow
	}
	return nil
}

func (m *TroubleshootingSessionSpec) GetRepeatEvery() string {
	if m != nil {
		return m.RepeatEvery
	}
	return ""
}

func (m *TroubleshootingSessionSpec) GetEnableMirroring() bool {
	if m != nil {
		return m.EnableMirroring
	}
	return false
}

// ----- Troubleshooting Session Status
type TroubleshootingSessionStatus struct {
	//
	State string `protobuf:"bytes,1,opt,name=State,json=state,inline,proto3" json:"state,inline"`
	// report is generated each time troubleshooting session is activated i.e time-window
	TsResults []*TsResult `protobuf:"bytes,2,rep,name=TsResults,json=troubleshooting-results,inline" json:"troubleshooting-results,inline"`
}

func (m *TroubleshootingSessionStatus) Reset()         { *m = TroubleshootingSessionStatus{} }
func (m *TroubleshootingSessionStatus) String() string { return proto.CompactTextString(m) }
func (*TroubleshootingSessionStatus) ProtoMessage()    {}
func (*TroubleshootingSessionStatus) Descriptor() ([]byte, []int) {
	return fileDescriptorTroubleshooting, []int{6}
}

func (m *TroubleshootingSessionStatus) GetState() string {
	if m != nil {
		return m.State
	}
	return ""
}

func (m *TroubleshootingSessionStatus) GetTsResults() []*TsResult {
	if m != nil {
		return m.TsResults
	}
	return nil
}

//
type TsAuditTrail struct {
}

func (m *TsAuditTrail) Reset()                    { *m = TsAuditTrail{} }
func (m *TsAuditTrail) String() string            { return proto.CompactTextString(m) }
func (*TsAuditTrail) ProtoMessage()               {}
func (*TsAuditTrail) Descriptor() ([]byte, []int) { return fileDescriptorTroubleshooting, []int{7} }

//
type TsFlowCounters struct {
}

func (m *TsFlowCounters) Reset()                    { *m = TsFlowCounters{} }
func (m *TsFlowCounters) String() string            { return proto.CompactTextString(m) }
func (*TsFlowCounters) ProtoMessage()               {}
func (*TsFlowCounters) Descriptor() ([]byte, []int) { return fileDescriptorTroubleshooting, []int{8} }

//
type TsFlowLogs struct {
}

func (m *TsFlowLogs) Reset()                    { *m = TsFlowLogs{} }
func (m *TsFlowLogs) String() string            { return proto.CompactTextString(m) }
func (*TsFlowLogs) ProtoMessage()               {}
func (*TsFlowLogs) Descriptor() ([]byte, []int) { return fileDescriptorTroubleshooting, []int{9} }

// ----- Troubleshooting Report
// Following information is available in TS report
type TsPolicy struct {
	// Policy and associated rules that affect the flow
	// Parent policy
	Sgpolicy *api.ObjectRef `protobuf:"bytes,1,opt,name=Sgpolicy,json=sg-policy,omitempty" json:"sg-policy,omitempty"`
	// InRules affecting TsFlow
	InRules []*security.SGRule `protobuf:"bytes,2,rep,name=InRules,json=in-rules,omitempty" json:"in-rules,omitempty"`
	// OutRules affecting TsFlow
	OutRules []*security.SGRule `protobuf:"bytes,3,rep,name=OutRules,json=out-rules,omitempty" json:"out-rules,omitempty"`
}

func (m *TsPolicy) Reset()                    { *m = TsPolicy{} }
func (m *TsPolicy) String() string            { return proto.CompactTextString(m) }
func (*TsPolicy) ProtoMessage()               {}
func (*TsPolicy) Descriptor() ([]byte, []int) { return fileDescriptorTroubleshooting, []int{10} }

func (m *TsPolicy) GetSgpolicy() *api.ObjectRef {
	if m != nil {
		return m.Sgpolicy
	}
	return nil
}

func (m *TsPolicy) GetInRules() []*security.SGRule {
	if m != nil {
		return m.InRules
	}
	return nil
}

func (m *TsPolicy) GetOutRules() []*security.SGRule {
	if m != nil {
		return m.OutRules
	}
	return nil
}

// Format the information stored at the objectstore URL into a single report
// - Events and Alerts from src/dst NICs
// - AuditTrail of actions that affect the TS flow
// - Packet stats (delta in the given time window)
// - flow logs and counter (delta in the given time window)
type TsReport struct {
	//
	TimeWindow TimeWindow `protobuf:"bytes,1,opt,name=TimeWindow,json=time-window,omitempty" json:"time-window,omitempty"`
	//
	ReportSummary string `protobuf:"bytes,2,opt,name=ReportSummary,json=report-summary,inline,proto3" json:"report-summary,inline"`
	//
	Events []events.Event `protobuf:"bytes,3,rep,name=Events,json=events,omitempty" json:"events,omitempty"`
	//
	Alerts []AlertStatus `protobuf:"bytes,4,rep,name=Alerts,json=alerts,omitempty" json:"alerts,omitempty"`
	//
	Stats *TsStats `protobuf:"bytes,5,opt,name=Stats,json=stats,omitempty" json:"stats,omitempty"`
	//
	FlowCounters *TsFlowCounters `protobuf:"bytes,6,opt,name=FlowCounters,json=flow-counters,omitempty" json:"flow-counters,omitempty"`
	//
	FlowLogs *TsFlowLogs `protobuf:"bytes,7,opt,name=FlowLogs,json=flow-logs,omitempty" json:"flow-logs,omitempty"`
	//
	AuditTrail *TsAuditTrail `protobuf:"bytes,8,opt,name=AuditTrail,json=audit-trail,omitempty" json:"audit-trail,omitempty"`
	//
	Policies []TsPolicy `protobuf:"bytes,9,rep,name=Policies,json=policies,omitempty" json:"policies,omitempty"`
	// MirrorSession internally created if client enabled mirroring on trouble shooting session
	MirrorStatus *MirrorSessionStatus `protobuf:"bytes,10,opt,name=MirrorStatus,json=mirror-session-status,inline" json:"mirror-session-status,inline"`
	// Tools like Ping, Traceroute will be used for trouble shooting. Results obtained from these tools are preserved in the status
	PingStats *PingStats `protobuf:"bytes,11,opt,name=PingStats,json=ping-stats,inline" json:"ping-stats,inline"`
	//
	TracedRouteInfo *TraceRouteInfo `protobuf:"bytes,12,opt,name=TracedRouteInfo,json=traced-route-info,inline" json:"traced-route-info,inline"`
}

func (m *TsReport) Reset()                    { *m = TsReport{} }
func (m *TsReport) String() string            { return proto.CompactTextString(m) }
func (*TsReport) ProtoMessage()               {}
func (*TsReport) Descriptor() ([]byte, []int) { return fileDescriptorTroubleshooting, []int{11} }

func (m *TsReport) GetTimeWindow() TimeWindow {
	if m != nil {
		return m.TimeWindow
	}
	return TimeWindow{}
}

func (m *TsReport) GetReportSummary() string {
	if m != nil {
		return m.ReportSummary
	}
	return ""
}

func (m *TsReport) GetEvents() []events.Event {
	if m != nil {
		return m.Events
	}
	return nil
}

func (m *TsReport) GetAlerts() []AlertStatus {
	if m != nil {
		return m.Alerts
	}
	return nil
}

func (m *TsReport) GetStats() *TsStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

func (m *TsReport) GetFlowCounters() *TsFlowCounters {
	if m != nil {
		return m.FlowCounters
	}
	return nil
}

func (m *TsReport) GetFlowLogs() *TsFlowLogs {
	if m != nil {
		return m.FlowLogs
	}
	return nil
}

func (m *TsReport) GetAuditTrail() *TsAuditTrail {
	if m != nil {
		return m.AuditTrail
	}
	return nil
}

func (m *TsReport) GetPolicies() []TsPolicy {
	if m != nil {
		return m.Policies
	}
	return nil
}

func (m *TsReport) GetMirrorStatus() *MirrorSessionStatus {
	if m != nil {
		return m.MirrorStatus
	}
	return nil
}

func (m *TsReport) GetPingStats() *PingStats {
	if m != nil {
		return m.PingStats
	}
	return nil
}

func (m *TsReport) GetTracedRouteInfo() *TraceRouteInfo {
	if m != nil {
		return m.TracedRouteInfo
	}
	return nil
}

//
type TsResult struct {
	// time window for which the information was collected
	TimeWindow TimeWindow `protobuf:"bytes,1,opt,name=TimeWindow,json=time-window,inline" json:"time-window,inline"`
	//
	ReportURL string `protobuf:"bytes,2,opt,name=ReportURL,json=report-url,inline,proto3" json:"report-url,inline"`
}

func (m *TsResult) Reset()                    { *m = TsResult{} }
func (m *TsResult) String() string            { return proto.CompactTextString(m) }
func (*TsResult) ProtoMessage()               {}
func (*TsResult) Descriptor() ([]byte, []int) { return fileDescriptorTroubleshooting, []int{12} }

func (m *TsResult) GetTimeWindow() TimeWindow {
	if m != nil {
		return m.TimeWindow
	}
	return TimeWindow{}
}

func (m *TsResult) GetReportURL() string {
	if m != nil {
		return m.ReportURL
	}
	return ""
}

//
type TsStats struct {
}

func (m *TsStats) Reset()                    { *m = TsStats{} }
func (m *TsStats) String() string            { return proto.CompactTextString(m) }
func (*TsStats) ProtoMessage()               {}
func (*TsStats) Descriptor() ([]byte, []int) { return fileDescriptorTroubleshooting, []int{13} }

func init() {
	proto.RegisterType((*PingPktStats)(nil), "monitoring.PingPktStats")
	proto.RegisterType((*PingStats)(nil), "monitoring.PingStats")
	proto.RegisterType((*TimeWindow)(nil), "monitoring.TimeWindow")
	proto.RegisterType((*TraceRouteInfo)(nil), "monitoring.TraceRouteInfo")
	proto.RegisterType((*TroubleshootingSession)(nil), "monitoring.TroubleshootingSession")
	proto.RegisterType((*TroubleshootingSessionSpec)(nil), "monitoring.TroubleshootingSessionSpec")
	proto.RegisterType((*TroubleshootingSessionStatus)(nil), "monitoring.TroubleshootingSessionStatus")
	proto.RegisterType((*TsAuditTrail)(nil), "monitoring.TsAuditTrail")
	proto.RegisterType((*TsFlowCounters)(nil), "monitoring.TsFlowCounters")
	proto.RegisterType((*TsFlowLogs)(nil), "monitoring.TsFlowLogs")
	proto.RegisterType((*TsPolicy)(nil), "monitoring.TsPolicy")
	proto.RegisterType((*TsReport)(nil), "monitoring.TsReport")
	proto.RegisterType((*TsResult)(nil), "monitoring.TsResult")
	proto.RegisterType((*TsStats)(nil), "monitoring.TsStats")
	proto.RegisterEnum("monitoring.TroubleshootingSessionState", TroubleshootingSessionState_name, TroubleshootingSessionState_value)
}
func (m *PingPktStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PingPktStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.NoResp {
		dAtA[i] = 0x8
		i++
		if m.NoResp {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.RttMs != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTroubleshooting(dAtA, i, uint64(m.RttMs))
	}
	return i, nil
}

func (m *PingStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PingStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.SmartNIC) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTroubleshooting(dAtA, i, uint64(len(m.SmartNIC)))
		i += copy(dAtA[i:], m.SmartNIC)
	}
	if m.PacketsTx != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTroubleshooting(dAtA, i, uint64(m.PacketsTx))
	}
	if m.PacketsRx != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTroubleshooting(dAtA, i, uint64(m.PacketsRx))
	}
	if m.PacketLoss != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintTroubleshooting(dAtA, i, uint64(m.PacketLoss))
	}
	if m.MinRttMs != 0 {
		dAtA[i] = 0x2d
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.MinRttMs))))
		i += 4
	}
	if m.MaxRttMs != 0 {
		dAtA[i] = 0x35
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.MaxRttMs))))
		i += 4
	}
	if m.AvgRttMs != 0 {
		dAtA[i] = 0x3d
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.AvgRttMs))))
		i += 4
	}
	if len(m.PktStats) > 0 {
		for _, msg := range m.PktStats {
			dAtA[i] = 0x42
			i++
			i = encodeVarintTroubleshooting(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *TimeWindow) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TimeWindow) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.StartTime != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTroubleshooting(dAtA, i, uint64(m.StartTime.Size()))
		n1, err := m.StartTime.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.StopTime != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTroubleshooting(dAtA, i, uint64(m.StopTime.Size()))
		n2, err := m.StopTime.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}

func (m *TraceRouteInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TraceRouteInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *TroubleshootingSession) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TroubleshootingSession) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintTroubleshooting(dAtA, i, uint64(m.TypeMeta.Size()))
	n3, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n3
	dAtA[i] = 0x12
	i++
	i = encodeVarintTroubleshooting(dAtA, i, uint64(m.ObjectMeta.Size()))
	n4, err := m.ObjectMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n4
	dAtA[i] = 0x1a
	i++
	i = encodeVarintTroubleshooting(dAtA, i, uint64(m.Spec.Size()))
	n5, err := m.Spec.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n5
	dAtA[i] = 0x22
	i++
	i = encodeVarintTroubleshooting(dAtA, i, uint64(m.Status.Size()))
	n6, err := m.Status.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n6
	return i, nil
}

func (m *TroubleshootingSessionSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TroubleshootingSessionSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintTroubleshooting(dAtA, i, uint64(m.FlowSelector.Size()))
	n7, err := m.FlowSelector.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n7
	if m.TimeWindow != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTroubleshooting(dAtA, i, uint64(m.TimeWindow.Size()))
		n8, err := m.TimeWindow.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if len(m.RepeatEvery) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTroubleshooting(dAtA, i, uint64(len(m.RepeatEvery)))
		i += copy(dAtA[i:], m.RepeatEvery)
	}
	if m.EnableMirroring {
		dAtA[i] = 0x20
		i++
		if m.EnableMirroring {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *TroubleshootingSessionStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TroubleshootingSessionStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.State) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTroubleshooting(dAtA, i, uint64(len(m.State)))
		i += copy(dAtA[i:], m.State)
	}
	if len(m.TsResults) > 0 {
		for _, msg := range m.TsResults {
			dAtA[i] = 0x12
			i++
			i = encodeVarintTroubleshooting(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *TsAuditTrail) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TsAuditTrail) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *TsFlowCounters) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TsFlowCounters) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *TsFlowLogs) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TsFlowLogs) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *TsPolicy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TsPolicy) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Sgpolicy != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTroubleshooting(dAtA, i, uint64(m.Sgpolicy.Size()))
		n9, err := m.Sgpolicy.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if len(m.InRules) > 0 {
		for _, msg := range m.InRules {
			dAtA[i] = 0x12
			i++
			i = encodeVarintTroubleshooting(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.OutRules) > 0 {
		for _, msg := range m.OutRules {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintTroubleshooting(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *TsReport) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TsReport) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintTroubleshooting(dAtA, i, uint64(m.TimeWindow.Size()))
	n10, err := m.TimeWindow.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n10
	if len(m.ReportSummary) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTroubleshooting(dAtA, i, uint64(len(m.ReportSummary)))
		i += copy(dAtA[i:], m.ReportSummary)
	}
	if len(m.Events) > 0 {
		for _, msg := range m.Events {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintTroubleshooting(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Alerts) > 0 {
		for _, msg := range m.Alerts {
			dAtA[i] = 0x22
			i++
			i = encodeVarintTroubleshooting(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Stats != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTroubleshooting(dAtA, i, uint64(m.Stats.Size()))
		n11, err := m.Stats.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if m.FlowCounters != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintTroubleshooting(dAtA, i, uint64(m.FlowCounters.Size()))
		n12, err := m.FlowCounters.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if m.FlowLogs != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintTroubleshooting(dAtA, i, uint64(m.FlowLogs.Size()))
		n13, err := m.FlowLogs.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if m.AuditTrail != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintTroubleshooting(dAtA, i, uint64(m.AuditTrail.Size()))
		n14, err := m.AuditTrail.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	if len(m.Policies) > 0 {
		for _, msg := range m.Policies {
			dAtA[i] = 0x4a
			i++
			i = encodeVarintTroubleshooting(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.MirrorStatus != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintTroubleshooting(dAtA, i, uint64(m.MirrorStatus.Size()))
		n15, err := m.MirrorStatus.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	if m.PingStats != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintTroubleshooting(dAtA, i, uint64(m.PingStats.Size()))
		n16, err := m.PingStats.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	if m.TracedRouteInfo != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintTroubleshooting(dAtA, i, uint64(m.TracedRouteInfo.Size()))
		n17, err := m.TracedRouteInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	return i, nil
}

func (m *TsResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TsResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintTroubleshooting(dAtA, i, uint64(m.TimeWindow.Size()))
	n18, err := m.TimeWindow.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n18
	if len(m.ReportURL) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTroubleshooting(dAtA, i, uint64(len(m.ReportURL)))
		i += copy(dAtA[i:], m.ReportURL)
	}
	return i, nil
}

func (m *TsStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TsStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func encodeVarintTroubleshooting(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *PingPktStats) Size() (n int) {
	var l int
	_ = l
	if m.NoResp {
		n += 2
	}
	if m.RttMs != 0 {
		n += 1 + sovTroubleshooting(uint64(m.RttMs))
	}
	return n
}

func (m *PingStats) Size() (n int) {
	var l int
	_ = l
	l = len(m.SmartNIC)
	if l > 0 {
		n += 1 + l + sovTroubleshooting(uint64(l))
	}
	if m.PacketsTx != 0 {
		n += 1 + sovTroubleshooting(uint64(m.PacketsTx))
	}
	if m.PacketsRx != 0 {
		n += 1 + sovTroubleshooting(uint64(m.PacketsRx))
	}
	if m.PacketLoss != 0 {
		n += 1 + sovTroubleshooting(uint64(m.PacketLoss))
	}
	if m.MinRttMs != 0 {
		n += 5
	}
	if m.MaxRttMs != 0 {
		n += 5
	}
	if m.AvgRttMs != 0 {
		n += 5
	}
	if len(m.PktStats) > 0 {
		for _, e := range m.PktStats {
			l = e.Size()
			n += 1 + l + sovTroubleshooting(uint64(l))
		}
	}
	return n
}

func (m *TimeWindow) Size() (n int) {
	var l int
	_ = l
	if m.StartTime != nil {
		l = m.StartTime.Size()
		n += 1 + l + sovTroubleshooting(uint64(l))
	}
	if m.StopTime != nil {
		l = m.StopTime.Size()
		n += 1 + l + sovTroubleshooting(uint64(l))
	}
	return n
}

func (m *TraceRouteInfo) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *TroubleshootingSession) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovTroubleshooting(uint64(l))
	l = m.ObjectMeta.Size()
	n += 1 + l + sovTroubleshooting(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovTroubleshooting(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovTroubleshooting(uint64(l))
	return n
}

func (m *TroubleshootingSessionSpec) Size() (n int) {
	var l int
	_ = l
	l = m.FlowSelector.Size()
	n += 1 + l + sovTroubleshooting(uint64(l))
	if m.TimeWindow != nil {
		l = m.TimeWindow.Size()
		n += 1 + l + sovTroubleshooting(uint64(l))
	}
	l = len(m.RepeatEvery)
	if l > 0 {
		n += 1 + l + sovTroubleshooting(uint64(l))
	}
	if m.EnableMirroring {
		n += 2
	}
	return n
}

func (m *TroubleshootingSessionStatus) Size() (n int) {
	var l int
	_ = l
	l = len(m.State)
	if l > 0 {
		n += 1 + l + sovTroubleshooting(uint64(l))
	}
	if len(m.TsResults) > 0 {
		for _, e := range m.TsResults {
			l = e.Size()
			n += 1 + l + sovTroubleshooting(uint64(l))
		}
	}
	return n
}

func (m *TsAuditTrail) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *TsFlowCounters) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *TsFlowLogs) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *TsPolicy) Size() (n int) {
	var l int
	_ = l
	if m.Sgpolicy != nil {
		l = m.Sgpolicy.Size()
		n += 1 + l + sovTroubleshooting(uint64(l))
	}
	if len(m.InRules) > 0 {
		for _, e := range m.InRules {
			l = e.Size()
			n += 1 + l + sovTroubleshooting(uint64(l))
		}
	}
	if len(m.OutRules) > 0 {
		for _, e := range m.OutRules {
			l = e.Size()
			n += 1 + l + sovTroubleshooting(uint64(l))
		}
	}
	return n
}

func (m *TsReport) Size() (n int) {
	var l int
	_ = l
	l = m.TimeWindow.Size()
	n += 1 + l + sovTroubleshooting(uint64(l))
	l = len(m.ReportSummary)
	if l > 0 {
		n += 1 + l + sovTroubleshooting(uint64(l))
	}
	if len(m.Events) > 0 {
		for _, e := range m.Events {
			l = e.Size()
			n += 1 + l + sovTroubleshooting(uint64(l))
		}
	}
	if len(m.Alerts) > 0 {
		for _, e := range m.Alerts {
			l = e.Size()
			n += 1 + l + sovTroubleshooting(uint64(l))
		}
	}
	if m.Stats != nil {
		l = m.Stats.Size()
		n += 1 + l + sovTroubleshooting(uint64(l))
	}
	if m.FlowCounters != nil {
		l = m.FlowCounters.Size()
		n += 1 + l + sovTroubleshooting(uint64(l))
	}
	if m.FlowLogs != nil {
		l = m.FlowLogs.Size()
		n += 1 + l + sovTroubleshooting(uint64(l))
	}
	if m.AuditTrail != nil {
		l = m.AuditTrail.Size()
		n += 1 + l + sovTroubleshooting(uint64(l))
	}
	if len(m.Policies) > 0 {
		for _, e := range m.Policies {
			l = e.Size()
			n += 1 + l + sovTroubleshooting(uint64(l))
		}
	}
	if m.MirrorStatus != nil {
		l = m.MirrorStatus.Size()
		n += 1 + l + sovTroubleshooting(uint64(l))
	}
	if m.PingStats != nil {
		l = m.PingStats.Size()
		n += 1 + l + sovTroubleshooting(uint64(l))
	}
	if m.TracedRouteInfo != nil {
		l = m.TracedRouteInfo.Size()
		n += 1 + l + sovTroubleshooting(uint64(l))
	}
	return n
}

func (m *TsResult) Size() (n int) {
	var l int
	_ = l
	l = m.TimeWindow.Size()
	n += 1 + l + sovTroubleshooting(uint64(l))
	l = len(m.ReportURL)
	if l > 0 {
		n += 1 + l + sovTroubleshooting(uint64(l))
	}
	return n
}

func (m *TsStats) Size() (n int) {
	var l int
	_ = l
	return n
}

func sovTroubleshooting(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozTroubleshooting(x uint64) (n int) {
	return sovTroubleshooting(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *PingPktStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTroubleshooting
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PingPktStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PingPktStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoResp", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTroubleshooting
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NoResp = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RttMs", wireType)
			}
			m.RttMs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTroubleshooting
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RttMs |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTroubleshooting(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTroubleshooting
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PingStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTroubleshooting
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PingStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PingStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SmartNIC", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTroubleshooting
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTroubleshooting
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SmartNIC = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PacketsTx", wireType)
			}
			m.PacketsTx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTroubleshooting
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PacketsTx |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PacketsRx", wireType)
			}
			m.PacketsRx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTroubleshooting
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PacketsRx |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PacketLoss", wireType)
			}
			m.PacketLoss = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTroubleshooting
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PacketLoss |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinRttMs", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.MinRttMs = float32(math.Float32frombits(v))
		case 6:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxRttMs", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.MaxRttMs = float32(math.Float32frombits(v))
		case 7:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field AvgRttMs", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.AvgRttMs = float32(math.Float32frombits(v))
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PktStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTroubleshooting
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTroubleshooting
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PktStats = append(m.PktStats, &PingPktStats{})
			if err := m.PktStats[len(m.PktStats)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTroubleshooting(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTroubleshooting
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TimeWindow) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTroubleshooting
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TimeWindow: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TimeWindow: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTroubleshooting
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTroubleshooting
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StartTime == nil {
				m.StartTime = &api.Timestamp{}
			}
			if err := m.StartTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StopTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTroubleshooting
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTroubleshooting
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StopTime == nil {
				m.StopTime = &api.Timestamp{}
			}
			if err := m.StopTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTroubleshooting(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTroubleshooting
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TraceRouteInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTroubleshooting
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TraceRouteInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TraceRouteInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTroubleshooting(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTroubleshooting
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TroubleshootingSession) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTroubleshooting
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TroubleshootingSession: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TroubleshootingSession: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTroubleshooting
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTroubleshooting
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTroubleshooting
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTroubleshooting
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTroubleshooting
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTroubleshooting
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTroubleshooting
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTroubleshooting
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTroubleshooting(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTroubleshooting
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TroubleshootingSessionSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTroubleshooting
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TroubleshootingSessionSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TroubleshootingSessionSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlowSelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTroubleshooting
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTroubleshooting
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.FlowSelector.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeWindow", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTroubleshooting
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTroubleshooting
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TimeWindow == nil {
				m.TimeWindow = &TimeWindow{}
			}
			if err := m.TimeWindow.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatEvery", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTroubleshooting
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTroubleshooting
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RepeatEvery = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableMirroring", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTroubleshooting
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableMirroring = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTroubleshooting(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTroubleshooting
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TroubleshootingSessionStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTroubleshooting
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TroubleshootingSessionStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TroubleshootingSessionStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTroubleshooting
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTroubleshooting
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TsResults", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTroubleshooting
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTroubleshooting
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TsResults = append(m.TsResults, &TsResult{})
			if err := m.TsResults[len(m.TsResults)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTroubleshooting(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTroubleshooting
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TsAuditTrail) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTroubleshooting
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TsAuditTrail: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TsAuditTrail: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTroubleshooting(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTroubleshooting
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TsFlowCounters) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTroubleshooting
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TsFlowCounters: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TsFlowCounters: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTroubleshooting(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTroubleshooting
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TsFlowLogs) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTroubleshooting
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TsFlowLogs: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TsFlowLogs: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTroubleshooting(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTroubleshooting
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TsPolicy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTroubleshooting
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TsPolicy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TsPolicy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sgpolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTroubleshooting
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTroubleshooting
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Sgpolicy == nil {
				m.Sgpolicy = &api.ObjectRef{}
			}
			if err := m.Sgpolicy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InRules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTroubleshooting
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTroubleshooting
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InRules = append(m.InRules, &security.SGRule{})
			if err := m.InRules[len(m.InRules)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutRules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTroubleshooting
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTroubleshooting
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OutRules = append(m.OutRules, &security.SGRule{})
			if err := m.OutRules[len(m.OutRules)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTroubleshooting(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTroubleshooting
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TsReport) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTroubleshooting
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TsReport: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TsReport: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeWindow", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTroubleshooting
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTroubleshooting
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TimeWindow.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReportSummary", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTroubleshooting
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTroubleshooting
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReportSummary = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Events", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTroubleshooting
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTroubleshooting
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Events = append(m.Events, events.Event{})
			if err := m.Events[len(m.Events)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Alerts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTroubleshooting
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTroubleshooting
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Alerts = append(m.Alerts, AlertStatus{})
			if err := m.Alerts[len(m.Alerts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTroubleshooting
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTroubleshooting
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = &TsStats{}
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlowCounters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTroubleshooting
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTroubleshooting
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FlowCounters == nil {
				m.FlowCounters = &TsFlowCounters{}
			}
			if err := m.FlowCounters.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlowLogs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTroubleshooting
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTroubleshooting
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FlowLogs == nil {
				m.FlowLogs = &TsFlowLogs{}
			}
			if err := m.FlowLogs.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuditTrail", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTroubleshooting
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTroubleshooting
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AuditTrail == nil {
				m.AuditTrail = &TsAuditTrail{}
			}
			if err := m.AuditTrail.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Policies", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTroubleshooting
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTroubleshooting
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Policies = append(m.Policies, TsPolicy{})
			if err := m.Policies[len(m.Policies)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MirrorStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTroubleshooting
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTroubleshooting
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MirrorStatus == nil {
				m.MirrorStatus = &MirrorSessionStatus{}
			}
			if err := m.MirrorStatus.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PingStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTroubleshooting
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTroubleshooting
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PingStats == nil {
				m.PingStats = &PingStats{}
			}
			if err := m.PingStats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TracedRouteInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTroubleshooting
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTroubleshooting
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TracedRouteInfo == nil {
				m.TracedRouteInfo = &TraceRouteInfo{}
			}
			if err := m.TracedRouteInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTroubleshooting(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTroubleshooting
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TsResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTroubleshooting
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TsResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TsResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeWindow", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTroubleshooting
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTroubleshooting
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TimeWindow.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReportURL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTroubleshooting
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTroubleshooting
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReportURL = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTroubleshooting(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTroubleshooting
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TsStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTroubleshooting
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TsStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TsStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTroubleshooting(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTroubleshooting
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTroubleshooting(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTroubleshooting
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTroubleshooting
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTroubleshooting
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthTroubleshooting
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowTroubleshooting
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipTroubleshooting(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthTroubleshooting = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTroubleshooting   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("troubleshooting.proto", fileDescriptorTroubleshooting) }

var fileDescriptorTroubleshooting = []byte{
	// 1544 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x57, 0xcb, 0x6e, 0xdb, 0x46,
	0x17, 0x36, 0x6d, 0xc7, 0x96, 0x46, 0xb2, 0xad, 0x7f, 0x7c, 0x93, 0x65, 0xff, 0xa6, 0x21, 0xfc,
	0xf9, 0xe1, 0x14, 0xa5, 0x54, 0xb8, 0x40, 0x11, 0xa4, 0x40, 0x0b, 0x33, 0x51, 0x5c, 0xa3, 0xbe,
	0x08, 0x92, 0x9c, 0x00, 0xd9, 0x24, 0xb4, 0x34, 0xa6, 0x27, 0xa6, 0x66, 0x08, 0xce, 0xd0, 0x17,
	0x14, 0x5d, 0x74, 0x91, 0x22, 0x9b, 0x3e, 0x45, 0x77, 0x7d, 0x81, 0xbe, 0x42, 0x96, 0x41, 0xb7,
	0x05, 0xd4, 0xc2, 0xab, 0x42, 0xaf, 0xd0, 0x4d, 0x31, 0x17, 0x4a, 0x94, 0x44, 0x39, 0xcd, 0x4e,
	0xf3, 0x9d, 0x73, 0xbe, 0x39, 0x3c, 0x73, 0x6e, 0x02, 0xcb, 0x3c, 0xa0, 0xe1, 0xa9, 0x87, 0xd8,
	0x39, 0xa5, 0x1c, 0x13, 0xb7, 0xe4, 0x07, 0x94, 0x53, 0x08, 0xda, 0x94, 0x60, 0x4e, 0x03, 0x4c,
	0xdc, 0xc2, 0x86, 0x4b, 0xa9, 0xeb, 0xa1, 0xb2, 0xe3, 0xe3, 0xb2, 0x43, 0x08, 0xe5, 0x0e, 0xc7,
	0x94, 0x30, 0xa5, 0x59, 0xa8, 0xb8, 0x98, 0x9f, 0x87, 0xa7, 0xa5, 0x26, 0x6d, 0x97, 0x7d, 0x44,
	0x98, 0x43, 0x5a, 0xb4, 0xcc, 0xae, 0xca, 0x97, 0x88, 0xe0, 0x26, 0x2a, 0x87, 0x1c, 0x7b, 0x4c,
	0x98, 0xba, 0x88, 0xc4, 0xad, 0xcb, 0x98, 0x34, 0xbd, 0xb0, 0x85, 0x22, 0x1a, 0x2b, 0x46, 0xe3,
	0x52, 0x97, 0x96, 0x25, 0x7c, 0x1a, 0x9e, 0xc9, 0x93, 0x3c, 0xc8, 0x5f, 0x5a, 0xfd, 0xfe, 0x98,
	0x5b, 0x85, 0x8f, 0x6d, 0xc4, 0x1d, 0xad, 0x56, 0xba, 0x43, 0x4d, 0x6a, 0xb0, 0x32, 0xba, 0x44,
	0x84, 0x47, 0x5e, 0x7c, 0xf6, 0x61, 0x7d, 0xe6, 0xfa, 0xd4, 0xc3, 0xcd, 0x1b, 0x6d, 0x91, 0x75,
	0x3c, 0x14, 0xf4, 0xec, 0xb3, 0x6d, 0x1c, 0x04, 0x34, 0x50, 0xa7, 0xe2, 0x4f, 0x06, 0xc8, 0x56,
	0x31, 0x71, 0xab, 0x17, 0xbc, 0xce, 0x1d, 0xce, 0xe0, 0x23, 0x30, 0x73, 0x44, 0x6b, 0x88, 0xf9,
	0x79, 0x63, 0xcb, 0xd8, 0x4e, 0xd9, 0x2b, 0xdd, 0x8e, 0x09, 0x09, 0xb5, 0x02, 0xc4, 0x7c, 0x4a,
	0x18, 0xfa, 0x14, 0x13, 0x0f, 0x13, 0x54, 0x4b, 0xc0, 0xe0, 0x2e, 0xb8, 0x57, 0xe3, 0xfc, 0x90,
	0xe5, 0x27, 0xb7, 0x8c, 0xed, 0x39, 0xbb, 0xd0, 0xed, 0x98, 0x2b, 0x01, 0x0d, 0x49, 0xcb, 0xe2,
	0x01, 0xf6, 0x2d, 0x8e, 0xdb, 0x3d, 0xf3, 0x31, 0x78, 0xf1, 0xf7, 0x69, 0x90, 0x16, 0xfe, 0x28,
	0x67, 0x1e, 0x82, 0x54, 0xbd, 0xed, 0x04, 0xfc, 0x68, 0xff, 0xb1, 0x74, 0x27, 0x6d, 0x2f, 0x75,
	0x3b, 0x66, 0x8e, 0x09, 0xcc, 0x22, 0xb8, 0x19, 0xb1, 0x8d, 0x20, 0xf0, 0x6b, 0x90, 0xae, 0x3a,
	0xcd, 0x0b, 0xc4, 0x59, 0xe3, 0x5a, 0xbb, 0xb3, 0xda, 0xed, 0x98, 0x8b, 0xbe, 0x02, 0x2d, 0x86,
	0x08, 0x8f, 0xac, 0x93, 0x40, 0xb8, 0xd7, 0x23, 0xa8, 0x5d, 0xe7, 0xa7, 0x24, 0xc1, 0x7a, 0xb7,
	0x63, 0xae, 0x46, 0xba, 0x01, 0x6a, 0x22, 0x7c, 0x89, 0x5a, 0x11, 0xc9, 0x38, 0x01, 0xfc, 0x0a,
	0x00, 0x45, 0x74, 0x40, 0x19, 0xcb, 0x4f, 0x4b, 0x26, 0x19, 0x54, 0x65, 0x60, 0x79, 0x94, 0xb1,
	0x5e, 0x50, 0x47, 0x31, 0x78, 0x00, 0x52, 0x87, 0x98, 0xa8, 0xb8, 0xde, 0xdb, 0x32, 0xb6, 0x27,
	0xed, 0xcd, 0x6e, 0xc7, 0x2c, 0xb4, 0x31, 0xb1, 0xc6, 0xc4, 0xf6, 0x0e, 0x99, 0x64, 0x73, 0xae,
	0x15, 0xdb, 0x4c, 0x8c, 0xcd, 0xb9, 0x1e, 0xcf, 0x36, 0x56, 0x26, 0xd8, 0x76, 0x2f, 0x5d, 0xc5,
	0x36, 0xdb, 0x67, 0x73, 0x2e, 0xdd, 0xb1, 0x6c, 0xe3, 0x65, 0xf0, 0x15, 0x48, 0x45, 0x69, 0x98,
	0x4f, 0x6d, 0x4d, 0x6d, 0x67, 0x76, 0xf2, 0xa5, 0x7e, 0x8d, 0x97, 0xe2, 0x69, 0xaa, 0xdf, 0x02,
	0x05, 0x96, 0x8e, 0x18, 0x13, 0x68, 0xff, 0x2d, 0x92, 0x05, 0xc5, 0x5f, 0x0d, 0x00, 0x1a, 0xb8,
	0x8d, 0x9e, 0x63, 0xd2, 0xa2, 0x57, 0xf0, 0x04, 0xa4, 0xeb, 0xdc, 0x09, 0xb8, 0x80, 0x64, 0x7e,
	0x65, 0x76, 0xe6, 0x4b, 0x8e, 0x8f, 0x4b, 0x02, 0x60, 0xdc, 0x69, 0xfb, 0xf6, 0xc6, 0xbb, 0x8e,
	0x69, 0x74, 0x3b, 0xe6, 0x12, 0x13, 0x8a, 0xca, 0x5d, 0xda, 0xc6, 0x1c, 0xb5, 0x7d, 0x7e, 0x53,
	0x4b, 0x44, 0x61, 0x0d, 0xa4, 0xea, 0x9c, 0xfa, 0x92, 0x75, 0x32, 0x91, 0x75, 0x5d, 0xb3, 0x2e,
	0x32, 0x4e, 0xfd, 0x61, 0xd2, 0x24, 0xb0, 0x98, 0x03, 0xf3, 0x8d, 0xc0, 0x69, 0xa2, 0x1a, 0x0d,
	0x39, 0xda, 0x27, 0x67, 0xb4, 0xf8, 0xc3, 0x14, 0x58, 0x69, 0x0c, 0x36, 0xc6, 0x3a, 0x62, 0x0c,
	0x53, 0x02, 0xbf, 0x00, 0x46, 0x43, 0x7f, 0xcf, 0x9c, 0xba, 0xf9, 0xc6, 0x47, 0x87, 0x88, 0x3b,
	0xf6, 0xe2, 0xbb, 0x8e, 0x39, 0xf1, 0x5e, 0x5d, 0x3e, 0x1b, 0x85, 0x2b, 0xfa, 0x01, 0x9f, 0x02,
	0xe3, 0x58, 0x7b, 0xbc, 0x20, 0xed, 0x8e, 0x4f, 0x5f, 0xa3, 0x26, 0x97, 0x96, 0x85, 0x98, 0xe5,
	0xbc, 0x68, 0x5f, 0x31, 0x8f, 0x87, 0xce, 0xf0, 0x19, 0x98, 0xae, 0xfb, 0xa8, 0x29, 0xcb, 0x26,
	0xb3, 0xf3, 0xff, 0xf8, 0x23, 0x26, 0x7b, 0x2c, 0xb4, 0x95, 0x6f, 0xdd, 0x8e, 0x99, 0x61, 0x3e,
	0xea, 0x55, 0x76, 0xfc, 0x00, 0x5b, 0x60, 0x46, 0xbc, 0x7e, 0xa8, 0xca, 0x28, 0xb3, 0xb3, 0xfd,
	0x2f, 0x98, 0xa5, 0xbe, 0x9d, 0xd7, 0xdc, 0x39, 0x26, 0xcf, 0x31, 0xdf, 0x47, 0x90, 0x47, 0x0f,
	0x7e, 0x7b, 0xb3, 0x76, 0x1f, 0x64, 0xca, 0xdf, 0x1d, 0x97, 0x1a, 0x88, 0x38, 0x84, 0x7f, 0x0f,
	0xc7, 0x04, 0xba, 0xf8, 0x66, 0x0a, 0x14, 0xc6, 0x7f, 0x11, 0x7c, 0x09, 0xb2, 0x4f, 0x3d, 0x7a,
	0x55, 0x47, 0x1e, 0x6a, 0x72, 0x1a, 0xe8, 0x27, 0x59, 0x8e, 0x7b, 0x7d, 0xe8, 0xf0, 0xe6, 0x79,
	0x2d, 0xf4, 0x90, 0xcc, 0x34, 0xe1, 0xe2, 0xd2, 0x99, 0x47, 0xaf, 0x2c, 0xa6, 0x6d, 0xa2, 0x38,
	0x24, 0xa2, 0xf0, 0x55, 0x3c, 0x9d, 0xf5, 0xcb, 0xad, 0x0c, 0x04, 0xa5, 0x27, 0xb5, 0xff, 0xab,
	0x73, 0x6e, 0x59, 0x64, 0x96, 0x75, 0x25, 0xc1, 0x58, 0x1c, 0x92, 0x61, 0xf8, 0x2d, 0xc8, 0xd4,
	0x90, 0x8f, 0x1c, 0x5e, 0xb9, 0x44, 0xc1, 0x8d, 0x7c, 0xd1, 0xb4, 0xbd, 0xa9, 0xa9, 0x56, 0x02,
	0x29, 0xb2, 0x90, 0x90, 0xc5, 0xb8, 0xc6, 0xe0, 0xf0, 0x39, 0x58, 0xa8, 0x10, 0xe7, 0xd4, 0x43,
	0x87, 0x72, 0x04, 0x61, 0xe2, 0xca, 0x87, 0x4c, 0xd9, 0x45, 0x4d, 0x58, 0x40, 0x52, 0x6c, 0xb5,
	0x23, 0x79, 0x8c, 0xf4, 0x0e, 0x59, 0xf1, 0xd6, 0x00, 0x1b, 0x77, 0xbd, 0x3f, 0x3c, 0x01, 0xf7,
	0xc4, 0x2f, 0xa4, 0xa7, 0xc8, 0xc3, 0x5f, 0x7e, 0x5c, 0xfb, 0x5f, 0x9d, 0x07, 0x15, 0x12, 0xb6,
	0xb7, 0xc7, 0x1b, 0xa2, 0x07, 0xdd, 0x8e, 0x99, 0x15, 0x09, 0xd2, 0xeb, 0x5f, 0x03, 0x27, 0x78,
	0x01, 0xd2, 0x0d, 0x56, 0x43, 0x2c, 0xf4, 0xb8, 0x18, 0x7a, 0xa2, 0x65, 0x2d, 0x0d, 0x84, 0x5f,
	0x0b, 0xed, 0x62, 0xb7, 0x63, 0x6e, 0x0e, 0xad, 0x31, 0x62, 0x7c, 0x0a, 0xc3, 0x88, 0xfa, 0x03,
	0xf2, 0xe2, 0x3c, 0xc8, 0x36, 0xd8, 0x6e, 0xd8, 0xc2, 0xbc, 0x11, 0x38, 0xd8, 0x93, 0x2d, 0x81,
	0x89, 0xfc, 0x7a, 0x4c, 0x43, 0xc2, 0x51, 0xc0, 0x8a, 0x59, 0x00, 0x14, 0x72, 0x40, 0x5d, 0x56,
	0xfc, 0xdb, 0x00, 0xa9, 0x06, 0xab, 0xca, 0x4d, 0x00, 0x1e, 0x81, 0x54, 0x5d, 0x6f, 0x05, 0x03,
	0x9d, 0x4e, 0x55, 0x78, 0x0d, 0x9d, 0xa9, 0xf1, 0xc8, 0x5c, 0x4b, 0x29, 0x0d, 0xf4, 0xa3, 0x51,
	0x10, 0x1e, 0x82, 0xd9, 0x7d, 0x22, 0xf2, 0x36, 0xfa, 0xee, 0x5c, 0x89, 0xa1, 0x66, 0x18, 0x60,
	0x7e, 0x53, 0xaa, 0xef, 0xc9, 0x84, 0x96, 0x43, 0x4e, 0x4c, 0x22, 0xa1, 0x15, 0xe3, 0x4b, 0xc0,
	0x60, 0x15, 0xa4, 0x8e, 0x43, 0xae, 0xf8, 0xa6, 0xc6, 0xf0, 0x49, 0x07, 0x69, 0xc8, 0x47, 0x08,
	0x93, 0xc0, 0xe2, 0x1f, 0x29, 0xf1, 0xf5, 0x35, 0xe4, 0xd3, 0x80, 0x0f, 0xd5, 0x89, 0xf1, 0xc1,
	0x3a, 0x99, 0xf8, 0xe8, 0x3a, 0xd9, 0x03, 0x73, 0xea, 0xae, 0x7a, 0xd8, 0x6e, 0x3b, 0xc1, 0x8d,
	0x2c, 0xc6, 0xb4, 0xbd, 0x26, 0x88, 0x02, 0x29, 0xb0, 0x98, 0x92, 0x44, 0xcf, 0x9d, 0x0c, 0xc3,
	0x7d, 0x30, 0x53, 0x91, 0xeb, 0x9e, 0x8e, 0xc3, 0x5c, 0x49, 0x6f, 0x7f, 0x12, 0xed, 0x37, 0x32,
	0x85, 0xc6, 0x1b, 0xd9, 0x30, 0x02, 0xeb, 0x60, 0x66, 0x57, 0x6e, 0x7e, 0xf9, 0x69, 0x49, 0xb5,
	0x1a, 0xff, 0x62, 0x29, 0x19, 0xee, 0x8e, 0x6a, 0x51, 0x8c, 0x93, 0x0e, 0x23, 0xf0, 0x40, 0x55,
	0x92, 0xda, 0x45, 0x32, 0x3b, 0x8b, 0x83, 0xe9, 0xae, 0x86, 0xf3, 0xaa, 0x2e, 0xe7, 0x05, 0x35,
	0x7c, 0xfb, 0x74, 0xc3, 0x00, 0x7c, 0xad, 0x3a, 0x64, 0x94, 0xc1, 0x72, 0x25, 0xc9, 0xec, 0x14,
	0x06, 0x49, 0xe3, 0x1a, 0xb6, 0xa9, 0xb9, 0x57, 0x65, 0x43, 0x6c, 0x6a, 0x38, 0x76, 0xc7, 0x38,
	0x01, 0x7c, 0x01, 0x52, 0x51, 0x6d, 0xc8, 0x65, 0x65, 0x38, 0x05, 0x7a, 0x95, 0xd3, 0x1f, 0xcf,
	0x92, 0xca, 0xa3, 0xee, 0x40, 0xb6, 0x25, 0x80, 0xf0, 0x14, 0x80, 0x7e, 0x65, 0xe6, 0x53, 0x92,
	0x3d, 0x3f, 0xc8, 0xde, 0x97, 0xf7, 0x5b, 0xb1, 0x23, 0x30, 0x8b, 0x0b, 0x30, 0x9e, 0x62, 0x89,
	0x30, 0x7c, 0x06, 0x52, 0xb2, 0x98, 0x31, 0x62, 0xf9, 0x74, 0x52, 0xaf, 0x51, 0xa5, 0xae, 0x26,
	0xb5, 0x5c, 0x30, 0xb5, 0x76, 0xbc, 0xf6, 0x46, 0x31, 0x18, 0x82, 0xac, 0xea, 0xc7, 0x7a, 0xb6,
	0x02, 0xe9, 0xbd, 0x39, 0x30, 0xa5, 0x94, 0x7c, 0x60, 0xa4, 0x6e, 0x75, 0x3b, 0xe6, 0x86, 0x6a,
	0xc6, 0x16, 0x53, 0x12, 0x4b, 0xcf, 0x52, 0x9d, 0xe1, 0x77, 0x4a, 0x61, 0x2d, 0xb6, 0xe8, 0xe7,
	0x33, 0xa3, 0x93, 0xb1, 0x27, 0xb4, 0x97, 0xbb, 0x1d, 0xf3, 0x3f, 0xbe, 0xe8, 0x88, 0x03, 0x5b,
	0xde, 0x28, 0x04, 0x2f, 0xc0, 0x82, 0xdc, 0x92, 0x5a, 0xbd, 0x35, 0x29, 0x9f, 0x4d, 0xc8, 0xa8,
	0x81, 0x45, 0xca, 0xde, 0xe8, 0x76, 0xcc, 0x3c, 0x97, 0x66, 0x62, 0x33, 0xe5, 0xc8, 0xc2, 0xe4,
	0x8c, 0x46, 0xb7, 0x8c, 0x95, 0x14, 0x7f, 0x36, 0x54, 0x87, 0x11, 0x4d, 0x1a, 0xbe, 0xf8, 0x88,
	0x0e, 0xd3, 0x7b, 0xa0, 0x78, 0x2b, 0x89, 0xfe, 0x01, 0x8c, 0x62, 0xf0, 0x4b, 0x90, 0x56, 0xbd,
	0xe5, 0xa4, 0x76, 0xa0, 0xfb, 0x8a, 0x0c, 0x89, 0x6e, 0x20, 0x61, 0xe0, 0xf5, 0x42, 0x32, 0x02,
	0x15, 0xd3, 0x60, 0x56, 0x97, 0xe5, 0x27, 0xd7, 0x60, 0xfd, 0x8e, 0x59, 0x07, 0xd7, 0x01, 0x68,
	0xd4, 0x5f, 0xd6, 0x4e, 0x8e, 0x8e, 0xf6, 0x8f, 0xf6, 0x72, 0x13, 0x85, 0xcc, 0xed, 0xdb, 0xb5,
	0xd9, 0x20, 0x24, 0x04, 0x13, 0x57, 0x0b, 0xeb, 0x8d, 0xe3, 0x6a, 0xb5, 0xf2, 0x24, 0x67, 0x28,
	0xa1, 0x58, 0x54, 0x7d, 0xd4, 0x82, 0x26, 0xc8, 0x0a, 0xe1, 0xe3, 0x6f, 0x2a, 0x4f, 0x4e, 0x0e,
	0x2a, 0x4f, 0x72, 0x93, 0x85, 0xb9, 0xdb, 0xb7, 0x6b, 0x69, 0xd6, 0x3c, 0x47, 0xad, 0xd0, 0x43,
	0x2d, 0x3b, 0xf7, 0xee, 0x76, 0xd3, 0x78, 0x7f, 0xbb, 0x69, 0xfc, 0x79, 0xbb, 0x69, 0xfc, 0x75,
	0xbb, 0x39, 0x51, 0x35, 0x4e, 0x67, 0xe4, 0x1f, 0xd0, 0xcf, 0xff, 0x09, 0x00, 0x00, 0xff, 0xff,
	0x57, 0x44, 0xfa, 0x54, 0xde, 0x0f, 0x00, 0x00,
}
