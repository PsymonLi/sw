// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: alerts.proto

/*
	Package monitoring is a generated protocol buffer package.

	It is generated from these files:
		alerts.proto
		eventpolicy.proto
		mirror.proto
		svc_monitoring.proto
		telemetry.proto

	It has these top-level messages:
		Alert
		AlertDestination
		AlertDestinationSpec
		AlertDestinationStatus
		AlertPolicy
		AlertPolicySpec
		AlertPolicyStatus
		AlertReason
		AlertSource
		AlertSpec
		AlertStatus
		AuditInfo
		AuthConfig
		MatchedRequirement
		PrivacyConfig
		Requirement
		SNMPTrapServer
		EventExport
		EventPolicy
		EventPolicySpec
		EventPolicyStatus
		AppProtoSelector
		MatchRule
		MatchSelector
		MirrorCollector
		MirrorSession
		MirrorSessionSpec
		MirrorSessionStatus
		MirrorStartConditions
		MirrorStopConditions
		AlertDestinationList
		AlertList
		AlertPolicyList
		AutoMsgAlertDestinationWatchHelper
		AutoMsgAlertPolicyWatchHelper
		AutoMsgAlertWatchHelper
		AutoMsgEventPolicyWatchHelper
		AutoMsgFlowExportPolicyWatchHelper
		AutoMsgFwlogPolicyWatchHelper
		AutoMsgMirrorSessionWatchHelper
		AutoMsgStatsPolicyWatchHelper
		EventPolicyList
		FlowExportPolicyList
		FwlogPolicyList
		MirrorSessionList
		StatsPolicyList
		FlowExportPolicy
		FlowExportSpec
		FlowExportStatus
		FlowExportTarget
		FwlogExport
		FwlogPolicy
		FwlogSpec
		FwlogStatus
		StatsPolicy
		StatsSpec
		StatsStatus
*/
package monitoring

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/pensando/grpc-gateway/third_party/googleapis/google/api"
import _ "github.com/pensando/sw/venice/utils/apigen/annotations"
import _ "github.com/gogo/protobuf/gogoproto"
import api "github.com/pensando/sw/api"
import _ "github.com/pensando/sw/api/generated/events"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// Possible alert states
type AlertSpec_AlertState int32

const (
	// ui-hint: Open
	AlertSpec_OPEN AlertSpec_AlertState = 0
	// ui-hint: Resolved
	AlertSpec_RESOLVED AlertSpec_AlertState = 1
	// ui-hint: Acknowledged
	AlertSpec_ACKNOWLEDGED AlertSpec_AlertState = 2
)

var AlertSpec_AlertState_name = map[int32]string{
	0: "OPEN",
	1: "RESOLVED",
	2: "ACKNOWLEDGED",
}
var AlertSpec_AlertState_value = map[string]int32{
	"OPEN":         0,
	"RESOLVED":     1,
	"ACKNOWLEDGED": 2,
}

func (x AlertSpec_AlertState) String() string {
	return proto.EnumName(AlertSpec_AlertState_name, int32(x))
}
func (AlertSpec_AlertState) EnumDescriptor() ([]byte, []int) { return fileDescriptorAlerts, []int{9, 0} }

// Algos contains the authentication algorithm to be used when SecurityMethod
// has AUTH.
type AuthConfig_Algos int32

const (
	//
	AuthConfig_MD5 AuthConfig_Algos = 0
	//
	AuthConfig_SHA1 AuthConfig_Algos = 1
)

var AuthConfig_Algos_name = map[int32]string{
	0: "MD5",
	1: "SHA1",
}
var AuthConfig_Algos_value = map[string]int32{
	"MD5":  0,
	"SHA1": 1,
}

func (x AuthConfig_Algos) String() string {
	return proto.EnumName(AuthConfig_Algos_name, int32(x))
}
func (AuthConfig_Algos) EnumDescriptor() ([]byte, []int) { return fileDescriptorAlerts, []int{12, 0} }

// Algos contains the encryption algorithm to be used when SecurityMethod
// has PRIVACY.
type PrivacyConfig_Algos int32

const (
	//
	PrivacyConfig_DES56 PrivacyConfig_Algos = 0
	//
	PrivacyConfig_AES128 PrivacyConfig_Algos = 1
)

var PrivacyConfig_Algos_name = map[int32]string{
	0: "DES56",
	1: "AES128",
}
var PrivacyConfig_Algos_value = map[string]int32{
	"DES56":  0,
	"AES128": 1,
}

func (x PrivacyConfig_Algos) String() string {
	return proto.EnumName(PrivacyConfig_Algos_name, int32(x))
}
func (PrivacyConfig_Algos) EnumDescriptor() ([]byte, []int) { return fileDescriptorAlerts, []int{14, 0} }

// List of allowed operators in the requirement
type Requirement_AllowedOperators int32

const (
	//
	Requirement_Equals Requirement_AllowedOperators = 0
	//
	Requirement_In Requirement_AllowedOperators = 1
	//
	Requirement_NotEquals Requirement_AllowedOperators = 2
	//
	Requirement_NotIn Requirement_AllowedOperators = 3
	//
	Requirement_Gt Requirement_AllowedOperators = 4
	//
	Requirement_Lt Requirement_AllowedOperators = 5
)

var Requirement_AllowedOperators_name = map[int32]string{
	0: "Equals",
	1: "In",
	2: "NotEquals",
	3: "NotIn",
	4: "Gt",
	5: "Lt",
}
var Requirement_AllowedOperators_value = map[string]int32{
	"Equals":    0,
	"In":        1,
	"NotEquals": 2,
	"NotIn":     3,
	"Gt":        4,
	"Lt":        5,
}

func (x Requirement_AllowedOperators) String() string {
	return proto.EnumName(Requirement_AllowedOperators_name, int32(x))
}
func (Requirement_AllowedOperators) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorAlerts, []int{15, 0}
}

// Version of SNMP to use to send the traps (v1 is not supported).
type SNMPTrapServer_SNMPVersions int32

const (
	//
	SNMPTrapServer_V2C SNMPTrapServer_SNMPVersions = 0
	//
	SNMPTrapServer_V3 SNMPTrapServer_SNMPVersions = 1
)

var SNMPTrapServer_SNMPVersions_name = map[int32]string{
	0: "V2C",
	1: "V3",
}
var SNMPTrapServer_SNMPVersions_value = map[string]int32{
	"V2C": 0,
	"V3":  1,
}

func (x SNMPTrapServer_SNMPVersions) String() string {
	return proto.EnumName(SNMPTrapServer_SNMPVersions_name, int32(x))
}
func (SNMPTrapServer_SNMPVersions) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorAlerts, []int{16, 0}
}

// Alert defines an alert object
type Alert struct {
	//
	api.TypeMeta `protobuf:"bytes,1,opt,name=T,json=,inline,embedded=T" json:",inline"`
	//
	api.ObjectMeta `protobuf:"bytes,2,opt,name=O,json=meta, omitempty,embedded=O" json:"meta, omitempty"`
	//
	Spec AlertSpec `protobuf:"bytes,3,opt,name=Spec,json=spec, omitempty" json:"spec, omitempty"`
	//
	Status AlertStatus `protobuf:"bytes,4,opt,name=Status,json=status, omitempty" json:"status, omitempty"`
}

func (m *Alert) Reset()                    { *m = Alert{} }
func (m *Alert) String() string            { return proto.CompactTextString(m) }
func (*Alert) ProtoMessage()               {}
func (*Alert) Descriptor() ([]byte, []int) { return fileDescriptorAlerts, []int{0} }

func (m *Alert) GetSpec() AlertSpec {
	if m != nil {
		return m.Spec
	}
	return AlertSpec{}
}

func (m *Alert) GetStatus() AlertStatus {
	if m != nil {
		return m.Status
	}
	return AlertStatus{}
}

// AlertDestination - tenant scoped
type AlertDestination struct {
	//
	api.TypeMeta `protobuf:"bytes,1,opt,name=T,json=,inline,embedded=T" json:",inline"`
	//
	api.ObjectMeta `protobuf:"bytes,2,opt,name=O,json=meta, omitempty,embedded=O" json:"meta, omitempty"`
	//
	Spec AlertDestinationSpec `protobuf:"bytes,3,opt,name=Spec,json=spec, omitempty" json:"spec, omitempty"`
	//
	Status AlertDestinationStatus `protobuf:"bytes,4,opt,name=Status,json=status, omitempty" json:"status, omitempty"`
}

func (m *AlertDestination) Reset()                    { *m = AlertDestination{} }
func (m *AlertDestination) String() string            { return proto.CompactTextString(m) }
func (*AlertDestination) ProtoMessage()               {}
func (*AlertDestination) Descriptor() ([]byte, []int) { return fileDescriptorAlerts, []int{1} }

func (m *AlertDestination) GetSpec() AlertDestinationSpec {
	if m != nil {
		return m.Spec
	}
	return AlertDestinationSpec{}
}

func (m *AlertDestination) GetStatus() AlertDestinationStatus {
	if m != nil {
		return m.Status
	}
	return AlertDestinationStatus{}
}

//
type AlertDestinationSpec struct {
	// If set, this will be the default notification option for the alert policies unless otherwise
	// something else is mentioned.
	Default bool `protobuf:"varint,1,opt,name=Default,json=default, omitempty,proto3" json:"default, omitempty"`
	// Email notification
	EmailList []string `protobuf:"bytes,2,rep,name=EmailList,json=email-list, omitempty" json:"email-list, omitempty"`
	// SNMP trap destination(s)
	SNMPTrapServers []*SNMPTrapServer `protobuf:"bytes,3,rep,name=SNMPTrapServers,json=snmp-trap-servers, omitempty" json:"snmp-trap-servers, omitempty"`
}

func (m *AlertDestinationSpec) Reset()                    { *m = AlertDestinationSpec{} }
func (m *AlertDestinationSpec) String() string            { return proto.CompactTextString(m) }
func (*AlertDestinationSpec) ProtoMessage()               {}
func (*AlertDestinationSpec) Descriptor() ([]byte, []int) { return fileDescriptorAlerts, []int{2} }

func (m *AlertDestinationSpec) GetDefault() bool {
	if m != nil {
		return m.Default
	}
	return false
}

func (m *AlertDestinationSpec) GetEmailList() []string {
	if m != nil {
		return m.EmailList
	}
	return nil
}

func (m *AlertDestinationSpec) GetSNMPTrapServers() []*SNMPTrapServer {
	if m != nil {
		return m.SNMPTrapServers
	}
	return nil
}

//
type AlertDestinationStatus struct {
	// total number of notifications sent using this notification mechanism
	TotalNotificationsSent int32 `protobuf:"varint,1,opt,name=totalNotificationsSent,json=total-notifications-sent, omitempty,proto3" json:"total-notifications-sent, omitempty"`
}

func (m *AlertDestinationStatus) Reset()                    { *m = AlertDestinationStatus{} }
func (m *AlertDestinationStatus) String() string            { return proto.CompactTextString(m) }
func (*AlertDestinationStatus) ProtoMessage()               {}
func (*AlertDestinationStatus) Descriptor() ([]byte, []int) { return fileDescriptorAlerts, []int{3} }

func (m *AlertDestinationStatus) GetTotalNotificationsSent() int32 {
	if m != nil {
		return m.TotalNotificationsSent
	}
	return 0
}

// AlertPolicy - tenant scoped
type AlertPolicy struct {
	//
	api.TypeMeta `protobuf:"bytes,1,opt,name=T,json=,inline,embedded=T" json:",inline"`
	//
	api.ObjectMeta `protobuf:"bytes,2,opt,name=O,json=meta, omitempty,embedded=O" json:"meta, omitempty"`
	//
	Spec AlertPolicySpec `protobuf:"bytes,3,opt,name=Spec,json=spec, omitempty" json:"spec, omitempty"`
	//
	Status AlertPolicyStatus `protobuf:"bytes,4,opt,name=Status,json=status, omitempty" json:"status, omitempty"`
}

func (m *AlertPolicy) Reset()                    { *m = AlertPolicy{} }
func (m *AlertPolicy) String() string            { return proto.CompactTextString(m) }
func (*AlertPolicy) ProtoMessage()               {}
func (*AlertPolicy) Descriptor() ([]byte, []int) { return fileDescriptorAlerts, []int{4} }

func (m *AlertPolicy) GetSpec() AlertPolicySpec {
	if m != nil {
		return m.Spec
	}
	return AlertPolicySpec{}
}

func (m *AlertPolicy) GetStatus() AlertPolicyStatus {
	if m != nil {
		return m.Status
	}
	return AlertPolicyStatus{}
}

//
type AlertPolicySpec struct {
	// Resource type - target resource to run this policy.
	// e.g. Network, Endpoint - object based alert policy
	//      Event - event based alert policy
	//      EndpointMetrics - metric based alert policy
	// based on the resource type, the policy gets interpreted.
	Resource string `protobuf:"bytes,1,opt,name=Resource,json=resource, omitempty,proto3" json:"resource, omitempty"`
	// Severity to be set for an alert that gets triggered from this rule
	Severity string `protobuf:"bytes,2,opt,name=Severity,json=severity, omitempty,proto3" json:"severity, omitempty"`
	// Message to be used while generating the alert
	// XXX: Event based alerts should not carry a message. It will be derived from the event.
	Message string `protobuf:"bytes,3,opt,name=Message,json=message, omitempty,proto3" json:"message, omitempty"`
	// List of requirements that needs to be met to trigger an alert
	Requirements []Requirement `protobuf:"bytes,4,rep,name=Requirements,json=requirements, omitempty" json:"requirements, omitempty"`
	// Met rule (requirements) needs to sustain for the given duration to qualify to be an alert
	PersistenceDuration string `protobuf:"bytes,5,opt,name=PersistenceDuration,json=persistence-duration, omitempty,proto3" json:"persistence-duration, omitempty"`
	// Met rule (requirements) needs to be cleared for the given duration to resolve an alert
	ClearDuration string `protobuf:"bytes,6,opt,name=ClearDuration,json=clear-duration, omitempty,proto3" json:"clear-duration, omitempty"`
	// User can disable the policy by setting this field.
	// Disabled policies will not generate any more alerts but the outstanding ones will remain as is.
	Enable bool `protobuf:"varint,7,opt,name=Enable,json=enable, omitempty,proto3" json:"enable, omitempty"`
	// If set, the underlying alert will be auto-resolved if the rule that
	// triggered the alert is cleared
	AutoResolve bool `protobuf:"varint,8,opt,name=AutoResolve,json=auto-resolve, omitempty,proto3" json:"auto-resolve, omitempty"`
	// name of the alert destinations to be used to send out notification when an alert
	// gets generated.
	Destinations []string `protobuf:"bytes,9,rep,name=Destinations,json=destinations, omitempty" json:"destinations, omitempty"`
}

func (m *AlertPolicySpec) Reset()                    { *m = AlertPolicySpec{} }
func (m *AlertPolicySpec) String() string            { return proto.CompactTextString(m) }
func (*AlertPolicySpec) ProtoMessage()               {}
func (*AlertPolicySpec) Descriptor() ([]byte, []int) { return fileDescriptorAlerts, []int{5} }

func (m *AlertPolicySpec) GetResource() string {
	if m != nil {
		return m.Resource
	}
	return ""
}

func (m *AlertPolicySpec) GetSeverity() string {
	if m != nil {
		return m.Severity
	}
	return ""
}

func (m *AlertPolicySpec) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *AlertPolicySpec) GetRequirements() []Requirement {
	if m != nil {
		return m.Requirements
	}
	return nil
}

func (m *AlertPolicySpec) GetPersistenceDuration() string {
	if m != nil {
		return m.PersistenceDuration
	}
	return ""
}

func (m *AlertPolicySpec) GetClearDuration() string {
	if m != nil {
		return m.ClearDuration
	}
	return ""
}

func (m *AlertPolicySpec) GetEnable() bool {
	if m != nil {
		return m.Enable
	}
	return false
}

func (m *AlertPolicySpec) GetAutoResolve() bool {
	if m != nil {
		return m.AutoResolve
	}
	return false
}

func (m *AlertPolicySpec) GetDestinations() []string {
	if m != nil {
		return m.Destinations
	}
	return nil
}

//
type AlertPolicyStatus struct {
	// Total hits on this policy
	TotalHits int32 `protobuf:"varint,1,opt,name=TotalHits,json=total-hits, omitempty,proto3" json:"total-hits, omitempty"`
	// Open alerts based on this policy
	OpenAlerts int32 `protobuf:"varint,2,opt,name=OpenAlerts,json=open-alerts, omitempty,proto3" json:"open-alerts, omitempty"`
	// Acknowledged alerts based on this policy
	AcknowledgedAlerts int32 `protobuf:"varint,3,opt,name=AcknowledgedAlerts,json=acknowledged-alerts, omitempty,proto3" json:"acknowledged-alerts, omitempty"`
}

func (m *AlertPolicyStatus) Reset()                    { *m = AlertPolicyStatus{} }
func (m *AlertPolicyStatus) String() string            { return proto.CompactTextString(m) }
func (*AlertPolicyStatus) ProtoMessage()               {}
func (*AlertPolicyStatus) Descriptor() ([]byte, []int) { return fileDescriptorAlerts, []int{6} }

func (m *AlertPolicyStatus) GetTotalHits() int32 {
	if m != nil {
		return m.TotalHits
	}
	return 0
}

func (m *AlertPolicyStatus) GetOpenAlerts() int32 {
	if m != nil {
		return m.OpenAlerts
	}
	return 0
}

func (m *AlertPolicyStatus) GetAcknowledgedAlerts() int32 {
	if m != nil {
		return m.AcknowledgedAlerts
	}
	return 0
}

// AlertReason captures all the requirements with matched value from the alert policy rule
// at the time of creating an alert.
// e.g. "matched-requirements": [{"field": "cpu", "operator": "Gt", "values": [90], "observed-value": 95}]
type AlertReason struct {
	// List of requirements from the alert policy with it's matched value
	MatchedRequirements []*MatchedRequirement `protobuf:"bytes,1,rep,name=MatchedRequirements,json=matched-requirements, omitempty" json:"matched-requirements, omitempty"`
	// Alert Policy ID that matched
	PolicyID string `protobuf:"bytes,2,opt,name=PolicyID,json=alert-policy-id, omitempty,proto3" json:"alert-policy-id, omitempty"`
}

func (m *AlertReason) Reset()                    { *m = AlertReason{} }
func (m *AlertReason) String() string            { return proto.CompactTextString(m) }
func (*AlertReason) ProtoMessage()               {}
func (*AlertReason) Descriptor() ([]byte, []int) { return fileDescriptorAlerts, []int{7} }

func (m *AlertReason) GetMatchedRequirements() []*MatchedRequirement {
	if m != nil {
		return m.MatchedRequirements
	}
	return nil
}

func (m *AlertReason) GetPolicyID() string {
	if m != nil {
		return m.PolicyID
	}
	return ""
}

// Source of an alert; for alerts generated from events, it maps to event.Source
type AlertSource struct {
	//
	Component string `protobuf:"bytes,1,opt,name=Component,json=component, omitempty,proto3" json:"component, omitempty"`
	//
	NodeName string `protobuf:"bytes,2,opt,name=NodeName,json=node-name, omitempty,proto3" json:"node-name, omitempty"`
}

func (m *AlertSource) Reset()                    { *m = AlertSource{} }
func (m *AlertSource) String() string            { return proto.CompactTextString(m) }
func (*AlertSource) ProtoMessage()               {}
func (*AlertSource) Descriptor() ([]byte, []int) { return fileDescriptorAlerts, []int{8} }

func (m *AlertSource) GetComponent() string {
	if m != nil {
		return m.Component
	}
	return ""
}

func (m *AlertSource) GetNodeName() string {
	if m != nil {
		return m.NodeName
	}
	return ""
}

// User can change the state of the alert by changing the spec
type AlertSpec struct {
	//
	State string `protobuf:"bytes,1,opt,name=State,json=state, omitempty,proto3" json:"state, omitempty"`
}

func (m *AlertSpec) Reset()                    { *m = AlertSpec{} }
func (m *AlertSpec) String() string            { return proto.CompactTextString(m) }
func (*AlertSpec) ProtoMessage()               {}
func (*AlertSpec) Descriptor() ([]byte, []int) { return fileDescriptorAlerts, []int{9} }

func (m *AlertSpec) GetState() string {
	if m != nil {
		return m.State
	}
	return ""
}

// Status part of the alert object
type AlertStatus struct {
	// Severity of an alert
	Severity string `protobuf:"bytes,1,opt,name=Severity,json=severity, omitempty,proto3" json:"severity, omitempty"`
	// Alert source or origin
	Source *AlertSource `protobuf:"bytes,2,opt,name=Source,json=source, omitempty" json:"source, omitempty"`
	// Affected object
	ObjectRef api.ObjectRef `protobuf:"bytes,3,opt,name=ObjectRef,json=object-ref, omitempty" json:"object-ref, omitempty"`
	// Message from the alert rule that triggered the alert
	Message string `protobuf:"bytes,4,opt,name=Message,json=message, omitempty,proto3" json:"message, omitempty"`
	// Captures all the requirements from the alert policy rule with matched value.
	// All these requirements must be cleared to auto-resolve an alert.
	Reason AlertReason `protobuf:"bytes,5,opt,name=Reason,json=reason, omitempty" json:"reason, omitempty"`
	// Username and time at which the alert was acknowledged
	Acknowledged *AuditInfo `protobuf:"bytes,6,opt,name=Acknowledged,json=acknowledged, omitempty" json:"acknowledged, omitempty"`
	// Username and time at which the alert was resolved
	Resolved *AuditInfo `protobuf:"bytes,7,opt,name=Resolved,json=resolved, omitempty" json:"resolved, omitempty"`
}

func (m *AlertStatus) Reset()                    { *m = AlertStatus{} }
func (m *AlertStatus) String() string            { return proto.CompactTextString(m) }
func (*AlertStatus) ProtoMessage()               {}
func (*AlertStatus) Descriptor() ([]byte, []int) { return fileDescriptorAlerts, []int{10} }

func (m *AlertStatus) GetSeverity() string {
	if m != nil {
		return m.Severity
	}
	return ""
}

func (m *AlertStatus) GetSource() *AlertSource {
	if m != nil {
		return m.Source
	}
	return nil
}

func (m *AlertStatus) GetObjectRef() api.ObjectRef {
	if m != nil {
		return m.ObjectRef
	}
	return api.ObjectRef{}
}

func (m *AlertStatus) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *AlertStatus) GetReason() AlertReason {
	if m != nil {
		return m.Reason
	}
	return AlertReason{}
}

func (m *AlertStatus) GetAcknowledged() *AuditInfo {
	if m != nil {
		return m.Acknowledged
	}
	return nil
}

func (m *AlertStatus) GetResolved() *AuditInfo {
	if m != nil {
		return m.Resolved
	}
	return nil
}

// AuditInfo captures the user performed the action and the time at which the
// action was performed.
type AuditInfo struct {
	// Name of the user performed some action.
	User string `protobuf:"bytes,1,opt,name=User,json=user, omitempty,proto3" json:"user, omitempty"`
	// Time at which the action was performed.
	Time *api.Timestamp `protobuf:"bytes,2,opt,name=Time,json=time, omitempty" json:"time, omitempty"`
}

func (m *AuditInfo) Reset()                    { *m = AuditInfo{} }
func (m *AuditInfo) String() string            { return proto.CompactTextString(m) }
func (*AuditInfo) ProtoMessage()               {}
func (*AuditInfo) Descriptor() ([]byte, []int) { return fileDescriptorAlerts, []int{11} }

func (m *AuditInfo) GetUser() string {
	if m != nil {
		return m.User
	}
	return ""
}

func (m *AuditInfo) GetTime() *api.Timestamp {
	if m != nil {
		return m.Time
	}
	return nil
}

// AuthConfig contains the configuration for SNMP Trap authentication.
type AuthConfig struct {
	//
	Algo string `protobuf:"bytes,1,opt,name=Algo,json=algo, omitempty,proto3" json:"algo, omitempty"`
	// Password contains the authentication password.
	Password string `protobuf:"bytes,2,opt,name=Password,json=password, omitempty,proto3" json:"password, omitempty"`
}

func (m *AuthConfig) Reset()                    { *m = AuthConfig{} }
func (m *AuthConfig) String() string            { return proto.CompactTextString(m) }
func (*AuthConfig) ProtoMessage()               {}
func (*AuthConfig) Descriptor() ([]byte, []int) { return fileDescriptorAlerts, []int{12} }

func (m *AuthConfig) GetAlgo() string {
	if m != nil {
		return m.Algo
	}
	return ""
}

func (m *AuthConfig) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

// One of the requirement from the expression that was met
type MatchedRequirement struct {
	// Requirement from the alert rule that was met
	Requirement `protobuf:"bytes,1,opt,name=Requirement,json=,inline,embedded=Requirement" json:",inline"`
	// The value at which the requirement was met.
	// same as Requirement.value for operator `Equals` but could vary for other operators
	// e.g. requirement - CPU;Gt;90 could have a matching value 96
	ObservedValue string `protobuf:"bytes,2,opt,name=ObservedValue,json=observed-value, omitempty,proto3" json:"observed-value, omitempty"`
}

func (m *MatchedRequirement) Reset()                    { *m = MatchedRequirement{} }
func (m *MatchedRequirement) String() string            { return proto.CompactTextString(m) }
func (*MatchedRequirement) ProtoMessage()               {}
func (*MatchedRequirement) Descriptor() ([]byte, []int) { return fileDescriptorAlerts, []int{13} }

func (m *MatchedRequirement) GetObservedValue() string {
	if m != nil {
		return m.ObservedValue
	}
	return ""
}

// PrivacyConfig contains the configuration for SNMP Trap encryption.
type PrivacyConfig struct {
	//
	Algo string `protobuf:"bytes,1,opt,name=Algo,json=algo, omitempty,proto3" json:"algo, omitempty"`
	// Password contains the privacy password.
	Password string `protobuf:"bytes,2,opt,name=Password,json=password, omitempty,proto3" json:"password, omitempty"`
}

func (m *PrivacyConfig) Reset()                    { *m = PrivacyConfig{} }
func (m *PrivacyConfig) String() string            { return proto.CompactTextString(m) }
func (*PrivacyConfig) ProtoMessage()               {}
func (*PrivacyConfig) Descriptor() ([]byte, []int) { return fileDescriptorAlerts, []int{14} }

func (m *PrivacyConfig) GetAlgo() string {
	if m != nil {
		return m.Algo
	}
	return ""
}

func (m *PrivacyConfig) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

// Requirement specifies each
// {"field": "Status.Phase", "operator":"Equals", "values":["JOINED"]}
type Requirement struct {
	// name of the field or metric
	FieldOrMetric string `protobuf:"bytes,1,opt,name=FieldOrMetric,json=field-or-metric, omitempty,proto3" json:"field-or-metric, omitempty"`
	//
	Operator string `protobuf:"bytes,2,opt,name=Operator,json=operator, omitempty,proto3" json:"operator, omitempty"`
	// Values contains one or more values corresponding to the field-or-metric. "Equals",
	// "NotEquals", "Gt" and "Lt" operators need a single value. "In" and "NotIn" operators
	// can have one or more values.
	Values []string `protobuf:"bytes,3,rep,name=Values,json=values, omitempty" json:"values, omitempty"`
}

func (m *Requirement) Reset()                    { *m = Requirement{} }
func (m *Requirement) String() string            { return proto.CompactTextString(m) }
func (*Requirement) ProtoMessage()               {}
func (*Requirement) Descriptor() ([]byte, []int) { return fileDescriptorAlerts, []int{15} }

func (m *Requirement) GetFieldOrMetric() string {
	if m != nil {
		return m.FieldOrMetric
	}
	return ""
}

func (m *Requirement) GetOperator() string {
	if m != nil {
		return m.Operator
	}
	return ""
}

func (m *Requirement) GetValues() []string {
	if m != nil {
		return m.Values
	}
	return nil
}

// SNMPTrapServer contains the configuration for sending SNMP traps to a receiver.
type SNMPTrapServer struct {
	// Host where the trap needs to be sent.
	Host string `protobuf:"bytes,1,opt,name=Host,json=host, omitempty,proto3" json:"host, omitempty"`
	// Port on the Host where the trap needs to be sent, default is 162.
	Port string `protobuf:"bytes,2,opt,name=Port,json=port, omitempty,proto3" json:"port, omitempty"`
	//
	Version string `protobuf:"bytes,3,opt,name=Version,json=version, omitempty,proto3" json:"version, omitempty"`
	// CommunityOrUser contains community string for v2c, user for v3.
	CommunityOrUser string `protobuf:"bytes,4,opt,name=CommunityOrUser,json=community-or-user, omitempty,proto3" json:"community-or-user, omitempty"`
	// AuthConfig contains the configuration for authentication, valid only for v3.
	AuthConfig *AuthConfig `protobuf:"bytes,5,opt,name=AuthConfig,json=auth-config, omitempty" json:"auth-config, omitempty"`
	// PrivacyConfig contains the configuration for encryption, valid only for v3.
	PrivacyConfig *PrivacyConfig `protobuf:"bytes,6,opt,name=PrivacyConfig,json=privacy-config, omitempty" json:"privacy-config, omitempty"`
}

func (m *SNMPTrapServer) Reset()                    { *m = SNMPTrapServer{} }
func (m *SNMPTrapServer) String() string            { return proto.CompactTextString(m) }
func (*SNMPTrapServer) ProtoMessage()               {}
func (*SNMPTrapServer) Descriptor() ([]byte, []int) { return fileDescriptorAlerts, []int{16} }

func (m *SNMPTrapServer) GetHost() string {
	if m != nil {
		return m.Host
	}
	return ""
}

func (m *SNMPTrapServer) GetPort() string {
	if m != nil {
		return m.Port
	}
	return ""
}

func (m *SNMPTrapServer) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *SNMPTrapServer) GetCommunityOrUser() string {
	if m != nil {
		return m.CommunityOrUser
	}
	return ""
}

func (m *SNMPTrapServer) GetAuthConfig() *AuthConfig {
	if m != nil {
		return m.AuthConfig
	}
	return nil
}

func (m *SNMPTrapServer) GetPrivacyConfig() *PrivacyConfig {
	if m != nil {
		return m.PrivacyConfig
	}
	return nil
}

func init() {
	proto.RegisterType((*Alert)(nil), "monitoring.Alert")
	proto.RegisterType((*AlertDestination)(nil), "monitoring.AlertDestination")
	proto.RegisterType((*AlertDestinationSpec)(nil), "monitoring.AlertDestinationSpec")
	proto.RegisterType((*AlertDestinationStatus)(nil), "monitoring.AlertDestinationStatus")
	proto.RegisterType((*AlertPolicy)(nil), "monitoring.AlertPolicy")
	proto.RegisterType((*AlertPolicySpec)(nil), "monitoring.AlertPolicySpec")
	proto.RegisterType((*AlertPolicyStatus)(nil), "monitoring.AlertPolicyStatus")
	proto.RegisterType((*AlertReason)(nil), "monitoring.AlertReason")
	proto.RegisterType((*AlertSource)(nil), "monitoring.AlertSource")
	proto.RegisterType((*AlertSpec)(nil), "monitoring.AlertSpec")
	proto.RegisterType((*AlertStatus)(nil), "monitoring.AlertStatus")
	proto.RegisterType((*AuditInfo)(nil), "monitoring.AuditInfo")
	proto.RegisterType((*AuthConfig)(nil), "monitoring.AuthConfig")
	proto.RegisterType((*MatchedRequirement)(nil), "monitoring.MatchedRequirement")
	proto.RegisterType((*PrivacyConfig)(nil), "monitoring.PrivacyConfig")
	proto.RegisterType((*Requirement)(nil), "monitoring.Requirement")
	proto.RegisterType((*SNMPTrapServer)(nil), "monitoring.SNMPTrapServer")
	proto.RegisterEnum("monitoring.AlertSpec_AlertState", AlertSpec_AlertState_name, AlertSpec_AlertState_value)
	proto.RegisterEnum("monitoring.AuthConfig_Algos", AuthConfig_Algos_name, AuthConfig_Algos_value)
	proto.RegisterEnum("monitoring.PrivacyConfig_Algos", PrivacyConfig_Algos_name, PrivacyConfig_Algos_value)
	proto.RegisterEnum("monitoring.Requirement_AllowedOperators", Requirement_AllowedOperators_name, Requirement_AllowedOperators_value)
	proto.RegisterEnum("monitoring.SNMPTrapServer_SNMPVersions", SNMPTrapServer_SNMPVersions_name, SNMPTrapServer_SNMPVersions_value)
}
func (m *Alert) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Alert) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintAlerts(dAtA, i, uint64(m.TypeMeta.Size()))
	n1, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n1
	dAtA[i] = 0x12
	i++
	i = encodeVarintAlerts(dAtA, i, uint64(m.ObjectMeta.Size()))
	n2, err := m.ObjectMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n2
	dAtA[i] = 0x1a
	i++
	i = encodeVarintAlerts(dAtA, i, uint64(m.Spec.Size()))
	n3, err := m.Spec.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n3
	dAtA[i] = 0x22
	i++
	i = encodeVarintAlerts(dAtA, i, uint64(m.Status.Size()))
	n4, err := m.Status.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n4
	return i, nil
}

func (m *AlertDestination) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AlertDestination) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintAlerts(dAtA, i, uint64(m.TypeMeta.Size()))
	n5, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n5
	dAtA[i] = 0x12
	i++
	i = encodeVarintAlerts(dAtA, i, uint64(m.ObjectMeta.Size()))
	n6, err := m.ObjectMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n6
	dAtA[i] = 0x1a
	i++
	i = encodeVarintAlerts(dAtA, i, uint64(m.Spec.Size()))
	n7, err := m.Spec.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n7
	dAtA[i] = 0x22
	i++
	i = encodeVarintAlerts(dAtA, i, uint64(m.Status.Size()))
	n8, err := m.Status.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n8
	return i, nil
}

func (m *AlertDestinationSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AlertDestinationSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Default {
		dAtA[i] = 0x8
		i++
		if m.Default {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.EmailList) > 0 {
		for _, s := range m.EmailList {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.SNMPTrapServers) > 0 {
		for _, msg := range m.SNMPTrapServers {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintAlerts(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *AlertDestinationStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AlertDestinationStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TotalNotificationsSent != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(m.TotalNotificationsSent))
	}
	return i, nil
}

func (m *AlertPolicy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AlertPolicy) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintAlerts(dAtA, i, uint64(m.TypeMeta.Size()))
	n9, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n9
	dAtA[i] = 0x12
	i++
	i = encodeVarintAlerts(dAtA, i, uint64(m.ObjectMeta.Size()))
	n10, err := m.ObjectMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n10
	dAtA[i] = 0x1a
	i++
	i = encodeVarintAlerts(dAtA, i, uint64(m.Spec.Size()))
	n11, err := m.Spec.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n11
	dAtA[i] = 0x22
	i++
	i = encodeVarintAlerts(dAtA, i, uint64(m.Status.Size()))
	n12, err := m.Status.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n12
	return i, nil
}

func (m *AlertPolicySpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AlertPolicySpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Resource) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(len(m.Resource)))
		i += copy(dAtA[i:], m.Resource)
	}
	if len(m.Severity) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(len(m.Severity)))
		i += copy(dAtA[i:], m.Severity)
	}
	if len(m.Message) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	if len(m.Requirements) > 0 {
		for _, msg := range m.Requirements {
			dAtA[i] = 0x22
			i++
			i = encodeVarintAlerts(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.PersistenceDuration) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(len(m.PersistenceDuration)))
		i += copy(dAtA[i:], m.PersistenceDuration)
	}
	if len(m.ClearDuration) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(len(m.ClearDuration)))
		i += copy(dAtA[i:], m.ClearDuration)
	}
	if m.Enable {
		dAtA[i] = 0x38
		i++
		if m.Enable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.AutoResolve {
		dAtA[i] = 0x40
		i++
		if m.AutoResolve {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Destinations) > 0 {
		for _, s := range m.Destinations {
			dAtA[i] = 0x4a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *AlertPolicyStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AlertPolicyStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TotalHits != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(m.TotalHits))
	}
	if m.OpenAlerts != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(m.OpenAlerts))
	}
	if m.AcknowledgedAlerts != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(m.AcknowledgedAlerts))
	}
	return i, nil
}

func (m *AlertReason) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AlertReason) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.MatchedRequirements) > 0 {
		for _, msg := range m.MatchedRequirements {
			dAtA[i] = 0xa
			i++
			i = encodeVarintAlerts(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.PolicyID) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(len(m.PolicyID)))
		i += copy(dAtA[i:], m.PolicyID)
	}
	return i, nil
}

func (m *AlertSource) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AlertSource) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Component) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(len(m.Component)))
		i += copy(dAtA[i:], m.Component)
	}
	if len(m.NodeName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(len(m.NodeName)))
		i += copy(dAtA[i:], m.NodeName)
	}
	return i, nil
}

func (m *AlertSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AlertSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.State) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(len(m.State)))
		i += copy(dAtA[i:], m.State)
	}
	return i, nil
}

func (m *AlertStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AlertStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Severity) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(len(m.Severity)))
		i += copy(dAtA[i:], m.Severity)
	}
	if m.Source != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(m.Source.Size()))
		n13, err := m.Source.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	dAtA[i] = 0x1a
	i++
	i = encodeVarintAlerts(dAtA, i, uint64(m.ObjectRef.Size()))
	n14, err := m.ObjectRef.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n14
	if len(m.Message) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	dAtA[i] = 0x2a
	i++
	i = encodeVarintAlerts(dAtA, i, uint64(m.Reason.Size()))
	n15, err := m.Reason.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n15
	if m.Acknowledged != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(m.Acknowledged.Size()))
		n16, err := m.Acknowledged.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	if m.Resolved != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(m.Resolved.Size()))
		n17, err := m.Resolved.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	return i, nil
}

func (m *AuditInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuditInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.User) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(len(m.User)))
		i += copy(dAtA[i:], m.User)
	}
	if m.Time != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(m.Time.Size()))
		n18, err := m.Time.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	return i, nil
}

func (m *AuthConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuthConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Algo) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(len(m.Algo)))
		i += copy(dAtA[i:], m.Algo)
	}
	if len(m.Password) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(len(m.Password)))
		i += copy(dAtA[i:], m.Password)
	}
	return i, nil
}

func (m *MatchedRequirement) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MatchedRequirement) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintAlerts(dAtA, i, uint64(m.Requirement.Size()))
	n19, err := m.Requirement.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n19
	if len(m.ObservedValue) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(len(m.ObservedValue)))
		i += copy(dAtA[i:], m.ObservedValue)
	}
	return i, nil
}

func (m *PrivacyConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PrivacyConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Algo) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(len(m.Algo)))
		i += copy(dAtA[i:], m.Algo)
	}
	if len(m.Password) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(len(m.Password)))
		i += copy(dAtA[i:], m.Password)
	}
	return i, nil
}

func (m *Requirement) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Requirement) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.FieldOrMetric) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(len(m.FieldOrMetric)))
		i += copy(dAtA[i:], m.FieldOrMetric)
	}
	if len(m.Operator) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(len(m.Operator)))
		i += copy(dAtA[i:], m.Operator)
	}
	if len(m.Values) > 0 {
		for _, s := range m.Values {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *SNMPTrapServer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SNMPTrapServer) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Host) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(len(m.Host)))
		i += copy(dAtA[i:], m.Host)
	}
	if len(m.Port) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(len(m.Port)))
		i += copy(dAtA[i:], m.Port)
	}
	if len(m.Version) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(len(m.Version)))
		i += copy(dAtA[i:], m.Version)
	}
	if len(m.CommunityOrUser) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(len(m.CommunityOrUser)))
		i += copy(dAtA[i:], m.CommunityOrUser)
	}
	if m.AuthConfig != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(m.AuthConfig.Size()))
		n20, err := m.AuthConfig.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	if m.PrivacyConfig != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(m.PrivacyConfig.Size()))
		n21, err := m.PrivacyConfig.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	return i, nil
}

func encodeVarintAlerts(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Alert) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovAlerts(uint64(l))
	l = m.ObjectMeta.Size()
	n += 1 + l + sovAlerts(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovAlerts(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovAlerts(uint64(l))
	return n
}

func (m *AlertDestination) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovAlerts(uint64(l))
	l = m.ObjectMeta.Size()
	n += 1 + l + sovAlerts(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovAlerts(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovAlerts(uint64(l))
	return n
}

func (m *AlertDestinationSpec) Size() (n int) {
	var l int
	_ = l
	if m.Default {
		n += 2
	}
	if len(m.EmailList) > 0 {
		for _, s := range m.EmailList {
			l = len(s)
			n += 1 + l + sovAlerts(uint64(l))
		}
	}
	if len(m.SNMPTrapServers) > 0 {
		for _, e := range m.SNMPTrapServers {
			l = e.Size()
			n += 1 + l + sovAlerts(uint64(l))
		}
	}
	return n
}

func (m *AlertDestinationStatus) Size() (n int) {
	var l int
	_ = l
	if m.TotalNotificationsSent != 0 {
		n += 1 + sovAlerts(uint64(m.TotalNotificationsSent))
	}
	return n
}

func (m *AlertPolicy) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovAlerts(uint64(l))
	l = m.ObjectMeta.Size()
	n += 1 + l + sovAlerts(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovAlerts(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovAlerts(uint64(l))
	return n
}

func (m *AlertPolicySpec) Size() (n int) {
	var l int
	_ = l
	l = len(m.Resource)
	if l > 0 {
		n += 1 + l + sovAlerts(uint64(l))
	}
	l = len(m.Severity)
	if l > 0 {
		n += 1 + l + sovAlerts(uint64(l))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovAlerts(uint64(l))
	}
	if len(m.Requirements) > 0 {
		for _, e := range m.Requirements {
			l = e.Size()
			n += 1 + l + sovAlerts(uint64(l))
		}
	}
	l = len(m.PersistenceDuration)
	if l > 0 {
		n += 1 + l + sovAlerts(uint64(l))
	}
	l = len(m.ClearDuration)
	if l > 0 {
		n += 1 + l + sovAlerts(uint64(l))
	}
	if m.Enable {
		n += 2
	}
	if m.AutoResolve {
		n += 2
	}
	if len(m.Destinations) > 0 {
		for _, s := range m.Destinations {
			l = len(s)
			n += 1 + l + sovAlerts(uint64(l))
		}
	}
	return n
}

func (m *AlertPolicyStatus) Size() (n int) {
	var l int
	_ = l
	if m.TotalHits != 0 {
		n += 1 + sovAlerts(uint64(m.TotalHits))
	}
	if m.OpenAlerts != 0 {
		n += 1 + sovAlerts(uint64(m.OpenAlerts))
	}
	if m.AcknowledgedAlerts != 0 {
		n += 1 + sovAlerts(uint64(m.AcknowledgedAlerts))
	}
	return n
}

func (m *AlertReason) Size() (n int) {
	var l int
	_ = l
	if len(m.MatchedRequirements) > 0 {
		for _, e := range m.MatchedRequirements {
			l = e.Size()
			n += 1 + l + sovAlerts(uint64(l))
		}
	}
	l = len(m.PolicyID)
	if l > 0 {
		n += 1 + l + sovAlerts(uint64(l))
	}
	return n
}

func (m *AlertSource) Size() (n int) {
	var l int
	_ = l
	l = len(m.Component)
	if l > 0 {
		n += 1 + l + sovAlerts(uint64(l))
	}
	l = len(m.NodeName)
	if l > 0 {
		n += 1 + l + sovAlerts(uint64(l))
	}
	return n
}

func (m *AlertSpec) Size() (n int) {
	var l int
	_ = l
	l = len(m.State)
	if l > 0 {
		n += 1 + l + sovAlerts(uint64(l))
	}
	return n
}

func (m *AlertStatus) Size() (n int) {
	var l int
	_ = l
	l = len(m.Severity)
	if l > 0 {
		n += 1 + l + sovAlerts(uint64(l))
	}
	if m.Source != nil {
		l = m.Source.Size()
		n += 1 + l + sovAlerts(uint64(l))
	}
	l = m.ObjectRef.Size()
	n += 1 + l + sovAlerts(uint64(l))
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovAlerts(uint64(l))
	}
	l = m.Reason.Size()
	n += 1 + l + sovAlerts(uint64(l))
	if m.Acknowledged != nil {
		l = m.Acknowledged.Size()
		n += 1 + l + sovAlerts(uint64(l))
	}
	if m.Resolved != nil {
		l = m.Resolved.Size()
		n += 1 + l + sovAlerts(uint64(l))
	}
	return n
}

func (m *AuditInfo) Size() (n int) {
	var l int
	_ = l
	l = len(m.User)
	if l > 0 {
		n += 1 + l + sovAlerts(uint64(l))
	}
	if m.Time != nil {
		l = m.Time.Size()
		n += 1 + l + sovAlerts(uint64(l))
	}
	return n
}

func (m *AuthConfig) Size() (n int) {
	var l int
	_ = l
	l = len(m.Algo)
	if l > 0 {
		n += 1 + l + sovAlerts(uint64(l))
	}
	l = len(m.Password)
	if l > 0 {
		n += 1 + l + sovAlerts(uint64(l))
	}
	return n
}

func (m *MatchedRequirement) Size() (n int) {
	var l int
	_ = l
	l = m.Requirement.Size()
	n += 1 + l + sovAlerts(uint64(l))
	l = len(m.ObservedValue)
	if l > 0 {
		n += 1 + l + sovAlerts(uint64(l))
	}
	return n
}

func (m *PrivacyConfig) Size() (n int) {
	var l int
	_ = l
	l = len(m.Algo)
	if l > 0 {
		n += 1 + l + sovAlerts(uint64(l))
	}
	l = len(m.Password)
	if l > 0 {
		n += 1 + l + sovAlerts(uint64(l))
	}
	return n
}

func (m *Requirement) Size() (n int) {
	var l int
	_ = l
	l = len(m.FieldOrMetric)
	if l > 0 {
		n += 1 + l + sovAlerts(uint64(l))
	}
	l = len(m.Operator)
	if l > 0 {
		n += 1 + l + sovAlerts(uint64(l))
	}
	if len(m.Values) > 0 {
		for _, s := range m.Values {
			l = len(s)
			n += 1 + l + sovAlerts(uint64(l))
		}
	}
	return n
}

func (m *SNMPTrapServer) Size() (n int) {
	var l int
	_ = l
	l = len(m.Host)
	if l > 0 {
		n += 1 + l + sovAlerts(uint64(l))
	}
	l = len(m.Port)
	if l > 0 {
		n += 1 + l + sovAlerts(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovAlerts(uint64(l))
	}
	l = len(m.CommunityOrUser)
	if l > 0 {
		n += 1 + l + sovAlerts(uint64(l))
	}
	if m.AuthConfig != nil {
		l = m.AuthConfig.Size()
		n += 1 + l + sovAlerts(uint64(l))
	}
	if m.PrivacyConfig != nil {
		l = m.PrivacyConfig.Size()
		n += 1 + l + sovAlerts(uint64(l))
	}
	return n
}

func sovAlerts(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozAlerts(x uint64) (n int) {
	return sovAlerts(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Alert) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAlerts
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Alert: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Alert: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAlerts(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAlerts
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AlertDestination) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAlerts
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AlertDestination: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AlertDestination: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAlerts(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAlerts
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AlertDestinationSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAlerts
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AlertDestinationSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AlertDestinationSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Default", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Default = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EmailList", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EmailList = append(m.EmailList, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SNMPTrapServers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SNMPTrapServers = append(m.SNMPTrapServers, &SNMPTrapServer{})
			if err := m.SNMPTrapServers[len(m.SNMPTrapServers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAlerts(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAlerts
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AlertDestinationStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAlerts
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AlertDestinationStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AlertDestinationStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalNotificationsSent", wireType)
			}
			m.TotalNotificationsSent = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalNotificationsSent |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAlerts(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAlerts
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AlertPolicy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAlerts
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AlertPolicy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AlertPolicy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAlerts(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAlerts
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AlertPolicySpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAlerts
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AlertPolicySpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AlertPolicySpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resource", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Resource = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Severity", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Severity = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Requirements", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Requirements = append(m.Requirements, Requirement{})
			if err := m.Requirements[len(m.Requirements)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PersistenceDuration", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PersistenceDuration = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClearDuration", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClearDuration = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enable = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoResolve", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AutoResolve = bool(v != 0)
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Destinations", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Destinations = append(m.Destinations, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAlerts(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAlerts
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AlertPolicyStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAlerts
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AlertPolicyStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AlertPolicyStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalHits", wireType)
			}
			m.TotalHits = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalHits |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenAlerts", wireType)
			}
			m.OpenAlerts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OpenAlerts |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AcknowledgedAlerts", wireType)
			}
			m.AcknowledgedAlerts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AcknowledgedAlerts |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAlerts(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAlerts
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AlertReason) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAlerts
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AlertReason: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AlertReason: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchedRequirements", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MatchedRequirements = append(m.MatchedRequirements, &MatchedRequirement{})
			if err := m.MatchedRequirements[len(m.MatchedRequirements)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PolicyID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PolicyID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAlerts(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAlerts
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AlertSource) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAlerts
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AlertSource: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AlertSource: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Component", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Component = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAlerts(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAlerts
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AlertSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAlerts
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AlertSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AlertSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAlerts(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAlerts
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AlertStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAlerts
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AlertStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AlertStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Severity", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Severity = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Source == nil {
				m.Source = &AlertSource{}
			}
			if err := m.Source.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectRef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectRef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Reason.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Acknowledged", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Acknowledged == nil {
				m.Acknowledged = &AuditInfo{}
			}
			if err := m.Acknowledged.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resolved", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Resolved == nil {
				m.Resolved = &AuditInfo{}
			}
			if err := m.Resolved.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAlerts(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAlerts
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuditInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAlerts
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuditInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuditInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.User = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Time == nil {
				m.Time = &api.Timestamp{}
			}
			if err := m.Time.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAlerts(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAlerts
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuthConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAlerts
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuthConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuthConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Algo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Algo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Password", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Password = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAlerts(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAlerts
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MatchedRequirement) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAlerts
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MatchedRequirement: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MatchedRequirement: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Requirement", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Requirement.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObservedValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ObservedValue = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAlerts(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAlerts
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PrivacyConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAlerts
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PrivacyConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PrivacyConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Algo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Algo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Password", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Password = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAlerts(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAlerts
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Requirement) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAlerts
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Requirement: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Requirement: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FieldOrMetric", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FieldOrMetric = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Operator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Values", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Values = append(m.Values, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAlerts(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAlerts
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SNMPTrapServer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAlerts
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SNMPTrapServer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SNMPTrapServer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Host", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Host = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Port = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommunityOrUser", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CommunityOrUser = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AuthConfig == nil {
				m.AuthConfig = &AuthConfig{}
			}
			if err := m.AuthConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrivacyConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PrivacyConfig == nil {
				m.PrivacyConfig = &PrivacyConfig{}
			}
			if err := m.PrivacyConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAlerts(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAlerts
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipAlerts(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowAlerts
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthAlerts
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowAlerts
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipAlerts(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthAlerts = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowAlerts   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("alerts.proto", fileDescriptorAlerts) }

var fileDescriptorAlerts = []byte{
	// 1880 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x58, 0xcf, 0x6f, 0x23, 0x49,
	0x15, 0x4e, 0x3b, 0x8e, 0x63, 0x57, 0x92, 0x8d, 0xa7, 0xb2, 0xc9, 0xd8, 0x99, 0x4c, 0x1c, 0x7a,
	0x67, 0x61, 0x10, 0xdb, 0xb6, 0x36, 0xcb, 0x0e, 0xcb, 0x6f, 0xd9, 0xb1, 0x77, 0x26, 0x43, 0x12,
	0x5b, 0x71, 0x26, 0x0b, 0xec, 0x85, 0x4e, 0x77, 0xd9, 0x69, 0xb6, 0xbb, 0xaa, 0xb7, 0xab, 0xda,
	0x51, 0x84, 0x38, 0x26, 0x07, 0xe0, 0xca, 0x85, 0x0b, 0xf7, 0xdc, 0x11, 0x67, 0x6e, 0x23, 0xb8,
	0xac, 0xe6, 0x0f, 0x88, 0x60, 0x90, 0x40, 0xca, 0x1f, 0xc0, 0x0d, 0x09, 0x55, 0x75, 0xb5, 0xdd,
	0x65, 0xb7, 0x33, 0xec, 0x48, 0x88, 0x39, 0x25, 0xfd, 0xbd, 0x57, 0x5f, 0x55, 0xbd, 0xaa, 0xf7,
	0xbd, 0x57, 0x06, 0x8b, 0xa6, 0x8b, 0x02, 0x46, 0xab, 0x7e, 0x40, 0x18, 0x81, 0xc0, 0x23, 0xd8,
	0x61, 0x24, 0x70, 0x70, 0x7f, 0x7d, 0xa3, 0x4f, 0x48, 0xdf, 0x45, 0x35, 0xd3, 0x77, 0x6a, 0x26,
	0xc6, 0x84, 0x99, 0xcc, 0x21, 0x58, 0x7a, 0xae, 0xb7, 0xfa, 0x0e, 0x3b, 0x0d, 0x4f, 0xaa, 0x16,
	0xf1, 0x6a, 0x3e, 0xc2, 0xd4, 0xc4, 0x36, 0xa9, 0xd1, 0xb3, 0xda, 0x00, 0x61, 0xc7, 0x42, 0xb5,
	0x90, 0x39, 0x2e, 0xe5, 0x43, 0xfb, 0x08, 0x27, 0x47, 0xd7, 0x1c, 0x6c, 0xb9, 0xa1, 0x8d, 0x62,
	0x1a, 0x23, 0x41, 0xd3, 0x27, 0x7d, 0x52, 0x13, 0xf0, 0x49, 0xd8, 0x13, 0x5f, 0xe2, 0x43, 0xfc,
	0x27, 0xdd, 0xdf, 0x9d, 0x32, 0x2b, 0x5f, 0xa3, 0x87, 0x98, 0x29, 0xdd, 0xaa, 0xb7, 0xb8, 0x09,
	0x0f, 0x5a, 0x43, 0x03, 0x84, 0xe3, 0x6d, 0xeb, 0x7f, 0xce, 0x80, 0xb9, 0x3a, 0x8f, 0x03, 0x7c,
	0x04, 0xb4, 0xa3, 0x92, 0xb6, 0xa5, 0x3d, 0x5c, 0xd8, 0x5e, 0xaa, 0x9a, 0xbe, 0x53, 0x3d, 0x3a,
	0xf7, 0xd1, 0x3e, 0x62, 0x66, 0x63, 0xe5, 0xf9, 0x75, 0x65, 0xe6, 0x8b, 0xeb, 0x8a, 0x76, 0x73,
	0x5d, 0x99, 0x7f, 0xcf, 0xc1, 0xae, 0x83, 0xd1, 0x61, 0xfc, 0x0f, 0x7c, 0x02, 0xb4, 0x76, 0x29,
	0x23, 0xc6, 0x2d, 0x8b, 0x71, 0xed, 0x93, 0x9f, 0x23, 0x8b, 0x89, 0x91, 0xf7, 0x12, 0x23, 0x97,
	0xf9, 0x2a, 0xdf, 0xdb, 0x22, 0x9e, 0xc3, 0x90, 0xe7, 0xb3, 0xf3, 0xc3, 0x71, 0x00, 0xee, 0x83,
	0x6c, 0xd7, 0x47, 0x56, 0x69, 0x56, 0x90, 0xad, 0x56, 0x47, 0x27, 0x52, 0x15, 0x4b, 0xe4, 0xc6,
	0xc6, 0x5d, 0x4e, 0xc9, 0xe9, 0xa8, 0x8f, 0x2c, 0x85, 0x6e, 0x0c, 0x80, 0xcf, 0x40, 0xae, 0xcb,
	0x4c, 0x16, 0xd2, 0x52, 0x56, 0x10, 0xde, 0x9d, 0x24, 0x14, 0xe6, 0x46, 0x59, 0x52, 0xde, 0xa1,
	0xe2, 0x3b, 0x49, 0x3a, 0x09, 0x7d, 0xa7, 0xfc, 0xe2, 0xa2, 0xbc, 0x0a, 0x16, 0x6a, 0xbf, 0x68,
	0x57, 0x8f, 0x10, 0x36, 0x31, 0xfb, 0x25, 0xcc, 0x45, 0x37, 0x49, 0xff, 0x57, 0x06, 0x14, 0x05,
	0x71, 0x13, 0x51, 0xe6, 0x60, 0x71, 0xee, 0x6f, 0x40, 0x5c, 0x7f, 0xac, 0xc4, 0x75, 0x6b, 0x22,
	0x0c, 0x89, 0xd5, 0x7e, 0xc9, 0x10, 0xff, 0x6c, 0x2c, 0xc4, 0xfa, 0xad, 0xdc, 0xaf, 0x13, 0xed,
	0x07, 0x2f, 0x2e, 0xca, 0x5b, 0x6a, 0xb4, 0xef, 0x98, 0x63, 0xc4, 0x54, 0xff, 0x6d, 0x06, 0xbc,
	0x9d, 0xb6, 0x15, 0xf8, 0x5d, 0x30, 0xdf, 0x44, 0x3d, 0x33, 0x74, 0x99, 0x38, 0x82, 0x7c, 0x63,
	0xed, 0xe6, 0xba, 0x02, 0xed, 0x08, 0x4a, 0x4e, 0x9d, 0x82, 0xc1, 0xc7, 0xa0, 0xd0, 0xf2, 0x4c,
	0xc7, 0xdd, 0x73, 0x28, 0x2b, 0x65, 0xb6, 0x66, 0x1f, 0x16, 0x1a, 0xf7, 0x9f, 0x47, 0x41, 0x5f,
	0x45, 0xdc, 0x60, 0xb8, 0x0e, 0x55, 0x58, 0xd2, 0x61, 0x78, 0x06, 0x96, 0xbb, 0x07, 0xfb, 0x9d,
	0xa3, 0xc0, 0xf4, 0xbb, 0x28, 0x18, 0xa0, 0x80, 0x96, 0x66, 0xb7, 0x66, 0x1f, 0x2e, 0x6c, 0xaf,
	0x27, 0xe3, 0xa5, 0xba, 0x34, 0x1e, 0xc8, 0xa9, 0x36, 0x28, 0xf6, 0x7c, 0x83, 0x05, 0xa6, 0x6f,
	0xd0, 0x68, 0x70, 0x72, 0xc6, 0x5b, 0xad, 0xfa, 0xaf, 0x34, 0xb0, 0x96, 0x7e, 0x0c, 0xd0, 0x07,
	0x6b, 0x8c, 0x30, 0xd3, 0x3d, 0x20, 0xcc, 0xe9, 0x39, 0x56, 0x14, 0xc8, 0x2e, 0xc2, 0x51, 0xa0,
	0xe6, 0x1a, 0xdf, 0x90, 0xd3, 0xbf, 0x23, 0xbc, 0x0c, 0x9c, 0x74, 0x33, 0x28, 0xc2, 0xca, 0xbe,
	0xff, 0x1b, 0x27, 0xfd, 0xef, 0x19, 0xb0, 0x20, 0x16, 0xd3, 0x21, 0xae, 0x63, 0x9d, 0xbf, 0x01,
	0x89, 0xd1, 0x55, 0x12, 0xe3, 0xde, 0xc4, 0xe5, 0x8d, 0x16, 0xfa, 0x25, 0x73, 0xe2, 0xd3, 0xb1,
	0x9c, 0xb8, 0x3f, 0x8d, 0xf6, 0x75, 0xd2, 0x61, 0xeb, 0xc5, 0x45, 0x79, 0x43, 0x4d, 0x87, 0x25,
	0x73, 0xc8, 0xe9, 0x20, 0xaa, 0xff, 0x63, 0x0e, 0x2c, 0x8f, 0x2d, 0x1e, 0xfe, 0x00, 0xe4, 0x0f,
	0x11, 0x25, 0x61, 0x60, 0x21, 0x11, 0xf0, 0x42, 0xe3, 0xee, 0xcd, 0x75, 0x65, 0x25, 0x90, 0x58,
	0x72, 0xce, 0x34, 0x10, 0xda, 0x20, 0xdf, 0x45, 0x03, 0x14, 0x38, 0xec, 0x5c, 0x04, 0xbe, 0xd0,
	0xf8, 0xfe, 0xd5, 0x65, 0x79, 0xb3, 0xcb, 0x82, 0x16, 0x0e, 0xbd, 0x87, 0x55, 0x59, 0x51, 0x62,
	0x9f, 0x3d, 0x34, 0x40, 0xee, 0xd7, 0xe5, 0xfd, 0x59, 0xa1, 0x12, 0x55, 0x66, 0x49, 0x01, 0xe1,
	0x0f, 0xc1, 0xfc, 0x3e, 0xa2, 0xd4, 0xec, 0x23, 0x71, 0x20, 0x85, 0xc6, 0xba, 0xa4, 0x80, 0x5e,
	0x04, 0x2b, 0xf9, 0x3a, 0x89, 0xc1, 0x3e, 0x58, 0x3c, 0x44, 0x9f, 0x87, 0x4e, 0x80, 0x3c, 0xbe,
	0x9e, 0x52, 0x56, 0xe4, 0x98, 0x22, 0xfb, 0x09, 0x7b, 0xa3, 0x22, 0x23, 0x7f, 0x37, 0x48, 0x0c,
	0x4a, 0xce, 0x31, 0xcd, 0x00, 0x4d, 0xb0, 0xd2, 0x41, 0x01, 0x75, 0x28, 0x43, 0xd8, 0x42, 0xcd,
	0x30, 0x10, 0x37, 0xbe, 0x34, 0x27, 0x56, 0xfd, 0xce, 0xcd, 0x75, 0xa5, 0xe2, 0x8f, 0xcc, 0x86,
	0x2d, 0xed, 0x49, 0xea, 0x57, 0x39, 0xc0, 0x36, 0x58, 0xda, 0x71, 0x91, 0x19, 0x0c, 0xc9, 0x73,
	0x82, 0xfc, 0xfe, 0xcd, 0x75, 0xa5, 0x6c, 0x71, 0x43, 0x2a, 0xed, 0x74, 0x13, 0xfc, 0x08, 0xe4,
	0x5a, 0xd8, 0x3c, 0x71, 0x51, 0x69, 0x5e, 0x08, 0xe1, 0x2a, 0xbf, 0x73, 0x48, 0x20, 0xca, 0x9d,
	0x9b, 0x80, 0xe0, 0x2e, 0x58, 0xa8, 0x87, 0x8c, 0xf0, 0x1b, 0xe4, 0x0e, 0x50, 0x29, 0x2f, 0x86,
	0xdf, 0xe3, 0x81, 0x33, 0x43, 0x46, 0x8c, 0x20, 0xc2, 0x95, 0xc0, 0x4d, 0x31, 0xc0, 0xa7, 0x60,
	0x31, 0xa9, 0xdb, 0xa5, 0x82, 0x10, 0x55, 0xc1, 0x65, 0x27, 0x70, 0x85, 0x6b, 0x8a, 0x41, 0xff,
	0x4d, 0x06, 0xdc, 0x99, 0x48, 0x27, 0xae, 0xd9, 0x47, 0x5c, 0x8b, 0x9e, 0x38, 0x8c, 0x4a, 0x25,
	0x1b, 0x6a, 0x76, 0x24, 0x52, 0xa7, 0x8e, 0x7a, 0xca, 0xe9, 0x30, 0x7c, 0x0a, 0x40, 0xdb, 0x47,
	0x58, 0xcc, 0x40, 0xc5, 0xad, 0x9f, 0x6b, 0x6c, 0x4a, 0xa6, 0x35, 0xe2, 0x23, 0x6c, 0x44, 0x45,
	0x3f, 0x49, 0x35, 0x05, 0x87, 0x27, 0x00, 0xd6, 0xad, 0xcf, 0x30, 0x39, 0x73, 0x91, 0xdd, 0x47,
	0xb6, 0xe4, 0x9c, 0x15, 0x9c, 0x5f, 0x95, 0x9c, 0x9b, 0x66, 0xc2, 0x23, 0x85, 0xfb, 0x15, 0x76,
	0xfd, 0x9f, 0x9a, 0x54, 0xd7, 0x43, 0x64, 0x52, 0x82, 0xe1, 0x85, 0x06, 0x56, 0xf6, 0x4d, 0x66,
	0x9d, 0x22, 0x5b, 0x49, 0x0a, 0x4d, 0x24, 0xc5, 0x66, 0x32, 0x29, 0x26, 0xdd, 0x1a, 0x5f, 0x93,
	0xab, 0xaa, 0x78, 0x91, 0xcd, 0x98, 0x96, 0x23, 0xaf, 0x72, 0x80, 0x1d, 0x90, 0x8f, 0x0e, 0x68,
	0xb7, 0x29, 0xb5, 0x43, 0x97, 0xdc, 0xeb, 0x62, 0x13, 0x86, 0x2f, 0xac, 0x86, 0x63, 0x27, 0x69,
	0x6f, 0xb1, 0xe9, 0xbf, 0x8b, 0x77, 0xda, 0x15, 0x42, 0x05, 0x5b, 0xa0, 0xb0, 0x43, 0x3c, 0x9f,
	0xe0, 0xb8, 0x78, 0x15, 0x1a, 0x1b, 0x72, 0x8a, 0xb7, 0xad, 0xd8, 0x90, 0x24, 0x4f, 0x45, 0x61,
	0x13, 0xe4, 0x0f, 0x88, 0x8d, 0x0e, 0x4c, 0x0f, 0xc9, 0x85, 0x0e, 0x59, 0x30, 0xb1, 0x91, 0x81,
	0x4d, 0x4f, 0xb9, 0xe4, 0xa9, 0xa8, 0xfe, 0x7b, 0x0d, 0x14, 0x86, 0xcd, 0x2a, 0xfc, 0x29, 0x98,
	0xe3, 0xf7, 0x32, 0x56, 0xdd, 0x6f, 0x5f, 0x5d, 0x96, 0xef, 0xc7, 0xaa, 0x39, 0xf4, 0x1a, 0xf5,
	0xa2, 0x28, 0x16, 0xcd, 0x22, 0x57, 0x7e, 0x65, 0xb6, 0x09, 0x44, 0x7f, 0x04, 0xc0, 0x68, 0x20,
	0xcc, 0x83, 0x6c, 0xbb, 0xd3, 0x3a, 0x28, 0xce, 0xc0, 0x45, 0x90, 0x3f, 0x6c, 0x75, 0xdb, 0x7b,
	0xc7, 0xad, 0x66, 0x51, 0x83, 0x45, 0xb0, 0x58, 0xdf, 0xf9, 0xd1, 0x41, 0xfb, 0x93, 0xbd, 0x56,
	0xf3, 0x71, 0xab, 0x59, 0xcc, 0xe8, 0xff, 0xce, 0xc6, 0xe1, 0x8b, 0x32, 0x26, 0x29, 0xee, 0xda,
	0xff, 0x4c, 0xdc, 0x79, 0x33, 0x1e, 0x15, 0xa0, 0xcc, 0xb4, 0x66, 0x5c, 0x98, 0x45, 0x3d, 0xd4,
	0x44, 0x3d, 0x9c, 0xa8, 0x4d, 0x93, 0x10, 0xfc, 0x04, 0x14, 0xa2, 0xea, 0x7f, 0x88, 0x7a, 0xb2,
	0x8c, 0xbf, 0x95, 0xe8, 0x09, 0x0e, 0x51, 0x4f, 0xa4, 0x3f, 0x97, 0xf9, 0x55, 0x22, 0x20, 0x23,
	0x40, 0x3d, 0x25, 0xfd, 0x53, 0xe1, 0x64, 0x31, 0xca, 0xbe, 0x56, 0x31, 0x7a, 0x06, 0x72, 0x51,
	0x26, 0x8a, 0xb2, 0x90, 0xb6, 0xe1, 0xc8, 0x3c, 0x6a, 0x00, 0x02, 0xf1, 0xad, 0x6c, 0x78, 0x02,
	0x82, 0x08, 0x2c, 0x26, 0xa5, 0x44, 0x94, 0x85, 0xf1, 0xb7, 0x52, 0x68, 0x3b, 0x6c, 0x17, 0xf7,
	0x88, 0xa8, 0x70, 0x9a, 0x10, 0xea, 0xc4, 0x10, 0x55, 0xa8, 0xd3, 0x0d, 0xf0, 0x27, 0x51, 0xc7,
	0xe0, 0x0e, 0x90, 0x2d, 0xea, 0xc5, 0xd4, 0x29, 0xee, 0xc5, 0x37, 0x41, 0xaa, 0xbd, 0x3d, 0xd1,
	0x4c, 0x8c, 0x81, 0xfa, 0xaf, 0x79, 0x86, 0xc4, 0xe3, 0xe1, 0x23, 0x90, 0x7d, 0x46, 0x51, 0x10,
	0xb7, 0x25, 0x92, 0x6d, 0x39, 0xa4, 0x28, 0x50, 0xba, 0xac, 0x31, 0x00, 0x7e, 0x0c, 0xb2, 0x47,
	0x8e, 0x17, 0xdf, 0xa6, 0xe8, 0xcc, 0x39, 0x40, 0x99, 0xe9, 0xf9, 0x23, 0x1e, 0xe6, 0xa8, 0x49,
	0x3b, 0x0e, 0xe8, 0x7f, 0xd2, 0x00, 0xa8, 0x87, 0xec, 0x74, 0x87, 0xe0, 0x9e, 0xd3, 0xe7, 0x1d,
	0x61, 0xdd, 0xed, 0x13, 0xb9, 0x9c, 0x6f, 0x5e, 0x5d, 0x96, 0xcb, 0xc3, 0x7c, 0x1d, 0x7a, 0x55,
	0xb9, 0x0b, 0x8d, 0x73, 0x60, 0xd9, 0x74, 0xfb, 0x44, 0x99, 0x63, 0x0c, 0x80, 0x0d, 0x90, 0xef,
	0x98, 0x94, 0x9e, 0x91, 0xc0, 0x96, 0xca, 0x32, 0x8c, 0x9a, 0x2f, 0x71, 0x25, 0x6a, 0x29, 0xa0,
	0xbe, 0xce, 0x9f, 0xe9, 0x7d, 0x42, 0xe1, 0x3c, 0x98, 0xdd, 0x6f, 0x7e, 0x58, 0x9c, 0xe1, 0x19,
	0xdf, 0x7d, 0x52, 0x7f, 0xbf, 0xa8, 0xe9, 0x7f, 0xd0, 0x00, 0x9c, 0xd4, 0x70, 0xf8, 0x14, 0x2c,
	0x24, 0x3e, 0x65, 0xa7, 0x3d, 0xb5, 0x1b, 0xba, 0xbd, 0xe7, 0xee, 0x82, 0xa5, 0xf6, 0x89, 0x78,
	0x60, 0xd8, 0xc7, 0xa6, 0x1b, 0xc6, 0x0a, 0xf9, 0x15, 0xb9, 0x8f, 0x32, 0x91, 0x46, 0x63, 0xc0,
	0xad, 0x4a, 0x4b, 0x32, 0xd5, 0xa4, 0xff, 0x45, 0x03, 0x4b, 0x9d, 0xc0, 0x19, 0x98, 0xd6, 0xb9,
	0x0c, 0xff, 0xb1, 0x12, 0xfe, 0x6f, 0x5d, 0x5d, 0x96, 0x37, 0xe2, 0xf0, 0x2b, 0x8e, 0xff, 0x8f,
	0x13, 0xd8, 0x8c, 0x4f, 0xa0, 0x00, 0xe6, 0x9a, 0xad, 0xee, 0x87, 0x8f, 0x8a, 0x33, 0x10, 0x80,
	0x5c, 0xbd, 0xd5, 0x7d, 0x7f, 0xfb, 0xa3, 0xa2, 0xa6, 0xff, 0x2d, 0xa3, 0xc4, 0x1b, 0x3e, 0x03,
	0x4b, 0x1f, 0x3b, 0xc8, 0xb5, 0xdb, 0xc1, 0x3e, 0x62, 0x81, 0x63, 0xc9, 0x4d, 0x0d, 0xab, 0x5f,
	0x8f, 0x1b, 0x0d, 0x12, 0x18, 0x9e, 0x30, 0x2b, 0xd5, 0x6f, 0xba, 0x0d, 0x7e, 0x06, 0xf2, 0x6d,
	0x1f, 0x05, 0x26, 0x23, 0x81, 0xdc, 0x4a, 0xf3, 0xea, 0xb2, 0xfc, 0x6e, 0x1c, 0xa6, 0xc4, 0x0a,
	0xaa, 0x75, 0xd7, 0x25, 0x67, 0xc8, 0x8e, 0xdd, 0x87, 0xf1, 0x5a, 0x21, 0x12, 0x51, 0xf6, 0x9c,
	0x02, 0xc2, 0xef, 0x81, 0x9c, 0x38, 0xee, 0xe8, 0xbd, 0x5a, 0x18, 0x89, 0xb3, 0x38, 0x4b, 0xf5,
	0xb1, 0x32, 0x01, 0xe9, 0x1d, 0x50, 0x1c, 0x5f, 0x02, 0x8f, 0x58, 0xeb, 0xf3, 0xd0, 0x74, 0x69,
	0x71, 0x06, 0xe6, 0x40, 0x66, 0x17, 0x17, 0x35, 0xb8, 0x04, 0x0a, 0x07, 0x84, 0x49, 0x38, 0xc3,
	0xe3, 0x7b, 0x40, 0xd8, 0x2e, 0x2e, 0xce, 0x72, 0x8f, 0xc7, 0xac, 0x98, 0xe5, 0x7f, 0xf7, 0x58,
	0x71, 0x4e, 0xff, 0x63, 0x16, 0xbc, 0xa5, 0x3e, 0x93, 0xe1, 0x36, 0xc8, 0x3e, 0x21, 0x34, 0x2e,
	0xfc, 0x2b, 0xfc, 0x3a, 0x9c, 0x12, 0xf5, 0x55, 0x3e, 0x0e, 0x70, 0xd1, 0xe9, 0x90, 0x80, 0xc9,
	0xf8, 0x0d, 0xc5, 0xc2, 0x27, 0x81, 0x3a, 0x6e, 0x0c, 0x80, 0x7d, 0x30, 0x7f, 0xcc, 0xfb, 0x76,
	0x82, 0xe5, 0x0b, 0xa5, 0x71, 0x75, 0x59, 0x7e, 0x10, 0x87, 0x5e, 0x5d, 0x98, 0x78, 0xce, 0x4b,
	0xef, 0x61, 0xe4, 0xe1, 0x20, 0x02, 0x94, 0xe2, 0x31, 0x89, 0xc1, 0x4f, 0xc1, 0xf2, 0x0e, 0xf1,
	0xbc, 0x10, 0x3b, 0xec, 0xbc, 0x1d, 0x08, 0x81, 0x8c, 0xaa, 0xd0, 0xf0, 0x47, 0x01, 0x2b, 0x36,
	0xf3, 0x5b, 0x32, 0xae, 0x96, 0xb7, 0x5a, 0xe1, 0x49, 0x52, 0xf1, 0x64, 0x75, 0x5a, 0x53, 0xd5,
	0x3d, 0xb6, 0x8e, 0x3a, 0x5e, 0x33, 0x64, 0xa7, 0x86, 0x25, 0x40, 0xa5, 0xe3, 0x4d, 0xc7, 0x21,
	0x1e, 0xcb, 0x6c, 0x59, 0xa7, 0xca, 0xc9, 0x69, 0x14, 0x87, 0x91, 0x94, 0xf8, 0x11, 0x9c, 0x32,
	0xd9, 0x74, 0x93, 0x5e, 0x01, 0x8b, 0xc9, 0x78, 0x73, 0x95, 0x3c, 0xde, 0xde, 0x89, 0xee, 0xd8,
	0xf1, 0x07, 0x45, 0xad, 0xb1, 0xf8, 0xfc, 0xe5, 0xa6, 0xf6, 0xc5, 0xcb, 0x4d, 0xed, 0xaf, 0x2f,
	0x37, 0xb5, 0x8e, 0x76, 0x92, 0x13, 0x3f, 0x7f, 0x7e, 0xf0, 0x9f, 0x00, 0x00, 0x00, 0xff, 0xff,
	0x8b, 0xc1, 0xe8, 0x5b, 0x05, 0x16, 0x00, 0x00,
}
