// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: alerts.proto

/*
	Package monitoring is a generated protocol buffer package.

	Service name

	It is generated from these files:
		alerts.proto
		events.proto
		mirror.proto
		svc_monitoring.proto
		telemetry.proto

	It has these top-level messages:
		Alert
		AlertDestination
		AlertDestinationSpec
		AlertDestinationStatus
		AlertPolicy
		AlertPolicySpec
		AlertPolicyStatus
		AlertReason
		AlertSource
		AlertSpec
		AlertStatus
		AuditInfo
		AuthConfig
		MatchedRequirement
		PrivacyConfig
		Requirement
		SNMPTrapServer
		Event
		EventAttributes
		EventExport
		EventPolicy
		EventPolicySpec
		EventPolicyStatus
		EventSource
		EventsList
		AppProtoSelector
		MatchRule
		MatchSelector
		MirrorCollector
		MirrorSession
		MirrorSessionSpec
		MirrorSessionStatus
		MirrorStartConditions
		MirrorStopConditions
		SmartNICMirrorSessionStatus
		AlertDestinationList
		AlertList
		AlertPolicyList
		AutoMsgAlertDestinationWatchHelper
		AutoMsgAlertPolicyWatchHelper
		AutoMsgAlertWatchHelper
		AutoMsgEventPolicyWatchHelper
		AutoMsgEventWatchHelper
		AutoMsgFlowExportPolicyWatchHelper
		AutoMsgFwlogPolicyWatchHelper
		AutoMsgMirrorSessionWatchHelper
		AutoMsgStatsPolicyWatchHelper
		EventList
		EventPolicyList
		FlowExportPolicyList
		FwlogPolicyList
		MirrorSessionList
		StatsPolicyList
		FlowExportPolicy
		FlowExportSpec
		FlowExportStatus
		FlowExportTarget
		FwlogExport
		FwlogPolicy
		FwlogSpec
		FwlogStatus
		StatsPolicy
		StatsSpec
		StatsStatus
*/
package monitoring

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/pensando/grpc-gateway/third_party/googleapis/google/api"
import _ "github.com/pensando/sw/venice/utils/apigen/annotations"
import _ "github.com/gogo/protobuf/gogoproto"
import api "github.com/pensando/sw/api"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type AlertSpec_AlertState int32

const (
	AlertSpec_OPEN         AlertSpec_AlertState = 0
	AlertSpec_RESOLVED     AlertSpec_AlertState = 1
	AlertSpec_ACKNOWLEDGED AlertSpec_AlertState = 2
)

var AlertSpec_AlertState_name = map[int32]string{
	0: "OPEN",
	1: "RESOLVED",
	2: "ACKNOWLEDGED",
}
var AlertSpec_AlertState_value = map[string]int32{
	"OPEN":         0,
	"RESOLVED":     1,
	"ACKNOWLEDGED": 2,
}

func (x AlertSpec_AlertState) String() string {
	return proto.EnumName(AlertSpec_AlertState_name, int32(x))
}
func (AlertSpec_AlertState) EnumDescriptor() ([]byte, []int) { return fileDescriptorAlerts, []int{9, 0} }

// Algos contains the encryption algorithm to be used when SecurityMethod
// has PRIVACY.
type AuthConfig_Algos int32

const (
	AuthConfig_MD5  AuthConfig_Algos = 0
	AuthConfig_SHA1 AuthConfig_Algos = 1
)

var AuthConfig_Algos_name = map[int32]string{
	0: "MD5",
	1: "SHA1",
}
var AuthConfig_Algos_value = map[string]int32{
	"MD5":  0,
	"SHA1": 1,
}

func (x AuthConfig_Algos) String() string {
	return proto.EnumName(AuthConfig_Algos_name, int32(x))
}
func (AuthConfig_Algos) EnumDescriptor() ([]byte, []int) { return fileDescriptorAlerts, []int{12, 0} }

type PrivacyConfig_Algos int32

const (
	PrivacyConfig_DES56  PrivacyConfig_Algos = 0
	PrivacyConfig_AES128 PrivacyConfig_Algos = 1
)

var PrivacyConfig_Algos_name = map[int32]string{
	0: "DES56",
	1: "AES128",
}
var PrivacyConfig_Algos_value = map[string]int32{
	"DES56":  0,
	"AES128": 1,
}

func (x PrivacyConfig_Algos) String() string {
	return proto.EnumName(PrivacyConfig_Algos_name, int32(x))
}
func (PrivacyConfig_Algos) EnumDescriptor() ([]byte, []int) { return fileDescriptorAlerts, []int{14, 0} }

type Requirement_AllowedOperators int32

const (
	Requirement_Equals    Requirement_AllowedOperators = 0
	Requirement_In        Requirement_AllowedOperators = 1
	Requirement_NotEquals Requirement_AllowedOperators = 2
	Requirement_NotIn     Requirement_AllowedOperators = 3
	Requirement_Gt        Requirement_AllowedOperators = 4
	Requirement_Lt        Requirement_AllowedOperators = 5
)

var Requirement_AllowedOperators_name = map[int32]string{
	0: "Equals",
	1: "In",
	2: "NotEquals",
	3: "NotIn",
	4: "Gt",
	5: "Lt",
}
var Requirement_AllowedOperators_value = map[string]int32{
	"Equals":    0,
	"In":        1,
	"NotEquals": 2,
	"NotIn":     3,
	"Gt":        4,
	"Lt":        5,
}

func (x Requirement_AllowedOperators) String() string {
	return proto.EnumName(Requirement_AllowedOperators_name, int32(x))
}
func (Requirement_AllowedOperators) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorAlerts, []int{15, 0}
}

type SNMPTrapServer_SNMPVersions int32

const (
	SNMPTrapServer_V2C SNMPTrapServer_SNMPVersions = 0
	SNMPTrapServer_V3  SNMPTrapServer_SNMPVersions = 1
)

var SNMPTrapServer_SNMPVersions_name = map[int32]string{
	0: "V2C",
	1: "V3",
}
var SNMPTrapServer_SNMPVersions_value = map[string]int32{
	"V2C": 0,
	"V3":  1,
}

func (x SNMPTrapServer_SNMPVersions) String() string {
	return proto.EnumName(SNMPTrapServer_SNMPVersions_name, int32(x))
}
func (SNMPTrapServer_SNMPVersions) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorAlerts, []int{16, 0}
}

// Source of an alert; for alerts generated from events, it maps to event.Source
type Alert struct {
	api.TypeMeta   `protobuf:"bytes,1,opt,name=T,embedded=T" json:",inline"`
	api.ObjectMeta `protobuf:"bytes,2,opt,name=O,embedded=O" json:"meta, omitempty"`
	Spec           AlertSpec   `protobuf:"bytes,3,opt,name=Spec" json:"spec, omitempty"`
	Status         AlertStatus `protobuf:"bytes,4,opt,name=Status" json:"status, omitempty"`
}

func (m *Alert) Reset()                    { *m = Alert{} }
func (m *Alert) String() string            { return proto.CompactTextString(m) }
func (*Alert) ProtoMessage()               {}
func (*Alert) Descriptor() ([]byte, []int) { return fileDescriptorAlerts, []int{0} }

func (m *Alert) GetSpec() AlertSpec {
	if m != nil {
		return m.Spec
	}
	return AlertSpec{}
}

func (m *Alert) GetStatus() AlertStatus {
	if m != nil {
		return m.Status
	}
	return AlertStatus{}
}

// One of the requirement from the expression that was met
type AlertDestination struct {
	// Requirement from the alert rule that was met
	api.TypeMeta `protobuf:"bytes,1,opt,name=T,embedded=T" json:",inline"`
	// The value at which the requirement was met.
	// same as Requirement.value for operator `Equals` but could vary for other operators
	// e.g. requirement - CPU;Gt;90 could have a matching value 96
	api.ObjectMeta `protobuf:"bytes,2,opt,name=O,embedded=O" json:"meta, omitempty"`
	Spec           AlertDestinationSpec   `protobuf:"bytes,3,opt,name=Spec" json:"spec, omitempty"`
	Status         AlertDestinationStatus `protobuf:"bytes,4,opt,name=Status" json:"status, omitempty"`
}

func (m *AlertDestination) Reset()                    { *m = AlertDestination{} }
func (m *AlertDestination) String() string            { return proto.CompactTextString(m) }
func (*AlertDestination) ProtoMessage()               {}
func (*AlertDestination) Descriptor() ([]byte, []int) { return fileDescriptorAlerts, []int{1} }

func (m *AlertDestination) GetSpec() AlertDestinationSpec {
	if m != nil {
		return m.Spec
	}
	return AlertDestinationSpec{}
}

func (m *AlertDestination) GetStatus() AlertDestinationStatus {
	if m != nil {
		return m.Status
	}
	return AlertDestinationStatus{}
}

// AlertReason captures all the requirements with matched value from the alert policy rule
// at the time of creating an alert.
// e.g. "matched-requirements": [{"field": "cpu", "operator": "Gt", "values": [90], "observed-value": 95}]
type AlertDestinationSpec struct {
	// List of requirements from the alert policy with it's matched value
	Default bool `protobuf:"varint,1,opt,name=Default,proto3" json:"default, omitempty"`
	// Alert Policy ID that matched
	EmailList       []string          `protobuf:"bytes,2,rep,name=EmailList" json:"email-list, omitempty"`
	SNMPTrapServers []*SNMPTrapServer `protobuf:"bytes,3,rep,name=SNMPTrapServers" json:"snmp-trap-servers, omitempty"`
}

func (m *AlertDestinationSpec) Reset()                    { *m = AlertDestinationSpec{} }
func (m *AlertDestinationSpec) String() string            { return proto.CompactTextString(m) }
func (*AlertDestinationSpec) ProtoMessage()               {}
func (*AlertDestinationSpec) Descriptor() ([]byte, []int) { return fileDescriptorAlerts, []int{2} }

func (m *AlertDestinationSpec) GetDefault() bool {
	if m != nil {
		return m.Default
	}
	return false
}

func (m *AlertDestinationSpec) GetEmailList() []string {
	if m != nil {
		return m.EmailList
	}
	return nil
}

func (m *AlertDestinationSpec) GetSNMPTrapServers() []*SNMPTrapServer {
	if m != nil {
		return m.SNMPTrapServers
	}
	return nil
}

// AuditInfo captures the user performed the action and the time at which the
// action was performed.
type AlertDestinationStatus struct {
	// Name of the user performed some action.
	TotalNotificationsSent int32 `protobuf:"varint,1,opt,name=totalNotificationsSent,proto3" json:"total-notifications-sent, omitempty"`
}

func (m *AlertDestinationStatus) Reset()                    { *m = AlertDestinationStatus{} }
func (m *AlertDestinationStatus) String() string            { return proto.CompactTextString(m) }
func (*AlertDestinationStatus) ProtoMessage()               {}
func (*AlertDestinationStatus) Descriptor() ([]byte, []int) { return fileDescriptorAlerts, []int{3} }

func (m *AlertDestinationStatus) GetTotalNotificationsSent() int32 {
	if m != nil {
		return m.TotalNotificationsSent
	}
	return 0
}

// User can change the state of the alert by changing the spec
type AlertPolicy struct {
	api.TypeMeta   `protobuf:"bytes,1,opt,name=T,embedded=T" json:",inline"`
	api.ObjectMeta `protobuf:"bytes,2,opt,name=O,embedded=O" json:"meta, omitempty"`
	Spec           AlertPolicySpec   `protobuf:"bytes,3,opt,name=Spec" json:"spec, omitempty"`
	Status         AlertPolicyStatus `protobuf:"bytes,4,opt,name=Status" json:"status, omitempty"`
}

func (m *AlertPolicy) Reset()                    { *m = AlertPolicy{} }
func (m *AlertPolicy) String() string            { return proto.CompactTextString(m) }
func (*AlertPolicy) ProtoMessage()               {}
func (*AlertPolicy) Descriptor() ([]byte, []int) { return fileDescriptorAlerts, []int{4} }

func (m *AlertPolicy) GetSpec() AlertPolicySpec {
	if m != nil {
		return m.Spec
	}
	return AlertPolicySpec{}
}

func (m *AlertPolicy) GetStatus() AlertPolicyStatus {
	if m != nil {
		return m.Status
	}
	return AlertPolicyStatus{}
}

// Status part of the alert object
type AlertPolicySpec struct {
	// Severity of an alert
	Resource string `protobuf:"bytes,1,opt,name=Resource,proto3" json:"resource, omitempty"`
	// Alert source or origin
	Severity string `protobuf:"bytes,2,opt,name=Severity,proto3" json:"severity, omitempty"`
	// Affected object
	Message string `protobuf:"bytes,3,opt,name=Message,proto3" json:"message, omitempty"`
	// Message from the alert rule that triggered the alert
	Requirements []Requirement `protobuf:"bytes,4,rep,name=Requirements" json:"requirements, omitempty"`
	// Captures all the requirements from the alert policy rule with matched value.
	// All these requirements must be cleared to auto-resolve an alert.
	PersistenceDuration string `protobuf:"bytes,5,opt,name=PersistenceDuration,proto3" json:"persistence-duration, omitempty"`
	// Username and time at which the alert was acknowledged
	ClearDuration string `protobuf:"bytes,6,opt,name=ClearDuration,proto3" json:"clear-duration, omitempty"`
	// Username and time at which the alert was resolved
	Enable       bool     `protobuf:"varint,7,opt,name=Enable,proto3" json:"enable, omitempty"`
	AutoResolve  bool     `protobuf:"varint,8,opt,name=AutoResolve,proto3" json:"auto-resolve, omitempty"`
	Destinations []string `protobuf:"bytes,9,rep,name=Destinations" json:"destinations, omitempty"`
}

func (m *AlertPolicySpec) Reset()                    { *m = AlertPolicySpec{} }
func (m *AlertPolicySpec) String() string            { return proto.CompactTextString(m) }
func (*AlertPolicySpec) ProtoMessage()               {}
func (*AlertPolicySpec) Descriptor() ([]byte, []int) { return fileDescriptorAlerts, []int{5} }

func (m *AlertPolicySpec) GetResource() string {
	if m != nil {
		return m.Resource
	}
	return ""
}

func (m *AlertPolicySpec) GetSeverity() string {
	if m != nil {
		return m.Severity
	}
	return ""
}

func (m *AlertPolicySpec) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *AlertPolicySpec) GetRequirements() []Requirement {
	if m != nil {
		return m.Requirements
	}
	return nil
}

func (m *AlertPolicySpec) GetPersistenceDuration() string {
	if m != nil {
		return m.PersistenceDuration
	}
	return ""
}

func (m *AlertPolicySpec) GetClearDuration() string {
	if m != nil {
		return m.ClearDuration
	}
	return ""
}

func (m *AlertPolicySpec) GetEnable() bool {
	if m != nil {
		return m.Enable
	}
	return false
}

func (m *AlertPolicySpec) GetAutoResolve() bool {
	if m != nil {
		return m.AutoResolve
	}
	return false
}

func (m *AlertPolicySpec) GetDestinations() []string {
	if m != nil {
		return m.Destinations
	}
	return nil
}

// Alert defines an alert object
type AlertPolicyStatus struct {
	TotalHits          int32 `protobuf:"varint,1,opt,name=TotalHits,proto3" json:"total-hits, omitempty"`
	OpenAlerts         int32 `protobuf:"varint,2,opt,name=OpenAlerts,proto3" json:"open-alerts, omitempty"`
	AcknowledgedAlerts int32 `protobuf:"varint,3,opt,name=AcknowledgedAlerts,proto3" json:"acknowledged-alerts, omitempty"`
}

func (m *AlertPolicyStatus) Reset()                    { *m = AlertPolicyStatus{} }
func (m *AlertPolicyStatus) String() string            { return proto.CompactTextString(m) }
func (*AlertPolicyStatus) ProtoMessage()               {}
func (*AlertPolicyStatus) Descriptor() ([]byte, []int) { return fileDescriptorAlerts, []int{6} }

func (m *AlertPolicyStatus) GetTotalHits() int32 {
	if m != nil {
		return m.TotalHits
	}
	return 0
}

func (m *AlertPolicyStatus) GetOpenAlerts() int32 {
	if m != nil {
		return m.OpenAlerts
	}
	return 0
}

func (m *AlertPolicyStatus) GetAcknowledgedAlerts() int32 {
	if m != nil {
		return m.AcknowledgedAlerts
	}
	return 0
}

// Requirement specifies each
// {"field": "Status.Phase", "operator":"Equals", "values":["JOINED"]}
type AlertReason struct {
	// name of the field or metric
	MatchedRequirements []*MatchedRequirement `protobuf:"bytes,1,rep,name=MatchedRequirements" json:"matched-requirements, omitempty"`
	PolicyID            string                `protobuf:"bytes,2,opt,name=PolicyID,proto3" json:"alert-policy-id, omitempty"`
}

func (m *AlertReason) Reset()                    { *m = AlertReason{} }
func (m *AlertReason) String() string            { return proto.CompactTextString(m) }
func (*AlertReason) ProtoMessage()               {}
func (*AlertReason) Descriptor() ([]byte, []int) { return fileDescriptorAlerts, []int{7} }

func (m *AlertReason) GetMatchedRequirements() []*MatchedRequirement {
	if m != nil {
		return m.MatchedRequirements
	}
	return nil
}

func (m *AlertReason) GetPolicyID() string {
	if m != nil {
		return m.PolicyID
	}
	return ""
}

type AlertSource struct {
	// Resource type - target resource to run this policy.
	// e.g. Network, Endpoint - object based alert policy
	//      Event - event based alert policy
	//      EndpointMetrics - metric based alert policy
	// based on the resource type, the policy gets interpreted.
	Component string `protobuf:"bytes,1,opt,name=Component,proto3" json:"component, omitempty"`
	// Severity to be set for an alert that gets triggered from this rule
	NodeName string `protobuf:"bytes,2,opt,name=NodeName,proto3" json:"node-name, omitempty"`
}

func (m *AlertSource) Reset()                    { *m = AlertSource{} }
func (m *AlertSource) String() string            { return proto.CompactTextString(m) }
func (*AlertSource) ProtoMessage()               {}
func (*AlertSource) Descriptor() ([]byte, []int) { return fileDescriptorAlerts, []int{8} }

func (m *AlertSource) GetComponent() string {
	if m != nil {
		return m.Component
	}
	return ""
}

func (m *AlertSource) GetNodeName() string {
	if m != nil {
		return m.NodeName
	}
	return ""
}

type AlertSpec struct {
	// Total hits on this policy
	State string `protobuf:"bytes,1,opt,name=State,proto3" json:"state, omitempty"`
}

func (m *AlertSpec) Reset()                    { *m = AlertSpec{} }
func (m *AlertSpec) String() string            { return proto.CompactTextString(m) }
func (*AlertSpec) ProtoMessage()               {}
func (*AlertSpec) Descriptor() ([]byte, []int) { return fileDescriptorAlerts, []int{9} }

func (m *AlertSpec) GetState() string {
	if m != nil {
		return m.State
	}
	return ""
}

// AlertPolicy - tenant scoped
type AlertStatus struct {
	Severity     string        `protobuf:"bytes,1,opt,name=Severity,proto3" json:"severity, omitempty"`
	Source       *AlertSource  `protobuf:"bytes,2,opt,name=Source" json:"source, omitempty"`
	ObjectRef    api.ObjectRef `protobuf:"bytes,3,opt,name=ObjectRef" json:"object-ref, omitempty"`
	Message      string        `protobuf:"bytes,4,opt,name=Message,proto3" json:"message, omitempty"`
	Reason       AlertReason   `protobuf:"bytes,5,opt,name=Reason" json:"reason, omitempty"`
	Acknowledged *AuditInfo    `protobuf:"bytes,6,opt,name=Acknowledged" json:"acknowledged, omitempty"`
	Resolved     *AuditInfo    `protobuf:"bytes,7,opt,name=Resolved" json:"resolved, omitempty"`
}

func (m *AlertStatus) Reset()                    { *m = AlertStatus{} }
func (m *AlertStatus) String() string            { return proto.CompactTextString(m) }
func (*AlertStatus) ProtoMessage()               {}
func (*AlertStatus) Descriptor() ([]byte, []int) { return fileDescriptorAlerts, []int{10} }

func (m *AlertStatus) GetSeverity() string {
	if m != nil {
		return m.Severity
	}
	return ""
}

func (m *AlertStatus) GetSource() *AlertSource {
	if m != nil {
		return m.Source
	}
	return nil
}

func (m *AlertStatus) GetObjectRef() api.ObjectRef {
	if m != nil {
		return m.ObjectRef
	}
	return api.ObjectRef{}
}

func (m *AlertStatus) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *AlertStatus) GetReason() AlertReason {
	if m != nil {
		return m.Reason
	}
	return AlertReason{}
}

func (m *AlertStatus) GetAcknowledged() *AuditInfo {
	if m != nil {
		return m.Acknowledged
	}
	return nil
}

func (m *AlertStatus) GetResolved() *AuditInfo {
	if m != nil {
		return m.Resolved
	}
	return nil
}

// AuthConfig contains the configuration for SNMP Trap authentication.
type AuditInfo struct {
	User string `protobuf:"bytes,1,opt,name=User,proto3" json:"user, omitempty"`
	// Password contains the authentication password.
	Time *api.Timestamp `protobuf:"bytes,2,opt,name=Time" json:"time, omitempty"`
}

func (m *AuditInfo) Reset()                    { *m = AuditInfo{} }
func (m *AuditInfo) String() string            { return proto.CompactTextString(m) }
func (*AuditInfo) ProtoMessage()               {}
func (*AuditInfo) Descriptor() ([]byte, []int) { return fileDescriptorAlerts, []int{11} }

func (m *AuditInfo) GetUser() string {
	if m != nil {
		return m.User
	}
	return ""
}

func (m *AuditInfo) GetTime() *api.Timestamp {
	if m != nil {
		return m.Time
	}
	return nil
}

// PrivacyConfig contains the configuration for SNMP Trap encryption.
type AuthConfig struct {
	Algo string `protobuf:"bytes,1,opt,name=Algo,proto3" json:"algo, omitempty"`
	// Password contains the privacy password.
	Password string `protobuf:"bytes,2,opt,name=Password,proto3" json:"password, omitempty"`
}

func (m *AuthConfig) Reset()                    { *m = AuthConfig{} }
func (m *AuthConfig) String() string            { return proto.CompactTextString(m) }
func (*AuthConfig) ProtoMessage()               {}
func (*AuthConfig) Descriptor() ([]byte, []int) { return fileDescriptorAlerts, []int{12} }

func (m *AuthConfig) GetAlgo() string {
	if m != nil {
		return m.Algo
	}
	return ""
}

func (m *AuthConfig) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

// SNMPTrapServer contains the configuration for sending SNMP traps to a receiver.
type MatchedRequirement struct {
	// Host where the trap needs to be sent.
	Requirement `protobuf:"bytes,1,opt,name=Requirement,embedded=Requirement" json:",inline"`
	// Port on the Host where the trap needs to be sent, default is 162.
	ObservedValue string `protobuf:"bytes,2,opt,name=ObservedValue,proto3" json:"observed-value, omitempty"`
}

func (m *MatchedRequirement) Reset()                    { *m = MatchedRequirement{} }
func (m *MatchedRequirement) String() string            { return proto.CompactTextString(m) }
func (*MatchedRequirement) ProtoMessage()               {}
func (*MatchedRequirement) Descriptor() ([]byte, []int) { return fileDescriptorAlerts, []int{13} }

func (m *MatchedRequirement) GetObservedValue() string {
	if m != nil {
		return m.ObservedValue
	}
	return ""
}

type PrivacyConfig struct {
	// If set, this will be the default notification option for the alert policies unless otherwise
	// something else is mentioned.
	Algo string `protobuf:"bytes,1,opt,name=Algo,proto3" json:"algo, omitempty"`
	// Email notification
	Password string `protobuf:"bytes,2,opt,name=Password,proto3" json:"password, omitempty"`
}

func (m *PrivacyConfig) Reset()                    { *m = PrivacyConfig{} }
func (m *PrivacyConfig) String() string            { return proto.CompactTextString(m) }
func (*PrivacyConfig) ProtoMessage()               {}
func (*PrivacyConfig) Descriptor() ([]byte, []int) { return fileDescriptorAlerts, []int{14} }

func (m *PrivacyConfig) GetAlgo() string {
	if m != nil {
		return m.Algo
	}
	return ""
}

func (m *PrivacyConfig) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

type Requirement struct {
	// total number of notifications sent using this notification mechanism
	FieldOrMetric string   `protobuf:"bytes,1,opt,name=FieldOrMetric,proto3" json:"field-or-metric, omitempty"`
	Operator      string   `protobuf:"bytes,2,opt,name=Operator,proto3" json:"operator, omitempty"`
	Values        []string `protobuf:"bytes,3,rep,name=Values" json:"values, omitempty"`
}

func (m *Requirement) Reset()                    { *m = Requirement{} }
func (m *Requirement) String() string            { return proto.CompactTextString(m) }
func (*Requirement) ProtoMessage()               {}
func (*Requirement) Descriptor() ([]byte, []int) { return fileDescriptorAlerts, []int{15} }

func (m *Requirement) GetFieldOrMetric() string {
	if m != nil {
		return m.FieldOrMetric
	}
	return ""
}

func (m *Requirement) GetOperator() string {
	if m != nil {
		return m.Operator
	}
	return ""
}

func (m *Requirement) GetValues() []string {
	if m != nil {
		return m.Values
	}
	return nil
}

// AlertDestination - tenant scoped
type SNMPTrapServer struct {
	Host            string         `protobuf:"bytes,1,opt,name=Host,proto3" json:"host, omitempty"`
	Port            string         `protobuf:"bytes,2,opt,name=Port,proto3" json:"port, omitempty"`
	Version         string         `protobuf:"bytes,3,opt,name=Version,proto3" json:"version, omitempty"`
	CommunityOrUser string         `protobuf:"bytes,4,opt,name=CommunityOrUser,proto3" json:"community-or-user, omitempty"`
	AuthConfig      *AuthConfig    `protobuf:"bytes,5,opt,name=AuthConfig" json:"auth-config, omitempty"`
	PrivacyConfig   *PrivacyConfig `protobuf:"bytes,6,opt,name=PrivacyConfig" json:"privacy-config, omitempty"`
}

func (m *SNMPTrapServer) Reset()                    { *m = SNMPTrapServer{} }
func (m *SNMPTrapServer) String() string            { return proto.CompactTextString(m) }
func (*SNMPTrapServer) ProtoMessage()               {}
func (*SNMPTrapServer) Descriptor() ([]byte, []int) { return fileDescriptorAlerts, []int{16} }

func (m *SNMPTrapServer) GetHost() string {
	if m != nil {
		return m.Host
	}
	return ""
}

func (m *SNMPTrapServer) GetPort() string {
	if m != nil {
		return m.Port
	}
	return ""
}

func (m *SNMPTrapServer) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *SNMPTrapServer) GetCommunityOrUser() string {
	if m != nil {
		return m.CommunityOrUser
	}
	return ""
}

func (m *SNMPTrapServer) GetAuthConfig() *AuthConfig {
	if m != nil {
		return m.AuthConfig
	}
	return nil
}

func (m *SNMPTrapServer) GetPrivacyConfig() *PrivacyConfig {
	if m != nil {
		return m.PrivacyConfig
	}
	return nil
}

func init() {
	proto.RegisterType((*Alert)(nil), "monitoring.Alert")
	proto.RegisterType((*AlertDestination)(nil), "monitoring.AlertDestination")
	proto.RegisterType((*AlertDestinationSpec)(nil), "monitoring.AlertDestinationSpec")
	proto.RegisterType((*AlertDestinationStatus)(nil), "monitoring.AlertDestinationStatus")
	proto.RegisterType((*AlertPolicy)(nil), "monitoring.AlertPolicy")
	proto.RegisterType((*AlertPolicySpec)(nil), "monitoring.AlertPolicySpec")
	proto.RegisterType((*AlertPolicyStatus)(nil), "monitoring.AlertPolicyStatus")
	proto.RegisterType((*AlertReason)(nil), "monitoring.AlertReason")
	proto.RegisterType((*AlertSource)(nil), "monitoring.AlertSource")
	proto.RegisterType((*AlertSpec)(nil), "monitoring.AlertSpec")
	proto.RegisterType((*AlertStatus)(nil), "monitoring.AlertStatus")
	proto.RegisterType((*AuditInfo)(nil), "monitoring.AuditInfo")
	proto.RegisterType((*AuthConfig)(nil), "monitoring.AuthConfig")
	proto.RegisterType((*MatchedRequirement)(nil), "monitoring.MatchedRequirement")
	proto.RegisterType((*PrivacyConfig)(nil), "monitoring.PrivacyConfig")
	proto.RegisterType((*Requirement)(nil), "monitoring.Requirement")
	proto.RegisterType((*SNMPTrapServer)(nil), "monitoring.SNMPTrapServer")
	proto.RegisterEnum("monitoring.AlertSpec_AlertState", AlertSpec_AlertState_name, AlertSpec_AlertState_value)
	proto.RegisterEnum("monitoring.AuthConfig_Algos", AuthConfig_Algos_name, AuthConfig_Algos_value)
	proto.RegisterEnum("monitoring.PrivacyConfig_Algos", PrivacyConfig_Algos_name, PrivacyConfig_Algos_value)
	proto.RegisterEnum("monitoring.Requirement_AllowedOperators", Requirement_AllowedOperators_name, Requirement_AllowedOperators_value)
	proto.RegisterEnum("monitoring.SNMPTrapServer_SNMPVersions", SNMPTrapServer_SNMPVersions_name, SNMPTrapServer_SNMPVersions_value)
}
func (m *Alert) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Alert) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintAlerts(dAtA, i, uint64(m.TypeMeta.Size()))
	n1, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n1
	dAtA[i] = 0x12
	i++
	i = encodeVarintAlerts(dAtA, i, uint64(m.ObjectMeta.Size()))
	n2, err := m.ObjectMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n2
	dAtA[i] = 0x1a
	i++
	i = encodeVarintAlerts(dAtA, i, uint64(m.Spec.Size()))
	n3, err := m.Spec.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n3
	dAtA[i] = 0x22
	i++
	i = encodeVarintAlerts(dAtA, i, uint64(m.Status.Size()))
	n4, err := m.Status.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n4
	return i, nil
}

func (m *AlertDestination) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AlertDestination) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintAlerts(dAtA, i, uint64(m.TypeMeta.Size()))
	n5, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n5
	dAtA[i] = 0x12
	i++
	i = encodeVarintAlerts(dAtA, i, uint64(m.ObjectMeta.Size()))
	n6, err := m.ObjectMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n6
	dAtA[i] = 0x1a
	i++
	i = encodeVarintAlerts(dAtA, i, uint64(m.Spec.Size()))
	n7, err := m.Spec.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n7
	dAtA[i] = 0x22
	i++
	i = encodeVarintAlerts(dAtA, i, uint64(m.Status.Size()))
	n8, err := m.Status.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n8
	return i, nil
}

func (m *AlertDestinationSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AlertDestinationSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Default {
		dAtA[i] = 0x8
		i++
		if m.Default {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.EmailList) > 0 {
		for _, s := range m.EmailList {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.SNMPTrapServers) > 0 {
		for _, msg := range m.SNMPTrapServers {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintAlerts(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *AlertDestinationStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AlertDestinationStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TotalNotificationsSent != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(m.TotalNotificationsSent))
	}
	return i, nil
}

func (m *AlertPolicy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AlertPolicy) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintAlerts(dAtA, i, uint64(m.TypeMeta.Size()))
	n9, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n9
	dAtA[i] = 0x12
	i++
	i = encodeVarintAlerts(dAtA, i, uint64(m.ObjectMeta.Size()))
	n10, err := m.ObjectMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n10
	dAtA[i] = 0x1a
	i++
	i = encodeVarintAlerts(dAtA, i, uint64(m.Spec.Size()))
	n11, err := m.Spec.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n11
	dAtA[i] = 0x22
	i++
	i = encodeVarintAlerts(dAtA, i, uint64(m.Status.Size()))
	n12, err := m.Status.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n12
	return i, nil
}

func (m *AlertPolicySpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AlertPolicySpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Resource) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(len(m.Resource)))
		i += copy(dAtA[i:], m.Resource)
	}
	if len(m.Severity) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(len(m.Severity)))
		i += copy(dAtA[i:], m.Severity)
	}
	if len(m.Message) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	if len(m.Requirements) > 0 {
		for _, msg := range m.Requirements {
			dAtA[i] = 0x22
			i++
			i = encodeVarintAlerts(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.PersistenceDuration) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(len(m.PersistenceDuration)))
		i += copy(dAtA[i:], m.PersistenceDuration)
	}
	if len(m.ClearDuration) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(len(m.ClearDuration)))
		i += copy(dAtA[i:], m.ClearDuration)
	}
	if m.Enable {
		dAtA[i] = 0x38
		i++
		if m.Enable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.AutoResolve {
		dAtA[i] = 0x40
		i++
		if m.AutoResolve {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Destinations) > 0 {
		for _, s := range m.Destinations {
			dAtA[i] = 0x4a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *AlertPolicyStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AlertPolicyStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TotalHits != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(m.TotalHits))
	}
	if m.OpenAlerts != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(m.OpenAlerts))
	}
	if m.AcknowledgedAlerts != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(m.AcknowledgedAlerts))
	}
	return i, nil
}

func (m *AlertReason) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AlertReason) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.MatchedRequirements) > 0 {
		for _, msg := range m.MatchedRequirements {
			dAtA[i] = 0xa
			i++
			i = encodeVarintAlerts(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.PolicyID) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(len(m.PolicyID)))
		i += copy(dAtA[i:], m.PolicyID)
	}
	return i, nil
}

func (m *AlertSource) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AlertSource) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Component) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(len(m.Component)))
		i += copy(dAtA[i:], m.Component)
	}
	if len(m.NodeName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(len(m.NodeName)))
		i += copy(dAtA[i:], m.NodeName)
	}
	return i, nil
}

func (m *AlertSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AlertSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.State) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(len(m.State)))
		i += copy(dAtA[i:], m.State)
	}
	return i, nil
}

func (m *AlertStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AlertStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Severity) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(len(m.Severity)))
		i += copy(dAtA[i:], m.Severity)
	}
	if m.Source != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(m.Source.Size()))
		n13, err := m.Source.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	dAtA[i] = 0x1a
	i++
	i = encodeVarintAlerts(dAtA, i, uint64(m.ObjectRef.Size()))
	n14, err := m.ObjectRef.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n14
	if len(m.Message) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	dAtA[i] = 0x2a
	i++
	i = encodeVarintAlerts(dAtA, i, uint64(m.Reason.Size()))
	n15, err := m.Reason.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n15
	if m.Acknowledged != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(m.Acknowledged.Size()))
		n16, err := m.Acknowledged.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	if m.Resolved != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(m.Resolved.Size()))
		n17, err := m.Resolved.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	return i, nil
}

func (m *AuditInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuditInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.User) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(len(m.User)))
		i += copy(dAtA[i:], m.User)
	}
	if m.Time != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(m.Time.Size()))
		n18, err := m.Time.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	return i, nil
}

func (m *AuthConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuthConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Algo) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(len(m.Algo)))
		i += copy(dAtA[i:], m.Algo)
	}
	if len(m.Password) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(len(m.Password)))
		i += copy(dAtA[i:], m.Password)
	}
	return i, nil
}

func (m *MatchedRequirement) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MatchedRequirement) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintAlerts(dAtA, i, uint64(m.Requirement.Size()))
	n19, err := m.Requirement.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n19
	if len(m.ObservedValue) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(len(m.ObservedValue)))
		i += copy(dAtA[i:], m.ObservedValue)
	}
	return i, nil
}

func (m *PrivacyConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PrivacyConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Algo) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(len(m.Algo)))
		i += copy(dAtA[i:], m.Algo)
	}
	if len(m.Password) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(len(m.Password)))
		i += copy(dAtA[i:], m.Password)
	}
	return i, nil
}

func (m *Requirement) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Requirement) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.FieldOrMetric) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(len(m.FieldOrMetric)))
		i += copy(dAtA[i:], m.FieldOrMetric)
	}
	if len(m.Operator) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(len(m.Operator)))
		i += copy(dAtA[i:], m.Operator)
	}
	if len(m.Values) > 0 {
		for _, s := range m.Values {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *SNMPTrapServer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SNMPTrapServer) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Host) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(len(m.Host)))
		i += copy(dAtA[i:], m.Host)
	}
	if len(m.Port) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(len(m.Port)))
		i += copy(dAtA[i:], m.Port)
	}
	if len(m.Version) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(len(m.Version)))
		i += copy(dAtA[i:], m.Version)
	}
	if len(m.CommunityOrUser) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(len(m.CommunityOrUser)))
		i += copy(dAtA[i:], m.CommunityOrUser)
	}
	if m.AuthConfig != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(m.AuthConfig.Size()))
		n20, err := m.AuthConfig.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	if m.PrivacyConfig != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(m.PrivacyConfig.Size()))
		n21, err := m.PrivacyConfig.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	return i, nil
}

func encodeVarintAlerts(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Alert) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovAlerts(uint64(l))
	l = m.ObjectMeta.Size()
	n += 1 + l + sovAlerts(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovAlerts(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovAlerts(uint64(l))
	return n
}

func (m *AlertDestination) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovAlerts(uint64(l))
	l = m.ObjectMeta.Size()
	n += 1 + l + sovAlerts(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovAlerts(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovAlerts(uint64(l))
	return n
}

func (m *AlertDestinationSpec) Size() (n int) {
	var l int
	_ = l
	if m.Default {
		n += 2
	}
	if len(m.EmailList) > 0 {
		for _, s := range m.EmailList {
			l = len(s)
			n += 1 + l + sovAlerts(uint64(l))
		}
	}
	if len(m.SNMPTrapServers) > 0 {
		for _, e := range m.SNMPTrapServers {
			l = e.Size()
			n += 1 + l + sovAlerts(uint64(l))
		}
	}
	return n
}

func (m *AlertDestinationStatus) Size() (n int) {
	var l int
	_ = l
	if m.TotalNotificationsSent != 0 {
		n += 1 + sovAlerts(uint64(m.TotalNotificationsSent))
	}
	return n
}

func (m *AlertPolicy) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovAlerts(uint64(l))
	l = m.ObjectMeta.Size()
	n += 1 + l + sovAlerts(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovAlerts(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovAlerts(uint64(l))
	return n
}

func (m *AlertPolicySpec) Size() (n int) {
	var l int
	_ = l
	l = len(m.Resource)
	if l > 0 {
		n += 1 + l + sovAlerts(uint64(l))
	}
	l = len(m.Severity)
	if l > 0 {
		n += 1 + l + sovAlerts(uint64(l))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovAlerts(uint64(l))
	}
	if len(m.Requirements) > 0 {
		for _, e := range m.Requirements {
			l = e.Size()
			n += 1 + l + sovAlerts(uint64(l))
		}
	}
	l = len(m.PersistenceDuration)
	if l > 0 {
		n += 1 + l + sovAlerts(uint64(l))
	}
	l = len(m.ClearDuration)
	if l > 0 {
		n += 1 + l + sovAlerts(uint64(l))
	}
	if m.Enable {
		n += 2
	}
	if m.AutoResolve {
		n += 2
	}
	if len(m.Destinations) > 0 {
		for _, s := range m.Destinations {
			l = len(s)
			n += 1 + l + sovAlerts(uint64(l))
		}
	}
	return n
}

func (m *AlertPolicyStatus) Size() (n int) {
	var l int
	_ = l
	if m.TotalHits != 0 {
		n += 1 + sovAlerts(uint64(m.TotalHits))
	}
	if m.OpenAlerts != 0 {
		n += 1 + sovAlerts(uint64(m.OpenAlerts))
	}
	if m.AcknowledgedAlerts != 0 {
		n += 1 + sovAlerts(uint64(m.AcknowledgedAlerts))
	}
	return n
}

func (m *AlertReason) Size() (n int) {
	var l int
	_ = l
	if len(m.MatchedRequirements) > 0 {
		for _, e := range m.MatchedRequirements {
			l = e.Size()
			n += 1 + l + sovAlerts(uint64(l))
		}
	}
	l = len(m.PolicyID)
	if l > 0 {
		n += 1 + l + sovAlerts(uint64(l))
	}
	return n
}

func (m *AlertSource) Size() (n int) {
	var l int
	_ = l
	l = len(m.Component)
	if l > 0 {
		n += 1 + l + sovAlerts(uint64(l))
	}
	l = len(m.NodeName)
	if l > 0 {
		n += 1 + l + sovAlerts(uint64(l))
	}
	return n
}

func (m *AlertSpec) Size() (n int) {
	var l int
	_ = l
	l = len(m.State)
	if l > 0 {
		n += 1 + l + sovAlerts(uint64(l))
	}
	return n
}

func (m *AlertStatus) Size() (n int) {
	var l int
	_ = l
	l = len(m.Severity)
	if l > 0 {
		n += 1 + l + sovAlerts(uint64(l))
	}
	if m.Source != nil {
		l = m.Source.Size()
		n += 1 + l + sovAlerts(uint64(l))
	}
	l = m.ObjectRef.Size()
	n += 1 + l + sovAlerts(uint64(l))
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovAlerts(uint64(l))
	}
	l = m.Reason.Size()
	n += 1 + l + sovAlerts(uint64(l))
	if m.Acknowledged != nil {
		l = m.Acknowledged.Size()
		n += 1 + l + sovAlerts(uint64(l))
	}
	if m.Resolved != nil {
		l = m.Resolved.Size()
		n += 1 + l + sovAlerts(uint64(l))
	}
	return n
}

func (m *AuditInfo) Size() (n int) {
	var l int
	_ = l
	l = len(m.User)
	if l > 0 {
		n += 1 + l + sovAlerts(uint64(l))
	}
	if m.Time != nil {
		l = m.Time.Size()
		n += 1 + l + sovAlerts(uint64(l))
	}
	return n
}

func (m *AuthConfig) Size() (n int) {
	var l int
	_ = l
	l = len(m.Algo)
	if l > 0 {
		n += 1 + l + sovAlerts(uint64(l))
	}
	l = len(m.Password)
	if l > 0 {
		n += 1 + l + sovAlerts(uint64(l))
	}
	return n
}

func (m *MatchedRequirement) Size() (n int) {
	var l int
	_ = l
	l = m.Requirement.Size()
	n += 1 + l + sovAlerts(uint64(l))
	l = len(m.ObservedValue)
	if l > 0 {
		n += 1 + l + sovAlerts(uint64(l))
	}
	return n
}

func (m *PrivacyConfig) Size() (n int) {
	var l int
	_ = l
	l = len(m.Algo)
	if l > 0 {
		n += 1 + l + sovAlerts(uint64(l))
	}
	l = len(m.Password)
	if l > 0 {
		n += 1 + l + sovAlerts(uint64(l))
	}
	return n
}

func (m *Requirement) Size() (n int) {
	var l int
	_ = l
	l = len(m.FieldOrMetric)
	if l > 0 {
		n += 1 + l + sovAlerts(uint64(l))
	}
	l = len(m.Operator)
	if l > 0 {
		n += 1 + l + sovAlerts(uint64(l))
	}
	if len(m.Values) > 0 {
		for _, s := range m.Values {
			l = len(s)
			n += 1 + l + sovAlerts(uint64(l))
		}
	}
	return n
}

func (m *SNMPTrapServer) Size() (n int) {
	var l int
	_ = l
	l = len(m.Host)
	if l > 0 {
		n += 1 + l + sovAlerts(uint64(l))
	}
	l = len(m.Port)
	if l > 0 {
		n += 1 + l + sovAlerts(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovAlerts(uint64(l))
	}
	l = len(m.CommunityOrUser)
	if l > 0 {
		n += 1 + l + sovAlerts(uint64(l))
	}
	if m.AuthConfig != nil {
		l = m.AuthConfig.Size()
		n += 1 + l + sovAlerts(uint64(l))
	}
	if m.PrivacyConfig != nil {
		l = m.PrivacyConfig.Size()
		n += 1 + l + sovAlerts(uint64(l))
	}
	return n
}

func sovAlerts(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozAlerts(x uint64) (n int) {
	return sovAlerts(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Alert) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAlerts
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Alert: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Alert: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAlerts(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAlerts
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AlertDestination) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAlerts
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AlertDestination: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AlertDestination: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAlerts(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAlerts
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AlertDestinationSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAlerts
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AlertDestinationSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AlertDestinationSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Default", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Default = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EmailList", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EmailList = append(m.EmailList, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SNMPTrapServers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SNMPTrapServers = append(m.SNMPTrapServers, &SNMPTrapServer{})
			if err := m.SNMPTrapServers[len(m.SNMPTrapServers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAlerts(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAlerts
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AlertDestinationStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAlerts
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AlertDestinationStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AlertDestinationStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalNotificationsSent", wireType)
			}
			m.TotalNotificationsSent = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalNotificationsSent |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAlerts(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAlerts
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AlertPolicy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAlerts
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AlertPolicy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AlertPolicy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAlerts(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAlerts
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AlertPolicySpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAlerts
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AlertPolicySpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AlertPolicySpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resource", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Resource = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Severity", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Severity = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Requirements", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Requirements = append(m.Requirements, Requirement{})
			if err := m.Requirements[len(m.Requirements)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PersistenceDuration", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PersistenceDuration = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClearDuration", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClearDuration = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enable = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoResolve", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AutoResolve = bool(v != 0)
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Destinations", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Destinations = append(m.Destinations, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAlerts(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAlerts
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AlertPolicyStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAlerts
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AlertPolicyStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AlertPolicyStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalHits", wireType)
			}
			m.TotalHits = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalHits |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenAlerts", wireType)
			}
			m.OpenAlerts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OpenAlerts |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AcknowledgedAlerts", wireType)
			}
			m.AcknowledgedAlerts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AcknowledgedAlerts |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAlerts(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAlerts
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AlertReason) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAlerts
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AlertReason: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AlertReason: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchedRequirements", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MatchedRequirements = append(m.MatchedRequirements, &MatchedRequirement{})
			if err := m.MatchedRequirements[len(m.MatchedRequirements)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PolicyID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PolicyID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAlerts(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAlerts
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AlertSource) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAlerts
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AlertSource: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AlertSource: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Component", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Component = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAlerts(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAlerts
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AlertSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAlerts
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AlertSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AlertSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAlerts(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAlerts
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AlertStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAlerts
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AlertStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AlertStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Severity", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Severity = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Source == nil {
				m.Source = &AlertSource{}
			}
			if err := m.Source.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectRef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectRef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Reason.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Acknowledged", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Acknowledged == nil {
				m.Acknowledged = &AuditInfo{}
			}
			if err := m.Acknowledged.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resolved", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Resolved == nil {
				m.Resolved = &AuditInfo{}
			}
			if err := m.Resolved.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAlerts(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAlerts
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuditInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAlerts
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuditInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuditInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.User = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Time == nil {
				m.Time = &api.Timestamp{}
			}
			if err := m.Time.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAlerts(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAlerts
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuthConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAlerts
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuthConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuthConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Algo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Algo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Password", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Password = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAlerts(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAlerts
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MatchedRequirement) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAlerts
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MatchedRequirement: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MatchedRequirement: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Requirement", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Requirement.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObservedValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ObservedValue = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAlerts(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAlerts
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PrivacyConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAlerts
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PrivacyConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PrivacyConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Algo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Algo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Password", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Password = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAlerts(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAlerts
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Requirement) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAlerts
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Requirement: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Requirement: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FieldOrMetric", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FieldOrMetric = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Operator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Values", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Values = append(m.Values, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAlerts(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAlerts
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SNMPTrapServer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAlerts
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SNMPTrapServer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SNMPTrapServer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Host", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Host = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Port = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommunityOrUser", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CommunityOrUser = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AuthConfig == nil {
				m.AuthConfig = &AuthConfig{}
			}
			if err := m.AuthConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrivacyConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PrivacyConfig == nil {
				m.PrivacyConfig = &PrivacyConfig{}
			}
			if err := m.PrivacyConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAlerts(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAlerts
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipAlerts(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowAlerts
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthAlerts
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowAlerts
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipAlerts(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthAlerts = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowAlerts   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("alerts.proto", fileDescriptorAlerts) }

var fileDescriptorAlerts = []byte{
	// 1849 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x58, 0x41, 0x6f, 0x1b, 0xc7,
	0x15, 0xd6, 0x92, 0x14, 0x45, 0x8e, 0xa4, 0x88, 0x19, 0x45, 0x32, 0x29, 0xcb, 0xa2, 0xba, 0x71,
	0x1a, 0x17, 0xc9, 0x92, 0xb1, 0x1d, 0x27, 0xa9, 0x83, 0xa6, 0xe0, 0x8a, 0xac, 0xe5, 0x58, 0x22,
	0x59, 0x51, 0x56, 0x81, 0x22, 0x87, 0xae, 0x76, 0x87, 0xd4, 0xa6, 0xbb, 0x33, 0x9b, 0xdd, 0x59,
	0x1a, 0x42, 0x91, 0x53, 0x61, 0xfd, 0x82, 0xfe, 0x80, 0xde, 0x0a, 0xa8, 0xe8, 0xb1, 0x87, 0x5e,
	0x7a, 0xf6, 0xa1, 0x87, 0xc0, 0x3f, 0x40, 0x28, 0x7c, 0x2a, 0x74, 0xcb, 0xad, 0xc7, 0x62, 0x66,
	0x67, 0x97, 0x33, 0x14, 0x55, 0xe8, 0xd0, 0xe6, 0x64, 0xf3, 0xbd, 0xef, 0x7d, 0x33, 0xf3, 0xcd,
	0x9b, 0x6f, 0x66, 0x05, 0x96, 0x2c, 0x0f, 0x85, 0x34, 0x6a, 0x04, 0x21, 0xa1, 0x04, 0x02, 0x9f,
	0x60, 0x97, 0x92, 0xd0, 0xc5, 0xa3, 0x8d, 0xcd, 0x11, 0x21, 0x23, 0x0f, 0x35, 0xad, 0xc0, 0x6d,
	0x5a, 0x18, 0x13, 0x6a, 0x51, 0x97, 0x60, 0x81, 0xdc, 0xe8, 0x8c, 0x5c, 0x7a, 0x12, 0x1f, 0x37,
	0x6c, 0xe2, 0x37, 0x03, 0x84, 0x23, 0x0b, 0x3b, 0xa4, 0x19, 0xbd, 0x68, 0x8e, 0x11, 0x76, 0x6d,
	0xd4, 0x8c, 0xa9, 0xeb, 0x45, 0xac, 0x74, 0x84, 0xb0, 0x5c, 0xdd, 0x74, 0xb1, 0xed, 0xc5, 0x0e,
	0x4a, 0x69, 0x0c, 0x89, 0x66, 0x44, 0x46, 0xa4, 0xc9, 0xc3, 0xc7, 0xf1, 0x90, 0xff, 0xe2, 0x3f,
	0xf8, 0xff, 0x04, 0xfc, 0xbd, 0x6b, 0x46, 0x65, 0x73, 0xf4, 0x11, 0xb5, 0x12, 0x98, 0xfe, 0xc7,
	0x1c, 0x98, 0x6f, 0xb1, 0x75, 0xc1, 0x8f, 0x80, 0x76, 0x58, 0xd5, 0xb6, 0xb5, 0x7b, 0x8b, 0x0f,
	0x96, 0x1b, 0x56, 0xe0, 0x36, 0x0e, 0x4f, 0x03, 0xb4, 0x8f, 0xa8, 0x65, 0xae, 0xbe, 0xba, 0xa8,
	0xcf, 0x7d, 0x77, 0x51, 0xd7, 0x2e, 0x2f, 0xea, 0x0b, 0x1f, 0xba, 0xd8, 0x73, 0x31, 0x3a, 0xd0,
	0x0e, 0xe1, 0x63, 0xa0, 0xf5, 0xaa, 0x39, 0x5e, 0xb1, 0xc2, 0x2b, 0x7a, 0xc7, 0x5f, 0x23, 0x9b,
	0xf2, 0x9a, 0xdb, 0x52, 0xcd, 0x0a, 0x1b, 0xef, 0xc3, 0x6d, 0xe2, 0xbb, 0x14, 0xf9, 0x01, 0x3d,
	0x3d, 0xd0, 0x7a, 0xd0, 0x04, 0x85, 0x41, 0x80, 0xec, 0x6a, 0x9e, 0x97, 0xaf, 0x35, 0x26, 0x6a,
	0x36, 0xf8, 0x74, 0x58, 0xd2, 0xbc, 0xc5, 0x48, 0x18, 0x41, 0x14, 0x20, 0x5b, 0x26, 0xe0, 0xb5,
	0xf0, 0x4b, 0x50, 0x1c, 0x50, 0x8b, 0xc6, 0x51, 0xb5, 0xc0, 0x59, 0x6e, 0x5d, 0x65, 0xe1, 0x69,
	0xb3, 0x26, 0x78, 0xde, 0x8e, 0xf8, 0x6f, 0x99, 0x49, 0x30, 0x3c, 0xae, 0xbd, 0x7e, 0x59, 0x5b,
	0x03, 0x8b, 0xcd, 0xdf, 0xf5, 0x1a, 0x87, 0x08, 0x5b, 0x98, 0x7e, 0x0b, 0x8b, 0xc9, 0x7e, 0xeb,
	0xff, 0xc8, 0x81, 0x0a, 0x67, 0x6b, 0xa3, 0x88, 0xba, 0x98, 0xef, 0xce, 0x0f, 0xac, 0xd6, 0xbe,
	0xa2, 0xd6, 0xf6, 0x95, 0x75, 0x4a, 0x33, 0xbb, 0x89, 0x70, 0xcf, 0xa7, 0x84, 0xd3, 0xff, 0x2b,
	0xe1, 0x8d, 0x35, 0xbc, 0xfb, 0xfa, 0x65, 0x6d, 0x5b, 0xd5, 0xf0, 0x6d, 0x6b, 0x8a, 0x2d, 0xd2,
	0xbf, 0xd7, 0xc0, 0x3b, 0xb3, 0x26, 0x0d, 0x3f, 0x02, 0x0b, 0x6d, 0x34, 0xb4, 0x62, 0x8f, 0x72,
	0x61, 0x4b, 0xe6, 0xfa, 0xe5, 0x45, 0x1d, 0x3a, 0x49, 0x48, 0x1e, 0x2f, 0x85, 0xc1, 0xcf, 0x41,
	0xb9, 0xe3, 0x5b, 0xae, 0xb7, 0xe7, 0x46, 0xb4, 0x9a, 0xdb, 0xce, 0xdf, 0x2b, 0x9b, 0x77, 0x5e,
	0x25, 0x2a, 0xae, 0x21, 0x96, 0x30, 0x3c, 0x37, 0x52, 0x4a, 0x27, 0x78, 0xf8, 0x35, 0x58, 0x19,
	0x74, 0xf7, 0xfb, 0x87, 0xa1, 0x15, 0x0c, 0x50, 0x38, 0x46, 0x61, 0x54, 0xcd, 0x6f, 0xe7, 0xef,
	0x2d, 0x3e, 0xd8, 0x90, 0xd5, 0x50, 0x21, 0xe6, 0x5d, 0x41, 0xbf, 0x19, 0x61, 0x3f, 0x30, 0x68,
	0x68, 0x05, 0x46, 0x94, 0x14, 0xcb, 0xa3, 0x4c, 0x13, 0xeb, 0xdf, 0x82, 0xf5, 0xd9, 0xb2, 0x42,
	0x1b, 0xac, 0x53, 0x42, 0x2d, 0xaf, 0x4b, 0xa8, 0x3b, 0x74, 0xed, 0x44, 0xa3, 0x01, 0xc2, 0x89,
	0x06, 0xf3, 0xe6, 0x07, 0x62, 0xc0, 0x77, 0x39, 0xca, 0xc0, 0x32, 0xcc, 0x88, 0x10, 0x56, 0x56,
	0x77, 0x0d, 0x95, 0xfe, 0xb7, 0x1c, 0x58, 0xe4, 0xe3, 0xf7, 0x89, 0xe7, 0xda, 0xa7, 0x3f, 0x70,
	0xf3, 0xee, 0x2a, 0xcd, 0x7b, 0xfb, 0x4a, 0xaf, 0x25, 0x93, 0xba, 0x49, 0xdf, 0xf6, 0xa7, 0xfa,
	0xf6, 0xce, 0x75, 0x5c, 0x37, 0x6e, 0xd9, 0xed, 0xd7, 0x2f, 0x6b, 0x9b, 0x6a, 0xcb, 0x2e, 0x5b,
	0x19, 0x91, 0x8b, 0x22, 0xfd, 0xdf, 0x05, 0xb0, 0x32, 0x35, 0x4d, 0xf8, 0x10, 0x94, 0x0e, 0x50,
	0x44, 0xe2, 0xd0, 0x46, 0x5c, 0xc6, 0xb2, 0x79, 0xeb, 0xf2, 0xa2, 0xbe, 0x1a, 0x8a, 0x98, 0x3c,
	0x50, 0x06, 0x84, 0xbf, 0x04, 0xa5, 0x01, 0x1a, 0xa3, 0xd0, 0xa5, 0xa7, 0x5c, 0xc9, 0xb2, 0xf9,
	0xe8, 0xfc, 0xac, 0xb6, 0x3e, 0xa0, 0x61, 0x07, 0xc7, 0xfe, 0xbd, 0x34, 0xb7, 0x87, 0xc6, 0xc8,
	0xfb, 0x89, 0xd8, 0xf5, 0xd5, 0x48, 0x44, 0x15, 0xca, 0x14, 0x0a, 0x3f, 0x06, 0x0b, 0xfb, 0x28,
	0x8a, 0xac, 0x11, 0xe2, 0xe2, 0x96, 0xcd, 0x0d, 0x51, 0x07, 0xfd, 0x24, 0xac, 0x9c, 0x1a, 0x01,
	0x85, 0x5f, 0x81, 0xa5, 0x03, 0xf4, 0x4d, 0xec, 0x86, 0xc8, 0x47, 0x98, 0x32, 0x2d, 0xf3, 0xd3,
	0xe6, 0x29, 0xe5, 0xcd, 0xba, 0x50, 0xf1, 0x56, 0x28, 0x15, 0xc9, 0xc4, 0x0a, 0x1b, 0x7c, 0x0e,
	0x56, 0xfb, 0x28, 0x8c, 0xdc, 0x88, 0x22, 0x6c, 0xa3, 0x76, 0x1c, 0xf2, 0x3e, 0xac, 0xce, 0xf3,
	0xf9, 0xbd, 0x7b, 0x79, 0x51, 0xaf, 0x07, 0x93, 0xb4, 0xe1, 0x88, 0xbc, 0xcc, 0x37, 0xab, 0x1e,
	0xee, 0x80, 0xe5, 0x1d, 0x0f, 0x59, 0x61, 0x46, 0x58, 0xe4, 0x84, 0x77, 0x2e, 0x2f, 0xea, 0x35,
	0x9b, 0x25, 0x66, 0x52, 0xa9, 0x35, 0xd0, 0x00, 0xc5, 0x0e, 0xb6, 0x8e, 0x3d, 0x54, 0x5d, 0xe0,
	0x06, 0xb3, 0xc6, 0x9a, 0x03, 0xf1, 0x88, 0xd2, 0x1c, 0x09, 0x08, 0xfe, 0x0c, 0x2c, 0xb6, 0x62,
	0x4a, 0xd8, 0x0e, 0x7a, 0x63, 0x54, 0x2d, 0xf1, 0x9a, 0xdb, 0x4c, 0x0a, 0x2b, 0xa6, 0xc4, 0x08,
	0x93, 0xb8, 0x5c, 0x29, 0xe3, 0xe1, 0xcf, 0xc1, 0x92, 0x6c, 0x7c, 0xd5, 0x32, 0x37, 0x28, 0x5e,
	0xef, 0x48, 0x71, 0x45, 0x4a, 0xc5, 0x29, 0xff, 0xa5, 0x81, 0xb7, 0xaf, 0x74, 0x35, 0x33, 0xbd,
	0x43, 0x76, 0xcc, 0x77, 0x5d, 0x1a, 0x09, 0x93, 0xc8, 0x4c, 0x2f, 0x31, 0x89, 0x13, 0x57, 0xdd,
	0xa0, 0x09, 0x1e, 0x7e, 0x01, 0x40, 0x2f, 0x40, 0x98, 0xb3, 0x46, 0xbc, 0x0d, 0xe7, 0xcd, 0x2d,
	0x51, 0xbd, 0x4e, 0x02, 0x84, 0x8d, 0xe4, 0xd2, 0x93, 0xcb, 0xa5, 0x0a, 0x78, 0x04, 0x60, 0xcb,
	0xfe, 0x2d, 0x26, 0x2f, 0x3c, 0xe4, 0x8c, 0x90, 0x23, 0x78, 0xf2, 0x9c, 0xe7, 0xc7, 0x82, 0x67,
	0xcb, 0x92, 0x10, 0x33, 0xf8, 0x66, 0x30, 0xe8, 0xaf, 0x34, 0xe1, 0x50, 0x07, 0xc8, 0x8a, 0x08,
	0x86, 0xa7, 0x60, 0x75, 0xdf, 0xa2, 0xf6, 0x09, 0x72, 0x94, 0x56, 0xd5, 0x78, 0xab, 0x6e, 0xc9,
	0xad, 0x7a, 0x15, 0x66, 0xbe, 0x2f, 0x26, 0x52, 0xf7, 0x93, 0x9c, 0x71, 0x5d, 0xe7, 0xce, 0x1a,
	0x03, 0x7e, 0x01, 0x4a, 0x89, 0xde, 0x4f, 0xdb, 0xe2, 0x9c, 0xea, 0x82, 0x6f, 0x83, 0xaf, 0xc5,
	0x08, 0x78, 0xd6, 0x70, 0x1d, 0xe5, 0x50, 0xa6, 0x35, 0xfa, 0xef, 0xd3, 0xa5, 0x0c, 0x92, 0x73,
	0xff, 0x18, 0x94, 0x77, 0x88, 0x1f, 0x10, 0x9c, 0x9a, 0x7a, 0xd9, 0xdc, 0x14, 0x84, 0xef, 0xd8,
	0x69, 0x42, 0xd9, 0xae, 0x0c, 0x0e, 0x3f, 0x03, 0xa5, 0x2e, 0x71, 0x50, 0xd7, 0xf2, 0x91, 0x98,
	0x4b, 0x56, 0x8a, 0x89, 0x83, 0x0c, 0x6c, 0xf9, 0xaa, 0xdb, 0xa4, 0x68, 0xfd, 0x0f, 0x1a, 0x28,
	0x67, 0x0f, 0x29, 0xd8, 0x03, 0xf3, 0xac, 0x7b, 0x52, 0xb7, 0xfa, 0xe9, 0xf9, 0x59, 0xed, 0x4e,
	0x6a, 0x3c, 0x19, 0x6a, 0xf2, 0x64, 0x42, 0xa9, 0xff, 0x54, 0x98, 0x73, 0x2a, 0x23, 0x24, 0x3c,
	0xfa, 0x27, 0x00, 0x4c, 0xd0, 0xb0, 0x04, 0x0a, 0xbd, 0x7e, 0xa7, 0x5b, 0x99, 0x83, 0x4b, 0xa0,
	0x74, 0xd0, 0x19, 0xf4, 0xf6, 0x8e, 0x3a, 0xed, 0x8a, 0x06, 0x2b, 0x60, 0xa9, 0xb5, 0xf3, 0xac,
	0xdb, 0xfb, 0xd5, 0x5e, 0xa7, 0xfd, 0xa4, 0xd3, 0xae, 0xe4, 0xf4, 0x3f, 0x15, 0x52, 0x71, 0x92,
	0x66, 0x96, 0x4d, 0x51, 0xfb, 0xdf, 0x98, 0x22, 0x7b, 0x15, 0x26, 0xd6, 0x9c, 0xbb, 0xee, 0x55,
	0xc8, 0xd3, 0xfc, 0x7a, 0xd0, 0xf8, 0xf5, 0x70, 0xc5, 0xb5, 0x05, 0x03, 0x7c, 0x06, 0xca, 0xc9,
	0x45, 0x77, 0x80, 0x86, 0xe2, 0xfe, 0x7a, 0x4b, 0xba, 0xfe, 0x0e, 0xd0, 0x90, 0x9f, 0x3d, 0x66,
	0x8f, 0x6b, 0x84, 0x87, 0x8c, 0x10, 0x0d, 0x95, 0xcd, 0xcc, 0x90, 0xb2, 0x5b, 0x17, 0x6e, 0xee,
	0xd6, 0x5f, 0x82, 0x62, 0x72, 0x26, 0xb8, 0x85, 0xce, 0x5a, 0x4e, 0x92, 0x9e, 0xdc, 0x76, 0x21,
	0xff, 0xad, 0x2c, 0x47, 0x9c, 0xaa, 0x5f, 0x83, 0x25, 0xf9, 0xec, 0x71, 0x0f, 0x9d, 0x7e, 0x7c,
	0xc7, 0x8e, 0x4b, 0x9f, 0xe2, 0x21, 0xe1, 0xbe, 0xaf, 0x71, 0xb3, 0x93, 0x4a, 0x14, 0xb3, 0x92,
	0xb9, 0x60, 0x37, 0xb9, 0x13, 0xbd, 0x31, 0x72, 0xb8, 0xbb, 0x5e, 0xcb, 0x7b, 0x3b, 0xdd, 0x46,
	0xe1, 0x9f, 0xce, 0x95, 0xeb, 0x92, 0x05, 0xf5, 0x18, 0x94, 0xb3, 0x1a, 0xf8, 0x01, 0x28, 0x3c,
	0x8f, 0x50, 0x98, 0x5e, 0xb6, 0x82, 0x61, 0x25, 0x8e, 0x50, 0xa8, 0xbc, 0x12, 0x18, 0x08, 0x7e,
	0x0e, 0x0a, 0x87, 0xae, 0x9f, 0x6e, 0x7f, 0xb2, 0x5f, 0x2c, 0x10, 0x51, 0xcb, 0x0f, 0x26, 0xc5,
	0xd4, 0x55, 0xcf, 0x0e, 0x2f, 0xd2, 0xff, 0xac, 0x01, 0xd0, 0x8a, 0xe9, 0xc9, 0x0e, 0xc1, 0x43,
	0x77, 0xc4, 0xde, 0x2e, 0x2d, 0x6f, 0x44, 0xc4, 0xc0, 0x1f, 0x9f, 0x9f, 0xd5, 0x6a, 0xd9, 0xb9,
	0xc9, 0x50, 0x0d, 0x06, 0x89, 0xd2, 0xf6, 0x5c, 0xb1, 0xbc, 0x11, 0x51, 0x88, 0x59, 0x1a, 0x7e,
	0x0a, 0x4a, 0x7d, 0x2b, 0x8a, 0x5e, 0x90, 0xd0, 0x11, 0x47, 0x39, 0x13, 0x22, 0x10, 0x71, 0xd5,
	0x4f, 0x44, 0x50, 0xdf, 0x60, 0x1f, 0x68, 0x23, 0x12, 0xc1, 0x05, 0x90, 0xdf, 0x6f, 0x3f, 0xaa,
	0xcc, 0xb1, 0xe3, 0x36, 0xd8, 0x6d, 0xdd, 0xaf, 0x68, 0xfa, 0x5f, 0x34, 0x00, 0xaf, 0x7a, 0x18,
	0xec, 0x82, 0x45, 0xe9, 0xa7, 0x78, 0xe9, 0x5d, 0x7b, 0xc1, 0xcf, 0x7c, 0xf3, 0xc9, 0x04, 0xf0,
	0x09, 0x58, 0xee, 0x1d, 0xf3, 0x77, 0xae, 0x73, 0x64, 0x79, 0x71, 0xea, 0x45, 0x3f, 0x12, 0x0b,
	0xa8, 0x11, 0x91, 0x34, 0xc6, 0x2c, 0xab, 0x5c, 0xc0, 0x4a, 0x9d, 0xfe, 0x57, 0x0d, 0x2c, 0xf7,
	0x43, 0x77, 0x6c, 0xd9, 0xa7, 0x42, 0xe0, 0x67, 0x8a, 0xc0, 0x9f, 0x9e, 0x9f, 0xd5, 0x36, 0x53,
	0x81, 0x15, 0xe0, 0xff, 0x57, 0xe3, 0xad, 0x54, 0xe3, 0x32, 0x98, 0x6f, 0x77, 0x06, 0x8f, 0x3e,
	0xa9, 0xcc, 0x41, 0x00, 0x8a, 0xad, 0xce, 0xe0, 0xfe, 0x83, 0xcf, 0x2a, 0x9a, 0xfe, 0xf7, 0x9c,
	0xa2, 0x28, 0xdc, 0x05, 0xcb, 0xbf, 0x70, 0x91, 0xe7, 0xf4, 0xc2, 0x7d, 0x44, 0x43, 0xd7, 0x16,
	0xd3, 0xcf, 0x2e, 0x8a, 0x21, 0x4b, 0x1a, 0x24, 0x34, 0x7c, 0x9e, 0x56, 0x14, 0x51, 0x0a, 0xe1,
	0x6f, 0x40, 0xa9, 0x17, 0xa0, 0xd0, 0xa2, 0x24, 0x14, 0x53, 0x6e, 0x9f, 0x9f, 0xd5, 0xde, 0x4b,
	0x35, 0x90, 0x06, 0x6d, 0xb4, 0x3c, 0x8f, 0xbc, 0x40, 0x4e, 0x0a, 0xcf, 0xc4, 0x58, 0x25, 0x22,
	0xa2, 0xac, 0x2d, 0x85, 0xc1, 0xfb, 0xa0, 0xc8, 0xc5, 0x4f, 0x3e, 0x6f, 0xca, 0x13, 0xdb, 0xe3,
	0x9b, 0xa5, 0xbe, 0x8a, 0x13, 0xa0, 0xde, 0x67, 0x1f, 0xbc, 0xea, 0x60, 0x4c, 0x8e, 0xce, 0x37,
	0xb1, 0xe5, 0x45, 0x95, 0x39, 0x58, 0x04, 0xb9, 0xa7, 0xb8, 0xa2, 0xc1, 0x65, 0x50, 0xee, 0x12,
	0x2a, 0xc2, 0x39, 0x26, 0x5e, 0x97, 0xd0, 0xa7, 0xb8, 0x92, 0x67, 0x88, 0x27, 0xb4, 0x52, 0x60,
	0xff, 0xee, 0xd1, 0xca, 0xbc, 0xfe, 0x7d, 0x1e, 0xbc, 0xa5, 0x7e, 0x14, 0xc1, 0xf7, 0x41, 0x61,
	0x97, 0x44, 0xe9, 0x95, 0xb8, 0xca, 0x76, 0xf5, 0x84, 0xa8, 0x5f, 0x6b, 0x1c, 0xc0, 0x0e, 0x7f,
	0x9f, 0x84, 0x54, 0xc8, 0x93, 0x9d, 0xdf, 0x80, 0x84, 0x2a, 0x98, 0x81, 0xe0, 0x57, 0x60, 0xe1,
	0x88, 0x3d, 0x1f, 0x09, 0x16, 0x4f, 0x62, 0xf3, 0xfc, 0xac, 0x76, 0x37, 0xbb, 0x4f, 0x94, 0x29,
	0xf0, 0x8f, 0x3b, 0x81, 0xce, 0xd4, 0x84, 0xe3, 0x24, 0xa0, 0x98, 0xb1, 0x00, 0xc1, 0x2e, 0x58,
	0xd9, 0x21, 0xbe, 0x1f, 0x63, 0x97, 0x9e, 0xf6, 0x42, 0x6e, 0x49, 0x89, 0x95, 0x67, 0xdf, 0x85,
	0x76, 0x9a, 0x66, 0xbb, 0x3f, 0xed, 0x4f, 0xd3, 0xc5, 0xf0, 0x48, 0x36, 0x1b, 0x61, 0xf0, 0xeb,
	0xaa, 0x6d, 0xa6, 0xd9, 0xc9, 0x33, 0xcd, 0x8a, 0xe9, 0x89, 0x61, 0xf3, 0xa0, 0xf2, 0x4c, 0x93,
	0x6c, 0xeb, 0x78, 0xea, 0x98, 0x09, 0xa7, 0xaf, 0xc9, 0xd4, 0x0a, 0x60, 0x72, 0x96, 0x83, 0x24,
	0x3c, 0x63, 0x00, 0x95, 0x52, 0xaf, 0x83, 0x25, 0x59, 0x3f, 0x66, 0x4f, 0x47, 0x0f, 0x76, 0x92,
	0xee, 0x38, 0x7a, 0x58, 0xd1, 0xcc, 0xa5, 0x57, 0x6f, 0xb6, 0xb4, 0xef, 0xde, 0x6c, 0x69, 0xff,
	0x7c, 0xb3, 0xa5, 0xf5, 0xb5, 0xe3, 0x22, 0xff, 0x8b, 0xd3, 0xc3, 0xff, 0x04, 0x00, 0x00, 0xff,
	0xff, 0x7d, 0x7f, 0xc9, 0xaa, 0x48, 0x13, 0x00, 0x00,
}
