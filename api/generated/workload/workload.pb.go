// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: workload.proto

package workload

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/pensando/grpc-gateway/third_party/googleapis/google/api"
import _ "github.com/pensando/sw/venice/utils/apigen/annotations"
import _ "github.com/gogo/protobuf/gogoproto"
import api "github.com/pensando/sw/api"
import _ "github.com/pensando/sw/api/labels"
import _ "github.com/pensando/sw/api/generated/cluster"
import security1 "github.com/pensando/sw/api/generated/security"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// migration stage
type WorkloadMigrationStatus_MigrationStage int32

const (
	//
	WorkloadMigrationStatus_MIGRATION_NONE WorkloadMigrationStatus_MigrationStage = 0
	//
	WorkloadMigrationStatus_MIGRATION_START WorkloadMigrationStatus_MigrationStage = 1
	//
	WorkloadMigrationStatus_MIGRATION_FINAL_SYNC WorkloadMigrationStatus_MigrationStage = 2
	//
	WorkloadMigrationStatus_MIGRATION_DONE WorkloadMigrationStatus_MigrationStage = 3
	//
	WorkloadMigrationStatus_MIGRATION_ABORT WorkloadMigrationStatus_MigrationStage = 4
	//
	WorkloadMigrationStatus_MIGRATION_FROM_NON_PEN_HOST WorkloadMigrationStatus_MigrationStage = 5
)

var WorkloadMigrationStatus_MigrationStage_name = map[int32]string{
	0: "MIGRATION_NONE",
	1: "MIGRATION_START",
	2: "MIGRATION_FINAL_SYNC",
	3: "MIGRATION_DONE",
	4: "MIGRATION_ABORT",
	5: "MIGRATION_FROM_NON_PEN_HOST",
}
var WorkloadMigrationStatus_MigrationStage_value = map[string]int32{
	"MIGRATION_NONE":              0,
	"MIGRATION_START":             1,
	"MIGRATION_FINAL_SYNC":        2,
	"MIGRATION_DONE":              3,
	"MIGRATION_ABORT":             4,
	"MIGRATION_FROM_NON_PEN_HOST": 5,
}

func (WorkloadMigrationStatus_MigrationStage) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorWorkload, []int{3, 0}
}

//
type WorkloadMigrationStatus_DataplaneStatus int32

const (
	//
	WorkloadMigrationStatus_NONE WorkloadMigrationStatus_DataplaneStatus = 0
	//
	WorkloadMigrationStatus_STARTED WorkloadMigrationStatus_DataplaneStatus = 1
	//
	WorkloadMigrationStatus_DONE WorkloadMigrationStatus_DataplaneStatus = 2
	//
	WorkloadMigrationStatus_FAILED WorkloadMigrationStatus_DataplaneStatus = 3
	//
	WorkloadMigrationStatus_TIMED_OUT WorkloadMigrationStatus_DataplaneStatus = 4
)

var WorkloadMigrationStatus_DataplaneStatus_name = map[int32]string{
	0: "NONE",
	1: "STARTED",
	2: "DONE",
	3: "FAILED",
	4: "TIMED_OUT",
}
var WorkloadMigrationStatus_DataplaneStatus_value = map[string]int32{
	"NONE":      0,
	"STARTED":   1,
	"DONE":      2,
	"FAILED":    3,
	"TIMED_OUT": 4,
}

func (WorkloadMigrationStatus_DataplaneStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorWorkload, []int{3, 1}
}

// Workload represents a VM, container/pod or Baremetal.
type Workload struct {
	//
	api.TypeMeta `protobuf:"bytes,1,opt,name=T,json=,inline,embedded=T" json:",inline"`
	//
	api.ObjectMeta `protobuf:"bytes,2,opt,name=O,json=meta,omitempty,embedded=O" json:"meta,omitempty"`
	// Spec contains the configuration of the Workload.
	Spec WorkloadSpec `protobuf:"bytes,3,opt,name=Spec,json=spec,omitempty" json:"spec,omitempty"`
	// Status contains the current state of the Workload.
	Status WorkloadStatus `protobuf:"bytes,4,opt,name=Status,json=status,omitempty" json:"status,omitempty"`
}

func (m *Workload) Reset()                    { *m = Workload{} }
func (m *Workload) String() string            { return proto.CompactTextString(m) }
func (*Workload) ProtoMessage()               {}
func (*Workload) Descriptor() ([]byte, []int) { return fileDescriptorWorkload, []int{0} }

func (m *Workload) GetSpec() WorkloadSpec {
	if m != nil {
		return m.Spec
	}
	return WorkloadSpec{}
}

func (m *Workload) GetStatus() WorkloadStatus {
	if m != nil {
		return m.Status
	}
	return WorkloadStatus{}
}

// Spec of a Workload interface
type WorkloadIntfSpec struct {
	// MACAddress contains the MAC address of the interface as seen by the workload
	// cli-help: MAC address of the interface as seen by the workload
	MACAddress string `protobuf:"bytes,1,opt,name=MACAddress,json=mac-address,omitempty,proto3" json:"mac-address,omitempty"`
	// Micro-segmentation vlan assigned for this interface
	// cli-help: Vlan identifying host unique vlan id
	MicroSegVlan uint32 `protobuf:"varint,2,opt,name=MicroSegVlan,json=micro-seg-vlan,omitempty,proto3" json:"micro-seg-vlan,omitempty"`
	// External vlan assigned for this interface
	// cli-help: External vlan associated with the workload
	ExternalVlan uint32 `protobuf:"varint,3,opt,name=ExternalVlan,json=external-vlan,omitempty,proto3" json:"external-vlan,omitempty"`
	// List of all IP addresses configured on a Workload Interface
	IpAddresses []string `protobuf:"bytes,4,rep,name=IpAddresses,json=ip-addresses,omitempty" json:"ip-addresses,omitempty"`
	// Network this interface will belong to
	// cli-help: Network this interface will belong to
	Network string `protobuf:"bytes,5,opt,name=Network,json=network,omitempty,proto3" json:"network,omitempty"`
	// List of all DSC interfaces that can be used. The DSC interface is identified using the MAC
	// address assigned to the DSC port. If not specified, DSCs from workload's host object are used
	// cli-help: List of MAC addresses of the DSC ports associated with this workload interface
	DSCInterfaces []string `protobuf:"bytes,6,rep,name=DSCInterfaces,json=dsc-interfaces,omitempty" json:"dsc-interfaces,omitempty"`
}

func (m *WorkloadIntfSpec) Reset()                    { *m = WorkloadIntfSpec{} }
func (m *WorkloadIntfSpec) String() string            { return proto.CompactTextString(m) }
func (*WorkloadIntfSpec) ProtoMessage()               {}
func (*WorkloadIntfSpec) Descriptor() ([]byte, []int) { return fileDescriptorWorkload, []int{1} }

func (m *WorkloadIntfSpec) GetMACAddress() string {
	if m != nil {
		return m.MACAddress
	}
	return ""
}

func (m *WorkloadIntfSpec) GetMicroSegVlan() uint32 {
	if m != nil {
		return m.MicroSegVlan
	}
	return 0
}

func (m *WorkloadIntfSpec) GetExternalVlan() uint32 {
	if m != nil {
		return m.ExternalVlan
	}
	return 0
}

func (m *WorkloadIntfSpec) GetIpAddresses() []string {
	if m != nil {
		return m.IpAddresses
	}
	return nil
}

func (m *WorkloadIntfSpec) GetNetwork() string {
	if m != nil {
		return m.Network
	}
	return ""
}

func (m *WorkloadIntfSpec) GetDSCInterfaces() []string {
	if m != nil {
		return m.DSCInterfaces
	}
	return nil
}

// Status of a Workload interface
type WorkloadIntfStatus struct {
	// List of all IP addresses configured and discovered on a Workload Interface
	IpAddresses []string `protobuf:"bytes,1,rep,name=IpAddresses,json=ip-addresses,omitempty" json:"ip-addresses,omitempty"`
	// Endpoint associated with this Workload interface
	Endpoint string `protobuf:"bytes,2,opt,name=Endpoint,json=endpoint,omitempty,proto3" json:"endpoint,omitempty"`
	// Micro-segmentation vlan used by this interface
	MicroSegVlan uint32 `protobuf:"varint,3,opt,name=MicroSegVlan,json=micro-seg-vlan,omitempty,proto3" json:"micro-seg-vlan,omitempty"`
	// MACAddress contains the MAC address of the interface as seen by the workload
	MACAddress string `protobuf:"bytes,4,opt,name=MACAddress,json=mac-address,omitempty,proto3" json:"mac-address,omitempty"`
	// External vlan assigned for this interface
	ExternalVlan uint32 `protobuf:"varint,5,opt,name=ExternalVlan,json=external-vlan, omitempty,proto3" json:"external-vlan, omitempty"`
	// Network this interface belongs to
	Network string `protobuf:"bytes,6,opt,name=Network,json=network,omitempty,proto3" json:"network,omitempty"`
	// List of all DSC interfaces that can be used. The DSC interface is identified using the MAC
	// address assigned to the DSC port.
	DSCInterfaces []string `protobuf:"bytes,7,rep,name=DSCInterfaces,json=dsc-interfaces,omitempty" json:"dsc-interfaces,omitempty"`
}

func (m *WorkloadIntfStatus) Reset()                    { *m = WorkloadIntfStatus{} }
func (m *WorkloadIntfStatus) String() string            { return proto.CompactTextString(m) }
func (*WorkloadIntfStatus) ProtoMessage()               {}
func (*WorkloadIntfStatus) Descriptor() ([]byte, []int) { return fileDescriptorWorkload, []int{2} }

func (m *WorkloadIntfStatus) GetIpAddresses() []string {
	if m != nil {
		return m.IpAddresses
	}
	return nil
}

func (m *WorkloadIntfStatus) GetEndpoint() string {
	if m != nil {
		return m.Endpoint
	}
	return ""
}

func (m *WorkloadIntfStatus) GetMicroSegVlan() uint32 {
	if m != nil {
		return m.MicroSegVlan
	}
	return 0
}

func (m *WorkloadIntfStatus) GetMACAddress() string {
	if m != nil {
		return m.MACAddress
	}
	return ""
}

func (m *WorkloadIntfStatus) GetExternalVlan() uint32 {
	if m != nil {
		return m.ExternalVlan
	}
	return 0
}

func (m *WorkloadIntfStatus) GetNetwork() string {
	if m != nil {
		return m.Network
	}
	return ""
}

func (m *WorkloadIntfStatus) GetDSCInterfaces() []string {
	if m != nil {
		return m.DSCInterfaces
	}
	return nil
}

//
type WorkloadMigrationStatus struct {
	// Controller's migration stage
	Stage string `protobuf:"bytes,1,opt,name=Stage,json=stage,proto3" json:"stage"`
	// migration start time
	StartedAt *api.Timestamp `protobuf:"bytes,2,opt,name=StartedAt,json=started-at" json:"started-at"`
	// The status from the dataplane performing migration
	Status string `protobuf:"bytes,3,opt,name=Status,json=status,proto3" json:"status"`
	// migration completion time
	CompletedAt *api.Timestamp `protobuf:"bytes,4,opt,name=CompletedAt,json=completed-at" json:"completed-at"`
}

func (m *WorkloadMigrationStatus) Reset()                    { *m = WorkloadMigrationStatus{} }
func (m *WorkloadMigrationStatus) String() string            { return proto.CompactTextString(m) }
func (*WorkloadMigrationStatus) ProtoMessage()               {}
func (*WorkloadMigrationStatus) Descriptor() ([]byte, []int) { return fileDescriptorWorkload, []int{3} }

func (m *WorkloadMigrationStatus) GetStage() string {
	if m != nil {
		return m.Stage
	}
	return ""
}

func (m *WorkloadMigrationStatus) GetStartedAt() *api.Timestamp {
	if m != nil {
		return m.StartedAt
	}
	return nil
}

func (m *WorkloadMigrationStatus) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *WorkloadMigrationStatus) GetCompletedAt() *api.Timestamp {
	if m != nil {
		return m.CompletedAt
	}
	return nil
}

// Spec part of Workload object
type WorkloadSpec struct {
	// Hostname of the server where the workload should be running.
	// cli-help: Host name where the workload runs
	HostName string `protobuf:"bytes,1,opt,name=HostName,json=host-name,proto3" json:"host-name"`
	// Spec of all interfaces in the Workload identified by Primary MAC
	Interfaces []WorkloadIntfSpec `protobuf:"bytes,2,rep,name=Interfaces,json=interfaces,omitempty" json:"interfaces,omitempty"`
	//
	MigrationTimeout string `protobuf:"bytes,3,opt,name=MigrationTimeout,json=migration-timeout,omitempty,proto3" json:"migration-timeout,omitempty"`
}

func (m *WorkloadSpec) Reset()                    { *m = WorkloadSpec{} }
func (m *WorkloadSpec) String() string            { return proto.CompactTextString(m) }
func (*WorkloadSpec) ProtoMessage()               {}
func (*WorkloadSpec) Descriptor() ([]byte, []int) { return fileDescriptorWorkload, []int{4} }

func (m *WorkloadSpec) GetHostName() string {
	if m != nil {
		return m.HostName
	}
	return ""
}

func (m *WorkloadSpec) GetInterfaces() []WorkloadIntfSpec {
	if m != nil {
		return m.Interfaces
	}
	return nil
}

func (m *WorkloadSpec) GetMigrationTimeout() string {
	if m != nil {
		return m.MigrationTimeout
	}
	return ""
}

// Status part of Workload object
type WorkloadStatus struct {
	// The status of the configuration propagation to the Naples
	PropagationStatus security1.PropagationStatus `protobuf:"bytes,1,opt,name=PropagationStatus,json=propagation-status" json:"propagation-status"`
	// Status of all interfaces in the Workload identified by Primary MAC
	Interfaces []WorkloadIntfStatus `protobuf:"bytes,2,rep,name=Interfaces,json=interfaces,omitempty" json:"interfaces,omitempty"`
	// Hostname of the server where the workload is currently running.
	HostName string `protobuf:"bytes,3,opt,name=HostName,json=host-name,omitempty,proto3" json:"host-name,omitempty"`
	// Status of workload migration when migration is in process
	MigrationStatus *WorkloadMigrationStatus `protobuf:"bytes,4,opt,name=MigrationStatus,json=migration-status,omitempty" json:"migration-status,omitempty"`
	// MirrorSessions list of mirror sessions enabled on this workload
	MirrorSessions []string `protobuf:"bytes,5,rep,name=MirrorSessions,json=mirror-sessions" json:"mirror-sessions"`
}

func (m *WorkloadStatus) Reset()                    { *m = WorkloadStatus{} }
func (m *WorkloadStatus) String() string            { return proto.CompactTextString(m) }
func (*WorkloadStatus) ProtoMessage()               {}
func (*WorkloadStatus) Descriptor() ([]byte, []int) { return fileDescriptorWorkload, []int{5} }

func (m *WorkloadStatus) GetPropagationStatus() security1.PropagationStatus {
	if m != nil {
		return m.PropagationStatus
	}
	return security1.PropagationStatus{}
}

func (m *WorkloadStatus) GetInterfaces() []WorkloadIntfStatus {
	if m != nil {
		return m.Interfaces
	}
	return nil
}

func (m *WorkloadStatus) GetHostName() string {
	if m != nil {
		return m.HostName
	}
	return ""
}

func (m *WorkloadStatus) GetMigrationStatus() *WorkloadMigrationStatus {
	if m != nil {
		return m.MigrationStatus
	}
	return nil
}

func (m *WorkloadStatus) GetMirrorSessions() []string {
	if m != nil {
		return m.MirrorSessions
	}
	return nil
}

func init() {
	proto.RegisterType((*Workload)(nil), "workload.Workload")
	proto.RegisterType((*WorkloadIntfSpec)(nil), "workload.WorkloadIntfSpec")
	proto.RegisterType((*WorkloadIntfStatus)(nil), "workload.WorkloadIntfStatus")
	proto.RegisterType((*WorkloadMigrationStatus)(nil), "workload.WorkloadMigrationStatus")
	proto.RegisterType((*WorkloadSpec)(nil), "workload.WorkloadSpec")
	proto.RegisterType((*WorkloadStatus)(nil), "workload.WorkloadStatus")
	proto.RegisterEnum("workload.WorkloadMigrationStatus_MigrationStage", WorkloadMigrationStatus_MigrationStage_name, WorkloadMigrationStatus_MigrationStage_value)
	proto.RegisterEnum("workload.WorkloadMigrationStatus_DataplaneStatus", WorkloadMigrationStatus_DataplaneStatus_name, WorkloadMigrationStatus_DataplaneStatus_value)
}
func (m *Workload) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Workload) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintWorkload(dAtA, i, uint64(m.TypeMeta.Size()))
	n1, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n1
	dAtA[i] = 0x12
	i++
	i = encodeVarintWorkload(dAtA, i, uint64(m.ObjectMeta.Size()))
	n2, err := m.ObjectMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n2
	dAtA[i] = 0x1a
	i++
	i = encodeVarintWorkload(dAtA, i, uint64(m.Spec.Size()))
	n3, err := m.Spec.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n3
	dAtA[i] = 0x22
	i++
	i = encodeVarintWorkload(dAtA, i, uint64(m.Status.Size()))
	n4, err := m.Status.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n4
	return i, nil
}

func (m *WorkloadIntfSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WorkloadIntfSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.MACAddress) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintWorkload(dAtA, i, uint64(len(m.MACAddress)))
		i += copy(dAtA[i:], m.MACAddress)
	}
	if m.MicroSegVlan != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintWorkload(dAtA, i, uint64(m.MicroSegVlan))
	}
	if m.ExternalVlan != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintWorkload(dAtA, i, uint64(m.ExternalVlan))
	}
	if len(m.IpAddresses) > 0 {
		for _, s := range m.IpAddresses {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Network) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintWorkload(dAtA, i, uint64(len(m.Network)))
		i += copy(dAtA[i:], m.Network)
	}
	if len(m.DSCInterfaces) > 0 {
		for _, s := range m.DSCInterfaces {
			dAtA[i] = 0x32
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *WorkloadIntfStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WorkloadIntfStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.IpAddresses) > 0 {
		for _, s := range m.IpAddresses {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Endpoint) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintWorkload(dAtA, i, uint64(len(m.Endpoint)))
		i += copy(dAtA[i:], m.Endpoint)
	}
	if m.MicroSegVlan != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintWorkload(dAtA, i, uint64(m.MicroSegVlan))
	}
	if len(m.MACAddress) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintWorkload(dAtA, i, uint64(len(m.MACAddress)))
		i += copy(dAtA[i:], m.MACAddress)
	}
	if m.ExternalVlan != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintWorkload(dAtA, i, uint64(m.ExternalVlan))
	}
	if len(m.Network) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintWorkload(dAtA, i, uint64(len(m.Network)))
		i += copy(dAtA[i:], m.Network)
	}
	if len(m.DSCInterfaces) > 0 {
		for _, s := range m.DSCInterfaces {
			dAtA[i] = 0x3a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *WorkloadMigrationStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WorkloadMigrationStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Stage) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintWorkload(dAtA, i, uint64(len(m.Stage)))
		i += copy(dAtA[i:], m.Stage)
	}
	if m.StartedAt != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintWorkload(dAtA, i, uint64(m.StartedAt.Size()))
		n5, err := m.StartedAt.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if len(m.Status) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintWorkload(dAtA, i, uint64(len(m.Status)))
		i += copy(dAtA[i:], m.Status)
	}
	if m.CompletedAt != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintWorkload(dAtA, i, uint64(m.CompletedAt.Size()))
		n6, err := m.CompletedAt.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}

func (m *WorkloadSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WorkloadSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.HostName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintWorkload(dAtA, i, uint64(len(m.HostName)))
		i += copy(dAtA[i:], m.HostName)
	}
	if len(m.Interfaces) > 0 {
		for _, msg := range m.Interfaces {
			dAtA[i] = 0x12
			i++
			i = encodeVarintWorkload(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.MigrationTimeout) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintWorkload(dAtA, i, uint64(len(m.MigrationTimeout)))
		i += copy(dAtA[i:], m.MigrationTimeout)
	}
	return i, nil
}

func (m *WorkloadStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WorkloadStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintWorkload(dAtA, i, uint64(m.PropagationStatus.Size()))
	n7, err := m.PropagationStatus.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n7
	if len(m.Interfaces) > 0 {
		for _, msg := range m.Interfaces {
			dAtA[i] = 0x12
			i++
			i = encodeVarintWorkload(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.HostName) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintWorkload(dAtA, i, uint64(len(m.HostName)))
		i += copy(dAtA[i:], m.HostName)
	}
	if m.MigrationStatus != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintWorkload(dAtA, i, uint64(m.MigrationStatus.Size()))
		n8, err := m.MigrationStatus.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if len(m.MirrorSessions) > 0 {
		for _, s := range m.MirrorSessions {
			dAtA[i] = 0x2a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func encodeVarintWorkload(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Workload) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovWorkload(uint64(l))
	l = m.ObjectMeta.Size()
	n += 1 + l + sovWorkload(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovWorkload(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovWorkload(uint64(l))
	return n
}

func (m *WorkloadIntfSpec) Size() (n int) {
	var l int
	_ = l
	l = len(m.MACAddress)
	if l > 0 {
		n += 1 + l + sovWorkload(uint64(l))
	}
	if m.MicroSegVlan != 0 {
		n += 1 + sovWorkload(uint64(m.MicroSegVlan))
	}
	if m.ExternalVlan != 0 {
		n += 1 + sovWorkload(uint64(m.ExternalVlan))
	}
	if len(m.IpAddresses) > 0 {
		for _, s := range m.IpAddresses {
			l = len(s)
			n += 1 + l + sovWorkload(uint64(l))
		}
	}
	l = len(m.Network)
	if l > 0 {
		n += 1 + l + sovWorkload(uint64(l))
	}
	if len(m.DSCInterfaces) > 0 {
		for _, s := range m.DSCInterfaces {
			l = len(s)
			n += 1 + l + sovWorkload(uint64(l))
		}
	}
	return n
}

func (m *WorkloadIntfStatus) Size() (n int) {
	var l int
	_ = l
	if len(m.IpAddresses) > 0 {
		for _, s := range m.IpAddresses {
			l = len(s)
			n += 1 + l + sovWorkload(uint64(l))
		}
	}
	l = len(m.Endpoint)
	if l > 0 {
		n += 1 + l + sovWorkload(uint64(l))
	}
	if m.MicroSegVlan != 0 {
		n += 1 + sovWorkload(uint64(m.MicroSegVlan))
	}
	l = len(m.MACAddress)
	if l > 0 {
		n += 1 + l + sovWorkload(uint64(l))
	}
	if m.ExternalVlan != 0 {
		n += 1 + sovWorkload(uint64(m.ExternalVlan))
	}
	l = len(m.Network)
	if l > 0 {
		n += 1 + l + sovWorkload(uint64(l))
	}
	if len(m.DSCInterfaces) > 0 {
		for _, s := range m.DSCInterfaces {
			l = len(s)
			n += 1 + l + sovWorkload(uint64(l))
		}
	}
	return n
}

func (m *WorkloadMigrationStatus) Size() (n int) {
	var l int
	_ = l
	l = len(m.Stage)
	if l > 0 {
		n += 1 + l + sovWorkload(uint64(l))
	}
	if m.StartedAt != nil {
		l = m.StartedAt.Size()
		n += 1 + l + sovWorkload(uint64(l))
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovWorkload(uint64(l))
	}
	if m.CompletedAt != nil {
		l = m.CompletedAt.Size()
		n += 1 + l + sovWorkload(uint64(l))
	}
	return n
}

func (m *WorkloadSpec) Size() (n int) {
	var l int
	_ = l
	l = len(m.HostName)
	if l > 0 {
		n += 1 + l + sovWorkload(uint64(l))
	}
	if len(m.Interfaces) > 0 {
		for _, e := range m.Interfaces {
			l = e.Size()
			n += 1 + l + sovWorkload(uint64(l))
		}
	}
	l = len(m.MigrationTimeout)
	if l > 0 {
		n += 1 + l + sovWorkload(uint64(l))
	}
	return n
}

func (m *WorkloadStatus) Size() (n int) {
	var l int
	_ = l
	l = m.PropagationStatus.Size()
	n += 1 + l + sovWorkload(uint64(l))
	if len(m.Interfaces) > 0 {
		for _, e := range m.Interfaces {
			l = e.Size()
			n += 1 + l + sovWorkload(uint64(l))
		}
	}
	l = len(m.HostName)
	if l > 0 {
		n += 1 + l + sovWorkload(uint64(l))
	}
	if m.MigrationStatus != nil {
		l = m.MigrationStatus.Size()
		n += 1 + l + sovWorkload(uint64(l))
	}
	if len(m.MirrorSessions) > 0 {
		for _, s := range m.MirrorSessions {
			l = len(s)
			n += 1 + l + sovWorkload(uint64(l))
		}
	}
	return n
}

func sovWorkload(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozWorkload(x uint64) (n int) {
	return sovWorkload(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Workload) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWorkload
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Workload: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Workload: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorkload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWorkload
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorkload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWorkload
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorkload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWorkload
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorkload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWorkload
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWorkload(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWorkload
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WorkloadIntfSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWorkload
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WorkloadIntfSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WorkloadIntfSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MACAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorkload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWorkload
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MACAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MicroSegVlan", wireType)
			}
			m.MicroSegVlan = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorkload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MicroSegVlan |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalVlan", wireType)
			}
			m.ExternalVlan = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorkload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExternalVlan |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpAddresses", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorkload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWorkload
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IpAddresses = append(m.IpAddresses, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Network", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorkload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWorkload
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Network = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DSCInterfaces", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorkload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWorkload
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DSCInterfaces = append(m.DSCInterfaces, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWorkload(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWorkload
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WorkloadIntfStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWorkload
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WorkloadIntfStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WorkloadIntfStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpAddresses", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorkload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWorkload
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IpAddresses = append(m.IpAddresses, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Endpoint", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorkload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWorkload
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Endpoint = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MicroSegVlan", wireType)
			}
			m.MicroSegVlan = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorkload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MicroSegVlan |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MACAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorkload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWorkload
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MACAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalVlan", wireType)
			}
			m.ExternalVlan = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorkload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExternalVlan |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Network", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorkload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWorkload
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Network = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DSCInterfaces", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorkload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWorkload
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DSCInterfaces = append(m.DSCInterfaces, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWorkload(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWorkload
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WorkloadMigrationStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWorkload
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WorkloadMigrationStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WorkloadMigrationStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorkload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWorkload
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Stage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorkload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWorkload
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StartedAt == nil {
				m.StartedAt = &api.Timestamp{}
			}
			if err := m.StartedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorkload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWorkload
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompletedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorkload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWorkload
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CompletedAt == nil {
				m.CompletedAt = &api.Timestamp{}
			}
			if err := m.CompletedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWorkload(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWorkload
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WorkloadSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWorkload
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WorkloadSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WorkloadSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorkload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWorkload
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Interfaces", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorkload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWorkload
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Interfaces = append(m.Interfaces, WorkloadIntfSpec{})
			if err := m.Interfaces[len(m.Interfaces)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MigrationTimeout", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorkload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWorkload
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MigrationTimeout = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWorkload(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWorkload
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WorkloadStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWorkload
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WorkloadStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WorkloadStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PropagationStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorkload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWorkload
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PropagationStatus.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Interfaces", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorkload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWorkload
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Interfaces = append(m.Interfaces, WorkloadIntfStatus{})
			if err := m.Interfaces[len(m.Interfaces)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorkload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWorkload
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MigrationStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorkload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWorkload
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MigrationStatus == nil {
				m.MigrationStatus = &WorkloadMigrationStatus{}
			}
			if err := m.MigrationStatus.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MirrorSessions", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorkload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWorkload
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MirrorSessions = append(m.MirrorSessions, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWorkload(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWorkload
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipWorkload(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowWorkload
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowWorkload
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowWorkload
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthWorkload
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowWorkload
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipWorkload(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthWorkload = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowWorkload   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("workload.proto", fileDescriptorWorkload) }

var fileDescriptorWorkload = []byte{
	// 1369 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x57, 0x4f, 0x6f, 0x1a, 0x47,
	0x14, 0x0f, 0x7f, 0x8c, 0xcd, 0xd8, 0xc6, 0x64, 0x9c, 0x38, 0xbb, 0xd8, 0x32, 0x29, 0x52, 0x2b,
	0x2c, 0x19, 0xd6, 0x4d, 0xd2, 0x56, 0xa9, 0xd2, 0x34, 0x60, 0x48, 0x82, 0x64, 0x20, 0x5a, 0x68,
	0xfa, 0xe7, 0x50, 0x77, 0x58, 0x86, 0xcd, 0xb6, 0xbb, 0xb3, 0xab, 0x9d, 0x21, 0xa9, 0x5b, 0xf5,
	0x52, 0xa9, 0x88, 0xaa, 0xdf, 0x22, 0x47, 0x8e, 0xfd, 0x04, 0x3d, 0xe6, 0xd0, 0x43, 0xd4, 0x53,
	0x4f, 0xa8, 0xe2, 0x54, 0xf1, 0x29, 0xaa, 0x99, 0x5d, 0xcc, 0x82, 0x21, 0x55, 0xdd, 0x13, 0xfb,
	0xde, 0xfb, 0xcd, 0x9b, 0xdf, 0xbc, 0xf9, 0xcd, 0x9b, 0x01, 0x24, 0x5e, 0xd8, 0xee, 0x37, 0xa6,
	0x8d, 0xda, 0x79, 0xc7, 0xb5, 0x99, 0x0d, 0xd7, 0x26, 0x76, 0x6a, 0x4f, 0xb7, 0x6d, 0xdd, 0xc4,
	0x0a, 0x72, 0x0c, 0x05, 0x11, 0x62, 0x33, 0xc4, 0x0c, 0x9b, 0x50, 0x0f, 0x97, 0x2a, 0xeb, 0x06,
	0x7b, 0xd6, 0x6d, 0xe5, 0x35, 0xdb, 0x52, 0x1c, 0x4c, 0x28, 0x22, 0x6d, 0x5b, 0xa1, 0x2f, 0x94,
	0xe7, 0x98, 0x18, 0x1a, 0x56, 0xba, 0xcc, 0x30, 0x29, 0x1f, 0xaa, 0x63, 0x12, 0x1c, 0xad, 0x18,
	0x44, 0x33, 0xbb, 0x6d, 0x3c, 0x49, 0x93, 0x0b, 0xa4, 0xd1, 0x6d, 0xdd, 0x56, 0x84, 0xbb, 0xd5,
	0xed, 0x08, 0x4b, 0x18, 0xe2, 0xcb, 0x87, 0xbf, 0xbd, 0x64, 0x56, 0xce, 0xd1, 0xc2, 0x0c, 0xf9,
	0xb0, 0xa3, 0x37, 0xc0, 0x4c, 0xd4, 0xc2, 0x26, 0x55, 0x28, 0x36, 0xb1, 0xc6, 0x6c, 0xd7, 0x1f,
	0xb1, 0xa9, 0x99, 0x5d, 0xca, 0xf0, 0xc4, 0x4c, 0x50, 0xdd, 0xb1, 0x4d, 0x43, 0x3b, 0xf3, 0xec,
	0xcc, 0xef, 0x61, 0xb0, 0xf6, 0xa9, 0x5f, 0x18, 0xf8, 0x3e, 0x08, 0x35, 0xa5, 0xd0, 0xcd, 0x50,
	0x76, 0xfd, 0xd6, 0x66, 0x1e, 0x39, 0x46, 0xbe, 0x79, 0xe6, 0xe0, 0x2a, 0x66, 0xa8, 0xb8, 0xfd,
	0x6a, 0x98, 0xbe, 0xf2, 0x7a, 0x98, 0x0e, 0x8d, 0x87, 0xe9, 0xd5, 0x43, 0x83, 0x98, 0x06, 0xc1,
	0xea, 0xe4, 0x03, 0x3e, 0x04, 0xa1, 0xba, 0x14, 0x16, 0xe3, 0xb6, 0xc4, 0xb8, 0x7a, 0xeb, 0x6b,
	0xac, 0x31, 0x31, 0x32, 0x15, 0x18, 0x99, 0xe0, 0x2b, 0x39, 0xb4, 0x2d, 0x83, 0x61, 0xcb, 0x61,
	0x67, 0xea, 0x9c, 0x0d, 0x4f, 0x40, 0xb4, 0xe1, 0x60, 0x4d, 0x8a, 0x88, 0x54, 0x3b, 0xf9, 0xf3,
	0x1d, 0x9c, 0x30, 0xe4, 0xd1, 0xe2, 0x0e, 0xcf, 0xc8, 0xb3, 0x51, 0x07, 0x6b, 0xc1, 0x6c, 0xb3,
	0x36, 0x6c, 0x82, 0x58, 0x83, 0x21, 0xd6, 0xa5, 0x52, 0x54, 0xe4, 0x93, 0x16, 0xe4, 0x13, 0xf1,
	0xa2, 0xe4, 0x67, 0x4c, 0x52, 0x61, 0x07, 0x72, 0x5e, 0xf0, 0x7c, 0xb8, 0xf7, 0xc7, 0x4f, 0xb2,
	0x04, 0xd6, 0x95, 0xef, 0xeb, 0xf9, 0x26, 0x26, 0x88, 0xb0, 0x1f, 0x60, 0x7c, 0x92, 0x97, 0x66,
	0x5e, 0x46, 0x41, 0x72, 0x92, 0xbc, 0x42, 0x58, 0x87, 0x13, 0x86, 0x5f, 0x00, 0x50, 0x2d, 0x1c,
	0x17, 0xda, 0x6d, 0x17, 0x53, 0x2a, 0xea, 0x1b, 0x2f, 0x2a, 0x83, 0x9e, 0x0c, 0xcb, 0x3c, 0x63,
	0xdd, 0xcd, 0x56, 0x91, 0xc6, 0xa3, 0xd9, 0x83, 0x83, 0xf1, 0x30, 0x7d, 0xdd, 0x42, 0x5a, 0x0e,
	0x79, 0xe0, 0x00, 0x93, 0xc5, 0x6e, 0xf8, 0x15, 0xd8, 0xa8, 0x1a, 0x9a, 0x6b, 0x37, 0xb0, 0xfe,
	0xd4, 0x44, 0x44, 0xec, 0xc2, 0x66, 0xf1, 0x68, 0xd0, 0x93, 0x93, 0x15, 0xc2, 0x54, 0x44, 0x74,
	0x9c, 0x7d, 0xf7, 0xf0, 0xce, 0xd1, 0xdd, 0xf7, 0x78, 0x6e, 0xc9, 0xe2, 0xd8, 0x1c, 0xc5, 0x7a,
	0xee, 0xb9, 0x89, 0x48, 0x20, 0xfd, 0xd2, 0x08, 0xfc, 0x12, 0x6c, 0x94, 0xbf, 0x65, 0xd8, 0x25,
	0xc8, 0x14, 0x33, 0x44, 0xc4, 0x0c, 0xca, 0xcc, 0x0c, 0x47, 0xe7, 0x33, 0xdc, 0xc0, 0x3e, 0x76,
	0x7e, 0x82, 0x65, 0x01, 0xf8, 0x08, 0xac, 0x57, 0x1c, 0xbf, 0x38, 0x98, 0xef, 0x55, 0x24, 0x1b,
	0x2f, 0xa6, 0xc6, 0xc3, 0xf4, 0x8e, 0xe1, 0x4c, 0x16, 0x8c, 0x83, 0x95, 0x58, 0xe2, 0x87, 0x9f,
	0x81, 0xd5, 0x1a, 0x66, 0x7c, 0x2f, 0xa4, 0x15, 0x51, 0xe3, 0x3b, 0x2f, 0x7b, 0xf2, 0x2e, 0x58,
	0xab, 0x21, 0x0b, 0xb7, 0x55, 0xdc, 0x81, 0x5b, 0xc4, 0x0b, 0x2b, 0x3e, 0x6c, 0x3c, 0x4c, 0x5f,
	0xf5, 0x5d, 0x81, 0xf4, 0x17, 0x5d, 0xb0, 0x0a, 0x36, 0x4b, 0x8d, 0xe3, 0x0a, 0x61, 0xd8, 0xed,
	0x20, 0x0d, 0x53, 0x29, 0x26, 0x48, 0xee, 0xf1, 0x8a, 0xb6, 0xa9, 0x96, 0x33, 0xce, 0x23, 0xc1,
	0x8a, 0x2e, 0x8b, 0x64, 0x7e, 0x89, 0x02, 0x38, 0x23, 0x12, 0xa1, 0xb1, 0xf9, 0x42, 0x84, 0x2e,
	0x5d, 0x88, 0x07, 0x60, 0xad, 0x4c, 0xda, 0x8e, 0x6d, 0x10, 0x26, 0xf4, 0x10, 0x17, 0x87, 0x90,
	0x1f, 0x40, 0x88, 0x7d, 0x7f, 0x20, 0xcb, 0x02, 0x1f, 0x3c, 0x99, 0x53, 0x95, 0xb7, 0xe7, 0x7b,
	0x97, 0x54, 0x50, 0x69, 0x46, 0xff, 0x51, 0xc1, 0x48, 0xfe, 0xcf, 0x4a, 0x3f, 0x99, 0xd3, 0xe1,
	0xca, 0x94, 0xd3, 0xac, 0xb4, 0x6e, 0x06, 0x38, 0x2d, 0x8b, 0xc0, 0xbb, 0x53, 0xb1, 0xc4, 0x04,
	0xa1, 0xeb, 0x97, 0x57, 0xc3, 0xea, 0xff, 0x52, 0xc3, 0x8f, 0x31, 0x70, 0x63, 0xa2, 0x86, 0xaa,
	0xa1, 0xbb, 0xe2, 0x3a, 0xf1, 0x25, 0xa1, 0x82, 0x95, 0x06, 0x43, 0x3a, 0xf6, 0x9b, 0xc6, 0xbd,
	0x41, 0x4f, 0x56, 0x1a, 0xcc, 0x2d, 0x93, 0xae, 0x95, 0x5d, 0x32, 0x26, 0x1f, 0xb4, 0x75, 0xcc,
	0xcf, 0xe4, 0x0a, 0xe5, 0x5f, 0xaa, 0xf7, 0x03, 0x3f, 0x02, 0xf1, 0x06, 0x43, 0x2e, 0xc3, 0xed,
	0x02, 0xf3, 0x9b, 0x76, 0xc2, 0x6b, 0xf6, 0x86, 0x85, 0x29, 0x43, 0x96, 0x53, 0x4c, 0x8c, 0x87,
	0x69, 0x40, 0x3d, 0x50, 0x0e, 0x31, 0x35, 0xf0, 0x0d, 0x9f, 0x9e, 0x77, 0xd5, 0x88, 0xe0, 0x74,
	0x7f, 0xd0, 0x93, 0x8f, 0xfe, 0x8d, 0x53, 0x09, 0x31, 0xe4, 0x98, 0x88, 0x60, 0xcf, 0xe6, 0xa4,
	0x62, 0x5e, 0x67, 0x55, 0xfd, 0x5f, 0x78, 0x0c, 0xd6, 0x8f, 0x6d, 0xcb, 0x31, 0xb1, 0x47, 0x2c,
	0xba, 0x90, 0x58, 0x72, 0x3c, 0x4c, 0x6f, 0x68, 0x13, 0x18, 0xa7, 0x36, 0x63, 0x65, 0x06, 0x61,
	0x90, 0x98, 0x5d, 0x3f, 0x7c, 0x07, 0x24, 0xaa, 0x95, 0x47, 0x6a, 0xa1, 0x59, 0xa9, 0xd7, 0x4e,
	0x6b, 0xf5, 0x5a, 0x39, 0x79, 0x25, 0x05, 0x47, 0x7d, 0x39, 0x61, 0x4d, 0x70, 0x39, 0x62, 0x13,
	0x0c, 0xb3, 0x60, 0x6b, 0x8a, 0x6b, 0x34, 0x0b, 0x6a, 0x33, 0x19, 0x4a, 0x6d, 0x8f, 0xfa, 0xf2,
	0xd6, 0x14, 0x28, 0xca, 0x00, 0x6f, 0x81, 0x6b, 0x53, 0xe4, 0xc3, 0x4a, 0xad, 0x70, 0x72, 0xda,
	0xf8, 0xbc, 0x76, 0x9c, 0x0c, 0xa7, 0xa4, 0x51, 0x5f, 0xbe, 0x36, 0x85, 0x77, 0x0c, 0xae, 0x3c,
	0x7a, 0x46, 0xb4, 0x59, 0x16, 0x25, 0xce, 0x22, 0x32, 0xcf, 0xa2, 0x7d, 0x81, 0x45, 0xa1, 0x58,
	0x57, 0x9b, 0xc9, 0xe8, 0x3c, 0x0b, 0xd4, 0xb2, 0x5d, 0x06, 0x1f, 0x80, 0xdd, 0x00, 0x0b, 0xb5,
	0x5e, 0xe5, 0x8b, 0x3b, 0x7d, 0x52, 0xae, 0x9d, 0x3e, 0xae, 0x37, 0x9a, 0xc9, 0x95, 0x54, 0x7a,
	0xd4, 0x97, 0x77, 0x03, 0x64, 0x5c, 0xdb, 0xe2, 0x2b, 0xcd, 0x39, 0x98, 0xe4, 0x9e, 0xd9, 0x94,
	0x65, 0x7e, 0x0e, 0x81, 0xad, 0xb9, 0x8d, 0x81, 0x10, 0x44, 0xfd, 0x1a, 0xad, 0x8d, 0xfa, 0x72,
	0x54, 0x54, 0x46, 0x02, 0xab, 0xa2, 0x1e, 0xe5, 0x52, 0x32, 0x94, 0x5a, 0x1f, 0xf5, 0xe5, 0x55,
	0x5f, 0x0e, 0x1c, 0x2d, 0xd6, 0x12, 0xf6, 0xd0, 0x62, 0x05, 0x3b, 0x20, 0xf6, 0xb0, 0x50, 0x39,
	0x29, 0x97, 0x92, 0x91, 0x14, 0x18, 0xf5, 0xe5, 0x58, 0x07, 0x19, 0x26, 0x6e, 0xc3, 0x3d, 0x10,
	0x6f, 0x56, 0xaa, 0xe5, 0xd2, 0x69, 0xfd, 0x13, 0xbe, 0xa6, 0xcd, 0x51, 0x5f, 0x8e, 0x33, 0xc3,
	0xc2, 0xed, 0x9c, 0xdd, 0x65, 0x99, 0xdf, 0xc2, 0x60, 0x23, 0x78, 0xc9, 0xc3, 0x26, 0x58, 0x7b,
	0x6c, 0x53, 0xc6, 0x7b, 0xb7, 0x2f, 0xfe, 0x0f, 0x5e, 0xf6, 0x64, 0x29, 0xd0, 0xcd, 0x37, 0xfc,
	0x87, 0x8d, 0xc2, 0x71, 0x83, 0x9e, 0x0c, 0xf8, 0xaf, 0x77, 0x8d, 0x8e, 0x87, 0xe9, 0x38, 0x5f,
	0x62, 0x8e, 0x20, 0x0b, 0xab, 0xd3, 0x4f, 0xd8, 0x02, 0x20, 0x70, 0x6e, 0xc3, 0x37, 0x23, 0xd9,
	0xf5, 0x5b, 0xa9, 0x8b, 0xcf, 0x82, 0xc9, 0xcd, 0x5d, 0xdc, 0xf3, 0x1f, 0x06, 0xd7, 0x16, 0x9e,
	0xe9, 0x85, 0x5e, 0xf8, 0x1c, 0x24, 0xcf, 0x25, 0xc8, 0x95, 0x6b, 0x77, 0x99, 0x7f, 0x54, 0x3e,
	0x1e, 0xf4, 0xe4, 0x9d, 0xc9, 0x9d, 0x5f, 0xea, 0x7a, 0x90, 0xec, 0xd1, 0xe1, 0xd1, 0xc1, 0xc1,
	0xaf, 0x3d, 0x39, 0x7c, 0xdb, 0x1a, 0x0f, 0xd3, 0x81, 0x1d, 0x63, 0xde, 0xe0, 0xc0, 0x84, 0x6f,
	0x0a, 0x66, 0xfe, 0x8c, 0x80, 0xc4, 0xec, 0xbb, 0x06, 0x76, 0xc0, 0xd5, 0x27, 0xae, 0xed, 0x20,
	0x3d, 0x70, 0x16, 0xfd, 0xf7, 0xdd, 0x6e, 0x9e, 0x62, 0xad, 0xeb, 0x1a, 0xec, 0x2c, 0x7f, 0x01,
	0xe2, 0xbd, 0xd9, 0xf8, 0x75, 0xe1, 0x4c, 0x43, 0x39, 0xff, 0xbc, 0x2e, 0xf0, 0xc1, 0xf6, 0x82,
	0xb2, 0xee, 0x2d, 0x29, 0xab, 0x37, 0xc3, 0x65, 0x0a, 0x7b, 0x3f, 0x20, 0x09, 0xaf, 0xa0, 0x37,
	0xc6, 0xc3, 0xf4, 0xf6, 0xf9, 0xee, 0x06, 0x12, 0x2c, 0x72, 0xc2, 0xef, 0xc0, 0xd6, 0x5c, 0x5f,
	0xf2, 0xbb, 0xcc, 0x5b, 0x17, 0xa9, 0xce, 0x01, 0x8b, 0x19, 0xff, 0x02, 0x4d, 0xcd, 0x34, 0x83,
	0xd9, 0xb7, 0xe2, 0x1b, 0x62, 0xf0, 0x1e, 0xef, 0x4b, 0xae, 0x6b, 0xbb, 0x0d, 0x4c, 0x29, 0xff,
	0xbb, 0x20, 0xad, 0x88, 0x4b, 0x63, 0x7b, 0x3c, 0x4c, 0x6f, 0x59, 0x22, 0x92, 0xa3, 0x7e, 0x48,
	0x9d, 0x77, 0x14, 0x93, 0xaf, 0x46, 0xfb, 0xa1, 0xd7, 0xa3, 0xfd, 0xd0, 0x5f, 0xa3, 0xfd, 0xd0,
	0xdf, 0xa3, 0xfd, 0x2b, 0x4f, 0x42, 0xad, 0x98, 0x78, 0xbf, 0xdf, 0xfe, 0x27, 0x00, 0x00, 0xff,
	0xff, 0xc9, 0x37, 0x64, 0xc3, 0xe7, 0x0c, 0x00, 0x00,
}
