// Code generated by protoc-gen-grpc-pensando DO NOT EDIT.

package grpcclient

import (
	"context"
	"errors"
	oldlog "log"
	"net/http"

	"github.com/go-kit/kit/endpoint"
	grpctransport "github.com/go-kit/kit/transport/grpc"
	"google.golang.org/grpc"

	api "github.com/pensando/sw/api"
	workload "github.com/pensando/sw/api/generated/workload"
	"github.com/pensando/sw/api/interfaces"
	listerwatcher "github.com/pensando/sw/api/listerwatcher"
	"github.com/pensando/sw/venice/globals"
	"github.com/pensando/sw/venice/utils/kvstore"
	"github.com/pensando/sw/venice/utils/log"
	"github.com/pensando/sw/venice/utils/trace"
)

// Dummy vars to suppress import errors
var _ api.TypeMeta
var _ listerwatcher.WatcherClient
var _ kvstore.Interface

// NewWorkloadV1 sets up a new client for WorkloadV1
func NewWorkloadV1(conn *grpc.ClientConn, logger log.Logger) workload.ServiceWorkloadV1Client {

	var lAbortMigrationEndpoint endpoint.Endpoint
	{
		lAbortMigrationEndpoint = grpctransport.NewClient(
			conn,
			"workload.WorkloadV1",
			"AbortMigration",
			workload.EncodeGrpcReqWorkload,
			workload.DecodeGrpcRespWorkload,
			&workload.Workload{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAbortMigrationEndpoint = trace.ClientEndPoint("WorkloadV1:AbortMigration")(lAbortMigrationEndpoint)
	}
	var lAutoAddEndpointEndpoint endpoint.Endpoint
	{
		lAutoAddEndpointEndpoint = grpctransport.NewClient(
			conn,
			"workload.WorkloadV1",
			"AutoAddEndpoint",
			workload.EncodeGrpcReqEndpoint,
			workload.DecodeGrpcRespEndpoint,
			&workload.Endpoint{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoAddEndpointEndpoint = trace.ClientEndPoint("WorkloadV1:AutoAddEndpoint")(lAutoAddEndpointEndpoint)
	}
	var lAutoAddWorkloadEndpoint endpoint.Endpoint
	{
		lAutoAddWorkloadEndpoint = grpctransport.NewClient(
			conn,
			"workload.WorkloadV1",
			"AutoAddWorkload",
			workload.EncodeGrpcReqWorkload,
			workload.DecodeGrpcRespWorkload,
			&workload.Workload{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoAddWorkloadEndpoint = trace.ClientEndPoint("WorkloadV1:AutoAddWorkload")(lAutoAddWorkloadEndpoint)
	}
	var lAutoDeleteEndpointEndpoint endpoint.Endpoint
	{
		lAutoDeleteEndpointEndpoint = grpctransport.NewClient(
			conn,
			"workload.WorkloadV1",
			"AutoDeleteEndpoint",
			workload.EncodeGrpcReqEndpoint,
			workload.DecodeGrpcRespEndpoint,
			&workload.Endpoint{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoDeleteEndpointEndpoint = trace.ClientEndPoint("WorkloadV1:AutoDeleteEndpoint")(lAutoDeleteEndpointEndpoint)
	}
	var lAutoDeleteWorkloadEndpoint endpoint.Endpoint
	{
		lAutoDeleteWorkloadEndpoint = grpctransport.NewClient(
			conn,
			"workload.WorkloadV1",
			"AutoDeleteWorkload",
			workload.EncodeGrpcReqWorkload,
			workload.DecodeGrpcRespWorkload,
			&workload.Workload{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoDeleteWorkloadEndpoint = trace.ClientEndPoint("WorkloadV1:AutoDeleteWorkload")(lAutoDeleteWorkloadEndpoint)
	}
	var lAutoGetEndpointEndpoint endpoint.Endpoint
	{
		lAutoGetEndpointEndpoint = grpctransport.NewClient(
			conn,
			"workload.WorkloadV1",
			"AutoGetEndpoint",
			workload.EncodeGrpcReqEndpoint,
			workload.DecodeGrpcRespEndpoint,
			&workload.Endpoint{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoGetEndpointEndpoint = trace.ClientEndPoint("WorkloadV1:AutoGetEndpoint")(lAutoGetEndpointEndpoint)
	}
	var lAutoGetWorkloadEndpoint endpoint.Endpoint
	{
		lAutoGetWorkloadEndpoint = grpctransport.NewClient(
			conn,
			"workload.WorkloadV1",
			"AutoGetWorkload",
			workload.EncodeGrpcReqWorkload,
			workload.DecodeGrpcRespWorkload,
			&workload.Workload{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoGetWorkloadEndpoint = trace.ClientEndPoint("WorkloadV1:AutoGetWorkload")(lAutoGetWorkloadEndpoint)
	}
	var lAutoListEndpointEndpoint endpoint.Endpoint
	{
		lAutoListEndpointEndpoint = grpctransport.NewClient(
			conn,
			"workload.WorkloadV1",
			"AutoListEndpoint",
			workload.EncodeGrpcReqListWatchOptions,
			workload.DecodeGrpcRespEndpointList,
			&workload.EndpointList{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoListEndpointEndpoint = trace.ClientEndPoint("WorkloadV1:AutoListEndpoint")(lAutoListEndpointEndpoint)
	}
	var lAutoListWorkloadEndpoint endpoint.Endpoint
	{
		lAutoListWorkloadEndpoint = grpctransport.NewClient(
			conn,
			"workload.WorkloadV1",
			"AutoListWorkload",
			workload.EncodeGrpcReqListWatchOptions,
			workload.DecodeGrpcRespWorkloadList,
			&workload.WorkloadList{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoListWorkloadEndpoint = trace.ClientEndPoint("WorkloadV1:AutoListWorkload")(lAutoListWorkloadEndpoint)
	}
	var lAutoUpdateEndpointEndpoint endpoint.Endpoint
	{
		lAutoUpdateEndpointEndpoint = grpctransport.NewClient(
			conn,
			"workload.WorkloadV1",
			"AutoUpdateEndpoint",
			workload.EncodeGrpcReqEndpoint,
			workload.DecodeGrpcRespEndpoint,
			&workload.Endpoint{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoUpdateEndpointEndpoint = trace.ClientEndPoint("WorkloadV1:AutoUpdateEndpoint")(lAutoUpdateEndpointEndpoint)
	}
	var lAutoUpdateWorkloadEndpoint endpoint.Endpoint
	{
		lAutoUpdateWorkloadEndpoint = grpctransport.NewClient(
			conn,
			"workload.WorkloadV1",
			"AutoUpdateWorkload",
			workload.EncodeGrpcReqWorkload,
			workload.DecodeGrpcRespWorkload,
			&workload.Workload{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoUpdateWorkloadEndpoint = trace.ClientEndPoint("WorkloadV1:AutoUpdateWorkload")(lAutoUpdateWorkloadEndpoint)
	}
	var lFinishMigrationEndpoint endpoint.Endpoint
	{
		lFinishMigrationEndpoint = grpctransport.NewClient(
			conn,
			"workload.WorkloadV1",
			"FinishMigration",
			workload.EncodeGrpcReqWorkload,
			workload.DecodeGrpcRespWorkload,
			&workload.Workload{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lFinishMigrationEndpoint = trace.ClientEndPoint("WorkloadV1:FinishMigration")(lFinishMigrationEndpoint)
	}
	var lStartMigrationEndpoint endpoint.Endpoint
	{
		lStartMigrationEndpoint = grpctransport.NewClient(
			conn,
			"workload.WorkloadV1",
			"StartMigration",
			workload.EncodeGrpcReqWorkload,
			workload.DecodeGrpcRespWorkload,
			&workload.Workload{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lStartMigrationEndpoint = trace.ClientEndPoint("WorkloadV1:StartMigration")(lStartMigrationEndpoint)
	}
	return workload.EndpointsWorkloadV1Client{
		Client: workload.NewWorkloadV1Client(conn),

		AbortMigrationEndpoint:     lAbortMigrationEndpoint,
		AutoAddEndpointEndpoint:    lAutoAddEndpointEndpoint,
		AutoAddWorkloadEndpoint:    lAutoAddWorkloadEndpoint,
		AutoDeleteEndpointEndpoint: lAutoDeleteEndpointEndpoint,
		AutoDeleteWorkloadEndpoint: lAutoDeleteWorkloadEndpoint,
		AutoGetEndpointEndpoint:    lAutoGetEndpointEndpoint,
		AutoGetWorkloadEndpoint:    lAutoGetWorkloadEndpoint,
		AutoListEndpointEndpoint:   lAutoListEndpointEndpoint,
		AutoListWorkloadEndpoint:   lAutoListWorkloadEndpoint,
		AutoUpdateEndpointEndpoint: lAutoUpdateEndpointEndpoint,
		AutoUpdateWorkloadEndpoint: lAutoUpdateWorkloadEndpoint,
		FinishMigrationEndpoint:    lFinishMigrationEndpoint,
		StartMigrationEndpoint:     lStartMigrationEndpoint,
	}
}

// NewWorkloadV1Backend creates an instrumented client with middleware
func NewWorkloadV1Backend(conn *grpc.ClientConn, logger log.Logger) workload.ServiceWorkloadV1Client {
	cl := NewWorkloadV1(conn, logger)
	cl = workload.LoggingWorkloadV1MiddlewareClient(logger)(cl)
	return cl
}

type grpcObjWorkloadV1Endpoint struct {
	logger log.Logger
	client workload.ServiceWorkloadV1Client
}

func (a *grpcObjWorkloadV1Endpoint) Create(ctx context.Context, in *workload.Endpoint) (*workload.Endpoint, error) {
	a.logger.DebugLog("msg", "received call", "object", "Endpoint", "oper", "create")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoAddEndpoint(nctx, in)
}

func (a *grpcObjWorkloadV1Endpoint) Update(ctx context.Context, in *workload.Endpoint) (*workload.Endpoint, error) {
	a.logger.DebugLog("msg", "received call", "object", "Endpoint", "oper", "update")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoUpdateEndpoint(nctx, in)
}

func (a *grpcObjWorkloadV1Endpoint) UpdateStatus(ctx context.Context, in *workload.Endpoint) (*workload.Endpoint, error) {
	a.logger.DebugLog("msg", "received call", "object", "Endpoint", "oper", "update")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	nctx = addStatusUpd(nctx)
	return a.client.AutoUpdateEndpoint(nctx, in)
}

func (a *grpcObjWorkloadV1Endpoint) Get(ctx context.Context, objMeta *api.ObjectMeta) (*workload.Endpoint, error) {
	a.logger.DebugLog("msg", "received call", "object", "Endpoint", "oper", "get")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := workload.Endpoint{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoGetEndpoint(nctx, &in)
}

func (a *grpcObjWorkloadV1Endpoint) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*workload.Endpoint, error) {
	a.logger.DebugLog("msg", "received call", "object", "Endpoint", "oper", "delete")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := workload.Endpoint{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoDeleteEndpoint(nctx, &in)
}

func (a *grpcObjWorkloadV1Endpoint) List(ctx context.Context, options *api.ListWatchOptions) ([]*workload.Endpoint, error) {
	a.logger.DebugLog("msg", "received call", "object", "Endpoint", "oper", "list")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	r, err := a.client.AutoListEndpoint(nctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *grpcObjWorkloadV1Endpoint) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	a.logger.DebugLog("msg", "received call", "object", "Endpoint", "oper", "WatchOper")
	nctx := addVersion(ctx, "v1")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	stream, err := a.client.AutoWatchEndpoint(nctx, options)
	if err != nil {
		return nil, err
	}
	wstream := stream.(workload.WorkloadV1_AutoWatchEndpointClient)
	bridgefn := func(lw *listerwatcher.WatcherClient) {
		for {
			r, err := wstream.Recv()
			if err != nil {
				a.logger.ErrorLog("msg", "error on receive", "err", err)
				close(lw.OutCh)
				return
			}
			for _, e := range r.Events {
				ev := kvstore.WatchEvent{
					Type:   kvstore.WatchEventType(e.Type),
					Object: e.Object,
				}
				select {
				case lw.OutCh <- &ev:
				case <-wstream.Context().Done():
					close(lw.OutCh)
					return
				}
			}
		}
	}
	lw := listerwatcher.NewWatcherClient(wstream, bridgefn)
	lw.Run()
	return lw, nil
}

func (a *grpcObjWorkloadV1Endpoint) Allowed(oper apiintf.APIOperType) bool {
	return true
}

type restObjWorkloadV1Endpoint struct {
	endpoints workload.EndpointsWorkloadV1RestClient
	instance  string
}

func (a *restObjWorkloadV1Endpoint) Create(ctx context.Context, in *workload.Endpoint) (*workload.Endpoint, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoAddEndpoint(ctx, in)
}

func (a *restObjWorkloadV1Endpoint) Update(ctx context.Context, in *workload.Endpoint) (*workload.Endpoint, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoUpdateEndpoint(ctx, in)
}

func (a *restObjWorkloadV1Endpoint) UpdateStatus(ctx context.Context, in *workload.Endpoint) (*workload.Endpoint, error) {
	return nil, errors.New("not supported for REST")
}

func (a *restObjWorkloadV1Endpoint) Get(ctx context.Context, objMeta *api.ObjectMeta) (*workload.Endpoint, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := workload.Endpoint{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoGetEndpoint(ctx, &in)
}

func (a *restObjWorkloadV1Endpoint) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*workload.Endpoint, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := workload.Endpoint{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoDeleteEndpoint(ctx, &in)
}

func (a *restObjWorkloadV1Endpoint) List(ctx context.Context, options *api.ListWatchOptions) ([]*workload.Endpoint, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}

	if options.Tenant == "" {
		options.Tenant = globals.DefaultTenant
	}
	r, err := a.endpoints.AutoListEndpoint(ctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *restObjWorkloadV1Endpoint) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoWatchEndpoint(ctx, options)
}

func (a *restObjWorkloadV1Endpoint) Allowed(oper apiintf.APIOperType) bool {
	switch oper {
	case apiintf.CreateOper:
		return false
	case apiintf.UpdateOper:
		return false
	case apiintf.GetOper:
		return true
	case apiintf.DeleteOper:
		return false
	case apiintf.ListOper:
		return true
	case apiintf.WatchOper:
		return true
	default:
		return false
	}
}

type grpcObjWorkloadV1Workload struct {
	logger log.Logger
	client workload.ServiceWorkloadV1Client
}

func (a *grpcObjWorkloadV1Workload) Create(ctx context.Context, in *workload.Workload) (*workload.Workload, error) {
	a.logger.DebugLog("msg", "received call", "object", "Workload", "oper", "create")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoAddWorkload(nctx, in)
}

func (a *grpcObjWorkloadV1Workload) Update(ctx context.Context, in *workload.Workload) (*workload.Workload, error) {
	a.logger.DebugLog("msg", "received call", "object", "Workload", "oper", "update")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoUpdateWorkload(nctx, in)
}

func (a *grpcObjWorkloadV1Workload) UpdateStatus(ctx context.Context, in *workload.Workload) (*workload.Workload, error) {
	a.logger.DebugLog("msg", "received call", "object", "Workload", "oper", "update")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	nctx = addStatusUpd(nctx)
	return a.client.AutoUpdateWorkload(nctx, in)
}

func (a *grpcObjWorkloadV1Workload) Get(ctx context.Context, objMeta *api.ObjectMeta) (*workload.Workload, error) {
	a.logger.DebugLog("msg", "received call", "object", "Workload", "oper", "get")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := workload.Workload{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoGetWorkload(nctx, &in)
}

func (a *grpcObjWorkloadV1Workload) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*workload.Workload, error) {
	a.logger.DebugLog("msg", "received call", "object", "Workload", "oper", "delete")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := workload.Workload{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoDeleteWorkload(nctx, &in)
}

func (a *grpcObjWorkloadV1Workload) List(ctx context.Context, options *api.ListWatchOptions) ([]*workload.Workload, error) {
	a.logger.DebugLog("msg", "received call", "object", "Workload", "oper", "list")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	r, err := a.client.AutoListWorkload(nctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *grpcObjWorkloadV1Workload) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	a.logger.DebugLog("msg", "received call", "object", "Workload", "oper", "WatchOper")
	nctx := addVersion(ctx, "v1")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	stream, err := a.client.AutoWatchWorkload(nctx, options)
	if err != nil {
		return nil, err
	}
	wstream := stream.(workload.WorkloadV1_AutoWatchWorkloadClient)
	bridgefn := func(lw *listerwatcher.WatcherClient) {
		for {
			r, err := wstream.Recv()
			if err != nil {
				a.logger.ErrorLog("msg", "error on receive", "err", err)
				close(lw.OutCh)
				return
			}
			for _, e := range r.Events {
				ev := kvstore.WatchEvent{
					Type:   kvstore.WatchEventType(e.Type),
					Object: e.Object,
				}
				select {
				case lw.OutCh <- &ev:
				case <-wstream.Context().Done():
					close(lw.OutCh)
					return
				}
			}
		}
	}
	lw := listerwatcher.NewWatcherClient(wstream, bridgefn)
	lw.Run()
	return lw, nil
}

func (a *grpcObjWorkloadV1Workload) StartMigration(ctx context.Context, in *workload.Workload) (*workload.Workload, error) {
	a.logger.DebugLog("msg", "received call", "object", "{StartMigration Workload Workload}", "oper", "StartMigration")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.StartMigration(nctx, in)
}

func (a *grpcObjWorkloadV1Workload) FinishMigration(ctx context.Context, in *workload.Workload) (*workload.Workload, error) {
	a.logger.DebugLog("msg", "received call", "object", "{FinishMigration Workload Workload}", "oper", "FinishMigration")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.FinishMigration(nctx, in)
}

func (a *grpcObjWorkloadV1Workload) AbortMigration(ctx context.Context, in *workload.Workload) (*workload.Workload, error) {
	a.logger.DebugLog("msg", "received call", "object", "{AbortMigration Workload Workload}", "oper", "AbortMigration")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AbortMigration(nctx, in)
}

func (a *grpcObjWorkloadV1Workload) Allowed(oper apiintf.APIOperType) bool {
	return true
}

type restObjWorkloadV1Workload struct {
	endpoints workload.EndpointsWorkloadV1RestClient
	instance  string
}

func (a *restObjWorkloadV1Workload) Create(ctx context.Context, in *workload.Workload) (*workload.Workload, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoAddWorkload(ctx, in)
}

func (a *restObjWorkloadV1Workload) Update(ctx context.Context, in *workload.Workload) (*workload.Workload, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoUpdateWorkload(ctx, in)
}

func (a *restObjWorkloadV1Workload) UpdateStatus(ctx context.Context, in *workload.Workload) (*workload.Workload, error) {
	return nil, errors.New("not supported for REST")
}

func (a *restObjWorkloadV1Workload) Get(ctx context.Context, objMeta *api.ObjectMeta) (*workload.Workload, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := workload.Workload{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoGetWorkload(ctx, &in)
}

func (a *restObjWorkloadV1Workload) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*workload.Workload, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := workload.Workload{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoDeleteWorkload(ctx, &in)
}

func (a *restObjWorkloadV1Workload) List(ctx context.Context, options *api.ListWatchOptions) ([]*workload.Workload, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}

	if options.Tenant == "" {
		options.Tenant = globals.DefaultTenant
	}
	r, err := a.endpoints.AutoListWorkload(ctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *restObjWorkloadV1Workload) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoWatchWorkload(ctx, options)
}

func (a *restObjWorkloadV1Workload) Allowed(oper apiintf.APIOperType) bool {
	switch oper {
	case apiintf.CreateOper:
		return true
	case apiintf.UpdateOper:
		return true
	case apiintf.GetOper:
		return true
	case apiintf.DeleteOper:
		return true
	case apiintf.ListOper:
		return true
	case apiintf.WatchOper:
		return true
	default:
		return false
	}
}

func (a *restObjWorkloadV1Workload) StartMigration(ctx context.Context, in *workload.Workload) (*workload.Workload, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.StartMigrationWorkload(ctx, in)
}
func (a *restObjWorkloadV1Workload) FinishMigration(ctx context.Context, in *workload.Workload) (*workload.Workload, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.FinishMigrationWorkload(ctx, in)
}
func (a *restObjWorkloadV1Workload) AbortMigration(ctx context.Context, in *workload.Workload) (*workload.Workload, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AbortMigrationWorkload(ctx, in)
}

type crudClientWorkloadV1 struct {
	logger log.Logger
	client workload.ServiceWorkloadV1Client

	grpcEndpoint workload.WorkloadV1EndpointInterface
	grpcWorkload workload.WorkloadV1WorkloadInterface
}

// NewGrpcCrudClientWorkloadV1 creates a GRPC client for the service
func NewGrpcCrudClientWorkloadV1(conn *grpc.ClientConn, logger log.Logger) workload.WorkloadV1Interface {
	client := NewWorkloadV1Backend(conn, logger)
	return &crudClientWorkloadV1{
		logger: logger,
		client: client,

		grpcEndpoint: &grpcObjWorkloadV1Endpoint{client: client, logger: logger},
		grpcWorkload: &grpcObjWorkloadV1Workload{client: client, logger: logger},
	}
}

func (a *crudClientWorkloadV1) Endpoint() workload.WorkloadV1EndpointInterface {
	return a.grpcEndpoint
}

func (a *crudClientWorkloadV1) Workload() workload.WorkloadV1WorkloadInterface {
	return a.grpcWorkload
}

func (a *crudClientWorkloadV1) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	a.logger.DebugLog("msg", "received call", "object", "WorkloadV1", "oper", "WatchOper")
	nctx := addVersion(ctx, "v1")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	stream, err := a.client.AutoWatchSvcWorkloadV1(nctx, options)
	if err != nil {
		return nil, err
	}
	wstream := stream.(workload.WorkloadV1_AutoWatchSvcWorkloadV1Client)
	bridgefn := func(lw *listerwatcher.WatcherClient) {
		for {
			r, err := wstream.Recv()
			if err != nil {
				a.logger.ErrorLog("msg", "error on receive", "err", err)
				close(lw.OutCh)
				return
			}
			for _, e := range r.Events {
				ev := kvstore.WatchEvent{Type: kvstore.WatchEventType(e.Type)}
				robj, err := listerwatcher.GetObject(e)
				if err != nil {
					a.logger.ErrorLog("msg", "error on receive unmarshall", "err", err)
					close(lw.OutCh)
					return
				}
				ev.Object = robj
				select {
				case lw.OutCh <- &ev:
				case <-wstream.Context().Done():
					close(lw.OutCh)
					return
				}
			}
		}
	}
	lw := listerwatcher.NewWatcherClient(wstream, bridgefn)
	lw.Run()
	return lw, nil
}

type crudRestClientWorkloadV1 struct {
	restEndpoint workload.WorkloadV1EndpointInterface
	restWorkload workload.WorkloadV1WorkloadInterface
}

// NewRestCrudClientWorkloadV1 creates a REST client for the service.
func NewRestCrudClientWorkloadV1(url string, httpClient *http.Client) workload.WorkloadV1Interface {
	endpoints, err := workload.MakeWorkloadV1RestClientEndpoints(url, httpClient)
	if err != nil {
		oldlog.Fatal("failed to create client")
	}
	return &crudRestClientWorkloadV1{

		restEndpoint: &restObjWorkloadV1Endpoint{endpoints: endpoints, instance: url},
		restWorkload: &restObjWorkloadV1Workload{endpoints: endpoints, instance: url},
	}
}

// NewStagedRestCrudClientWorkloadV1 creates a REST client for the service.
func NewStagedRestCrudClientWorkloadV1(url string, id string, httpClient *http.Client) workload.WorkloadV1Interface {
	endpoints, err := workload.MakeWorkloadV1StagedRestClientEndpoints(url, id, httpClient)
	if err != nil {
		oldlog.Fatal("failed to create client")
	}
	return &crudRestClientWorkloadV1{

		restEndpoint: &restObjWorkloadV1Endpoint{endpoints: endpoints, instance: url},
		restWorkload: &restObjWorkloadV1Workload{endpoints: endpoints, instance: url},
	}
}

func (a *crudRestClientWorkloadV1) Endpoint() workload.WorkloadV1EndpointInterface {
	return a.restEndpoint
}

func (a *crudRestClientWorkloadV1) Workload() workload.WorkloadV1WorkloadInterface {
	return a.restWorkload
}

func (a *crudRestClientWorkloadV1) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	return nil, errors.New("method unimplemented")
}
