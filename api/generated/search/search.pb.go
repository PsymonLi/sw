// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: search.proto

/*
	Package search is a generated protocol buffer package.

	Service name

	It is generated from these files:
		search.proto
		svc_search.proto

	It has these top-level messages:
		Aggregation
		Category
		Entry
		EntryList
		Error
		Kind
		NestedAggregation
		SearchQuery
		SearchRequest
		SearchResponse
		TextRequirement
*/
package search

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/pensando/grpc-gateway/third_party/googleapis/google/api"
import _ "github.com/pensando/sw/venice/utils/apigen/annotations"
import _ "github.com/gogo/protobuf/gogoproto"
import api "github.com/pensando/sw/api"
import fields "github.com/pensando/sw/api/fields"
import labels "github.com/pensando/sw/api/labels"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type Category_Type int32

const (
	Category_Cluster    Category_Type = 0
	Category_Workload   Category_Type = 1
	Category_Security   Category_Type = 2
	Category_Auth       Category_Type = 3
	Category_Network    Category_Type = 4
	Category_Monitoring Category_Type = 5
	Category_Telemetry  Category_Type = 6
	Category_Events     Category_Type = 7
	Category_Alerts     Category_Type = 8
	Category_AuditTrail Category_Type = 9
	Category_Log        Category_Type = 10
	Category_Config     Category_Type = 11
)

var Category_Type_name = map[int32]string{
	0:  "Cluster",
	1:  "Workload",
	2:  "Security",
	3:  "Auth",
	4:  "Network",
	5:  "Monitoring",
	6:  "Telemetry",
	7:  "Events",
	8:  "Alerts",
	9:  "AuditTrail",
	10: "Log",
	11: "Config",
}
var Category_Type_value = map[string]int32{
	"Cluster":    0,
	"Workload":   1,
	"Security":   2,
	"Auth":       3,
	"Network":    4,
	"Monitoring": 5,
	"Telemetry":  6,
	"Events":     7,
	"Alerts":     8,
	"AuditTrail": 9,
	"Log":        10,
	"Config":     11,
}

func (x Category_Type) String() string {
	return proto.EnumName(Category_Type_name, int32(x))
}
func (Category_Type) EnumDescriptor() ([]byte, []int) { return fileDescriptorSearch, []int{1, 0} }

type Kind_Type int32

const (
	Kind_Cluster                 Kind_Type = 0
	Kind_Node                    Kind_Type = 1
	Kind_SmartNIC                Kind_Type = 2
	Kind_Rollout                 Kind_Type = 3
	Kind_Tenant                  Kind_Type = 4
	Kind_Endpoint                Kind_Type = 5
	Kind_SecurityGroup           Kind_Type = 6
	Kind_Sgpolicy                Kind_Type = 7
	Kind_App                     Kind_Type = 8
	Kind_AppUser                 Kind_Type = 9
	Kind_AppUserGrp              Kind_Type = 10
	Kind_Certificate             Kind_Type = 11
	Kind_TrafficEncryptionPolicy Kind_Type = 12
	Kind_User                    Kind_Type = 13
	Kind_AuthenticationPolicy    Kind_Type = 14
	Kind_Role                    Kind_Type = 15
	Kind_RoleBinding             Kind_Type = 16
	Kind_ClusterUser             Kind_Type = 17
	Kind_ClusterRole             Kind_Type = 18
	Kind_ClusterRoleBinding      Kind_Type = 19
	Kind_Network                 Kind_Type = 20
	Kind_Service                 Kind_Type = 21
	Kind_LbPolicy                Kind_Type = 22
	Kind_Alert                   Kind_Type = 23
	Kind_AlertDestination        Kind_Type = 24
	Kind_AlertPolicy             Kind_Type = 25
	Kind_Event                   Kind_Type = 26
	Kind_EventPolicy             Kind_Type = 27
	Kind_StatsPolicy             Kind_Type = 28
	Kind_FlowExportPolicy        Kind_Type = 29
	Kind_FwlogPolicy             Kind_Type = 30
	Kind_MirrorSession           Kind_Type = 31
)

var Kind_Type_name = map[int32]string{
	0:  "Cluster",
	1:  "Node",
	2:  "SmartNIC",
	3:  "Rollout",
	4:  "Tenant",
	5:  "Endpoint",
	6:  "SecurityGroup",
	7:  "Sgpolicy",
	8:  "App",
	9:  "AppUser",
	10: "AppUserGrp",
	11: "Certificate",
	12: "TrafficEncryptionPolicy",
	13: "User",
	14: "AuthenticationPolicy",
	15: "Role",
	16: "RoleBinding",
	17: "ClusterUser",
	18: "ClusterRole",
	19: "ClusterRoleBinding",
	20: "Network",
	21: "Service",
	22: "LbPolicy",
	23: "Alert",
	24: "AlertDestination",
	25: "AlertPolicy",
	26: "Event",
	27: "EventPolicy",
	28: "StatsPolicy",
	29: "FlowExportPolicy",
	30: "FwlogPolicy",
	31: "MirrorSession",
}
var Kind_Type_value = map[string]int32{
	"Cluster":                 0,
	"Node":                    1,
	"SmartNIC":                2,
	"Rollout":                 3,
	"Tenant":                  4,
	"Endpoint":                5,
	"SecurityGroup":           6,
	"Sgpolicy":                7,
	"App":                     8,
	"AppUser":                 9,
	"AppUserGrp":              10,
	"Certificate":             11,
	"TrafficEncryptionPolicy": 12,
	"User":                 13,
	"AuthenticationPolicy": 14,
	"Role":                 15,
	"RoleBinding":          16,
	"ClusterUser":          17,
	"ClusterRole":          18,
	"ClusterRoleBinding":   19,
	"Network":              20,
	"Service":              21,
	"LbPolicy":             22,
	"Alert":                23,
	"AlertDestination":     24,
	"AlertPolicy":          25,
	"Event":                26,
	"EventPolicy":          27,
	"StatsPolicy":          28,
	"FlowExportPolicy":     29,
	"FwlogPolicy":          30,
	"MirrorSession":        31,
}

func (x Kind_Type) String() string {
	return proto.EnumName(Kind_Type_name, int32(x))
}
func (Kind_Type) EnumDescriptor() ([]byte, []int) { return fileDescriptorSearch, []int{5, 0} }

// List of search categories, specified via "category" modifier
// TODO: generate these enums if possible and use it for validation
type Aggregation struct {
	Entries map[string]*EntryList `protobuf:"bytes,1,rep,name=Entries" json:"entries,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *Aggregation) Reset()                    { *m = Aggregation{} }
func (m *Aggregation) String() string            { return proto.CompactTextString(m) }
func (*Aggregation) ProtoMessage()               {}
func (*Aggregation) Descriptor() ([]byte, []int) { return fileDescriptorSearch, []int{0} }

func (m *Aggregation) GetEntries() map[string]*EntryList {
	if m != nil {
		return m.Entries
	}
	return nil
}

// List of all allowed Kinds in search, specified via "kind" modifier
// TODO: Define a list/map of Kinds per Category
// TODO: generate these enums if possible and use it for validation per Category
//       This is a placeholder enum until we have a way to auto-generate list
//       of all kinds
type Category struct {
}

func (m *Category) Reset()                    { *m = Category{} }
func (m *Category) String() string            { return proto.CompactTextString(m) }
func (*Category) ProtoMessage()               {}
func (*Category) Descriptor() ([]byte, []int) { return fileDescriptorSearch, []int{1} }

// TextRequirement is AND of text-strings in the list
// It is comprised of words or phrases for text search support.
// If a text-string has space separated multi-word, it will be
// interpreted as a phrase.
//
// In the example below :
// - "link down" will be a phrase query
// - network, production, staging will be a word query
//
// For eg:
//    network                      (match network)
//    link down                    (match "link down" phrase)
//    network,production           (match network AND production)
//    network,link down,staging    (match network AND "link down" AND staging)
//
type Entry struct {
	// AND of words or phrases to be matched
	api.TypeMeta   `protobuf:"bytes,1,opt,name=T,embedded=T" json:",inline"`
	api.ObjectMeta `protobuf:"bytes,2,opt,name=O,embedded=O" json:"meta,omitempty"`
}

func (m *Entry) Reset()                    { *m = Entry{} }
func (m *Entry) String() string            { return proto.CompactTextString(m) }
func (*Entry) ProtoMessage()               {}
func (*Entry) Descriptor() ([]byte, []int) { return fileDescriptorSearch, []int{2} }

type EntryList struct {
	// OR of Text-requirements to be matched, Exclude is not supported for Text search
	Entries []*Entry `protobuf:"bytes,1,rep,name=Entries" json:"entries,omitempty"`
}

func (m *EntryList) Reset()                    { *m = EntryList{} }
func (m *EntryList) String() string            { return proto.CompactTextString(m) }
func (*EntryList) ProtoMessage()               {}
func (*EntryList) Descriptor() ([]byte, []int) { return fileDescriptorSearch, []int{3} }

func (m *EntryList) GetEntries() []*Entry {
	if m != nil {
		return m.Entries
	}
	return nil
}

// Error contains the error code, description and
// associated details
type Error struct {
	// Type of error
	Type string `protobuf:"bytes,1,opt,name=Type,proto3" json:"type,omitempty"`
	// Reason or description of the failure
	Reason string `protobuf:"bytes,2,opt,name=Reason,proto3" json:"reason,omitempty"`
}

func (m *Error) Reset()                    { *m = Error{} }
func (m *Error) String() string            { return proto.CompactTextString(m) }
func (*Error) ProtoMessage()               {}
func (*Error) Descriptor() ([]byte, []int) { return fileDescriptorSearch, []int{4} }

func (m *Error) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *Error) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

// Entry represent a single search result entry
type Kind struct {
}

func (m *Kind) Reset()                    { *m = Kind{} }
func (m *Kind) String() string            { return proto.CompactTextString(m) }
func (*Kind) ProtoMessage()               {}
func (*Kind) Descriptor() ([]byte, []int) { return fileDescriptorSearch, []int{5} }

// EntryList is list of search result entries
type NestedAggregation struct {
	Entries map[string]*Aggregation `protobuf:"bytes,1,rep,name=Entries" json:"entries,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *NestedAggregation) Reset()                    { *m = NestedAggregation{} }
func (m *NestedAggregation) String() string            { return proto.CompactTextString(m) }
func (*NestedAggregation) ProtoMessage()               {}
func (*NestedAggregation) Descriptor() ([]byte, []int) { return fileDescriptorSearch, []int{6} }

func (m *NestedAggregation) GetEntries() map[string]*Aggregation {
	if m != nil {
		return m.Entries
	}
	return nil
}

// Aggregation contains map of search results entries
// grouped by a Key.
// For eg: search result entries grouped by Kind as key
type SearchQuery struct {
	Texts      []*TextRequirement `protobuf:"bytes,1,rep,name=Texts" json:"texts,omitempty"`
	Categories []string           `protobuf:"bytes,2,rep,name=Categories" json:"categories,omitempty"`
	Kinds      []string           `protobuf:"bytes,3,rep,name=Kinds" json:"kinds,omitempty"`
	Fields     *fields.Selector   `protobuf:"bytes,4,opt,name=Fields" json:"fields,omitempty"`
	Labels     *labels.Selector   `protobuf:"bytes,5,opt,name=Labels" json:"labels,omitempty"`
}

func (m *SearchQuery) Reset()                    { *m = SearchQuery{} }
func (m *SearchQuery) String() string            { return proto.CompactTextString(m) }
func (*SearchQuery) ProtoMessage()               {}
func (*SearchQuery) Descriptor() ([]byte, []int) { return fileDescriptorSearch, []int{7} }

func (m *SearchQuery) GetTexts() []*TextRequirement {
	if m != nil {
		return m.Texts
	}
	return nil
}

func (m *SearchQuery) GetCategories() []string {
	if m != nil {
		return m.Categories
	}
	return nil
}

func (m *SearchQuery) GetKinds() []string {
	if m != nil {
		return m.Kinds
	}
	return nil
}

func (m *SearchQuery) GetFields() *fields.Selector {
	if m != nil {
		return m.Fields
	}
	return nil
}

func (m *SearchQuery) GetLabels() *labels.Selector {
	if m != nil {
		return m.Labels
	}
	return nil
}

// NestedAggregation contains map of search results
// grouped by two levels of Aggregation
// For eg: search result entries grouped first by Tenant
//         name and subsequently grouped by Kind.
type SearchRequest struct {
	QueryString string       `protobuf:"bytes,1,opt,name=QueryString,proto3" json:"query-string,omitempty"`
	From        int32        `protobuf:"varint,2,opt,name=From,proto3" json:"from,omitempty"`
	MaxResults  int32        `protobuf:"varint,3,opt,name=MaxResults,proto3" json:"max-results,omitempty"`
	Query       *SearchQuery `protobuf:"bytes,4,opt,name=Query" json:"query,omitempty"`
}

func (m *SearchRequest) Reset()                    { *m = SearchRequest{} }
func (m *SearchRequest) String() string            { return proto.CompactTextString(m) }
func (*SearchRequest) ProtoMessage()               {}
func (*SearchRequest) Descriptor() ([]byte, []int) { return fileDescriptorSearch, []int{8} }

func (m *SearchRequest) GetQueryString() string {
	if m != nil {
		return m.QueryString
	}
	return ""
}

func (m *SearchRequest) GetFrom() int32 {
	if m != nil {
		return m.From
	}
	return 0
}

func (m *SearchRequest) GetMaxResults() int32 {
	if m != nil {
		return m.MaxResults
	}
	return 0
}

func (m *SearchRequest) GetQuery() *SearchQuery {
	if m != nil {
		return m.Query
	}
	return nil
}

// SearchRequest is the input to the search API
//
// Simple queries can be specified as URI param using "QueryString".
// For advanced queries, it is recommended to use the "SearchQuery" structure
// and specify them in BODY of the GET/POST method.
//
// Examples of search query in query-string format:
//
//  1. Find all occurrences matching text “Network”
//     Network
//  2. Find all occurrences matching phrase “link down”
//     “link down”
//  3. Find all occurrences matching text production OR "staging"
//     production staging
//  4. Find all occurrences matching text “Network” AND "link down"
//     Network,"link down"
//     Network AND "link down"
//  5. Find all config objects with label1=foo
//     category:config label:label1=foo
//  6. Find all objects created on or after certain date+time
//     category:config field:meta.created-time>=”date-time-string”
//  7. Find all Network objects with type=vlan
//     kind:Network field:spec.type=vlan
//  8. Find all Naples nodes with admission-phase = pending or rejected
//     kind:SmartNIC field:spec.phase in (pending, rejected)
//  9. Find all events with text matching “disconnected”
//     category:events disconnected
// 10. Find all Critical events for Network objects
//     category:events kind:Network field:severity=CRITICAL
// 11. Find all Alerts generated from Naples MAC1
//     category:alerts field:status.source.node=MAC1
//     category:alerts MAC1
// 12. Find all Naples nodes with metric filter : mem>90 && cpu>90
//     category:metrics kind:SmartNIC field:metric.mem>90,metric.cpu>90
// 13. Find all Endpoints with label Tier=Web with counter1>=100
//     category:metrics kind:Endpoint label:Tier=Web field:metric.counter1 > 100
// 14. Find all Endpoints objects with label target=prod with crc-error-count != 0
//     category:metrics kind:Endpoint label:target=prod field:status.crc-error-count!=0
// 15. Find all occurences matching the words and phrase in a certain category & kinds with certain field and label match
//     production "status down" category:Network kind:Network,Service field:spec.service-type=external label:tier=web
//
type SearchResponse struct {
	// Simple query string
	// This can be specified as URI parameter.
	// For advanced query cases, Users should use specify SearchQuery
	// and pass the SearchRequest in a GET/POST Body
	api.TypeMeta `protobuf:"bytes,1,opt,name=T,embedded=T" json:",inline"`
	// From represents the start offset (zero based), used in paginated search requests
	// The results returned would be in the range [From ... From+MaxResults-1]
	// TODO: Add venice option to set default to 0.
	// This can be specified as URI parameter.
	api.ObjectMeta `protobuf:"bytes,2,opt,name=O,embedded=O" json:"meta,omitempty"`
	// MaxResults is the max-count of search results
	// TODO: Add venice option to set some default value (TBD)
	// This can be specified as URI parameter.
	TotalHits int64 `protobuf:"varint,3,opt,name=TotalHits,proto3" json:"total-hits,omitempty"`
	// Search query contains the search requirements
	// This is intended for advanced query use cases involving
	// boolean query, structured term query and supports various
	// combinations of text, phrase strings and search modifiers
	// for specific categories, kinds, fields and labels.
	// This cannot be specified as URI parameter.
	ActualHits        int64              `protobuf:"varint,4,opt,name=ActualHits,proto3" json:"actual-hits,omitempty"`
	TimeTakenMsecs    int64              `protobuf:"varint,5,opt,name=TimeTakenMsecs,proto3" json:"time-taken-msecs,omitempty"`
	Error             *Error             `protobuf:"bytes,6,opt,name=Error" json:"error,omitempty"`
	Entries           []*Entry           `protobuf:"bytes,7,rep,name=Entries" json:"entries,omitempty"`
	AggregatedEntries *NestedAggregation `protobuf:"bytes,8,opt,name=AggregatedEntries" json:"aggregated-entries,omitempty"`
}

func (m *SearchResponse) Reset()                    { *m = SearchResponse{} }
func (m *SearchResponse) String() string            { return proto.CompactTextString(m) }
func (*SearchResponse) ProtoMessage()               {}
func (*SearchResponse) Descriptor() ([]byte, []int) { return fileDescriptorSearch, []int{9} }

func (m *SearchResponse) GetTotalHits() int64 {
	if m != nil {
		return m.TotalHits
	}
	return 0
}

func (m *SearchResponse) GetActualHits() int64 {
	if m != nil {
		return m.ActualHits
	}
	return 0
}

func (m *SearchResponse) GetTimeTakenMsecs() int64 {
	if m != nil {
		return m.TimeTakenMsecs
	}
	return 0
}

func (m *SearchResponse) GetError() *Error {
	if m != nil {
		return m.Error
	}
	return nil
}

func (m *SearchResponse) GetEntries() []*Entry {
	if m != nil {
		return m.Entries
	}
	return nil
}

func (m *SearchResponse) GetAggregatedEntries() *NestedAggregation {
	if m != nil {
		return m.AggregatedEntries
	}
	return nil
}

// SearchResponse is the output provided by the search API
// Based on the search request, search results would be part
// of one of the entities : Entries or NestedAggregation.
// In case of failures, Error would indicate the error status and
// description.
type TextRequirement struct {
	Text []string `protobuf:"bytes,1,rep,name=Text" json:"text,omitempty"`
}

func (m *TextRequirement) Reset()                    { *m = TextRequirement{} }
func (m *TextRequirement) String() string            { return proto.CompactTextString(m) }
func (*TextRequirement) ProtoMessage()               {}
func (*TextRequirement) Descriptor() ([]byte, []int) { return fileDescriptorSearch, []int{10} }

func (m *TextRequirement) GetText() []string {
	if m != nil {
		return m.Text
	}
	return nil
}

func init() {
	proto.RegisterType((*Aggregation)(nil), "search.Aggregation")
	proto.RegisterType((*Category)(nil), "search.Category")
	proto.RegisterType((*Entry)(nil), "search.Entry")
	proto.RegisterType((*EntryList)(nil), "search.EntryList")
	proto.RegisterType((*Error)(nil), "search.Error")
	proto.RegisterType((*Kind)(nil), "search.Kind")
	proto.RegisterType((*NestedAggregation)(nil), "search.NestedAggregation")
	proto.RegisterType((*SearchQuery)(nil), "search.SearchQuery")
	proto.RegisterType((*SearchRequest)(nil), "search.SearchRequest")
	proto.RegisterType((*SearchResponse)(nil), "search.SearchResponse")
	proto.RegisterType((*TextRequirement)(nil), "search.TextRequirement")
	proto.RegisterEnum("search.Category_Type", Category_Type_name, Category_Type_value)
	proto.RegisterEnum("search.Kind_Type", Kind_Type_name, Kind_Type_value)
}
func (m *Aggregation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Aggregation) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Entries) > 0 {
		for k, _ := range m.Entries {
			dAtA[i] = 0xa
			i++
			v := m.Entries[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovSearch(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovSearch(uint64(len(k))) + msgSize
			i = encodeVarintSearch(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintSearch(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintSearch(dAtA, i, uint64(v.Size()))
				n1, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n1
			}
		}
	}
	return i, nil
}

func (m *Category) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Category) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *Entry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Entry) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintSearch(dAtA, i, uint64(m.TypeMeta.Size()))
	n2, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n2
	dAtA[i] = 0x12
	i++
	i = encodeVarintSearch(dAtA, i, uint64(m.ObjectMeta.Size()))
	n3, err := m.ObjectMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n3
	return i, nil
}

func (m *EntryList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EntryList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Entries) > 0 {
		for _, msg := range m.Entries {
			dAtA[i] = 0xa
			i++
			i = encodeVarintSearch(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Error) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Error) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSearch(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.Reason) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSearch(dAtA, i, uint64(len(m.Reason)))
		i += copy(dAtA[i:], m.Reason)
	}
	return i, nil
}

func (m *Kind) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Kind) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *NestedAggregation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NestedAggregation) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Entries) > 0 {
		for k, _ := range m.Entries {
			dAtA[i] = 0xa
			i++
			v := m.Entries[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovSearch(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovSearch(uint64(len(k))) + msgSize
			i = encodeVarintSearch(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintSearch(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintSearch(dAtA, i, uint64(v.Size()))
				n4, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n4
			}
		}
	}
	return i, nil
}

func (m *SearchQuery) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchQuery) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Texts) > 0 {
		for _, msg := range m.Texts {
			dAtA[i] = 0xa
			i++
			i = encodeVarintSearch(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Categories) > 0 {
		for _, s := range m.Categories {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Kinds) > 0 {
		for _, s := range m.Kinds {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.Fields != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintSearch(dAtA, i, uint64(m.Fields.Size()))
		n5, err := m.Fields.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.Labels != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintSearch(dAtA, i, uint64(m.Labels.Size()))
		n6, err := m.Labels.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}

func (m *SearchRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.QueryString) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSearch(dAtA, i, uint64(len(m.QueryString)))
		i += copy(dAtA[i:], m.QueryString)
	}
	if m.From != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintSearch(dAtA, i, uint64(m.From))
	}
	if m.MaxResults != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintSearch(dAtA, i, uint64(m.MaxResults))
	}
	if m.Query != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintSearch(dAtA, i, uint64(m.Query.Size()))
		n7, err := m.Query.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	return i, nil
}

func (m *SearchResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintSearch(dAtA, i, uint64(m.TypeMeta.Size()))
	n8, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n8
	dAtA[i] = 0x12
	i++
	i = encodeVarintSearch(dAtA, i, uint64(m.ObjectMeta.Size()))
	n9, err := m.ObjectMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n9
	if m.TotalHits != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintSearch(dAtA, i, uint64(m.TotalHits))
	}
	if m.ActualHits != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintSearch(dAtA, i, uint64(m.ActualHits))
	}
	if m.TimeTakenMsecs != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintSearch(dAtA, i, uint64(m.TimeTakenMsecs))
	}
	if m.Error != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintSearch(dAtA, i, uint64(m.Error.Size()))
		n10, err := m.Error.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if len(m.Entries) > 0 {
		for _, msg := range m.Entries {
			dAtA[i] = 0x3a
			i++
			i = encodeVarintSearch(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.AggregatedEntries != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintSearch(dAtA, i, uint64(m.AggregatedEntries.Size()))
		n11, err := m.AggregatedEntries.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	return i, nil
}

func (m *TextRequirement) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TextRequirement) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Text) > 0 {
		for _, s := range m.Text {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func encodeVarintSearch(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Aggregation) Size() (n int) {
	var l int
	_ = l
	if len(m.Entries) > 0 {
		for k, v := range m.Entries {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovSearch(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovSearch(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovSearch(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *Category) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *Entry) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovSearch(uint64(l))
	l = m.ObjectMeta.Size()
	n += 1 + l + sovSearch(uint64(l))
	return n
}

func (m *EntryList) Size() (n int) {
	var l int
	_ = l
	if len(m.Entries) > 0 {
		for _, e := range m.Entries {
			l = e.Size()
			n += 1 + l + sovSearch(uint64(l))
		}
	}
	return n
}

func (m *Error) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovSearch(uint64(l))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovSearch(uint64(l))
	}
	return n
}

func (m *Kind) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *NestedAggregation) Size() (n int) {
	var l int
	_ = l
	if len(m.Entries) > 0 {
		for k, v := range m.Entries {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovSearch(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovSearch(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovSearch(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *SearchQuery) Size() (n int) {
	var l int
	_ = l
	if len(m.Texts) > 0 {
		for _, e := range m.Texts {
			l = e.Size()
			n += 1 + l + sovSearch(uint64(l))
		}
	}
	if len(m.Categories) > 0 {
		for _, s := range m.Categories {
			l = len(s)
			n += 1 + l + sovSearch(uint64(l))
		}
	}
	if len(m.Kinds) > 0 {
		for _, s := range m.Kinds {
			l = len(s)
			n += 1 + l + sovSearch(uint64(l))
		}
	}
	if m.Fields != nil {
		l = m.Fields.Size()
		n += 1 + l + sovSearch(uint64(l))
	}
	if m.Labels != nil {
		l = m.Labels.Size()
		n += 1 + l + sovSearch(uint64(l))
	}
	return n
}

func (m *SearchRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.QueryString)
	if l > 0 {
		n += 1 + l + sovSearch(uint64(l))
	}
	if m.From != 0 {
		n += 1 + sovSearch(uint64(m.From))
	}
	if m.MaxResults != 0 {
		n += 1 + sovSearch(uint64(m.MaxResults))
	}
	if m.Query != nil {
		l = m.Query.Size()
		n += 1 + l + sovSearch(uint64(l))
	}
	return n
}

func (m *SearchResponse) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovSearch(uint64(l))
	l = m.ObjectMeta.Size()
	n += 1 + l + sovSearch(uint64(l))
	if m.TotalHits != 0 {
		n += 1 + sovSearch(uint64(m.TotalHits))
	}
	if m.ActualHits != 0 {
		n += 1 + sovSearch(uint64(m.ActualHits))
	}
	if m.TimeTakenMsecs != 0 {
		n += 1 + sovSearch(uint64(m.TimeTakenMsecs))
	}
	if m.Error != nil {
		l = m.Error.Size()
		n += 1 + l + sovSearch(uint64(l))
	}
	if len(m.Entries) > 0 {
		for _, e := range m.Entries {
			l = e.Size()
			n += 1 + l + sovSearch(uint64(l))
		}
	}
	if m.AggregatedEntries != nil {
		l = m.AggregatedEntries.Size()
		n += 1 + l + sovSearch(uint64(l))
	}
	return n
}

func (m *TextRequirement) Size() (n int) {
	var l int
	_ = l
	if len(m.Text) > 0 {
		for _, s := range m.Text {
			l = len(s)
			n += 1 + l + sovSearch(uint64(l))
		}
	}
	return n
}

func sovSearch(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozSearch(x uint64) (n int) {
	return sovSearch(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Aggregation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSearch
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Aggregation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Aggregation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSearch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSearch
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Entries == nil {
				m.Entries = make(map[string]*EntryList)
			}
			var mapkey string
			var mapvalue *EntryList
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSearch
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSearch
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthSearch
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSearch
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthSearch
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthSearch
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &EntryList{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipSearch(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthSearch
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Entries[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSearch(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSearch
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Category) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSearch
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Category: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Category: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipSearch(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSearch
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Entry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSearch
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Entry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Entry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSearch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSearch
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSearch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSearch
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSearch(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSearch
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EntryList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSearch
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EntryList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EntryList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSearch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSearch
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entries = append(m.Entries, &Entry{})
			if err := m.Entries[len(m.Entries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSearch(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSearch
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Error) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSearch
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Error: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Error: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSearch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSearch
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSearch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSearch
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSearch(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSearch
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Kind) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSearch
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Kind: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Kind: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipSearch(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSearch
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NestedAggregation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSearch
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NestedAggregation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NestedAggregation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSearch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSearch
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Entries == nil {
				m.Entries = make(map[string]*Aggregation)
			}
			var mapkey string
			var mapvalue *Aggregation
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSearch
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSearch
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthSearch
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSearch
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthSearch
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthSearch
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Aggregation{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipSearch(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthSearch
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Entries[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSearch(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSearch
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchQuery) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSearch
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchQuery: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchQuery: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Texts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSearch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSearch
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Texts = append(m.Texts, &TextRequirement{})
			if err := m.Texts[len(m.Texts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Categories", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSearch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSearch
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Categories = append(m.Categories, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kinds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSearch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSearch
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kinds = append(m.Kinds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fields", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSearch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSearch
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Fields == nil {
				m.Fields = &fields.Selector{}
			}
			if err := m.Fields.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSearch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSearch
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = &labels.Selector{}
			}
			if err := m.Labels.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSearch(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSearch
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSearch
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueryString", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSearch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSearch
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QueryString = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			m.From = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSearch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.From |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxResults", wireType)
			}
			m.MaxResults = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSearch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxResults |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSearch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSearch
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Query == nil {
				m.Query = &SearchQuery{}
			}
			if err := m.Query.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSearch(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSearch
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSearch
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSearch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSearch
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSearch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSearch
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalHits", wireType)
			}
			m.TotalHits = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSearch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalHits |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActualHits", wireType)
			}
			m.ActualHits = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSearch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ActualHits |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeTakenMsecs", wireType)
			}
			m.TimeTakenMsecs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSearch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimeTakenMsecs |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSearch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSearch
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Error == nil {
				m.Error = &Error{}
			}
			if err := m.Error.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSearch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSearch
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entries = append(m.Entries, &Entry{})
			if err := m.Entries[len(m.Entries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AggregatedEntries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSearch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSearch
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AggregatedEntries == nil {
				m.AggregatedEntries = &NestedAggregation{}
			}
			if err := m.AggregatedEntries.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSearch(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSearch
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TextRequirement) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSearch
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TextRequirement: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TextRequirement: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSearch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSearch
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Text = append(m.Text, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSearch(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSearch
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipSearch(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowSearch
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSearch
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSearch
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthSearch
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowSearch
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipSearch(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthSearch = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowSearch   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("search.proto", fileDescriptorSearch) }

var fileDescriptorSearch = []byte{
	// 1340 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x56, 0xcd, 0x6e, 0x1b, 0x37,
	0x17, 0xcd, 0x58, 0x3f, 0xb6, 0x28, 0xff, 0xd0, 0xb4, 0x63, 0xcb, 0x4e, 0x3e, 0xcb, 0x10, 0xbe,
	0xa6, 0x0e, 0x10, 0x4b, 0x81, 0x0b, 0x14, 0x4d, 0x11, 0xb4, 0xb0, 0x5c, 0x39, 0x2d, 0xea, 0x9f,
	0x54, 0x52, 0xd0, 0x45, 0xd1, 0xc5, 0x78, 0x74, 0x3d, 0x66, 0x3d, 0x43, 0x4e, 0x38, 0x1c, 0xdb,
	0x5a, 0x76, 0x93, 0x45, 0x1f, 0xa3, 0xbb, 0x66, 0xd3, 0x45, 0x9f, 0xa0, 0xbb, 0x2c, 0xf3, 0x04,
	0x42, 0x91, 0x45, 0x17, 0x5e, 0xf7, 0x01, 0x8a, 0xcb, 0x99, 0xb1, 0x69, 0x27, 0x69, 0xd3, 0x2e,
	0xba, 0xd2, 0xf0, 0xf2, 0x9c, 0x43, 0xf2, 0xf0, 0xf2, 0x5e, 0x91, 0xc9, 0x18, 0x5c, 0xe5, 0x1d,
	0x35, 0x23, 0x25, 0xb5, 0x64, 0xe5, 0x74, 0xb4, 0x7c, 0xdb, 0x97, 0xd2, 0x0f, 0xa0, 0xe5, 0x46,
	0xbc, 0xe5, 0x0a, 0x21, 0xb5, 0xab, 0xb9, 0x14, 0x71, 0x8a, 0x5a, 0xee, 0xf8, 0x5c, 0x1f, 0x25,
	0x07, 0x4d, 0x4f, 0x86, 0xad, 0x08, 0x44, 0xec, 0x8a, 0x81, 0x6c, 0xc5, 0xa7, 0xad, 0x13, 0x10,
	0xdc, 0x83, 0x56, 0xa2, 0x79, 0x10, 0x23, 0xd5, 0x07, 0x61, 0xb3, 0x5b, 0x5c, 0x78, 0x41, 0x32,
	0x80, 0x5c, 0x66, 0xdd, 0x92, 0xf1, 0xa5, 0x2f, 0x5b, 0x26, 0x7c, 0x90, 0x1c, 0x9a, 0x91, 0x19,
	0x98, 0xaf, 0x0c, 0xfe, 0xde, 0x5b, 0x56, 0xc5, 0x3d, 0x86, 0xa0, 0xdd, 0x0c, 0x76, 0xff, 0x2f,
	0x60, 0x87, 0x1c, 0x82, 0x41, 0xdc, 0x8a, 0x21, 0x00, 0x4f, 0x4b, 0xf5, 0x0e, 0x8c, 0xc0, 0x3d,
	0x80, 0xe0, 0x3a, 0xa3, 0xf1, 0x8b, 0x43, 0xaa, 0x9b, 0xbe, 0xaf, 0xc0, 0x37, 0x27, 0x63, 0x4f,
	0xc8, 0x78, 0x47, 0x68, 0xc5, 0x21, 0xae, 0x39, 0xab, 0x85, 0xb5, 0xea, 0xc6, 0x6a, 0x33, 0xb3,
	0xd5, 0x42, 0x35, 0x33, 0x08, 0xfe, 0x0c, 0xdb, 0x4b, 0x2f, 0x46, 0x75, 0xe7, 0x7c, 0x54, 0x9f,
	0x85, 0x34, 0x7a, 0x4f, 0x86, 0x5c, 0x43, 0x18, 0xe9, 0x61, 0x37, 0xd7, 0x5a, 0xde, 0x25, 0x93,
	0x36, 0x87, 0x51, 0x52, 0x38, 0x86, 0x61, 0xcd, 0x59, 0x75, 0xd6, 0x2a, 0x5d, 0xfc, 0x64, 0xef,
	0x93, 0xd2, 0x89, 0x1b, 0x24, 0x50, 0x1b, 0x5b, 0x75, 0xd6, 0xaa, 0x1b, 0xb3, 0xf9, 0xb2, 0x06,
	0xbf, 0xc3, 0x63, 0xdd, 0x4d, 0xe7, 0x3f, 0x1e, 0xfb, 0xc8, 0x69, 0xfc, 0xec, 0x90, 0x89, 0x2d,
	0x57, 0x83, 0x2f, 0xd5, 0xb0, 0xf1, 0xa3, 0x43, 0x8a, 0xfd, 0x61, 0x04, 0xac, 0x4a, 0xc6, 0xb7,
	0x82, 0x24, 0xd6, 0xa0, 0xe8, 0x0d, 0x36, 0x49, 0x26, 0xbe, 0x96, 0xea, 0x38, 0x90, 0xee, 0x80,
	0x3a, 0x38, 0xea, 0x81, 0x97, 0x28, 0xae, 0x87, 0x74, 0x8c, 0x4d, 0x90, 0xe2, 0x66, 0xa2, 0x8f,
	0x68, 0x01, 0x29, 0x7b, 0xa0, 0x4f, 0xa5, 0x3a, 0xa6, 0x45, 0x36, 0x4d, 0xc8, 0xae, 0x14, 0x5c,
	0x4b, 0xc5, 0x85, 0x4f, 0x4b, 0x6c, 0x8a, 0x54, 0xfa, 0x10, 0x40, 0x08, 0x5a, 0x0d, 0x69, 0x99,
	0x11, 0x52, 0xee, 0x9c, 0x80, 0xd0, 0x31, 0x1d, 0xc7, 0xef, 0xcd, 0x00, 0x94, 0x8e, 0xe9, 0x04,
	0xd2, 0x36, 0x93, 0x01, 0xd7, 0x7d, 0xe5, 0xf2, 0x80, 0x56, 0xd8, 0x38, 0x29, 0xec, 0x48, 0x9f,
	0x12, 0x04, 0x6d, 0x49, 0x71, 0xc8, 0x7d, 0x5a, 0x6d, 0x68, 0x52, 0x4a, 0x4f, 0x7e, 0x9f, 0x38,
	0x7d, 0x73, 0xee, 0xea, 0xc6, 0x54, 0xd3, 0x8d, 0x78, 0x13, 0xb7, 0xbe, 0x0b, 0xda, 0x6d, 0xcf,
	0xbd, 0x18, 0xd5, 0x6f, 0xbc, 0x4c, 0xbd, 0x1c, 0xbf, 0xc7, 0x45, 0xc0, 0x05, 0x74, 0x9d, 0x3e,
	0x7b, 0x40, 0x9c, 0xfd, 0xcc, 0x95, 0x19, 0xc3, 0xd8, 0x3f, 0xf8, 0x0e, 0x3c, 0x6d, 0x38, 0xcb,
	0x16, 0x67, 0x1a, 0x53, 0xc7, 0x32, 0xdf, 0xd9, 0x6f, 0xec, 0x93, 0xca, 0x85, 0x7f, 0xac, 0x7d,
	0xfd, 0x6a, 0xa7, 0xae, 0x78, 0xfc, 0x2e, 0xf7, 0xd8, 0xf8, 0x96, 0x94, 0x3a, 0x4a, 0x49, 0xc5,
	0xee, 0xa4, 0x9e, 0xa7, 0x37, 0xd8, 0x66, 0xb8, 0xbc, 0x1e, 0x46, 0x60, 0x71, 0xd2, 0x3b, 0xb9,
	0x47, 0xca, 0x5d, 0x70, 0x63, 0x29, 0xcc, 0x09, 0x2a, 0xed, 0xf9, 0xf3, 0x51, 0x9d, 0x2a, 0x13,
	0xb1, 0xb0, 0x19, 0xa6, 0xf1, 0x43, 0x91, 0x14, 0xbf, 0xe4, 0x62, 0xd0, 0xf8, 0xbe, 0xf8, 0xa6,
	0x3b, 0x9d, 0x20, 0xc5, 0x3d, 0x39, 0x80, 0xec, 0x3e, 0x43, 0x57, 0xe9, 0xbd, 0x2f, 0xb6, 0xe8,
	0x18, 0x82, 0xba, 0x32, 0x08, 0x64, 0xa2, 0x69, 0x01, 0x5d, 0xef, 0x83, 0x70, 0x85, 0xa6, 0x45,
	0x84, 0x75, 0xc4, 0x20, 0x92, 0x5c, 0x68, 0x5a, 0x62, 0xb3, 0x64, 0x2a, 0x4f, 0x82, 0x47, 0x4a,
	0x26, 0x11, 0x2d, 0x1b, 0x1d, 0x3f, 0x92, 0x01, 0xf7, 0x86, 0x74, 0x1c, 0x6f, 0x6e, 0x33, 0x8a,
	0xe8, 0x04, 0x0a, 0x6e, 0x46, 0xd1, 0x93, 0x18, 0x14, 0xad, 0x98, 0xfb, 0x4d, 0x07, 0x8f, 0x54,
	0x44, 0x09, 0x9b, 0x21, 0xd5, 0x2d, 0x50, 0x9a, 0x1f, 0x72, 0xcf, 0xd5, 0x40, 0xab, 0xec, 0x16,
	0x59, 0xec, 0x2b, 0xf7, 0xf0, 0x90, 0x7b, 0x1d, 0xe1, 0xa9, 0x61, 0x84, 0x4f, 0xe4, 0x71, 0xaa,
	0x39, 0x89, 0x7b, 0x36, 0x3a, 0x53, 0xac, 0x46, 0xe6, 0x31, 0xeb, 0x40, 0x68, 0x24, 0x5e, 0x62,
	0xa6, 0x11, 0xd3, 0x95, 0x01, 0xd0, 0x19, 0xd4, 0xc6, 0xaf, 0x36, 0x17, 0x03, 0xcc, 0x41, 0x6a,
	0x16, 0x4b, 0xcf, 0x6f, 0x54, 0x66, 0xad, 0x80, 0xa1, 0x30, 0xb6, 0x40, 0x98, 0x15, 0xc8, 0x99,
	0x73, 0x76, 0x6a, 0xcf, 0xe3, 0xa0, 0x07, 0xea, 0x84, 0x7b, 0x40, 0x6f, 0xe2, 0xa1, 0x77, 0x0e,
	0xb2, 0xc5, 0x17, 0x58, 0x85, 0x94, 0x4c, 0x2a, 0xd3, 0x45, 0x36, 0x4f, 0xa8, 0xf9, 0xfc, 0x0c,
	0x62, 0xcd, 0x85, 0xd9, 0x23, 0xad, 0xe1, 0x8a, 0x26, 0x9a, 0x31, 0x96, 0x90, 0x61, 0x1e, 0x02,
	0x5d, 0xc6, 0x39, 0xf3, 0x99, 0xcd, 0xdd, 0xc2, 0x40, 0x4f, 0xbb, 0x3a, 0xce, 0x02, 0xb7, 0x51,
	0x73, 0x3b, 0x90, 0xa7, 0x9d, 0xb3, 0x48, 0x5e, 0x48, 0xfc, 0x0f, 0x61, 0xdb, 0xa7, 0x81, 0xf4,
	0xb3, 0xc0, 0x0a, 0xde, 0xcd, 0x2e, 0xc7, 0xcc, 0xea, 0x41, 0x1c, 0xe3, 0xba, 0xf5, 0xc6, 0xaf,
	0x0e, 0x99, 0xdd, 0x83, 0x58, 0xc3, 0xc0, 0x2e, 0x50, 0xdf, 0x5c, 0xcf, 0xe2, 0x3b, 0x79, 0x16,
	0xbf, 0x86, 0xfd, 0xe7, 0x65, 0x6a, 0xff, 0x6f, 0xcb, 0xd4, 0xdd, 0xab, 0x65, 0x6a, 0xee, 0x0d,
	0xd5, 0xd1, 0x2e, 0x54, 0xbf, 0x8f, 0x91, 0x6a, 0xcf, 0x20, 0xbe, 0x4a, 0x40, 0x0d, 0x59, 0x9b,
	0x94, 0xfa, 0x70, 0xa6, 0xf3, 0xbd, 0x2f, 0xe6, 0x74, 0x0c, 0x76, 0xe1, 0x69, 0xc2, 0x15, 0x84,
	0x20, 0x74, 0x7b, 0xee, 0x7c, 0x54, 0x9f, 0xd1, 0x88, 0xb4, 0xb6, 0x99, 0x52, 0x59, 0x97, 0x90,
	0xac, 0xf6, 0xa1, 0x09, 0x63, 0xab, 0x85, 0xb5, 0x4a, 0x7b, 0xe3, 0xf9, 0xb3, 0xa5, 0x85, 0x9e,
	0x56, 0x1d, 0x91, 0x84, 0x6b, 0x79, 0x65, 0x34, 0xa5, 0xe5, 0xee, 0xf9, 0xa8, 0x3e, 0xef, 0x5d,
	0xe0, 0x2d, 0x39, 0x4b, 0x85, 0x7d, 0x4a, 0x4a, 0xf8, 0xee, 0xe2, 0x5a, 0xc1, 0xc8, 0xdd, 0x7d,
	0xfe, 0x6c, 0x89, 0xe5, 0x72, 0x38, 0x71, 0x21, 0x35, 0x73, 0x8c, 0x30, 0x7b, 0x53, 0x86, 0xc7,
	0x3e, 0x21, 0xe5, 0x6d, 0xd3, 0x92, 0x6a, 0x45, 0x63, 0x0c, 0x6d, 0xa6, 0x1d, 0xaa, 0xd9, 0xcb,
	0xfa, 0x4d, 0xfa, 0xf2, 0xd3, 0xa0, 0xfd, 0xf2, 0x53, 0x16, 0xf2, 0x77, 0x4c, 0x83, 0xaa, 0x95,
	0x32, 0x7e, 0xda, 0xaf, 0xae, 0xf1, 0xd3, 0xa0, 0xcd, 0x4f, 0x59, 0x8d, 0x3f, 0x1c, 0x7c, 0xdc,
	0xe8, 0x25, 0xda, 0x08, 0xb1, 0x66, 0x0f, 0x49, 0xd5, 0x78, 0xde, 0xd3, 0x58, 0xce, 0xb3, 0x42,
	0xb5, 0x7c, 0x3e, 0xaa, 0x2f, 0x3c, 0xc5, 0xf0, 0x7a, 0x6c, 0xe2, 0x96, 0x94, 0x0d, 0xc7, 0xfa,
	0xb6, 0xad, 0x64, 0x68, 0xae, 0xb9, 0x94, 0xd6, 0xb7, 0x43, 0x25, 0x43, 0xbb, 0xbe, 0xe1, 0x3c,
	0x7b, 0x40, 0xc8, 0xae, 0x7b, 0xd6, 0x85, 0x38, 0x09, 0x34, 0xba, 0x87, 0xe8, 0xa5, 0xf3, 0x51,
	0xfd, 0x66, 0xe8, 0x9e, 0xad, 0xab, 0x34, 0x6c, 0x7b, 0x7e, 0x09, 0xc6, 0x5c, 0x30, 0x2b, 0x66,
	0x8e, 0x5d, 0xa4, 0x92, 0x95, 0x2f, 0xed, 0xc5, 0x2c, 0x69, 0x67, 0xcc, 0x9e, 0x6d, 0xdb, 0xcd,
	0x7c, 0xe3, 0xa7, 0x22, 0x99, 0xce, 0x8f, 0x1d, 0x47, 0x52, 0xc4, 0xf0, 0x9f, 0x36, 0x18, 0xf6,
	0x21, 0xa9, 0xf4, 0xa5, 0x76, 0x83, 0xcf, 0x79, 0x76, 0xfa, 0x42, 0xbb, 0x86, 0x09, 0xa7, 0x31,
	0xb8, 0x7e, 0xc4, 0xaf, 0x1c, 0xfe, 0x12, 0x8a, 0xb6, 0x6d, 0x7a, 0x3a, 0xc9, 0x88, 0x45, 0x43,
	0x34, 0xb6, 0xb9, 0x26, 0x7a, 0x9d, 0x69, 0x81, 0xd9, 0x36, 0x99, 0xee, 0xf3, 0x10, 0xfa, 0xee,
	0x31, 0x88, 0xdd, 0x18, 0xbc, 0x34, 0x63, 0x0a, 0xed, 0x95, 0xf3, 0x51, 0x7d, 0x59, 0xf3, 0x10,
	0xd6, 0x35, 0x4e, 0xad, 0x87, 0x38, 0x67, 0x69, 0x5c, 0x63, 0xb1, 0x87, 0x59, 0x2b, 0xab, 0x95,
	0x33, 0xaf, 0xf2, 0x66, 0x88, 0xc1, 0x4b, 0xe3, 0x01, 0x87, 0xb6, 0xf1, 0x69, 0xff, 0xb3, 0x9a,
	0xe9, 0xf8, 0xbf, 0x6c, 0xa6, 0x2c, 0x24, 0xb3, 0x79, 0xd9, 0x80, 0x41, 0xae, 0x36, 0x61, 0x76,
	0xb3, 0xf4, 0xd6, 0xa2, 0xd6, 0xfe, 0x7f, 0xa6, 0x7c, 0xdb, 0xbd, 0xe0, 0xae, 0xbf, 0xbe, 0xc8,
	0xeb, 0xca, 0x8d, 0x07, 0x64, 0xe6, 0x5a, 0x99, 0x31, 0x5d, 0x1c, 0xce, 0xb4, 0xa9, 0x46, 0x79,
	0x17, 0x87, 0x33, 0x7d, 0xa5, 0x8b, 0xc3, 0x99, 0x6e, 0x4f, 0xbe, 0x78, 0xb5, 0xe2, 0xbc, 0x7c,
	0xb5, 0xe2, 0xfc, 0xf6, 0x6a, 0xc5, 0x79, 0xec, 0x1c, 0x94, 0xcd, 0x9f, 0xc7, 0x0f, 0xfe, 0x0c,
	0x00, 0x00, 0xff, 0xff, 0xff, 0x67, 0x36, 0xe9, 0x73, 0x0b, 0x00, 0x00,
}
