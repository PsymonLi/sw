// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: search.proto

/*
	Package search is a generated protocol buffer package.

	Service name

	It is generated from these files:
		search.proto
		svc_search.proto

	It has these top-level messages:
		Category
		CategoryAggregation
		CategoryPreview
		Entry
		EntryList
		Error
		Kind
		KindAggregation
		KindPreview
		PolicySearchRequest
		PolicySearchResponse
		SearchQuery
		SearchRequest
		SearchResponse
		TenantAggregation
		TenantPreview
		TextRequirement
*/
package search

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/pensando/grpc-gateway/third_party/googleapis/google/api"
import _ "github.com/pensando/sw/venice/utils/apigen/annotations"
import _ "github.com/gogo/protobuf/gogoproto"
import api "github.com/pensando/sw/api"
import fields "github.com/pensando/sw/api/fields"
import labels "github.com/pensando/sw/api/labels"
import security "github.com/pensando/sw/api/generated/security"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

//
type Category_Type int32

const (
	// api-groups
	Category_Cluster Category_Type = 0
	//
	Category_Workload Category_Type = 1
	//
	Category_Security Category_Type = 2
	//
	Category_Auth Category_Type = 3
	//
	Category_Network Category_Type = 4
	//
	Category_Monitoring Category_Type = 5
	// Additional categories
	// granular categories
	Category_Telemetry Category_Type = 6
	//
	Category_Events Category_Type = 7
	//
	Category_Alerts Category_Type = 8
	// special categories
	Category_AuditTrail Category_Type = 9
)

var Category_Type_name = map[int32]string{
	0: "Cluster",
	1: "Workload",
	2: "Security",
	3: "Auth",
	4: "Network",
	5: "Monitoring",
	6: "Telemetry",
	7: "Events",
	8: "Alerts",
	9: "AuditTrail",
}
var Category_Type_value = map[string]int32{
	"Cluster":    0,
	"Workload":   1,
	"Security":   2,
	"Auth":       3,
	"Network":    4,
	"Monitoring": 5,
	"Telemetry":  6,
	"Events":     7,
	"Alerts":     8,
	"AuditTrail": 9,
}

func (x Category_Type) String() string {
	return proto.EnumName(Category_Type_name, int32(x))
}
func (Category_Type) EnumDescriptor() ([]byte, []int) { return fileDescriptorSearch, []int{0, 0} }

//
type Kind_Type int32

const (
	//
	Kind_Cluster Kind_Type = 0
	//
	Kind_Node Kind_Type = 1
	//
	Kind_SmartNIC Kind_Type = 2
	//
	Kind_Rollout Kind_Type = 3
	//
	Kind_Tenant Kind_Type = 4
	//
	Kind_Endpoint Kind_Type = 5
	//
	Kind_SecurityGroup Kind_Type = 6
	//
	Kind_Sgpolicy Kind_Type = 7
	//
	Kind_App Kind_Type = 8
	//
	Kind_AppUser Kind_Type = 9
	//
	Kind_AppUserGrp Kind_Type = 10
	//
	Kind_Certificate Kind_Type = 11
	//
	Kind_TrafficEncryptionPolicy Kind_Type = 12
	//
	Kind_User Kind_Type = 13
	//
	Kind_AuthenticationPolicy Kind_Type = 14
	//
	Kind_Role Kind_Type = 15
	//
	Kind_RoleBinding Kind_Type = 16
	//
	Kind_Network Kind_Type = 17
	//
	Kind_Service Kind_Type = 18
	//
	Kind_LbPolicy Kind_Type = 19
	//
	Kind_Alert Kind_Type = 20
	//
	Kind_AlertDestination Kind_Type = 21
	//
	Kind_AlertPolicy Kind_Type = 22
	//
	Kind_Event Kind_Type = 23
	//
	Kind_EventPolicy Kind_Type = 24
	//
	Kind_StatsPolicy Kind_Type = 25
	//
	Kind_FlowExportPolicy Kind_Type = 26
	//
	Kind_FwlogPolicy Kind_Type = 27
	//
	Kind_MirrorSession Kind_Type = 28
)

var Kind_Type_name = map[int32]string{
	0:  "Cluster",
	1:  "Node",
	2:  "SmartNIC",
	3:  "Rollout",
	4:  "Tenant",
	5:  "Endpoint",
	6:  "SecurityGroup",
	7:  "Sgpolicy",
	8:  "App",
	9:  "AppUser",
	10: "AppUserGrp",
	11: "Certificate",
	12: "TrafficEncryptionPolicy",
	13: "User",
	14: "AuthenticationPolicy",
	15: "Role",
	16: "RoleBinding",
	17: "Network",
	18: "Service",
	19: "LbPolicy",
	20: "Alert",
	21: "AlertDestination",
	22: "AlertPolicy",
	23: "Event",
	24: "EventPolicy",
	25: "StatsPolicy",
	26: "FlowExportPolicy",
	27: "FwlogPolicy",
	28: "MirrorSession",
}
var Kind_Type_value = map[string]int32{
	"Cluster":                 0,
	"Node":                    1,
	"SmartNIC":                2,
	"Rollout":                 3,
	"Tenant":                  4,
	"Endpoint":                5,
	"SecurityGroup":           6,
	"Sgpolicy":                7,
	"App":                     8,
	"AppUser":                 9,
	"AppUserGrp":              10,
	"Certificate":             11,
	"TrafficEncryptionPolicy": 12,
	"User":                 13,
	"AuthenticationPolicy": 14,
	"Role":                 15,
	"RoleBinding":          16,
	"Network":              17,
	"Service":              18,
	"LbPolicy":             19,
	"Alert":                20,
	"AlertDestination":     21,
	"AlertPolicy":          22,
	"Event":                23,
	"EventPolicy":          24,
	"StatsPolicy":          25,
	"FlowExportPolicy":     26,
	"FwlogPolicy":          27,
	"MirrorSession":        28,
}

func (x Kind_Type) String() string {
	return proto.EnumName(Kind_Type_name, int32(x))
}
func (Kind_Type) EnumDescriptor() ([]byte, []int) { return fileDescriptorSearch, []int{6, 0} }

//
type PolicySearchResponse_MatchStatus int32

const (
	//
	PolicySearchResponse_MATCH PolicySearchResponse_MatchStatus = 0
	//
	PolicySearchResponse_MISS PolicySearchResponse_MatchStatus = 1
)

var PolicySearchResponse_MatchStatus_name = map[int32]string{
	0: "MATCH",
	1: "MISS",
}
var PolicySearchResponse_MatchStatus_value = map[string]int32{
	"MATCH": 0,
	"MISS":  1,
}

func (x PolicySearchResponse_MatchStatus) String() string {
	return proto.EnumName(PolicySearchResponse_MatchStatus_name, int32(x))
}
func (PolicySearchResponse_MatchStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorSearch, []int{10, 0}
}

// Search Request Mode
type SearchRequest_RequestMode int32

const (
	// In full mode, full results comprising of Object Meta
	// grouped by Tenant->Category->Kind is returned. This
	// is the default mode.
	SearchRequest_Full SearchRequest_RequestMode = 0
	// In preview mode, only the search summary (i.e number of hits)
	// grouped by Tenant->Category->Kind is returned
	SearchRequest_Preview SearchRequest_RequestMode = 1
)

var SearchRequest_RequestMode_name = map[int32]string{
	0: "Full",
	1: "Preview",
}
var SearchRequest_RequestMode_value = map[string]int32{
	"Full":    0,
	"Preview": 1,
}

func (x SearchRequest_RequestMode) String() string {
	return proto.EnumName(SearchRequest_RequestMode_name, int32(x))
}
func (SearchRequest_RequestMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorSearch, []int{12, 0}
}

// List of search categories, specified via "category" modifier
// TODO: generate these enums if possible and use it for validation
type Category struct {
}

func (m *Category) Reset()                    { *m = Category{} }
func (m *Category) String() string            { return proto.CompactTextString(m) }
func (*Category) ProtoMessage()               {}
func (*Category) Descriptor() ([]byte, []int) { return fileDescriptorSearch, []int{0} }

// CategoryAggregation contains map of search result entries
// grouped by two levels: first by Category and then by Kind.
type CategoryAggregation struct {
	//
	Categories map[string]*KindAggregation `protobuf:"bytes,1,rep,name=Categories,json=categories,omitempty" json:"categories,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *CategoryAggregation) Reset()                    { *m = CategoryAggregation{} }
func (m *CategoryAggregation) String() string            { return proto.CompactTextString(m) }
func (*CategoryAggregation) ProtoMessage()               {}
func (*CategoryAggregation) Descriptor() ([]byte, []int) { return fileDescriptorSearch, []int{1} }

func (m *CategoryAggregation) GetCategories() map[string]*KindAggregation {
	if m != nil {
		return m.Categories
	}
	return nil
}

// CategoryPreview contains map of search summary (#hits)
// grouped by two levels: first by Category and then by Kind.
type CategoryPreview struct {
	//
	Categories map[string]*KindPreview `protobuf:"bytes,1,rep,name=Categories,json=categories,omitempty" json:"categories,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *CategoryPreview) Reset()                    { *m = CategoryPreview{} }
func (m *CategoryPreview) String() string            { return proto.CompactTextString(m) }
func (*CategoryPreview) ProtoMessage()               {}
func (*CategoryPreview) Descriptor() ([]byte, []int) { return fileDescriptorSearch, []int{2} }

func (m *CategoryPreview) GetCategories() map[string]*KindPreview {
	if m != nil {
		return m.Categories
	}
	return nil
}

// Entry represent a single search result entry
type Entry struct {
	// For Policy & config objects, the result will have
	// have all the metadata and a self-link to get the
	// entire object next if needed
	api.TypeMeta `protobuf:"bytes,1,opt,name=T,json=,inline,embedded=T" json:",inline"`
	//
	api.ObjectMeta `protobuf:"bytes,2,opt,name=O,json=meta,omitempty,embedded=O" json:"meta,omitempty"`
}

func (m *Entry) Reset()                    { *m = Entry{} }
func (m *Entry) String() string            { return proto.CompactTextString(m) }
func (*Entry) ProtoMessage()               {}
func (*Entry) Descriptor() ([]byte, []int) { return fileDescriptorSearch, []int{3} }

// EntryList is list of search result entries
type EntryList struct {
	//
	Entries []*Entry `protobuf:"bytes,1,rep,name=Entries,json=entries,omitempty" json:"entries,omitempty"`
}

func (m *EntryList) Reset()                    { *m = EntryList{} }
func (m *EntryList) String() string            { return proto.CompactTextString(m) }
func (*EntryList) ProtoMessage()               {}
func (*EntryList) Descriptor() ([]byte, []int) { return fileDescriptorSearch, []int{4} }

func (m *EntryList) GetEntries() []*Entry {
	if m != nil {
		return m.Entries
	}
	return nil
}

// Error contains the error code, description and
// associated details
type Error struct {
	// Type of error
	Type string `protobuf:"bytes,1,opt,name=Type,json=type,omitempty,proto3" json:"type,omitempty"`
	// Reason or description of the failure
	Reason string `protobuf:"bytes,2,opt,name=Reason,json=reason,omitempty,proto3" json:"reason,omitempty"`
}

func (m *Error) Reset()                    { *m = Error{} }
func (m *Error) String() string            { return proto.CompactTextString(m) }
func (*Error) ProtoMessage()               {}
func (*Error) Descriptor() ([]byte, []int) { return fileDescriptorSearch, []int{5} }

func (m *Error) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *Error) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

// List of all allowed Kinds in search, specified via "kind" modifier
// TODO: Define a list/map of Kinds per Category
// TODO: generate these enums if possible and use it for validation per Category
//       This is a placeholder enum until we have a way to auto-generate list
//       of all kinds
type Kind struct {
}

func (m *Kind) Reset()                    { *m = Kind{} }
func (m *Kind) String() string            { return proto.CompactTextString(m) }
func (*Kind) ProtoMessage()               {}
func (*Kind) Descriptor() ([]byte, []int) { return fileDescriptorSearch, []int{6} }

// KindAggregation contains map of search result
// entries grouped by Kind.
type KindAggregation struct {
	//
	Kinds map[string]*EntryList `protobuf:"bytes,1,rep,name=Kinds,json=kinds,omitempty" json:"kinds,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *KindAggregation) Reset()                    { *m = KindAggregation{} }
func (m *KindAggregation) String() string            { return proto.CompactTextString(m) }
func (*KindAggregation) ProtoMessage()               {}
func (*KindAggregation) Descriptor() ([]byte, []int) { return fileDescriptorSearch, []int{7} }

func (m *KindAggregation) GetKinds() map[string]*EntryList {
	if m != nil {
		return m.Kinds
	}
	return nil
}

// KindPreview contains map of search summary (#hits) grouped by Kind.
type KindPreview struct {
	//
	Kinds map[string]int64 `protobuf:"bytes,1,rep,name=Kinds,json=kinds,omitempty" json:"kinds,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
}

func (m *KindPreview) Reset()                    { *m = KindPreview{} }
func (m *KindPreview) String() string            { return proto.CompactTextString(m) }
func (*KindPreview) ProtoMessage()               {}
func (*KindPreview) Descriptor() ([]byte, []int) { return fileDescriptorSearch, []int{8} }

func (m *KindPreview) GetKinds() map[string]int64 {
	if m != nil {
		return m.Kinds
	}
	return nil
}

// PolicySearchRequest is input to the security/firewall policy search request
type PolicySearchRequest struct {
	// Tenant Name, to perform query within a Tenant's scope.
	// This is an optional field, specified by user. In the backend
	// this field gets auto-filled & validated by apigw-hook based on
	// user login context.
	Tenant string `protobuf:"bytes,1,opt,name=Tenant,json=tenant,omitempty,proto3" json:"tenant,omitempty"`
	// SGPolicy name is optional. If provided policy-search will
	// be limited to the specified SGpolicy object.
	SGPolicy string `protobuf:"bytes,2,opt,name=SGPolicy,json=sg-policy,omitempty,proto3" json:"sg-policy,omitempty"`
	// App specification, proto/port format, or predefined apps and alg config
	App string `protobuf:"bytes,3,opt,name=App,json=app,omitempty,proto3" json:"app,omitempty"`
	// Inbound ip-address/ip-mask/ip-range. Use any to refer to all ipaddresses
	FromIPAddress string `protobuf:"bytes,4,opt,name=FromIPAddress,json=from-ip-address,omitempty,proto3" json:"from-ip-address,omitempty"`
	// Outbound ip-address/ip-mask/ip-range. Use any to refer to all ipaddresses
	ToIPAddress string `protobuf:"bytes,5,opt,name=ToIPAddress,json=to-ip-address,omitempty,proto3" json:"to-ip-address,omitempty"`
	// Inbound security group
	FromSecurityGroup string `protobuf:"bytes,6,opt,name=FromSecurityGroup,json=from-security-group,omitempty,proto3" json:"from-security-group,omitempty"`
	// Outbound security group
	ToSecurityGroup string `protobuf:"bytes,7,opt,name=ToSecurityGroup,json=to-security-group,omitempty,proto3" json:"to-security-group,omitempty"`
}

func (m *PolicySearchRequest) Reset()                    { *m = PolicySearchRequest{} }
func (m *PolicySearchRequest) String() string            { return proto.CompactTextString(m) }
func (*PolicySearchRequest) ProtoMessage()               {}
func (*PolicySearchRequest) Descriptor() ([]byte, []int) { return fileDescriptorSearch, []int{9} }

func (m *PolicySearchRequest) GetTenant() string {
	if m != nil {
		return m.Tenant
	}
	return ""
}

func (m *PolicySearchRequest) GetSGPolicy() string {
	if m != nil {
		return m.SGPolicy
	}
	return ""
}

func (m *PolicySearchRequest) GetApp() string {
	if m != nil {
		return m.App
	}
	return ""
}

func (m *PolicySearchRequest) GetFromIPAddress() string {
	if m != nil {
		return m.FromIPAddress
	}
	return ""
}

func (m *PolicySearchRequest) GetToIPAddress() string {
	if m != nil {
		return m.ToIPAddress
	}
	return ""
}

func (m *PolicySearchRequest) GetFromSecurityGroup() string {
	if m != nil {
		return m.FromSecurityGroup
	}
	return ""
}

func (m *PolicySearchRequest) GetToSecurityGroup() string {
	if m != nil {
		return m.ToSecurityGroup
	}
	return ""
}

// PolicySearchResponse is response to the security/firewall policy search request
type PolicySearchResponse struct {
	// Status of firewall policy search
	Status string `protobuf:"bytes,1,opt,name=Status,json=status,omitempty,proto3" json:"status,omitempty"`
	// Matching SG policy name if there is a MATCH
	SGPolicy string `protobuf:"bytes,2,opt,name=SGPolicy,json=sg-policy,omitempty,proto3" json:"sg-policy,omitempty"`
	// Matching SG rule if there is a MATCH
	Rule *security.SGRule `protobuf:"bytes,3,opt,name=Rule,json=rule,omitempty" json:"rule,omitempty"`
	// Index of the matching SG rule if there is a MATCH
	Index uint32 `protobuf:"varint,4,opt,name=Index,json=index,omitempty,proto3" json:"index,omitempty"`
}

func (m *PolicySearchResponse) Reset()                    { *m = PolicySearchResponse{} }
func (m *PolicySearchResponse) String() string            { return proto.CompactTextString(m) }
func (*PolicySearchResponse) ProtoMessage()               {}
func (*PolicySearchResponse) Descriptor() ([]byte, []int) { return fileDescriptorSearch, []int{10} }

func (m *PolicySearchResponse) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *PolicySearchResponse) GetSGPolicy() string {
	if m != nil {
		return m.SGPolicy
	}
	return ""
}

func (m *PolicySearchResponse) GetRule() *security.SGRule {
	if m != nil {
		return m.Rule
	}
	return nil
}

func (m *PolicySearchResponse) GetIndex() uint32 {
	if m != nil {
		return m.Index
	}
	return 0
}

//
type SearchQuery struct {
	// OR of Text-requirements to be matched, Exclude is not supported for Text search
	Texts []*TextRequirement `protobuf:"bytes,1,rep,name=Texts,json=texts,omitempty" json:"texts,omitempty"`
	// OR of Categories to be matched, AND and Exclude are not supported for this type
	// The max category string length is 64 bytes
	Categories []string `protobuf:"bytes,2,rep,name=Categories,json=categories,omitempty" json:"categories,omitempty"`
	// OR of Kinds to be matched, AND and Exclude are not supported for this type
	// The max kind string length is 64 bytes
	Kinds []string `protobuf:"bytes,3,rep,name=Kinds,json=kinds,omitempty" json:"kinds,omitempty"`
	// Field Selector is AND of field.Requirements
	Fields *fields.Selector `protobuf:"bytes,4,opt,name=Fields,json=fields,omitempty" json:"fields,omitempty"`
	// Label Selector is AND of label.Requirememts
	Labels *labels.Selector `protobuf:"bytes,5,opt,name=Labels,json=labels,omitempty" json:"labels,omitempty"`
}

func (m *SearchQuery) Reset()                    { *m = SearchQuery{} }
func (m *SearchQuery) String() string            { return proto.CompactTextString(m) }
func (*SearchQuery) ProtoMessage()               {}
func (*SearchQuery) Descriptor() ([]byte, []int) { return fileDescriptorSearch, []int{11} }

func (m *SearchQuery) GetTexts() []*TextRequirement {
	if m != nil {
		return m.Texts
	}
	return nil
}

func (m *SearchQuery) GetCategories() []string {
	if m != nil {
		return m.Categories
	}
	return nil
}

func (m *SearchQuery) GetKinds() []string {
	if m != nil {
		return m.Kinds
	}
	return nil
}

func (m *SearchQuery) GetFields() *fields.Selector {
	if m != nil {
		return m.Fields
	}
	return nil
}

func (m *SearchQuery) GetLabels() *labels.Selector {
	if m != nil {
		return m.Labels
	}
	return nil
}

// SearchRequest is the input to the search API
//
// Simple queries can be specified as URI param using "QueryString".
// For advanced queries, it is recommended to use the "SearchQuery" structure
// and specify them in BODY of the GET/POST method.
//
// Examples of search query in query-string format:
//
//  1. Find all occurrences matching text “Network”
//     Network
//  2. Find all occurrences matching phrase “link down”
//     “link down”
//  3. Find all occurrences matching text production OR "staging"
//     production staging
//  4. Find all occurrences matching text “Network” AND "link down"
//     Network,"link down"
//     Network AND "link down"
//  5. Find all config objects with label1=foo
//     category:config label:label1=foo
//  6. Find all objects created on or after certain date+time
//     category:config field:meta.created-time>=”date-time-string”
//  7. Find all Network objects with type=vlan
//     kind:Network field:spec.type=vlan
//  8. Find all Naples nodes with admission-phase = pending or rejected
//     kind:SmartNIC field:spec.phase in (pending, rejected)
//  9. Find all events with text matching “disconnected”
//     category:events disconnected
// 10. Find all Critical events for Network objects
//     category:events kind:Network field:severity=CRITICAL
// 11. Find all Alerts generated from Naples MAC1
//     category:alerts field:status.source.node=MAC1
//     category:alerts MAC1
// 12. Find all Naples nodes with metric filter : mem>90 && cpu>90
//     category:metrics kind:SmartNIC field:metric.mem>90,metric.cpu>90
// 13. Find all Endpoints with label Tier=Web with counter1>=100
//     category:metrics kind:Endpoint label:Tier=Web field:metric.counter1 > 100
// 14. Find all Endpoints objects with label target=prod with crc-error-count != 0
//     category:metrics kind:Endpoint label:target=prod field:status.crc-error-count!=0
// 15. Find all occurences matching the words and phrase in a certain category & kinds with certain field and label match
//     production "status down" category:Network kind:Network,Service field:spec.service-type=external label:tier=web
//
type SearchRequest struct {
	// Simple query string
	// This can be specified as URI parameter.
	// For advanced query cases, Users should use specify SearchQuery
	// and pass the SearchRequest in a GET/POST Body
	// The max query-string length is 256 bytes
	QueryString string `protobuf:"bytes,1,opt,name=QueryString,json=query-string,omitempty,proto3" json:"query-string,omitempty"`
	// From represents the start offset (zero based), used in paginated search requests
	// The results returned would be in the range [From ... From+MaxResults-1]
	// This can be specified as URI parameter.
	// Default value is 0 and valid range is 0..1023
	From int32 `protobuf:"varint,2,opt,name=From,json=from,omitempty,proto3" json:"from,omitempty"`
	// MaxResults is the max-count of search results
	// This can be specified as URI parameter.
	// Default value is 10 and valid range is 0..8192
	MaxResults int32 `protobuf:"varint,3,opt,name=MaxResults,json=max-results,omitempty,proto3" json:"max-results,omitempty"`
	// SortyBy is an optional parameter and contains the field name
	// to be sorted by, For eg: "meta.name"
	// This can be specified as URI parameter.
	SortBy string `protobuf:"bytes,4,opt,name=SortBy,json=sort-by,omitempty,proto3" json:"sort-by,omitempty"`
	// Query Mode
	Mode string `protobuf:"bytes,5,opt,name=Mode,json=mode,omitempty,proto3" json:"mode,omitempty"`
	// Search query contains the search requirements
	// This is intended for advanced query use cases involving
	// boolean query, structured term query and supports various
	// combinations of text, phrase strings and search modifiers
	// for specific categories, kinds, fields and labels.
	// This cannot be specified as URI parameter.
	Query *SearchQuery `protobuf:"bytes,6,opt,name=Query,json=query,omitempty" json:"query,omitempty"`
}

func (m *SearchRequest) Reset()                    { *m = SearchRequest{} }
func (m *SearchRequest) String() string            { return proto.CompactTextString(m) }
func (*SearchRequest) ProtoMessage()               {}
func (*SearchRequest) Descriptor() ([]byte, []int) { return fileDescriptorSearch, []int{12} }

func (m *SearchRequest) GetQueryString() string {
	if m != nil {
		return m.QueryString
	}
	return ""
}

func (m *SearchRequest) GetFrom() int32 {
	if m != nil {
		return m.From
	}
	return 0
}

func (m *SearchRequest) GetMaxResults() int32 {
	if m != nil {
		return m.MaxResults
	}
	return 0
}

func (m *SearchRequest) GetSortBy() string {
	if m != nil {
		return m.SortBy
	}
	return ""
}

func (m *SearchRequest) GetMode() string {
	if m != nil {
		return m.Mode
	}
	return ""
}

func (m *SearchRequest) GetQuery() *SearchQuery {
	if m != nil {
		return m.Query
	}
	return nil
}

// SearchResponse is the output provided by the search API
// Based on the search request, search results would be part
// of one of the entities : Entries or NestedAggregation.
// In case of failures, Error would indicate the error status and
// description.
type SearchResponse struct {
	// TotalHits indicates total number of hits matched
	TotalHits int64 `protobuf:"varint,3,opt,name=TotalHits,json=total-hits,omitempty,proto3" json:"total-hits,omitempty"`
	// ActualHits indicates the actual hits returned in this response
	ActualHits int64 `protobuf:"varint,4,opt,name=ActualHits,json=actual-hits,omitempty,proto3" json:"actual-hits,omitempty"`
	// TimeTakenMsecs is the time taken for search response in millisecs
	TimeTakenMsecs int64 `protobuf:"varint,5,opt,name=TimeTakenMsecs,json=time-taken-msecs,omitempty,proto3" json:"time-taken-msecs,omitempty"`
	// Error status for failures
	Error *Error `protobuf:"bytes,6,opt,name=Error,json=error,omitempty" json:"error,omitempty"`
	// EntryList is list of all search results with no grouping.
	// This attribute is populated and valid only in Full request-mode
	Entries []*Entry `protobuf:"bytes,7,rep,name=Entries,json=entries,omitempty" json:"entries,omitempty"`
	// PreviewEntries is a three level grouping of search summary (#hits),
	// grouped by tenant, category and kind in that order. This attribute
	// is populated and valid only in Preview request-mode
	PreviewEntries *TenantPreview `protobuf:"bytes,8,opt,name=PreviewEntries,json=preview-entries,omitempty" json:"preview-entries,omitempty"`
	// AggregatedEntries is a three level grouping of full search results,
	// Grouped by tenant, category and kind in that order. This attribute
	// is populated and valid only in Full request-mode
	AggregatedEntries *TenantAggregation `protobuf:"bytes,9,opt,name=AggregatedEntries,json=aggregated-entries,omitempty" json:"aggregated-entries,omitempty"`
}

func (m *SearchResponse) Reset()                    { *m = SearchResponse{} }
func (m *SearchResponse) String() string            { return proto.CompactTextString(m) }
func (*SearchResponse) ProtoMessage()               {}
func (*SearchResponse) Descriptor() ([]byte, []int) { return fileDescriptorSearch, []int{13} }

func (m *SearchResponse) GetTotalHits() int64 {
	if m != nil {
		return m.TotalHits
	}
	return 0
}

func (m *SearchResponse) GetActualHits() int64 {
	if m != nil {
		return m.ActualHits
	}
	return 0
}

func (m *SearchResponse) GetTimeTakenMsecs() int64 {
	if m != nil {
		return m.TimeTakenMsecs
	}
	return 0
}

func (m *SearchResponse) GetError() *Error {
	if m != nil {
		return m.Error
	}
	return nil
}

func (m *SearchResponse) GetEntries() []*Entry {
	if m != nil {
		return m.Entries
	}
	return nil
}

func (m *SearchResponse) GetPreviewEntries() *TenantPreview {
	if m != nil {
		return m.PreviewEntries
	}
	return nil
}

func (m *SearchResponse) GetAggregatedEntries() *TenantAggregation {
	if m != nil {
		return m.AggregatedEntries
	}
	return nil
}

// TenantAggregation contains map of search result entries
// grouped by three levels: first by Tenant, second by Category
// and finally by Kind.
type TenantAggregation struct {
	//
	Tenants map[string]*CategoryAggregation `protobuf:"bytes,1,rep,name=Tenants,json=tenants,omitempty" json:"tenants,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *TenantAggregation) Reset()                    { *m = TenantAggregation{} }
func (m *TenantAggregation) String() string            { return proto.CompactTextString(m) }
func (*TenantAggregation) ProtoMessage()               {}
func (*TenantAggregation) Descriptor() ([]byte, []int) { return fileDescriptorSearch, []int{14} }

func (m *TenantAggregation) GetTenants() map[string]*CategoryAggregation {
	if m != nil {
		return m.Tenants
	}
	return nil
}

// TenantPreview contains map of search summary (#hits)
// grouped by three levels: first by Tenant, second by Category
// and finally by Kind.
type TenantPreview struct {
	//
	Tenants map[string]*CategoryPreview `protobuf:"bytes,1,rep,name=Tenants,json=tenants,omitempty" json:"tenants,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *TenantPreview) Reset()                    { *m = TenantPreview{} }
func (m *TenantPreview) String() string            { return proto.CompactTextString(m) }
func (*TenantPreview) ProtoMessage()               {}
func (*TenantPreview) Descriptor() ([]byte, []int) { return fileDescriptorSearch, []int{15} }

func (m *TenantPreview) GetTenants() map[string]*CategoryPreview {
	if m != nil {
		return m.Tenants
	}
	return nil
}

// TextRequirement is AND of text-strings in the list
// It is comprised of words or phrases for text search support.
// If a text-string has space separated multi-word, it will be
// interpreted as a phrase.
//
// In the example below :
// - "link down" will be a phrase query
// - network, production, staging will be a word query
//
// For eg:
//    network                      (match network)
//    link down                    (match "link down" phrase)
//    network,production           (match network AND production)
//    network,link down,staging    (match network AND "link down" AND staging)
//
type TextRequirement struct {
	// AND of words or phrases to be matched
	// The max text-string length is 256 bytes
	Text []string `protobuf:"bytes,1,rep,name=Text,json=text,omitempty" json:"text,omitempty"`
}

func (m *TextRequirement) Reset()                    { *m = TextRequirement{} }
func (m *TextRequirement) String() string            { return proto.CompactTextString(m) }
func (*TextRequirement) ProtoMessage()               {}
func (*TextRequirement) Descriptor() ([]byte, []int) { return fileDescriptorSearch, []int{16} }

func (m *TextRequirement) GetText() []string {
	if m != nil {
		return m.Text
	}
	return nil
}

func init() {
	proto.RegisterType((*Category)(nil), "search.Category")
	proto.RegisterType((*CategoryAggregation)(nil), "search.CategoryAggregation")
	proto.RegisterType((*CategoryPreview)(nil), "search.CategoryPreview")
	proto.RegisterType((*Entry)(nil), "search.Entry")
	proto.RegisterType((*EntryList)(nil), "search.EntryList")
	proto.RegisterType((*Error)(nil), "search.Error")
	proto.RegisterType((*Kind)(nil), "search.Kind")
	proto.RegisterType((*KindAggregation)(nil), "search.KindAggregation")
	proto.RegisterType((*KindPreview)(nil), "search.KindPreview")
	proto.RegisterType((*PolicySearchRequest)(nil), "search.PolicySearchRequest")
	proto.RegisterType((*PolicySearchResponse)(nil), "search.PolicySearchResponse")
	proto.RegisterType((*SearchQuery)(nil), "search.SearchQuery")
	proto.RegisterType((*SearchRequest)(nil), "search.SearchRequest")
	proto.RegisterType((*SearchResponse)(nil), "search.SearchResponse")
	proto.RegisterType((*TenantAggregation)(nil), "search.TenantAggregation")
	proto.RegisterType((*TenantPreview)(nil), "search.TenantPreview")
	proto.RegisterType((*TextRequirement)(nil), "search.TextRequirement")
	proto.RegisterEnum("search.Category_Type", Category_Type_name, Category_Type_value)
	proto.RegisterEnum("search.Kind_Type", Kind_Type_name, Kind_Type_value)
	proto.RegisterEnum("search.PolicySearchResponse_MatchStatus", PolicySearchResponse_MatchStatus_name, PolicySearchResponse_MatchStatus_value)
	proto.RegisterEnum("search.SearchRequest_RequestMode", SearchRequest_RequestMode_name, SearchRequest_RequestMode_value)
}
func (m *Category) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Category) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *CategoryAggregation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CategoryAggregation) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Categories) > 0 {
		for k, _ := range m.Categories {
			dAtA[i] = 0xa
			i++
			v := m.Categories[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovSearch(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovSearch(uint64(len(k))) + msgSize
			i = encodeVarintSearch(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintSearch(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintSearch(dAtA, i, uint64(v.Size()))
				n1, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n1
			}
		}
	}
	return i, nil
}

func (m *CategoryPreview) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CategoryPreview) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Categories) > 0 {
		for k, _ := range m.Categories {
			dAtA[i] = 0xa
			i++
			v := m.Categories[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovSearch(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovSearch(uint64(len(k))) + msgSize
			i = encodeVarintSearch(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintSearch(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintSearch(dAtA, i, uint64(v.Size()))
				n2, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n2
			}
		}
	}
	return i, nil
}

func (m *Entry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Entry) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintSearch(dAtA, i, uint64(m.TypeMeta.Size()))
	n3, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n3
	dAtA[i] = 0x12
	i++
	i = encodeVarintSearch(dAtA, i, uint64(m.ObjectMeta.Size()))
	n4, err := m.ObjectMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n4
	return i, nil
}

func (m *EntryList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EntryList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Entries) > 0 {
		for _, msg := range m.Entries {
			dAtA[i] = 0xa
			i++
			i = encodeVarintSearch(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Error) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Error) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSearch(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.Reason) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSearch(dAtA, i, uint64(len(m.Reason)))
		i += copy(dAtA[i:], m.Reason)
	}
	return i, nil
}

func (m *Kind) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Kind) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *KindAggregation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KindAggregation) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Kinds) > 0 {
		for k, _ := range m.Kinds {
			dAtA[i] = 0xa
			i++
			v := m.Kinds[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovSearch(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovSearch(uint64(len(k))) + msgSize
			i = encodeVarintSearch(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintSearch(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintSearch(dAtA, i, uint64(v.Size()))
				n5, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n5
			}
		}
	}
	return i, nil
}

func (m *KindPreview) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KindPreview) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Kinds) > 0 {
		for k, _ := range m.Kinds {
			dAtA[i] = 0xa
			i++
			v := m.Kinds[k]
			mapSize := 1 + len(k) + sovSearch(uint64(len(k))) + 1 + sovSearch(uint64(v))
			i = encodeVarintSearch(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintSearch(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x10
			i++
			i = encodeVarintSearch(dAtA, i, uint64(v))
		}
	}
	return i, nil
}

func (m *PolicySearchRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PolicySearchRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Tenant) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSearch(dAtA, i, uint64(len(m.Tenant)))
		i += copy(dAtA[i:], m.Tenant)
	}
	if len(m.SGPolicy) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSearch(dAtA, i, uint64(len(m.SGPolicy)))
		i += copy(dAtA[i:], m.SGPolicy)
	}
	if len(m.App) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSearch(dAtA, i, uint64(len(m.App)))
		i += copy(dAtA[i:], m.App)
	}
	if len(m.FromIPAddress) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintSearch(dAtA, i, uint64(len(m.FromIPAddress)))
		i += copy(dAtA[i:], m.FromIPAddress)
	}
	if len(m.ToIPAddress) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintSearch(dAtA, i, uint64(len(m.ToIPAddress)))
		i += copy(dAtA[i:], m.ToIPAddress)
	}
	if len(m.FromSecurityGroup) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintSearch(dAtA, i, uint64(len(m.FromSecurityGroup)))
		i += copy(dAtA[i:], m.FromSecurityGroup)
	}
	if len(m.ToSecurityGroup) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintSearch(dAtA, i, uint64(len(m.ToSecurityGroup)))
		i += copy(dAtA[i:], m.ToSecurityGroup)
	}
	return i, nil
}

func (m *PolicySearchResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PolicySearchResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Status) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSearch(dAtA, i, uint64(len(m.Status)))
		i += copy(dAtA[i:], m.Status)
	}
	if len(m.SGPolicy) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSearch(dAtA, i, uint64(len(m.SGPolicy)))
		i += copy(dAtA[i:], m.SGPolicy)
	}
	if m.Rule != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSearch(dAtA, i, uint64(m.Rule.Size()))
		n6, err := m.Rule.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.Index != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintSearch(dAtA, i, uint64(m.Index))
	}
	return i, nil
}

func (m *SearchQuery) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchQuery) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Texts) > 0 {
		for _, msg := range m.Texts {
			dAtA[i] = 0xa
			i++
			i = encodeVarintSearch(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Categories) > 0 {
		for _, s := range m.Categories {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Kinds) > 0 {
		for _, s := range m.Kinds {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.Fields != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintSearch(dAtA, i, uint64(m.Fields.Size()))
		n7, err := m.Fields.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.Labels != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintSearch(dAtA, i, uint64(m.Labels.Size()))
		n8, err := m.Labels.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	return i, nil
}

func (m *SearchRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.QueryString) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSearch(dAtA, i, uint64(len(m.QueryString)))
		i += copy(dAtA[i:], m.QueryString)
	}
	if m.From != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintSearch(dAtA, i, uint64(m.From))
	}
	if m.MaxResults != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintSearch(dAtA, i, uint64(m.MaxResults))
	}
	if len(m.SortBy) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintSearch(dAtA, i, uint64(len(m.SortBy)))
		i += copy(dAtA[i:], m.SortBy)
	}
	if len(m.Mode) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintSearch(dAtA, i, uint64(len(m.Mode)))
		i += copy(dAtA[i:], m.Mode)
	}
	if m.Query != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintSearch(dAtA, i, uint64(m.Query.Size()))
		n9, err := m.Query.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	return i, nil
}

func (m *SearchResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TotalHits != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintSearch(dAtA, i, uint64(m.TotalHits))
	}
	if m.ActualHits != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintSearch(dAtA, i, uint64(m.ActualHits))
	}
	if m.TimeTakenMsecs != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintSearch(dAtA, i, uint64(m.TimeTakenMsecs))
	}
	if m.Error != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintSearch(dAtA, i, uint64(m.Error.Size()))
		n10, err := m.Error.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if len(m.Entries) > 0 {
		for _, msg := range m.Entries {
			dAtA[i] = 0x3a
			i++
			i = encodeVarintSearch(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.PreviewEntries != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintSearch(dAtA, i, uint64(m.PreviewEntries.Size()))
		n11, err := m.PreviewEntries.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if m.AggregatedEntries != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintSearch(dAtA, i, uint64(m.AggregatedEntries.Size()))
		n12, err := m.AggregatedEntries.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	return i, nil
}

func (m *TenantAggregation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TenantAggregation) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Tenants) > 0 {
		for k, _ := range m.Tenants {
			dAtA[i] = 0xa
			i++
			v := m.Tenants[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovSearch(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovSearch(uint64(len(k))) + msgSize
			i = encodeVarintSearch(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintSearch(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintSearch(dAtA, i, uint64(v.Size()))
				n13, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n13
			}
		}
	}
	return i, nil
}

func (m *TenantPreview) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TenantPreview) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Tenants) > 0 {
		for k, _ := range m.Tenants {
			dAtA[i] = 0xa
			i++
			v := m.Tenants[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovSearch(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovSearch(uint64(len(k))) + msgSize
			i = encodeVarintSearch(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintSearch(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintSearch(dAtA, i, uint64(v.Size()))
				n14, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n14
			}
		}
	}
	return i, nil
}

func (m *TextRequirement) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TextRequirement) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Text) > 0 {
		for _, s := range m.Text {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func encodeVarintSearch(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Category) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *CategoryAggregation) Size() (n int) {
	var l int
	_ = l
	if len(m.Categories) > 0 {
		for k, v := range m.Categories {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovSearch(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovSearch(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovSearch(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *CategoryPreview) Size() (n int) {
	var l int
	_ = l
	if len(m.Categories) > 0 {
		for k, v := range m.Categories {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovSearch(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovSearch(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovSearch(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *Entry) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovSearch(uint64(l))
	l = m.ObjectMeta.Size()
	n += 1 + l + sovSearch(uint64(l))
	return n
}

func (m *EntryList) Size() (n int) {
	var l int
	_ = l
	if len(m.Entries) > 0 {
		for _, e := range m.Entries {
			l = e.Size()
			n += 1 + l + sovSearch(uint64(l))
		}
	}
	return n
}

func (m *Error) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovSearch(uint64(l))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovSearch(uint64(l))
	}
	return n
}

func (m *Kind) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *KindAggregation) Size() (n int) {
	var l int
	_ = l
	if len(m.Kinds) > 0 {
		for k, v := range m.Kinds {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovSearch(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovSearch(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovSearch(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *KindPreview) Size() (n int) {
	var l int
	_ = l
	if len(m.Kinds) > 0 {
		for k, v := range m.Kinds {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovSearch(uint64(len(k))) + 1 + sovSearch(uint64(v))
			n += mapEntrySize + 1 + sovSearch(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *PolicySearchRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Tenant)
	if l > 0 {
		n += 1 + l + sovSearch(uint64(l))
	}
	l = len(m.SGPolicy)
	if l > 0 {
		n += 1 + l + sovSearch(uint64(l))
	}
	l = len(m.App)
	if l > 0 {
		n += 1 + l + sovSearch(uint64(l))
	}
	l = len(m.FromIPAddress)
	if l > 0 {
		n += 1 + l + sovSearch(uint64(l))
	}
	l = len(m.ToIPAddress)
	if l > 0 {
		n += 1 + l + sovSearch(uint64(l))
	}
	l = len(m.FromSecurityGroup)
	if l > 0 {
		n += 1 + l + sovSearch(uint64(l))
	}
	l = len(m.ToSecurityGroup)
	if l > 0 {
		n += 1 + l + sovSearch(uint64(l))
	}
	return n
}

func (m *PolicySearchResponse) Size() (n int) {
	var l int
	_ = l
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovSearch(uint64(l))
	}
	l = len(m.SGPolicy)
	if l > 0 {
		n += 1 + l + sovSearch(uint64(l))
	}
	if m.Rule != nil {
		l = m.Rule.Size()
		n += 1 + l + sovSearch(uint64(l))
	}
	if m.Index != 0 {
		n += 1 + sovSearch(uint64(m.Index))
	}
	return n
}

func (m *SearchQuery) Size() (n int) {
	var l int
	_ = l
	if len(m.Texts) > 0 {
		for _, e := range m.Texts {
			l = e.Size()
			n += 1 + l + sovSearch(uint64(l))
		}
	}
	if len(m.Categories) > 0 {
		for _, s := range m.Categories {
			l = len(s)
			n += 1 + l + sovSearch(uint64(l))
		}
	}
	if len(m.Kinds) > 0 {
		for _, s := range m.Kinds {
			l = len(s)
			n += 1 + l + sovSearch(uint64(l))
		}
	}
	if m.Fields != nil {
		l = m.Fields.Size()
		n += 1 + l + sovSearch(uint64(l))
	}
	if m.Labels != nil {
		l = m.Labels.Size()
		n += 1 + l + sovSearch(uint64(l))
	}
	return n
}

func (m *SearchRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.QueryString)
	if l > 0 {
		n += 1 + l + sovSearch(uint64(l))
	}
	if m.From != 0 {
		n += 1 + sovSearch(uint64(m.From))
	}
	if m.MaxResults != 0 {
		n += 1 + sovSearch(uint64(m.MaxResults))
	}
	l = len(m.SortBy)
	if l > 0 {
		n += 1 + l + sovSearch(uint64(l))
	}
	l = len(m.Mode)
	if l > 0 {
		n += 1 + l + sovSearch(uint64(l))
	}
	if m.Query != nil {
		l = m.Query.Size()
		n += 1 + l + sovSearch(uint64(l))
	}
	return n
}

func (m *SearchResponse) Size() (n int) {
	var l int
	_ = l
	if m.TotalHits != 0 {
		n += 1 + sovSearch(uint64(m.TotalHits))
	}
	if m.ActualHits != 0 {
		n += 1 + sovSearch(uint64(m.ActualHits))
	}
	if m.TimeTakenMsecs != 0 {
		n += 1 + sovSearch(uint64(m.TimeTakenMsecs))
	}
	if m.Error != nil {
		l = m.Error.Size()
		n += 1 + l + sovSearch(uint64(l))
	}
	if len(m.Entries) > 0 {
		for _, e := range m.Entries {
			l = e.Size()
			n += 1 + l + sovSearch(uint64(l))
		}
	}
	if m.PreviewEntries != nil {
		l = m.PreviewEntries.Size()
		n += 1 + l + sovSearch(uint64(l))
	}
	if m.AggregatedEntries != nil {
		l = m.AggregatedEntries.Size()
		n += 1 + l + sovSearch(uint64(l))
	}
	return n
}

func (m *TenantAggregation) Size() (n int) {
	var l int
	_ = l
	if len(m.Tenants) > 0 {
		for k, v := range m.Tenants {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovSearch(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovSearch(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovSearch(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *TenantPreview) Size() (n int) {
	var l int
	_ = l
	if len(m.Tenants) > 0 {
		for k, v := range m.Tenants {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovSearch(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovSearch(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovSearch(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *TextRequirement) Size() (n int) {
	var l int
	_ = l
	if len(m.Text) > 0 {
		for _, s := range m.Text {
			l = len(s)
			n += 1 + l + sovSearch(uint64(l))
		}
	}
	return n
}

func sovSearch(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozSearch(x uint64) (n int) {
	return sovSearch(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Category) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSearch
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Category: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Category: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipSearch(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSearch
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CategoryAggregation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSearch
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CategoryAggregation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CategoryAggregation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Categories", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSearch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSearch
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Categories == nil {
				m.Categories = make(map[string]*KindAggregation)
			}
			var mapkey string
			var mapvalue *KindAggregation
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSearch
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSearch
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthSearch
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSearch
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthSearch
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthSearch
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &KindAggregation{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipSearch(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthSearch
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Categories[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSearch(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSearch
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CategoryPreview) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSearch
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CategoryPreview: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CategoryPreview: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Categories", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSearch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSearch
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Categories == nil {
				m.Categories = make(map[string]*KindPreview)
			}
			var mapkey string
			var mapvalue *KindPreview
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSearch
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSearch
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthSearch
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSearch
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthSearch
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthSearch
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &KindPreview{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipSearch(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthSearch
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Categories[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSearch(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSearch
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Entry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSearch
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Entry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Entry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSearch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSearch
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSearch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSearch
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSearch(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSearch
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EntryList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSearch
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EntryList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EntryList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSearch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSearch
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entries = append(m.Entries, &Entry{})
			if err := m.Entries[len(m.Entries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSearch(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSearch
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Error) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSearch
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Error: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Error: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSearch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSearch
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSearch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSearch
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSearch(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSearch
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Kind) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSearch
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Kind: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Kind: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipSearch(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSearch
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KindAggregation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSearch
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KindAggregation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KindAggregation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kinds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSearch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSearch
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Kinds == nil {
				m.Kinds = make(map[string]*EntryList)
			}
			var mapkey string
			var mapvalue *EntryList
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSearch
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSearch
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthSearch
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSearch
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthSearch
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthSearch
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &EntryList{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipSearch(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthSearch
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Kinds[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSearch(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSearch
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KindPreview) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSearch
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KindPreview: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KindPreview: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kinds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSearch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSearch
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Kinds == nil {
				m.Kinds = make(map[string]int64)
			}
			var mapkey string
			var mapvalue int64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSearch
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSearch
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthSearch
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSearch
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipSearch(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthSearch
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Kinds[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSearch(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSearch
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PolicySearchRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSearch
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PolicySearchRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PolicySearchRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tenant", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSearch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSearch
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tenant = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SGPolicy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSearch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSearch
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SGPolicy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field App", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSearch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSearch
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.App = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromIPAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSearch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSearch
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FromIPAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToIPAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSearch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSearch
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ToIPAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromSecurityGroup", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSearch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSearch
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FromSecurityGroup = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToSecurityGroup", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSearch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSearch
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ToSecurityGroup = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSearch(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSearch
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PolicySearchResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSearch
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PolicySearchResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PolicySearchResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSearch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSearch
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SGPolicy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSearch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSearch
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SGPolicy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rule", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSearch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSearch
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Rule == nil {
				m.Rule = &security.SGRule{}
			}
			if err := m.Rule.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSearch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSearch(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSearch
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchQuery) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSearch
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchQuery: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchQuery: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Texts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSearch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSearch
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Texts = append(m.Texts, &TextRequirement{})
			if err := m.Texts[len(m.Texts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Categories", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSearch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSearch
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Categories = append(m.Categories, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kinds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSearch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSearch
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kinds = append(m.Kinds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fields", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSearch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSearch
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Fields == nil {
				m.Fields = &fields.Selector{}
			}
			if err := m.Fields.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSearch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSearch
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = &labels.Selector{}
			}
			if err := m.Labels.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSearch(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSearch
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSearch
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueryString", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSearch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSearch
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QueryString = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			m.From = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSearch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.From |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxResults", wireType)
			}
			m.MaxResults = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSearch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxResults |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SortBy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSearch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSearch
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SortBy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSearch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSearch
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSearch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSearch
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Query == nil {
				m.Query = &SearchQuery{}
			}
			if err := m.Query.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSearch(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSearch
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSearch
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalHits", wireType)
			}
			m.TotalHits = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSearch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalHits |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActualHits", wireType)
			}
			m.ActualHits = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSearch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ActualHits |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeTakenMsecs", wireType)
			}
			m.TimeTakenMsecs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSearch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimeTakenMsecs |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSearch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSearch
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Error == nil {
				m.Error = &Error{}
			}
			if err := m.Error.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSearch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSearch
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entries = append(m.Entries, &Entry{})
			if err := m.Entries[len(m.Entries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreviewEntries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSearch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSearch
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PreviewEntries == nil {
				m.PreviewEntries = &TenantPreview{}
			}
			if err := m.PreviewEntries.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AggregatedEntries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSearch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSearch
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AggregatedEntries == nil {
				m.AggregatedEntries = &TenantAggregation{}
			}
			if err := m.AggregatedEntries.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSearch(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSearch
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TenantAggregation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSearch
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TenantAggregation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TenantAggregation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tenants", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSearch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSearch
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tenants == nil {
				m.Tenants = make(map[string]*CategoryAggregation)
			}
			var mapkey string
			var mapvalue *CategoryAggregation
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSearch
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSearch
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthSearch
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSearch
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthSearch
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthSearch
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &CategoryAggregation{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipSearch(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthSearch
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Tenants[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSearch(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSearch
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TenantPreview) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSearch
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TenantPreview: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TenantPreview: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tenants", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSearch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSearch
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tenants == nil {
				m.Tenants = make(map[string]*CategoryPreview)
			}
			var mapkey string
			var mapvalue *CategoryPreview
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSearch
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSearch
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthSearch
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSearch
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthSearch
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthSearch
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &CategoryPreview{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipSearch(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthSearch
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Tenants[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSearch(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSearch
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TextRequirement) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSearch
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TextRequirement: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TextRequirement: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSearch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSearch
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Text = append(m.Text, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSearch(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSearch
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipSearch(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowSearch
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSearch
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSearch
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthSearch
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowSearch
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipSearch(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthSearch = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowSearch   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("search.proto", fileDescriptorSearch) }

var fileDescriptorSearch = []byte{
	// 1924 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x58, 0x4f, 0x53, 0x1b, 0xc9,
	0x15, 0xdf, 0x41, 0x7f, 0x40, 0x2d, 0x04, 0x43, 0x83, 0x8d, 0x04, 0x0e, 0x38, 0xb3, 0xbb, 0x5e,
	0xa8, 0xb5, 0x24, 0xc0, 0x89, 0xe3, 0xdd, 0x53, 0x24, 0x0c, 0x36, 0xb5, 0xc8, 0xeb, 0x48, 0x4a,
	0x1c, 0x57, 0xaa, 0x36, 0x35, 0x48, 0x8d, 0x98, 0x30, 0x9a, 0x1e, 0x77, 0xf7, 0x00, 0xfa, 0x02,
	0xe4, 0x94, 0x2f, 0x90, 0x53, 0x8e, 0x29, 0x0e, 0x39, 0xe4, 0x94, 0xaa, 0x7c, 0x80, 0xf5, 0xd1,
	0x55, 0xa9, 0xca, 0x91, 0x4a, 0xb9, 0x72, 0xe2, 0x53, 0xa4, 0x5e, 0x4f, 0x0f, 0xea, 0x19, 0x24,
	0xbc, 0x9b, 0xdd, 0x93, 0xa6, 0x7f, 0xfd, 0xde, 0xaf, 0xdf, 0xeb, 0xee, 0xdf, 0x9b, 0x37, 0x42,
	0xd3, 0x9c, 0xd8, 0xac, 0x73, 0x54, 0xf1, 0x19, 0x15, 0x14, 0x67, 0xc3, 0xd1, 0xd2, 0xbd, 0x1e,
	0xa5, 0x3d, 0x97, 0x54, 0x6d, 0xdf, 0xa9, 0xda, 0x9e, 0x47, 0x85, 0x2d, 0x1c, 0xea, 0xf1, 0xd0,
	0x6a, 0x69, 0xa7, 0xe7, 0x88, 0xa3, 0xe0, 0xa0, 0xd2, 0xa1, 0xfd, 0xaa, 0x4f, 0x3c, 0x6e, 0x7b,
	0x5d, 0x5a, 0xe5, 0xa7, 0xd5, 0x13, 0xe2, 0x39, 0x1d, 0x52, 0x0d, 0x84, 0xe3, 0x72, 0x70, 0xed,
	0x11, 0x4f, 0xf7, 0xae, 0x3a, 0x5e, 0xc7, 0x0d, 0xba, 0x24, 0xa2, 0x29, 0x6b, 0x34, 0x3d, 0xda,
	0xa3, 0x55, 0x09, 0x1f, 0x04, 0x87, 0x72, 0x24, 0x07, 0xf2, 0x49, 0x99, 0x7f, 0x3a, 0x66, 0x55,
	0x88, 0xb1, 0x4f, 0x84, 0xad, 0xcc, 0x36, 0x6e, 0x31, 0x3b, 0x74, 0x88, 0xdb, 0xe5, 0x55, 0x4e,
	0x5c, 0xd2, 0x11, 0x94, 0x7d, 0x07, 0x0f, 0xd7, 0x3e, 0x20, 0xee, 0xf7, 0xf2, 0x90, 0x16, 0xbc,
	0xca, 0x7b, 0x3e, 0x75, 0x9d, 0xce, 0x20, 0xf4, 0xb0, 0xfe, 0x6c, 0xa0, 0xa9, 0x6d, 0x5b, 0x90,
	0x1e, 0x65, 0x03, 0xeb, 0x4f, 0x06, 0x4a, 0xb7, 0x07, 0x3e, 0xc1, 0x79, 0x34, 0xb9, 0xed, 0x06,
	0x5c, 0x10, 0x66, 0x7e, 0x84, 0xa7, 0xd1, 0xd4, 0x2b, 0xca, 0x8e, 0x5d, 0x6a, 0x77, 0x4d, 0x03,
	0x46, 0x2d, 0xd2, 0x09, 0x98, 0x23, 0x06, 0xe6, 0x04, 0x9e, 0x42, 0xe9, 0x5a, 0x20, 0x8e, 0xcc,
	0x14, 0xb8, 0xbc, 0x20, 0xe2, 0x94, 0xb2, 0x63, 0x33, 0x8d, 0x67, 0x10, 0x6a, 0x50, 0xcf, 0x11,
	0x94, 0x39, 0x5e, 0xcf, 0xcc, 0xe0, 0x02, 0xca, 0xb5, 0x89, 0x4b, 0xfa, 0x44, 0xb0, 0x81, 0x99,
	0xc5, 0x08, 0x65, 0x77, 0x4e, 0x88, 0x27, 0xb8, 0x39, 0x09, 0xcf, 0x35, 0x97, 0x30, 0xc1, 0xcd,
	0x29, 0x70, 0xab, 0x05, 0x5d, 0x47, 0xb4, 0x99, 0xed, 0xb8, 0x66, 0xce, 0x7a, 0x6f, 0xa0, 0xf9,
	0x28, 0xb8, 0x5a, 0xaf, 0xc7, 0x48, 0x4f, 0x1e, 0x18, 0xe6, 0x08, 0x29, 0xd8, 0x21, 0xbc, 0x68,
	0xdc, 0x4f, 0xad, 0xe5, 0xb7, 0x3e, 0xaf, 0xa8, 0x0b, 0x33, 0xc2, 0xa1, 0x32, 0xb4, 0xde, 0xf1,
	0x04, 0x1b, 0xd4, 0xef, 0xbd, 0xbd, 0x5c, 0x35, 0xae, 0x2e, 0x57, 0x17, 0x3a, 0xd7, 0x13, 0x0f,
	0x69, 0xdf, 0x11, 0xa4, 0xef, 0x8b, 0x41, 0x73, 0x24, 0xba, 0xf4, 0x1b, 0x34, 0x9b, 0xa0, 0xc1,
	0x26, 0x4a, 0x1d, 0x93, 0x41, 0xd1, 0xb8, 0x6f, 0xac, 0xe5, 0x9a, 0xf0, 0x88, 0xcb, 0x28, 0x73,
	0x62, 0xbb, 0x01, 0x29, 0x4e, 0xdc, 0x37, 0xd6, 0xf2, 0x5b, 0x8b, 0x51, 0x50, 0x5f, 0x39, 0x5e,
	0x57, 0x0b, 0xa8, 0x19, 0x5a, 0x7d, 0x39, 0xf1, 0xc4, 0xb0, 0xfe, 0x6d, 0x5c, 0x13, 0x0f, 0x5e,
	0x32, 0x72, 0xe2, 0x90, 0x53, 0x4c, 0x47, 0x24, 0xf8, 0x59, 0x32, 0x41, 0x65, 0xfc, 0xa3, 0x24,
	0xd7, 0xfc, 0x2e, 0xc9, 0xad, 0xc7, 0x93, 0x9b, 0xd7, 0x93, 0x53, 0xc1, 0xe8, 0x89, 0xfd, 0xd1,
	0x40, 0x99, 0x90, 0xea, 0x31, 0x32, 0xda, 0x92, 0x28, 0xbf, 0x55, 0xa8, 0xd8, 0xbe, 0x53, 0x81,
	0x4b, 0xd6, 0x20, 0xc2, 0xae, 0xcf, 0xbf, 0xbd, 0x5c, 0xfd, 0xe8, 0x5d, 0x18, 0xef, 0xe4, 0x43,
	0xc7, 0x73, 0x1d, 0x8f, 0x34, 0xa3, 0x07, 0xbc, 0x8b, 0x8c, 0xaf, 0xd5, 0x62, 0xb3, 0xd2, 0xef,
	0xeb, 0x83, 0x3f, 0x90, 0x8e, 0x90, 0x9e, 0x4b, 0x9a, 0xe7, 0x0c, 0xc8, 0x4c, 0xcb, 0x31, 0x31,
	0xb6, 0x5e, 0xa3, 0x9c, 0x0c, 0x64, 0xdf, 0xe1, 0x02, 0xef, 0xa3, 0x49, 0x18, 0x0c, 0x37, 0xb6,
	0x10, 0xe5, 0x11, 0x6e, 0x5f, 0x49, 0x6d, 0xdf, 0x1c, 0x09, 0xad, 0x34, 0xde, 0x9b, 0x90, 0xf5,
	0x06, 0x65, 0x76, 0x18, 0xa3, 0x0c, 0x6f, 0x84, 0xd2, 0x09, 0xf7, 0xab, 0x8e, 0x21, 0x2a, 0x31,
	0xf0, 0x89, 0x1e, 0x55, 0x7c, 0x8c, 0x1f, 0xa3, 0x6c, 0x93, 0xd8, 0x9c, 0x7a, 0x32, 0xc5, 0x5c,
	0x7d, 0xe1, 0xea, 0x72, 0xd5, 0x64, 0x12, 0xd1, 0xbc, 0x6e, 0x20, 0xd6, 0xbb, 0x14, 0x4a, 0xc3,
	0x96, 0x5b, 0xdf, 0xa6, 0x46, 0xc9, 0x75, 0x0a, 0xa5, 0x5f, 0xd0, 0x2e, 0x51, 0x52, 0xed, 0xdb,
	0x4c, 0xbc, 0xd8, 0xdb, 0x36, 0x27, 0xc0, 0xa8, 0x49, 0x5d, 0x97, 0x06, 0xc2, 0x4c, 0x81, 0xea,
	0xda, 0xc4, 0xb3, 0x3d, 0x61, 0xa6, 0xc1, 0x6c, 0xc7, 0xeb, 0xfa, 0xd4, 0xf1, 0x84, 0x99, 0xc1,
	0x73, 0xa8, 0x10, 0xe9, 0xfb, 0x19, 0xa3, 0x81, 0x6f, 0x66, 0x25, 0x8f, 0xaa, 0x1a, 0xe6, 0x24,
	0x9e, 0x44, 0xa9, 0x9a, 0xef, 0x9b, 0x53, 0x40, 0x58, 0xf3, 0xfd, 0x5f, 0x73, 0xc2, 0xcc, 0x9c,
	0x94, 0x6e, 0x38, 0x78, 0xc6, 0x7c, 0x13, 0xe1, 0x59, 0x94, 0xdf, 0x26, 0x4c, 0x38, 0x87, 0x0e,
	0xdc, 0x37, 0x33, 0x8f, 0x97, 0xd1, 0x62, 0x9b, 0xd9, 0x87, 0x87, 0x4e, 0x67, 0xc7, 0xeb, 0xb0,
	0x81, 0x0f, 0x32, 0x78, 0x19, 0x72, 0x4e, 0x43, 0xcc, 0x92, 0xa7, 0x80, 0x8b, 0x68, 0x01, 0x0a,
	0x0a, 0xf1, 0x04, 0x38, 0x0e, 0x6d, 0x66, 0xc0, 0xa6, 0x49, 0x5d, 0x62, 0xce, 0x02, 0x37, 0x3c,
	0xd5, 0x1d, 0xaf, 0x0b, 0xe5, 0xc5, 0xd4, 0x6b, 0xcf, 0x1c, 0x0c, 0x5a, 0x84, 0x9d, 0x38, 0x1d,
	0x62, 0x62, 0x08, 0x7d, 0xff, 0x40, 0x51, 0xcc, 0xe3, 0x1c, 0xca, 0xc8, 0x5a, 0x63, 0x2e, 0xe0,
	0x05, 0x64, 0xca, 0xc7, 0xa7, 0x84, 0x0b, 0xc7, 0x93, 0x2b, 0x99, 0x77, 0x80, 0x59, 0xa2, 0xca,
	0xe3, 0x2e, 0x78, 0xc8, 0x4a, 0x65, 0x2e, 0xc2, 0x9c, 0x7c, 0x54, 0x73, 0x45, 0x00, 0x5a, 0xc2,
	0x16, 0x5c, 0x01, 0x25, 0xe0, 0xdc, 0x75, 0xe9, 0xe9, 0xce, 0x99, 0x4f, 0xaf, 0x29, 0x96, 0xc0,
	0x6c, 0xf7, 0xd4, 0xa5, 0x3d, 0x05, 0x2c, 0xc3, 0x0e, 0x37, 0x1c, 0xb8, 0x33, 0x2d, 0xc2, 0x39,
	0xac, 0x7b, 0xcf, 0xfa, 0xa7, 0x81, 0x66, 0x13, 0x25, 0x02, 0xff, 0x0e, 0x65, 0x00, 0x8a, 0x6e,
	0xa9, 0x35, 0xa6, 0x94, 0xc8, 0xb1, 0x52, 0xfe, 0xa2, 0xba, 0xba, 0xb3, 0xc7, 0x80, 0x69, 0x97,
	0x28, 0x09, 0x2c, 0x7d, 0x85, 0xd0, 0xd0, 0x6f, 0x84, 0xd4, 0x3f, 0x8b, 0x4b, 0x7d, 0x2e, 0x26,
	0x11, 0x90, 0x91, 0x2e, 0xf4, 0xbf, 0x18, 0x28, 0xaf, 0xd5, 0x00, 0xfc, 0x2a, 0x1e, 0xf9, 0xca,
	0x88, 0x3a, 0xf1, 0xff, 0x45, 0xfd, 0xe4, 0x03, 0x51, 0x2f, 0xe8, 0x51, 0xa7, 0xf4, 0x10, 0xff,
	0x9a, 0x46, 0xf3, 0xe1, 0x01, 0xb4, 0x64, 0x2c, 0x4d, 0xf2, 0x26, 0x20, 0x5c, 0xe0, 0x2f, 0x23,
	0x1d, 0x28, 0xdd, 0x16, 0x55, 0x2c, 0xa6, 0x90, 0xa8, 0xae, 0xc3, 0x24, 0x82, 0xeb, 0x68, 0xaa,
	0xf5, 0x2c, 0x24, 0x55, 0x0a, 0x5e, 0x56, 0xde, 0xf3, 0xbc, 0x57, 0x0e, 0xf5, 0xa2, 0x11, 0x8c,
	0x02, 0xf1, 0xa6, 0x14, 0x53, 0x31, 0x25, 0xdd, 0xef, 0x28, 0xf7, 0x82, 0xed, 0xfb, 0x9a, 0x63,
	0x7c, 0x88, 0x5b, 0xa8, 0xb0, 0xcb, 0x68, 0x7f, 0xef, 0x65, 0xad, 0xdb, 0x65, 0x84, 0xf3, 0x62,
	0x5a, 0x3a, 0xff, 0x54, 0x39, 0x97, 0x0e, 0x19, 0xed, 0x97, 0x1d, 0xbf, 0x6c, 0x87, 0xd3, 0x1a,
	0xd1, 0xf8, 0x29, 0xdc, 0x40, 0xf9, 0x36, 0x1d, 0x52, 0x66, 0x24, 0xe5, 0xaa, 0xa2, 0x5c, 0x14,
	0x74, 0x34, 0xe1, 0xb8, 0x09, 0xfc, 0x7b, 0x34, 0x07, 0x31, 0xc6, 0x0a, 0x49, 0x31, 0x2b, 0x49,
	0x3f, 0x55, 0xa4, 0x3f, 0x91, 0xc1, 0x70, 0x65, 0x51, 0xee, 0x81, 0x89, 0x46, 0x7d, 0xfb, 0x34,
	0x7e, 0x8d, 0x66, 0xdb, 0x34, 0x4e, 0x3f, 0x29, 0xe9, 0x3f, 0x56, 0xf4, 0xcb, 0x82, 0x8e, 0x27,
	0xbf, 0x6d, 0xd2, 0xfa, 0xef, 0x04, 0x5a, 0x88, 0x5f, 0x15, 0xee, 0x53, 0x8f, 0x13, 0xdc, 0x41,
	0x59, 0xd0, 0x7b, 0xc0, 0xd5, 0x5d, 0xa9, 0x5d, 0x9c, 0x97, 0xd6, 0x5b, 0x82, 0xed, 0x78, 0x41,
	0x7f, 0x6d, 0x94, 0x47, 0xa5, 0x61, 0x8b, 0xce, 0x51, 0xe8, 0xb3, 0x0e, 0x97, 0x8a, 0xcb, 0x47,
	0xfd, 0x52, 0x25, 0x91, 0x1f, 0xe5, 0x52, 0xed, 0xa2, 0x74, 0x33, 0x70, 0x89, 0xbc, 0x55, 0xf9,
	0x2d, 0xb3, 0x12, 0xa5, 0x5a, 0x69, 0x3d, 0x03, 0xbc, 0x7e, 0x57, 0x31, 0xce, 0xb0, 0xc0, 0x8d,
	0xbd, 0xa0, 0xe2, 0x63, 0xfc, 0x0b, 0x94, 0xd9, 0xf3, 0xba, 0xe4, 0x4c, 0xde, 0xb0, 0xc2, 0x50,
	0xa7, 0x0e, 0x80, 0xba, 0x4e, 0x13, 0x80, 0x65, 0xa1, 0xbc, 0x96, 0x3a, 0x14, 0xd1, 0x46, 0xad,
	0xbd, 0xfd, 0x3c, 0x7c, 0x39, 0x35, 0xf6, 0x5a, 0x2d, 0xd3, 0xb0, 0xfe, 0x91, 0x42, 0xf9, 0x70,
	0xbb, 0x7e, 0x15, 0x10, 0x36, 0xc0, 0xfb, 0x28, 0xd3, 0x26, 0x67, 0x22, 0x2a, 0x1a, 0xd7, 0x9d,
	0x13, 0x80, 0xa0, 0x56, 0x87, 0x91, 0x3e, 0xf1, 0x44, 0x7d, 0x1e, 0x22, 0x10, 0x60, 0xa9, 0x47,
	0x90, 0x00, 0xb0, 0x1b, 0x6b, 0xa0, 0x26, 0xee, 0xa7, 0xd6, 0x72, 0xf5, 0xfa, 0xc5, 0x79, 0xe9,
	0x6e, 0x74, 0x5e, 0x51, 0x13, 0x25, 0x5b, 0x91, 0xf5, 0x8b, 0xf3, 0xd2, 0x74, 0x4b, 0xb0, 0x7d,
	0xe2, 0xad, 0x6d, 0x3c, 0x7c, 0xfc, 0xb3, 0xf5, 0xef, 0xd7, 0x3d, 0xe1, 0xd7, 0x51, 0xc1, 0x4b,
	0xc9, 0x85, 0xbe, 0xb8, 0x38, 0x2f, 0xe1, 0x68, 0x21, 0x98, 0x18, 0xbb, 0xc8, 0x07, 0x4b, 0x1e,
	0x7e, 0x8e, 0xb2, 0xbb, 0xf2, 0xe3, 0x40, 0x1e, 0x02, 0x9c, 0x66, 0xf8, 0xad, 0x50, 0x69, 0xa9,
	0xce, 0x3f, 0x6c, 0x1b, 0x42, 0x50, 0xbf, 0x59, 0x49, 0x04, 0x98, 0xf6, 0xe5, 0x47, 0x83, 0x54,
	0x37, 0x30, 0x85, 0xdf, 0x10, 0x09, 0xa6, 0x10, 0xd4, 0x99, 0x92, 0x88, 0xf5, 0xb7, 0x34, 0xf4,
	0x08, 0x7a, 0x19, 0xfd, 0x2d, 0xca, 0xcb, 0x53, 0x6c, 0x09, 0x68, 0xf8, 0x95, 0x3e, 0x3e, 0xbf,
	0x38, 0x2f, 0x15, 0xae, 0x13, 0xde, 0xfa, 0xf9, 0x63, 0xc8, 0xf8, 0xee, 0x1b, 0xb0, 0x2b, 0x73,
	0x69, 0xa8, 0xad, 0x32, 0x06, 0xc7, 0x4f, 0x51, 0x1a, 0x2a, 0x89, 0xd4, 0x42, 0xa6, 0xfe, 0xe0,
	0xe2, 0xbc, 0x64, 0xee, 0x79, 0xa2, 0x69, 0x7b, 0x3d, 0xb2, 0xb6, 0xf1, 0x70, 0x73, 0x63, 0xeb,
	0x11, 0xb0, 0xce, 0x40, 0xb5, 0xd0, 0x6f, 0x72, 0x7c, 0x8c, 0xbf, 0x41, 0xa8, 0x61, 0x9f, 0x35,
	0x09, 0x0f, 0x5c, 0xc1, 0xa5, 0x2e, 0x32, 0xf5, 0x47, 0x09, 0xae, 0x27, 0x9b, 0x5f, 0x6c, 0xad,
	0xff, 0xfd, 0xbc, 0x34, 0xb1, 0xb9, 0x71, 0x75, 0xb9, 0x7a, 0xa7, 0x6f, 0x9f, 0x95, 0x59, 0xe8,
	0xa0, 0x11, 0x8f, 0x86, 0xf1, 0x1e, 0xca, 0xb6, 0x28, 0x13, 0xf5, 0x81, 0x2a, 0xc6, 0x0f, 0x46,
	0xa5, 0x3e, 0xc7, 0x29, 0x13, 0xe5, 0x03, 0x5d, 0xbe, 0x37, 0x21, 0xfc, 0x0d, 0x4a, 0x37, 0x68,
	0x97, 0xa8, 0x12, 0xfc, 0xcb, 0x8b, 0xf3, 0x92, 0x15, 0x5d, 0xa5, 0xd8, 0x9e, 0x57, 0xd4, 0x2f,
	0x18, 0x43, 0xd8, 0xe9, 0xdd, 0xc0, 0x75, 0x65, 0x2f, 0x4c, 0xbb, 0x31, 0x51, 0xc7, 0xc7, 0xa0,
	0x33, 0x79, 0x54, 0xb2, 0x1c, 0x6b, 0x4d, 0xbc, 0xa6, 0xc5, 0xa1, 0xd2, 0xe5, 0xa1, 0xe8, 0xd7,
	0x33, 0x01, 0x58, 0x9f, 0xa0, 0xbc, 0x16, 0x07, 0xc8, 0x1b, 0xc2, 0x30, 0x3f, 0x82, 0x2e, 0x4c,
	0xbd, 0xea, 0x4d, 0xc3, 0xba, 0x4a, 0xa3, 0x99, 0x44, 0x31, 0xad, 0xa1, 0x5c, 0x9b, 0x0a, 0xdb,
	0x7d, 0xee, 0xa8, 0x03, 0x49, 0xd5, 0x8b, 0xa0, 0x3a, 0x01, 0x60, 0xf9, 0xc8, 0x89, 0xed, 0xfa,
	0x48, 0x14, 0x3f, 0x45, 0xa8, 0xd6, 0x11, 0x81, 0xe2, 0x48, 0x4b, 0x8e, 0x12, 0x1c, 0x9d, 0x2d,
	0xd1, 0x24, 0xc9, 0x68, 0x18, 0x37, 0xd1, 0x4c, 0xdb, 0xe9, 0x93, 0xb6, 0x7d, 0x4c, 0xbc, 0x06,
	0x27, 0x9d, 0x50, 0x1e, 0xa9, 0xfa, 0xca, 0xd5, 0xe5, 0xea, 0x92, 0x70, 0xfa, 0xa4, 0x2c, 0x60,
	0xaa, 0xdc, 0x87, 0x39, 0x8d, 0xee, 0x96, 0x39, 0xbc, 0xab, 0x3e, 0x0a, 0xd4, 0x1e, 0x0f, 0x3f,
	0x30, 0x00, 0x1c, 0xee, 0x2e, 0x81, 0xa1, 0xbe, 0xbb, 0x09, 0x40, 0xff, 0x54, 0x99, 0xfc, 0xc1,
	0x9f, 0x2a, 0xf8, 0x18, 0xcd, 0xa8, 0x23, 0x89, 0x48, 0xa7, 0x64, 0x78, 0x77, 0x86, 0xa5, 0x16,
	0x3a, 0x1c, 0x65, 0x33, 0x6c, 0x28, 0xfc, 0x10, 0x28, 0xdf, 0x5c, 0x64, 0xfc, 0x14, 0x3e, 0x43,
	0x73, 0x51, 0x93, 0x4a, 0xba, 0xd1, 0x7a, 0x39, 0xb9, 0x5e, 0x29, 0xbe, 0x9e, 0xd6, 0xcb, 0xd6,
	0x3f, 0x51, 0x6b, 0xde, 0xb3, 0xaf, 0x7d, 0x47, 0x2c, 0x7b, 0xeb, 0xac, 0xf5, 0x2f, 0x03, 0xcd,
	0xdd, 0x60, 0xc6, 0x04, 0x4d, 0x86, 0x60, 0xf4, 0x82, 0x79, 0x30, 0x36, 0x0a, 0x85, 0xf0, 0xc4,
	0x1e, 0x87, 0xfd, 0x5f, 0x6c, 0x8f, 0x6f, 0x40, 0x4b, 0xaf, 0xd0, 0xb4, 0xee, 0x3d, 0xa2, 0x47,
	0xdd, 0x8c, 0x77, 0xd6, 0xcb, 0xb7, 0xfc, 0x6d, 0xa1, 0x37, 0xb0, 0xdf, 0x1a, 0xa8, 0x10, 0x3b,
	0x1f, 0x6c, 0x27, 0x33, 0xb2, 0x46, 0x9e, 0xe3, 0x0f, 0xc9, 0xa6, 0xf5, 0xc1, 0x6c, 0xc6, 0xfd,
	0xdf, 0x91, 0xf8, 0x8f, 0x42, 0xcf, 0xa4, 0x8d, 0x66, 0x13, 0xef, 0x74, 0x5c, 0x43, 0x69, 0x80,
	0x64, 0x1e, 0xb9, 0xfa, 0xc7, 0xa3, 0x8a, 0xe7, 0x0c, 0xbc, 0xe1, 0x63, 0x1f, 0xd3, 0xb1, 0x71,
	0x7d, 0xfa, 0xed, 0xfb, 0x15, 0xe3, 0xdd, 0xfb, 0x15, 0xe3, 0x3f, 0xef, 0x57, 0x8c, 0x97, 0xc6,
	0x41, 0x56, 0xfe, 0xbd, 0xf5, 0xe8, 0x7f, 0x01, 0x00, 0x00, 0xff, 0xff, 0xd7, 0xc4, 0x64, 0x30,
	0x47, 0x14, 0x00, 0x00,
}
