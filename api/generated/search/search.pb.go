// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: search.proto

/*
	Package search is a generated protocol buffer package.

	Service name

	It is generated from these files:
		search.proto

	It has these top-level messages:
		Aggregation
		Entry
		EntryList
		Error
		NestedAggregation
		Requirement
		SearchCriteria
		SearchRequest
		SearchResponse
		SearchResult
*/
package search

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/pensando/grpc-gateway/third_party/googleapis/google/api"
import _ "github.com/pensando/sw/venice/utils/apigen/annotations"
import _ "github.com/gogo/protobuf/gogoproto"
import api "github.com/pensando/sw/api"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// Operator represents a key/field's relationship to value(s).
type Operator int32

const (
	Operator_Empty     Operator = 0
	Operator_Equals    Operator = 1
	Operator_In        Operator = 2
	Operator_NotEquals Operator = 3
	Operator_NotIn     Operator = 4
	Operator_Gt        Operator = 5
	Operator_Lt        Operator = 6
)

var Operator_name = map[int32]string{
	0: "Empty",
	1: "Equals",
	2: "In",
	3: "NotEquals",
	4: "NotIn",
	5: "Gt",
	6: "Lt",
}
var Operator_value = map[string]int32{
	"Empty":     0,
	"Equals":    1,
	"In":        2,
	"NotEquals": 3,
	"NotIn":     4,
	"Gt":        5,
	"Lt":        6,
}

func (x Operator) String() string {
	return proto.EnumName(Operator_name, int32(x))
}
func (Operator) EnumDescriptor() ([]byte, []int) { return fileDescriptorSearch, []int{0} }

// Requirement defines a single matching criteria for search
// TODO: Switch to unified requirement defintion once it is ready
type Aggregation struct {
	// KeyOrText contains the following.
	// -  "Key" followed by operator and list of values
	//                 (OR)
	// -  "Text" - single-word or Phrase text search and
	//    in such cases Operator and Values are empty and
	//    not-applicable.
	//
	// Examples of Text search:
	//     "Prod", "Link Down"
	// Examples of Structured query:
	//     (Note these are illustrative examples and exact values will be per our object model)
	//     Key=Kind Operator=Equals Values=[Network]
	//     Key=Meta.Tenant Operator=In Values=[tesla,ford]
	//     Key=Status.RxErrCount Operator:Gt Values=[100]
	Entries map[string]*EntryList `protobuf:"bytes,1,rep,name=Entries" json:"entries,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *Aggregation) Reset()                    { *m = Aggregation{} }
func (m *Aggregation) String() string            { return proto.CompactTextString(m) }
func (*Aggregation) ProtoMessage()               {}
func (*Aggregation) Descriptor() ([]byte, []int) { return fileDescriptorSearch, []int{0} }

func (m *Aggregation) GetEntries() map[string]*EntryList {
	if m != nil {
		return m.Entries
	}
	return nil
}

// SearchCriteria contains the following :
// - Requirements is list of match critertia parsed by the Query Parser
// - User-info and optionally RbacFilters will be added by RBAC-plugin
//   running in API-GW and will be passed to backend. The details are TBD.
type Entry struct {
	// Requirements is a list of match critertia for the
	// Search request. It could be combination of Keyword,
	// Phrase or Fields matching certain values. The
	// requirements are ANDed by default. In cases where
	// User specifies a QueryString as URI parameter,
	// the query parser would parse it and translate
	// into Requirements.
	// For contextual search, these requirements will be used
	// as well to specify the scope to narrow down the search.
	api.TypeMeta   `protobuf:"bytes,1,opt,name=T,embedded=T" json:",inline"`
	api.ObjectMeta `protobuf:"bytes,2,opt,name=O,embedded=O" json:"meta,omitempty"`
}

func (m *Entry) Reset()                    { *m = Entry{} }
func (m *Entry) String() string            { return proto.CompactTextString(m) }
func (*Entry) ProtoMessage()               {}
func (*Entry) Descriptor() ([]byte, []int) { return fileDescriptorSearch, []int{1} }

// Error contains the error code, description and
// associated details
type EntryList struct {
	// Type of error
	Entries []*Entry `protobuf:"bytes,1,rep,name=Entries" json:"entries,omitempty"`
}

func (m *EntryList) Reset()                    { *m = EntryList{} }
func (m *EntryList) String() string            { return proto.CompactTextString(m) }
func (*EntryList) ProtoMessage()               {}
func (*EntryList) Descriptor() ([]byte, []int) { return fileDescriptorSearch, []int{2} }

func (m *EntryList) GetEntries() []*Entry {
	if m != nil {
		return m.Entries
	}
	return nil
}

// Entry represent a single search result entry
type Error struct {
	// For Policy & config objects, the result will have
	// have all the metadata and a self-link to get the
	// entire object next if needed
	Type   string `protobuf:"bytes,1,opt,name=Type,proto3" json:"type,omitempty"`
	Reason string `protobuf:"bytes,2,opt,name=Reason,proto3" json:"reason,omitempty"`
}

func (m *Error) Reset()                    { *m = Error{} }
func (m *Error) String() string            { return proto.CompactTextString(m) }
func (*Error) ProtoMessage()               {}
func (*Error) Descriptor() ([]byte, []int) { return fileDescriptorSearch, []int{3} }

func (m *Error) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *Error) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

// EntryList is list of search result entries
type NestedAggregation struct {
	Entries map[string]*Aggregation `protobuf:"bytes,1,rep,name=Entries" json:"entries,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *NestedAggregation) Reset()                    { *m = NestedAggregation{} }
func (m *NestedAggregation) String() string            { return proto.CompactTextString(m) }
func (*NestedAggregation) ProtoMessage()               {}
func (*NestedAggregation) Descriptor() ([]byte, []int) { return fileDescriptorSearch, []int{4} }

func (m *NestedAggregation) GetEntries() map[string]*Aggregation {
	if m != nil {
		return m.Entries
	}
	return nil
}

// Aggregation contains map of search results entries
// grouped by a Key.
// For eg: search result entries grouped by Kind as key
type Requirement struct {
	KeyOrText string   `protobuf:"bytes,1,opt,name=KeyOrText,proto3" json:"key-or-text,omitempty"`
	Operator  string   `protobuf:"bytes,2,opt,name=Operator,proto3" json:"operator,omitempty"`
	Values    []string `protobuf:"bytes,3,rep,name=Values" json:"values,omitempty"`
}

func (m *Requirement) Reset()                    { *m = Requirement{} }
func (m *Requirement) String() string            { return proto.CompactTextString(m) }
func (*Requirement) ProtoMessage()               {}
func (*Requirement) Descriptor() ([]byte, []int) { return fileDescriptorSearch, []int{5} }

func (m *Requirement) GetKeyOrText() string {
	if m != nil {
		return m.KeyOrText
	}
	return ""
}

func (m *Requirement) GetOperator() string {
	if m != nil {
		return m.Operator
	}
	return ""
}

func (m *Requirement) GetValues() []string {
	if m != nil {
		return m.Values
	}
	return nil
}

// NestedAggregation contains map of search results
// grouped by two levels of Aggregation
// For eg: search result entries grouped first by Tenant
//         name and subsequently grouped by Kind.
type SearchCriteria struct {
	Requirements []Requirement `protobuf:"bytes,1,rep,name=Requirements" json:"requirements,omitempty"`
}

func (m *SearchCriteria) Reset()                    { *m = SearchCriteria{} }
func (m *SearchCriteria) String() string            { return proto.CompactTextString(m) }
func (*SearchCriteria) ProtoMessage()               {}
func (*SearchCriteria) Descriptor() ([]byte, []int) { return fileDescriptorSearch, []int{6} }

func (m *SearchCriteria) GetRequirements() []Requirement {
	if m != nil {
		return m.Requirements
	}
	return nil
}

// SearchResult contains the search result.
// Based on the search request, search results would be part
// of one of the entities : Entries, Aggregation or NestedAggregation.
// In case of failures, Error would indicate the error status and
// description.
type SearchRequest struct {
	// TotalHits indicates total number of hits matched
	QueryString string `protobuf:"bytes,1,opt,name=QueryString,proto3" json:"query-string,omitempty"`
	// ActualHits indicates the actual hits returned in this response
	From int32 `protobuf:"varint,2,opt,name=From,proto3" json:"from,omitempty"`
	// TimeTakenMsecs is the time taken for search response in millisecs
	MaxResults int32 `protobuf:"varint,3,opt,name=MaxResults,proto3" json:"max-results,omitempty"`
	// Error status for failures
	Criteria *SearchCriteria `protobuf:"bytes,4,opt,name=Criteria" json:"criteria,omitempty"`
}

func (m *SearchRequest) Reset()                    { *m = SearchRequest{} }
func (m *SearchRequest) String() string            { return proto.CompactTextString(m) }
func (*SearchRequest) ProtoMessage()               {}
func (*SearchRequest) Descriptor() ([]byte, []int) { return fileDescriptorSearch, []int{7} }

func (m *SearchRequest) GetQueryString() string {
	if m != nil {
		return m.QueryString
	}
	return ""
}

func (m *SearchRequest) GetFrom() int32 {
	if m != nil {
		return m.From
	}
	return 0
}

func (m *SearchRequest) GetMaxResults() int32 {
	if m != nil {
		return m.MaxResults
	}
	return 0
}

func (m *SearchRequest) GetCriteria() *SearchCriteria {
	if m != nil {
		return m.Criteria
	}
	return nil
}

// SearchRequest is the input to the Query method
type SearchResponse struct {
	// Query string as presented by User.
	api.TypeMeta `protobuf:"bytes,1,opt,name=T,embedded=T" json:",inline"`
	// From represents the start offset (zero based), used in paginated search requests
	// The results returned would be in the range [From ... From+MaxResults-1]
	// TODO: Add venice option to set default to 0.
	api.ObjectMeta `protobuf:"bytes,2,opt,name=O,embedded=O" json:"meta,omitempty"`
	// MaxResults is the max-count of search results
	// TODO: Add venice option to set some default value (TBD)
	Result *SearchResult `protobuf:"bytes,3,opt,name=Result" json:"result,omitempty"`
}

func (m *SearchResponse) Reset()                    { *m = SearchResponse{} }
func (m *SearchResponse) String() string            { return proto.CompactTextString(m) }
func (*SearchResponse) ProtoMessage()               {}
func (*SearchResponse) Descriptor() ([]byte, []int) { return fileDescriptorSearch, []int{8} }

func (m *SearchResponse) GetResult() *SearchResult {
	if m != nil {
		return m.Result
	}
	return nil
}

// SearchResponse is the output provided by the Query method
type SearchResult struct {
	TotalHits         int64              `protobuf:"varint,1,opt,name=TotalHits,proto3" json:"total-hits,omitempty"`
	ActualHits        int64              `protobuf:"varint,2,opt,name=ActualHits,proto3" json:"actual-hits,omitempty"`
	TimeTakenMsecs    int64              `protobuf:"varint,3,opt,name=TimeTakenMsecs,proto3" json:"time-taken-msecs,omitempty"`
	Error             *Error             `protobuf:"bytes,4,opt,name=Error" json:"error,omitempty"`
	Entries           []*Entry           `protobuf:"bytes,5,rep,name=Entries" json:"entries,omitempty"`
	AggregatedEntries *NestedAggregation `protobuf:"bytes,6,opt,name=AggregatedEntries" json:"aggregated-entries,omitempty"`
}

func (m *SearchResult) Reset()                    { *m = SearchResult{} }
func (m *SearchResult) String() string            { return proto.CompactTextString(m) }
func (*SearchResult) ProtoMessage()               {}
func (*SearchResult) Descriptor() ([]byte, []int) { return fileDescriptorSearch, []int{9} }

func (m *SearchResult) GetTotalHits() int64 {
	if m != nil {
		return m.TotalHits
	}
	return 0
}

func (m *SearchResult) GetActualHits() int64 {
	if m != nil {
		return m.ActualHits
	}
	return 0
}

func (m *SearchResult) GetTimeTakenMsecs() int64 {
	if m != nil {
		return m.TimeTakenMsecs
	}
	return 0
}

func (m *SearchResult) GetError() *Error {
	if m != nil {
		return m.Error
	}
	return nil
}

func (m *SearchResult) GetEntries() []*Entry {
	if m != nil {
		return m.Entries
	}
	return nil
}

func (m *SearchResult) GetAggregatedEntries() *NestedAggregation {
	if m != nil {
		return m.AggregatedEntries
	}
	return nil
}

func init() {
	proto.RegisterType((*Aggregation)(nil), "search.Aggregation")
	proto.RegisterType((*Entry)(nil), "search.Entry")
	proto.RegisterType((*EntryList)(nil), "search.EntryList")
	proto.RegisterType((*Error)(nil), "search.Error")
	proto.RegisterType((*NestedAggregation)(nil), "search.NestedAggregation")
	proto.RegisterType((*Requirement)(nil), "search.Requirement")
	proto.RegisterType((*SearchCriteria)(nil), "search.SearchCriteria")
	proto.RegisterType((*SearchRequest)(nil), "search.SearchRequest")
	proto.RegisterType((*SearchResponse)(nil), "search.SearchResponse")
	proto.RegisterType((*SearchResult)(nil), "search.SearchResult")
	proto.RegisterEnum("search.Operator", Operator_name, Operator_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for SearchV1 service

type SearchV1Client interface {
	// In the example below a query like
	//    http://<...>/venice/v1/search/query?QueryString=XXXXX&MaxResults=100
	//  generates a RPC call Query with the parameter as
	//  SearchRequest{ QueryString: "XXXXX", MaxResults:100}
	Query(ctx context.Context, in *SearchRequest, opts ...grpc.CallOption) (*SearchResponse, error)
}

type searchV1Client struct {
	cc *grpc.ClientConn
}

func NewSearchV1Client(cc *grpc.ClientConn) SearchV1Client {
	return &searchV1Client{cc}
}

func (c *searchV1Client) Query(ctx context.Context, in *SearchRequest, opts ...grpc.CallOption) (*SearchResponse, error) {
	out := new(SearchResponse)
	err := grpc.Invoke(ctx, "/search.SearchV1/Query", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for SearchV1 service

type SearchV1Server interface {
	// In the example below a query like
	//    http://<...>/venice/v1/search/query?QueryString=XXXXX&MaxResults=100
	//  generates a RPC call Query with the parameter as
	//  SearchRequest{ QueryString: "XXXXX", MaxResults:100}
	Query(context.Context, *SearchRequest) (*SearchResponse, error)
}

func RegisterSearchV1Server(s *grpc.Server, srv SearchV1Server) {
	s.RegisterService(&_SearchV1_serviceDesc, srv)
}

func _SearchV1_Query_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SearchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SearchV1Server).Query(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/search.SearchV1/Query",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SearchV1Server).Query(ctx, req.(*SearchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _SearchV1_serviceDesc = grpc.ServiceDesc{
	ServiceName: "search.SearchV1",
	HandlerType: (*SearchV1Server)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Query",
			Handler:    _SearchV1_Query_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "search.proto",
}

func (m *Aggregation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Aggregation) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Entries) > 0 {
		for k, _ := range m.Entries {
			dAtA[i] = 0xa
			i++
			v := m.Entries[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovSearch(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovSearch(uint64(len(k))) + msgSize
			i = encodeVarintSearch(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintSearch(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintSearch(dAtA, i, uint64(v.Size()))
				n1, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n1
			}
		}
	}
	return i, nil
}

func (m *Entry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Entry) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintSearch(dAtA, i, uint64(m.TypeMeta.Size()))
	n2, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n2
	dAtA[i] = 0x12
	i++
	i = encodeVarintSearch(dAtA, i, uint64(m.ObjectMeta.Size()))
	n3, err := m.ObjectMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n3
	return i, nil
}

func (m *EntryList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EntryList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Entries) > 0 {
		for _, msg := range m.Entries {
			dAtA[i] = 0xa
			i++
			i = encodeVarintSearch(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Error) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Error) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSearch(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.Reason) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSearch(dAtA, i, uint64(len(m.Reason)))
		i += copy(dAtA[i:], m.Reason)
	}
	return i, nil
}

func (m *NestedAggregation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NestedAggregation) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Entries) > 0 {
		for k, _ := range m.Entries {
			dAtA[i] = 0xa
			i++
			v := m.Entries[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovSearch(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovSearch(uint64(len(k))) + msgSize
			i = encodeVarintSearch(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintSearch(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintSearch(dAtA, i, uint64(v.Size()))
				n4, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n4
			}
		}
	}
	return i, nil
}

func (m *Requirement) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Requirement) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.KeyOrText) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSearch(dAtA, i, uint64(len(m.KeyOrText)))
		i += copy(dAtA[i:], m.KeyOrText)
	}
	if len(m.Operator) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSearch(dAtA, i, uint64(len(m.Operator)))
		i += copy(dAtA[i:], m.Operator)
	}
	if len(m.Values) > 0 {
		for _, s := range m.Values {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *SearchCriteria) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchCriteria) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Requirements) > 0 {
		for _, msg := range m.Requirements {
			dAtA[i] = 0xa
			i++
			i = encodeVarintSearch(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SearchRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.QueryString) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSearch(dAtA, i, uint64(len(m.QueryString)))
		i += copy(dAtA[i:], m.QueryString)
	}
	if m.From != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintSearch(dAtA, i, uint64(m.From))
	}
	if m.MaxResults != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintSearch(dAtA, i, uint64(m.MaxResults))
	}
	if m.Criteria != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintSearch(dAtA, i, uint64(m.Criteria.Size()))
		n5, err := m.Criteria.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	return i, nil
}

func (m *SearchResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintSearch(dAtA, i, uint64(m.TypeMeta.Size()))
	n6, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n6
	dAtA[i] = 0x12
	i++
	i = encodeVarintSearch(dAtA, i, uint64(m.ObjectMeta.Size()))
	n7, err := m.ObjectMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n7
	if m.Result != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSearch(dAtA, i, uint64(m.Result.Size()))
		n8, err := m.Result.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	return i, nil
}

func (m *SearchResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TotalHits != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintSearch(dAtA, i, uint64(m.TotalHits))
	}
	if m.ActualHits != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintSearch(dAtA, i, uint64(m.ActualHits))
	}
	if m.TimeTakenMsecs != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintSearch(dAtA, i, uint64(m.TimeTakenMsecs))
	}
	if m.Error != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintSearch(dAtA, i, uint64(m.Error.Size()))
		n9, err := m.Error.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if len(m.Entries) > 0 {
		for _, msg := range m.Entries {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintSearch(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.AggregatedEntries != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintSearch(dAtA, i, uint64(m.AggregatedEntries.Size()))
		n10, err := m.AggregatedEntries.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	return i, nil
}

func encodeVarintSearch(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Aggregation) Size() (n int) {
	var l int
	_ = l
	if len(m.Entries) > 0 {
		for k, v := range m.Entries {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovSearch(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovSearch(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovSearch(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *Entry) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovSearch(uint64(l))
	l = m.ObjectMeta.Size()
	n += 1 + l + sovSearch(uint64(l))
	return n
}

func (m *EntryList) Size() (n int) {
	var l int
	_ = l
	if len(m.Entries) > 0 {
		for _, e := range m.Entries {
			l = e.Size()
			n += 1 + l + sovSearch(uint64(l))
		}
	}
	return n
}

func (m *Error) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovSearch(uint64(l))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovSearch(uint64(l))
	}
	return n
}

func (m *NestedAggregation) Size() (n int) {
	var l int
	_ = l
	if len(m.Entries) > 0 {
		for k, v := range m.Entries {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovSearch(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovSearch(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovSearch(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *Requirement) Size() (n int) {
	var l int
	_ = l
	l = len(m.KeyOrText)
	if l > 0 {
		n += 1 + l + sovSearch(uint64(l))
	}
	l = len(m.Operator)
	if l > 0 {
		n += 1 + l + sovSearch(uint64(l))
	}
	if len(m.Values) > 0 {
		for _, s := range m.Values {
			l = len(s)
			n += 1 + l + sovSearch(uint64(l))
		}
	}
	return n
}

func (m *SearchCriteria) Size() (n int) {
	var l int
	_ = l
	if len(m.Requirements) > 0 {
		for _, e := range m.Requirements {
			l = e.Size()
			n += 1 + l + sovSearch(uint64(l))
		}
	}
	return n
}

func (m *SearchRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.QueryString)
	if l > 0 {
		n += 1 + l + sovSearch(uint64(l))
	}
	if m.From != 0 {
		n += 1 + sovSearch(uint64(m.From))
	}
	if m.MaxResults != 0 {
		n += 1 + sovSearch(uint64(m.MaxResults))
	}
	if m.Criteria != nil {
		l = m.Criteria.Size()
		n += 1 + l + sovSearch(uint64(l))
	}
	return n
}

func (m *SearchResponse) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovSearch(uint64(l))
	l = m.ObjectMeta.Size()
	n += 1 + l + sovSearch(uint64(l))
	if m.Result != nil {
		l = m.Result.Size()
		n += 1 + l + sovSearch(uint64(l))
	}
	return n
}

func (m *SearchResult) Size() (n int) {
	var l int
	_ = l
	if m.TotalHits != 0 {
		n += 1 + sovSearch(uint64(m.TotalHits))
	}
	if m.ActualHits != 0 {
		n += 1 + sovSearch(uint64(m.ActualHits))
	}
	if m.TimeTakenMsecs != 0 {
		n += 1 + sovSearch(uint64(m.TimeTakenMsecs))
	}
	if m.Error != nil {
		l = m.Error.Size()
		n += 1 + l + sovSearch(uint64(l))
	}
	if len(m.Entries) > 0 {
		for _, e := range m.Entries {
			l = e.Size()
			n += 1 + l + sovSearch(uint64(l))
		}
	}
	if m.AggregatedEntries != nil {
		l = m.AggregatedEntries.Size()
		n += 1 + l + sovSearch(uint64(l))
	}
	return n
}

func sovSearch(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozSearch(x uint64) (n int) {
	return sovSearch(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Aggregation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSearch
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Aggregation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Aggregation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSearch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSearch
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Entries == nil {
				m.Entries = make(map[string]*EntryList)
			}
			var mapkey string
			var mapvalue *EntryList
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSearch
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSearch
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthSearch
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSearch
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthSearch
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthSearch
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &EntryList{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipSearch(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthSearch
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Entries[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSearch(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSearch
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Entry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSearch
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Entry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Entry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSearch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSearch
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSearch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSearch
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSearch(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSearch
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EntryList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSearch
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EntryList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EntryList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSearch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSearch
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entries = append(m.Entries, &Entry{})
			if err := m.Entries[len(m.Entries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSearch(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSearch
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Error) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSearch
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Error: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Error: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSearch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSearch
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSearch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSearch
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSearch(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSearch
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NestedAggregation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSearch
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NestedAggregation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NestedAggregation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSearch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSearch
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Entries == nil {
				m.Entries = make(map[string]*Aggregation)
			}
			var mapkey string
			var mapvalue *Aggregation
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSearch
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSearch
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthSearch
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSearch
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthSearch
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthSearch
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Aggregation{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipSearch(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthSearch
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Entries[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSearch(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSearch
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Requirement) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSearch
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Requirement: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Requirement: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrText", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSearch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSearch
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyOrText = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSearch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSearch
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Operator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Values", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSearch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSearch
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Values = append(m.Values, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSearch(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSearch
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchCriteria) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSearch
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchCriteria: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchCriteria: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Requirements", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSearch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSearch
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Requirements = append(m.Requirements, Requirement{})
			if err := m.Requirements[len(m.Requirements)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSearch(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSearch
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSearch
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueryString", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSearch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSearch
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QueryString = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			m.From = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSearch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.From |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxResults", wireType)
			}
			m.MaxResults = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSearch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxResults |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Criteria", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSearch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSearch
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Criteria == nil {
				m.Criteria = &SearchCriteria{}
			}
			if err := m.Criteria.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSearch(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSearch
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSearch
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSearch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSearch
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSearch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSearch
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSearch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSearch
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Result == nil {
				m.Result = &SearchResult{}
			}
			if err := m.Result.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSearch(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSearch
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSearch
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalHits", wireType)
			}
			m.TotalHits = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSearch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalHits |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActualHits", wireType)
			}
			m.ActualHits = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSearch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ActualHits |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeTakenMsecs", wireType)
			}
			m.TimeTakenMsecs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSearch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimeTakenMsecs |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSearch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSearch
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Error == nil {
				m.Error = &Error{}
			}
			if err := m.Error.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSearch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSearch
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entries = append(m.Entries, &Entry{})
			if err := m.Entries[len(m.Entries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AggregatedEntries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSearch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSearch
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AggregatedEntries == nil {
				m.AggregatedEntries = &NestedAggregation{}
			}
			if err := m.AggregatedEntries.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSearch(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSearch
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipSearch(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowSearch
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSearch
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSearch
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthSearch
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowSearch
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipSearch(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthSearch = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowSearch   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("search.proto", fileDescriptorSearch) }

var fileDescriptorSearch = []byte{
	// 1014 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x56, 0x4f, 0x6f, 0x1b, 0x45,
	0x14, 0xef, 0xd8, 0xb1, 0x1b, 0x8f, 0x93, 0xd4, 0x99, 0xa6, 0xc1, 0xb6, 0x4a, 0x6c, 0x59, 0x50,
	0x02, 0xca, 0xda, 0x6d, 0x90, 0x2a, 0x0a, 0xbd, 0x74, 0x51, 0x02, 0x15, 0x4d, 0x0c, 0x8e, 0x29,
	0x07, 0xc4, 0x61, 0xe2, 0xbc, 0x6e, 0x86, 0x78, 0x77, 0x36, 0x33, 0xb3, 0x21, 0xbe, 0xa1, 0xf4,
	0x1b, 0xc0, 0xad, 0x27, 0xbe, 0x03, 0x9c, 0xb8, 0x71, 0x40, 0xca, 0xb1, 0x12, 0x77, 0x0b, 0x45,
	0x9c, 0xf2, 0x29, 0xd0, 0xcc, 0xce, 0xc6, 0xe3, 0x84, 0x8a, 0x3f, 0x07, 0x4e, 0xf6, 0xbc, 0xf9,
	0xfd, 0xde, 0x9f, 0xdf, 0x7b, 0xf3, 0xb4, 0x78, 0x4e, 0x02, 0x15, 0x83, 0xfd, 0x76, 0x2c, 0xb8,
	0xe2, 0xa4, 0x98, 0x9e, 0xea, 0xb7, 0x03, 0xce, 0x83, 0x21, 0x74, 0x68, 0xcc, 0x3a, 0x34, 0x8a,
	0xb8, 0xa2, 0x8a, 0xf1, 0x48, 0xa6, 0xa8, 0xfa, 0x46, 0xc0, 0xd4, 0x7e, 0xb2, 0xdb, 0x1e, 0xf0,
	0xb0, 0x13, 0x43, 0x24, 0x69, 0xb4, 0xc7, 0x3b, 0xf2, 0x9b, 0xce, 0x11, 0x44, 0x6c, 0x00, 0x9d,
	0x44, 0xb1, 0xa1, 0xd4, 0xd4, 0x00, 0x22, 0x97, 0xdd, 0x61, 0xd1, 0x60, 0x98, 0xec, 0x41, 0xe6,
	0xc6, 0x73, 0xdc, 0x04, 0x3c, 0xe0, 0x1d, 0x63, 0xde, 0x4d, 0x9e, 0x99, 0x93, 0x39, 0x98, 0x7f,
	0x16, 0xfe, 0xe6, 0x2b, 0xa2, 0xea, 0x1c, 0x43, 0x50, 0x34, 0x85, 0xb5, 0x7e, 0x44, 0xb8, 0xfc,
	0x28, 0x08, 0x04, 0x04, 0x26, 0x2a, 0xf9, 0x1c, 0x5f, 0xdf, 0x88, 0x94, 0x60, 0x20, 0xab, 0xa8,
	0x99, 0x5f, 0x2d, 0xaf, 0x37, 0xdb, 0xb6, 0x64, 0x07, 0xd5, 0xb6, 0x10, 0xfd, 0x33, 0xf2, 0x6b,
	0xa7, 0xe3, 0x06, 0x3a, 0x1f, 0x37, 0x16, 0x21, 0xb5, 0xae, 0xf1, 0x90, 0x29, 0x08, 0x63, 0x35,
	0xea, 0x65, 0xbe, 0xea, 0x5b, 0x78, 0xce, 0xe5, 0x90, 0x0a, 0xce, 0x1f, 0xc0, 0xa8, 0x8a, 0x9a,
	0x68, 0xb5, 0xd4, 0xd3, 0x7f, 0xc9, 0x5b, 0xb8, 0x70, 0x44, 0x87, 0x09, 0x54, 0x73, 0x4d, 0xb4,
	0x5a, 0x5e, 0x5f, 0xcc, 0xc2, 0x1a, 0xfc, 0x13, 0x26, 0x55, 0x2f, 0xbd, 0x7f, 0x3f, 0xf7, 0x1e,
	0x6a, 0x29, 0x5c, 0x48, 0xfd, 0xdc, 0xc5, 0xa8, 0x6f, 0xbc, 0x94, 0xd7, 0xe7, 0xdb, 0x34, 0x66,
	0xed, 0xfe, 0x28, 0x86, 0x2d, 0x50, 0xd4, 0xbf, 0x79, 0x3a, 0x6e, 0x5c, 0x7b, 0x99, 0x66, 0x76,
	0x7d, 0x8d, 0x45, 0x43, 0x16, 0x41, 0x0f, 0xf5, 0xc9, 0x03, 0x8c, 0xba, 0x36, 0xc6, 0x0d, 0xc3,
	0xe8, 0xee, 0x7e, 0x0d, 0x03, 0x65, 0x38, 0x75, 0x87, 0xb3, 0xa0, 0x45, 0x72, 0x4a, 0x41, 0xdd,
	0x56, 0x17, 0x97, 0x2e, 0xb2, 0x21, 0xfe, 0x65, 0xa1, 0xe6, 0xa7, 0x32, 0xfe, 0x27, 0xaa, 0xb4,
	0xbe, 0xc2, 0x85, 0x0d, 0x21, 0xb8, 0x20, 0x77, 0xf0, 0x8c, 0x4e, 0x3c, 0xd5, 0xc3, 0x27, 0x3a,
	0xbc, 0x1a, 0xc5, 0xe0, 0x70, 0xcc, 0x3d, 0x59, 0xc3, 0xc5, 0x1e, 0x50, 0xc9, 0x23, 0x53, 0x41,
	0xc9, 0x5f, 0x3a, 0x1f, 0x37, 0x2a, 0xc2, 0x58, 0x1c, 0xac, 0xc5, 0xb4, 0x7e, 0x41, 0x78, 0x71,
	0x1b, 0xa4, 0x82, 0x3d, 0xb7, 0xc3, 0x5f, 0x5e, 0x4e, 0xfc, 0x4e, 0x96, 0xf8, 0x15, 0xec, 0xbf,
	0xef, 0x73, 0xf7, 0x6f, 0xfb, 0xfc, 0xf6, 0x74, 0x9f, 0x6f, 0xfe, 0xc5, 0x78, 0xb9, 0x9d, 0xfe,
	0x09, 0xe1, 0x72, 0x0f, 0x0e, 0x13, 0x26, 0x20, 0x84, 0x48, 0x91, 0x0f, 0x70, 0xe9, 0x13, 0x18,
	0x75, 0x45, 0x1f, 0x8e, 0x95, 0x95, 0xeb, 0x75, 0x9b, 0xd7, 0xad, 0x03, 0x18, 0x79, 0x5c, 0x78,
	0x0a, 0x8e, 0x95, 0x93, 0xdb, 0x04, 0x4f, 0xee, 0xe3, 0xd9, 0x6e, 0x0c, 0x82, 0x2a, 0x2e, 0xac,
	0x80, 0x75, 0xcb, 0x25, 0xdc, 0xda, 0x1d, 0xe2, 0x05, 0x96, 0xdc, 0xc5, 0xc5, 0xa7, 0x3a, 0x23,
	0x59, 0xcd, 0x37, 0xf3, 0xab, 0x25, 0xbf, 0x6a, 0x59, 0x15, 0x93, 0xa7, 0x2b, 0x84, 0xc5, 0xb5,
	0x18, 0x5e, 0xd8, 0x31, 0x75, 0x7d, 0x28, 0x98, 0x02, 0xc1, 0x28, 0xf9, 0x02, 0xcf, 0x39, 0x75,
	0x64, 0xda, 0x5f, 0x94, 0xef, 0xdc, 0xf9, 0x2b, 0x7a, 0x0c, 0xcf, 0xc7, 0x8d, 0x65, 0xe1, 0x10,
	0x9c, 0x20, 0x53, 0x8e, 0x5a, 0xdf, 0xe6, 0xf0, 0x7c, 0x1a, 0x4b, 0x9b, 0x41, 0x2a, 0xf2, 0x10,
	0x97, 0x3f, 0x4b, 0x40, 0x8c, 0x76, 0x94, 0x60, 0x51, 0x60, 0x55, 0xaa, 0x6b, 0x87, 0x87, 0xda,
	0xec, 0x49, 0x63, 0x77, 0x1c, 0xba, 0x70, 0x3d, 0x8b, 0x9b, 0x82, 0x87, 0x46, 0xa0, 0x42, 0x3a,
	0x8b, 0xcf, 0x04, 0x0f, 0xdd, 0x59, 0xd4, 0xf7, 0xe4, 0x01, 0xc6, 0x5b, 0xf4, 0xb8, 0x07, 0x32,
	0x19, 0x2a, 0x2d, 0x8c, 0x46, 0xd7, 0x74, 0x1b, 0x42, 0x7a, 0xec, 0x89, 0xd4, 0xec, 0x90, 0x1c,
	0x30, 0xd9, 0xc6, 0xb3, 0x99, 0x2e, 0xd5, 0x19, 0x33, 0x06, 0xcb, 0x99, 0x0e, 0xd3, 0xaa, 0x4d,
	0xfa, 0x33, 0xb0, 0x16, 0xb7, 0x3f, 0x19, 0xaa, 0xf5, 0x2b, 0xca, 0xe4, 0xee, 0x81, 0x8c, 0x79,
	0x24, 0xe1, 0x7f, 0x5d, 0x0c, 0x64, 0x53, 0x3f, 0x4b, 0x5d, 0x9a, 0x91, 0xa1, 0xbc, 0xbe, 0x34,
	0x5d, 0x4d, 0x7a, 0x37, 0x99, 0x9a, 0x54, 0x9c, 0xe9, 0x07, 0xab, 0x2d, 0xad, 0x9f, 0xf3, 0x78,
	0xce, 0xa5, 0x90, 0xfb, 0xb8, 0xd4, 0xe7, 0x8a, 0x0e, 0x3f, 0x66, 0x66, 0x62, 0xd0, 0x6a, 0xde,
	0xaf, 0x9e, 0x8f, 0x1b, 0x4b, 0x4a, 0x1b, 0xbd, 0x7d, 0x36, 0xa5, 0xf0, 0x04, 0xaa, 0x7b, 0xf3,
	0x68, 0xa0, 0x12, 0x4b, 0xcc, 0x19, 0xa2, 0xe9, 0x0d, 0x35, 0xd6, 0xcb, 0x4c, 0x07, 0x4c, 0x36,
	0xf1, 0x42, 0x9f, 0x85, 0xd0, 0xa7, 0x07, 0x10, 0x6d, 0x49, 0x18, 0xa4, 0xad, 0xcd, 0xfb, 0x2b,
	0xe7, 0xe3, 0x46, 0x5d, 0xb1, 0x10, 0x3c, 0xa5, 0xaf, 0xbc, 0x50, 0xdf, 0x39, 0x3e, 0x2e, 0xb1,
	0xc8, 0x43, 0xbb, 0xdb, 0x6c, 0x83, 0x27, 0xdb, 0x51, 0x1b, 0xfd, 0xd7, 0xac, 0x16, 0x37, 0x40,
	0x1f, 0x1d, 0x37, 0x76, 0x21, 0x3a, 0xdb, 0xb5, 0xf0, 0x1f, 0xb7, 0x2b, 0x09, 0xf1, 0x62, 0xb6,
	0x54, 0x60, 0x2f, 0xf3, 0x56, 0x34, 0xd9, 0xd4, 0x5e, 0xb9, 0xf2, 0xfc, 0x37, 0xac, 0xe7, 0xdb,
	0xf4, 0x82, 0xeb, 0x5d, 0x0d, 0x72, 0xd5, 0xf3, 0x3b, 0x3b, 0x93, 0xe5, 0x42, 0x4a, 0xb8, 0xb0,
	0xa1, 0x71, 0x95, 0x6b, 0x04, 0xe3, 0xe2, 0xc6, 0x61, 0x42, 0x87, 0xb2, 0x82, 0x48, 0x11, 0xe7,
	0x1e, 0x47, 0x95, 0x1c, 0x99, 0xc7, 0xa5, 0x6d, 0xae, 0xac, 0x39, 0xaf, 0xd1, 0xdb, 0x5c, 0x3d,
	0x8e, 0x2a, 0x33, 0x1a, 0xf1, 0x91, 0xaa, 0x14, 0xf4, 0xef, 0x13, 0x55, 0x29, 0xae, 0xef, 0xe1,
	0xd9, 0x74, 0x20, 0x9e, 0xde, 0x23, 0x9b, 0xb8, 0x60, 0xde, 0x29, 0xb9, 0x75, 0x79, 0xbc, 0xcc,
	0xb3, 0xaf, 0x2f, 0x5f, 0x99, 0x3a, 0xf3, 0x14, 0x5a, 0x0b, 0x27, 0xbf, 0xfd, 0xf1, 0x7d, 0x6e,
	0x96, 0x14, 0x3b, 0xe6, 0xf9, 0xd7, 0x2b, 0xdf, 0x3d, 0xaf, 0xe5, 0x8e, 0xee, 0xbd, 0x78, 0x5e,
	0xb3, 0xdf, 0x2f, 0x7e, 0xf3, 0xc5, 0x49, 0x6d, 0x2e, 0x86, 0xc8, 0x93, 0xf1, 0x28, 0x18, 0x52,
	0x29, 0x7f, 0x38, 0xa9, 0x5d, 0x3b, 0x3d, 0x5b, 0x41, 0x2f, 0xcf, 0x56, 0xd0, 0xef, 0x67, 0x2b,
	0xe8, 0x53, 0xb4, 0x5b, 0x34, 0xdf, 0x0b, 0xef, 0xfe, 0x19, 0x00, 0x00, 0xff, 0xff, 0xf0, 0xcc,
	0xc5, 0x15, 0x02, 0x09, 0x00, 0x00,
}
