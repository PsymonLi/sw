// Code generated by protoc-gen-grpc-pensando DO NOT EDIT.

package grpcclient

import (
	"context"
	"errors"
	oldlog "log"

	"github.com/go-kit/kit/endpoint"
	grpctransport "github.com/go-kit/kit/transport/grpc"
	"google.golang.org/grpc"

	api "github.com/pensando/sw/api"
	security "github.com/pensando/sw/api/generated/security"
	listerwatcher "github.com/pensando/sw/api/listerwatcher"
	apiserver "github.com/pensando/sw/venice/apiserver"
	"github.com/pensando/sw/venice/utils/kvstore"
	"github.com/pensando/sw/venice/utils/log"
	"github.com/pensando/sw/venice/utils/trace"
)

// Dummy vars to suppress import errors
var _ api.TypeMeta
var _ listerwatcher.WatcherClient
var _ kvstore.Interface

// NewSecurityV1 sets up a new client for SecurityV1
func NewSecurityV1(conn *grpc.ClientConn, logger log.Logger) security.ServiceSecurityV1Client {

	var lAutoAddAppEndpoint endpoint.Endpoint
	{
		lAutoAddAppEndpoint = grpctransport.NewClient(
			conn,
			"security.SecurityV1",
			"AutoAddApp",
			security.EncodeGrpcReqApp,
			security.DecodeGrpcRespApp,
			&security.App{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoAddAppEndpoint = trace.ClientEndPoint("SecurityV1:AutoAddApp")(lAutoAddAppEndpoint)
	}
	var lAutoAddCertificateEndpoint endpoint.Endpoint
	{
		lAutoAddCertificateEndpoint = grpctransport.NewClient(
			conn,
			"security.SecurityV1",
			"AutoAddCertificate",
			security.EncodeGrpcReqCertificate,
			security.DecodeGrpcRespCertificate,
			&security.Certificate{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoAddCertificateEndpoint = trace.ClientEndPoint("SecurityV1:AutoAddCertificate")(lAutoAddCertificateEndpoint)
	}
	var lAutoAddSecurityGroupEndpoint endpoint.Endpoint
	{
		lAutoAddSecurityGroupEndpoint = grpctransport.NewClient(
			conn,
			"security.SecurityV1",
			"AutoAddSecurityGroup",
			security.EncodeGrpcReqSecurityGroup,
			security.DecodeGrpcRespSecurityGroup,
			&security.SecurityGroup{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoAddSecurityGroupEndpoint = trace.ClientEndPoint("SecurityV1:AutoAddSecurityGroup")(lAutoAddSecurityGroupEndpoint)
	}
	var lAutoAddSgpolicyEndpoint endpoint.Endpoint
	{
		lAutoAddSgpolicyEndpoint = grpctransport.NewClient(
			conn,
			"security.SecurityV1",
			"AutoAddSgpolicy",
			security.EncodeGrpcReqSgpolicy,
			security.DecodeGrpcRespSgpolicy,
			&security.Sgpolicy{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoAddSgpolicyEndpoint = trace.ClientEndPoint("SecurityV1:AutoAddSgpolicy")(lAutoAddSgpolicyEndpoint)
	}
	var lAutoAddTrafficEncryptionPolicyEndpoint endpoint.Endpoint
	{
		lAutoAddTrafficEncryptionPolicyEndpoint = grpctransport.NewClient(
			conn,
			"security.SecurityV1",
			"AutoAddTrafficEncryptionPolicy",
			security.EncodeGrpcReqTrafficEncryptionPolicy,
			security.DecodeGrpcRespTrafficEncryptionPolicy,
			&security.TrafficEncryptionPolicy{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoAddTrafficEncryptionPolicyEndpoint = trace.ClientEndPoint("SecurityV1:AutoAddTrafficEncryptionPolicy")(lAutoAddTrafficEncryptionPolicyEndpoint)
	}
	var lAutoDeleteAppEndpoint endpoint.Endpoint
	{
		lAutoDeleteAppEndpoint = grpctransport.NewClient(
			conn,
			"security.SecurityV1",
			"AutoDeleteApp",
			security.EncodeGrpcReqApp,
			security.DecodeGrpcRespApp,
			&security.App{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoDeleteAppEndpoint = trace.ClientEndPoint("SecurityV1:AutoDeleteApp")(lAutoDeleteAppEndpoint)
	}
	var lAutoDeleteCertificateEndpoint endpoint.Endpoint
	{
		lAutoDeleteCertificateEndpoint = grpctransport.NewClient(
			conn,
			"security.SecurityV1",
			"AutoDeleteCertificate",
			security.EncodeGrpcReqCertificate,
			security.DecodeGrpcRespCertificate,
			&security.Certificate{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoDeleteCertificateEndpoint = trace.ClientEndPoint("SecurityV1:AutoDeleteCertificate")(lAutoDeleteCertificateEndpoint)
	}
	var lAutoDeleteSecurityGroupEndpoint endpoint.Endpoint
	{
		lAutoDeleteSecurityGroupEndpoint = grpctransport.NewClient(
			conn,
			"security.SecurityV1",
			"AutoDeleteSecurityGroup",
			security.EncodeGrpcReqSecurityGroup,
			security.DecodeGrpcRespSecurityGroup,
			&security.SecurityGroup{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoDeleteSecurityGroupEndpoint = trace.ClientEndPoint("SecurityV1:AutoDeleteSecurityGroup")(lAutoDeleteSecurityGroupEndpoint)
	}
	var lAutoDeleteSgpolicyEndpoint endpoint.Endpoint
	{
		lAutoDeleteSgpolicyEndpoint = grpctransport.NewClient(
			conn,
			"security.SecurityV1",
			"AutoDeleteSgpolicy",
			security.EncodeGrpcReqSgpolicy,
			security.DecodeGrpcRespSgpolicy,
			&security.Sgpolicy{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoDeleteSgpolicyEndpoint = trace.ClientEndPoint("SecurityV1:AutoDeleteSgpolicy")(lAutoDeleteSgpolicyEndpoint)
	}
	var lAutoDeleteTrafficEncryptionPolicyEndpoint endpoint.Endpoint
	{
		lAutoDeleteTrafficEncryptionPolicyEndpoint = grpctransport.NewClient(
			conn,
			"security.SecurityV1",
			"AutoDeleteTrafficEncryptionPolicy",
			security.EncodeGrpcReqTrafficEncryptionPolicy,
			security.DecodeGrpcRespTrafficEncryptionPolicy,
			&security.TrafficEncryptionPolicy{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoDeleteTrafficEncryptionPolicyEndpoint = trace.ClientEndPoint("SecurityV1:AutoDeleteTrafficEncryptionPolicy")(lAutoDeleteTrafficEncryptionPolicyEndpoint)
	}
	var lAutoGetAppEndpoint endpoint.Endpoint
	{
		lAutoGetAppEndpoint = grpctransport.NewClient(
			conn,
			"security.SecurityV1",
			"AutoGetApp",
			security.EncodeGrpcReqApp,
			security.DecodeGrpcRespApp,
			&security.App{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoGetAppEndpoint = trace.ClientEndPoint("SecurityV1:AutoGetApp")(lAutoGetAppEndpoint)
	}
	var lAutoGetCertificateEndpoint endpoint.Endpoint
	{
		lAutoGetCertificateEndpoint = grpctransport.NewClient(
			conn,
			"security.SecurityV1",
			"AutoGetCertificate",
			security.EncodeGrpcReqCertificate,
			security.DecodeGrpcRespCertificate,
			&security.Certificate{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoGetCertificateEndpoint = trace.ClientEndPoint("SecurityV1:AutoGetCertificate")(lAutoGetCertificateEndpoint)
	}
	var lAutoGetSecurityGroupEndpoint endpoint.Endpoint
	{
		lAutoGetSecurityGroupEndpoint = grpctransport.NewClient(
			conn,
			"security.SecurityV1",
			"AutoGetSecurityGroup",
			security.EncodeGrpcReqSecurityGroup,
			security.DecodeGrpcRespSecurityGroup,
			&security.SecurityGroup{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoGetSecurityGroupEndpoint = trace.ClientEndPoint("SecurityV1:AutoGetSecurityGroup")(lAutoGetSecurityGroupEndpoint)
	}
	var lAutoGetSgpolicyEndpoint endpoint.Endpoint
	{
		lAutoGetSgpolicyEndpoint = grpctransport.NewClient(
			conn,
			"security.SecurityV1",
			"AutoGetSgpolicy",
			security.EncodeGrpcReqSgpolicy,
			security.DecodeGrpcRespSgpolicy,
			&security.Sgpolicy{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoGetSgpolicyEndpoint = trace.ClientEndPoint("SecurityV1:AutoGetSgpolicy")(lAutoGetSgpolicyEndpoint)
	}
	var lAutoGetTrafficEncryptionPolicyEndpoint endpoint.Endpoint
	{
		lAutoGetTrafficEncryptionPolicyEndpoint = grpctransport.NewClient(
			conn,
			"security.SecurityV1",
			"AutoGetTrafficEncryptionPolicy",
			security.EncodeGrpcReqTrafficEncryptionPolicy,
			security.DecodeGrpcRespTrafficEncryptionPolicy,
			&security.TrafficEncryptionPolicy{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoGetTrafficEncryptionPolicyEndpoint = trace.ClientEndPoint("SecurityV1:AutoGetTrafficEncryptionPolicy")(lAutoGetTrafficEncryptionPolicyEndpoint)
	}
	var lAutoListAppEndpoint endpoint.Endpoint
	{
		lAutoListAppEndpoint = grpctransport.NewClient(
			conn,
			"security.SecurityV1",
			"AutoListApp",
			security.EncodeGrpcReqListWatchOptions,
			security.DecodeGrpcRespAppList,
			&security.AppList{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoListAppEndpoint = trace.ClientEndPoint("SecurityV1:AutoListApp")(lAutoListAppEndpoint)
	}
	var lAutoListCertificateEndpoint endpoint.Endpoint
	{
		lAutoListCertificateEndpoint = grpctransport.NewClient(
			conn,
			"security.SecurityV1",
			"AutoListCertificate",
			security.EncodeGrpcReqListWatchOptions,
			security.DecodeGrpcRespCertificateList,
			&security.CertificateList{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoListCertificateEndpoint = trace.ClientEndPoint("SecurityV1:AutoListCertificate")(lAutoListCertificateEndpoint)
	}
	var lAutoListSecurityGroupEndpoint endpoint.Endpoint
	{
		lAutoListSecurityGroupEndpoint = grpctransport.NewClient(
			conn,
			"security.SecurityV1",
			"AutoListSecurityGroup",
			security.EncodeGrpcReqListWatchOptions,
			security.DecodeGrpcRespSecurityGroupList,
			&security.SecurityGroupList{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoListSecurityGroupEndpoint = trace.ClientEndPoint("SecurityV1:AutoListSecurityGroup")(lAutoListSecurityGroupEndpoint)
	}
	var lAutoListSgpolicyEndpoint endpoint.Endpoint
	{
		lAutoListSgpolicyEndpoint = grpctransport.NewClient(
			conn,
			"security.SecurityV1",
			"AutoListSgpolicy",
			security.EncodeGrpcReqListWatchOptions,
			security.DecodeGrpcRespSgpolicyList,
			&security.SgpolicyList{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoListSgpolicyEndpoint = trace.ClientEndPoint("SecurityV1:AutoListSgpolicy")(lAutoListSgpolicyEndpoint)
	}
	var lAutoListTrafficEncryptionPolicyEndpoint endpoint.Endpoint
	{
		lAutoListTrafficEncryptionPolicyEndpoint = grpctransport.NewClient(
			conn,
			"security.SecurityV1",
			"AutoListTrafficEncryptionPolicy",
			security.EncodeGrpcReqListWatchOptions,
			security.DecodeGrpcRespTrafficEncryptionPolicyList,
			&security.TrafficEncryptionPolicyList{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoListTrafficEncryptionPolicyEndpoint = trace.ClientEndPoint("SecurityV1:AutoListTrafficEncryptionPolicy")(lAutoListTrafficEncryptionPolicyEndpoint)
	}
	var lAutoUpdateAppEndpoint endpoint.Endpoint
	{
		lAutoUpdateAppEndpoint = grpctransport.NewClient(
			conn,
			"security.SecurityV1",
			"AutoUpdateApp",
			security.EncodeGrpcReqApp,
			security.DecodeGrpcRespApp,
			&security.App{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoUpdateAppEndpoint = trace.ClientEndPoint("SecurityV1:AutoUpdateApp")(lAutoUpdateAppEndpoint)
	}
	var lAutoUpdateCertificateEndpoint endpoint.Endpoint
	{
		lAutoUpdateCertificateEndpoint = grpctransport.NewClient(
			conn,
			"security.SecurityV1",
			"AutoUpdateCertificate",
			security.EncodeGrpcReqCertificate,
			security.DecodeGrpcRespCertificate,
			&security.Certificate{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoUpdateCertificateEndpoint = trace.ClientEndPoint("SecurityV1:AutoUpdateCertificate")(lAutoUpdateCertificateEndpoint)
	}
	var lAutoUpdateSecurityGroupEndpoint endpoint.Endpoint
	{
		lAutoUpdateSecurityGroupEndpoint = grpctransport.NewClient(
			conn,
			"security.SecurityV1",
			"AutoUpdateSecurityGroup",
			security.EncodeGrpcReqSecurityGroup,
			security.DecodeGrpcRespSecurityGroup,
			&security.SecurityGroup{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoUpdateSecurityGroupEndpoint = trace.ClientEndPoint("SecurityV1:AutoUpdateSecurityGroup")(lAutoUpdateSecurityGroupEndpoint)
	}
	var lAutoUpdateSgpolicyEndpoint endpoint.Endpoint
	{
		lAutoUpdateSgpolicyEndpoint = grpctransport.NewClient(
			conn,
			"security.SecurityV1",
			"AutoUpdateSgpolicy",
			security.EncodeGrpcReqSgpolicy,
			security.DecodeGrpcRespSgpolicy,
			&security.Sgpolicy{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoUpdateSgpolicyEndpoint = trace.ClientEndPoint("SecurityV1:AutoUpdateSgpolicy")(lAutoUpdateSgpolicyEndpoint)
	}
	var lAutoUpdateTrafficEncryptionPolicyEndpoint endpoint.Endpoint
	{
		lAutoUpdateTrafficEncryptionPolicyEndpoint = grpctransport.NewClient(
			conn,
			"security.SecurityV1",
			"AutoUpdateTrafficEncryptionPolicy",
			security.EncodeGrpcReqTrafficEncryptionPolicy,
			security.DecodeGrpcRespTrafficEncryptionPolicy,
			&security.TrafficEncryptionPolicy{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoUpdateTrafficEncryptionPolicyEndpoint = trace.ClientEndPoint("SecurityV1:AutoUpdateTrafficEncryptionPolicy")(lAutoUpdateTrafficEncryptionPolicyEndpoint)
	}
	return security.EndpointsSecurityV1Client{
		Client: security.NewSecurityV1Client(conn),

		AutoAddAppEndpoint:                        lAutoAddAppEndpoint,
		AutoAddCertificateEndpoint:                lAutoAddCertificateEndpoint,
		AutoAddSecurityGroupEndpoint:              lAutoAddSecurityGroupEndpoint,
		AutoAddSgpolicyEndpoint:                   lAutoAddSgpolicyEndpoint,
		AutoAddTrafficEncryptionPolicyEndpoint:    lAutoAddTrafficEncryptionPolicyEndpoint,
		AutoDeleteAppEndpoint:                     lAutoDeleteAppEndpoint,
		AutoDeleteCertificateEndpoint:             lAutoDeleteCertificateEndpoint,
		AutoDeleteSecurityGroupEndpoint:           lAutoDeleteSecurityGroupEndpoint,
		AutoDeleteSgpolicyEndpoint:                lAutoDeleteSgpolicyEndpoint,
		AutoDeleteTrafficEncryptionPolicyEndpoint: lAutoDeleteTrafficEncryptionPolicyEndpoint,
		AutoGetAppEndpoint:                        lAutoGetAppEndpoint,
		AutoGetCertificateEndpoint:                lAutoGetCertificateEndpoint,
		AutoGetSecurityGroupEndpoint:              lAutoGetSecurityGroupEndpoint,
		AutoGetSgpolicyEndpoint:                   lAutoGetSgpolicyEndpoint,
		AutoGetTrafficEncryptionPolicyEndpoint:    lAutoGetTrafficEncryptionPolicyEndpoint,
		AutoListAppEndpoint:                       lAutoListAppEndpoint,
		AutoListCertificateEndpoint:               lAutoListCertificateEndpoint,
		AutoListSecurityGroupEndpoint:             lAutoListSecurityGroupEndpoint,
		AutoListSgpolicyEndpoint:                  lAutoListSgpolicyEndpoint,
		AutoListTrafficEncryptionPolicyEndpoint:   lAutoListTrafficEncryptionPolicyEndpoint,
		AutoUpdateAppEndpoint:                     lAutoUpdateAppEndpoint,
		AutoUpdateCertificateEndpoint:             lAutoUpdateCertificateEndpoint,
		AutoUpdateSecurityGroupEndpoint:           lAutoUpdateSecurityGroupEndpoint,
		AutoUpdateSgpolicyEndpoint:                lAutoUpdateSgpolicyEndpoint,
		AutoUpdateTrafficEncryptionPolicyEndpoint: lAutoUpdateTrafficEncryptionPolicyEndpoint,
	}
}

// NewSecurityV1Backend creates an instrumented client with middleware
func NewSecurityV1Backend(conn *grpc.ClientConn, logger log.Logger) security.ServiceSecurityV1Client {
	cl := NewSecurityV1(conn, logger)
	cl = security.LoggingSecurityV1MiddlewareClient(logger)(cl)
	return cl
}

type grpcObjSecurityV1SecurityGroup struct {
	logger log.Logger
	client security.ServiceSecurityV1Client
}

func (a *grpcObjSecurityV1SecurityGroup) Create(ctx context.Context, in *security.SecurityGroup) (*security.SecurityGroup, error) {
	a.logger.DebugLog("msg", "received call", "object", "SecurityGroup", "oper", "create")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoAddSecurityGroup(nctx, in)
}

func (a *grpcObjSecurityV1SecurityGroup) Update(ctx context.Context, in *security.SecurityGroup) (*security.SecurityGroup, error) {
	a.logger.DebugLog("msg", "received call", "object", "SecurityGroup", "oper", "update")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoUpdateSecurityGroup(nctx, in)
}

func (a *grpcObjSecurityV1SecurityGroup) Get(ctx context.Context, objMeta *api.ObjectMeta) (*security.SecurityGroup, error) {
	a.logger.DebugLog("msg", "received call", "object", "SecurityGroup", "oper", "get")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := security.SecurityGroup{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoGetSecurityGroup(nctx, &in)
}

func (a *grpcObjSecurityV1SecurityGroup) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*security.SecurityGroup, error) {
	a.logger.DebugLog("msg", "received call", "object", "SecurityGroup", "oper", "delete")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := security.SecurityGroup{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoDeleteSecurityGroup(nctx, &in)
}

func (a *grpcObjSecurityV1SecurityGroup) List(ctx context.Context, options *api.ListWatchOptions) ([]*security.SecurityGroup, error) {
	a.logger.DebugLog("msg", "received call", "object", "SecurityGroup", "oper", "list")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	r, err := a.client.AutoListSecurityGroup(nctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *grpcObjSecurityV1SecurityGroup) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	a.logger.DebugLog("msg", "received call", "object", "SecurityGroup", "oper", "WatchOper")
	nctx := addVersion(ctx, "v1")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	stream, err := a.client.AutoWatchSecurityGroup(nctx, options)
	if err != nil {
		return nil, err
	}
	wstream := stream.(security.SecurityV1_AutoWatchSecurityGroupClient)
	bridgefn := func(lw *listerwatcher.WatcherClient) {
		for {
			r, err := wstream.Recv()
			if err != nil {
				a.logger.ErrorLog("msg", "error on receive", "error", err)
				close(lw.OutCh)
				return
			}
			for _, e := range r.Events {
				ev := kvstore.WatchEvent{
					Type:   kvstore.WatchEventType(e.Type),
					Object: e.Object,
				}
				select {
				case lw.OutCh <- &ev:
				case <-wstream.Context().Done():
					close(lw.OutCh)
					return
				}
			}
		}
	}
	lw := listerwatcher.NewWatcherClient(wstream, bridgefn)
	lw.Run()
	return lw, nil
}

func (a *grpcObjSecurityV1SecurityGroup) Allowed(oper apiserver.APIOperType) bool {
	return true
}

type restObjSecurityV1SecurityGroup struct {
	endpoints security.EndpointsSecurityV1RestClient
	instance  string
}

func (a *restObjSecurityV1SecurityGroup) Create(ctx context.Context, in *security.SecurityGroup) (*security.SecurityGroup, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoAddSecurityGroup(ctx, in)
}

func (a *restObjSecurityV1SecurityGroup) Update(ctx context.Context, in *security.SecurityGroup) (*security.SecurityGroup, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoUpdateSecurityGroup(ctx, in)
}

func (a *restObjSecurityV1SecurityGroup) Get(ctx context.Context, objMeta *api.ObjectMeta) (*security.SecurityGroup, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := security.SecurityGroup{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoGetSecurityGroup(ctx, &in)
}

func (a *restObjSecurityV1SecurityGroup) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*security.SecurityGroup, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := security.SecurityGroup{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoDeleteSecurityGroup(ctx, &in)
}

func (a *restObjSecurityV1SecurityGroup) List(ctx context.Context, options *api.ListWatchOptions) ([]*security.SecurityGroup, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}
	r, err := a.endpoints.AutoListSecurityGroup(ctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *restObjSecurityV1SecurityGroup) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}
	// XXX-TODO(sanjayt): add rest client handler for chunked stream
	return nil, nil
}

func (a *restObjSecurityV1SecurityGroup) Allowed(oper apiserver.APIOperType) bool {
	switch oper {
	case apiserver.CreateOper:
		return true
	case apiserver.UpdateOper:
		return true
	case apiserver.GetOper:
		return true
	case apiserver.DeleteOper:
		return true
	case apiserver.ListOper:
		return true
	case apiserver.WatchOper:
		return true
	default:
		return false
	}
}

type grpcObjSecurityV1Sgpolicy struct {
	logger log.Logger
	client security.ServiceSecurityV1Client
}

func (a *grpcObjSecurityV1Sgpolicy) Create(ctx context.Context, in *security.Sgpolicy) (*security.Sgpolicy, error) {
	a.logger.DebugLog("msg", "received call", "object", "Sgpolicy", "oper", "create")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoAddSgpolicy(nctx, in)
}

func (a *grpcObjSecurityV1Sgpolicy) Update(ctx context.Context, in *security.Sgpolicy) (*security.Sgpolicy, error) {
	a.logger.DebugLog("msg", "received call", "object", "Sgpolicy", "oper", "update")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoUpdateSgpolicy(nctx, in)
}

func (a *grpcObjSecurityV1Sgpolicy) Get(ctx context.Context, objMeta *api.ObjectMeta) (*security.Sgpolicy, error) {
	a.logger.DebugLog("msg", "received call", "object", "Sgpolicy", "oper", "get")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := security.Sgpolicy{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoGetSgpolicy(nctx, &in)
}

func (a *grpcObjSecurityV1Sgpolicy) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*security.Sgpolicy, error) {
	a.logger.DebugLog("msg", "received call", "object", "Sgpolicy", "oper", "delete")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := security.Sgpolicy{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoDeleteSgpolicy(nctx, &in)
}

func (a *grpcObjSecurityV1Sgpolicy) List(ctx context.Context, options *api.ListWatchOptions) ([]*security.Sgpolicy, error) {
	a.logger.DebugLog("msg", "received call", "object", "Sgpolicy", "oper", "list")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	r, err := a.client.AutoListSgpolicy(nctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *grpcObjSecurityV1Sgpolicy) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	a.logger.DebugLog("msg", "received call", "object", "Sgpolicy", "oper", "WatchOper")
	nctx := addVersion(ctx, "v1")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	stream, err := a.client.AutoWatchSgpolicy(nctx, options)
	if err != nil {
		return nil, err
	}
	wstream := stream.(security.SecurityV1_AutoWatchSgpolicyClient)
	bridgefn := func(lw *listerwatcher.WatcherClient) {
		for {
			r, err := wstream.Recv()
			if err != nil {
				a.logger.ErrorLog("msg", "error on receive", "error", err)
				close(lw.OutCh)
				return
			}
			for _, e := range r.Events {
				ev := kvstore.WatchEvent{
					Type:   kvstore.WatchEventType(e.Type),
					Object: e.Object,
				}
				select {
				case lw.OutCh <- &ev:
				case <-wstream.Context().Done():
					close(lw.OutCh)
					return
				}
			}
		}
	}
	lw := listerwatcher.NewWatcherClient(wstream, bridgefn)
	lw.Run()
	return lw, nil
}

func (a *grpcObjSecurityV1Sgpolicy) Allowed(oper apiserver.APIOperType) bool {
	return true
}

type restObjSecurityV1Sgpolicy struct {
	endpoints security.EndpointsSecurityV1RestClient
	instance  string
}

func (a *restObjSecurityV1Sgpolicy) Create(ctx context.Context, in *security.Sgpolicy) (*security.Sgpolicy, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoAddSgpolicy(ctx, in)
}

func (a *restObjSecurityV1Sgpolicy) Update(ctx context.Context, in *security.Sgpolicy) (*security.Sgpolicy, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoUpdateSgpolicy(ctx, in)
}

func (a *restObjSecurityV1Sgpolicy) Get(ctx context.Context, objMeta *api.ObjectMeta) (*security.Sgpolicy, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := security.Sgpolicy{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoGetSgpolicy(ctx, &in)
}

func (a *restObjSecurityV1Sgpolicy) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*security.Sgpolicy, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := security.Sgpolicy{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoDeleteSgpolicy(ctx, &in)
}

func (a *restObjSecurityV1Sgpolicy) List(ctx context.Context, options *api.ListWatchOptions) ([]*security.Sgpolicy, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}
	r, err := a.endpoints.AutoListSgpolicy(ctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *restObjSecurityV1Sgpolicy) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}
	// XXX-TODO(sanjayt): add rest client handler for chunked stream
	return nil, nil
}

func (a *restObjSecurityV1Sgpolicy) Allowed(oper apiserver.APIOperType) bool {
	switch oper {
	case apiserver.CreateOper:
		return true
	case apiserver.UpdateOper:
		return true
	case apiserver.GetOper:
		return true
	case apiserver.DeleteOper:
		return true
	case apiserver.ListOper:
		return true
	case apiserver.WatchOper:
		return true
	default:
		return false
	}
}

type grpcObjSecurityV1App struct {
	logger log.Logger
	client security.ServiceSecurityV1Client
}

func (a *grpcObjSecurityV1App) Create(ctx context.Context, in *security.App) (*security.App, error) {
	a.logger.DebugLog("msg", "received call", "object", "App", "oper", "create")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoAddApp(nctx, in)
}

func (a *grpcObjSecurityV1App) Update(ctx context.Context, in *security.App) (*security.App, error) {
	a.logger.DebugLog("msg", "received call", "object", "App", "oper", "update")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoUpdateApp(nctx, in)
}

func (a *grpcObjSecurityV1App) Get(ctx context.Context, objMeta *api.ObjectMeta) (*security.App, error) {
	a.logger.DebugLog("msg", "received call", "object", "App", "oper", "get")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := security.App{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoGetApp(nctx, &in)
}

func (a *grpcObjSecurityV1App) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*security.App, error) {
	a.logger.DebugLog("msg", "received call", "object", "App", "oper", "delete")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := security.App{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoDeleteApp(nctx, &in)
}

func (a *grpcObjSecurityV1App) List(ctx context.Context, options *api.ListWatchOptions) ([]*security.App, error) {
	a.logger.DebugLog("msg", "received call", "object", "App", "oper", "list")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	r, err := a.client.AutoListApp(nctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *grpcObjSecurityV1App) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	a.logger.DebugLog("msg", "received call", "object", "App", "oper", "WatchOper")
	nctx := addVersion(ctx, "v1")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	stream, err := a.client.AutoWatchApp(nctx, options)
	if err != nil {
		return nil, err
	}
	wstream := stream.(security.SecurityV1_AutoWatchAppClient)
	bridgefn := func(lw *listerwatcher.WatcherClient) {
		for {
			r, err := wstream.Recv()
			if err != nil {
				a.logger.ErrorLog("msg", "error on receive", "error", err)
				close(lw.OutCh)
				return
			}
			for _, e := range r.Events {
				ev := kvstore.WatchEvent{
					Type:   kvstore.WatchEventType(e.Type),
					Object: e.Object,
				}
				select {
				case lw.OutCh <- &ev:
				case <-wstream.Context().Done():
					close(lw.OutCh)
					return
				}
			}
		}
	}
	lw := listerwatcher.NewWatcherClient(wstream, bridgefn)
	lw.Run()
	return lw, nil
}

func (a *grpcObjSecurityV1App) Allowed(oper apiserver.APIOperType) bool {
	return true
}

type restObjSecurityV1App struct {
	endpoints security.EndpointsSecurityV1RestClient
	instance  string
}

func (a *restObjSecurityV1App) Create(ctx context.Context, in *security.App) (*security.App, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoAddApp(ctx, in)
}

func (a *restObjSecurityV1App) Update(ctx context.Context, in *security.App) (*security.App, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoUpdateApp(ctx, in)
}

func (a *restObjSecurityV1App) Get(ctx context.Context, objMeta *api.ObjectMeta) (*security.App, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := security.App{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoGetApp(ctx, &in)
}

func (a *restObjSecurityV1App) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*security.App, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := security.App{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoDeleteApp(ctx, &in)
}

func (a *restObjSecurityV1App) List(ctx context.Context, options *api.ListWatchOptions) ([]*security.App, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}
	r, err := a.endpoints.AutoListApp(ctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *restObjSecurityV1App) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}
	// XXX-TODO(sanjayt): add rest client handler for chunked stream
	return nil, nil
}

func (a *restObjSecurityV1App) Allowed(oper apiserver.APIOperType) bool {
	switch oper {
	case apiserver.CreateOper:
		return true
	case apiserver.UpdateOper:
		return true
	case apiserver.GetOper:
		return true
	case apiserver.DeleteOper:
		return true
	case apiserver.ListOper:
		return true
	case apiserver.WatchOper:
		return true
	default:
		return false
	}
}

type grpcObjSecurityV1Certificate struct {
	logger log.Logger
	client security.ServiceSecurityV1Client
}

func (a *grpcObjSecurityV1Certificate) Create(ctx context.Context, in *security.Certificate) (*security.Certificate, error) {
	a.logger.DebugLog("msg", "received call", "object", "Certificate", "oper", "create")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoAddCertificate(nctx, in)
}

func (a *grpcObjSecurityV1Certificate) Update(ctx context.Context, in *security.Certificate) (*security.Certificate, error) {
	a.logger.DebugLog("msg", "received call", "object", "Certificate", "oper", "update")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoUpdateCertificate(nctx, in)
}

func (a *grpcObjSecurityV1Certificate) Get(ctx context.Context, objMeta *api.ObjectMeta) (*security.Certificate, error) {
	a.logger.DebugLog("msg", "received call", "object", "Certificate", "oper", "get")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := security.Certificate{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoGetCertificate(nctx, &in)
}

func (a *grpcObjSecurityV1Certificate) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*security.Certificate, error) {
	a.logger.DebugLog("msg", "received call", "object", "Certificate", "oper", "delete")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := security.Certificate{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoDeleteCertificate(nctx, &in)
}

func (a *grpcObjSecurityV1Certificate) List(ctx context.Context, options *api.ListWatchOptions) ([]*security.Certificate, error) {
	a.logger.DebugLog("msg", "received call", "object", "Certificate", "oper", "list")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	r, err := a.client.AutoListCertificate(nctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *grpcObjSecurityV1Certificate) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	a.logger.DebugLog("msg", "received call", "object", "Certificate", "oper", "WatchOper")
	nctx := addVersion(ctx, "v1")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	stream, err := a.client.AutoWatchCertificate(nctx, options)
	if err != nil {
		return nil, err
	}
	wstream := stream.(security.SecurityV1_AutoWatchCertificateClient)
	bridgefn := func(lw *listerwatcher.WatcherClient) {
		for {
			r, err := wstream.Recv()
			if err != nil {
				a.logger.ErrorLog("msg", "error on receive", "error", err)
				close(lw.OutCh)
				return
			}
			for _, e := range r.Events {
				ev := kvstore.WatchEvent{
					Type:   kvstore.WatchEventType(e.Type),
					Object: e.Object,
				}
				select {
				case lw.OutCh <- &ev:
				case <-wstream.Context().Done():
					close(lw.OutCh)
					return
				}
			}
		}
	}
	lw := listerwatcher.NewWatcherClient(wstream, bridgefn)
	lw.Run()
	return lw, nil
}

func (a *grpcObjSecurityV1Certificate) Allowed(oper apiserver.APIOperType) bool {
	return true
}

type restObjSecurityV1Certificate struct {
	endpoints security.EndpointsSecurityV1RestClient
	instance  string
}

func (a *restObjSecurityV1Certificate) Create(ctx context.Context, in *security.Certificate) (*security.Certificate, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoAddCertificate(ctx, in)
}

func (a *restObjSecurityV1Certificate) Update(ctx context.Context, in *security.Certificate) (*security.Certificate, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoUpdateCertificate(ctx, in)
}

func (a *restObjSecurityV1Certificate) Get(ctx context.Context, objMeta *api.ObjectMeta) (*security.Certificate, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := security.Certificate{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoGetCertificate(ctx, &in)
}

func (a *restObjSecurityV1Certificate) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*security.Certificate, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := security.Certificate{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoDeleteCertificate(ctx, &in)
}

func (a *restObjSecurityV1Certificate) List(ctx context.Context, options *api.ListWatchOptions) ([]*security.Certificate, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}
	r, err := a.endpoints.AutoListCertificate(ctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *restObjSecurityV1Certificate) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}
	// XXX-TODO(sanjayt): add rest client handler for chunked stream
	return nil, nil
}

func (a *restObjSecurityV1Certificate) Allowed(oper apiserver.APIOperType) bool {
	switch oper {
	case apiserver.CreateOper:
		return true
	case apiserver.UpdateOper:
		return true
	case apiserver.GetOper:
		return true
	case apiserver.DeleteOper:
		return true
	case apiserver.ListOper:
		return true
	case apiserver.WatchOper:
		return true
	default:
		return false
	}
}

type grpcObjSecurityV1TrafficEncryptionPolicy struct {
	logger log.Logger
	client security.ServiceSecurityV1Client
}

func (a *grpcObjSecurityV1TrafficEncryptionPolicy) Create(ctx context.Context, in *security.TrafficEncryptionPolicy) (*security.TrafficEncryptionPolicy, error) {
	a.logger.DebugLog("msg", "received call", "object", "TrafficEncryptionPolicy", "oper", "create")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoAddTrafficEncryptionPolicy(nctx, in)
}

func (a *grpcObjSecurityV1TrafficEncryptionPolicy) Update(ctx context.Context, in *security.TrafficEncryptionPolicy) (*security.TrafficEncryptionPolicy, error) {
	a.logger.DebugLog("msg", "received call", "object", "TrafficEncryptionPolicy", "oper", "update")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoUpdateTrafficEncryptionPolicy(nctx, in)
}

func (a *grpcObjSecurityV1TrafficEncryptionPolicy) Get(ctx context.Context, objMeta *api.ObjectMeta) (*security.TrafficEncryptionPolicy, error) {
	a.logger.DebugLog("msg", "received call", "object", "TrafficEncryptionPolicy", "oper", "get")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := security.TrafficEncryptionPolicy{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoGetTrafficEncryptionPolicy(nctx, &in)
}

func (a *grpcObjSecurityV1TrafficEncryptionPolicy) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*security.TrafficEncryptionPolicy, error) {
	a.logger.DebugLog("msg", "received call", "object", "TrafficEncryptionPolicy", "oper", "delete")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := security.TrafficEncryptionPolicy{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoDeleteTrafficEncryptionPolicy(nctx, &in)
}

func (a *grpcObjSecurityV1TrafficEncryptionPolicy) List(ctx context.Context, options *api.ListWatchOptions) ([]*security.TrafficEncryptionPolicy, error) {
	a.logger.DebugLog("msg", "received call", "object", "TrafficEncryptionPolicy", "oper", "list")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	r, err := a.client.AutoListTrafficEncryptionPolicy(nctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *grpcObjSecurityV1TrafficEncryptionPolicy) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	a.logger.DebugLog("msg", "received call", "object", "TrafficEncryptionPolicy", "oper", "WatchOper")
	nctx := addVersion(ctx, "v1")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	stream, err := a.client.AutoWatchTrafficEncryptionPolicy(nctx, options)
	if err != nil {
		return nil, err
	}
	wstream := stream.(security.SecurityV1_AutoWatchTrafficEncryptionPolicyClient)
	bridgefn := func(lw *listerwatcher.WatcherClient) {
		for {
			r, err := wstream.Recv()
			if err != nil {
				a.logger.ErrorLog("msg", "error on receive", "error", err)
				close(lw.OutCh)
				return
			}
			for _, e := range r.Events {
				ev := kvstore.WatchEvent{
					Type:   kvstore.WatchEventType(e.Type),
					Object: e.Object,
				}
				select {
				case lw.OutCh <- &ev:
				case <-wstream.Context().Done():
					close(lw.OutCh)
					return
				}
			}
		}
	}
	lw := listerwatcher.NewWatcherClient(wstream, bridgefn)
	lw.Run()
	return lw, nil
}

func (a *grpcObjSecurityV1TrafficEncryptionPolicy) Allowed(oper apiserver.APIOperType) bool {
	return true
}

type restObjSecurityV1TrafficEncryptionPolicy struct {
	endpoints security.EndpointsSecurityV1RestClient
	instance  string
}

func (a *restObjSecurityV1TrafficEncryptionPolicy) Create(ctx context.Context, in *security.TrafficEncryptionPolicy) (*security.TrafficEncryptionPolicy, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoAddTrafficEncryptionPolicy(ctx, in)
}

func (a *restObjSecurityV1TrafficEncryptionPolicy) Update(ctx context.Context, in *security.TrafficEncryptionPolicy) (*security.TrafficEncryptionPolicy, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoUpdateTrafficEncryptionPolicy(ctx, in)
}

func (a *restObjSecurityV1TrafficEncryptionPolicy) Get(ctx context.Context, objMeta *api.ObjectMeta) (*security.TrafficEncryptionPolicy, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := security.TrafficEncryptionPolicy{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoGetTrafficEncryptionPolicy(ctx, &in)
}

func (a *restObjSecurityV1TrafficEncryptionPolicy) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*security.TrafficEncryptionPolicy, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := security.TrafficEncryptionPolicy{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoDeleteTrafficEncryptionPolicy(ctx, &in)
}

func (a *restObjSecurityV1TrafficEncryptionPolicy) List(ctx context.Context, options *api.ListWatchOptions) ([]*security.TrafficEncryptionPolicy, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}
	r, err := a.endpoints.AutoListTrafficEncryptionPolicy(ctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *restObjSecurityV1TrafficEncryptionPolicy) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}
	// XXX-TODO(sanjayt): add rest client handler for chunked stream
	return nil, nil
}

func (a *restObjSecurityV1TrafficEncryptionPolicy) Allowed(oper apiserver.APIOperType) bool {
	switch oper {
	case apiserver.CreateOper:
		return true
	case apiserver.UpdateOper:
		return true
	case apiserver.GetOper:
		return true
	case apiserver.DeleteOper:
		return true
	case apiserver.ListOper:
		return false
	case apiserver.WatchOper:
		return true
	default:
		return false
	}
}

type crudClientSecurityV1 struct {
	logger log.Logger
	client security.ServiceSecurityV1Client

	grpcSecurityGroup           security.SecurityV1SecurityGroupInterface
	grpcSgpolicy                security.SecurityV1SgpolicyInterface
	grpcApp                     security.SecurityV1AppInterface
	grpcCertificate             security.SecurityV1CertificateInterface
	grpcTrafficEncryptionPolicy security.SecurityV1TrafficEncryptionPolicyInterface
}

// NewGrpcCrudClientSecurityV1 creates a GRPC client for the service
func NewGrpcCrudClientSecurityV1(conn *grpc.ClientConn, logger log.Logger) security.SecurityV1Interface {
	client := NewSecurityV1Backend(conn, logger)
	return &crudClientSecurityV1{
		logger: logger,
		client: client,

		grpcSecurityGroup:           &grpcObjSecurityV1SecurityGroup{client: client, logger: logger},
		grpcSgpolicy:                &grpcObjSecurityV1Sgpolicy{client: client, logger: logger},
		grpcApp:                     &grpcObjSecurityV1App{client: client, logger: logger},
		grpcCertificate:             &grpcObjSecurityV1Certificate{client: client, logger: logger},
		grpcTrafficEncryptionPolicy: &grpcObjSecurityV1TrafficEncryptionPolicy{client: client, logger: logger},
	}
}

func (a *crudClientSecurityV1) SecurityGroup() security.SecurityV1SecurityGroupInterface {
	return a.grpcSecurityGroup
}

func (a *crudClientSecurityV1) Sgpolicy() security.SecurityV1SgpolicyInterface {
	return a.grpcSgpolicy
}

func (a *crudClientSecurityV1) App() security.SecurityV1AppInterface {
	return a.grpcApp
}

func (a *crudClientSecurityV1) Certificate() security.SecurityV1CertificateInterface {
	return a.grpcCertificate
}

func (a *crudClientSecurityV1) TrafficEncryptionPolicy() security.SecurityV1TrafficEncryptionPolicyInterface {
	return a.grpcTrafficEncryptionPolicy
}

func (a *crudClientSecurityV1) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	a.logger.DebugLog("msg", "received call", "object", "SecurityV1", "oper", "WatchOper")
	nctx := addVersion(ctx, "v1")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	stream, err := a.client.AutoWatchSvcSecurityV1(nctx, options)
	if err != nil {
		return nil, err
	}
	wstream := stream.(security.SecurityV1_AutoWatchSvcSecurityV1Client)
	bridgefn := func(lw *listerwatcher.WatcherClient) {
		for {
			r, err := wstream.Recv()
			if err != nil {
				a.logger.ErrorLog("msg", "error on receive", "error", err)
				close(lw.OutCh)
				return
			}
			for _, e := range r.Events {
				ev := kvstore.WatchEvent{Type: kvstore.WatchEventType(e.Type)}
				robj, err := listerwatcher.GetObject(e)
				if err != nil {
					a.logger.ErrorLog("msg", "error on receive unmarshall", "error", err)
					close(lw.OutCh)
					return
				}
				ev.Object = robj
				select {
				case lw.OutCh <- &ev:
				case <-wstream.Context().Done():
					close(lw.OutCh)
					return
				}
			}
		}
	}
	lw := listerwatcher.NewWatcherClient(wstream, bridgefn)
	lw.Run()
	return lw, nil
}

type crudRestClientSecurityV1 struct {
	restSecurityGroup           security.SecurityV1SecurityGroupInterface
	restSgpolicy                security.SecurityV1SgpolicyInterface
	restApp                     security.SecurityV1AppInterface
	restCertificate             security.SecurityV1CertificateInterface
	restTrafficEncryptionPolicy security.SecurityV1TrafficEncryptionPolicyInterface
}

// NewRestCrudClientSecurityV1 creates a REST client for the service.
func NewRestCrudClientSecurityV1(url string) security.SecurityV1Interface {
	endpoints, err := security.MakeSecurityV1RestClientEndpoints(url)
	if err != nil {
		oldlog.Fatal("failed to create client")
	}
	return &crudRestClientSecurityV1{

		restSecurityGroup:           &restObjSecurityV1SecurityGroup{endpoints: endpoints, instance: url},
		restSgpolicy:                &restObjSecurityV1Sgpolicy{endpoints: endpoints, instance: url},
		restApp:                     &restObjSecurityV1App{endpoints: endpoints, instance: url},
		restCertificate:             &restObjSecurityV1Certificate{endpoints: endpoints, instance: url},
		restTrafficEncryptionPolicy: &restObjSecurityV1TrafficEncryptionPolicy{endpoints: endpoints, instance: url},
	}
}

func (a *crudRestClientSecurityV1) SecurityGroup() security.SecurityV1SecurityGroupInterface {
	return a.restSecurityGroup
}

func (a *crudRestClientSecurityV1) Sgpolicy() security.SecurityV1SgpolicyInterface {
	return a.restSgpolicy
}

func (a *crudRestClientSecurityV1) App() security.SecurityV1AppInterface {
	return a.restApp
}

func (a *crudRestClientSecurityV1) Certificate() security.SecurityV1CertificateInterface {
	return a.restCertificate
}

func (a *crudRestClientSecurityV1) TrafficEncryptionPolicy() security.SecurityV1TrafficEncryptionPolicyInterface {
	return a.restTrafficEncryptionPolicy
}

func (a *crudRestClientSecurityV1) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	return nil, errors.New("method unimplemented")
}
