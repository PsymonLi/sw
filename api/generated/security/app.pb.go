// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: app.proto

/*
	Package security is a generated protocol buffer package.

	It is generated from these files:
		app.proto
		networkencryption.proto
		securitygroup.proto
		sgpolicy.proto
		svc_security.proto
		x509.proto

	It has these top-level messages:
		ALG
		App
		AppSpec
		AppStatus
		DNS
		FTP
		MSRPC
		RSTP
		SIP
		SunRPC
		TFTP
		IPsecProtocolSpec
		TLSProtocolSpec
		TrafficEncryptionPolicy
		TrafficEncryptionPolicySpec
		TrafficEncryptionPolicyStatus
		SecurityGroup
		SecurityGroupSpec
		SecurityGroupStatus
		SGPolicy
		SGPolicyPropagationStatus
		SGPolicySpec
		SGPolicyStatus
		SGRule
		AppList
		AutoMsgAppWatchHelper
		AutoMsgCertificateWatchHelper
		AutoMsgSGPolicyWatchHelper
		AutoMsgSecurityGroupWatchHelper
		AutoMsgTrafficEncryptionPolicyWatchHelper
		CertificateList
		SGPolicyList
		SecurityGroupList
		TrafficEncryptionPolicyList
		Certificate
		CertificateSpec
		CertificateStatus
*/
package security

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/pensando/grpc-gateway/third_party/googleapis/google/api"
import _ "github.com/pensando/sw/venice/utils/apigen/annotations"
import _ "github.com/gogo/protobuf/gogoproto"
import api "github.com/pensando/sw/api"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// ALG specifies the application specific configuration for the list of applications mentioned below.
// TODO Investigate configuration for other ALGs
type ALG struct {
	//
	DNS *DNS `protobuf:"bytes,1,opt,name=DNS,json=dns,omitempty" json:"dns,omitempty"`
	//
	SIP *SIP `protobuf:"bytes,2,opt,name=SIP,json=sip,omitempty" json:"sip,omitempty"`
	//
	SunRPC *SunRPC `protobuf:"bytes,3,opt,name=SunRPC,json=sunrpc,omitempty" json:"sunrpc,omitempty"`
	//
	FTP *FTP `protobuf:"bytes,4,opt,name=FTP,json=ftp,omitempty" json:"ftp,omitempty"`
	//
	MSRPC *MSRPC `protobuf:"bytes,5,opt,name=MSRPC,json=msrpc,omitempty" json:"msrpc,omitempty"`
	//
	TFTP *TFTP `protobuf:"bytes,6,opt,name=TFTP,json=tftp,omitempty" json:"tftp,omitempty"`
	//
	RSTP *RSTP `protobuf:"bytes,7,opt,name=RSTP,json=rstp,omitempty" json:"rstp,omitempty"`
}

func (m *ALG) Reset()                    { *m = ALG{} }
func (m *ALG) String() string            { return proto.CompactTextString(m) }
func (*ALG) ProtoMessage()               {}
func (*ALG) Descriptor() ([]byte, []int) { return fileDescriptorApp, []int{0} }

func (m *ALG) GetDNS() *DNS {
	if m != nil {
		return m.DNS
	}
	return nil
}

func (m *ALG) GetSIP() *SIP {
	if m != nil {
		return m.SIP
	}
	return nil
}

func (m *ALG) GetSunRPC() *SunRPC {
	if m != nil {
		return m.SunRPC
	}
	return nil
}

func (m *ALG) GetFTP() *FTP {
	if m != nil {
		return m.FTP
	}
	return nil
}

func (m *ALG) GetMSRPC() *MSRPC {
	if m != nil {
		return m.MSRPC
	}
	return nil
}

func (m *ALG) GetTFTP() *TFTP {
	if m != nil {
		return m.TFTP
	}
	return nil
}

func (m *ALG) GetRSTP() *RSTP {
	if m != nil {
		return m.RSTP
	}
	return nil
}

// App - Read-only objects auto-created by Venice
// One object per App that can be identified by Naples
type App struct {
	//
	api.TypeMeta `protobuf:"bytes,1,opt,name=T,json=,inline,embedded=T" json:",inline"`
	//
	api.ObjectMeta `protobuf:"bytes,2,opt,name=O,json=meta,omitempty,embedded=O" json:"meta,omitempty"`
	//
	Spec AppSpec `protobuf:"bytes,3,opt,name=Spec,json=spec,omitempty" json:"spec,omitempty"`
	//
	Status AppStatus `protobuf:"bytes,4,opt,name=Status,json=status,omitempty" json:"status,omitempty"`
}

func (m *App) Reset()                    { *m = App{} }
func (m *App) String() string            { return proto.CompactTextString(m) }
func (*App) ProtoMessage()               {}
func (*App) Descriptor() ([]byte, []int) { return fileDescriptorApp, []int{1} }

func (m *App) GetSpec() AppSpec {
	if m != nil {
		return m.Spec
	}
	return AppSpec{}
}

func (m *App) GetStatus() AppStatus {
	if m != nil {
		return m.Status
	}
	return AppStatus{}
}

// AppSpec - spec part of App object
type AppSpec struct {
	// List of proto/port
	Protocol []string `protobuf:"bytes,1,rep,name=Protocol,json=protocol,omitempty" json:"protocol,omitempty"`
	// ALG configuration if specified
	ALG *ALG `protobuf:"bytes,2,opt,name=ALG,json=alg,omitempty" json:"alg,omitempty"`
}

func (m *AppSpec) Reset()                    { *m = AppSpec{} }
func (m *AppSpec) String() string            { return proto.CompactTextString(m) }
func (*AppSpec) ProtoMessage()               {}
func (*AppSpec) Descriptor() ([]byte, []int) { return fileDescriptorApp, []int{2} }

func (m *AppSpec) GetProtocol() []string {
	if m != nil {
		return m.Protocol
	}
	return nil
}

func (m *AppSpec) GetALG() *ALG {
	if m != nil {
		return m.ALG
	}
	return nil
}

// AppStatus - status part of App object
type AppStatus struct {
	// List of security group policies attached to the app
	AttachedPolicies []string `protobuf:"bytes,1,rep,name=AttachedPolicies,json=attached-policies,omitempty" json:"attached-policies,omitempty"`
}

func (m *AppStatus) Reset()                    { *m = AppStatus{} }
func (m *AppStatus) String() string            { return proto.CompactTextString(m) }
func (*AppStatus) ProtoMessage()               {}
func (*AppStatus) Descriptor() ([]byte, []int) { return fileDescriptorApp, []int{3} }

func (m *AppStatus) GetAttachedPolicies() []string {
	if m != nil {
		return m.AttachedPolicies
	}
	return nil
}

// DNS ALG configuration
type DNS struct {
	//
	DropMultiQuestionPackets bool `protobuf:"varint,1,opt,name=DropMultiQuestionPackets,json=drop-multi-question-packets,omitempty,proto3" json:"drop-multi-question-packets,omitempty"`
}

func (m *DNS) Reset()                    { *m = DNS{} }
func (m *DNS) String() string            { return proto.CompactTextString(m) }
func (*DNS) ProtoMessage()               {}
func (*DNS) Descriptor() ([]byte, []int) { return fileDescriptorApp, []int{4} }

func (m *DNS) GetDropMultiQuestionPackets() bool {
	if m != nil {
		return m.DropMultiQuestionPackets
	}
	return false
}

// FTP ALG configuration
type FTP struct {
}

func (m *FTP) Reset()                    { *m = FTP{} }
func (m *FTP) String() string            { return proto.CompactTextString(m) }
func (*FTP) ProtoMessage()               {}
func (*FTP) Descriptor() ([]byte, []int) { return fileDescriptorApp, []int{5} }

// MSRPC ALG configuration
type MSRPC struct {
}

func (m *MSRPC) Reset()                    { *m = MSRPC{} }
func (m *MSRPC) String() string            { return proto.CompactTextString(m) }
func (*MSRPC) ProtoMessage()               {}
func (*MSRPC) Descriptor() ([]byte, []int) { return fileDescriptorApp, []int{6} }

// RSTP ALG configuration
type RSTP struct {
}

func (m *RSTP) Reset()                    { *m = RSTP{} }
func (m *RSTP) String() string            { return proto.CompactTextString(m) }
func (*RSTP) ProtoMessage()               {}
func (*RSTP) Descriptor() ([]byte, []int) { return fileDescriptorApp, []int{7} }

// SIP ALG configuration
type SIP struct {
	//
	MaxCallDuration uint32 `protobuf:"varint,1,opt,name=MaxCallDuration,json=max-call-duration,omitemtpy,proto3" json:"max-call-duration,omitemtpy"`
}

func (m *SIP) Reset()                    { *m = SIP{} }
func (m *SIP) String() string            { return proto.CompactTextString(m) }
func (*SIP) ProtoMessage()               {}
func (*SIP) Descriptor() ([]byte, []int) { return fileDescriptorApp, []int{8} }

func (m *SIP) GetMaxCallDuration() uint32 {
	if m != nil {
		return m.MaxCallDuration
	}
	return 0
}

// SunRPC ALG configuration
type SunRPC struct {
	// RPC Program identifier
	ProgramID string `protobuf:"bytes,1,opt,name=ProgramID,json=program-id,omitempty,proto3" json:"program-id,omitempty"`
	// Defines timeout in hours, minutes, eg 24h, 300m
	MapEntryTimeout string `protobuf:"bytes,2,opt,name=MapEntryTimeout,json=map-entry-timeout,proto3" json:"map-entry-timeout"`
}

func (m *SunRPC) Reset()                    { *m = SunRPC{} }
func (m *SunRPC) String() string            { return proto.CompactTextString(m) }
func (*SunRPC) ProtoMessage()               {}
func (*SunRPC) Descriptor() ([]byte, []int) { return fileDescriptorApp, []int{9} }

func (m *SunRPC) GetProgramID() string {
	if m != nil {
		return m.ProgramID
	}
	return ""
}

func (m *SunRPC) GetMapEntryTimeout() string {
	if m != nil {
		return m.MapEntryTimeout
	}
	return ""
}

// TFTP ALG configuration
type TFTP struct {
}

func (m *TFTP) Reset()                    { *m = TFTP{} }
func (m *TFTP) String() string            { return proto.CompactTextString(m) }
func (*TFTP) ProtoMessage()               {}
func (*TFTP) Descriptor() ([]byte, []int) { return fileDescriptorApp, []int{10} }

func init() {
	proto.RegisterType((*ALG)(nil), "security.ALG")
	proto.RegisterType((*App)(nil), "security.App")
	proto.RegisterType((*AppSpec)(nil), "security.AppSpec")
	proto.RegisterType((*AppStatus)(nil), "security.AppStatus")
	proto.RegisterType((*DNS)(nil), "security.DNS")
	proto.RegisterType((*FTP)(nil), "security.FTP")
	proto.RegisterType((*MSRPC)(nil), "security.MSRPC")
	proto.RegisterType((*RSTP)(nil), "security.RSTP")
	proto.RegisterType((*SIP)(nil), "security.SIP")
	proto.RegisterType((*SunRPC)(nil), "security.SunRPC")
	proto.RegisterType((*TFTP)(nil), "security.TFTP")
}
func (m *ALG) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ALG) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.DNS != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApp(dAtA, i, uint64(m.DNS.Size()))
		n1, err := m.DNS.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.SIP != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApp(dAtA, i, uint64(m.SIP.Size()))
		n2, err := m.SIP.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.SunRPC != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintApp(dAtA, i, uint64(m.SunRPC.Size()))
		n3, err := m.SunRPC.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.FTP != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintApp(dAtA, i, uint64(m.FTP.Size()))
		n4, err := m.FTP.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.MSRPC != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintApp(dAtA, i, uint64(m.MSRPC.Size()))
		n5, err := m.MSRPC.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.TFTP != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintApp(dAtA, i, uint64(m.TFTP.Size()))
		n6, err := m.TFTP.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.RSTP != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintApp(dAtA, i, uint64(m.RSTP.Size()))
		n7, err := m.RSTP.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	return i, nil
}

func (m *App) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *App) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintApp(dAtA, i, uint64(m.TypeMeta.Size()))
	n8, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n8
	dAtA[i] = 0x12
	i++
	i = encodeVarintApp(dAtA, i, uint64(m.ObjectMeta.Size()))
	n9, err := m.ObjectMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n9
	dAtA[i] = 0x1a
	i++
	i = encodeVarintApp(dAtA, i, uint64(m.Spec.Size()))
	n10, err := m.Spec.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n10
	dAtA[i] = 0x22
	i++
	i = encodeVarintApp(dAtA, i, uint64(m.Status.Size()))
	n11, err := m.Status.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n11
	return i, nil
}

func (m *AppSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Protocol) > 0 {
		for _, s := range m.Protocol {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.ALG != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApp(dAtA, i, uint64(m.ALG.Size()))
		n12, err := m.ALG.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	return i, nil
}

func (m *AppStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AttachedPolicies) > 0 {
		for _, s := range m.AttachedPolicies {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *DNS) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DNS) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.DropMultiQuestionPackets {
		dAtA[i] = 0x8
		i++
		if m.DropMultiQuestionPackets {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *FTP) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FTP) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *MSRPC) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MSRPC) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *RSTP) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RSTP) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *SIP) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SIP) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MaxCallDuration != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApp(dAtA, i, uint64(m.MaxCallDuration))
	}
	return i, nil
}

func (m *SunRPC) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SunRPC) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ProgramID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApp(dAtA, i, uint64(len(m.ProgramID)))
		i += copy(dAtA[i:], m.ProgramID)
	}
	if len(m.MapEntryTimeout) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApp(dAtA, i, uint64(len(m.MapEntryTimeout)))
		i += copy(dAtA[i:], m.MapEntryTimeout)
	}
	return i, nil
}

func (m *TFTP) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TFTP) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func encodeVarintApp(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *ALG) Size() (n int) {
	var l int
	_ = l
	if m.DNS != nil {
		l = m.DNS.Size()
		n += 1 + l + sovApp(uint64(l))
	}
	if m.SIP != nil {
		l = m.SIP.Size()
		n += 1 + l + sovApp(uint64(l))
	}
	if m.SunRPC != nil {
		l = m.SunRPC.Size()
		n += 1 + l + sovApp(uint64(l))
	}
	if m.FTP != nil {
		l = m.FTP.Size()
		n += 1 + l + sovApp(uint64(l))
	}
	if m.MSRPC != nil {
		l = m.MSRPC.Size()
		n += 1 + l + sovApp(uint64(l))
	}
	if m.TFTP != nil {
		l = m.TFTP.Size()
		n += 1 + l + sovApp(uint64(l))
	}
	if m.RSTP != nil {
		l = m.RSTP.Size()
		n += 1 + l + sovApp(uint64(l))
	}
	return n
}

func (m *App) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovApp(uint64(l))
	l = m.ObjectMeta.Size()
	n += 1 + l + sovApp(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovApp(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovApp(uint64(l))
	return n
}

func (m *AppSpec) Size() (n int) {
	var l int
	_ = l
	if len(m.Protocol) > 0 {
		for _, s := range m.Protocol {
			l = len(s)
			n += 1 + l + sovApp(uint64(l))
		}
	}
	if m.ALG != nil {
		l = m.ALG.Size()
		n += 1 + l + sovApp(uint64(l))
	}
	return n
}

func (m *AppStatus) Size() (n int) {
	var l int
	_ = l
	if len(m.AttachedPolicies) > 0 {
		for _, s := range m.AttachedPolicies {
			l = len(s)
			n += 1 + l + sovApp(uint64(l))
		}
	}
	return n
}

func (m *DNS) Size() (n int) {
	var l int
	_ = l
	if m.DropMultiQuestionPackets {
		n += 2
	}
	return n
}

func (m *FTP) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *MSRPC) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *RSTP) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *SIP) Size() (n int) {
	var l int
	_ = l
	if m.MaxCallDuration != 0 {
		n += 1 + sovApp(uint64(m.MaxCallDuration))
	}
	return n
}

func (m *SunRPC) Size() (n int) {
	var l int
	_ = l
	l = len(m.ProgramID)
	if l > 0 {
		n += 1 + l + sovApp(uint64(l))
	}
	l = len(m.MapEntryTimeout)
	if l > 0 {
		n += 1 + l + sovApp(uint64(l))
	}
	return n
}

func (m *TFTP) Size() (n int) {
	var l int
	_ = l
	return n
}

func sovApp(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozApp(x uint64) (n int) {
	return sovApp(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ALG) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ALG: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ALG: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DNS", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DNS == nil {
				m.DNS = &DNS{}
			}
			if err := m.DNS.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SIP", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SIP == nil {
				m.SIP = &SIP{}
			}
			if err := m.SIP.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SunRPC", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SunRPC == nil {
				m.SunRPC = &SunRPC{}
			}
			if err := m.SunRPC.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FTP", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FTP == nil {
				m.FTP = &FTP{}
			}
			if err := m.FTP.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MSRPC", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MSRPC == nil {
				m.MSRPC = &MSRPC{}
			}
			if err := m.MSRPC.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TFTP", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TFTP == nil {
				m.TFTP = &TFTP{}
			}
			if err := m.TFTP.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RSTP", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RSTP == nil {
				m.RSTP = &RSTP{}
			}
			if err := m.RSTP.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *App) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: App: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: App: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Protocol = append(m.Protocol, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ALG", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ALG == nil {
				m.ALG = &ALG{}
			}
			if err := m.ALG.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttachedPolicies", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AttachedPolicies = append(m.AttachedPolicies, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DNS) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DNS: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DNS: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropMultiQuestionPackets", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DropMultiQuestionPackets = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipApp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FTP) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FTP: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FTP: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipApp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MSRPC) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MSRPC: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MSRPC: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipApp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RSTP) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RSTP: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RSTP: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipApp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SIP) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SIP: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SIP: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxCallDuration", wireType)
			}
			m.MaxCallDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxCallDuration |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SunRPC) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SunRPC: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SunRPC: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProgramID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProgramID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapEntryTimeout", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MapEntryTimeout = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TFTP) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TFTP: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TFTP: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipApp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipApp(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowApp
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowApp
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowApp
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthApp
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowApp
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipApp(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthApp = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowApp   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("app.proto", fileDescriptorApp) }

var fileDescriptorApp = []byte{
	// 773 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x94, 0xcf, 0x4e, 0xfb, 0x46,
	0x10, 0xc7, 0x31, 0x09, 0x09, 0xd9, 0x16, 0x02, 0x4b, 0xff, 0x98, 0x3f, 0x22, 0xc8, 0x15, 0x12,
	0x07, 0x1c, 0x4b, 0xad, 0xd4, 0x43, 0x4f, 0xc4, 0x24, 0xa4, 0x48, 0x09, 0xb8, 0x71, 0x54, 0xa9,
	0xb7, 0x6e, 0x9c, 0xc5, 0x6c, 0x6b, 0x7b, 0xb7, 0xde, 0x35, 0x25, 0x87, 0x1e, 0x7b, 0xec, 0xb5,
	0x2f, 0xd1, 0x17, 0xe1, 0x88, 0xfa, 0x00, 0x51, 0xc5, 0x91, 0x4b, 0x5f, 0xa1, 0xda, 0xcd, 0x86,
	0xd8, 0x81, 0xa2, 0xdf, 0x2d, 0xf3, 0x9d, 0xd9, 0x4f, 0xbe, 0xe3, 0x9d, 0x1d, 0x50, 0x43, 0x8c,
	0x35, 0x59, 0x4a, 0x05, 0x85, 0xeb, 0x1c, 0x07, 0x59, 0x4a, 0xc4, 0x64, 0xef, 0x20, 0xa4, 0x34,
	0x8c, 0xb0, 0x83, 0x18, 0x71, 0x50, 0x92, 0x50, 0x81, 0x04, 0xa1, 0x09, 0x9f, 0xd5, 0xed, 0x75,
	0x42, 0x22, 0x6e, 0xb3, 0x51, 0x33, 0xa0, 0xb1, 0xc3, 0x70, 0xc2, 0x51, 0x32, 0xa6, 0x0e, 0xff,
	0xd5, 0xb9, 0xc3, 0x09, 0x09, 0xb0, 0x93, 0x09, 0x12, 0x71, 0x79, 0x34, 0xc4, 0x49, 0xfe, 0xb4,
	0x43, 0x92, 0x20, 0xca, 0xc6, 0x78, 0x8e, 0xb1, 0x73, 0x98, 0x90, 0x86, 0xd4, 0x51, 0xf2, 0x28,
	0xbb, 0x51, 0x91, 0x0a, 0xd4, 0x2f, 0x5d, 0x7e, 0xfc, 0x3f, 0xff, 0x2a, 0x3d, 0xc6, 0x58, 0xa0,
	0x59, 0x99, 0xf5, 0x6f, 0x09, 0x94, 0x5a, 0xbd, 0x2e, 0x3c, 0x03, 0xa5, 0xf6, 0x95, 0x6f, 0x1a,
	0x47, 0xc6, 0xc9, 0x47, 0x5f, 0x6e, 0x34, 0xe7, 0xad, 0x35, 0xdb, 0x57, 0xbe, 0xfb, 0xe9, 0xc3,
	0xb4, 0x61, 0x3c, 0x4f, 0x1b, 0x1b, 0xe3, 0x84, 0x9f, 0xd2, 0x98, 0x08, 0x1c, 0x33, 0x31, 0x19,
	0x14, 0x43, 0x49, 0xf0, 0x2f, 0x3d, 0x73, 0x75, 0x99, 0xe0, 0x5f, 0x7a, 0x0b, 0x02, 0x27, 0x2c,
	0x4f, 0x28, 0x84, 0xb0, 0x07, 0x2a, 0x7e, 0x96, 0x0c, 0xbc, 0x73, 0xb3, 0xa4, 0x20, 0x5b, 0x39,
	0x88, 0xd2, 0x5d, 0x53, 0x73, 0xb6, 0x78, 0x96, 0xa4, 0x2c, 0xc8, 0xa1, 0x5e, 0x29, 0xd2, 0xcf,
	0xc5, 0xd0, 0x33, 0xcb, 0xcb, 0x7e, 0x2e, 0x86, 0x39, 0x3f, 0x37, 0xa2, 0xe0, 0xa7, 0x10, 0xc2,
	0x6f, 0xc1, 0x5a, 0xdf, 0x97, 0x76, 0xd6, 0x14, 0xa3, 0xbe, 0x60, 0x28, 0xd9, 0xfd, 0x5c, 0x53,
	0xea, 0x31, 0x2f, 0x9a, 0x59, 0x16, 0x60, 0x1b, 0x94, 0x87, 0xd2, 0x4c, 0x45, 0x81, 0x36, 0x17,
	0x20, 0xa9, 0xba, 0x9f, 0x69, 0xce, 0xa6, 0x28, 0xda, 0x59, 0x8a, 0x25, 0x65, 0xe0, 0x0f, 0x3d,
	0xb3, 0xba, 0x4c, 0x91, 0xea, 0x82, 0x92, 0xf2, 0x22, 0xa5, 0x18, 0x5b, 0x7f, 0xad, 0x82, 0x52,
	0x8b, 0x31, 0xf8, 0x35, 0x30, 0x86, 0x2f, 0xf7, 0x8d, 0x18, 0x69, 0x0e, 0x27, 0x0c, 0xf7, 0xb1,
	0x40, 0xee, 0xce, 0xc3, 0xb4, 0xb1, 0xf2, 0x38, 0xa3, 0x55, 0x4f, 0x49, 0x12, 0x91, 0x04, 0x0f,
	0xe6, 0x3f, 0xe0, 0x05, 0x30, 0xae, 0xf5, 0x2d, 0xd7, 0xd5, 0xb9, 0xeb, 0xd1, 0x4f, 0x38, 0x10,
	0xea, 0xe4, 0x5e, 0xee, 0xe4, 0xa6, 0x9c, 0xb2, 0xbc, 0x8f, 0x62, 0x0c, 0xbb, 0xa0, 0xec, 0x33,
	0x1c, 0xe8, 0xbb, 0xde, 0x5e, 0x74, 0xd3, 0x62, 0x4c, 0x26, 0x54, 0x43, 0x2b, 0x12, 0xc4, 0x19,
	0xce, 0x7f, 0xdd, 0xa5, 0x18, 0x5e, 0x83, 0x8a, 0x2f, 0x90, 0xc8, 0xb8, 0xbe, 0xeb, 0x9d, 0x22,
	0x4a, 0xa5, 0xd4, 0xe4, 0xac, 0xa8, 0xc9, 0x51, 0x71, 0x61, 0x72, 0x96, 0x94, 0x6f, 0xc0, 0xdf,
	0xbf, 0xef, 0x56, 0x60, 0x19, 0x31, 0xc6, 0xad, 0x3f, 0x0c, 0x50, 0xd5, 0x86, 0xe0, 0x19, 0x58,
	0xf7, 0xe4, 0xa3, 0x09, 0x68, 0x64, 0x1a, 0x47, 0xa5, 0x93, 0x9a, 0xea, 0x57, 0xf6, 0x0a, 0x99,
	0xd6, 0x73, 0xdc, 0x37, 0x34, 0x39, 0x93, 0xad, 0x5e, 0xf7, 0xf5, 0x1b, 0x69, 0xf5, 0xba, 0x8b,
	0x99, 0x44, 0x51, 0x98, 0x9f, 0xc9, 0x42, 0x68, 0x05, 0xa0, 0xf6, 0xd2, 0x14, 0xfc, 0x1e, 0x6c,
	0xb5, 0x84, 0x40, 0xc1, 0x2d, 0x1e, 0x7b, 0x34, 0x22, 0x01, 0xc1, 0x5c, 0x1b, 0x6b, 0x3c, 0x4f,
	0x1b, 0xfb, 0x48, 0xe7, 0x6c, 0xa6, 0x93, 0x39, 0xec, 0x7b, 0x49, 0xeb, 0x37, 0xb5, 0x0c, 0xe0,
	0x1d, 0x30, 0xdb, 0x29, 0x65, 0xfd, 0x2c, 0x12, 0xe4, 0xbb, 0x0c, 0x73, 0xb9, 0x96, 0x3c, 0x14,
	0xfc, 0x8c, 0x05, 0x57, 0x83, 0xb3, 0xee, 0xda, 0xda, 0xf3, 0xf1, 0x38, 0xa5, 0xcc, 0x8e, 0x65,
	0xa1, 0xfd, 0x8b, 0xae, 0xb4, 0xd9, 0xac, 0x34, 0xf7, 0xa7, 0x1f, 0x56, 0x66, 0xad, 0xa9, 0x97,
	0x6b, 0x55, 0xf5, 0xf3, 0xb3, 0x2a, 0xb3, 0xb9, 0xb7, 0x7e, 0x54, 0x1b, 0x06, 0xfe, 0x00, 0xea,
	0x7d, 0x74, 0x7f, 0x8e, 0xa2, 0xa8, 0x9d, 0xa5, 0x6a, 0x57, 0x2a, 0x37, 0x1b, 0xee, 0x17, 0xda,
	0xcd, 0x7e, 0x8c, 0xee, 0xed, 0x00, 0x45, 0x91, 0x3d, 0xd6, 0x05, 0x1a, 0x2e, 0xd8, 0x64, 0xf0,
	0x5e, 0xd2, 0xfa, 0xd3, 0x98, 0xaf, 0x20, 0xd8, 0x01, 0x35, 0x2f, 0xa5, 0x61, 0x8a, 0xe2, 0xcb,
	0xb6, 0xe2, 0xd7, 0xdc, 0x03, 0xcd, 0xff, 0x84, 0xcd, 0x12, 0x36, 0x19, 0xe7, 0x9a, 0x7b, 0x53,
	0x85, 0x1d, 0x69, 0x96, 0x75, 0x12, 0x91, 0x4e, 0x86, 0x24, 0xc6, 0x34, 0x13, 0xea, 0xf6, 0x6b,
	0xee, 0xae, 0x86, 0x6d, 0xc7, 0x88, 0xd9, 0x58, 0xe6, 0x6d, 0x31, 0x2b, 0x18, 0xbc, 0x96, 0xe4,
	0x27, 0x50, 0xab, 0xe2, 0xe3, 0x87, 0xa7, 0x43, 0xe3, 0xf1, 0xe9, 0xd0, 0xf8, 0xe7, 0xe9, 0xd0,
	0xf0, 0x8c, 0x51, 0x45, 0x0d, 0xd9, 0x57, 0xff, 0x05, 0x00, 0x00, 0xff, 0xff, 0x78, 0x77, 0xfa,
	0x23, 0x97, 0x06, 0x00, 0x00,
}
