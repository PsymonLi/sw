// Code generated by protoc-gen-grpc-pensando DO NOT EDIT.

package grpcclient

import (
	"context"
	"errors"
	oldlog "log"

	"github.com/go-kit/kit/endpoint"
	"github.com/go-kit/kit/tracing/opentracing"
	grpctransport "github.com/go-kit/kit/transport/grpc"
	stdopentracing "github.com/opentracing/opentracing-go"
	"google.golang.org/grpc"

	api "github.com/pensando/sw/api"
	events "github.com/pensando/sw/api/generated/events"
	listerwatcher "github.com/pensando/sw/api/listerwatcher"
	apiserver "github.com/pensando/sw/venice/apiserver"
	"github.com/pensando/sw/venice/utils/kvstore"
	"github.com/pensando/sw/venice/utils/log"
)

// Dummy vars to suppress import errors
var _ api.TypeMeta
var _ listerwatcher.WatcherClient
var _ kvstore.Interface

// NewEventPolicyV1 sets up a new client for EventPolicyV1
func NewEventPolicyV1(conn *grpc.ClientConn, logger log.Logger) events.ServiceEventPolicyV1Client {

	var lAutoAddEventPolicyEndpoint endpoint.Endpoint
	{
		lAutoAddEventPolicyEndpoint = grpctransport.NewClient(
			conn,
			"events.EventPolicyV1",
			"AutoAddEventPolicy",
			events.EncodeGrpcReqEventPolicy,
			events.DecodeGrpcRespEventPolicy,
			&events.EventPolicy{},
			grpctransport.ClientBefore(opentracing.ToGRPCRequest(stdopentracing.GlobalTracer(), logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoAddEventPolicyEndpoint = opentracing.TraceClient(stdopentracing.GlobalTracer(), "EventPolicyV1:AutoAddEventPolicy")(lAutoAddEventPolicyEndpoint)
	}
	var lAutoDeleteEventPolicyEndpoint endpoint.Endpoint
	{
		lAutoDeleteEventPolicyEndpoint = grpctransport.NewClient(
			conn,
			"events.EventPolicyV1",
			"AutoDeleteEventPolicy",
			events.EncodeGrpcReqEventPolicy,
			events.DecodeGrpcRespEventPolicy,
			&events.EventPolicy{},
			grpctransport.ClientBefore(opentracing.ToGRPCRequest(stdopentracing.GlobalTracer(), logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoDeleteEventPolicyEndpoint = opentracing.TraceClient(stdopentracing.GlobalTracer(), "EventPolicyV1:AutoDeleteEventPolicy")(lAutoDeleteEventPolicyEndpoint)
	}
	var lAutoGetEventPolicyEndpoint endpoint.Endpoint
	{
		lAutoGetEventPolicyEndpoint = grpctransport.NewClient(
			conn,
			"events.EventPolicyV1",
			"AutoGetEventPolicy",
			events.EncodeGrpcReqEventPolicy,
			events.DecodeGrpcRespEventPolicy,
			&events.EventPolicy{},
			grpctransport.ClientBefore(opentracing.ToGRPCRequest(stdopentracing.GlobalTracer(), logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoGetEventPolicyEndpoint = opentracing.TraceClient(stdopentracing.GlobalTracer(), "EventPolicyV1:AutoGetEventPolicy")(lAutoGetEventPolicyEndpoint)
	}
	var lAutoListEventPolicyEndpoint endpoint.Endpoint
	{
		lAutoListEventPolicyEndpoint = grpctransport.NewClient(
			conn,
			"events.EventPolicyV1",
			"AutoListEventPolicy",
			events.EncodeGrpcReqListWatchOptions,
			events.DecodeGrpcRespEventPolicyList,
			&events.EventPolicyList{},
			grpctransport.ClientBefore(opentracing.ToGRPCRequest(stdopentracing.GlobalTracer(), logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoListEventPolicyEndpoint = opentracing.TraceClient(stdopentracing.GlobalTracer(), "EventPolicyV1:AutoListEventPolicy")(lAutoListEventPolicyEndpoint)
	}
	var lAutoUpdateEventPolicyEndpoint endpoint.Endpoint
	{
		lAutoUpdateEventPolicyEndpoint = grpctransport.NewClient(
			conn,
			"events.EventPolicyV1",
			"AutoUpdateEventPolicy",
			events.EncodeGrpcReqEventPolicy,
			events.DecodeGrpcRespEventPolicy,
			&events.EventPolicy{},
			grpctransport.ClientBefore(opentracing.ToGRPCRequest(stdopentracing.GlobalTracer(), logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoUpdateEventPolicyEndpoint = opentracing.TraceClient(stdopentracing.GlobalTracer(), "EventPolicyV1:AutoUpdateEventPolicy")(lAutoUpdateEventPolicyEndpoint)
	}
	return events.EndpointsEventPolicyV1Client{
		Client: events.NewEventPolicyV1Client(conn),

		AutoAddEventPolicyEndpoint:    lAutoAddEventPolicyEndpoint,
		AutoDeleteEventPolicyEndpoint: lAutoDeleteEventPolicyEndpoint,
		AutoGetEventPolicyEndpoint:    lAutoGetEventPolicyEndpoint,
		AutoListEventPolicyEndpoint:   lAutoListEventPolicyEndpoint,
		AutoUpdateEventPolicyEndpoint: lAutoUpdateEventPolicyEndpoint,
	}
}

// NewEventPolicyV1Backend creates an instrumented client with middleware
func NewEventPolicyV1Backend(conn *grpc.ClientConn, logger log.Logger) events.ServiceEventPolicyV1Client {
	cl := NewEventPolicyV1(conn, logger)
	cl = events.LoggingEventPolicyV1MiddlewareClient(logger)(cl)
	return cl
}

// NewEventV1 sets up a new client for EventV1
func NewEventV1(conn *grpc.ClientConn, logger log.Logger) events.ServiceEventV1Client {

	var lAutoAddEventEndpoint endpoint.Endpoint
	{
		lAutoAddEventEndpoint = grpctransport.NewClient(
			conn,
			"events.EventV1",
			"AutoAddEvent",
			events.EncodeGrpcReqEvent,
			events.DecodeGrpcRespEvent,
			&events.Event{},
			grpctransport.ClientBefore(opentracing.ToGRPCRequest(stdopentracing.GlobalTracer(), logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoAddEventEndpoint = opentracing.TraceClient(stdopentracing.GlobalTracer(), "EventV1:AutoAddEvent")(lAutoAddEventEndpoint)
	}
	var lAutoDeleteEventEndpoint endpoint.Endpoint
	{
		lAutoDeleteEventEndpoint = grpctransport.NewClient(
			conn,
			"events.EventV1",
			"AutoDeleteEvent",
			events.EncodeGrpcReqEvent,
			events.DecodeGrpcRespEvent,
			&events.Event{},
			grpctransport.ClientBefore(opentracing.ToGRPCRequest(stdopentracing.GlobalTracer(), logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoDeleteEventEndpoint = opentracing.TraceClient(stdopentracing.GlobalTracer(), "EventV1:AutoDeleteEvent")(lAutoDeleteEventEndpoint)
	}
	var lAutoGetEventEndpoint endpoint.Endpoint
	{
		lAutoGetEventEndpoint = grpctransport.NewClient(
			conn,
			"events.EventV1",
			"AutoGetEvent",
			events.EncodeGrpcReqEvent,
			events.DecodeGrpcRespEvent,
			&events.Event{},
			grpctransport.ClientBefore(opentracing.ToGRPCRequest(stdopentracing.GlobalTracer(), logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoGetEventEndpoint = opentracing.TraceClient(stdopentracing.GlobalTracer(), "EventV1:AutoGetEvent")(lAutoGetEventEndpoint)
	}
	var lAutoListEventEndpoint endpoint.Endpoint
	{
		lAutoListEventEndpoint = grpctransport.NewClient(
			conn,
			"events.EventV1",
			"AutoListEvent",
			events.EncodeGrpcReqListWatchOptions,
			events.DecodeGrpcRespEventList,
			&events.EventList{},
			grpctransport.ClientBefore(opentracing.ToGRPCRequest(stdopentracing.GlobalTracer(), logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoListEventEndpoint = opentracing.TraceClient(stdopentracing.GlobalTracer(), "EventV1:AutoListEvent")(lAutoListEventEndpoint)
	}
	var lAutoUpdateEventEndpoint endpoint.Endpoint
	{
		lAutoUpdateEventEndpoint = grpctransport.NewClient(
			conn,
			"events.EventV1",
			"AutoUpdateEvent",
			events.EncodeGrpcReqEvent,
			events.DecodeGrpcRespEvent,
			&events.Event{},
			grpctransport.ClientBefore(opentracing.ToGRPCRequest(stdopentracing.GlobalTracer(), logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoUpdateEventEndpoint = opentracing.TraceClient(stdopentracing.GlobalTracer(), "EventV1:AutoUpdateEvent")(lAutoUpdateEventEndpoint)
	}
	return events.EndpointsEventV1Client{
		Client: events.NewEventV1Client(conn),

		AutoAddEventEndpoint:    lAutoAddEventEndpoint,
		AutoDeleteEventEndpoint: lAutoDeleteEventEndpoint,
		AutoGetEventEndpoint:    lAutoGetEventEndpoint,
		AutoListEventEndpoint:   lAutoListEventEndpoint,
		AutoUpdateEventEndpoint: lAutoUpdateEventEndpoint,
	}
}

// NewEventV1Backend creates an instrumented client with middleware
func NewEventV1Backend(conn *grpc.ClientConn, logger log.Logger) events.ServiceEventV1Client {
	cl := NewEventV1(conn, logger)
	cl = events.LoggingEventV1MiddlewareClient(logger)(cl)
	return cl
}

type grpcObjEventPolicyV1EventPolicy struct {
	logger log.Logger
	client events.ServiceEventPolicyV1Client
}

func (a *grpcObjEventPolicyV1EventPolicy) Create(ctx context.Context, in *events.EventPolicy) (*events.EventPolicy, error) {
	a.logger.DebugLog("msg", "recieved call", "object", "EventPolicy", "oper", "create")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoAddEventPolicy(nctx, in)
}

func (a *grpcObjEventPolicyV1EventPolicy) Update(ctx context.Context, in *events.EventPolicy) (*events.EventPolicy, error) {
	a.logger.DebugLog("msg", "received call", "object", "EventPolicy", "oper", "update")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoUpdateEventPolicy(nctx, in)
}

func (a *grpcObjEventPolicyV1EventPolicy) Get(ctx context.Context, objMeta *api.ObjectMeta) (*events.EventPolicy, error) {
	a.logger.DebugLog("msg", "received call", "object", "EventPolicy", "oper", "get")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := events.EventPolicy{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoGetEventPolicy(nctx, &in)
}

func (a *grpcObjEventPolicyV1EventPolicy) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*events.EventPolicy, error) {
	a.logger.DebugLog("msg", "received call", "object", "EventPolicy", "oper", "delete")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := events.EventPolicy{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoDeleteEventPolicy(nctx, &in)
}

func (a *grpcObjEventPolicyV1EventPolicy) List(ctx context.Context, options *api.ListWatchOptions) ([]*events.EventPolicy, error) {
	a.logger.DebugLog("msg", "received call", "object", "EventPolicy", "oper", "list")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	r, err := a.client.AutoListEventPolicy(nctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *grpcObjEventPolicyV1EventPolicy) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	a.logger.DebugLog("msg", "received call", "object", "EventPolicy", "oper", "WatchOper")
	nctx := addVersion(ctx, "v1")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	stream, err := a.client.AutoWatchEventPolicy(nctx, options)
	if err != nil {
		return nil, err
	}
	wstream := stream.(events.EventPolicyV1_AutoWatchEventPolicyClient)
	bridgefn := func(lw *listerwatcher.WatcherClient) {
		for {
			r, err := wstream.Recv()
			if err != nil {
				a.logger.ErrorLog("msg", "error on recieve", "error", err)
				close(lw.OutCh)
				return
			}
			ev := kvstore.WatchEvent{
				Type:   kvstore.WatchEventType(r.Type),
				Object: r.Object,
			}
			select {
			case lw.OutCh <- &ev:
			case <-wstream.Context().Done():
				close(lw.OutCh)
				return
			}
		}
	}
	lw := listerwatcher.NewWatcherClient(wstream, bridgefn)
	lw.Run()
	return lw, nil
}

func (a *grpcObjEventPolicyV1EventPolicy) Allowed(oper apiserver.APIOperType) bool {
	return true
}

type restObjEventPolicyV1EventPolicy struct {
	endpoints events.EndpointsEventPolicyV1RestClient
	instance  string
}

func (a *restObjEventPolicyV1EventPolicy) Create(ctx context.Context, in *events.EventPolicy) (*events.EventPolicy, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoAddEventPolicy(ctx, in)
}

func (a *restObjEventPolicyV1EventPolicy) Update(ctx context.Context, in *events.EventPolicy) (*events.EventPolicy, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoUpdateEventPolicy(ctx, in)
}

func (a *restObjEventPolicyV1EventPolicy) Get(ctx context.Context, objMeta *api.ObjectMeta) (*events.EventPolicy, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := events.EventPolicy{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoGetEventPolicy(ctx, &in)
}

func (a *restObjEventPolicyV1EventPolicy) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*events.EventPolicy, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := events.EventPolicy{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoDeleteEventPolicy(ctx, &in)
}

func (a *restObjEventPolicyV1EventPolicy) List(ctx context.Context, options *api.ListWatchOptions) ([]*events.EventPolicy, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}
	r, err := a.endpoints.AutoListEventPolicy(ctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *restObjEventPolicyV1EventPolicy) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	return nil, errors.New("not allowed")
}

func (a *restObjEventPolicyV1EventPolicy) Allowed(oper apiserver.APIOperType) bool {
	switch oper {
	case apiserver.CreateOper:
		return true
	case apiserver.UpdateOper:
		return true
	case apiserver.GetOper:
		return true
	case apiserver.DeleteOper:
		return true
	case apiserver.ListOper:
		return false
	case apiserver.WatchOper:
		return false
	default:
		return false
	}
}

type grpcObjEventV1Event struct {
	logger log.Logger
	client events.ServiceEventV1Client
}

func (a *grpcObjEventV1Event) Create(ctx context.Context, in *events.Event) (*events.Event, error) {
	a.logger.DebugLog("msg", "recieved call", "object", "Event", "oper", "create")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoAddEvent(nctx, in)
}

func (a *grpcObjEventV1Event) Update(ctx context.Context, in *events.Event) (*events.Event, error) {
	a.logger.DebugLog("msg", "received call", "object", "Event", "oper", "update")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoUpdateEvent(nctx, in)
}

func (a *grpcObjEventV1Event) Get(ctx context.Context, objMeta *api.ObjectMeta) (*events.Event, error) {
	a.logger.DebugLog("msg", "received call", "object", "Event", "oper", "get")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := events.Event{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoGetEvent(nctx, &in)
}

func (a *grpcObjEventV1Event) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*events.Event, error) {
	a.logger.DebugLog("msg", "received call", "object", "Event", "oper", "delete")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := events.Event{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoDeleteEvent(nctx, &in)
}

func (a *grpcObjEventV1Event) List(ctx context.Context, options *api.ListWatchOptions) ([]*events.Event, error) {
	a.logger.DebugLog("msg", "received call", "object", "Event", "oper", "list")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	r, err := a.client.AutoListEvent(nctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *grpcObjEventV1Event) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	a.logger.DebugLog("msg", "received call", "object", "Event", "oper", "WatchOper")
	nctx := addVersion(ctx, "v1")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	stream, err := a.client.AutoWatchEvent(nctx, options)
	if err != nil {
		return nil, err
	}
	wstream := stream.(events.EventV1_AutoWatchEventClient)
	bridgefn := func(lw *listerwatcher.WatcherClient) {
		for {
			r, err := wstream.Recv()
			if err != nil {
				a.logger.ErrorLog("msg", "error on recieve", "error", err)
				close(lw.OutCh)
				return
			}
			ev := kvstore.WatchEvent{
				Type:   kvstore.WatchEventType(r.Type),
				Object: r.Object,
			}
			select {
			case lw.OutCh <- &ev:
			case <-wstream.Context().Done():
				close(lw.OutCh)
				return
			}
		}
	}
	lw := listerwatcher.NewWatcherClient(wstream, bridgefn)
	lw.Run()
	return lw, nil
}

func (a *grpcObjEventV1Event) Allowed(oper apiserver.APIOperType) bool {
	return true
}

type restObjEventV1Event struct {
	endpoints events.EndpointsEventV1RestClient
	instance  string
}

func (a *restObjEventV1Event) Create(ctx context.Context, in *events.Event) (*events.Event, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoAddEvent(ctx, in)
}

func (a *restObjEventV1Event) Update(ctx context.Context, in *events.Event) (*events.Event, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoUpdateEvent(ctx, in)
}

func (a *restObjEventV1Event) Get(ctx context.Context, objMeta *api.ObjectMeta) (*events.Event, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := events.Event{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoGetEvent(ctx, &in)
}

func (a *restObjEventV1Event) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*events.Event, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := events.Event{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoDeleteEvent(ctx, &in)
}

func (a *restObjEventV1Event) List(ctx context.Context, options *api.ListWatchOptions) ([]*events.Event, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}
	r, err := a.endpoints.AutoListEvent(ctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *restObjEventV1Event) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	return nil, errors.New("not allowed")
}

func (a *restObjEventV1Event) Allowed(oper apiserver.APIOperType) bool {
	switch oper {
	case apiserver.CreateOper:
		return false
	case apiserver.UpdateOper:
		return false
	case apiserver.GetOper:
		return true
	case apiserver.DeleteOper:
		return false
	case apiserver.ListOper:
		return true
	case apiserver.WatchOper:
		return false
	default:
		return false
	}
}

type crudClientEventPolicyV1 struct {
	grpcEventPolicy events.EventPolicyInterface
}

// NewGrpcCrudClientEventPolicyV1 creates a GRPC client for the service
func NewGrpcCrudClientEventPolicyV1(conn *grpc.ClientConn, logger log.Logger) events.EventPolicyV1Interface {
	client := NewEventPolicyV1Backend(conn, logger)
	return &crudClientEventPolicyV1{

		grpcEventPolicy: &grpcObjEventPolicyV1EventPolicy{client: client, logger: logger},
	}
}

func (a *crudClientEventPolicyV1) EventPolicy() events.EventPolicyInterface {
	return a.grpcEventPolicy
}

type crudRestClientEventPolicyV1 struct {
	restEventPolicy events.EventPolicyInterface
}

// NewRestCrudClientEventPolicyV1 creates a REST client for the service.
func NewRestCrudClientEventPolicyV1(url string) events.EventPolicyV1Interface {
	endpoints, err := events.MakeEventPolicyV1RestClientEndpoints(url)
	if err != nil {
		oldlog.Fatal("failed to create client")
	}
	return &crudRestClientEventPolicyV1{

		restEventPolicy: &restObjEventPolicyV1EventPolicy{endpoints: endpoints, instance: url},
	}
}

func (a *crudRestClientEventPolicyV1) EventPolicy() events.EventPolicyInterface {
	return a.restEventPolicy
}

type crudClientEventV1 struct {
	grpcEvent events.EventInterface
}

// NewGrpcCrudClientEventV1 creates a GRPC client for the service
func NewGrpcCrudClientEventV1(conn *grpc.ClientConn, logger log.Logger) events.EventV1Interface {
	client := NewEventV1Backend(conn, logger)
	return &crudClientEventV1{

		grpcEvent: &grpcObjEventV1Event{client: client, logger: logger},
	}
}

func (a *crudClientEventV1) Event() events.EventInterface {
	return a.grpcEvent
}

type crudRestClientEventV1 struct {
	restEvent events.EventInterface
}

// NewRestCrudClientEventV1 creates a REST client for the service.
func NewRestCrudClientEventV1(url string) events.EventV1Interface {
	endpoints, err := events.MakeEventV1RestClientEndpoints(url)
	if err != nil {
		oldlog.Fatal("failed to create client")
	}
	return &crudRestClientEventV1{

		restEvent: &restObjEventV1Event{endpoints: endpoints, instance: url},
	}
}

func (a *crudRestClientEventV1) Event() events.EventInterface {
	return a.restEvent
}
