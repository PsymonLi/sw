// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: events.proto

/*
	Package events is a generated protocol buffer package.

	Service name

	It is generated from these files:
		events.proto

	It has these top-level messages:
		AutoMsgEventPolicyWatchHelper
		AutoMsgEventWatchHelper
		Event
		EventList
		EventPolicy
		EventPolicyList
		EventPolicySpec
		EventPolicyStatus
		EventSource
		EventSpec
		EventStatus
*/
package events

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/pensando/grpc-gateway/third_party/googleapis/google/api"
import _ "github.com/pensando/sw/venice/utils/apigen/annotations"
import _ "github.com/gogo/protobuf/gogoproto"
import api "github.com/pensando/sw/api"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// Severity Level of an event
type SeverityLevel int32

const (
	SeverityLevel_INFO     SeverityLevel = 0
	SeverityLevel_WARNING  SeverityLevel = 1
	SeverityLevel_ERROR    SeverityLevel = 2
	SeverityLevel_CRITICAL SeverityLevel = 3
)

var SeverityLevel_name = map[int32]string{
	0: "INFO",
	1: "WARNING",
	2: "ERROR",
	3: "CRITICAL",
}
var SeverityLevel_value = map[string]int32{
	"INFO":     0,
	"WARNING":  1,
	"ERROR":    2,
	"CRITICAL": 3,
}

func (x SeverityLevel) String() string {
	return proto.EnumName(SeverityLevel_name, int32(x))
}
func (SeverityLevel) EnumDescriptor() ([]byte, []int) { return fileDescriptorEvents, []int{0} }

// -------------------------- Event Object -----------------------------
// Event is a system notification of a fault, condition or configuration
// that should be user visible. These objects are created internally by
// Event client and persisted in EventDB.
type AutoMsgEventPolicyWatchHelper struct {
	Type string `protobuf:"bytes,1,opt,name=Type,proto3" json:"Type,omitempty"`
	// ObjectMeta.Name will be an UUID for an Event object.
	// ObjectMeta.Labels will be used to tag an events
	// with Reason, UserInfo etc that will provide more
	// context for an event.
	// eg: Reason: NodeJoined, NetworkDeleted, NicRejected
	//     User: user-foo
	// TBD: Should there be predefined list of labels for
	//      Reason or keep it free form ?
	Object *EventPolicy `protobuf:"bytes,2,opt,name=Object" json:"Object,omitempty"`
}

func (m *AutoMsgEventPolicyWatchHelper) Reset()         { *m = AutoMsgEventPolicyWatchHelper{} }
func (m *AutoMsgEventPolicyWatchHelper) String() string { return proto.CompactTextString(m) }
func (*AutoMsgEventPolicyWatchHelper) ProtoMessage()    {}
func (*AutoMsgEventPolicyWatchHelper) Descriptor() ([]byte, []int) {
	return fileDescriptorEvents, []int{0}
}

func (m *AutoMsgEventPolicyWatchHelper) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *AutoMsgEventPolicyWatchHelper) GetObject() *EventPolicy {
	if m != nil {
		return m.Object
	}
	return nil
}

// EventSpec is empty for Event Object
type AutoMsgEventWatchHelper struct {
	Type   string `protobuf:"bytes,1,opt,name=Type,proto3" json:"Type,omitempty"`
	Object *Event `protobuf:"bytes,2,opt,name=Object" json:"Object,omitempty"`
}

func (m *AutoMsgEventWatchHelper) Reset()                    { *m = AutoMsgEventWatchHelper{} }
func (m *AutoMsgEventWatchHelper) String() string            { return proto.CompactTextString(m) }
func (*AutoMsgEventWatchHelper) ProtoMessage()               {}
func (*AutoMsgEventWatchHelper) Descriptor() ([]byte, []int) { return fileDescriptorEvents, []int{1} }

func (m *AutoMsgEventWatchHelper) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *AutoMsgEventWatchHelper) GetObject() *Event {
	if m != nil {
		return m.Object
	}
	return nil
}

// EventSource has info about the component and
// host/node that generated the event
type Event struct {
	// Component from which the event is generated.
	api.TypeMeta `protobuf:"bytes,1,opt,name=T,embedded=T" json:",inline"`
	// Node name on which the event is generated.
	api.ObjectMeta `protobuf:"bytes,2,opt,name=O,embedded=O" json:"meta,omitempty"`
	Spec           EventSpec   `protobuf:"bytes,3,opt,name=Spec" json:",inline"`
	Status         EventStatus `protobuf:"bytes,4,opt,name=Status" json:"status,omitempty"`
}

func (m *Event) Reset()                    { *m = Event{} }
func (m *Event) String() string            { return proto.CompactTextString(m) }
func (*Event) ProtoMessage()               {}
func (*Event) Descriptor() ([]byte, []int) { return fileDescriptorEvents, []int{2} }

func (m *Event) GetSpec() EventSpec {
	if m != nil {
		return m.Spec
	}
	return EventSpec{}
}

func (m *Event) GetStatus() EventStatus {
	if m != nil {
		return m.Status
	}
	return EventStatus{}
}

// EventStatus is status of the Event object
type EventList struct {
	// Severity represents the criticality level of an Event
	api.TypeMeta `protobuf:"bytes,2,opt,name=T,embedded=T" json:"T"`
	// Description represents the human readable description of an Event
	api.ListMeta `protobuf:"bytes,3,opt,name=ListMeta,embedded=ListMeta" json:"ListMeta"`
	// ObjectRef is the reference to the object associated with an event
	Items []*Event `protobuf:"bytes,4,rep,name=Items" json:"Items,omitempty"`
}

func (m *EventList) Reset()                    { *m = EventList{} }
func (m *EventList) String() string            { return proto.CompactTextString(m) }
func (*EventList) ProtoMessage()               {}
func (*EventList) Descriptor() ([]byte, []int) { return fileDescriptorEvents, []int{3} }

func (m *EventList) GetItems() []*Event {
	if m != nil {
		return m.Items
	}
	return nil
}

// -------------------------- Event Policy -----------------------------
// Event Policy represents the policy definition for Events.
// Event Client module will be consumer of this policy.
type EventPolicy struct {
	api.TypeMeta   `protobuf:"bytes,1,opt,name=T,embedded=T" json:",inline"`
	api.ObjectMeta `protobuf:"bytes,2,opt,name=O,embedded=O" json:"meta,omitempty"`
	// Spec contains the configuration of the event policy.
	Spec EventPolicySpec `protobuf:"bytes,3,opt,name=Spec" json:"spec,omitempty"`
	// Status contains the current state of the event policy.
	Status EventPolicyStatus `protobuf:"bytes,4,opt,name=Status" json:"status,omitempty"`
}

func (m *EventPolicy) Reset()                    { *m = EventPolicy{} }
func (m *EventPolicy) String() string            { return proto.CompactTextString(m) }
func (*EventPolicy) ProtoMessage()               {}
func (*EventPolicy) Descriptor() ([]byte, []int) { return fileDescriptorEvents, []int{4} }

func (m *EventPolicy) GetSpec() EventPolicySpec {
	if m != nil {
		return m.Spec
	}
	return EventPolicySpec{}
}

func (m *EventPolicy) GetStatus() EventPolicyStatus {
	if m != nil {
		return m.Status
	}
	return EventPolicyStatus{}
}

// EventPolicySpec is the specification of an Event Policy,
// It consists of the Object Selector, Level selector,
// Retention and Export policies.
//
// TBD: Decide if we need event specific collection policy
type EventPolicyList struct {
	// Levels is a match list of levels permitted for event generation
	api.TypeMeta `protobuf:"bytes,2,opt,name=T,embedded=T" json:"T"`
	// RetentionPolicy specifies for how long the data is kept
	api.ListMeta `protobuf:"bytes,3,opt,name=ListMeta,embedded=ListMeta" json:"ListMeta"`
	// ExportPolicies defines the location, frequency and format of data to an external collector
	Items []*EventPolicy `protobuf:"bytes,4,rep,name=Items" json:"Items,omitempty"`
}

func (m *EventPolicyList) Reset()                    { *m = EventPolicyList{} }
func (m *EventPolicyList) String() string            { return proto.CompactTextString(m) }
func (*EventPolicyList) ProtoMessage()               {}
func (*EventPolicyList) Descriptor() ([]byte, []int) { return fileDescriptorEvents, []int{5} }

func (m *EventPolicyList) GetItems() []*EventPolicy {
	if m != nil {
		return m.Items
	}
	return nil
}

// EventPolicyStatus
type EventPolicySpec struct {
	Levels          []string `protobuf:"bytes,1,rep,name=Levels" json:"levels,omitempty"`
	RetentionPolicy string   `protobuf:"bytes,2,opt,name=RetentionPolicy,proto3" json:"retention-policy,omitempty"`
	ExportPolicies  []string `protobuf:"bytes,3,rep,name=ExportPolicies" json:"export-policy,omitempty"`
}

func (m *EventPolicySpec) Reset()                    { *m = EventPolicySpec{} }
func (m *EventPolicySpec) String() string            { return proto.CompactTextString(m) }
func (*EventPolicySpec) ProtoMessage()               {}
func (*EventPolicySpec) Descriptor() ([]byte, []int) { return fileDescriptorEvents, []int{6} }

func (m *EventPolicySpec) GetLevels() []string {
	if m != nil {
		return m.Levels
	}
	return nil
}

func (m *EventPolicySpec) GetRetentionPolicy() string {
	if m != nil {
		return m.RetentionPolicy
	}
	return ""
}

func (m *EventPolicySpec) GetExportPolicies() []string {
	if m != nil {
		return m.ExportPolicies
	}
	return nil
}

type EventPolicyStatus struct {
}

func (m *EventPolicyStatus) Reset()                    { *m = EventPolicyStatus{} }
func (m *EventPolicyStatus) String() string            { return proto.CompactTextString(m) }
func (*EventPolicyStatus) ProtoMessage()               {}
func (*EventPolicyStatus) Descriptor() ([]byte, []int) { return fileDescriptorEvents, []int{7} }

type EventSource struct {
	Component string `protobuf:"bytes,1,opt,name=Component,proto3" json:"component,omitempty"`
	Node      string `protobuf:"bytes,2,opt,name=Node,proto3" json:"node,omitempty"`
}

func (m *EventSource) Reset()                    { *m = EventSource{} }
func (m *EventSource) String() string            { return proto.CompactTextString(m) }
func (*EventSource) ProtoMessage()               {}
func (*EventSource) Descriptor() ([]byte, []int) { return fileDescriptorEvents, []int{8} }

func (m *EventSource) GetComponent() string {
	if m != nil {
		return m.Component
	}
	return ""
}

func (m *EventSource) GetNode() string {
	if m != nil {
		return m.Node
	}
	return ""
}

type EventSpec struct {
}

func (m *EventSpec) Reset()                    { *m = EventSpec{} }
func (m *EventSpec) String() string            { return proto.CompactTextString(m) }
func (*EventSpec) ProtoMessage()               {}
func (*EventSpec) Descriptor() ([]byte, []int) { return fileDescriptorEvents, []int{9} }

type EventStatus struct {
	Severity    string         `protobuf:"bytes,1,opt,name=Severity,proto3" json:"severity,omitempty"`
	Description string         `protobuf:"bytes,2,opt,name=Description,proto3" json:"description,omitempty"`
	ObjectRef   *api.ObjectRef `protobuf:"bytes,3,opt,name=ObjectRef" json:"object-ref,omitempty"`
	Source      *EventSource   `protobuf:"bytes,4,opt,name=Source" json:"source,omitempty"`
	CreatedTime string         `protobuf:"bytes,5,opt,name=CreatedTime,proto3" json:"created-time,omitempty"`
	EventPolicy string         `protobuf:"bytes,6,opt,name=EventPolicy,proto3" json:"event-policy,omitempty"`
}

func (m *EventStatus) Reset()                    { *m = EventStatus{} }
func (m *EventStatus) String() string            { return proto.CompactTextString(m) }
func (*EventStatus) ProtoMessage()               {}
func (*EventStatus) Descriptor() ([]byte, []int) { return fileDescriptorEvents, []int{10} }

func (m *EventStatus) GetSeverity() string {
	if m != nil {
		return m.Severity
	}
	return ""
}

func (m *EventStatus) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *EventStatus) GetObjectRef() *api.ObjectRef {
	if m != nil {
		return m.ObjectRef
	}
	return nil
}

func (m *EventStatus) GetSource() *EventSource {
	if m != nil {
		return m.Source
	}
	return nil
}

func (m *EventStatus) GetCreatedTime() string {
	if m != nil {
		return m.CreatedTime
	}
	return ""
}

func (m *EventStatus) GetEventPolicy() string {
	if m != nil {
		return m.EventPolicy
	}
	return ""
}

func init() {
	proto.RegisterType((*AutoMsgEventPolicyWatchHelper)(nil), "events.AutoMsgEventPolicyWatchHelper")
	proto.RegisterType((*AutoMsgEventWatchHelper)(nil), "events.AutoMsgEventWatchHelper")
	proto.RegisterType((*Event)(nil), "events.Event")
	proto.RegisterType((*EventList)(nil), "events.EventList")
	proto.RegisterType((*EventPolicy)(nil), "events.EventPolicy")
	proto.RegisterType((*EventPolicyList)(nil), "events.EventPolicyList")
	proto.RegisterType((*EventPolicySpec)(nil), "events.EventPolicySpec")
	proto.RegisterType((*EventPolicyStatus)(nil), "events.EventPolicyStatus")
	proto.RegisterType((*EventSource)(nil), "events.EventSource")
	proto.RegisterType((*EventSpec)(nil), "events.EventSpec")
	proto.RegisterType((*EventStatus)(nil), "events.EventStatus")
	proto.RegisterEnum("events.SeverityLevel", SeverityLevel_name, SeverityLevel_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for EventPolicyV1 service

type EventPolicyV1Client interface {
	AutoAddEventPolicy(ctx context.Context, in *EventPolicy, opts ...grpc.CallOption) (*EventPolicy, error)
	AutoDeleteEventPolicy(ctx context.Context, in *EventPolicy, opts ...grpc.CallOption) (*EventPolicy, error)
	AutoGetEventPolicy(ctx context.Context, in *EventPolicy, opts ...grpc.CallOption) (*EventPolicy, error)
	AutoListEventPolicy(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (*EventPolicyList, error)
	AutoUpdateEventPolicy(ctx context.Context, in *EventPolicy, opts ...grpc.CallOption) (*EventPolicy, error)
	AutoWatchEventPolicy(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (EventPolicyV1_AutoWatchEventPolicyClient, error)
}

type eventPolicyV1Client struct {
	cc *grpc.ClientConn
}

func NewEventPolicyV1Client(cc *grpc.ClientConn) EventPolicyV1Client {
	return &eventPolicyV1Client{cc}
}

func (c *eventPolicyV1Client) AutoAddEventPolicy(ctx context.Context, in *EventPolicy, opts ...grpc.CallOption) (*EventPolicy, error) {
	out := new(EventPolicy)
	err := grpc.Invoke(ctx, "/events.EventPolicyV1/AutoAddEventPolicy", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eventPolicyV1Client) AutoDeleteEventPolicy(ctx context.Context, in *EventPolicy, opts ...grpc.CallOption) (*EventPolicy, error) {
	out := new(EventPolicy)
	err := grpc.Invoke(ctx, "/events.EventPolicyV1/AutoDeleteEventPolicy", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eventPolicyV1Client) AutoGetEventPolicy(ctx context.Context, in *EventPolicy, opts ...grpc.CallOption) (*EventPolicy, error) {
	out := new(EventPolicy)
	err := grpc.Invoke(ctx, "/events.EventPolicyV1/AutoGetEventPolicy", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eventPolicyV1Client) AutoListEventPolicy(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (*EventPolicyList, error) {
	out := new(EventPolicyList)
	err := grpc.Invoke(ctx, "/events.EventPolicyV1/AutoListEventPolicy", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eventPolicyV1Client) AutoUpdateEventPolicy(ctx context.Context, in *EventPolicy, opts ...grpc.CallOption) (*EventPolicy, error) {
	out := new(EventPolicy)
	err := grpc.Invoke(ctx, "/events.EventPolicyV1/AutoUpdateEventPolicy", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eventPolicyV1Client) AutoWatchEventPolicy(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (EventPolicyV1_AutoWatchEventPolicyClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_EventPolicyV1_serviceDesc.Streams[0], c.cc, "/events.EventPolicyV1/AutoWatchEventPolicy", opts...)
	if err != nil {
		return nil, err
	}
	x := &eventPolicyV1AutoWatchEventPolicyClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type EventPolicyV1_AutoWatchEventPolicyClient interface {
	Recv() (*AutoMsgEventPolicyWatchHelper, error)
	grpc.ClientStream
}

type eventPolicyV1AutoWatchEventPolicyClient struct {
	grpc.ClientStream
}

func (x *eventPolicyV1AutoWatchEventPolicyClient) Recv() (*AutoMsgEventPolicyWatchHelper, error) {
	m := new(AutoMsgEventPolicyWatchHelper)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for EventPolicyV1 service

type EventPolicyV1Server interface {
	AutoAddEventPolicy(context.Context, *EventPolicy) (*EventPolicy, error)
	AutoDeleteEventPolicy(context.Context, *EventPolicy) (*EventPolicy, error)
	AutoGetEventPolicy(context.Context, *EventPolicy) (*EventPolicy, error)
	AutoListEventPolicy(context.Context, *api.ListWatchOptions) (*EventPolicyList, error)
	AutoUpdateEventPolicy(context.Context, *EventPolicy) (*EventPolicy, error)
	AutoWatchEventPolicy(*api.ListWatchOptions, EventPolicyV1_AutoWatchEventPolicyServer) error
}

func RegisterEventPolicyV1Server(s *grpc.Server, srv EventPolicyV1Server) {
	s.RegisterService(&_EventPolicyV1_serviceDesc, srv)
}

func _EventPolicyV1_AutoAddEventPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EventPolicy)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EventPolicyV1Server).AutoAddEventPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/events.EventPolicyV1/AutoAddEventPolicy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EventPolicyV1Server).AutoAddEventPolicy(ctx, req.(*EventPolicy))
	}
	return interceptor(ctx, in, info, handler)
}

func _EventPolicyV1_AutoDeleteEventPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EventPolicy)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EventPolicyV1Server).AutoDeleteEventPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/events.EventPolicyV1/AutoDeleteEventPolicy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EventPolicyV1Server).AutoDeleteEventPolicy(ctx, req.(*EventPolicy))
	}
	return interceptor(ctx, in, info, handler)
}

func _EventPolicyV1_AutoGetEventPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EventPolicy)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EventPolicyV1Server).AutoGetEventPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/events.EventPolicyV1/AutoGetEventPolicy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EventPolicyV1Server).AutoGetEventPolicy(ctx, req.(*EventPolicy))
	}
	return interceptor(ctx, in, info, handler)
}

func _EventPolicyV1_AutoListEventPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(api.ListWatchOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EventPolicyV1Server).AutoListEventPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/events.EventPolicyV1/AutoListEventPolicy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EventPolicyV1Server).AutoListEventPolicy(ctx, req.(*api.ListWatchOptions))
	}
	return interceptor(ctx, in, info, handler)
}

func _EventPolicyV1_AutoUpdateEventPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EventPolicy)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EventPolicyV1Server).AutoUpdateEventPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/events.EventPolicyV1/AutoUpdateEventPolicy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EventPolicyV1Server).AutoUpdateEventPolicy(ctx, req.(*EventPolicy))
	}
	return interceptor(ctx, in, info, handler)
}

func _EventPolicyV1_AutoWatchEventPolicy_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(api.ListWatchOptions)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(EventPolicyV1Server).AutoWatchEventPolicy(m, &eventPolicyV1AutoWatchEventPolicyServer{stream})
}

type EventPolicyV1_AutoWatchEventPolicyServer interface {
	Send(*AutoMsgEventPolicyWatchHelper) error
	grpc.ServerStream
}

type eventPolicyV1AutoWatchEventPolicyServer struct {
	grpc.ServerStream
}

func (x *eventPolicyV1AutoWatchEventPolicyServer) Send(m *AutoMsgEventPolicyWatchHelper) error {
	return x.ServerStream.SendMsg(m)
}

var _EventPolicyV1_serviceDesc = grpc.ServiceDesc{
	ServiceName: "events.EventPolicyV1",
	HandlerType: (*EventPolicyV1Server)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AutoAddEventPolicy",
			Handler:    _EventPolicyV1_AutoAddEventPolicy_Handler,
		},
		{
			MethodName: "AutoDeleteEventPolicy",
			Handler:    _EventPolicyV1_AutoDeleteEventPolicy_Handler,
		},
		{
			MethodName: "AutoGetEventPolicy",
			Handler:    _EventPolicyV1_AutoGetEventPolicy_Handler,
		},
		{
			MethodName: "AutoListEventPolicy",
			Handler:    _EventPolicyV1_AutoListEventPolicy_Handler,
		},
		{
			MethodName: "AutoUpdateEventPolicy",
			Handler:    _EventPolicyV1_AutoUpdateEventPolicy_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "AutoWatchEventPolicy",
			Handler:       _EventPolicyV1_AutoWatchEventPolicy_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "events.proto",
}

// Client API for EventV1 service

type EventV1Client interface {
	AutoAddEvent(ctx context.Context, in *Event, opts ...grpc.CallOption) (*Event, error)
	AutoDeleteEvent(ctx context.Context, in *Event, opts ...grpc.CallOption) (*Event, error)
	AutoGetEvent(ctx context.Context, in *Event, opts ...grpc.CallOption) (*Event, error)
	AutoListEvent(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (*EventList, error)
	AutoUpdateEvent(ctx context.Context, in *Event, opts ...grpc.CallOption) (*Event, error)
	AutoWatchEvent(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (EventV1_AutoWatchEventClient, error)
}

type eventV1Client struct {
	cc *grpc.ClientConn
}

func NewEventV1Client(cc *grpc.ClientConn) EventV1Client {
	return &eventV1Client{cc}
}

func (c *eventV1Client) AutoAddEvent(ctx context.Context, in *Event, opts ...grpc.CallOption) (*Event, error) {
	out := new(Event)
	err := grpc.Invoke(ctx, "/events.EventV1/AutoAddEvent", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eventV1Client) AutoDeleteEvent(ctx context.Context, in *Event, opts ...grpc.CallOption) (*Event, error) {
	out := new(Event)
	err := grpc.Invoke(ctx, "/events.EventV1/AutoDeleteEvent", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eventV1Client) AutoGetEvent(ctx context.Context, in *Event, opts ...grpc.CallOption) (*Event, error) {
	out := new(Event)
	err := grpc.Invoke(ctx, "/events.EventV1/AutoGetEvent", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eventV1Client) AutoListEvent(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (*EventList, error) {
	out := new(EventList)
	err := grpc.Invoke(ctx, "/events.EventV1/AutoListEvent", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eventV1Client) AutoUpdateEvent(ctx context.Context, in *Event, opts ...grpc.CallOption) (*Event, error) {
	out := new(Event)
	err := grpc.Invoke(ctx, "/events.EventV1/AutoUpdateEvent", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eventV1Client) AutoWatchEvent(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (EventV1_AutoWatchEventClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_EventV1_serviceDesc.Streams[0], c.cc, "/events.EventV1/AutoWatchEvent", opts...)
	if err != nil {
		return nil, err
	}
	x := &eventV1AutoWatchEventClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type EventV1_AutoWatchEventClient interface {
	Recv() (*AutoMsgEventWatchHelper, error)
	grpc.ClientStream
}

type eventV1AutoWatchEventClient struct {
	grpc.ClientStream
}

func (x *eventV1AutoWatchEventClient) Recv() (*AutoMsgEventWatchHelper, error) {
	m := new(AutoMsgEventWatchHelper)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for EventV1 service

type EventV1Server interface {
	AutoAddEvent(context.Context, *Event) (*Event, error)
	AutoDeleteEvent(context.Context, *Event) (*Event, error)
	AutoGetEvent(context.Context, *Event) (*Event, error)
	AutoListEvent(context.Context, *api.ListWatchOptions) (*EventList, error)
	AutoUpdateEvent(context.Context, *Event) (*Event, error)
	AutoWatchEvent(*api.ListWatchOptions, EventV1_AutoWatchEventServer) error
}

func RegisterEventV1Server(s *grpc.Server, srv EventV1Server) {
	s.RegisterService(&_EventV1_serviceDesc, srv)
}

func _EventV1_AutoAddEvent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Event)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EventV1Server).AutoAddEvent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/events.EventV1/AutoAddEvent",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EventV1Server).AutoAddEvent(ctx, req.(*Event))
	}
	return interceptor(ctx, in, info, handler)
}

func _EventV1_AutoDeleteEvent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Event)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EventV1Server).AutoDeleteEvent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/events.EventV1/AutoDeleteEvent",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EventV1Server).AutoDeleteEvent(ctx, req.(*Event))
	}
	return interceptor(ctx, in, info, handler)
}

func _EventV1_AutoGetEvent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Event)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EventV1Server).AutoGetEvent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/events.EventV1/AutoGetEvent",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EventV1Server).AutoGetEvent(ctx, req.(*Event))
	}
	return interceptor(ctx, in, info, handler)
}

func _EventV1_AutoListEvent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(api.ListWatchOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EventV1Server).AutoListEvent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/events.EventV1/AutoListEvent",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EventV1Server).AutoListEvent(ctx, req.(*api.ListWatchOptions))
	}
	return interceptor(ctx, in, info, handler)
}

func _EventV1_AutoUpdateEvent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Event)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EventV1Server).AutoUpdateEvent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/events.EventV1/AutoUpdateEvent",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EventV1Server).AutoUpdateEvent(ctx, req.(*Event))
	}
	return interceptor(ctx, in, info, handler)
}

func _EventV1_AutoWatchEvent_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(api.ListWatchOptions)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(EventV1Server).AutoWatchEvent(m, &eventV1AutoWatchEventServer{stream})
}

type EventV1_AutoWatchEventServer interface {
	Send(*AutoMsgEventWatchHelper) error
	grpc.ServerStream
}

type eventV1AutoWatchEventServer struct {
	grpc.ServerStream
}

func (x *eventV1AutoWatchEventServer) Send(m *AutoMsgEventWatchHelper) error {
	return x.ServerStream.SendMsg(m)
}

var _EventV1_serviceDesc = grpc.ServiceDesc{
	ServiceName: "events.EventV1",
	HandlerType: (*EventV1Server)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AutoAddEvent",
			Handler:    _EventV1_AutoAddEvent_Handler,
		},
		{
			MethodName: "AutoDeleteEvent",
			Handler:    _EventV1_AutoDeleteEvent_Handler,
		},
		{
			MethodName: "AutoGetEvent",
			Handler:    _EventV1_AutoGetEvent_Handler,
		},
		{
			MethodName: "AutoListEvent",
			Handler:    _EventV1_AutoListEvent_Handler,
		},
		{
			MethodName: "AutoUpdateEvent",
			Handler:    _EventV1_AutoUpdateEvent_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "AutoWatchEvent",
			Handler:       _EventV1_AutoWatchEvent_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "events.proto",
}

func (m *AutoMsgEventPolicyWatchHelper) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AutoMsgEventPolicyWatchHelper) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if m.Object != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintEvents(dAtA, i, uint64(m.Object.Size()))
		n1, err := m.Object.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	return i, nil
}

func (m *AutoMsgEventWatchHelper) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AutoMsgEventWatchHelper) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if m.Object != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintEvents(dAtA, i, uint64(m.Object.Size()))
		n2, err := m.Object.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}

func (m *Event) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Event) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintEvents(dAtA, i, uint64(m.TypeMeta.Size()))
	n3, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n3
	dAtA[i] = 0x12
	i++
	i = encodeVarintEvents(dAtA, i, uint64(m.ObjectMeta.Size()))
	n4, err := m.ObjectMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n4
	dAtA[i] = 0x1a
	i++
	i = encodeVarintEvents(dAtA, i, uint64(m.Spec.Size()))
	n5, err := m.Spec.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n5
	dAtA[i] = 0x22
	i++
	i = encodeVarintEvents(dAtA, i, uint64(m.Status.Size()))
	n6, err := m.Status.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n6
	return i, nil
}

func (m *EventList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x12
	i++
	i = encodeVarintEvents(dAtA, i, uint64(m.TypeMeta.Size()))
	n7, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n7
	dAtA[i] = 0x1a
	i++
	i = encodeVarintEvents(dAtA, i, uint64(m.ListMeta.Size()))
	n8, err := m.ListMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n8
	if len(m.Items) > 0 {
		for _, msg := range m.Items {
			dAtA[i] = 0x22
			i++
			i = encodeVarintEvents(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *EventPolicy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventPolicy) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintEvents(dAtA, i, uint64(m.TypeMeta.Size()))
	n9, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n9
	dAtA[i] = 0x12
	i++
	i = encodeVarintEvents(dAtA, i, uint64(m.ObjectMeta.Size()))
	n10, err := m.ObjectMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n10
	dAtA[i] = 0x1a
	i++
	i = encodeVarintEvents(dAtA, i, uint64(m.Spec.Size()))
	n11, err := m.Spec.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n11
	dAtA[i] = 0x22
	i++
	i = encodeVarintEvents(dAtA, i, uint64(m.Status.Size()))
	n12, err := m.Status.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n12
	return i, nil
}

func (m *EventPolicyList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventPolicyList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x12
	i++
	i = encodeVarintEvents(dAtA, i, uint64(m.TypeMeta.Size()))
	n13, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n13
	dAtA[i] = 0x1a
	i++
	i = encodeVarintEvents(dAtA, i, uint64(m.ListMeta.Size()))
	n14, err := m.ListMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n14
	if len(m.Items) > 0 {
		for _, msg := range m.Items {
			dAtA[i] = 0x22
			i++
			i = encodeVarintEvents(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *EventPolicySpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventPolicySpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Levels) > 0 {
		for _, s := range m.Levels {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.RetentionPolicy) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintEvents(dAtA, i, uint64(len(m.RetentionPolicy)))
		i += copy(dAtA[i:], m.RetentionPolicy)
	}
	if len(m.ExportPolicies) > 0 {
		for _, s := range m.ExportPolicies {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *EventPolicyStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventPolicyStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *EventSource) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventSource) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Component) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Component)))
		i += copy(dAtA[i:], m.Component)
	}
	if len(m.Node) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Node)))
		i += copy(dAtA[i:], m.Node)
	}
	return i, nil
}

func (m *EventSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *EventStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Severity) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Severity)))
		i += copy(dAtA[i:], m.Severity)
	}
	if len(m.Description) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	if m.ObjectRef != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintEvents(dAtA, i, uint64(m.ObjectRef.Size()))
		n15, err := m.ObjectRef.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	if m.Source != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintEvents(dAtA, i, uint64(m.Source.Size()))
		n16, err := m.Source.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	if len(m.CreatedTime) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintEvents(dAtA, i, uint64(len(m.CreatedTime)))
		i += copy(dAtA[i:], m.CreatedTime)
	}
	if len(m.EventPolicy) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintEvents(dAtA, i, uint64(len(m.EventPolicy)))
		i += copy(dAtA[i:], m.EventPolicy)
	}
	return i, nil
}

func encodeFixed64Events(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Events(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintEvents(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *AutoMsgEventPolicyWatchHelper) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.Object != nil {
		l = m.Object.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *AutoMsgEventWatchHelper) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.Object != nil {
		l = m.Object.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *Event) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovEvents(uint64(l))
	l = m.ObjectMeta.Size()
	n += 1 + l + sovEvents(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovEvents(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovEvents(uint64(l))
	return n
}

func (m *EventList) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovEvents(uint64(l))
	l = m.ListMeta.Size()
	n += 1 + l + sovEvents(uint64(l))
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovEvents(uint64(l))
		}
	}
	return n
}

func (m *EventPolicy) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovEvents(uint64(l))
	l = m.ObjectMeta.Size()
	n += 1 + l + sovEvents(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovEvents(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovEvents(uint64(l))
	return n
}

func (m *EventPolicyList) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovEvents(uint64(l))
	l = m.ListMeta.Size()
	n += 1 + l + sovEvents(uint64(l))
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovEvents(uint64(l))
		}
	}
	return n
}

func (m *EventPolicySpec) Size() (n int) {
	var l int
	_ = l
	if len(m.Levels) > 0 {
		for _, s := range m.Levels {
			l = len(s)
			n += 1 + l + sovEvents(uint64(l))
		}
	}
	l = len(m.RetentionPolicy)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if len(m.ExportPolicies) > 0 {
		for _, s := range m.ExportPolicies {
			l = len(s)
			n += 1 + l + sovEvents(uint64(l))
		}
	}
	return n
}

func (m *EventPolicyStatus) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *EventSource) Size() (n int) {
	var l int
	_ = l
	l = len(m.Component)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.Node)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *EventSpec) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *EventStatus) Size() (n int) {
	var l int
	_ = l
	l = len(m.Severity)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.ObjectRef != nil {
		l = m.ObjectRef.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.Source != nil {
		l = m.Source.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.CreatedTime)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.EventPolicy)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func sovEvents(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozEvents(x uint64) (n int) {
	return sovEvents(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *AutoMsgEventPolicyWatchHelper) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AutoMsgEventPolicyWatchHelper: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AutoMsgEventPolicyWatchHelper: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Object", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Object == nil {
				m.Object = &EventPolicy{}
			}
			if err := m.Object.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AutoMsgEventWatchHelper) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AutoMsgEventWatchHelper: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AutoMsgEventWatchHelper: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Object", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Object == nil {
				m.Object = &Event{}
			}
			if err := m.Object.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Event) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Event: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Event: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ListMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &Event{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventPolicy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventPolicy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventPolicy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventPolicyList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventPolicyList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventPolicyList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ListMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &EventPolicy{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventPolicySpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventPolicySpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventPolicySpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Levels", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Levels = append(m.Levels, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetentionPolicy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RetentionPolicy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExportPolicies", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExportPolicies = append(m.ExportPolicies, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventPolicyStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventPolicyStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventPolicyStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventSource) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventSource: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventSource: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Component", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Component = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Node", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Node = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Severity", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Severity = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectRef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ObjectRef == nil {
				m.ObjectRef = &api.ObjectRef{}
			}
			if err := m.ObjectRef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Source == nil {
				m.Source = &EventSource{}
			}
			if err := m.Source.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CreatedTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventPolicy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EventPolicy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipEvents(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthEvents
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowEvents
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipEvents(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthEvents = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowEvents   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("events.proto", fileDescriptorEvents) }

var fileDescriptorEvents = []byte{
	// 1298 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x57, 0x4d, 0x6f, 0xdb, 0x46,
	0x13, 0x36, 0xf5, 0x15, 0x6b, 0x25, 0x4b, 0xca, 0x5a, 0x89, 0x45, 0x26, 0xb1, 0x1c, 0xbe, 0x48,
	0x5e, 0xc7, 0x88, 0xa5, 0xc4, 0x45, 0x5b, 0xd4, 0x09, 0x10, 0x48, 0x8a, 0x92, 0x18, 0x75, 0xac,
	0x40, 0x52, 0x13, 0xf4, 0x56, 0x9a, 0x1a, 0xcb, 0x0c, 0x24, 0x92, 0x20, 0x57, 0x76, 0x8d, 0xc2,
	0x3d, 0x54, 0x4d, 0xd1, 0x73, 0xeb, 0x4b, 0x7b, 0x29, 0xe0, 0xa3, 0x8f, 0xfd, 0x15, 0x39, 0x06,
	0xc9, 0xa5, 0xcd, 0x41, 0x28, 0x8c, 0x1e, 0x0a, 0xfd, 0x88, 0xa2, 0xd8, 0x25, 0x69, 0x2f, 0xf5,
	0x61, 0x1b, 0x06, 0xda, 0x9b, 0x76, 0x77, 0xe6, 0x79, 0x66, 0x9e, 0x99, 0x59, 0xae, 0x50, 0x1c,
	0xb6, 0x40, 0x27, 0x76, 0xce, 0xb4, 0x0c, 0x62, 0xe0, 0x88, 0xb3, 0x92, 0xae, 0x36, 0x0d, 0xa3,
	0xd9, 0x82, 0xbc, 0x62, 0x6a, 0x79, 0x45, 0xd7, 0x0d, 0xa2, 0x10, 0xcd, 0xd0, 0x5d, 0x2b, 0xa9,
	0xdc, 0xd4, 0xc8, 0x66, 0x67, 0x3d, 0xa7, 0x1a, 0xed, 0xbc, 0x09, 0xba, 0xad, 0xe8, 0x0d, 0x23,
	0x6f, 0x6f, 0xe7, 0xb7, 0x40, 0xd7, 0x54, 0xc8, 0x77, 0x88, 0xd6, 0xb2, 0xa9, 0x6b, 0x13, 0x74,
	0xde, 0x3b, 0xaf, 0xe9, 0x6a, 0xab, 0xd3, 0x00, 0x0f, 0x66, 0x91, 0x83, 0x69, 0x1a, 0x4d, 0x23,
	0xcf, 0xb6, 0xd7, 0x3b, 0x1b, 0x6c, 0xc5, 0x16, 0xec, 0x97, 0x6b, 0x7e, 0x63, 0x0c, 0x2b, 0x8d,
	0xb1, 0x0d, 0x44, 0x71, 0xcc, 0x64, 0x15, 0x5d, 0x2b, 0x74, 0x88, 0xf1, 0xd4, 0x6e, 0x96, 0x69,
	0x2e, 0xcf, 0x8c, 0x96, 0xa6, 0xee, 0xbc, 0x50, 0x88, 0xba, 0xf9, 0x04, 0x5a, 0x26, 0x58, 0x38,
	0x8e, 0x42, 0xf5, 0x1d, 0x13, 0x32, 0xc2, 0x9c, 0x30, 0x1f, 0xc5, 0xff, 0x43, 0x91, 0xca, 0xfa,
	0x4b, 0x50, 0x49, 0x26, 0x30, 0x27, 0xcc, 0xc7, 0x96, 0xa6, 0x73, 0xae, 0x20, 0x9c, 0xf7, 0x72,
	0xf2, 0xfd, 0x5e, 0x3a, 0xb6, 0x4d, 0x31, 0x36, 0x19, 0x86, 0xfc, 0x02, 0xcd, 0xf0, 0x24, 0xe3,
	0xe1, 0xaf, 0x0d, 0xc0, 0x4f, 0xf9, 0xe0, 0x87, 0x81, 0xff, 0x16, 0x50, 0x98, 0x1d, 0xe1, 0x3b,
	0x48, 0xa8, 0x33, 0x10, 0xea, 0xa4, 0x98, 0x5a, 0x8e, 0xa2, 0x3e, 0x05, 0xa2, 0x14, 0xa7, 0x5f,
	0xf7, 0xb2, 0x13, 0x6f, 0x7a, 0x59, 0xa1, 0xdf, 0xcb, 0x5e, 0xb8, 0xad, 0xe9, 0x2d, 0x4d, 0x87,
	0xaa, 0x50, 0xc7, 0x9f, 0x20, 0xa1, 0xe2, 0xd2, 0x24, 0x99, 0x87, 0xc3, 0xcc, 0x7c, 0x24, 0xce,
	0x27, 0x41, 0xd5, 0xba, 0x6d, 0xb4, 0x35, 0x02, 0x6d, 0x93, 0xec, 0x54, 0x85, 0x0a, 0xfe, 0x08,
	0x85, 0x6a, 0x26, 0xa8, 0x99, 0x20, 0xf3, 0xbe, 0xe8, 0x0b, 0x92, 0x1e, 0x14, 0x93, 0xd4, 0x9f,
	0xe7, 0x63, 0xf6, 0xb8, 0x8c, 0x22, 0x35, 0xa2, 0x90, 0x8e, 0x9d, 0x09, 0x8d, 0x50, 0xcf, 0x39,
	0x2a, 0x66, 0x5c, 0xdf, 0x94, 0xcd, 0xd6, 0x1c, 0xb3, 0xeb, 0xbc, 0x1c, 0x7d, 0xfb, 0x4a, 0x0c,
	0x33, 0x4f, 0xf9, 0x7b, 0x01, 0x45, 0x99, 0xf3, 0xaa, 0x66, 0x13, 0x2c, 0x53, 0x11, 0x02, 0xa3,
	0x44, 0x98, 0xf4, 0x12, 0xc2, 0xb7, 0xd0, 0x24, 0xb5, 0xa5, 0xbb, 0x6e, 0xfc, 0x8e, 0xa9, 0xb7,
	0xc9, 0x99, 0x5e, 0x45, 0xe1, 0x15, 0x02, 0x6d, 0x1a, 0x6d, 0x70, 0xb8, 0x18, 0x89, 0xf7, 0x7b,
	0x69, 0xd4, 0xd2, 0x6c, 0xe2, 0xd6, 0x62, 0x3f, 0x80, 0x62, 0x5c, 0x17, 0xfc, 0xb7, 0x15, 0x29,
	0xf9, 0x2a, 0x32, 0x33, 0xa2, 0x2b, 0x59, 0x5d, 0x2e, 0xbb, 0xda, 0x26, 0x6c, 0x13, 0x54, 0x0e,
	0xc1, 0x29, 0xcf, 0xa7, 0x03, 0xe5, 0x11, 0x47, 0xc1, 0x9c, 0xb5, 0x48, 0xe9, 0xb7, 0xaf, 0xc4,
	0x54, 0xdb, 0xd0, 0x35, 0x62, 0x58, 0x9a, 0xde, 0x74, 0xbc, 0xe5, 0x3d, 0x01, 0x25, 0x39, 0xb4,
	0x7f, 0xa3, 0x6a, 0xb2, 0xbf, 0x6a, 0x23, 0x27, 0x74, 0xb0, 0x76, 0x7f, 0xf9, 0xc3, 0x62, 0x6a,
	0x3c, 0x42, 0x91, 0x55, 0xd8, 0x82, 0x96, 0x9d, 0x11, 0xe6, 0x82, 0xf3, 0xd1, 0x62, 0xee, 0xe0,
	0x3b, 0xf1, 0x72, 0x8d, 0x58, 0x65, 0xbd, 0xd3, 0x9e, 0xaf, 0xc1, 0x16, 0x58, 0x1a, 0xd9, 0x61,
	0x16, 0xb7, 0xa8, 0x10, 0x2d, 0x66, 0xcb, 0x0b, 0xe1, 0x78, 0xe3, 0x27, 0x28, 0x59, 0x05, 0x02,
	0x3a, 0xbd, 0xd4, 0x1c, 0x78, 0x96, 0x6c, 0xb4, 0x38, 0xdb, 0xef, 0x65, 0x25, 0xcb, 0x3b, 0x5a,
	0x34, 0xd9, 0x19, 0x07, 0x30, 0xe8, 0x86, 0x4b, 0x28, 0x51, 0xfe, 0xd2, 0x34, 0x2c, 0x27, 0x4a,
	0x0d, 0xec, 0x4c, 0x90, 0x45, 0x76, 0xa5, 0xdf, 0xcb, 0xce, 0x00, 0x3b, 0x19, 0x46, 0x19, 0x70,
	0x91, 0xa7, 0xd1, 0xc5, 0xa1, 0x72, 0xca, 0x2d, 0xb7, 0x75, 0x6b, 0x46, 0xc7, 0x52, 0x01, 0x7f,
	0x88, 0xa2, 0x25, 0xa3, 0x6d, 0x1a, 0x3a, 0xe8, 0xc4, 0xb9, 0x99, 0x8a, 0x33, 0xfd, 0x5e, 0x76,
	0x5a, 0xf5, 0x36, 0x39, 0xfc, 0x63, 0x4b, 0x7c, 0x13, 0x85, 0xd6, 0x8c, 0x06, 0xb8, 0xe9, 0x61,
	0xda, 0x67, 0xba, 0xd1, 0x00, 0xbe, 0xcf, 0xe8, 0xb9, 0x1c, 0x73, 0x67, 0x96, 0xca, 0x2c, 0xff,
	0x12, 0xf4, 0xb8, 0x59, 0x28, 0x78, 0x15, 0x4d, 0x7a, 0xe2, 0xba, 0xd4, 0x77, 0x4e, 0x14, 0x1e,
	0xdb, 0xee, 0x0e, 0x47, 0x73, 0x84, 0x80, 0xef, 0xa1, 0xd8, 0x43, 0xb0, 0x55, 0x4b, 0x33, 0xa9,
	0x8e, 0x6e, 0x64, 0x62, 0xbf, 0x97, 0xbd, 0xd4, 0x38, 0xde, 0xe6, 0x3c, 0x79, 0x6b, 0xfc, 0x08,
	0x45, 0x9d, 0x09, 0xac, 0xc2, 0x86, 0xdb, 0x75, 0x09, 0x6e, 0x2e, 0xab, 0xb0, 0x51, 0xcc, 0xf4,
	0x7b, 0xd9, 0xb4, 0xc1, 0x96, 0x8b, 0x16, 0x6c, 0xf0, 0xba, 0x1c, 0x19, 0xe1, 0x02, 0x8a, 0x38,
	0xc2, 0x8e, 0xbe, 0xf6, 0xd8, 0x51, 0x31, 0xcd, 0xa6, 0x89, 0xfd, 0xf6, 0x4d, 0x93, 0x53, 0x91,
	0xfb, 0x28, 0x56, 0xb2, 0x40, 0x21, 0xd0, 0xa8, 0x6b, 0x6d, 0xc8, 0x84, 0x59, 0x1e, 0x52, 0xbf,
	0x97, 0xbd, 0xac, 0x3a, 0xdb, 0x8b, 0x44, 0x6b, 0xf3, 0x8e, 0xbc, 0x39, 0xf5, 0xe6, 0x6a, 0x9e,
	0x89, 0x1c, 0x7b, 0xb3, 0x40, 0x86, 0x9b, 0x86, 0x37, 0x5f, 0x78, 0x80, 0xa6, 0x7c, 0xaa, 0xe3,
	0x49, 0x14, 0x5a, 0x59, 0x7b, 0x54, 0x49, 0x4d, 0xe0, 0x18, 0xba, 0xf0, 0xa2, 0x50, 0x5d, 0x5b,
	0x59, 0x7b, 0x9c, 0x12, 0x70, 0x14, 0x85, 0xcb, 0xd5, 0x6a, 0xa5, 0x9a, 0x0a, 0xe0, 0x38, 0x9a,
	0x2c, 0x55, 0x57, 0xea, 0x2b, 0xa5, 0xc2, 0x6a, 0x2a, 0xb8, 0xf4, 0x2e, 0x82, 0xa6, 0x38, 0xc0,
	0xe7, 0x77, 0xb1, 0x85, 0x30, 0xfd, 0x20, 0x16, 0x1a, 0x0d, 0xfe, 0xc6, 0x1c, 0x35, 0xaa, 0xd2,
	0xa8, 0x4d, 0x79, 0xe9, 0xb7, 0xbd, 0xb4, 0xf0, 0xeb, 0xb7, 0x62, 0xc4, 0xc9, 0xfe, 0x9b, 0x77,
	0x7f, 0xfe, 0x18, 0x98, 0x45, 0x13, 0xcb, 0xc2, 0x82, 0x3c, 0x93, 0xff, 0xaa, 0x92, 0xab, 0x83,
	0xae, 0xe8, 0x64, 0x37, 0x0f, 0x1c, 0xfa, 0x2e, 0xba, 0x44, 0x39, 0x1f, 0x42, 0x0b, 0x08, 0x9c,
	0x8f, 0x76, 0xd9, 0xa3, 0x6d, 0x30, 0x10, 0x46, 0x7b, 0x13, 0x4d, 0x2c, 0x4f, 0x2c, 0xcc, 0x8d,
	0x61, 0xa5, 0xdb, 0x6b, 0x4a, 0x1b, 0x76, 0xf1, 0xb6, 0x93, 0xf2, 0x63, 0x20, 0xe7, 0xe3, 0xfe,
	0xd8, 0xe5, 0x0e, 0x36, 0x81, 0x1c, 0x13, 0xe3, 0xd3, 0x89, 0x6b, 0x68, 0x9a, 0x12, 0xd3, 0x9b,
	0x92, 0x67, 0xbe, 0x74, 0x74, 0x7f, 0xb2, 0xe7, 0x48, 0x85, 0xb5, 0xbc, 0x2d, 0x8d, 0xfa, 0x74,
	0x50, 0x23, 0x39, 0xee, 0xf2, 0x87, 0xe8, 0xb5, 0x89, 0xbf, 0x76, 0xc4, 0xfc, 0xcc, 0x6c, 0x28,
	0xe7, 0x15, 0xf3, 0x9e, 0x27, 0x66, 0x87, 0x81, 0xb0, 0x9c, 0xfe, 0xcf, 0x6a, 0x28, 0x9d, 0x9e,
	0x14, 0xa0, 0x34, 0xe5, 0x67, 0xa1, 0x9f, 0x21, 0xab, 0x1b, 0x5e, 0x00, 0x27, 0xbe, 0xf5, 0xe4,
	0x29, 0x37, 0xa4, 0x30, 0x7b, 0x63, 0xdd, 0x11, 0xa4, 0x9f, 0x84, 0x1f, 0xba, 0x62, 0x60, 0xeb,
	0xee, 0xcf, 0x5d, 0x31, 0xc6, 0xc5, 0xb1, 0xdf, 0x15, 0xf9, 0x09, 0x39, 0xe8, 0x8a, 0x05, 0xff,
	0xb7, 0x9f, 0x16, 0x09, 0x07, 0xcd, 0x0e, 0xc1, 0x6e, 0xab, 0x9c, 0x9e, 0xd2, 0x41, 0x57, 0xbc,
	0xed, 0x07, 0x09, 0x99, 0x86, 0x4d, 0xa4, 0x71, 0xfd, 0xbc, 0xf4, 0x7b, 0x08, 0x5d, 0x60, 0xe6,
	0xcf, 0xef, 0xe2, 0xfb, 0x28, 0xce, 0xcf, 0x13, 0xf6, 0x3f, 0x55, 0x24, 0xff, 0x52, 0x4e, 0xf8,
	0xa7, 0x07, 0x3f, 0x40, 0xc9, 0x81, 0xc9, 0x38, 0x2b, 0x80, 0x93, 0x1c, 0xfe, 0xc2, 0xa1, 0xf7,
	0x7a, 0xfb, 0x14, 0xef, 0xa5, 0xc1, 0x4e, 0xbe, 0xce, 0x3a, 0xf9, 0xca, 0x50, 0xa2, 0x36, 0x5f,
	0xef, 0x29, 0x5f, 0x13, 0x8f, 0x2b, 0xb4, 0xff, 0x2d, 0xca, 0x1a, 0x77, 0x81, 0x6f, 0x5c, 0xc6,
	0x97, 0x61, 0x7c, 0x78, 0x98, 0xcf, 0x53, 0x82, 0x6b, 0xeb, 0xb3, 0x2a, 0xe1, 0x34, 0x31, 0xfe,
	0x1c, 0x25, 0xfc, 0x7d, 0x39, 0x2e, 0xd0, 0xec, 0xa8, 0x8e, 0x3c, 0xb1, 0x17, 0x5f, 0x1e, 0xb5,
	0xa2, 0xf3, 0xf6, 0xdd, 0xef, 0x8a, 0xce, 0xdb, 0xff, 0xa0, 0x2b, 0xde, 0xf2, 0xfe, 0x06, 0x50,
	0x4d, 0xa5, 0x93, 0x94, 0x3c, 0xe8, 0x8a, 0xd7, 0x3d, 0x63, 0xa6, 0x88, 0x34, 0x42, 0x87, 0x62,
	0xfc, 0xf5, 0xe1, 0xac, 0xf0, 0xe6, 0x70, 0x56, 0xf8, 0xe3, 0x70, 0x56, 0x78, 0x26, 0xac, 0x47,
	0xd8, 0x9f, 0xa5, 0x0f, 0xfe, 0x09, 0x00, 0x00, 0xff, 0xff, 0x8f, 0x7c, 0xe9, 0xa6, 0xff, 0x0d,
	0x00, 0x00,
}
