// Code generated by protoc-gen-grpc-pensando DO NOT EDIT.

package grpcclient

import (
	"context"
	"errors"
	oldlog "log"
	"net/http"

	"github.com/go-kit/kit/endpoint"
	grpctransport "github.com/go-kit/kit/transport/grpc"
	"google.golang.org/grpc"

	api "github.com/pensando/sw/api"
	routing "github.com/pensando/sw/api/generated/routing"
	"github.com/pensando/sw/api/interfaces"
	listerwatcher "github.com/pensando/sw/api/listerwatcher"
	"github.com/pensando/sw/venice/utils/kvstore"
	"github.com/pensando/sw/venice/utils/log"
	"github.com/pensando/sw/venice/utils/trace"
)

// Dummy vars to suppress import errors
var _ api.TypeMeta
var _ listerwatcher.WatcherClient
var _ kvstore.Interface

// NewRoutingV1 sets up a new client for RoutingV1
func NewRoutingV1(conn *grpc.ClientConn, logger log.Logger) routing.ServiceRoutingV1Client {

	var lAutoAddNeighborEndpoint endpoint.Endpoint
	{
		lAutoAddNeighborEndpoint = grpctransport.NewClient(
			conn,
			"routing.RoutingV1",
			"AutoAddNeighbor",
			routing.EncodeGrpcReqNeighbor,
			routing.DecodeGrpcRespNeighbor,
			&routing.Neighbor{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoAddNeighborEndpoint = trace.ClientEndPoint("RoutingV1:AutoAddNeighbor")(lAutoAddNeighborEndpoint)
	}
	var lAutoDeleteNeighborEndpoint endpoint.Endpoint
	{
		lAutoDeleteNeighborEndpoint = grpctransport.NewClient(
			conn,
			"routing.RoutingV1",
			"AutoDeleteNeighbor",
			routing.EncodeGrpcReqNeighbor,
			routing.DecodeGrpcRespNeighbor,
			&routing.Neighbor{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoDeleteNeighborEndpoint = trace.ClientEndPoint("RoutingV1:AutoDeleteNeighbor")(lAutoDeleteNeighborEndpoint)
	}
	var lAutoGetNeighborEndpoint endpoint.Endpoint
	{
		lAutoGetNeighborEndpoint = grpctransport.NewClient(
			conn,
			"routing.RoutingV1",
			"AutoGetNeighbor",
			routing.EncodeGrpcReqNeighbor,
			routing.DecodeGrpcRespNeighbor,
			&routing.Neighbor{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoGetNeighborEndpoint = trace.ClientEndPoint("RoutingV1:AutoGetNeighbor")(lAutoGetNeighborEndpoint)
	}
	var lAutoLabelNeighborEndpoint endpoint.Endpoint
	{
		lAutoLabelNeighborEndpoint = grpctransport.NewClient(
			conn,
			"routing.RoutingV1",
			"AutoLabelNeighbor",
			routing.EncodeGrpcReqLabel,
			routing.DecodeGrpcRespNeighbor,
			&routing.Neighbor{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoLabelNeighborEndpoint = trace.ClientEndPoint("RoutingV1:AutoLabelNeighbor")(lAutoLabelNeighborEndpoint)
	}
	var lAutoListNeighborEndpoint endpoint.Endpoint
	{
		lAutoListNeighborEndpoint = grpctransport.NewClient(
			conn,
			"routing.RoutingV1",
			"AutoListNeighbor",
			routing.EncodeGrpcReqListWatchOptions,
			routing.DecodeGrpcRespNeighborList,
			&routing.NeighborList{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoListNeighborEndpoint = trace.ClientEndPoint("RoutingV1:AutoListNeighbor")(lAutoListNeighborEndpoint)
	}
	var lAutoUpdateNeighborEndpoint endpoint.Endpoint
	{
		lAutoUpdateNeighborEndpoint = grpctransport.NewClient(
			conn,
			"routing.RoutingV1",
			"AutoUpdateNeighbor",
			routing.EncodeGrpcReqNeighbor,
			routing.DecodeGrpcRespNeighbor,
			&routing.Neighbor{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoUpdateNeighborEndpoint = trace.ClientEndPoint("RoutingV1:AutoUpdateNeighbor")(lAutoUpdateNeighborEndpoint)
	}
	return routing.EndpointsRoutingV1Client{
		Client: routing.NewRoutingV1Client(conn),

		AutoAddNeighborEndpoint:    lAutoAddNeighborEndpoint,
		AutoDeleteNeighborEndpoint: lAutoDeleteNeighborEndpoint,
		AutoGetNeighborEndpoint:    lAutoGetNeighborEndpoint,
		AutoLabelNeighborEndpoint:  lAutoLabelNeighborEndpoint,
		AutoListNeighborEndpoint:   lAutoListNeighborEndpoint,
		AutoUpdateNeighborEndpoint: lAutoUpdateNeighborEndpoint,
	}
}

// NewRoutingV1Backend creates an instrumented client with middleware
func NewRoutingV1Backend(conn *grpc.ClientConn, logger log.Logger) routing.ServiceRoutingV1Client {
	cl := NewRoutingV1(conn, logger)
	cl = routing.LoggingRoutingV1MiddlewareClient(logger)(cl)
	return cl
}

type grpcObjRoutingV1Neighbor struct {
	logger log.Logger
	client routing.ServiceRoutingV1Client
}

func (a *grpcObjRoutingV1Neighbor) Create(ctx context.Context, in *routing.Neighbor) (*routing.Neighbor, error) {
	a.logger.DebugLog("msg", "received call", "object", "Neighbor", "oper", "create")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoAddNeighbor(nctx, in)
}

func (a *grpcObjRoutingV1Neighbor) Update(ctx context.Context, in *routing.Neighbor) (*routing.Neighbor, error) {
	a.logger.DebugLog("msg", "received call", "object", "Neighbor", "oper", "update")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoUpdateNeighbor(nctx, in)
}

func (a *grpcObjRoutingV1Neighbor) UpdateStatus(ctx context.Context, in *routing.Neighbor) (*routing.Neighbor, error) {
	a.logger.DebugLog("msg", "received call", "object", "Neighbor", "oper", "update")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	nctx = addStatusUpd(nctx)
	return a.client.AutoUpdateNeighbor(nctx, in)
}

func (a *grpcObjRoutingV1Neighbor) Label(ctx context.Context, in *api.Label) (*routing.Neighbor, error) {
	a.logger.DebugLog("msg", "received call", "object", "Neighbor", "oper", "label")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoLabelNeighbor(nctx, in)
}

func (a *grpcObjRoutingV1Neighbor) Get(ctx context.Context, objMeta *api.ObjectMeta) (*routing.Neighbor, error) {
	a.logger.DebugLog("msg", "received call", "object", "Neighbor", "oper", "get")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := routing.Neighbor{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoGetNeighbor(nctx, &in)
}

func (a *grpcObjRoutingV1Neighbor) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*routing.Neighbor, error) {
	a.logger.DebugLog("msg", "received call", "object", "Neighbor", "oper", "delete")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := routing.Neighbor{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoDeleteNeighbor(nctx, &in)
}

func (a *grpcObjRoutingV1Neighbor) List(ctx context.Context, options *api.ListWatchOptions) ([]*routing.Neighbor, error) {
	a.logger.DebugLog("msg", "received call", "object", "Neighbor", "oper", "list")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	r, err := a.client.AutoListNeighbor(nctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *grpcObjRoutingV1Neighbor) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	a.logger.DebugLog("msg", "received call", "object", "Neighbor", "oper", "WatchOper")
	nctx := addVersion(ctx, "v1")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	stream, err := a.client.AutoWatchNeighbor(nctx, options)
	if err != nil {
		return nil, err
	}
	wstream := stream.(routing.RoutingV1_AutoWatchNeighborClient)
	bridgefn := func(lw *listerwatcher.WatcherClient) {
		for {
			r, err := wstream.Recv()
			if err != nil {
				a.logger.ErrorLog("msg", "error on receive", "err", err)
				close(lw.OutCh)
				return
			}
			for _, e := range r.Events {
				ev := kvstore.WatchEvent{
					Type:   kvstore.WatchEventType(e.Type),
					Object: e.Object,
				}
				select {
				case lw.OutCh <- &ev:
				case <-wstream.Context().Done():
					close(lw.OutCh)
					return
				}
			}
		}
	}
	lw := listerwatcher.NewWatcherClient(wstream, bridgefn)
	lw.Run()
	return lw, nil
}

func (a *grpcObjRoutingV1Neighbor) Allowed(oper apiintf.APIOperType) bool {
	return true
}

type restObjRoutingV1Neighbor struct {
	endpoints routing.EndpointsRoutingV1RestClient
	instance  string
}

func (a *restObjRoutingV1Neighbor) Create(ctx context.Context, in *routing.Neighbor) (*routing.Neighbor, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoAddNeighbor(ctx, in)
}

func (a *restObjRoutingV1Neighbor) Update(ctx context.Context, in *routing.Neighbor) (*routing.Neighbor, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoUpdateNeighbor(ctx, in)
}

func (a *restObjRoutingV1Neighbor) UpdateStatus(ctx context.Context, in *routing.Neighbor) (*routing.Neighbor, error) {
	return nil, errors.New("not supported for REST")
}

func (a *restObjRoutingV1Neighbor) Label(ctx context.Context, in *api.Label) (*routing.Neighbor, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoLabelNeighbor(ctx, in)
}

func (a *restObjRoutingV1Neighbor) Get(ctx context.Context, objMeta *api.ObjectMeta) (*routing.Neighbor, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := routing.Neighbor{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoGetNeighbor(ctx, &in)
}

func (a *restObjRoutingV1Neighbor) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*routing.Neighbor, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := routing.Neighbor{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoDeleteNeighbor(ctx, &in)
}

func (a *restObjRoutingV1Neighbor) List(ctx context.Context, options *api.ListWatchOptions) ([]*routing.Neighbor, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}

	r, err := a.endpoints.AutoListNeighbor(ctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *restObjRoutingV1Neighbor) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoWatchNeighbor(ctx, options)
}

func (a *restObjRoutingV1Neighbor) Allowed(oper apiintf.APIOperType) bool {
	switch oper {
	case apiintf.CreateOper:
		return false
	case apiintf.UpdateOper:
		return false
	case apiintf.GetOper:
		return false
	case apiintf.DeleteOper:
		return false
	case apiintf.ListOper:
		return true
	case apiintf.WatchOper:
		return false
	default:
		return false
	}
}

type crudClientRoutingV1 struct {
	logger log.Logger
	client routing.ServiceRoutingV1Client

	grpcNeighbor routing.RoutingV1NeighborInterface
}

// NewGrpcCrudClientRoutingV1 creates a GRPC client for the service
func NewGrpcCrudClientRoutingV1(conn *grpc.ClientConn, logger log.Logger) routing.RoutingV1Interface {
	client := NewRoutingV1Backend(conn, logger)
	return &crudClientRoutingV1{
		logger: logger,
		client: client,

		grpcNeighbor: &grpcObjRoutingV1Neighbor{client: client, logger: logger},
	}
}

func (a *crudClientRoutingV1) Neighbor() routing.RoutingV1NeighborInterface {
	return a.grpcNeighbor
}

type crudRestClientRoutingV1 struct {
	restNeighbor routing.RoutingV1NeighborInterface
}

// NewRestCrudClientRoutingV1 creates a REST client for the service.
func NewRestCrudClientRoutingV1(url string, httpClient *http.Client) routing.RoutingV1Interface {
	endpoints, err := routing.MakeRoutingV1RestClientEndpoints(url, httpClient)
	if err != nil {
		oldlog.Fatal("failed to create client")
	}
	return &crudRestClientRoutingV1{

		restNeighbor: &restObjRoutingV1Neighbor{endpoints: endpoints, instance: url},
	}
}

// NewStagedRestCrudClientRoutingV1 creates a REST client for the service.
func NewStagedRestCrudClientRoutingV1(url string, id string, httpClient *http.Client) routing.RoutingV1Interface {
	endpoints, err := routing.MakeRoutingV1StagedRestClientEndpoints(url, id, httpClient)
	if err != nil {
		oldlog.Fatal("failed to create client")
	}
	return &crudRestClientRoutingV1{

		restNeighbor: &restObjRoutingV1Neighbor{endpoints: endpoints, instance: url},
	}
}

func (a *crudRestClientRoutingV1) Neighbor() routing.RoutingV1NeighborInterface {
	return a.restNeighbor
}

func (a *crudRestClientRoutingV1) Watch(ctx context.Context, options *api.AggWatchOptions) (kvstore.Watcher, error) {
	return nil, errors.New("method unimplemented")
}
