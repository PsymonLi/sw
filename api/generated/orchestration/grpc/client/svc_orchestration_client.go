// Code generated by protoc-gen-grpc-pensando DO NOT EDIT.

package grpcclient

import (
	"context"
	"errors"
	oldlog "log"
	"net/http"

	"github.com/go-kit/kit/endpoint"
	grpctransport "github.com/go-kit/kit/transport/grpc"
	"google.golang.org/grpc"

	api "github.com/pensando/sw/api"
	orchestration "github.com/pensando/sw/api/generated/orchestration"
	"github.com/pensando/sw/api/interfaces"
	listerwatcher "github.com/pensando/sw/api/listerwatcher"
	"github.com/pensando/sw/venice/utils/kvstore"
	"github.com/pensando/sw/venice/utils/log"
	"github.com/pensando/sw/venice/utils/trace"
)

// Dummy vars to suppress import errors
var _ api.TypeMeta
var _ listerwatcher.WatcherClient
var _ kvstore.Interface

// NewOrchestratorV1 sets up a new client for OrchestratorV1
func NewOrchestratorV1(conn *grpc.ClientConn, logger log.Logger) orchestration.ServiceOrchestratorV1Client {

	var lAutoAddOrchestratorEndpoint endpoint.Endpoint
	{
		lAutoAddOrchestratorEndpoint = grpctransport.NewClient(
			conn,
			"orchestration.OrchestratorV1",
			"AutoAddOrchestrator",
			orchestration.EncodeGrpcReqOrchestrator,
			orchestration.DecodeGrpcRespOrchestrator,
			&orchestration.Orchestrator{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoAddOrchestratorEndpoint = trace.ClientEndPoint("OrchestratorV1:AutoAddOrchestrator")(lAutoAddOrchestratorEndpoint)
	}
	var lAutoDeleteOrchestratorEndpoint endpoint.Endpoint
	{
		lAutoDeleteOrchestratorEndpoint = grpctransport.NewClient(
			conn,
			"orchestration.OrchestratorV1",
			"AutoDeleteOrchestrator",
			orchestration.EncodeGrpcReqOrchestrator,
			orchestration.DecodeGrpcRespOrchestrator,
			&orchestration.Orchestrator{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoDeleteOrchestratorEndpoint = trace.ClientEndPoint("OrchestratorV1:AutoDeleteOrchestrator")(lAutoDeleteOrchestratorEndpoint)
	}
	var lAutoGetOrchestratorEndpoint endpoint.Endpoint
	{
		lAutoGetOrchestratorEndpoint = grpctransport.NewClient(
			conn,
			"orchestration.OrchestratorV1",
			"AutoGetOrchestrator",
			orchestration.EncodeGrpcReqOrchestrator,
			orchestration.DecodeGrpcRespOrchestrator,
			&orchestration.Orchestrator{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoGetOrchestratorEndpoint = trace.ClientEndPoint("OrchestratorV1:AutoGetOrchestrator")(lAutoGetOrchestratorEndpoint)
	}
	var lAutoLabelOrchestratorEndpoint endpoint.Endpoint
	{
		lAutoLabelOrchestratorEndpoint = grpctransport.NewClient(
			conn,
			"orchestration.OrchestratorV1",
			"AutoLabelOrchestrator",
			orchestration.EncodeGrpcReqLabel,
			orchestration.DecodeGrpcRespOrchestrator,
			&orchestration.Orchestrator{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoLabelOrchestratorEndpoint = trace.ClientEndPoint("OrchestratorV1:AutoLabelOrchestrator")(lAutoLabelOrchestratorEndpoint)
	}
	var lAutoListOrchestratorEndpoint endpoint.Endpoint
	{
		lAutoListOrchestratorEndpoint = grpctransport.NewClient(
			conn,
			"orchestration.OrchestratorV1",
			"AutoListOrchestrator",
			orchestration.EncodeGrpcReqListWatchOptions,
			orchestration.DecodeGrpcRespOrchestratorList,
			&orchestration.OrchestratorList{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoListOrchestratorEndpoint = trace.ClientEndPoint("OrchestratorV1:AutoListOrchestrator")(lAutoListOrchestratorEndpoint)
	}
	var lAutoUpdateOrchestratorEndpoint endpoint.Endpoint
	{
		lAutoUpdateOrchestratorEndpoint = grpctransport.NewClient(
			conn,
			"orchestration.OrchestratorV1",
			"AutoUpdateOrchestrator",
			orchestration.EncodeGrpcReqOrchestrator,
			orchestration.DecodeGrpcRespOrchestrator,
			&orchestration.Orchestrator{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoUpdateOrchestratorEndpoint = trace.ClientEndPoint("OrchestratorV1:AutoUpdateOrchestrator")(lAutoUpdateOrchestratorEndpoint)
	}
	return orchestration.EndpointsOrchestratorV1Client{
		Client: orchestration.NewOrchestratorV1Client(conn),

		AutoAddOrchestratorEndpoint:    lAutoAddOrchestratorEndpoint,
		AutoDeleteOrchestratorEndpoint: lAutoDeleteOrchestratorEndpoint,
		AutoGetOrchestratorEndpoint:    lAutoGetOrchestratorEndpoint,
		AutoLabelOrchestratorEndpoint:  lAutoLabelOrchestratorEndpoint,
		AutoListOrchestratorEndpoint:   lAutoListOrchestratorEndpoint,
		AutoUpdateOrchestratorEndpoint: lAutoUpdateOrchestratorEndpoint,
	}
}

// NewOrchestratorV1Backend creates an instrumented client with middleware
func NewOrchestratorV1Backend(conn *grpc.ClientConn, logger log.Logger) orchestration.ServiceOrchestratorV1Client {
	cl := NewOrchestratorV1(conn, logger)
	cl = orchestration.LoggingOrchestratorV1MiddlewareClient(logger)(cl)
	return cl
}

type grpcObjOrchestratorV1Orchestrator struct {
	logger log.Logger
	client orchestration.ServiceOrchestratorV1Client
}

func (a *grpcObjOrchestratorV1Orchestrator) Create(ctx context.Context, in *orchestration.Orchestrator) (*orchestration.Orchestrator, error) {
	a.logger.DebugLog("msg", "received call", "object", "Orchestrator", "oper", "create")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoAddOrchestrator(nctx, in)
}

func (a *grpcObjOrchestratorV1Orchestrator) Update(ctx context.Context, in *orchestration.Orchestrator) (*orchestration.Orchestrator, error) {
	a.logger.DebugLog("msg", "received call", "object", "Orchestrator", "oper", "update")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoUpdateOrchestrator(nctx, in)
}

func (a *grpcObjOrchestratorV1Orchestrator) UpdateStatus(ctx context.Context, in *orchestration.Orchestrator) (*orchestration.Orchestrator, error) {
	a.logger.DebugLog("msg", "received call", "object", "Orchestrator", "oper", "update")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	nctx = addStatusUpd(nctx)
	return a.client.AutoUpdateOrchestrator(nctx, in)
}

func (a *grpcObjOrchestratorV1Orchestrator) Label(ctx context.Context, in *api.Label) (*orchestration.Orchestrator, error) {
	a.logger.DebugLog("msg", "received call", "object", "Orchestrator", "oper", "label")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoLabelOrchestrator(nctx, in)
}

func (a *grpcObjOrchestratorV1Orchestrator) Get(ctx context.Context, objMeta *api.ObjectMeta) (*orchestration.Orchestrator, error) {
	a.logger.DebugLog("msg", "received call", "object", "Orchestrator", "oper", "get")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := orchestration.Orchestrator{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoGetOrchestrator(nctx, &in)
}

func (a *grpcObjOrchestratorV1Orchestrator) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*orchestration.Orchestrator, error) {
	a.logger.DebugLog("msg", "received call", "object", "Orchestrator", "oper", "delete")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := orchestration.Orchestrator{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoDeleteOrchestrator(nctx, &in)
}

func (a *grpcObjOrchestratorV1Orchestrator) List(ctx context.Context, options *api.ListWatchOptions) ([]*orchestration.Orchestrator, error) {
	a.logger.DebugLog("msg", "received call", "object", "Orchestrator", "oper", "list")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	r, err := a.client.AutoListOrchestrator(nctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *grpcObjOrchestratorV1Orchestrator) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	a.logger.DebugLog("msg", "received call", "object", "Orchestrator", "oper", "WatchOper")
	nctx := addVersion(ctx, "v1")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	stream, err := a.client.AutoWatchOrchestrator(nctx, options)
	if err != nil {
		return nil, err
	}
	wstream := stream.(orchestration.OrchestratorV1_AutoWatchOrchestratorClient)
	bridgefn := func(lw *listerwatcher.WatcherClient) {
		for {
			r, err := wstream.Recv()
			if err != nil {
				a.logger.ErrorLog("msg", "error on receive", "err", err)
				close(lw.OutCh)
				return
			}
			for _, e := range r.Events {
				ev := kvstore.WatchEvent{
					Type:   kvstore.WatchEventType(e.Type),
					Object: e.Object,
				}
				select {
				case lw.OutCh <- &ev:
				case <-wstream.Context().Done():
					close(lw.OutCh)
					return
				}
			}
		}
	}
	lw := listerwatcher.NewWatcherClient(wstream, bridgefn)
	lw.Run()
	return lw, nil
}

func (a *grpcObjOrchestratorV1Orchestrator) Allowed(oper apiintf.APIOperType) bool {
	return true
}

type restObjOrchestratorV1Orchestrator struct {
	endpoints orchestration.EndpointsOrchestratorV1RestClient
	instance  string
}

func (a *restObjOrchestratorV1Orchestrator) Create(ctx context.Context, in *orchestration.Orchestrator) (*orchestration.Orchestrator, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoAddOrchestrator(ctx, in)
}

func (a *restObjOrchestratorV1Orchestrator) Update(ctx context.Context, in *orchestration.Orchestrator) (*orchestration.Orchestrator, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoUpdateOrchestrator(ctx, in)
}

func (a *restObjOrchestratorV1Orchestrator) UpdateStatus(ctx context.Context, in *orchestration.Orchestrator) (*orchestration.Orchestrator, error) {
	return nil, errors.New("not supported for REST")
}

func (a *restObjOrchestratorV1Orchestrator) Label(ctx context.Context, in *api.Label) (*orchestration.Orchestrator, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoLabelOrchestrator(ctx, in)
}

func (a *restObjOrchestratorV1Orchestrator) Get(ctx context.Context, objMeta *api.ObjectMeta) (*orchestration.Orchestrator, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := orchestration.Orchestrator{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoGetOrchestrator(ctx, &in)
}

func (a *restObjOrchestratorV1Orchestrator) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*orchestration.Orchestrator, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := orchestration.Orchestrator{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoDeleteOrchestrator(ctx, &in)
}

func (a *restObjOrchestratorV1Orchestrator) List(ctx context.Context, options *api.ListWatchOptions) ([]*orchestration.Orchestrator, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}

	r, err := a.endpoints.AutoListOrchestrator(ctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *restObjOrchestratorV1Orchestrator) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoWatchOrchestrator(ctx, options)
}

func (a *restObjOrchestratorV1Orchestrator) Allowed(oper apiintf.APIOperType) bool {
	switch oper {
	case apiintf.CreateOper:
		return true
	case apiintf.UpdateOper:
		return true
	case apiintf.GetOper:
		return true
	case apiintf.DeleteOper:
		return true
	case apiintf.ListOper:
		return true
	case apiintf.WatchOper:
		return true
	default:
		return false
	}
}

type crudClientOrchestratorV1 struct {
	logger log.Logger
	client orchestration.ServiceOrchestratorV1Client

	grpcOrchestrator orchestration.OrchestratorV1OrchestratorInterface
}

// NewGrpcCrudClientOrchestratorV1 creates a GRPC client for the service
func NewGrpcCrudClientOrchestratorV1(conn *grpc.ClientConn, logger log.Logger) orchestration.OrchestratorV1Interface {
	client := NewOrchestratorV1Backend(conn, logger)
	return &crudClientOrchestratorV1{
		logger: logger,
		client: client,

		grpcOrchestrator: &grpcObjOrchestratorV1Orchestrator{client: client, logger: logger},
	}
}

func (a *crudClientOrchestratorV1) Orchestrator() orchestration.OrchestratorV1OrchestratorInterface {
	return a.grpcOrchestrator
}

func (a *crudClientOrchestratorV1) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	a.logger.DebugLog("msg", "received call", "object", "OrchestratorV1", "oper", "WatchOper")
	nctx := addVersion(ctx, "v1")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	stream, err := a.client.AutoWatchSvcOrchestratorV1(nctx, options)
	if err != nil {
		return nil, err
	}
	wstream := stream.(orchestration.OrchestratorV1_AutoWatchSvcOrchestratorV1Client)
	bridgefn := func(lw *listerwatcher.WatcherClient) {
		for {
			r, err := wstream.Recv()
			if err != nil {
				a.logger.ErrorLog("msg", "error on receive", "err", err)
				close(lw.OutCh)
				return
			}
			for _, e := range r.Events {
				ev := kvstore.WatchEvent{Type: kvstore.WatchEventType(e.Type)}
				robj, err := listerwatcher.GetObject(e)
				if err != nil {
					a.logger.ErrorLog("msg", "error on receive unmarshall", "err", err)
					close(lw.OutCh)
					return
				}
				ev.Object = robj
				select {
				case lw.OutCh <- &ev:
				case <-wstream.Context().Done():
					close(lw.OutCh)
					return
				}
			}
		}
	}
	lw := listerwatcher.NewWatcherClient(wstream, bridgefn)
	lw.Run()
	return lw, nil
}

type crudRestClientOrchestratorV1 struct {
	restOrchestrator orchestration.OrchestratorV1OrchestratorInterface
}

// NewRestCrudClientOrchestratorV1 creates a REST client for the service.
func NewRestCrudClientOrchestratorV1(url string, httpClient *http.Client) orchestration.OrchestratorV1Interface {
	endpoints, err := orchestration.MakeOrchestratorV1RestClientEndpoints(url, httpClient)
	if err != nil {
		oldlog.Fatal("failed to create client")
	}
	return &crudRestClientOrchestratorV1{

		restOrchestrator: &restObjOrchestratorV1Orchestrator{endpoints: endpoints, instance: url},
	}
}

// NewStagedRestCrudClientOrchestratorV1 creates a REST client for the service.
func NewStagedRestCrudClientOrchestratorV1(url string, id string, httpClient *http.Client) orchestration.OrchestratorV1Interface {
	endpoints, err := orchestration.MakeOrchestratorV1StagedRestClientEndpoints(url, id, httpClient)
	if err != nil {
		oldlog.Fatal("failed to create client")
	}
	return &crudRestClientOrchestratorV1{

		restOrchestrator: &restObjOrchestratorV1Orchestrator{endpoints: endpoints, instance: url},
	}
}

func (a *crudRestClientOrchestratorV1) Orchestrator() orchestration.OrchestratorV1OrchestratorInterface {
	return a.restOrchestrator
}

func (a *crudRestClientOrchestratorV1) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	return nil, errors.New("method unimplemented")
}
