// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: orchestration.proto

/*
	Package orchestration is a generated protocol buffer package.

	Service name

	It is generated from these files:
		orchestration.proto
		svc_orchestration.proto

	It has these top-level messages:
		Orchestrator
		OrchestratorSpec
		OrchestratorStatus
		AutoMsgOrchestratorWatchHelper
		OrchestratorList
*/
package orchestration

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/pensando/grpc-gateway/third_party/googleapis/google/api"
import _ "github.com/pensando/sw/venice/utils/apigen/annotations"
import _ "github.com/gogo/protobuf/gogoproto"
import api "github.com/pensando/sw/api"
import monitoring "github.com/pensando/sw/api/generated/monitoring"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

//
type OrchestratorSpec_OrchestratorType int32

const (
	// ui-hint: vcenter
	OrchestratorSpec_VCenter OrchestratorSpec_OrchestratorType = 0
)

var OrchestratorSpec_OrchestratorType_name = map[int32]string{
	0: "VCenter",
}
var OrchestratorSpec_OrchestratorType_value = map[string]int32{
	"VCenter": 0,
}

func (OrchestratorSpec_OrchestratorType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorOrchestration, []int{1, 0}
}

//
type OrchestratorStatus_ConnectionStatus int32

const (
	// ui-hint: Unknown
	OrchestratorStatus_Unknown OrchestratorStatus_ConnectionStatus = 0
	// ui-hint: Success
	OrchestratorStatus_Success OrchestratorStatus_ConnectionStatus = 1
	// ui-hint: Failure
	OrchestratorStatus_Failure OrchestratorStatus_ConnectionStatus = 2
)

var OrchestratorStatus_ConnectionStatus_name = map[int32]string{
	0: "Unknown",
	1: "Success",
	2: "Failure",
}
var OrchestratorStatus_ConnectionStatus_value = map[string]int32{
	"Unknown": 0,
	"Success": 1,
	"Failure": 2,
}

func (OrchestratorStatus_ConnectionStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorOrchestration, []int{2, 0}
}

// --------------------------------- ORCHESTRATOR ---------------------------------------------
//
// Orchestrator represents the config object which allows Venice to connect to the appropriate orchestrator
//
//
type Orchestrator struct {
	//
	api.TypeMeta `protobuf:"bytes,1,opt,name=T,json=,inline,embedded=T" json:",inline"`
	//
	api.ObjectMeta `protobuf:"bytes,2,opt,name=O,json=meta,omitempty,embedded=O" json:"meta,omitempty"`
	// Spec contains the configuration of the vcenter.
	Spec OrchestratorSpec `protobuf:"bytes,3,opt,name=Spec,json=spec,omitempty" json:"spec,omitempty"`
	// Status contains the current state of the cluster.
	Status OrchestratorStatus `protobuf:"bytes,4,opt,name=Status,json=status,omitempty" json:"status,omitempty"`
}

func (m *Orchestrator) Reset()                    { *m = Orchestrator{} }
func (m *Orchestrator) String() string            { return proto.CompactTextString(m) }
func (*Orchestrator) ProtoMessage()               {}
func (*Orchestrator) Descriptor() ([]byte, []int) { return fileDescriptorOrchestration, []int{0} }

func (m *Orchestrator) GetSpec() OrchestratorSpec {
	if m != nil {
		return m.Spec
	}
	return OrchestratorSpec{}
}

func (m *Orchestrator) GetStatus() OrchestratorStatus {
	if m != nil {
		return m.Status
	}
	return OrchestratorStatus{}
}

// OrchestratorSpec contains the configuration of the cluster.
type OrchestratorSpec struct {
	// Type of orchestrator
	Type string `protobuf:"bytes,1,opt,name=Type,json=type,proto3" json:"type"`
	// URI of the orchestrator
	URI string `protobuf:"bytes,2,opt,name=URI,json=uri,proto3" json:"uri"`
	// Credentials for the orchestrator
	Credentials *monitoring.ExternalCred `protobuf:"bytes,3,opt,name=Credentials,json=credentials,omitempty" json:"credentials,omitempty"`
	//
	LoginData map[string]string `protobuf:"bytes,4,rep,name=LoginData,json=login-data,omitempty" json:"login-data,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Namespaces that will be managed by this orchestrator. "all_namespaces" will manage all namespaces.
	ManageNamespaces []string `protobuf:"bytes,5,rep,name=ManageNamespaces,json=manage-namespaces,omitempty" json:"manage-namespaces,omitempty"`
}

func (m *OrchestratorSpec) Reset()                    { *m = OrchestratorSpec{} }
func (m *OrchestratorSpec) String() string            { return proto.CompactTextString(m) }
func (*OrchestratorSpec) ProtoMessage()               {}
func (*OrchestratorSpec) Descriptor() ([]byte, []int) { return fileDescriptorOrchestration, []int{1} }

func (m *OrchestratorSpec) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *OrchestratorSpec) GetURI() string {
	if m != nil {
		return m.URI
	}
	return ""
}

func (m *OrchestratorSpec) GetCredentials() *monitoring.ExternalCred {
	if m != nil {
		return m.Credentials
	}
	return nil
}

func (m *OrchestratorSpec) GetLoginData() map[string]string {
	if m != nil {
		return m.LoginData
	}
	return nil
}

func (m *OrchestratorSpec) GetManageNamespaces() []string {
	if m != nil {
		return m.ManageNamespaces
	}
	return nil
}

// OrchestratorStatus contains the current state of connection with the orchestrator.
type OrchestratorStatus struct {
	//
	Status string `protobuf:"bytes,1,opt,name=Status,json=connection-status,proto3" json:"connection-status"`
	//
	LastConnected *api.Timestamp `protobuf:"bytes,2,opt,name=LastConnected,json=last-connected,omitempty" json:"last-connected,omitempty"`
	//
	LastSync *api.Timestamp `protobuf:"bytes,3,opt,name=LastSync,json=last-sync,omitempty" json:"last-sync,omitempty"`
	//
	SessionID string `protobuf:"bytes,4,opt,name=SessionID,json=session-id,omitempty,proto3" json:"session-id,omitempty"`
	//
	OrchID int32 `protobuf:"varint,5,opt,name=OrchID,json=orch-id,omitempty,proto3" json:"orch-id,omitempty"`
}

func (m *OrchestratorStatus) Reset()                    { *m = OrchestratorStatus{} }
func (m *OrchestratorStatus) String() string            { return proto.CompactTextString(m) }
func (*OrchestratorStatus) ProtoMessage()               {}
func (*OrchestratorStatus) Descriptor() ([]byte, []int) { return fileDescriptorOrchestration, []int{2} }

func (m *OrchestratorStatus) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *OrchestratorStatus) GetLastConnected() *api.Timestamp {
	if m != nil {
		return m.LastConnected
	}
	return nil
}

func (m *OrchestratorStatus) GetLastSync() *api.Timestamp {
	if m != nil {
		return m.LastSync
	}
	return nil
}

func (m *OrchestratorStatus) GetSessionID() string {
	if m != nil {
		return m.SessionID
	}
	return ""
}

func (m *OrchestratorStatus) GetOrchID() int32 {
	if m != nil {
		return m.OrchID
	}
	return 0
}

func init() {
	proto.RegisterType((*Orchestrator)(nil), "orchestration.Orchestrator")
	proto.RegisterType((*OrchestratorSpec)(nil), "orchestration.OrchestratorSpec")
	proto.RegisterType((*OrchestratorStatus)(nil), "orchestration.OrchestratorStatus")
	proto.RegisterEnum("orchestration.OrchestratorSpec_OrchestratorType", OrchestratorSpec_OrchestratorType_name, OrchestratorSpec_OrchestratorType_value)
	proto.RegisterEnum("orchestration.OrchestratorStatus_ConnectionStatus", OrchestratorStatus_ConnectionStatus_name, OrchestratorStatus_ConnectionStatus_value)
}
func (m *Orchestrator) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Orchestrator) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintOrchestration(dAtA, i, uint64(m.TypeMeta.Size()))
	n1, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n1
	dAtA[i] = 0x12
	i++
	i = encodeVarintOrchestration(dAtA, i, uint64(m.ObjectMeta.Size()))
	n2, err := m.ObjectMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n2
	dAtA[i] = 0x1a
	i++
	i = encodeVarintOrchestration(dAtA, i, uint64(m.Spec.Size()))
	n3, err := m.Spec.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n3
	dAtA[i] = 0x22
	i++
	i = encodeVarintOrchestration(dAtA, i, uint64(m.Status.Size()))
	n4, err := m.Status.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n4
	return i, nil
}

func (m *OrchestratorSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OrchestratorSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOrchestration(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.URI) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintOrchestration(dAtA, i, uint64(len(m.URI)))
		i += copy(dAtA[i:], m.URI)
	}
	if m.Credentials != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintOrchestration(dAtA, i, uint64(m.Credentials.Size()))
		n5, err := m.Credentials.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if len(m.LoginData) > 0 {
		for k, _ := range m.LoginData {
			dAtA[i] = 0x22
			i++
			v := m.LoginData[k]
			mapSize := 1 + len(k) + sovOrchestration(uint64(len(k))) + 1 + len(v) + sovOrchestration(uint64(len(v)))
			i = encodeVarintOrchestration(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintOrchestration(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintOrchestration(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.ManageNamespaces) > 0 {
		for _, s := range m.ManageNamespaces {
			dAtA[i] = 0x2a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *OrchestratorStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OrchestratorStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Status) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOrchestration(dAtA, i, uint64(len(m.Status)))
		i += copy(dAtA[i:], m.Status)
	}
	if m.LastConnected != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintOrchestration(dAtA, i, uint64(m.LastConnected.Size()))
		n6, err := m.LastConnected.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.LastSync != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintOrchestration(dAtA, i, uint64(m.LastSync.Size()))
		n7, err := m.LastSync.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if len(m.SessionID) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintOrchestration(dAtA, i, uint64(len(m.SessionID)))
		i += copy(dAtA[i:], m.SessionID)
	}
	if m.OrchID != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintOrchestration(dAtA, i, uint64(m.OrchID))
	}
	return i, nil
}

func encodeVarintOrchestration(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Orchestrator) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovOrchestration(uint64(l))
	l = m.ObjectMeta.Size()
	n += 1 + l + sovOrchestration(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovOrchestration(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovOrchestration(uint64(l))
	return n
}

func (m *OrchestratorSpec) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovOrchestration(uint64(l))
	}
	l = len(m.URI)
	if l > 0 {
		n += 1 + l + sovOrchestration(uint64(l))
	}
	if m.Credentials != nil {
		l = m.Credentials.Size()
		n += 1 + l + sovOrchestration(uint64(l))
	}
	if len(m.LoginData) > 0 {
		for k, v := range m.LoginData {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovOrchestration(uint64(len(k))) + 1 + len(v) + sovOrchestration(uint64(len(v)))
			n += mapEntrySize + 1 + sovOrchestration(uint64(mapEntrySize))
		}
	}
	if len(m.ManageNamespaces) > 0 {
		for _, s := range m.ManageNamespaces {
			l = len(s)
			n += 1 + l + sovOrchestration(uint64(l))
		}
	}
	return n
}

func (m *OrchestratorStatus) Size() (n int) {
	var l int
	_ = l
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovOrchestration(uint64(l))
	}
	if m.LastConnected != nil {
		l = m.LastConnected.Size()
		n += 1 + l + sovOrchestration(uint64(l))
	}
	if m.LastSync != nil {
		l = m.LastSync.Size()
		n += 1 + l + sovOrchestration(uint64(l))
	}
	l = len(m.SessionID)
	if l > 0 {
		n += 1 + l + sovOrchestration(uint64(l))
	}
	if m.OrchID != 0 {
		n += 1 + sovOrchestration(uint64(m.OrchID))
	}
	return n
}

func sovOrchestration(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozOrchestration(x uint64) (n int) {
	return sovOrchestration(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Orchestrator) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrchestration
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Orchestrator: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Orchestrator: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrchestration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrchestration
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrchestration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrchestration
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrchestration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrchestration
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrchestration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrchestration
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOrchestration(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOrchestration
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OrchestratorSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrchestration
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OrchestratorSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OrchestratorSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrchestration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrchestration
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URI", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrchestration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrchestration
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.URI = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Credentials", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrchestration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrchestration
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Credentials == nil {
				m.Credentials = &monitoring.ExternalCred{}
			}
			if err := m.Credentials.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoginData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrchestration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrchestration
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LoginData == nil {
				m.LoginData = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOrchestration
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOrchestration
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthOrchestration
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOrchestration
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthOrchestration
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipOrchestration(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthOrchestration
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.LoginData[mapkey] = mapvalue
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ManageNamespaces", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrchestration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrchestration
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ManageNamespaces = append(m.ManageNamespaces, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOrchestration(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOrchestration
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OrchestratorStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrchestration
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OrchestratorStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OrchestratorStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrchestration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrchestration
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastConnected", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrchestration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrchestration
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastConnected == nil {
				m.LastConnected = &api.Timestamp{}
			}
			if err := m.LastConnected.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastSync", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrchestration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrchestration
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastSync == nil {
				m.LastSync = &api.Timestamp{}
			}
			if err := m.LastSync.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrchestration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrchestration
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrchID", wireType)
			}
			m.OrchID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrchestration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OrchID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOrchestration(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOrchestration
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipOrchestration(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowOrchestration
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowOrchestration
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowOrchestration
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthOrchestration
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowOrchestration
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipOrchestration(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthOrchestration = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowOrchestration   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("orchestration.proto", fileDescriptorOrchestration) }

var fileDescriptorOrchestration = []byte{
	// 831 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x84, 0x54, 0xdd, 0x6e, 0xe3, 0x44,
	0x14, 0xae, 0x9b, 0xb4, 0x25, 0xd3, 0x1f, 0xbc, 0xd3, 0x02, 0x4e, 0x76, 0xd5, 0x84, 0x20, 0xa4,
	0x14, 0x25, 0x8e, 0x76, 0x91, 0x10, 0xaa, 0xf6, 0xca, 0x6d, 0x56, 0xaa, 0xd4, 0xdd, 0x22, 0x67,
	0xcb, 0x05, 0x12, 0x82, 0xa9, 0x73, 0xd6, 0x1d, 0xd6, 0x9e, 0x31, 0x9e, 0x71, 0x77, 0xf3, 0x00,
	0x54, 0x3c, 0x04, 0x2f, 0x40, 0x9f, 0x82, 0xcb, 0x5e, 0xae, 0xb8, 0xe2, 0x2a, 0x42, 0xb9, 0x42,
	0x7d, 0x0a, 0x34, 0x33, 0x4e, 0x70, 0x7e, 0xb6, 0xdc, 0x58, 0xf3, 0x7d, 0xe7, 0x3b, 0x9f, 0x8f,
	0xcf, 0x39, 0x63, 0xb4, 0xcb, 0xd3, 0xe0, 0x12, 0x84, 0x4c, 0x89, 0xa4, 0x9c, 0xb9, 0x49, 0xca,
	0x25, 0xc7, 0xdb, 0x33, 0x64, 0xed, 0x51, 0xc8, 0x79, 0x18, 0x41, 0x97, 0x24, 0xb4, 0x4b, 0x18,
	0xe3, 0x52, 0xd3, 0xc2, 0x88, 0x6b, 0xbd, 0x90, 0xca, 0xcb, 0xec, 0xc2, 0x0d, 0x78, 0xdc, 0x4d,
	0x80, 0x09, 0xc2, 0x06, 0xbc, 0x2b, 0xde, 0x74, 0xaf, 0x80, 0xd1, 0x00, 0xba, 0x99, 0xa4, 0x91,
	0x50, 0xa9, 0x21, 0xb0, 0x62, 0x76, 0x97, 0xb2, 0x20, 0xca, 0x06, 0x30, 0xb1, 0xe9, 0x14, 0x6c,
	0x42, 0x1e, 0xf2, 0xae, 0xa6, 0x2f, 0xb2, 0x57, 0x1a, 0x69, 0xa0, 0x4f, 0xb9, 0xfc, 0xf3, 0xf7,
	0xbc, 0x55, 0xd5, 0x18, 0x83, 0x24, 0xb9, 0x6c, 0x0b, 0xde, 0x26, 0x3c, 0x95, 0x06, 0x35, 0xff,
	0x5a, 0x45, 0x5b, 0x67, 0xd3, 0x4f, 0xe3, 0x29, 0xfe, 0x0a, 0x59, 0x2f, 0x1d, 0xab, 0x61, 0xb5,
	0x36, 0x9f, 0x6c, 0xbb, 0x24, 0xa1, 0xee, 0xcb, 0x61, 0x02, 0xcf, 0x41, 0x12, 0x6f, 0xf7, 0x76,
	0x54, 0x5f, 0x79, 0x37, 0xaa, 0x5b, 0x77, 0xa3, 0xfa, 0x46, 0x9b, 0xb2, 0x88, 0x32, 0xf0, 0x27,
	0x07, 0xfc, 0x0c, 0x59, 0x67, 0xce, 0xaa, 0xce, 0xfb, 0x50, 0xe7, 0x9d, 0x5d, 0xfc, 0x04, 0x81,
	0xd4, 0x99, 0xb5, 0x42, 0xe6, 0x8e, 0x2a, 0xa5, 0xcd, 0x63, 0x2a, 0x21, 0x4e, 0xe4, 0xd0, 0x9f,
	0xc3, 0xf8, 0x1c, 0x95, 0xfb, 0x09, 0x04, 0x4e, 0x49, 0x5b, 0xd5, 0xdd, 0xd9, 0x61, 0x14, 0x4b,
	0x55, 0x32, 0xef, 0x63, 0x65, 0xad, 0x6c, 0x45, 0x02, 0x41, 0xd1, 0x76, 0x16, 0xe3, 0xef, 0xd1,
	0x7a, 0x5f, 0x12, 0x99, 0x09, 0xa7, 0xac, 0x8d, 0x3f, 0xbd, 0xcf, 0x58, 0x0b, 0x3d, 0x27, 0xb7,
	0xb6, 0x85, 0xc6, 0x05, 0xf3, 0x05, 0xe6, 0x10, 0xff, 0xf9, 0x4b, 0x75, 0x07, 0x6f, 0xf1, 0x82,
	0x4b, 0xf3, 0xf7, 0x32, 0xb2, 0xe7, 0xeb, 0xc5, 0x2f, 0x50, 0x59, 0x35, 0x54, 0x77, 0xb8, 0xe2,
	0x1d, 0xde, 0x5c, 0x57, 0xbf, 0xe8, 0xcb, 0xb4, 0xc7, 0xb2, 0xb8, 0x35, 0xaf, 0x9d, 0xa9, 0x49,
	0x25, 0x1d, 0xfc, 0x71, 0x5d, 0x55, 0x05, 0x95, 0xe5, 0x30, 0x01, 0x5f, 0x3f, 0xf1, 0x01, 0x2a,
	0x9d, 0xfb, 0x27, 0xba, 0xf1, 0x15, 0xef, 0x93, 0x9b, 0xeb, 0xea, 0x56, 0x5f, 0xa6, 0xa7, 0xc0,
	0x5a, 0x8f, 0xdb, 0x9d, 0xc7, 0x07, 0x77, 0xa3, 0x7a, 0x29, 0x4b, 0xa9, 0xaf, 0x1e, 0xf8, 0x07,
	0xb4, 0x79, 0x94, 0xc2, 0x00, 0x98, 0xa4, 0x24, 0x12, 0x79, 0x83, 0x1d, 0x37, 0xe6, 0x8c, 0x4a,
	0x9e, 0x52, 0x16, 0xba, 0xbd, 0xb7, 0x12, 0x52, 0x46, 0x22, 0x25, 0xf3, 0xaa, 0x77, 0xa3, 0xfa,
	0x47, 0xc1, 0x7f, 0x09, 0x85, 0xef, 0x5f, 0x4e, 0xe3, 0x9f, 0x51, 0xe5, 0x94, 0x87, 0x94, 0x1d,
	0x13, 0x49, 0x9c, 0x72, 0xa3, 0xd4, 0xda, 0x7c, 0xe2, 0xfe, 0xcf, 0xfc, 0xdc, 0x69, 0x42, 0x8f,
	0xc9, 0x74, 0xe8, 0x39, 0x77, 0xa3, 0xfa, 0x5e, 0xa4, 0xb8, 0xce, 0x80, 0xcc, 0xec, 0xc9, 0x52,
	0x16, 0x7f, 0x87, 0xec, 0xe7, 0x84, 0x91, 0x10, 0x5e, 0x90, 0x18, 0x44, 0x42, 0x02, 0x10, 0xce,
	0x5a, 0xa3, 0xd4, 0xaa, 0x78, 0x9f, 0xdd, 0x9a, 0x7d, 0x7b, 0x18, 0xeb, 0x78, 0x87, 0x4d, 0x05,
	0x05, 0xd3, 0xfb, 0x82, 0xb5, 0xa7, 0x68, 0x67, 0xb6, 0x3a, 0x6c, 0xa3, 0xd2, 0x6b, 0x18, 0x9a,
	0xd9, 0xf9, 0xea, 0x88, 0xf7, 0xd0, 0xda, 0x15, 0x89, 0x32, 0x30, 0x03, 0xf0, 0x0d, 0x38, 0x5c,
	0xfd, 0xda, 0x6a, 0xb6, 0x67, 0x87, 0xaf, 0xe6, 0x87, 0x1d, 0xb4, 0xf1, 0xed, 0x11, 0x30, 0x09,
	0xa9, 0xbd, 0x52, 0xdb, 0x1c, 0xff, 0x5a, 0xdd, 0xb8, 0x0a, 0x34, 0x6c, 0xfe, 0x56, 0x46, 0x78,
	0x71, 0x05, 0xf1, 0xe5, 0x74, 0x6b, 0xcd, 0xbe, 0xf4, 0x6e, 0xae, 0xab, 0xed, 0xa5, 0xfb, 0xa2,
	0x55, 0xee, 0x11, 0x67, 0x0c, 0x02, 0xd5, 0x69, 0x43, 0xa8, 0x05, 0x78, 0x10, 0x4c, 0xc9, 0x8e,
	0xd9, 0x5b, 0x7f, 0x91, 0xc2, 0x04, 0x6d, 0x9f, 0x12, 0x21, 0x73, 0x03, 0x18, 0xe4, 0x57, 0x79,
	0xc7, 0xfc, 0x02, 0x68, 0x0c, 0x42, 0x92, 0x38, 0xf1, 0x1a, 0x79, 0x57, 0x9d, 0x88, 0x08, 0xd9,
	0x09, 0x26, 0xea, 0x42, 0x4b, 0xdf, 0x1b, 0xc1, 0x3e, 0xfa, 0x40, 0xbd, 0xa2, 0x3f, 0x64, 0x93,
	0xdb, 0x3d, 0xef, 0xfe, 0x30, 0x77, 0xdf, 0xd5, 0x1e, 0x62, 0xc8, 0x8a, 0x37, 0x7a, 0x19, 0x89,
	0x7b, 0xa8, 0xd2, 0x07, 0x21, 0x28, 0x67, 0x27, 0xc7, 0xfa, 0x66, 0x57, 0xbc, 0x47, 0xb9, 0xc9,
	0x9e, 0x30, 0x81, 0x0e, 0x2d, 0x96, 0xb7, 0x94, 0xc5, 0x4f, 0xd1, 0xba, 0xea, 0xe6, 0xc9, 0xb1,
	0xb3, 0xd6, 0xb0, 0x5a, 0x6b, 0x5e, 0x35, 0xf7, 0x78, 0xa0, 0xb6, 0x77, 0xd6, 0x60, 0x91, 0x6a,
	0xfe, 0x88, 0xec, 0xf9, 0xc6, 0xab, 0x51, 0x9f, 0xb3, 0xd7, 0x8c, 0xbf, 0x61, 0x93, 0x51, 0x67,
	0x06, 0xaa, 0x48, 0x3f, 0x0b, 0x02, 0x10, 0xc2, 0xb6, 0x4c, 0x44, 0x18, 0xa8, 0x22, 0xcf, 0x08,
	0x8d, 0xb2, 0x14, 0xec, 0x55, 0x13, 0x79, 0x65, 0xa0, 0x67, 0xdf, 0x8e, 0xf7, 0xad, 0x77, 0xe3,
	0x7d, 0xeb, 0xef, 0xf1, 0xbe, 0xf5, 0xcf, 0x78, 0x7f, 0xe5, 0x1b, 0xeb, 0x62, 0x5d, 0xff, 0xc0,
	0xbf, 0xfc, 0x37, 0x00, 0x00, 0xff, 0xff, 0x59, 0xa5, 0x8f, 0x03, 0xaf, 0x06, 0x00, 0x00,
}
