// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: orchestration.proto

/*
	Package orchestration is a generated protocol buffer package.

	Service name

	It is generated from these files:
		orchestration.proto
		svc_orchestration.proto

	It has these top-level messages:
		ManagedNamespaceSpec
		MonitoredNamespaceSpec
		NamespaceSpec
		Orchestrator
		OrchestratorSpec
		OrchestratorStatus
		AutoMsgOrchestratorWatchHelper
		OrchestratorList
*/
package orchestration

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/pensando/grpc-gateway/third_party/googleapis/google/api"
import _ "github.com/pensando/sw/venice/utils/apigen/annotations"
import _ "github.com/gogo/protobuf/gogoproto"
import api "github.com/pensando/sw/api"
import monitoring "github.com/pensando/sw/api/generated/monitoring"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

//
type ManagedNamespaceSpec_DiscoveryType int32

const (
	// ui-hint: Disabled
	ManagedNamespaceSpec_Disabled ManagedNamespaceSpec_DiscoveryType = 0
	// ui-hint: CDP
	ManagedNamespaceSpec_CDP ManagedNamespaceSpec_DiscoveryType = 1
	// ui-hint: LLDP
	ManagedNamespaceSpec_LLDP ManagedNamespaceSpec_DiscoveryType = 2
)

var ManagedNamespaceSpec_DiscoveryType_name = map[int32]string{
	0: "Disabled",
	1: "CDP",
	2: "LLDP",
}
var ManagedNamespaceSpec_DiscoveryType_value = map[string]int32{
	"Disabled": 0,
	"CDP":      1,
	"LLDP":     2,
}

func (ManagedNamespaceSpec_DiscoveryType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorOrchestration, []int{0, 0}
}

//
type ManagedNamespaceSpec_DiscoveryOp int32

const (
	// ui-hint: None
	ManagedNamespaceSpec_None ManagedNamespaceSpec_DiscoveryOp = 0
	// ui-hint: Listen
	ManagedNamespaceSpec_Listen ManagedNamespaceSpec_DiscoveryOp = 1
	// ui-hint: Advertise
	ManagedNamespaceSpec_Advertise ManagedNamespaceSpec_DiscoveryOp = 2
	// ui-hint: Both
	ManagedNamespaceSpec_Both ManagedNamespaceSpec_DiscoveryOp = 3
)

var ManagedNamespaceSpec_DiscoveryOp_name = map[int32]string{
	0: "None",
	1: "Listen",
	2: "Advertise",
	3: "Both",
}
var ManagedNamespaceSpec_DiscoveryOp_value = map[string]int32{
	"None":      0,
	"Listen":    1,
	"Advertise": 2,
	"Both":      3,
}

func (ManagedNamespaceSpec_DiscoveryOp) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorOrchestration, []int{0, 1}
}

//
type ManagedNamespaceSpec_MulticastFilteringMode int32

const (
	// ui-hint: Basic
	ManagedNamespaceSpec_Basic ManagedNamespaceSpec_MulticastFilteringMode = 0
	// ui-hint: Snooping
	ManagedNamespaceSpec_Snooping ManagedNamespaceSpec_MulticastFilteringMode = 1
)

var ManagedNamespaceSpec_MulticastFilteringMode_name = map[int32]string{
	0: "Basic",
	1: "Snooping",
}
var ManagedNamespaceSpec_MulticastFilteringMode_value = map[string]int32{
	"Basic":    0,
	"Snooping": 1,
}

func (ManagedNamespaceSpec_MulticastFilteringMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorOrchestration, []int{0, 2}
}

//
type NamespaceSpec_ModeType int32

const (
	// ui-hint: Managed
	NamespaceSpec_Managed NamespaceSpec_ModeType = 0
	// ui-hint: Monitored
	NamespaceSpec_Monitored NamespaceSpec_ModeType = 1
)

var NamespaceSpec_ModeType_name = map[int32]string{
	0: "Managed",
	1: "Monitored",
}
var NamespaceSpec_ModeType_value = map[string]int32{
	"Managed":   0,
	"Monitored": 1,
}

func (NamespaceSpec_ModeType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorOrchestration, []int{2, 0}
}

//
type OrchestratorSpec_OrchestratorType int32

const (
	// ui-hint: vcenter
	OrchestratorSpec_VCenter OrchestratorSpec_OrchestratorType = 0
)

var OrchestratorSpec_OrchestratorType_name = map[int32]string{
	0: "VCenter",
}
var OrchestratorSpec_OrchestratorType_value = map[string]int32{
	"VCenter": 0,
}

func (OrchestratorSpec_OrchestratorType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorOrchestration, []int{4, 0}
}

//
type OrchestratorStatus_ConnectionStatus int32

const (
	// ui-hint: Unknown
	OrchestratorStatus_Unknown OrchestratorStatus_ConnectionStatus = 0
	// ui-hint: Success
	OrchestratorStatus_Success OrchestratorStatus_ConnectionStatus = 1
	// ui-hint: Failure
	OrchestratorStatus_Failure OrchestratorStatus_ConnectionStatus = 2
	// ui-hint: Degraded
	OrchestratorStatus_Degraded OrchestratorStatus_ConnectionStatus = 3
)

var OrchestratorStatus_ConnectionStatus_name = map[int32]string{
	0: "Unknown",
	1: "Success",
	2: "Failure",
	3: "Degraded",
}
var OrchestratorStatus_ConnectionStatus_value = map[string]int32{
	"Unknown":  0,
	"Success":  1,
	"Failure":  2,
	"Degraded": 3,
}

func (OrchestratorStatus_ConnectionStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorOrchestration, []int{5, 0}
}

// ManagedNamespaceSpec contains namespace specific configuration
type ManagedNamespaceSpec struct {
	//
	MTU uint32 `protobuf:"varint,1,opt,name=MTU,json=mtu,omitempty,proto3" json:"mtu,omitempty"`
	//
	MulticastFilter string `protobuf:"bytes,2,opt,name=MulticastFilter,json=multicast-filter,omitempty,proto3" json:"multicast-filter,omitempty"`
	//
	DiscoveryProtocol string `protobuf:"bytes,3,opt,name=DiscoveryProtocol,json=discovery-protocol,omitempty,proto3" json:"discovery-protocol,omitempty"`
	//
	DiscoveryOperation string `protobuf:"bytes,4,opt,name=DiscoveryOperation,json=discovery-operation,omitempty,proto3" json:"discovery-operation,omitempty"`
	//
	NumUplinks uint32 `protobuf:"varint,5,opt,name=NumUplinks,json=num-uplinks,proto3" json:"num-uplinks"`
}

func (m *ManagedNamespaceSpec) Reset()         { *m = ManagedNamespaceSpec{} }
func (m *ManagedNamespaceSpec) String() string { return proto.CompactTextString(m) }
func (*ManagedNamespaceSpec) ProtoMessage()    {}
func (*ManagedNamespaceSpec) Descriptor() ([]byte, []int) {
	return fileDescriptorOrchestration, []int{0}
}

func (m *ManagedNamespaceSpec) GetMTU() uint32 {
	if m != nil {
		return m.MTU
	}
	return 0
}

func (m *ManagedNamespaceSpec) GetMulticastFilter() string {
	if m != nil {
		return m.MulticastFilter
	}
	return ""
}

func (m *ManagedNamespaceSpec) GetDiscoveryProtocol() string {
	if m != nil {
		return m.DiscoveryProtocol
	}
	return ""
}

func (m *ManagedNamespaceSpec) GetDiscoveryOperation() string {
	if m != nil {
		return m.DiscoveryOperation
	}
	return ""
}

func (m *ManagedNamespaceSpec) GetNumUplinks() uint32 {
	if m != nil {
		return m.NumUplinks
	}
	return 0
}

// MonitoredNamespaceSpec contains namespace specific configuration
type MonitoredNamespaceSpec struct {
}

func (m *MonitoredNamespaceSpec) Reset()         { *m = MonitoredNamespaceSpec{} }
func (m *MonitoredNamespaceSpec) String() string { return proto.CompactTextString(m) }
func (*MonitoredNamespaceSpec) ProtoMessage()    {}
func (*MonitoredNamespaceSpec) Descriptor() ([]byte, []int) {
	return fileDescriptorOrchestration, []int{1}
}

// NamespaceSpec contains the namespace specification
type NamespaceSpec struct {
	//
	Name string `protobuf:"bytes,1,opt,name=Name,json=name,proto3" json:"name"`
	//
	Mode string `protobuf:"bytes,2,opt,name=Mode,json=mode,proto3" json:"mode"`
	//
	ManagedSpec *ManagedNamespaceSpec `protobuf:"bytes,3,opt,name=ManagedSpec,json=managed-spec,omitempty" json:"managed-spec,omitempty"`
	//
	MonitoredSpec *MonitoredNamespaceSpec `protobuf:"bytes,4,opt,name=MonitoredSpec,json=monitored-spec,omitempty" json:"monitored-spec,omitempty"`
}

func (m *NamespaceSpec) Reset()                    { *m = NamespaceSpec{} }
func (m *NamespaceSpec) String() string            { return proto.CompactTextString(m) }
func (*NamespaceSpec) ProtoMessage()               {}
func (*NamespaceSpec) Descriptor() ([]byte, []int) { return fileDescriptorOrchestration, []int{2} }

func (m *NamespaceSpec) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *NamespaceSpec) GetMode() string {
	if m != nil {
		return m.Mode
	}
	return ""
}

func (m *NamespaceSpec) GetManagedSpec() *ManagedNamespaceSpec {
	if m != nil {
		return m.ManagedSpec
	}
	return nil
}

func (m *NamespaceSpec) GetMonitoredSpec() *MonitoredNamespaceSpec {
	if m != nil {
		return m.MonitoredSpec
	}
	return nil
}

// --------------------------------- ORCHESTRATOR ---------------------------------------------
//
// Orchestrator represents the config object which allows Venice to connect to the appropriate orchestrator
//
//
type Orchestrator struct {
	//
	api.TypeMeta `protobuf:"bytes,1,opt,name=T,json=,inline,embedded=T" json:",inline"`
	//
	api.ObjectMeta `protobuf:"bytes,2,opt,name=O,json=meta,omitempty,embedded=O" json:"meta,omitempty"`
	// Spec contains the configuration of the vcenter.
	Spec OrchestratorSpec `protobuf:"bytes,3,opt,name=Spec,json=spec,omitempty" json:"spec,omitempty"`
	// Status contains the current state of the cluster.
	Status OrchestratorStatus `protobuf:"bytes,4,opt,name=Status,json=status,omitempty" json:"status,omitempty"`
}

func (m *Orchestrator) Reset()                    { *m = Orchestrator{} }
func (m *Orchestrator) String() string            { return proto.CompactTextString(m) }
func (*Orchestrator) ProtoMessage()               {}
func (*Orchestrator) Descriptor() ([]byte, []int) { return fileDescriptorOrchestration, []int{3} }

func (m *Orchestrator) GetSpec() OrchestratorSpec {
	if m != nil {
		return m.Spec
	}
	return OrchestratorSpec{}
}

func (m *Orchestrator) GetStatus() OrchestratorStatus {
	if m != nil {
		return m.Status
	}
	return OrchestratorStatus{}
}

// OrchestratorSpec contains the configuration of the cluster.
type OrchestratorSpec struct {
	// Type of orchestrator
	Type string `protobuf:"bytes,1,opt,name=Type,json=type,proto3" json:"type"`
	// URI of the orchestrator
	URI string `protobuf:"bytes,2,opt,name=URI,json=uri,proto3" json:"uri"`
	// Credentials for the orchestrator
	Credentials *monitoring.ExternalCred `protobuf:"bytes,3,opt,name=Credentials,json=credentials,omitempty" json:"credentials,omitempty"`
	// Namespaces that will be managed by this orchestrator. "all_namespaces" will manage all namespaces. - deprecated from Rel-C
	ManageNamespaces []string `protobuf:"bytes,4,rep,name=ManageNamespaces,json=manage-namespaces,omitempty" json:"manage-namespaces,omitempty"`
	// Namespaces are used to provide namespace specific information. From Rel-C this will be the only means to pass namespace information
	// "all_namespaces" will be treated as a special namespace, which will apply the same configuration for all the namespaces discovered by the orchestrator
	Namespaces []*NamespaceSpec `protobuf:"bytes,5,rep,name=Namespaces,json=namespaces,omitempty" json:"namespaces,omitempty"`
}

func (m *OrchestratorSpec) Reset()                    { *m = OrchestratorSpec{} }
func (m *OrchestratorSpec) String() string            { return proto.CompactTextString(m) }
func (*OrchestratorSpec) ProtoMessage()               {}
func (*OrchestratorSpec) Descriptor() ([]byte, []int) { return fileDescriptorOrchestration, []int{4} }

func (m *OrchestratorSpec) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *OrchestratorSpec) GetURI() string {
	if m != nil {
		return m.URI
	}
	return ""
}

func (m *OrchestratorSpec) GetCredentials() *monitoring.ExternalCred {
	if m != nil {
		return m.Credentials
	}
	return nil
}

func (m *OrchestratorSpec) GetManageNamespaces() []string {
	if m != nil {
		return m.ManageNamespaces
	}
	return nil
}

func (m *OrchestratorSpec) GetNamespaces() []*NamespaceSpec {
	if m != nil {
		return m.Namespaces
	}
	return nil
}

// OrchestratorStatus contains the current state of connection with the orchestrator.
type OrchestratorStatus struct {
	//
	Status string `protobuf:"bytes,1,opt,name=Status,json=connection-status,proto3" json:"connection-status"`
	//
	LastTransitionTime *api.Timestamp `protobuf:"bytes,2,opt,name=LastTransitionTime,json=last-transition-time,omitempty" json:"last-transition-time,omitempty"`
	//
	Message string `protobuf:"bytes,3,opt,name=Message,json=message,omitempty,proto3" json:"message,omitempty"`
	//
	OrchID int32 `protobuf:"varint,4,opt,name=OrchID,json=orch-id,omitempty,proto3" json:"orch-id,omitempty"`
	//
	DiscoveredNamespaces []string `protobuf:"bytes,5,rep,name=DiscoveredNamespaces,json=discovered-namespaces,omitempty" json:"discovered-namespaces,omitempty"`
	//
	IncompatibleDSCs []string `protobuf:"bytes,6,rep,name=IncompatibleDSCs,json=incompatible-dscs,omitempty" json:"incompatible-dscs,omitempty"`
}

func (m *OrchestratorStatus) Reset()                    { *m = OrchestratorStatus{} }
func (m *OrchestratorStatus) String() string            { return proto.CompactTextString(m) }
func (*OrchestratorStatus) ProtoMessage()               {}
func (*OrchestratorStatus) Descriptor() ([]byte, []int) { return fileDescriptorOrchestration, []int{5} }

func (m *OrchestratorStatus) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *OrchestratorStatus) GetLastTransitionTime() *api.Timestamp {
	if m != nil {
		return m.LastTransitionTime
	}
	return nil
}

func (m *OrchestratorStatus) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *OrchestratorStatus) GetOrchID() int32 {
	if m != nil {
		return m.OrchID
	}
	return 0
}

func (m *OrchestratorStatus) GetDiscoveredNamespaces() []string {
	if m != nil {
		return m.DiscoveredNamespaces
	}
	return nil
}

func (m *OrchestratorStatus) GetIncompatibleDSCs() []string {
	if m != nil {
		return m.IncompatibleDSCs
	}
	return nil
}

func init() {
	proto.RegisterType((*ManagedNamespaceSpec)(nil), "orchestration.ManagedNamespaceSpec")
	proto.RegisterType((*MonitoredNamespaceSpec)(nil), "orchestration.MonitoredNamespaceSpec")
	proto.RegisterType((*NamespaceSpec)(nil), "orchestration.NamespaceSpec")
	proto.RegisterType((*Orchestrator)(nil), "orchestration.Orchestrator")
	proto.RegisterType((*OrchestratorSpec)(nil), "orchestration.OrchestratorSpec")
	proto.RegisterType((*OrchestratorStatus)(nil), "orchestration.OrchestratorStatus")
	proto.RegisterEnum("orchestration.ManagedNamespaceSpec_DiscoveryType", ManagedNamespaceSpec_DiscoveryType_name, ManagedNamespaceSpec_DiscoveryType_value)
	proto.RegisterEnum("orchestration.ManagedNamespaceSpec_DiscoveryOp", ManagedNamespaceSpec_DiscoveryOp_name, ManagedNamespaceSpec_DiscoveryOp_value)
	proto.RegisterEnum("orchestration.ManagedNamespaceSpec_MulticastFilteringMode", ManagedNamespaceSpec_MulticastFilteringMode_name, ManagedNamespaceSpec_MulticastFilteringMode_value)
	proto.RegisterEnum("orchestration.NamespaceSpec_ModeType", NamespaceSpec_ModeType_name, NamespaceSpec_ModeType_value)
	proto.RegisterEnum("orchestration.OrchestratorSpec_OrchestratorType", OrchestratorSpec_OrchestratorType_name, OrchestratorSpec_OrchestratorType_value)
	proto.RegisterEnum("orchestration.OrchestratorStatus_ConnectionStatus", OrchestratorStatus_ConnectionStatus_name, OrchestratorStatus_ConnectionStatus_value)
}
func (m *ManagedNamespaceSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ManagedNamespaceSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MTU != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintOrchestration(dAtA, i, uint64(m.MTU))
	}
	if len(m.MulticastFilter) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintOrchestration(dAtA, i, uint64(len(m.MulticastFilter)))
		i += copy(dAtA[i:], m.MulticastFilter)
	}
	if len(m.DiscoveryProtocol) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintOrchestration(dAtA, i, uint64(len(m.DiscoveryProtocol)))
		i += copy(dAtA[i:], m.DiscoveryProtocol)
	}
	if len(m.DiscoveryOperation) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintOrchestration(dAtA, i, uint64(len(m.DiscoveryOperation)))
		i += copy(dAtA[i:], m.DiscoveryOperation)
	}
	if m.NumUplinks != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintOrchestration(dAtA, i, uint64(m.NumUplinks))
	}
	return i, nil
}

func (m *MonitoredNamespaceSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MonitoredNamespaceSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *NamespaceSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NamespaceSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOrchestration(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Mode) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintOrchestration(dAtA, i, uint64(len(m.Mode)))
		i += copy(dAtA[i:], m.Mode)
	}
	if m.ManagedSpec != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintOrchestration(dAtA, i, uint64(m.ManagedSpec.Size()))
		n1, err := m.ManagedSpec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.MonitoredSpec != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintOrchestration(dAtA, i, uint64(m.MonitoredSpec.Size()))
		n2, err := m.MonitoredSpec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}

func (m *Orchestrator) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Orchestrator) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintOrchestration(dAtA, i, uint64(m.TypeMeta.Size()))
	n3, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n3
	dAtA[i] = 0x12
	i++
	i = encodeVarintOrchestration(dAtA, i, uint64(m.ObjectMeta.Size()))
	n4, err := m.ObjectMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n4
	dAtA[i] = 0x1a
	i++
	i = encodeVarintOrchestration(dAtA, i, uint64(m.Spec.Size()))
	n5, err := m.Spec.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n5
	dAtA[i] = 0x22
	i++
	i = encodeVarintOrchestration(dAtA, i, uint64(m.Status.Size()))
	n6, err := m.Status.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n6
	return i, nil
}

func (m *OrchestratorSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OrchestratorSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOrchestration(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.URI) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintOrchestration(dAtA, i, uint64(len(m.URI)))
		i += copy(dAtA[i:], m.URI)
	}
	if m.Credentials != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintOrchestration(dAtA, i, uint64(m.Credentials.Size()))
		n7, err := m.Credentials.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if len(m.ManageNamespaces) > 0 {
		for _, s := range m.ManageNamespaces {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Namespaces) > 0 {
		for _, msg := range m.Namespaces {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintOrchestration(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *OrchestratorStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OrchestratorStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Status) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOrchestration(dAtA, i, uint64(len(m.Status)))
		i += copy(dAtA[i:], m.Status)
	}
	if m.LastTransitionTime != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintOrchestration(dAtA, i, uint64(m.LastTransitionTime.Size()))
		n8, err := m.LastTransitionTime.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if len(m.Message) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintOrchestration(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	if m.OrchID != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintOrchestration(dAtA, i, uint64(m.OrchID))
	}
	if len(m.DiscoveredNamespaces) > 0 {
		for _, s := range m.DiscoveredNamespaces {
			dAtA[i] = 0x2a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.IncompatibleDSCs) > 0 {
		for _, s := range m.IncompatibleDSCs {
			dAtA[i] = 0x32
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func encodeVarintOrchestration(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *ManagedNamespaceSpec) Size() (n int) {
	var l int
	_ = l
	if m.MTU != 0 {
		n += 1 + sovOrchestration(uint64(m.MTU))
	}
	l = len(m.MulticastFilter)
	if l > 0 {
		n += 1 + l + sovOrchestration(uint64(l))
	}
	l = len(m.DiscoveryProtocol)
	if l > 0 {
		n += 1 + l + sovOrchestration(uint64(l))
	}
	l = len(m.DiscoveryOperation)
	if l > 0 {
		n += 1 + l + sovOrchestration(uint64(l))
	}
	if m.NumUplinks != 0 {
		n += 1 + sovOrchestration(uint64(m.NumUplinks))
	}
	return n
}

func (m *MonitoredNamespaceSpec) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *NamespaceSpec) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovOrchestration(uint64(l))
	}
	l = len(m.Mode)
	if l > 0 {
		n += 1 + l + sovOrchestration(uint64(l))
	}
	if m.ManagedSpec != nil {
		l = m.ManagedSpec.Size()
		n += 1 + l + sovOrchestration(uint64(l))
	}
	if m.MonitoredSpec != nil {
		l = m.MonitoredSpec.Size()
		n += 1 + l + sovOrchestration(uint64(l))
	}
	return n
}

func (m *Orchestrator) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovOrchestration(uint64(l))
	l = m.ObjectMeta.Size()
	n += 1 + l + sovOrchestration(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovOrchestration(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovOrchestration(uint64(l))
	return n
}

func (m *OrchestratorSpec) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovOrchestration(uint64(l))
	}
	l = len(m.URI)
	if l > 0 {
		n += 1 + l + sovOrchestration(uint64(l))
	}
	if m.Credentials != nil {
		l = m.Credentials.Size()
		n += 1 + l + sovOrchestration(uint64(l))
	}
	if len(m.ManageNamespaces) > 0 {
		for _, s := range m.ManageNamespaces {
			l = len(s)
			n += 1 + l + sovOrchestration(uint64(l))
		}
	}
	if len(m.Namespaces) > 0 {
		for _, e := range m.Namespaces {
			l = e.Size()
			n += 1 + l + sovOrchestration(uint64(l))
		}
	}
	return n
}

func (m *OrchestratorStatus) Size() (n int) {
	var l int
	_ = l
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovOrchestration(uint64(l))
	}
	if m.LastTransitionTime != nil {
		l = m.LastTransitionTime.Size()
		n += 1 + l + sovOrchestration(uint64(l))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovOrchestration(uint64(l))
	}
	if m.OrchID != 0 {
		n += 1 + sovOrchestration(uint64(m.OrchID))
	}
	if len(m.DiscoveredNamespaces) > 0 {
		for _, s := range m.DiscoveredNamespaces {
			l = len(s)
			n += 1 + l + sovOrchestration(uint64(l))
		}
	}
	if len(m.IncompatibleDSCs) > 0 {
		for _, s := range m.IncompatibleDSCs {
			l = len(s)
			n += 1 + l + sovOrchestration(uint64(l))
		}
	}
	return n
}

func sovOrchestration(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozOrchestration(x uint64) (n int) {
	return sovOrchestration(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ManagedNamespaceSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrchestration
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ManagedNamespaceSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ManagedNamespaceSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MTU", wireType)
			}
			m.MTU = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrchestration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MTU |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MulticastFilter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrchestration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrchestration
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MulticastFilter = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiscoveryProtocol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrchestration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrchestration
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DiscoveryProtocol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiscoveryOperation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrchestration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrchestration
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DiscoveryOperation = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumUplinks", wireType)
			}
			m.NumUplinks = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrchestration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumUplinks |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOrchestration(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOrchestration
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MonitoredNamespaceSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrchestration
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MonitoredNamespaceSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MonitoredNamespaceSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipOrchestration(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOrchestration
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NamespaceSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrchestration
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NamespaceSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NamespaceSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrchestration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrchestration
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrchestration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrchestration
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ManagedSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrchestration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrchestration
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ManagedSpec == nil {
				m.ManagedSpec = &ManagedNamespaceSpec{}
			}
			if err := m.ManagedSpec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MonitoredSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrchestration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrchestration
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MonitoredSpec == nil {
				m.MonitoredSpec = &MonitoredNamespaceSpec{}
			}
			if err := m.MonitoredSpec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOrchestration(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOrchestration
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Orchestrator) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrchestration
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Orchestrator: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Orchestrator: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrchestration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrchestration
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrchestration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrchestration
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrchestration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrchestration
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrchestration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrchestration
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOrchestration(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOrchestration
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OrchestratorSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrchestration
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OrchestratorSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OrchestratorSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrchestration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrchestration
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URI", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrchestration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrchestration
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.URI = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Credentials", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrchestration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrchestration
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Credentials == nil {
				m.Credentials = &monitoring.ExternalCred{}
			}
			if err := m.Credentials.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ManageNamespaces", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrchestration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrchestration
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ManageNamespaces = append(m.ManageNamespaces, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespaces", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrchestration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrchestration
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespaces = append(m.Namespaces, &NamespaceSpec{})
			if err := m.Namespaces[len(m.Namespaces)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOrchestration(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOrchestration
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OrchestratorStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrchestration
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OrchestratorStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OrchestratorStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrchestration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrchestration
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastTransitionTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrchestration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrchestration
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastTransitionTime == nil {
				m.LastTransitionTime = &api.Timestamp{}
			}
			if err := m.LastTransitionTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrchestration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrchestration
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrchID", wireType)
			}
			m.OrchID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrchestration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OrchID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiscoveredNamespaces", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrchestration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrchestration
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DiscoveredNamespaces = append(m.DiscoveredNamespaces, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IncompatibleDSCs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrchestration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrchestration
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IncompatibleDSCs = append(m.IncompatibleDSCs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOrchestration(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOrchestration
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipOrchestration(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowOrchestration
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowOrchestration
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowOrchestration
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthOrchestration
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowOrchestration
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipOrchestration(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthOrchestration = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowOrchestration   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("orchestration.proto", fileDescriptorOrchestration) }

var fileDescriptorOrchestration = []byte{
	// 1328 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x56, 0x4f, 0x6f, 0x1b, 0x45,
	0x14, 0xcf, 0xc6, 0xce, 0x1f, 0x8f, 0xe3, 0x76, 0x3b, 0x0d, 0xc1, 0x6b, 0xd2, 0x38, 0xb8, 0x2a,
	0x24, 0x10, 0xdb, 0x6d, 0xa0, 0x95, 0xa8, 0xe0, 0xc0, 0x26, 0xa9, 0xd4, 0x2a, 0x4e, 0x82, 0x9d,
	0x70, 0xa8, 0x84, 0xd0, 0x7a, 0x77, 0xe2, 0x0c, 0xdd, 0x9d, 0x59, 0xed, 0xcc, 0xa6, 0x8d, 0xc4,
	0x15, 0xcb, 0x07, 0x10, 0xdf, 0xc3, 0x37, 0x7a, 0xe3, 0xc6, 0x05, 0xa9, 0xc7, 0x8a, 0x13, 0x27,
	0x0b, 0xf9, 0x84, 0xf2, 0x29, 0xd0, 0xcc, 0xce, 0x6e, 0xd7, 0x8e, 0xeb, 0x72, 0x19, 0xf9, 0xfd,
	0xfb, 0xbd, 0x37, 0xef, 0xfd, 0xde, 0x7a, 0xc0, 0x4d, 0x1a, 0xd8, 0x67, 0x88, 0xf1, 0xc0, 0xe2,
	0x98, 0x92, 0x9a, 0x1f, 0x50, 0x4e, 0x61, 0x61, 0x44, 0x59, 0x5a, 0xed, 0x50, 0xda, 0x71, 0x51,
	0xdd, 0xf2, 0x71, 0xdd, 0x22, 0x84, 0x72, 0xa9, 0x66, 0x91, 0x73, 0x69, 0xaf, 0x83, 0xf9, 0x59,
	0xd8, 0xae, 0xd9, 0xd4, 0xab, 0xfb, 0x88, 0x30, 0x8b, 0x38, 0xb4, 0xce, 0x9e, 0xd7, 0xcf, 0x11,
	0xc1, 0x36, 0xaa, 0x87, 0x1c, 0xbb, 0x4c, 0x84, 0x76, 0x10, 0x49, 0x47, 0xd7, 0x31, 0xb1, 0xdd,
	0xd0, 0x41, 0x31, 0x4c, 0x35, 0x05, 0xd3, 0xa1, 0x1d, 0x5a, 0x97, 0xea, 0x76, 0x78, 0x2a, 0x25,
	0x29, 0xc8, 0x5f, 0xca, 0xfd, 0xce, 0x5b, 0xb2, 0x8a, 0x1a, 0x3d, 0xc4, 0x2d, 0xe5, 0xb6, 0x84,
	0x5e, 0xf8, 0x34, 0xe0, 0x91, 0x54, 0xf9, 0x73, 0x1e, 0x2c, 0x37, 0x2c, 0x62, 0x75, 0x90, 0x73,
	0x60, 0x79, 0x88, 0xf9, 0x96, 0x8d, 0x5a, 0x3e, 0xb2, 0xe1, 0x17, 0x20, 0xd3, 0x38, 0x3e, 0x29,
	0x6a, 0xeb, 0xda, 0x46, 0xc1, 0xbc, 0xf5, 0xb2, 0x6b, 0x64, 0xef, 0xdd, 0xbf, 0x7b, 0xf7, 0xd5,
	0xa0, 0xac, 0x5d, 0x0e, 0xca, 0x05, 0x8f, 0x87, 0x5b, 0xd4, 0xc3, 0x1c, 0x79, 0x3e, 0xbf, 0x68,
	0x8e, 0x8a, 0xf0, 0x57, 0x0d, 0x5c, 0x6f, 0x84, 0x2e, 0xc7, 0xb6, 0xc5, 0xf8, 0x23, 0xec, 0x72,
	0x14, 0x14, 0x67, 0xd7, 0xb5, 0x8d, 0x9c, 0xf9, 0xb4, 0xdf, 0x35, 0x3e, 0x6f, 0xf1, 0x60, 0x8f,
	0x84, 0xde, 0xc6, 0xa4, 0xb4, 0xb5, 0xb1, 0x38, 0x4c, 0x3a, 0x0d, 0xea, 0xa0, 0x4d, 0x95, 0xb7,
	0xe4, 0xc5, 0xe6, 0xea, 0xa9, 0xb4, 0xa7, 0x8a, 0x98, 0x62, 0x83, 0x3f, 0x6b, 0xe0, 0xc6, 0x2e,
	0x66, 0x36, 0x3d, 0x47, 0xc1, 0xc5, 0x91, 0xb8, 0xb8, 0x4d, 0xdd, 0x62, 0x46, 0xd6, 0xd4, 0xea,
	0x77, 0x8d, 0x4f, 0xa7, 0xd6, 0x94, 0x44, 0x1e, 0x5f, 0xf8, 0x49, 0x29, 0xab, 0x4e, 0xac, 0xad,
	0xfa, 0x0a, 0x30, 0x55, 0xcc, 0x54, 0x2b, 0xfc, 0x45, 0x03, 0x30, 0x01, 0x3d, 0xf4, 0x51, 0x44,
	0xaa, 0x62, 0x56, 0xd6, 0xd3, 0xec, 0x77, 0x8d, 0xcd, 0xff, 0x57, 0xcf, 0xa1, 0x1f, 0x57, 0x73,
	0xeb, 0x4d, 0x3e, 0x1a, 0xe3, 0xa5, 0xca, 0x99, 0x6e, 0x86, 0xf7, 0x01, 0x38, 0x08, 0xbd, 0x13,
	0xdf, 0xc5, 0xe4, 0x19, 0x2b, 0xce, 0xc9, 0x91, 0x2f, 0xbf, 0xec, 0x1a, 0xda, 0xf6, 0xe5, 0xa0,
	0x9c, 0x27, 0xa1, 0x57, 0x0d, 0x23, 0x5b, 0x33, 0x2d, 0x54, 0xbe, 0x01, 0x85, 0x91, 0xd6, 0xc0,
	0x12, 0x58, 0xdc, 0xc5, 0xcc, 0x6a, 0xbb, 0xc8, 0xd1, 0x67, 0x4a, 0x4b, 0xc3, 0x9e, 0xb1, 0xe8,
	0x28, 0x19, 0xea, 0x20, 0xb3, 0xb3, 0x7b, 0xa4, 0x6b, 0xa5, 0x85, 0x61, 0xcf, 0xc8, 0xd8, 0x8e,
	0x0f, 0x21, 0xc8, 0xee, 0xef, 0xef, 0x1e, 0xe9, 0xb3, 0xa5, 0xc5, 0x61, 0xcf, 0xc8, 0xba, 0xae,
	0xe3, 0x57, 0x9e, 0x81, 0x7c, 0xea, 0x76, 0xc2, 0xe5, 0x80, 0x12, 0xa4, 0xcf, 0x44, 0x2e, 0x84,
	0x12, 0x04, 0x57, 0xc0, 0xfc, 0x3e, 0x66, 0x1c, 0x11, 0x5d, 0x2b, 0x81, 0x61, 0xcf, 0x98, 0x77,
	0xa5, 0x04, 0x57, 0x41, 0xee, 0x6b, 0xe7, 0x1c, 0x05, 0x1c, 0x33, 0xa4, 0xcf, 0x96, 0x0a, 0xc3,
	0x9e, 0x91, 0xb3, 0x62, 0x85, 0x40, 0x32, 0x29, 0x3f, 0xd3, 0x33, 0x11, 0x52, 0x9b, 0xf2, 0xb3,
	0xca, 0x13, 0xb0, 0x32, 0x99, 0x6e, 0x70, 0x19, 0xcc, 0x99, 0x16, 0xc3, 0xb6, 0x3e, 0x53, 0xca,
	0x0d, 0x7b, 0xc6, 0x5c, 0x5b, 0x08, 0xe2, 0x7a, 0x2d, 0x42, 0xa9, 0x8f, 0x49, 0x47, 0xd7, 0xa2,
	0xeb, 0x31, 0x25, 0x57, 0x8a, 0x60, 0xa5, 0x41, 0x09, 0xe6, 0x34, 0x18, 0x9b, 0x56, 0xe5, 0xf7,
	0x0c, 0x28, 0x8c, 0xae, 0xd6, 0x16, 0xc8, 0x0a, 0x85, 0xdc, 0xad, 0x9c, 0x59, 0xec, 0x77, 0x8d,
	0xa5, 0x16, 0x0f, 0xf6, 0x11, 0xd9, 0xb8, 0xb7, 0x55, 0xbd, 0xb7, 0x79, 0x39, 0x28, 0x67, 0x89,
	0xe5, 0xa1, 0xa6, 0x3c, 0xe1, 0x13, 0x90, 0x15, 0x35, 0xa9, 0x0d, 0x7a, 0xd0, 0xef, 0x1a, 0xe5,
	0x98, 0x1d, 0x63, 0xab, 0x43, 0x1d, 0x24, 0x19, 0xfa, 0xb2, 0x6b, 0x2c, 0x78, 0x11, 0x71, 0x04,
	0x96, 0x47, 0x1d, 0xd4, 0x94, 0x27, 0xf4, 0x41, 0x5e, 0x31, 0x4a, 0x44, 0xc8, 0x05, 0xc8, 0x6f,
	0xdf, 0xae, 0x8d, 0x7e, 0xf0, 0x26, 0x71, 0xce, 0x5c, 0x53, 0x44, 0x5b, 0x51, 0xc0, 0x55, 0xe6,
	0x23, 0x3b, 0xc5, 0xb0, 0xb7, 0xe8, 0xe1, 0x0b, 0x50, 0x48, 0xfa, 0x22, 0x73, 0x66, 0x65, 0xce,
	0x3b, 0xe3, 0x39, 0x27, 0xf6, 0xce, 0x5c, 0x57, 0x59, 0x8b, 0x5e, 0x6c, 0x1f, 0xcf, 0xfb, 0x56,
	0x4b, 0xc5, 0x04, 0x8b, 0x71, 0x47, 0x60, 0x11, 0x2c, 0xa8, 0x5b, 0xe9, 0x33, 0xa5, 0xfc, 0xb0,
	0x97, 0xf4, 0x47, 0xb0, 0x26, 0xc9, 0xad, 0x6b, 0x11, 0x6b, 0x12, 0xc8, 0xca, 0xdf, 0xb3, 0x60,
	0xe9, 0x30, 0x29, 0x94, 0x06, 0xf0, 0x01, 0xd0, 0x8e, 0xe5, 0xdc, 0xf2, 0xdb, 0x85, 0x9a, 0xe5,
	0xe3, 0x9a, 0x80, 0x6f, 0x20, 0x6e, 0x99, 0x37, 0x5f, 0x0d, 0xca, 0x33, 0xaf, 0xa3, 0x72, 0x17,
	0xb6, 0x30, 0x71, 0x31, 0x41, 0xcd, 0xf8, 0x07, 0x7c, 0x04, 0xb4, 0x43, 0x39, 0xc1, 0xfc, 0xf6,
	0x75, 0x19, 0x77, 0xd8, 0xfe, 0x01, 0xd9, 0x5c, 0x46, 0x96, 0x52, 0x91, 0xd7, 0xc4, 0x87, 0x3a,
	0x75, 0xbd, 0x31, 0x19, 0x9e, 0x80, 0x6c, 0x6a, 0x72, 0xe5, 0xb1, 0x2e, 0xa6, 0x4b, 0x95, 0xfd,
	0x5b, 0x11, 0xd0, 0x02, 0x76, 0xac, 0x6b, 0x63, 0x32, 0xfc, 0x0e, 0xcc, 0xb7, 0xb8, 0xc5, 0x43,
	0xa6, 0xc6, 0xf3, 0xe1, 0x34, 0x60, 0xe9, 0x68, 0x16, 0x15, 0xb4, 0xce, 0xa4, 0x9c, 0x02, 0xbf,
	0xa2, 0x79, 0x08, 0xff, 0xfa, 0xc9, 0xb8, 0x06, 0x97, 0x68, 0x0a, 0xa5, 0x32, 0xc8, 0x00, 0x7d,
	0xbc, 0x5e, 0x78, 0x00, 0xb2, 0xa2, 0xa1, 0x6a, 0x33, 0x1e, 0xf6, 0xbb, 0xc6, 0x27, 0x31, 0xd7,
	0xc7, 0x7d, 0x47, 0x6a, 0x92, 0xb4, 0xff, 0xa3, 0x6b, 0x88, 0x82, 0xb2, 0xfc, 0xc2, 0x47, 0x4d,
	0x79, 0xc2, 0x4d, 0x90, 0x39, 0x69, 0x3e, 0x56, 0xab, 0xf3, 0xfe, 0x84, 0x45, 0xcb, 0x84, 0x01,
	0x6e, 0x8a, 0x03, 0x7e, 0x0f, 0xf2, 0x3b, 0x01, 0x72, 0x10, 0xe1, 0xd8, 0x72, 0x99, 0x6a, 0x70,
	0xb1, 0xa6, 0xb8, 0x80, 0x49, 0xa7, 0xb6, 0xf7, 0x82, 0xa3, 0x80, 0x58, 0xae, 0x70, 0x33, 0x8d,
	0xcb, 0x41, 0xf9, 0x3d, 0xfb, 0x4d, 0x40, 0xea, 0xfe, 0x93, 0xd5, 0xf0, 0x29, 0xd0, 0x23, 0x0e,
	0x26, 0x14, 0x17, 0xdd, 0xce, 0x6c, 0xe4, 0xcc, 0xdb, 0x8a, 0xe5, 0x1f, 0x44, 0xa4, 0xac, 0x92,
	0xc4, 0x21, 0x85, 0x3a, 0xcd, 0x08, 0x1d, 0x00, 0x52, 0xa8, 0x73, 0xeb, 0x99, 0x8d, 0xfc, 0xf6,
	0xea, 0xd8, 0x0c, 0x47, 0x37, 0x6b, 0x55, 0xe5, 0x5c, 0x9e, 0x98, 0x6c, 0xa2, 0xb6, 0xb2, 0x35,
	0x3a, 0xb1, 0x78, 0xb3, 0xbe, 0xdd, 0x41, 0x84, 0xa3, 0x20, 0xde, 0xac, 0x73, 0x5b, 0x8a, 0x95,
	0xdf, 0xe6, 0x00, 0xbc, 0xca, 0x1b, 0x78, 0x96, 0x50, 0x2d, 0x1a, 0xf2, 0x5e, 0xbf, 0x6b, 0x6c,
	0x4d, 0x1c, 0xb2, 0xf4, 0xaa, 0xed, 0x50, 0x42, 0x90, 0x2d, 0x6e, 0x10, 0x29, 0xc4, 0xd4, 0x6e,
	0xd8, 0x89, 0xb2, 0x1a, 0x91, 0xad, 0x79, 0x55, 0x05, 0x03, 0x00, 0xf7, 0x2d, 0xc6, 0x8f, 0x03,
	0x8b, 0x30, 0x2c, 0x0c, 0xc7, 0xd8, 0x43, 0x6a, 0x09, 0xaf, 0x45, 0xcb, 0x8b, 0x3d, 0xc4, 0xb8,
	0xe5, 0xf9, 0xe6, 0x47, 0xaa, 0x1d, 0x6b, 0xae, 0x78, 0x3f, 0xf0, 0x24, 0xa4, 0xca, 0xb1, 0x87,
	0x52, 0x8d, 0x79, 0x87, 0x1d, 0x7e, 0x05, 0x16, 0x1a, 0x88, 0x31, 0xab, 0x83, 0xd4, 0xeb, 0xc2,
	0x50, 0xc0, 0x37, 0xbc, 0x48, 0x9d, 0xc2, 0xba, 0xaa, 0x82, 0x5f, 0x82, 0x79, 0xd1, 0x82, 0xc7,
	0xbb, 0x72, 0x0f, 0xe7, 0xde, 0x44, 0x8b, 0x51, 0x56, 0xb1, 0x93, 0x8e, 0xbe, 0xa2, 0x82, 0xa7,
	0x60, 0x39, 0xfe, 0xf3, 0x4c, 0x7d, 0x48, 0x23, 0x3e, 0xe4, 0xcc, 0x8f, 0x15, 0x56, 0xd9, 0x49,
	0x7c, 0x26, 0x33, 0xed, 0x5d, 0x0e, 0x82, 0xc9, 0x8f, 0x89, 0x4d, 0x3d, 0xdf, 0xe2, 0xb8, 0xed,
	0xa2, 0xdd, 0xd6, 0x0e, 0x2b, 0xce, 0x8f, 0x32, 0x19, 0xa7, 0xec, 0x55, 0x87, 0xd9, 0x23, 0x4c,
	0x9e, 0x62, 0xac, 0xfc, 0x08, 0xf4, 0xf1, 0x89, 0x0b, 0x8e, 0x9d, 0x90, 0x67, 0x84, 0x3e, 0x27,
	0x31, 0xc7, 0xc2, 0x48, 0x14, 0x96, 0x56, 0x68, 0xdb, 0x88, 0x31, 0x5d, 0x8b, 0x2c, 0x2c, 0x12,
	0x85, 0xe5, 0x91, 0x85, 0xdd, 0x30, 0x10, 0x6f, 0x01, 0x69, 0x39, 0x8d, 0x44, 0xf9, 0x48, 0x41,
	0x9d, 0xc0, 0x72, 0x90, 0xa3, 0x67, 0xd4, 0x23, 0x45, 0xc9, 0xa6, 0xfe, 0x6a, 0xb8, 0xa6, 0xbd,
	0x1e, 0xae, 0x69, 0xff, 0x0c, 0xd7, 0xb4, 0x7f, 0x87, 0x6b, 0x33, 0x47, 0x5a, 0x7b, 0x5e, 0x3e,
	0xe0, 0x3e, 0xfb, 0x2f, 0x00, 0x00, 0xff, 0xff, 0xc8, 0x10, 0x56, 0x7e, 0x17, 0x0c, 0x00, 0x00,
}
