// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: svc_orchestration.proto

package orchestration

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/pensando/grpc-gateway/third_party/googleapis/google/api"
import _ "github.com/pensando/sw/venice/utils/apigen/annotations"
import _ "github.com/gogo/protobuf/gogoproto"
import api "github.com/pensando/sw/api"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// AutoMsgOrchestratorWatchHelper is a wrapper object for watch events for Orchestrator objects
type AutoMsgOrchestratorWatchHelper struct {
	Events []*AutoMsgOrchestratorWatchHelper_WatchEvent `protobuf:"bytes,1,rep,name=Events,json=events" json:"events"`
}

func (m *AutoMsgOrchestratorWatchHelper) Reset()         { *m = AutoMsgOrchestratorWatchHelper{} }
func (m *AutoMsgOrchestratorWatchHelper) String() string { return proto.CompactTextString(m) }
func (*AutoMsgOrchestratorWatchHelper) ProtoMessage()    {}
func (*AutoMsgOrchestratorWatchHelper) Descriptor() ([]byte, []int) {
	return fileDescriptorSvcOrchestration, []int{0}
}

func (m *AutoMsgOrchestratorWatchHelper) GetEvents() []*AutoMsgOrchestratorWatchHelper_WatchEvent {
	if m != nil {
		return m.Events
	}
	return nil
}

type AutoMsgOrchestratorWatchHelper_WatchEvent struct {
	Type   string        `protobuf:"bytes,1,opt,name=Type,proto3" json:"type,omitempty"`
	Object *Orchestrator `protobuf:"bytes,2,opt,name=Object" json:"object,omitempty"`
}

func (m *AutoMsgOrchestratorWatchHelper_WatchEvent) Reset() {
	*m = AutoMsgOrchestratorWatchHelper_WatchEvent{}
}
func (m *AutoMsgOrchestratorWatchHelper_WatchEvent) String() string { return proto.CompactTextString(m) }
func (*AutoMsgOrchestratorWatchHelper_WatchEvent) ProtoMessage()    {}
func (*AutoMsgOrchestratorWatchHelper_WatchEvent) Descriptor() ([]byte, []int) {
	return fileDescriptorSvcOrchestration, []int{0, 0}
}

func (m *AutoMsgOrchestratorWatchHelper_WatchEvent) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *AutoMsgOrchestratorWatchHelper_WatchEvent) GetObject() *Orchestrator {
	if m != nil {
		return m.Object
	}
	return nil
}

// OrchestratorList is a container object for list of Orchestrator objects
type OrchestratorList struct {
	api.TypeMeta `protobuf:"bytes,2,opt,name=T,json=,inline,embedded=T" json:",inline"`
	api.ListMeta `protobuf:"bytes,3,opt,name=ListMeta,json=list-meta,inline,embedded=ListMeta" json:"list-meta,inline"`
	// List of Orchestrator objects
	Items []*Orchestrator `protobuf:"bytes,4,rep,name=Items,json=items" json:"items"`
}

func (m *OrchestratorList) Reset()                    { *m = OrchestratorList{} }
func (m *OrchestratorList) String() string            { return proto.CompactTextString(m) }
func (*OrchestratorList) ProtoMessage()               {}
func (*OrchestratorList) Descriptor() ([]byte, []int) { return fileDescriptorSvcOrchestration, []int{1} }

func (m *OrchestratorList) GetItems() []*Orchestrator {
	if m != nil {
		return m.Items
	}
	return nil
}

func init() {
	proto.RegisterType((*AutoMsgOrchestratorWatchHelper)(nil), "orchestration.AutoMsgOrchestratorWatchHelper")
	proto.RegisterType((*AutoMsgOrchestratorWatchHelper_WatchEvent)(nil), "orchestration.AutoMsgOrchestratorWatchHelper.WatchEvent")
	proto.RegisterType((*OrchestratorList)(nil), "orchestration.OrchestratorList")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for OrchestratorV1 service

type OrchestratorV1Client interface {
	// Create Orchestrator object
	AutoAddOrchestrator(ctx context.Context, in *Orchestrator, opts ...grpc.CallOption) (*Orchestrator, error)
	// Delete Orchestrator object
	AutoDeleteOrchestrator(ctx context.Context, in *Orchestrator, opts ...grpc.CallOption) (*Orchestrator, error)
	// Get Orchestrator object
	AutoGetOrchestrator(ctx context.Context, in *Orchestrator, opts ...grpc.CallOption) (*Orchestrator, error)
	// Label Orchestrator object
	AutoLabelOrchestrator(ctx context.Context, in *api.Label, opts ...grpc.CallOption) (*Orchestrator, error)
	// List Orchestrator objects
	AutoListOrchestrator(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (*OrchestratorList, error)
	// Update Orchestrator object
	AutoUpdateOrchestrator(ctx context.Context, in *Orchestrator, opts ...grpc.CallOption) (*Orchestrator, error)
	// Watch Orchestrator objects. Supports WebSockets or HTTP long poll
	AutoWatchOrchestrator(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (OrchestratorV1_AutoWatchOrchestratorClient, error)
	AutoWatchSvcOrchestratorV1(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (OrchestratorV1_AutoWatchSvcOrchestratorV1Client, error)
}

type orchestratorV1Client struct {
	cc *grpc.ClientConn
}

func NewOrchestratorV1Client(cc *grpc.ClientConn) OrchestratorV1Client {
	return &orchestratorV1Client{cc}
}

func (c *orchestratorV1Client) AutoAddOrchestrator(ctx context.Context, in *Orchestrator, opts ...grpc.CallOption) (*Orchestrator, error) {
	out := new(Orchestrator)
	err := grpc.Invoke(ctx, "/orchestration.OrchestratorV1/AutoAddOrchestrator", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *orchestratorV1Client) AutoDeleteOrchestrator(ctx context.Context, in *Orchestrator, opts ...grpc.CallOption) (*Orchestrator, error) {
	out := new(Orchestrator)
	err := grpc.Invoke(ctx, "/orchestration.OrchestratorV1/AutoDeleteOrchestrator", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *orchestratorV1Client) AutoGetOrchestrator(ctx context.Context, in *Orchestrator, opts ...grpc.CallOption) (*Orchestrator, error) {
	out := new(Orchestrator)
	err := grpc.Invoke(ctx, "/orchestration.OrchestratorV1/AutoGetOrchestrator", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *orchestratorV1Client) AutoLabelOrchestrator(ctx context.Context, in *api.Label, opts ...grpc.CallOption) (*Orchestrator, error) {
	out := new(Orchestrator)
	err := grpc.Invoke(ctx, "/orchestration.OrchestratorV1/AutoLabelOrchestrator", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *orchestratorV1Client) AutoListOrchestrator(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (*OrchestratorList, error) {
	out := new(OrchestratorList)
	err := grpc.Invoke(ctx, "/orchestration.OrchestratorV1/AutoListOrchestrator", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *orchestratorV1Client) AutoUpdateOrchestrator(ctx context.Context, in *Orchestrator, opts ...grpc.CallOption) (*Orchestrator, error) {
	out := new(Orchestrator)
	err := grpc.Invoke(ctx, "/orchestration.OrchestratorV1/AutoUpdateOrchestrator", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *orchestratorV1Client) AutoWatchOrchestrator(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (OrchestratorV1_AutoWatchOrchestratorClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_OrchestratorV1_serviceDesc.Streams[0], c.cc, "/orchestration.OrchestratorV1/AutoWatchOrchestrator", opts...)
	if err != nil {
		return nil, err
	}
	x := &orchestratorV1AutoWatchOrchestratorClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type OrchestratorV1_AutoWatchOrchestratorClient interface {
	Recv() (*AutoMsgOrchestratorWatchHelper, error)
	grpc.ClientStream
}

type orchestratorV1AutoWatchOrchestratorClient struct {
	grpc.ClientStream
}

func (x *orchestratorV1AutoWatchOrchestratorClient) Recv() (*AutoMsgOrchestratorWatchHelper, error) {
	m := new(AutoMsgOrchestratorWatchHelper)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *orchestratorV1Client) AutoWatchSvcOrchestratorV1(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (OrchestratorV1_AutoWatchSvcOrchestratorV1Client, error) {
	stream, err := grpc.NewClientStream(ctx, &_OrchestratorV1_serviceDesc.Streams[1], c.cc, "/orchestration.OrchestratorV1/AutoWatchSvcOrchestratorV1", opts...)
	if err != nil {
		return nil, err
	}
	x := &orchestratorV1AutoWatchSvcOrchestratorV1Client{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type OrchestratorV1_AutoWatchSvcOrchestratorV1Client interface {
	Recv() (*api.WatchEventList, error)
	grpc.ClientStream
}

type orchestratorV1AutoWatchSvcOrchestratorV1Client struct {
	grpc.ClientStream
}

func (x *orchestratorV1AutoWatchSvcOrchestratorV1Client) Recv() (*api.WatchEventList, error) {
	m := new(api.WatchEventList)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for OrchestratorV1 service

type OrchestratorV1Server interface {
	// Create Orchestrator object
	AutoAddOrchestrator(context.Context, *Orchestrator) (*Orchestrator, error)
	// Delete Orchestrator object
	AutoDeleteOrchestrator(context.Context, *Orchestrator) (*Orchestrator, error)
	// Get Orchestrator object
	AutoGetOrchestrator(context.Context, *Orchestrator) (*Orchestrator, error)
	// Label Orchestrator object
	AutoLabelOrchestrator(context.Context, *api.Label) (*Orchestrator, error)
	// List Orchestrator objects
	AutoListOrchestrator(context.Context, *api.ListWatchOptions) (*OrchestratorList, error)
	// Update Orchestrator object
	AutoUpdateOrchestrator(context.Context, *Orchestrator) (*Orchestrator, error)
	// Watch Orchestrator objects. Supports WebSockets or HTTP long poll
	AutoWatchOrchestrator(*api.ListWatchOptions, OrchestratorV1_AutoWatchOrchestratorServer) error
	AutoWatchSvcOrchestratorV1(*api.ListWatchOptions, OrchestratorV1_AutoWatchSvcOrchestratorV1Server) error
}

func RegisterOrchestratorV1Server(s *grpc.Server, srv OrchestratorV1Server) {
	s.RegisterService(&_OrchestratorV1_serviceDesc, srv)
}

func _OrchestratorV1_AutoAddOrchestrator_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Orchestrator)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OrchestratorV1Server).AutoAddOrchestrator(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/orchestration.OrchestratorV1/AutoAddOrchestrator",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OrchestratorV1Server).AutoAddOrchestrator(ctx, req.(*Orchestrator))
	}
	return interceptor(ctx, in, info, handler)
}

func _OrchestratorV1_AutoDeleteOrchestrator_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Orchestrator)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OrchestratorV1Server).AutoDeleteOrchestrator(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/orchestration.OrchestratorV1/AutoDeleteOrchestrator",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OrchestratorV1Server).AutoDeleteOrchestrator(ctx, req.(*Orchestrator))
	}
	return interceptor(ctx, in, info, handler)
}

func _OrchestratorV1_AutoGetOrchestrator_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Orchestrator)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OrchestratorV1Server).AutoGetOrchestrator(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/orchestration.OrchestratorV1/AutoGetOrchestrator",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OrchestratorV1Server).AutoGetOrchestrator(ctx, req.(*Orchestrator))
	}
	return interceptor(ctx, in, info, handler)
}

func _OrchestratorV1_AutoLabelOrchestrator_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(api.Label)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OrchestratorV1Server).AutoLabelOrchestrator(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/orchestration.OrchestratorV1/AutoLabelOrchestrator",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OrchestratorV1Server).AutoLabelOrchestrator(ctx, req.(*api.Label))
	}
	return interceptor(ctx, in, info, handler)
}

func _OrchestratorV1_AutoListOrchestrator_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(api.ListWatchOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OrchestratorV1Server).AutoListOrchestrator(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/orchestration.OrchestratorV1/AutoListOrchestrator",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OrchestratorV1Server).AutoListOrchestrator(ctx, req.(*api.ListWatchOptions))
	}
	return interceptor(ctx, in, info, handler)
}

func _OrchestratorV1_AutoUpdateOrchestrator_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Orchestrator)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OrchestratorV1Server).AutoUpdateOrchestrator(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/orchestration.OrchestratorV1/AutoUpdateOrchestrator",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OrchestratorV1Server).AutoUpdateOrchestrator(ctx, req.(*Orchestrator))
	}
	return interceptor(ctx, in, info, handler)
}

func _OrchestratorV1_AutoWatchOrchestrator_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(api.ListWatchOptions)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(OrchestratorV1Server).AutoWatchOrchestrator(m, &orchestratorV1AutoWatchOrchestratorServer{stream})
}

type OrchestratorV1_AutoWatchOrchestratorServer interface {
	Send(*AutoMsgOrchestratorWatchHelper) error
	grpc.ServerStream
}

type orchestratorV1AutoWatchOrchestratorServer struct {
	grpc.ServerStream
}

func (x *orchestratorV1AutoWatchOrchestratorServer) Send(m *AutoMsgOrchestratorWatchHelper) error {
	return x.ServerStream.SendMsg(m)
}

func _OrchestratorV1_AutoWatchSvcOrchestratorV1_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(api.ListWatchOptions)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(OrchestratorV1Server).AutoWatchSvcOrchestratorV1(m, &orchestratorV1AutoWatchSvcOrchestratorV1Server{stream})
}

type OrchestratorV1_AutoWatchSvcOrchestratorV1Server interface {
	Send(*api.WatchEventList) error
	grpc.ServerStream
}

type orchestratorV1AutoWatchSvcOrchestratorV1Server struct {
	grpc.ServerStream
}

func (x *orchestratorV1AutoWatchSvcOrchestratorV1Server) Send(m *api.WatchEventList) error {
	return x.ServerStream.SendMsg(m)
}

var _OrchestratorV1_serviceDesc = grpc.ServiceDesc{
	ServiceName: "orchestration.OrchestratorV1",
	HandlerType: (*OrchestratorV1Server)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AutoAddOrchestrator",
			Handler:    _OrchestratorV1_AutoAddOrchestrator_Handler,
		},
		{
			MethodName: "AutoDeleteOrchestrator",
			Handler:    _OrchestratorV1_AutoDeleteOrchestrator_Handler,
		},
		{
			MethodName: "AutoGetOrchestrator",
			Handler:    _OrchestratorV1_AutoGetOrchestrator_Handler,
		},
		{
			MethodName: "AutoLabelOrchestrator",
			Handler:    _OrchestratorV1_AutoLabelOrchestrator_Handler,
		},
		{
			MethodName: "AutoListOrchestrator",
			Handler:    _OrchestratorV1_AutoListOrchestrator_Handler,
		},
		{
			MethodName: "AutoUpdateOrchestrator",
			Handler:    _OrchestratorV1_AutoUpdateOrchestrator_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "AutoWatchOrchestrator",
			Handler:       _OrchestratorV1_AutoWatchOrchestrator_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "AutoWatchSvcOrchestratorV1",
			Handler:       _OrchestratorV1_AutoWatchSvcOrchestratorV1_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "svc_orchestration.proto",
}

func (m *AutoMsgOrchestratorWatchHelper) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AutoMsgOrchestratorWatchHelper) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Events) > 0 {
		for _, msg := range m.Events {
			dAtA[i] = 0xa
			i++
			i = encodeVarintSvcOrchestration(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *AutoMsgOrchestratorWatchHelper_WatchEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AutoMsgOrchestratorWatchHelper_WatchEvent) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSvcOrchestration(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if m.Object != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSvcOrchestration(dAtA, i, uint64(m.Object.Size()))
		n1, err := m.Object.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	return i, nil
}

func (m *OrchestratorList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OrchestratorList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x12
	i++
	i = encodeVarintSvcOrchestration(dAtA, i, uint64(m.TypeMeta.Size()))
	n2, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n2
	dAtA[i] = 0x1a
	i++
	i = encodeVarintSvcOrchestration(dAtA, i, uint64(m.ListMeta.Size()))
	n3, err := m.ListMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n3
	if len(m.Items) > 0 {
		for _, msg := range m.Items {
			dAtA[i] = 0x22
			i++
			i = encodeVarintSvcOrchestration(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func encodeVarintSvcOrchestration(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *AutoMsgOrchestratorWatchHelper) Size() (n int) {
	var l int
	_ = l
	if len(m.Events) > 0 {
		for _, e := range m.Events {
			l = e.Size()
			n += 1 + l + sovSvcOrchestration(uint64(l))
		}
	}
	return n
}

func (m *AutoMsgOrchestratorWatchHelper_WatchEvent) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovSvcOrchestration(uint64(l))
	}
	if m.Object != nil {
		l = m.Object.Size()
		n += 1 + l + sovSvcOrchestration(uint64(l))
	}
	return n
}

func (m *OrchestratorList) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovSvcOrchestration(uint64(l))
	l = m.ListMeta.Size()
	n += 1 + l + sovSvcOrchestration(uint64(l))
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovSvcOrchestration(uint64(l))
		}
	}
	return n
}

func sovSvcOrchestration(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozSvcOrchestration(x uint64) (n int) {
	return sovSvcOrchestration(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *AutoMsgOrchestratorWatchHelper) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSvcOrchestration
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AutoMsgOrchestratorWatchHelper: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AutoMsgOrchestratorWatchHelper: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Events", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSvcOrchestration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSvcOrchestration
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Events = append(m.Events, &AutoMsgOrchestratorWatchHelper_WatchEvent{})
			if err := m.Events[len(m.Events)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSvcOrchestration(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSvcOrchestration
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AutoMsgOrchestratorWatchHelper_WatchEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSvcOrchestration
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WatchEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WatchEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSvcOrchestration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSvcOrchestration
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Object", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSvcOrchestration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSvcOrchestration
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Object == nil {
				m.Object = &Orchestrator{}
			}
			if err := m.Object.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSvcOrchestration(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSvcOrchestration
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OrchestratorList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSvcOrchestration
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OrchestratorList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OrchestratorList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSvcOrchestration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSvcOrchestration
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSvcOrchestration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSvcOrchestration
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ListMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSvcOrchestration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSvcOrchestration
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &Orchestrator{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSvcOrchestration(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSvcOrchestration
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipSvcOrchestration(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowSvcOrchestration
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSvcOrchestration
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSvcOrchestration
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthSvcOrchestration
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowSvcOrchestration
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipSvcOrchestration(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthSvcOrchestration = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowSvcOrchestration   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("svc_orchestration.proto", fileDescriptorSvcOrchestration) }

var fileDescriptorSvcOrchestration = []byte{
	// 802 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x95, 0xcf, 0x6b, 0x13, 0x41,
	0x14, 0xc7, 0x33, 0x49, 0x1a, 0xed, 0xd4, 0xd6, 0x38, 0x69, 0x6b, 0x76, 0x8d, 0xd9, 0x10, 0x11,
	0x6a, 0x69, 0xb3, 0x6d, 0xfd, 0x81, 0x04, 0x2f, 0x0d, 0x16, 0x7f, 0xd0, 0x1a, 0xa9, 0x55, 0x2f,
	0x8a, 0x6c, 0x36, 0xe3, 0x66, 0x65, 0xb3, 0xb3, 0x66, 0x27, 0x29, 0x41, 0x7a, 0x69, 0x52, 0x50,
	0x10, 0x44, 0xbd, 0x79, 0xf4, 0xe8, 0x31, 0x27, 0x8f, 0x1e, 0x8b, 0xa7, 0x82, 0xb7, 0x1e, 0x16,
	0x09, 0x1e, 0x34, 0x7f, 0x85, 0xcc, 0x6c, 0xd2, 0xee, 0xb6, 0x4d, 0x50, 0xe8, 0x69, 0x77, 0xdf,
	0xbc, 0xf7, 0x7d, 0x9f, 0x79, 0xef, 0xcd, 0x2c, 0x3c, 0x6b, 0xd7, 0xd4, 0x67, 0xa4, 0xa2, 0x96,
	0xb0, 0x4d, 0x2b, 0x0a, 0xd5, 0x89, 0x99, 0xb1, 0x2a, 0x84, 0x12, 0x34, 0xea, 0x33, 0x8a, 0x09,
	0x8d, 0x10, 0xcd, 0xc0, 0xb2, 0x62, 0xe9, 0xb2, 0x62, 0x9a, 0x84, 0x72, 0xb3, 0xed, 0x3a, 0x8b,
	0x4b, 0x9a, 0x4e, 0x4b, 0xd5, 0x42, 0x46, 0x25, 0x65, 0xd9, 0xc2, 0xa6, 0xad, 0x98, 0x45, 0x22,
	0xdb, 0xeb, 0x72, 0x0d, 0x9b, 0xba, 0x8a, 0xe5, 0x2a, 0xd5, 0x0d, 0x9b, 0x85, 0x6a, 0xd8, 0xf4,
	0x46, 0xcb, 0xba, 0xa9, 0x1a, 0xd5, 0x22, 0xee, 0xc9, 0xcc, 0x7a, 0x64, 0x34, 0xa2, 0x11, 0x99,
	0x9b, 0x0b, 0xd5, 0xe7, 0xfc, 0x8b, 0x7f, 0xf0, 0xb7, 0xae, 0x7b, 0xec, 0x08, 0x6e, 0xf1, 0x62,
	0x1f, 0x14, 0x06, 0x5e, 0xc6, 0x54, 0x71, 0xdd, 0xd2, 0x9b, 0x41, 0x98, 0x5c, 0xac, 0x52, 0xb2,
	0x62, 0x6b, 0xf9, 0x3d, 0x15, 0x52, 0x79, 0xac, 0x50, 0xb5, 0x74, 0x1b, 0x1b, 0x16, 0xae, 0xa0,
	0x27, 0x30, 0xb2, 0x54, 0xc3, 0x26, 0xb5, 0xe3, 0x20, 0x15, 0x9a, 0x1a, 0x59, 0xb8, 0x9e, 0xf1,
	0xe7, 0x1b, 0x1c, 0x9e, 0xe1, 0xef, 0x5c, 0x20, 0x07, 0x3b, 0x8e, 0x14, 0xc1, 0x5c, 0x6b, 0xb5,
	0xfb, 0x14, 0x5f, 0x42, 0xb8, 0xef, 0x81, 0x52, 0x30, 0xbc, 0x56, 0xb7, 0x70, 0x1c, 0xa4, 0xc0,
	0xd4, 0x70, 0x0e, 0x75, 0x1c, 0x69, 0x8c, 0xd6, 0x2d, 0x3c, 0x43, 0xca, 0x3a, 0xc5, 0x65, 0x8b,
	0xd6, 0xd1, 0x22, 0x8c, 0xe4, 0x0b, 0x2f, 0xb0, 0x4a, 0xe3, 0xc1, 0x14, 0x98, 0x1a, 0x59, 0x38,
	0x77, 0x80, 0xc6, 0x8b, 0x91, 0x1b, 0xef, 0x38, 0x52, 0x94, 0x70, 0xf7, 0x7d, 0x89, 0xec, 0xe9,
	0xdd, 0x2d, 0x61, 0x64, 0x9d, 0x25, 0x2d, 0x71, 0xc4, 0xf4, 0x1f, 0x00, 0xa3, 0xde, 0xb8, 0x65,
	0xdd, 0xa6, 0xe8, 0x1a, 0x04, 0x6b, 0xdd, 0x1c, 0xa3, 0x19, 0xc5, 0xd2, 0x33, 0x0c, 0x6c, 0x05,
	0x53, 0x25, 0x17, 0xdb, 0x76, 0xa4, 0xc0, 0x8e, 0x23, 0x81, 0x8e, 0x23, 0x9d, 0x98, 0xd1, 0x4d,
	0x43, 0x37, 0xf1, 0x6a, 0xef, 0x05, 0xe5, 0xe1, 0x49, 0x16, 0xcf, 0x3c, 0xe3, 0x21, 0x4f, 0x78,
	0xcf, 0x98, 0x4b, 0x78, 0xc2, 0xa3, 0x86, 0x6e, 0xd3, 0x59, 0xd6, 0x8f, 0x9e, 0xce, 0x21, 0x0b,
	0xba, 0x01, 0x87, 0xee, 0x50, 0x5c, 0xb6, 0xe3, 0x61, 0x5e, 0xfe, 0x81, 0x1b, 0x1e, 0xee, 0x38,
	0xd2, 0x10, 0xdb, 0xa7, 0xbd, 0xea, 0x3e, 0xb2, 0x63, 0xbb, 0x5b, 0x02, 0x64, 0x9a, 0xee, 0x5e,
	0x17, 0xde, 0x0d, 0xc3, 0x31, 0x6f, 0xc8, 0xa3, 0x79, 0xb4, 0x01, 0x63, 0xac, 0x87, 0x8b, 0xc5,
	0xa2, 0x77, 0x01, 0x0d, 0x4a, 0x24, 0x0e, 0x5a, 0x4c, 0xcf, 0xb4, 0x9a, 0x42, 0x44, 0xad, 0x60,
	0x85, 0xe2, 0xaf, 0x4d, 0x01, 0x7c, 0x6b, 0x0a, 0x81, 0xcd, 0x1f, 0xbf, 0x3e, 0x06, 0xc7, 0x61,
	0x20, 0x0b, 0xa6, 0xd3, 0xa3, 0x32, 0xf1, 0xe6, 0x79, 0x0d, 0xe0, 0x24, 0xcb, 0x7f, 0x13, 0x1b,
	0x98, 0xe2, 0x63, 0x42, 0xb8, 0xc2, 0x10, 0x8a, 0x5c, 0xd1, 0x87, 0x90, 0x80, 0x81, 0x6c, 0x60,
	0x7a, 0xd2, 0x47, 0x20, 0xbf, 0xca, 0x67, 0xee, 0x29, 0x65, 0xbc, 0x81, 0x36, 0x81, 0x5b, 0x8a,
	0x5b, 0x98, 0x1e, 0x13, 0xc7, 0x7c, 0xab, 0x29, 0x84, 0x34, 0x4c, 0x0f, 0x43, 0xa0, 0x7e, 0x10,
	0x6f, 0x01, 0x9c, 0x60, 0x10, 0xcb, 0x4a, 0x01, 0x1b, 0x3e, 0x0c, 0xe8, 0x0e, 0x12, 0xb3, 0x0f,
	0xce, 0x7a, 0xb7, 0xd5, 0x14, 0x86, 0x0c, 0xe6, 0xd7, 0xcb, 0xfb, 0xbd, 0x29, 0x9c, 0xf2, 0xba,
	0x70, 0x8e, 0x0b, 0x6e, 0x3f, 0x12, 0x47, 0x83, 0xc8, 0x5c, 0x00, 0xd5, 0xe1, 0x38, 0xa7, 0xd1,
	0x6d, 0x7f, 0x4d, 0x26, 0xf6, 0xa6, 0x9a, 0x9f, 0xdf, 0xbc, 0xc5, 0xaf, 0x32, 0x51, 0x1a, 0xc0,
	0xc5, 0x9c, 0xd3, 0x97, 0x5a, 0x4d, 0x21, 0xcc, 0x06, 0xd2, 0x57, 0x92, 0x18, 0x2f, 0xc9, 0x81,
	0xc9, 0x78, 0xd3, 0x9d, 0x8c, 0x87, 0x56, 0x51, 0x39, 0xb6, 0xc9, 0xb8, 0xca, 0x26, 0xa3, 0xca,
	0x15, 0x7d, 0x04, 0xe7, 0x79, 0x31, 0xc4, 0x7e, 0x5d, 0x79, 0xdf, 0xed, 0x8a, 0xbb, 0xd9, 0x7f,
	0x28, 0xc4, 0xec, 0x7f, 0x5d, 0x93, 0xe9, 0x39, 0xd6, 0x32, 0x7e, 0x29, 0xf9, 0xa8, 0x04, 0x5e,
	0x97, 0x98, 0xcc, 0x57, 0x7c, 0x68, 0x73, 0x00, 0x3d, 0x85, 0xe2, 0x1e, 0xd2, 0x83, 0x9a, 0x7a,
	0xe0, 0x58, 0xf7, 0xe1, 0x8a, 0x71, 0xf3, 0xfe, 0x9d, 0xcb, 0x9b, 0x72, 0xe6, 0x50, 0xf6, 0x39,
	0x20, 0xe2, 0x0f, 0x0d, 0x21, 0x58, 0x9b, 0xff, 0xd4, 0x10, 0xfc, 0x3f, 0xc1, 0xcf, 0x0d, 0xff,
	0x2c, 0x7d, 0x69, 0x08, 0x59, 0xe8, 0xb3, 0xa0, 0x90, 0x55, 0xa5, 0x88, 0xcd, 0x3d, 0xea, 0x1e,
	0x42, 0x14, 0xb6, 0x88, 0x4d, 0x11, 0x6f, 0x3c, 0x72, 0x33, 0x21, 0x77, 0x42, 0x73, 0xd1, 0xed,
	0x76, 0x12, 0xec, 0xb4, 0x93, 0xe0, 0x67, 0x3b, 0x09, 0x7e, 0xb7, 0x93, 0x81, 0xfb, 0xa0, 0x10,
	0xe1, 0x7f, 0xa7, 0xcb, 0x7f, 0x03, 0x00, 0x00, 0xff, 0xff, 0x1e, 0xee, 0x4e, 0xe1, 0x97, 0x07,
	0x00, 0x00,
}
