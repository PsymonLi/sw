// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: svc_diagnostics.proto

package diagnostics

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/pensando/grpc-gateway/third_party/googleapis/google/api"
import _ "github.com/pensando/sw/venice/utils/apigen/annotations"
import _ "github.com/gogo/protobuf/gogoproto"
import _ "github.com/pensando/sw/api/generated/cluster"
import api "github.com/pensando/sw/api"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// AutoMsgModuleWatchHelper is a wrapper object for watch events for Module objects
type AutoMsgModuleWatchHelper struct {
	Events []*AutoMsgModuleWatchHelper_WatchEvent `protobuf:"bytes,1,rep,name=Events,json=events" json:"events"`
}

func (m *AutoMsgModuleWatchHelper) Reset()         { *m = AutoMsgModuleWatchHelper{} }
func (m *AutoMsgModuleWatchHelper) String() string { return proto.CompactTextString(m) }
func (*AutoMsgModuleWatchHelper) ProtoMessage()    {}
func (*AutoMsgModuleWatchHelper) Descriptor() ([]byte, []int) {
	return fileDescriptorSvcDiagnostics, []int{0}
}

func (m *AutoMsgModuleWatchHelper) GetEvents() []*AutoMsgModuleWatchHelper_WatchEvent {
	if m != nil {
		return m.Events
	}
	return nil
}

type AutoMsgModuleWatchHelper_WatchEvent struct {
	Type   string  `protobuf:"bytes,1,opt,name=Type,proto3" json:"type,omitempty"`
	Object *Module `protobuf:"bytes,2,opt,name=Object" json:"object,omitempty"`
}

func (m *AutoMsgModuleWatchHelper_WatchEvent) Reset()         { *m = AutoMsgModuleWatchHelper_WatchEvent{} }
func (m *AutoMsgModuleWatchHelper_WatchEvent) String() string { return proto.CompactTextString(m) }
func (*AutoMsgModuleWatchHelper_WatchEvent) ProtoMessage()    {}
func (*AutoMsgModuleWatchHelper_WatchEvent) Descriptor() ([]byte, []int) {
	return fileDescriptorSvcDiagnostics, []int{0, 0}
}

func (m *AutoMsgModuleWatchHelper_WatchEvent) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *AutoMsgModuleWatchHelper_WatchEvent) GetObject() *Module {
	if m != nil {
		return m.Object
	}
	return nil
}

// ModuleList is a container object for list of Module objects
type ModuleList struct {
	api.TypeMeta `protobuf:"bytes,2,opt,name=T,json=,inline,embedded=T" json:",inline"`
	api.ListMeta `protobuf:"bytes,3,opt,name=ListMeta,json=list-meta,inline,embedded=ListMeta" json:"list-meta,inline"`
	// List of Module objects
	Items []*Module `protobuf:"bytes,4,rep,name=Items,json=items" json:"items"`
}

func (m *ModuleList) Reset()                    { *m = ModuleList{} }
func (m *ModuleList) String() string            { return proto.CompactTextString(m) }
func (*ModuleList) ProtoMessage()               {}
func (*ModuleList) Descriptor() ([]byte, []int) { return fileDescriptorSvcDiagnostics, []int{1} }

func (m *ModuleList) GetItems() []*Module {
	if m != nil {
		return m.Items
	}
	return nil
}

func init() {
	proto.RegisterType((*AutoMsgModuleWatchHelper)(nil), "diagnostics.AutoMsgModuleWatchHelper")
	proto.RegisterType((*AutoMsgModuleWatchHelper_WatchEvent)(nil), "diagnostics.AutoMsgModuleWatchHelper.WatchEvent")
	proto.RegisterType((*ModuleList)(nil), "diagnostics.ModuleList")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for DiagnosticsV1 service

type DiagnosticsV1Client interface {
	// Create Module object
	AutoAddModule(ctx context.Context, in *Module, opts ...grpc.CallOption) (*Module, error)
	// Delete Module object
	AutoDeleteModule(ctx context.Context, in *Module, opts ...grpc.CallOption) (*Module, error)
	// Get Module object
	AutoGetModule(ctx context.Context, in *Module, opts ...grpc.CallOption) (*Module, error)
	// List Module objects
	AutoListModule(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (*ModuleList, error)
	// Update Module object
	AutoUpdateModule(ctx context.Context, in *Module, opts ...grpc.CallOption) (*Module, error)
	// Watch Module objects. Supports WebSockets or HTTP long poll
	AutoWatchModule(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (DiagnosticsV1_AutoWatchModuleClient, error)
	AutoWatchSvcDiagnosticsV1(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (DiagnosticsV1_AutoWatchSvcDiagnosticsV1Client, error)
	Debug(ctx context.Context, in *DiagnosticsRequest, opts ...grpc.CallOption) (*DiagnosticsResponse, error)
}

type diagnosticsV1Client struct {
	cc *grpc.ClientConn
}

func NewDiagnosticsV1Client(cc *grpc.ClientConn) DiagnosticsV1Client {
	return &diagnosticsV1Client{cc}
}

func (c *diagnosticsV1Client) AutoAddModule(ctx context.Context, in *Module, opts ...grpc.CallOption) (*Module, error) {
	out := new(Module)
	err := grpc.Invoke(ctx, "/diagnostics.DiagnosticsV1/AutoAddModule", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *diagnosticsV1Client) AutoDeleteModule(ctx context.Context, in *Module, opts ...grpc.CallOption) (*Module, error) {
	out := new(Module)
	err := grpc.Invoke(ctx, "/diagnostics.DiagnosticsV1/AutoDeleteModule", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *diagnosticsV1Client) AutoGetModule(ctx context.Context, in *Module, opts ...grpc.CallOption) (*Module, error) {
	out := new(Module)
	err := grpc.Invoke(ctx, "/diagnostics.DiagnosticsV1/AutoGetModule", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *diagnosticsV1Client) AutoListModule(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (*ModuleList, error) {
	out := new(ModuleList)
	err := grpc.Invoke(ctx, "/diagnostics.DiagnosticsV1/AutoListModule", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *diagnosticsV1Client) AutoUpdateModule(ctx context.Context, in *Module, opts ...grpc.CallOption) (*Module, error) {
	out := new(Module)
	err := grpc.Invoke(ctx, "/diagnostics.DiagnosticsV1/AutoUpdateModule", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *diagnosticsV1Client) AutoWatchModule(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (DiagnosticsV1_AutoWatchModuleClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_DiagnosticsV1_serviceDesc.Streams[0], c.cc, "/diagnostics.DiagnosticsV1/AutoWatchModule", opts...)
	if err != nil {
		return nil, err
	}
	x := &diagnosticsV1AutoWatchModuleClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type DiagnosticsV1_AutoWatchModuleClient interface {
	Recv() (*AutoMsgModuleWatchHelper, error)
	grpc.ClientStream
}

type diagnosticsV1AutoWatchModuleClient struct {
	grpc.ClientStream
}

func (x *diagnosticsV1AutoWatchModuleClient) Recv() (*AutoMsgModuleWatchHelper, error) {
	m := new(AutoMsgModuleWatchHelper)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *diagnosticsV1Client) AutoWatchSvcDiagnosticsV1(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (DiagnosticsV1_AutoWatchSvcDiagnosticsV1Client, error) {
	stream, err := grpc.NewClientStream(ctx, &_DiagnosticsV1_serviceDesc.Streams[1], c.cc, "/diagnostics.DiagnosticsV1/AutoWatchSvcDiagnosticsV1", opts...)
	if err != nil {
		return nil, err
	}
	x := &diagnosticsV1AutoWatchSvcDiagnosticsV1Client{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type DiagnosticsV1_AutoWatchSvcDiagnosticsV1Client interface {
	Recv() (*api.WatchEventList, error)
	grpc.ClientStream
}

type diagnosticsV1AutoWatchSvcDiagnosticsV1Client struct {
	grpc.ClientStream
}

func (x *diagnosticsV1AutoWatchSvcDiagnosticsV1Client) Recv() (*api.WatchEventList, error) {
	m := new(api.WatchEventList)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *diagnosticsV1Client) Debug(ctx context.Context, in *DiagnosticsRequest, opts ...grpc.CallOption) (*DiagnosticsResponse, error) {
	out := new(DiagnosticsResponse)
	err := grpc.Invoke(ctx, "/diagnostics.DiagnosticsV1/Debug", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for DiagnosticsV1 service

type DiagnosticsV1Server interface {
	// Create Module object
	AutoAddModule(context.Context, *Module) (*Module, error)
	// Delete Module object
	AutoDeleteModule(context.Context, *Module) (*Module, error)
	// Get Module object
	AutoGetModule(context.Context, *Module) (*Module, error)
	// List Module objects
	AutoListModule(context.Context, *api.ListWatchOptions) (*ModuleList, error)
	// Update Module object
	AutoUpdateModule(context.Context, *Module) (*Module, error)
	// Watch Module objects. Supports WebSockets or HTTP long poll
	AutoWatchModule(*api.ListWatchOptions, DiagnosticsV1_AutoWatchModuleServer) error
	AutoWatchSvcDiagnosticsV1(*api.ListWatchOptions, DiagnosticsV1_AutoWatchSvcDiagnosticsV1Server) error
	Debug(context.Context, *DiagnosticsRequest) (*DiagnosticsResponse, error)
}

func RegisterDiagnosticsV1Server(s *grpc.Server, srv DiagnosticsV1Server) {
	s.RegisterService(&_DiagnosticsV1_serviceDesc, srv)
}

func _DiagnosticsV1_AutoAddModule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Module)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DiagnosticsV1Server).AutoAddModule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/diagnostics.DiagnosticsV1/AutoAddModule",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DiagnosticsV1Server).AutoAddModule(ctx, req.(*Module))
	}
	return interceptor(ctx, in, info, handler)
}

func _DiagnosticsV1_AutoDeleteModule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Module)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DiagnosticsV1Server).AutoDeleteModule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/diagnostics.DiagnosticsV1/AutoDeleteModule",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DiagnosticsV1Server).AutoDeleteModule(ctx, req.(*Module))
	}
	return interceptor(ctx, in, info, handler)
}

func _DiagnosticsV1_AutoGetModule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Module)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DiagnosticsV1Server).AutoGetModule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/diagnostics.DiagnosticsV1/AutoGetModule",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DiagnosticsV1Server).AutoGetModule(ctx, req.(*Module))
	}
	return interceptor(ctx, in, info, handler)
}

func _DiagnosticsV1_AutoListModule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(api.ListWatchOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DiagnosticsV1Server).AutoListModule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/diagnostics.DiagnosticsV1/AutoListModule",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DiagnosticsV1Server).AutoListModule(ctx, req.(*api.ListWatchOptions))
	}
	return interceptor(ctx, in, info, handler)
}

func _DiagnosticsV1_AutoUpdateModule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Module)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DiagnosticsV1Server).AutoUpdateModule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/diagnostics.DiagnosticsV1/AutoUpdateModule",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DiagnosticsV1Server).AutoUpdateModule(ctx, req.(*Module))
	}
	return interceptor(ctx, in, info, handler)
}

func _DiagnosticsV1_AutoWatchModule_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(api.ListWatchOptions)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(DiagnosticsV1Server).AutoWatchModule(m, &diagnosticsV1AutoWatchModuleServer{stream})
}

type DiagnosticsV1_AutoWatchModuleServer interface {
	Send(*AutoMsgModuleWatchHelper) error
	grpc.ServerStream
}

type diagnosticsV1AutoWatchModuleServer struct {
	grpc.ServerStream
}

func (x *diagnosticsV1AutoWatchModuleServer) Send(m *AutoMsgModuleWatchHelper) error {
	return x.ServerStream.SendMsg(m)
}

func _DiagnosticsV1_AutoWatchSvcDiagnosticsV1_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(api.ListWatchOptions)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(DiagnosticsV1Server).AutoWatchSvcDiagnosticsV1(m, &diagnosticsV1AutoWatchSvcDiagnosticsV1Server{stream})
}

type DiagnosticsV1_AutoWatchSvcDiagnosticsV1Server interface {
	Send(*api.WatchEventList) error
	grpc.ServerStream
}

type diagnosticsV1AutoWatchSvcDiagnosticsV1Server struct {
	grpc.ServerStream
}

func (x *diagnosticsV1AutoWatchSvcDiagnosticsV1Server) Send(m *api.WatchEventList) error {
	return x.ServerStream.SendMsg(m)
}

func _DiagnosticsV1_Debug_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DiagnosticsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DiagnosticsV1Server).Debug(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/diagnostics.DiagnosticsV1/Debug",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DiagnosticsV1Server).Debug(ctx, req.(*DiagnosticsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _DiagnosticsV1_serviceDesc = grpc.ServiceDesc{
	ServiceName: "diagnostics.DiagnosticsV1",
	HandlerType: (*DiagnosticsV1Server)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AutoAddModule",
			Handler:    _DiagnosticsV1_AutoAddModule_Handler,
		},
		{
			MethodName: "AutoDeleteModule",
			Handler:    _DiagnosticsV1_AutoDeleteModule_Handler,
		},
		{
			MethodName: "AutoGetModule",
			Handler:    _DiagnosticsV1_AutoGetModule_Handler,
		},
		{
			MethodName: "AutoListModule",
			Handler:    _DiagnosticsV1_AutoListModule_Handler,
		},
		{
			MethodName: "AutoUpdateModule",
			Handler:    _DiagnosticsV1_AutoUpdateModule_Handler,
		},
		{
			MethodName: "Debug",
			Handler:    _DiagnosticsV1_Debug_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "AutoWatchModule",
			Handler:       _DiagnosticsV1_AutoWatchModule_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "AutoWatchSvcDiagnosticsV1",
			Handler:       _DiagnosticsV1_AutoWatchSvcDiagnosticsV1_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "svc_diagnostics.proto",
}

func (m *AutoMsgModuleWatchHelper) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AutoMsgModuleWatchHelper) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Events) > 0 {
		for _, msg := range m.Events {
			dAtA[i] = 0xa
			i++
			i = encodeVarintSvcDiagnostics(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *AutoMsgModuleWatchHelper_WatchEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AutoMsgModuleWatchHelper_WatchEvent) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSvcDiagnostics(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if m.Object != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSvcDiagnostics(dAtA, i, uint64(m.Object.Size()))
		n1, err := m.Object.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	return i, nil
}

func (m *ModuleList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModuleList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x12
	i++
	i = encodeVarintSvcDiagnostics(dAtA, i, uint64(m.TypeMeta.Size()))
	n2, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n2
	dAtA[i] = 0x1a
	i++
	i = encodeVarintSvcDiagnostics(dAtA, i, uint64(m.ListMeta.Size()))
	n3, err := m.ListMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n3
	if len(m.Items) > 0 {
		for _, msg := range m.Items {
			dAtA[i] = 0x22
			i++
			i = encodeVarintSvcDiagnostics(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func encodeVarintSvcDiagnostics(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *AutoMsgModuleWatchHelper) Size() (n int) {
	var l int
	_ = l
	if len(m.Events) > 0 {
		for _, e := range m.Events {
			l = e.Size()
			n += 1 + l + sovSvcDiagnostics(uint64(l))
		}
	}
	return n
}

func (m *AutoMsgModuleWatchHelper_WatchEvent) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovSvcDiagnostics(uint64(l))
	}
	if m.Object != nil {
		l = m.Object.Size()
		n += 1 + l + sovSvcDiagnostics(uint64(l))
	}
	return n
}

func (m *ModuleList) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovSvcDiagnostics(uint64(l))
	l = m.ListMeta.Size()
	n += 1 + l + sovSvcDiagnostics(uint64(l))
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovSvcDiagnostics(uint64(l))
		}
	}
	return n
}

func sovSvcDiagnostics(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozSvcDiagnostics(x uint64) (n int) {
	return sovSvcDiagnostics(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *AutoMsgModuleWatchHelper) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSvcDiagnostics
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AutoMsgModuleWatchHelper: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AutoMsgModuleWatchHelper: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Events", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSvcDiagnostics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSvcDiagnostics
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Events = append(m.Events, &AutoMsgModuleWatchHelper_WatchEvent{})
			if err := m.Events[len(m.Events)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSvcDiagnostics(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSvcDiagnostics
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AutoMsgModuleWatchHelper_WatchEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSvcDiagnostics
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WatchEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WatchEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSvcDiagnostics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSvcDiagnostics
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Object", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSvcDiagnostics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSvcDiagnostics
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Object == nil {
				m.Object = &Module{}
			}
			if err := m.Object.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSvcDiagnostics(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSvcDiagnostics
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModuleList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSvcDiagnostics
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModuleList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModuleList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSvcDiagnostics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSvcDiagnostics
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSvcDiagnostics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSvcDiagnostics
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ListMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSvcDiagnostics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSvcDiagnostics
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &Module{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSvcDiagnostics(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSvcDiagnostics
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipSvcDiagnostics(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowSvcDiagnostics
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSvcDiagnostics
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSvcDiagnostics
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthSvcDiagnostics
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowSvcDiagnostics
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipSvcDiagnostics(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthSvcDiagnostics = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowSvcDiagnostics   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("svc_diagnostics.proto", fileDescriptorSvcDiagnostics) }

var fileDescriptorSvcDiagnostics = []byte{
	// 807 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x55, 0xcf, 0x8f, 0xdb, 0x44,
	0x18, 0xcd, 0xec, 0x8f, 0xb4, 0x9d, 0x74, 0xd3, 0xed, 0xa4, 0xd5, 0xc6, 0x56, 0x15, 0x47, 0x16,
	0x95, 0x56, 0x65, 0x6b, 0xa7, 0x0b, 0x42, 0x90, 0x13, 0x8d, 0xb6, 0x02, 0x24, 0x42, 0xaa, 0xb0,
	0xc0, 0x05, 0x09, 0x39, 0xf6, 0x57, 0xaf, 0x91, 0x33, 0x63, 0x76, 0xc6, 0xa9, 0x56, 0x88, 0x1e,
	0x48, 0x7a, 0xe3, 0x04, 0x37, 0x8e, 0x1c, 0x39, 0xe6, 0x84, 0x38, 0x71, 0xac, 0x38, 0x55, 0xe2,
	0x56, 0x24, 0x0b, 0xad, 0x38, 0x45, 0xfc, 0x11, 0x68, 0xc6, 0xf6, 0xc6, 0x51, 0x92, 0x0a, 0x7a,
	0xf2, 0xf8, 0xcb, 0xf7, 0xde, 0xfb, 0xde, 0x9b, 0x19, 0x07, 0xdf, 0xe4, 0x23, 0xf7, 0x0b, 0x2f,
	0x70, 0x7c, 0xca, 0xb8, 0x08, 0x5c, 0x6e, 0x45, 0xa7, 0x4c, 0x30, 0x52, 0x29, 0x94, 0xf4, 0x5b,
	0x3e, 0x63, 0x7e, 0x08, 0xb6, 0x13, 0x05, 0xb6, 0x43, 0x29, 0x13, 0x8e, 0x08, 0x18, 0xcd, 0x5a,
	0xf5, 0x07, 0x7e, 0x20, 0x4e, 0xe2, 0x81, 0xe5, 0xb2, 0xa1, 0x1d, 0x01, 0xe5, 0x0e, 0xf5, 0x98,
	0xcd, 0x1f, 0xdb, 0x23, 0xa0, 0x81, 0x0b, 0x76, 0x2c, 0x82, 0x90, 0x4b, 0xa8, 0x0f, 0xb4, 0x88,
	0xb6, 0x03, 0xea, 0x86, 0xb1, 0x07, 0x39, 0xcd, 0xdd, 0x02, 0x8d, 0xcf, 0x7c, 0x66, 0xab, 0xf2,
	0x20, 0x7e, 0xa4, 0xde, 0xd4, 0x8b, 0x5a, 0x65, 0xed, 0xd6, 0x1a, 0x55, 0x39, 0xa3, 0xea, 0xe0,
	0xb6, 0x00, 0xea, 0x50, 0x91, 0xf5, 0x5f, 0x1d, 0x32, 0x2f, 0x0e, 0x21, 0x7b, 0xbb, 0xfd, 0x12,
	0xf4, 0x10, 0x84, 0x93, 0xb6, 0x99, 0xff, 0x20, 0x5c, 0xbf, 0x1f, 0x0b, 0xd6, 0xe5, 0x7e, 0x57,
	0xc1, 0x3f, 0x73, 0x84, 0x7b, 0xf2, 0x3e, 0x84, 0x11, 0x9c, 0x92, 0x63, 0x5c, 0x7e, 0x30, 0x02,
	0x2a, 0x78, 0x1d, 0x35, 0x37, 0xf7, 0x2b, 0x87, 0x2d, 0xab, 0x18, 0xe3, 0x3a, 0x98, 0xa5, 0xd6,
	0x0a, 0xd8, 0xc1, 0xb3, 0xc4, 0x28, 0x83, 0xe2, 0xe8, 0x67, 0x4f, 0x3d, 0xc0, 0x78, 0xde, 0x41,
	0x9a, 0x78, 0xeb, 0xf8, 0x2c, 0x82, 0x3a, 0x6a, 0xa2, 0xfd, 0x2b, 0x1d, 0x32, 0x4b, 0x8c, 0xaa,
	0x38, 0x8b, 0xe0, 0x80, 0x0d, 0x03, 0x01, 0xc3, 0x48, 0x9c, 0x91, 0x77, 0x70, 0xb9, 0x37, 0xf8,
	0x12, 0x5c, 0x51, 0xdf, 0x68, 0xa2, 0xfd, 0xca, 0x61, 0x6d, 0x61, 0x8a, 0x54, 0xbe, 0x73, 0x63,
	0x96, 0x18, 0xbb, 0x4c, 0xb5, 0xcd, 0xa1, 0xed, 0x6b, 0x2f, 0x9e, 0x6a, 0x95, 0xc7, 0x52, 0xec,
	0x44, 0x8d, 0x66, 0xfe, 0x89, 0x30, 0x4e, 0x11, 0x1f, 0x06, 0x5c, 0x90, 0xb7, 0x30, 0x3a, 0xce,
	0x58, 0x77, 0x2c, 0x27, 0x0a, 0x2c, 0x39, 0x4a, 0x17, 0x84, 0xd3, 0xa9, 0x3d, 0x4b, 0x8c, 0xd2,
	0xf3, 0xc4, 0x40, 0xb3, 0xc4, 0xb8, 0x74, 0x10, 0xd0, 0x30, 0xa0, 0xd0, 0xcf, 0x17, 0xa4, 0x87,
	0x2f, 0x4b, 0xbc, 0xec, 0xac, 0x6f, 0x16, 0xe0, 0x79, 0xb1, 0x73, 0xab, 0x00, 0xdf, 0x0d, 0x03,
	0x2e, 0xee, 0xca, 0xcc, 0x73, 0x9e, 0xa5, 0x0a, 0x79, 0x13, 0x6f, 0x7f, 0x20, 0x60, 0xc8, 0xeb,
	0x5b, 0x2a, 0xe8, 0x95, 0x16, 0xaf, 0xcc, 0x12, 0x63, 0x5b, 0x3a, 0xe3, 0xfd, 0xf4, 0xd1, 0xae,
	0xbe, 0x78, 0xaa, 0x61, 0xc9, 0x95, 0xba, 0x3b, 0x4c, 0x2e, 0xe1, 0x9d, 0xa3, 0x39, 0xf0, 0xd3,
	0x7b, 0xa4, 0x8b, 0x77, 0xe4, 0x36, 0xdd, 0xf7, 0xbc, 0x94, 0x84, 0xac, 0x62, 0xd6, 0x57, 0x15,
	0x4d, 0x32, 0x9d, 0x68, 0x65, 0xf7, 0x14, 0x1c, 0x01, 0xbf, 0x4c, 0x34, 0xf4, 0xdb, 0x44, 0x2b,
	0x91, 0x87, 0x78, 0x57, 0xd2, 0x1d, 0x41, 0x08, 0x02, 0x5e, 0x8d, 0xd1, 0x53, 0xd8, 0x0b, 0x46,
	0x3f, 0x1d, 0xf0, 0x3d, 0x10, 0xff, 0x9b, 0xee, 0x60, 0x3a, 0xd1, 0x36, 0x7d, 0x10, 0x39, 0xd7,
	0xb7, 0x7f, 0xfc, 0xfd, 0xc3, 0xc6, 0x1e, 0x2e, 0xb5, 0x4b, 0xe4, 0xba, 0x9d, 0xde, 0x05, 0x6e,
	0x7f, 0xdd, 0xb3, 0x3e, 0x72, 0x86, 0xf0, 0x0d, 0x79, 0x84, 0xab, 0x52, 0x48, 0xed, 0x50, 0xaa,
	0x74, 0xf3, 0x62, 0xcb, 0xd4, 0x71, 0xec, 0x45, 0xea, 0xd2, 0xea, 0x7b, 0x2b, 0xb4, 0x64, 0x93,
	0xf9, 0xda, 0x74, 0xa2, 0x6d, 0xc9, 0xb4, 0x17, 0x04, 0xab, 0x4a, 0xf0, 0x72, 0x2e, 0x48, 0x68,
	0x1a, 0xd1, 0x27, 0x91, 0xe7, 0xbc, 0x42, 0x44, 0x2d, 0x19, 0x51, 0xac, 0xb0, 0x0b, 0x2a, 0x75,
	0x5c, 0x6a, 0xa3, 0x3b, 0xfa, 0x0a, 0x5f, 0x4f, 0xf0, 0x35, 0xa9, 0xa7, 0x2c, 0xbc, 0xdc, 0xd8,
	0xed, 0xff, 0x74, 0x7b, 0xcd, 0xd7, 0xa7, 0x13, 0x6d, 0x5b, 0xdd, 0x99, 0x85, 0x09, 0x6e, 0x28,
	0x9f, 0x55, 0x5b, 0xfd, 0x92, 0x8f, 0xd1, 0x42, 0xe4, 0x73, 0xac, 0x5d, 0xe8, 0x7f, 0x3c, 0x72,
	0x17, 0x8f, 0xdf, 0x9a, 0x49, 0x6a, 0xaa, 0x3c, 0xff, 0x08, 0xa8, 0x78, 0xaf, 0x2f, 0xe9, 0xb6,
	0x10, 0xf9, 0x0e, 0xe1, 0xed, 0x23, 0x18, 0xc4, 0x3e, 0x31, 0x16, 0xa6, 0x2f, 0xc8, 0xf4, 0xe1,
	0xab, 0x18, 0xb8, 0xd0, 0x9b, 0xeb, 0x1b, 0x78, 0xc4, 0x28, 0x07, 0xf3, 0xdd, 0xe5, 0x13, 0xfd,
	0xfb, 0x44, 0x2b, 0xa7, 0x11, 0x28, 0x93, 0x0d, 0x15, 0xb3, 0xb9, 0xb7, 0x14, 0xb3, 0xad, 0x86,
	0xd0, 0x9f, 0x7c, 0x3f, 0xd6, 0x36, 0x46, 0xf7, 0x7e, 0x1c, 0x6b, 0xc5, 0x7f, 0x8f, 0x9f, 0xc6,
	0x39, 0xc9, 0xcf, 0x63, 0xcd, 0xc0, 0xd9, 0x9a, 0xc8, 0xb3, 0x49, 0x36, 0xa3, 0x58, 0x10, 0x75,
	0x6a, 0x48, 0x6a, 0xee, 0xd7, 0xb1, 0xf6, 0x36, 0xc9, 0x5a, 0xf4, 0xd4, 0x9b, 0x49, 0x96, 0xed,
	0xdc, 0xa9, 0xad, 0x70, 0xd0, 0xb9, 0xfa, 0xec, 0xbc, 0x81, 0x9e, 0x9f, 0x37, 0xd0, 0x5f, 0xe7,
	0x0d, 0xf4, 0x10, 0x0d, 0xca, 0xea, 0x23, 0xfe, 0xc6, 0xbf, 0x01, 0x00, 0x00, 0xff, 0xff, 0x5d,
	0x9d, 0xe7, 0x1f, 0xe3, 0x06, 0x00, 0x00,
}
