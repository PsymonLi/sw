// Code generated by protoc-gen-grpc-pensando DO NOT EDIT.

package grpcclient

import (
	"context"
	"errors"
	oldlog "log"
	"net/http"

	"github.com/go-kit/kit/endpoint"
	grpctransport "github.com/go-kit/kit/transport/grpc"
	"google.golang.org/grpc"

	api "github.com/pensando/sw/api"
	diagnostics "github.com/pensando/sw/api/generated/diagnostics"
	"github.com/pensando/sw/api/interfaces"
	listerwatcher "github.com/pensando/sw/api/listerwatcher"
	"github.com/pensando/sw/venice/utils/kvstore"
	"github.com/pensando/sw/venice/utils/log"
	"github.com/pensando/sw/venice/utils/trace"
)

// Dummy vars to suppress import errors
var _ api.TypeMeta
var _ listerwatcher.WatcherClient
var _ kvstore.Interface

// NewDiagnosticsV1 sets up a new client for DiagnosticsV1
func NewDiagnosticsV1(conn *grpc.ClientConn, logger log.Logger) diagnostics.ServiceDiagnosticsV1Client {

	var lAutoAddModuleEndpoint endpoint.Endpoint
	{
		lAutoAddModuleEndpoint = grpctransport.NewClient(
			conn,
			"diagnostics.DiagnosticsV1",
			"AutoAddModule",
			diagnostics.EncodeGrpcReqModule,
			diagnostics.DecodeGrpcRespModule,
			&diagnostics.Module{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoAddModuleEndpoint = trace.ClientEndPoint("DiagnosticsV1:AutoAddModule")(lAutoAddModuleEndpoint)
	}
	var lAutoDeleteModuleEndpoint endpoint.Endpoint
	{
		lAutoDeleteModuleEndpoint = grpctransport.NewClient(
			conn,
			"diagnostics.DiagnosticsV1",
			"AutoDeleteModule",
			diagnostics.EncodeGrpcReqModule,
			diagnostics.DecodeGrpcRespModule,
			&diagnostics.Module{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoDeleteModuleEndpoint = trace.ClientEndPoint("DiagnosticsV1:AutoDeleteModule")(lAutoDeleteModuleEndpoint)
	}
	var lAutoGetModuleEndpoint endpoint.Endpoint
	{
		lAutoGetModuleEndpoint = grpctransport.NewClient(
			conn,
			"diagnostics.DiagnosticsV1",
			"AutoGetModule",
			diagnostics.EncodeGrpcReqModule,
			diagnostics.DecodeGrpcRespModule,
			&diagnostics.Module{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoGetModuleEndpoint = trace.ClientEndPoint("DiagnosticsV1:AutoGetModule")(lAutoGetModuleEndpoint)
	}
	var lAutoLabelModuleEndpoint endpoint.Endpoint
	{
		lAutoLabelModuleEndpoint = grpctransport.NewClient(
			conn,
			"diagnostics.DiagnosticsV1",
			"AutoLabelModule",
			diagnostics.EncodeGrpcReqLabel,
			diagnostics.DecodeGrpcRespModule,
			&diagnostics.Module{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoLabelModuleEndpoint = trace.ClientEndPoint("DiagnosticsV1:AutoLabelModule")(lAutoLabelModuleEndpoint)
	}
	var lAutoListModuleEndpoint endpoint.Endpoint
	{
		lAutoListModuleEndpoint = grpctransport.NewClient(
			conn,
			"diagnostics.DiagnosticsV1",
			"AutoListModule",
			diagnostics.EncodeGrpcReqListWatchOptions,
			diagnostics.DecodeGrpcRespModuleList,
			&diagnostics.ModuleList{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoListModuleEndpoint = trace.ClientEndPoint("DiagnosticsV1:AutoListModule")(lAutoListModuleEndpoint)
	}
	var lAutoUpdateModuleEndpoint endpoint.Endpoint
	{
		lAutoUpdateModuleEndpoint = grpctransport.NewClient(
			conn,
			"diagnostics.DiagnosticsV1",
			"AutoUpdateModule",
			diagnostics.EncodeGrpcReqModule,
			diagnostics.DecodeGrpcRespModule,
			&diagnostics.Module{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoUpdateModuleEndpoint = trace.ClientEndPoint("DiagnosticsV1:AutoUpdateModule")(lAutoUpdateModuleEndpoint)
	}
	var lDebugEndpoint endpoint.Endpoint
	{
		lDebugEndpoint = grpctransport.NewClient(
			conn,
			"diagnostics.DiagnosticsV1",
			"Debug",
			diagnostics.EncodeGrpcReqDiagnosticsRequest,
			diagnostics.DecodeGrpcRespDiagnosticsResponse,
			&diagnostics.DiagnosticsResponse{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lDebugEndpoint = trace.ClientEndPoint("DiagnosticsV1:Debug")(lDebugEndpoint)
	}
	return diagnostics.EndpointsDiagnosticsV1Client{
		Client: diagnostics.NewDiagnosticsV1Client(conn),

		AutoAddModuleEndpoint:    lAutoAddModuleEndpoint,
		AutoDeleteModuleEndpoint: lAutoDeleteModuleEndpoint,
		AutoGetModuleEndpoint:    lAutoGetModuleEndpoint,
		AutoLabelModuleEndpoint:  lAutoLabelModuleEndpoint,
		AutoListModuleEndpoint:   lAutoListModuleEndpoint,
		AutoUpdateModuleEndpoint: lAutoUpdateModuleEndpoint,
		DebugEndpoint:            lDebugEndpoint,
	}
}

// NewDiagnosticsV1Backend creates an instrumented client with middleware
func NewDiagnosticsV1Backend(conn *grpc.ClientConn, logger log.Logger) diagnostics.ServiceDiagnosticsV1Client {
	cl := NewDiagnosticsV1(conn, logger)
	cl = diagnostics.LoggingDiagnosticsV1MiddlewareClient(logger)(cl)
	return cl
}

type grpcObjDiagnosticsV1Module struct {
	logger log.Logger
	client diagnostics.ServiceDiagnosticsV1Client
}

func (a *grpcObjDiagnosticsV1Module) Create(ctx context.Context, in *diagnostics.Module) (*diagnostics.Module, error) {
	a.logger.DebugLog("msg", "received call", "object", "Module", "oper", "create")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoAddModule(nctx, in)
}

func (a *grpcObjDiagnosticsV1Module) Update(ctx context.Context, in *diagnostics.Module) (*diagnostics.Module, error) {
	a.logger.DebugLog("msg", "received call", "object", "Module", "oper", "update")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoUpdateModule(nctx, in)
}

func (a *grpcObjDiagnosticsV1Module) UpdateStatus(ctx context.Context, in *diagnostics.Module) (*diagnostics.Module, error) {
	a.logger.DebugLog("msg", "received call", "object", "Module", "oper", "update")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	nctx = addStatusUpd(nctx)
	return a.client.AutoUpdateModule(nctx, in)
}

func (a *grpcObjDiagnosticsV1Module) Label(ctx context.Context, in *api.Label) (*diagnostics.Module, error) {
	a.logger.DebugLog("msg", "received call", "object", "Module", "oper", "label")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoLabelModule(nctx, in)
}

func (a *grpcObjDiagnosticsV1Module) Get(ctx context.Context, objMeta *api.ObjectMeta) (*diagnostics.Module, error) {
	a.logger.DebugLog("msg", "received call", "object", "Module", "oper", "get")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := diagnostics.Module{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoGetModule(nctx, &in)
}

func (a *grpcObjDiagnosticsV1Module) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*diagnostics.Module, error) {
	a.logger.DebugLog("msg", "received call", "object", "Module", "oper", "delete")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := diagnostics.Module{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoDeleteModule(nctx, &in)
}

func (a *grpcObjDiagnosticsV1Module) List(ctx context.Context, options *api.ListWatchOptions) ([]*diagnostics.Module, error) {
	a.logger.DebugLog("msg", "received call", "object", "Module", "oper", "list")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	r, err := a.client.AutoListModule(nctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *grpcObjDiagnosticsV1Module) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	a.logger.DebugLog("msg", "received call", "object", "Module", "oper", "WatchOper")
	nctx := addVersion(ctx, "v1")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	stream, err := a.client.AutoWatchModule(nctx, options)
	if err != nil {
		return nil, err
	}
	wstream := stream.(diagnostics.DiagnosticsV1_AutoWatchModuleClient)
	bridgefn := func(lw *listerwatcher.WatcherClient) {
		for {
			r, err := wstream.Recv()
			if err != nil {
				a.logger.ErrorLog("msg", "error on receive", "err", err)
				close(lw.OutCh)
				return
			}
			for _, e := range r.Events {
				ev := kvstore.WatchEvent{
					Type:   kvstore.WatchEventType(e.Type),
					Object: e.Object,
				}
				select {
				case lw.OutCh <- &ev:
				case <-wstream.Context().Done():
					close(lw.OutCh)
					return
				}
			}
		}
	}
	lw := listerwatcher.NewWatcherClient(wstream, bridgefn)
	lw.Run()
	return lw, nil
}

func (a *grpcObjDiagnosticsV1Module) Debug(ctx context.Context, in *diagnostics.DiagnosticsRequest) (*diagnostics.DiagnosticsResponse, error) {
	a.logger.DebugLog("msg", "received call", "object", "{Debug DiagnosticsRequest DiagnosticsResponse}", "oper", "Debug")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.Debug(nctx, in)
}

func (a *grpcObjDiagnosticsV1Module) Allowed(oper apiintf.APIOperType) bool {
	return true
}

type restObjDiagnosticsV1Module struct {
	endpoints diagnostics.EndpointsDiagnosticsV1RestClient
	instance  string
}

func (a *restObjDiagnosticsV1Module) Create(ctx context.Context, in *diagnostics.Module) (*diagnostics.Module, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoAddModule(ctx, in)
}

func (a *restObjDiagnosticsV1Module) Update(ctx context.Context, in *diagnostics.Module) (*diagnostics.Module, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoUpdateModule(ctx, in)
}

func (a *restObjDiagnosticsV1Module) UpdateStatus(ctx context.Context, in *diagnostics.Module) (*diagnostics.Module, error) {
	return nil, errors.New("not supported for REST")
}

func (a *restObjDiagnosticsV1Module) Label(ctx context.Context, in *api.Label) (*diagnostics.Module, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoLabelModule(ctx, in)
}

func (a *restObjDiagnosticsV1Module) Get(ctx context.Context, objMeta *api.ObjectMeta) (*diagnostics.Module, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := diagnostics.Module{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoGetModule(ctx, &in)
}

func (a *restObjDiagnosticsV1Module) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*diagnostics.Module, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := diagnostics.Module{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoDeleteModule(ctx, &in)
}

func (a *restObjDiagnosticsV1Module) List(ctx context.Context, options *api.ListWatchOptions) ([]*diagnostics.Module, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}

	r, err := a.endpoints.AutoListModule(ctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *restObjDiagnosticsV1Module) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoWatchModule(ctx, options)
}

func (a *restObjDiagnosticsV1Module) Allowed(oper apiintf.APIOperType) bool {
	switch oper {
	case apiintf.CreateOper:
		return false
	case apiintf.UpdateOper:
		return true
	case apiintf.GetOper:
		return true
	case apiintf.DeleteOper:
		return false
	case apiintf.ListOper:
		return true
	case apiintf.WatchOper:
		return true
	default:
		return false
	}
}

func (a *restObjDiagnosticsV1Module) Debug(ctx context.Context, in *diagnostics.DiagnosticsRequest) (*diagnostics.DiagnosticsResponse, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.DebugModule(ctx, in)
}

type crudClientDiagnosticsV1 struct {
	logger log.Logger
	client diagnostics.ServiceDiagnosticsV1Client

	grpcModule diagnostics.DiagnosticsV1ModuleInterface
}

// NewGrpcCrudClientDiagnosticsV1 creates a GRPC client for the service
func NewGrpcCrudClientDiagnosticsV1(conn *grpc.ClientConn, logger log.Logger) diagnostics.DiagnosticsV1Interface {
	client := NewDiagnosticsV1Backend(conn, logger)
	return &crudClientDiagnosticsV1{
		logger: logger,
		client: client,

		grpcModule: &grpcObjDiagnosticsV1Module{client: client, logger: logger},
	}
}

func (a *crudClientDiagnosticsV1) Module() diagnostics.DiagnosticsV1ModuleInterface {
	return a.grpcModule
}

func (a *crudClientDiagnosticsV1) Watch(ctx context.Context, options *api.AggWatchOptions) (kvstore.Watcher, error) {
	a.logger.DebugLog("msg", "received call", "object", "DiagnosticsV1", "oper", "WatchOper")
	nctx := addVersion(ctx, "v1")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	stream, err := a.client.AutoWatchSvcDiagnosticsV1(nctx, options)
	if err != nil {
		return nil, err
	}
	wstream := stream.(diagnostics.DiagnosticsV1_AutoWatchSvcDiagnosticsV1Client)
	bridgefn := func(lw *listerwatcher.WatcherClient) {
		for {
			r, err := wstream.Recv()
			if err != nil {
				a.logger.ErrorLog("msg", "error on receive", "err", err)
				close(lw.OutCh)
				return
			}
			for _, e := range r.Events {
				ev := kvstore.WatchEvent{Type: kvstore.WatchEventType(e.Type)}
				switch e.Type {
				case string(kvstore.Created), string(kvstore.Updated), string(kvstore.Deleted):
					robj, err := listerwatcher.GetObject(e)
					if err != nil {
						a.logger.ErrorLog("msg", "error on receive unmarshall", "err", err)
						close(lw.OutCh)
						return
					}
					ev.Object = robj
				case string(kvstore.WatcherControl):
					ev.Control = &kvstore.WatchControl{
						Code:    e.Control.Code,
						Message: e.Control.Message,
					}
				}
				select {
				case lw.OutCh <- &ev:
				case <-wstream.Context().Done():
					close(lw.OutCh)
					return
				}
			}
		}
	}
	lw := listerwatcher.NewWatcherClient(wstream, bridgefn)
	lw.Run()
	return lw, nil
}

type crudRestClientDiagnosticsV1 struct {
	restModule diagnostics.DiagnosticsV1ModuleInterface
}

// NewRestCrudClientDiagnosticsV1 creates a REST client for the service.
func NewRestCrudClientDiagnosticsV1(url string, httpClient *http.Client) diagnostics.DiagnosticsV1Interface {
	endpoints, err := diagnostics.MakeDiagnosticsV1RestClientEndpoints(url, httpClient)
	if err != nil {
		oldlog.Fatal("failed to create client")
	}
	return &crudRestClientDiagnosticsV1{

		restModule: &restObjDiagnosticsV1Module{endpoints: endpoints, instance: url},
	}
}

// NewStagedRestCrudClientDiagnosticsV1 creates a REST client for the service.
func NewStagedRestCrudClientDiagnosticsV1(url string, id string, httpClient *http.Client) diagnostics.DiagnosticsV1Interface {
	endpoints, err := diagnostics.MakeDiagnosticsV1StagedRestClientEndpoints(url, id, httpClient)
	if err != nil {
		oldlog.Fatal("failed to create client")
	}
	return &crudRestClientDiagnosticsV1{

		restModule: &restObjDiagnosticsV1Module{endpoints: endpoints, instance: url},
	}
}

func (a *crudRestClientDiagnosticsV1) Module() diagnostics.DiagnosticsV1ModuleInterface {
	return a.restModule
}

func (a *crudRestClientDiagnosticsV1) Watch(ctx context.Context, options *api.AggWatchOptions) (kvstore.Watcher, error) {
	return nil, errors.New("method unimplemented")
}
