// Code generated by protoc-gen-grpc-pensando DO NOT EDIT.

package grpcclient

import (
	"context"
	"errors"
	oldlog "log"

	"github.com/go-kit/kit/endpoint"
	"github.com/go-kit/kit/tracing/opentracing"
	grpctransport "github.com/go-kit/kit/transport/grpc"
	stdopentracing "github.com/opentracing/opentracing-go"
	"google.golang.org/grpc"
	"google.golang.org/grpc/metadata"

	api "github.com/pensando/sw/api"
	cmd "github.com/pensando/sw/api/generated/cmd"
	listerwatcher "github.com/pensando/sw/api/listerwatcher"
	apiserver "github.com/pensando/sw/apiserver"
	"github.com/pensando/sw/utils/kvstore"
	"github.com/pensando/sw/utils/log"
)

func dummyBefore(ctx context.Context, md *metadata.MD) context.Context {
	xmd, ok := metadata.FromContext(ctx)
	if ok {
		cmd := metadata.Join(*md, xmd)
		*md = cmd
	}
	return ctx
}

// Dummy vars to suppress import errors
var _ api.TypeMeta
var _ listerwatcher.WatcherClient
var _ kvstore.Interface

func addVersion(ctx context.Context, version string) context.Context {
	pairs := []string{apiserver.RequestParamVersion, version}
	inmd, ok := metadata.FromContext(ctx)
	var outmd metadata.MD
	if ok {
		outmd = metadata.Join(inmd, metadata.Pairs(pairs...))
	} else {
		outmd = metadata.Pairs(pairs...)
	}
	return metadata.NewContext(ctx, outmd)
}

// NewCmdV1 sets up a new client for CmdV1
func NewCmdV1(conn *grpc.ClientConn, logger log.Logger) cmd.ServiceCmdV1Client {

	var lAutoAddNodeEndpoint endpoint.Endpoint
	{
		lAutoAddNodeEndpoint = grpctransport.NewClient(
			conn,
			"cmd.CmdV1",
			"AutoAddNode",
			cmd.EncodeGrpcReqNode,
			cmd.DecodeGrpcRespNode,
			&cmd.Node{},
			grpctransport.ClientBefore(opentracing.ToGRPCRequest(stdopentracing.GlobalTracer(), logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoAddNodeEndpoint = opentracing.TraceClient(stdopentracing.GlobalTracer(), "CmdV1:AutoAddNode")(lAutoAddNodeEndpoint)
	}
	var lAutoUpdateNodeEndpoint endpoint.Endpoint
	{
		lAutoUpdateNodeEndpoint = grpctransport.NewClient(
			conn,
			"cmd.CmdV1",
			"AutoUpdateNode",
			cmd.EncodeGrpcReqNode,
			cmd.DecodeGrpcRespNode,
			&cmd.Node{},
			grpctransport.ClientBefore(opentracing.ToGRPCRequest(stdopentracing.GlobalTracer(), logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoUpdateNodeEndpoint = opentracing.TraceClient(stdopentracing.GlobalTracer(), "CmdV1:AutoUpdateNode")(lAutoUpdateNodeEndpoint)
	}
	var lAutoGetNodeEndpoint endpoint.Endpoint
	{
		lAutoGetNodeEndpoint = grpctransport.NewClient(
			conn,
			"cmd.CmdV1",
			"AutoGetNode",
			cmd.EncodeGrpcReqNode,
			cmd.DecodeGrpcRespNode,
			&cmd.Node{},
			grpctransport.ClientBefore(opentracing.ToGRPCRequest(stdopentracing.GlobalTracer(), logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoGetNodeEndpoint = opentracing.TraceClient(stdopentracing.GlobalTracer(), "CmdV1:AutoGetNode")(lAutoGetNodeEndpoint)
	}
	var lAutoDeleteNodeEndpoint endpoint.Endpoint
	{
		lAutoDeleteNodeEndpoint = grpctransport.NewClient(
			conn,
			"cmd.CmdV1",
			"AutoDeleteNode",
			cmd.EncodeGrpcReqNode,
			cmd.DecodeGrpcRespNode,
			&cmd.Node{},
			grpctransport.ClientBefore(opentracing.ToGRPCRequest(stdopentracing.GlobalTracer(), logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoDeleteNodeEndpoint = opentracing.TraceClient(stdopentracing.GlobalTracer(), "CmdV1:AutoDeleteNode")(lAutoDeleteNodeEndpoint)
	}
	var lAutoListNodeEndpoint endpoint.Endpoint
	{
		lAutoListNodeEndpoint = grpctransport.NewClient(
			conn,
			"cmd.CmdV1",
			"AutoListNode",
			cmd.EncodeGrpcReqListWatchOptions,
			cmd.DecodeGrpcRespAutoMsgNodeListHelper,
			&cmd.AutoMsgNodeListHelper{},
			grpctransport.ClientBefore(opentracing.ToGRPCRequest(stdopentracing.GlobalTracer(), logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoListNodeEndpoint = opentracing.TraceClient(stdopentracing.GlobalTracer(), "CmdV1:AutoListNode")(lAutoListNodeEndpoint)
	}
	var lAutoAddClusterEndpoint endpoint.Endpoint
	{
		lAutoAddClusterEndpoint = grpctransport.NewClient(
			conn,
			"cmd.CmdV1",
			"AutoAddCluster",
			cmd.EncodeGrpcReqCluster,
			cmd.DecodeGrpcRespCluster,
			&cmd.Cluster{},
			grpctransport.ClientBefore(opentracing.ToGRPCRequest(stdopentracing.GlobalTracer(), logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoAddClusterEndpoint = opentracing.TraceClient(stdopentracing.GlobalTracer(), "CmdV1:AutoAddCluster")(lAutoAddClusterEndpoint)
	}
	var lAutoUpdateClusterEndpoint endpoint.Endpoint
	{
		lAutoUpdateClusterEndpoint = grpctransport.NewClient(
			conn,
			"cmd.CmdV1",
			"AutoUpdateCluster",
			cmd.EncodeGrpcReqCluster,
			cmd.DecodeGrpcRespCluster,
			&cmd.Cluster{},
			grpctransport.ClientBefore(opentracing.ToGRPCRequest(stdopentracing.GlobalTracer(), logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoUpdateClusterEndpoint = opentracing.TraceClient(stdopentracing.GlobalTracer(), "CmdV1:AutoUpdateCluster")(lAutoUpdateClusterEndpoint)
	}
	var lAutoGetClusterEndpoint endpoint.Endpoint
	{
		lAutoGetClusterEndpoint = grpctransport.NewClient(
			conn,
			"cmd.CmdV1",
			"AutoGetCluster",
			cmd.EncodeGrpcReqCluster,
			cmd.DecodeGrpcRespCluster,
			&cmd.Cluster{},
			grpctransport.ClientBefore(opentracing.ToGRPCRequest(stdopentracing.GlobalTracer(), logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoGetClusterEndpoint = opentracing.TraceClient(stdopentracing.GlobalTracer(), "CmdV1:AutoGetCluster")(lAutoGetClusterEndpoint)
	}
	var lAutoDeleteClusterEndpoint endpoint.Endpoint
	{
		lAutoDeleteClusterEndpoint = grpctransport.NewClient(
			conn,
			"cmd.CmdV1",
			"AutoDeleteCluster",
			cmd.EncodeGrpcReqCluster,
			cmd.DecodeGrpcRespCluster,
			&cmd.Cluster{},
			grpctransport.ClientBefore(opentracing.ToGRPCRequest(stdopentracing.GlobalTracer(), logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoDeleteClusterEndpoint = opentracing.TraceClient(stdopentracing.GlobalTracer(), "CmdV1:AutoDeleteCluster")(lAutoDeleteClusterEndpoint)
	}
	var lAutoListClusterEndpoint endpoint.Endpoint
	{
		lAutoListClusterEndpoint = grpctransport.NewClient(
			conn,
			"cmd.CmdV1",
			"AutoListCluster",
			cmd.EncodeGrpcReqListWatchOptions,
			cmd.DecodeGrpcRespAutoMsgClusterListHelper,
			&cmd.AutoMsgClusterListHelper{},
			grpctransport.ClientBefore(opentracing.ToGRPCRequest(stdopentracing.GlobalTracer(), logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoListClusterEndpoint = opentracing.TraceClient(stdopentracing.GlobalTracer(), "CmdV1:AutoListCluster")(lAutoListClusterEndpoint)
	}
	return cmd.EndpointsCmdV1Client{
		Client: cmd.NewCmdV1Client(conn),

		AutoAddNodeEndpoint:       lAutoAddNodeEndpoint,
		AutoUpdateNodeEndpoint:    lAutoUpdateNodeEndpoint,
		AutoGetNodeEndpoint:       lAutoGetNodeEndpoint,
		AutoDeleteNodeEndpoint:    lAutoDeleteNodeEndpoint,
		AutoListNodeEndpoint:      lAutoListNodeEndpoint,
		AutoAddClusterEndpoint:    lAutoAddClusterEndpoint,
		AutoUpdateClusterEndpoint: lAutoUpdateClusterEndpoint,
		AutoGetClusterEndpoint:    lAutoGetClusterEndpoint,
		AutoDeleteClusterEndpoint: lAutoDeleteClusterEndpoint,
		AutoListClusterEndpoint:   lAutoListClusterEndpoint,
	}
}

// NewCmdV1Backend creates an instrumented client with middleware
func NewCmdV1Backend(conn *grpc.ClientConn, logger log.Logger) cmd.ServiceCmdV1Client {
	cl := NewCmdV1(conn, logger)
	cl = cmd.LoggingCmdV1MiddlewareClient(logger)(cl)
	return cl
}

type grpcObjCmdV1Node struct {
	logger log.Logger
	client cmd.ServiceCmdV1Client
}

func (a *grpcObjCmdV1Node) Create(ctx context.Context, in *cmd.Node) (*cmd.Node, error) {
	a.logger.DebugLog("msg", "recieved call", "object", "Node", "oper", "create")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoAddNode(nctx, in)
}

func (a *grpcObjCmdV1Node) Update(ctx context.Context, in *cmd.Node) (*cmd.Node, error) {
	a.logger.DebugLog("msg", "received call", "object", "Node", "oper", "update")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoUpdateNode(nctx, in)
}

func (a *grpcObjCmdV1Node) Get(ctx context.Context, objMeta *api.ObjectMeta) (*cmd.Node, error) {
	a.logger.DebugLog("msg", "received call", "object", "Node", "oper", "get")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := cmd.Node{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoGetNode(nctx, &in)
}

func (a *grpcObjCmdV1Node) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*cmd.Node, error) {
	a.logger.DebugLog("msg", "received call", "object", "Node", "oper", "delete")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := cmd.Node{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoDeleteNode(nctx, &in)
}

func (a *grpcObjCmdV1Node) List(ctx context.Context, options *api.ListWatchOptions) ([]*cmd.Node, error) {
	a.logger.DebugLog("msg", "received call", "object", "Node", "oper", "list")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	r, err := a.client.AutoListNode(nctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *grpcObjCmdV1Node) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	a.logger.DebugLog("msg", "received call", "object", "Node", "oper", "WatchOper")
	nctx := addVersion(ctx, "v1")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	stream, err := a.client.AutoWatchNode(nctx, options)
	if err != nil {
		return nil, err
	}
	wstream := stream.(cmd.CmdV1_AutoWatchNodeClient)
	bridgefn := func(lw *listerwatcher.WatcherClient) {
		for {
			r, err := wstream.Recv()
			if err != nil {
				a.logger.ErrorLog("msg", "error on recieve", "error", err)
				close(lw.OutCh)
				return
			}
			ev := kvstore.WatchEvent{
				Type:   kvstore.WatchEventType(r.Type),
				Object: r.Object,
			}
			lw.OutCh <- &ev
		}
	}
	lw := listerwatcher.NewWatcherClient(wstream, bridgefn)
	lw.Run()
	return lw, nil
}

func (a *grpcObjCmdV1Node) Allowed(oper apiserver.APIOperType) bool {
	return true
}

type restObjCmdV1Node struct {
	endpoints cmd.EndpointsCmdV1RestClient
	instance  string
}

func (a *restObjCmdV1Node) Create(ctx context.Context, in *cmd.Node) (*cmd.Node, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoAddNode(ctx, in)
}

func (a *restObjCmdV1Node) Update(ctx context.Context, in *cmd.Node) (*cmd.Node, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoUpdateNode(ctx, in)
}

func (a *restObjCmdV1Node) Get(ctx context.Context, objMeta *api.ObjectMeta) (*cmd.Node, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := cmd.Node{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoGetNode(ctx, &in)
}

func (a *restObjCmdV1Node) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*cmd.Node, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := cmd.Node{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoDeleteNode(ctx, &in)
}

func (a *restObjCmdV1Node) List(ctx context.Context, options *api.ListWatchOptions) ([]*cmd.Node, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}
	r, err := a.endpoints.AutoListNode(ctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *restObjCmdV1Node) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	return nil, errors.New("not allowed")
}

func (a *restObjCmdV1Node) Allowed(oper apiserver.APIOperType) bool {
	switch oper {
	case apiserver.CreateOper:
		return true
	case apiserver.UpdateOper:
		return true
	case apiserver.GetOper:
		return true
	case apiserver.DeleteOper:
		return true
	case apiserver.ListOper:
		return true
	case apiserver.WatchOper:
		return false
	default:
		return false
	}
}

type grpcObjCmdV1Cluster struct {
	logger log.Logger
	client cmd.ServiceCmdV1Client
}

func (a *grpcObjCmdV1Cluster) Create(ctx context.Context, in *cmd.Cluster) (*cmd.Cluster, error) {
	a.logger.DebugLog("msg", "recieved call", "object", "Cluster", "oper", "create")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoAddCluster(nctx, in)
}

func (a *grpcObjCmdV1Cluster) Update(ctx context.Context, in *cmd.Cluster) (*cmd.Cluster, error) {
	a.logger.DebugLog("msg", "received call", "object", "Cluster", "oper", "update")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoUpdateCluster(nctx, in)
}

func (a *grpcObjCmdV1Cluster) Get(ctx context.Context, objMeta *api.ObjectMeta) (*cmd.Cluster, error) {
	a.logger.DebugLog("msg", "received call", "object", "Cluster", "oper", "get")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := cmd.Cluster{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoGetCluster(nctx, &in)
}

func (a *grpcObjCmdV1Cluster) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*cmd.Cluster, error) {
	a.logger.DebugLog("msg", "received call", "object", "Cluster", "oper", "delete")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := cmd.Cluster{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoDeleteCluster(nctx, &in)
}

func (a *grpcObjCmdV1Cluster) List(ctx context.Context, options *api.ListWatchOptions) ([]*cmd.Cluster, error) {
	a.logger.DebugLog("msg", "received call", "object", "Cluster", "oper", "list")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	r, err := a.client.AutoListCluster(nctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *grpcObjCmdV1Cluster) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	a.logger.DebugLog("msg", "received call", "object", "Cluster", "oper", "WatchOper")
	nctx := addVersion(ctx, "v1")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	stream, err := a.client.AutoWatchCluster(nctx, options)
	if err != nil {
		return nil, err
	}
	wstream := stream.(cmd.CmdV1_AutoWatchClusterClient)
	bridgefn := func(lw *listerwatcher.WatcherClient) {
		for {
			r, err := wstream.Recv()
			if err != nil {
				a.logger.ErrorLog("msg", "error on recieve", "error", err)
				close(lw.OutCh)
				return
			}
			ev := kvstore.WatchEvent{
				Type:   kvstore.WatchEventType(r.Type),
				Object: r.Object,
			}
			lw.OutCh <- &ev
		}
	}
	lw := listerwatcher.NewWatcherClient(wstream, bridgefn)
	lw.Run()
	return lw, nil
}

func (a *grpcObjCmdV1Cluster) Allowed(oper apiserver.APIOperType) bool {
	return true
}

type restObjCmdV1Cluster struct {
	endpoints cmd.EndpointsCmdV1RestClient
	instance  string
}

func (a *restObjCmdV1Cluster) Create(ctx context.Context, in *cmd.Cluster) (*cmd.Cluster, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoAddCluster(ctx, in)
}

func (a *restObjCmdV1Cluster) Update(ctx context.Context, in *cmd.Cluster) (*cmd.Cluster, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoUpdateCluster(ctx, in)
}

func (a *restObjCmdV1Cluster) Get(ctx context.Context, objMeta *api.ObjectMeta) (*cmd.Cluster, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := cmd.Cluster{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoGetCluster(ctx, &in)
}

func (a *restObjCmdV1Cluster) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*cmd.Cluster, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := cmd.Cluster{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoDeleteCluster(ctx, &in)
}

func (a *restObjCmdV1Cluster) List(ctx context.Context, options *api.ListWatchOptions) ([]*cmd.Cluster, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}
	r, err := a.endpoints.AutoListCluster(ctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *restObjCmdV1Cluster) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	return nil, errors.New("not allowed")
}

func (a *restObjCmdV1Cluster) Allowed(oper apiserver.APIOperType) bool {
	switch oper {
	case apiserver.CreateOper:
		return true
	case apiserver.UpdateOper:
		return true
	case apiserver.GetOper:
		return true
	case apiserver.DeleteOper:
		return true
	case apiserver.ListOper:
		return true
	case apiserver.WatchOper:
		return false
	default:
		return false
	}
}

type crudClientCmdV1 struct {
	grpcNode    cmd.NodeInterface
	grpcCluster cmd.ClusterInterface
}

// NewGrpcCrudClientCmdV1 creates a GRPC client for the service
func NewGrpcCrudClientCmdV1(conn *grpc.ClientConn, logger log.Logger) cmd.CmdV1Interface {
	client := NewCmdV1Backend(conn, logger)
	return &crudClientCmdV1{

		grpcNode:    &grpcObjCmdV1Node{client: client, logger: logger},
		grpcCluster: &grpcObjCmdV1Cluster{client: client, logger: logger},
	}
}

func (a *crudClientCmdV1) Node() cmd.NodeInterface {
	return a.grpcNode
}

func (a *crudClientCmdV1) Cluster() cmd.ClusterInterface {
	return a.grpcCluster
}

type crudRestClientCmdV1 struct {
	restNode    cmd.NodeInterface
	restCluster cmd.ClusterInterface
}

// NewRestCrudClientCmdV1 creates a REST client for the service.
func NewRestCrudClientCmdV1(url string) cmd.CmdV1Interface {
	endpoints, err := cmd.MakeCmdV1RestClientEndpoints(url)
	if err != nil {
		oldlog.Fatal("failed to create client")
	}
	return &crudRestClientCmdV1{

		restNode:    &restObjCmdV1Node{endpoints: endpoints, instance: url},
		restCluster: &restObjCmdV1Cluster{endpoints: endpoints, instance: url},
	}
}

func (a *crudRestClientCmdV1) Node() cmd.NodeInterface {
	return a.restNode
}

func (a *crudRestClientCmdV1) Cluster() cmd.ClusterInterface {
	return a.restCluster
}
