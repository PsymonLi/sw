// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: cmd.proto

/*
	Package cmd is a generated protocol buffer package.

	Service name

	It is generated from these files:
		cmd.proto

	It has these top-level messages:
		AutoMsgClusterWatchHelper
		AutoMsgNodeWatchHelper
		AutoMsgSmartNICWatchHelper
		Cluster
		ClusterList
		ClusterSpec
		ClusterStatus
		Node
		NodeCondition
		NodeList
		NodeSpec
		NodeStatus
		PortCondition
		PortSpec
		PortStatus
		SmartNIC
		SmartNICCondition
		SmartNICList
		SmartNICSpec
		SmartNICStatus
*/
package cmd

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/pensando/grpc-gateway/third_party/googleapis/google/api"
import _ "github.com/pensando/sw/venice/utils/apigen/annotations"
import _ "github.com/gogo/protobuf/gogoproto"
import api "github.com/pensando/sw/api"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// These are valid condition statuses.
type ConditionStatus int32

const (
	ConditionStatus_UNKNOWN ConditionStatus = 0
	ConditionStatus_TRUE    ConditionStatus = 1
	ConditionStatus_FALSE   ConditionStatus = 2
)

var ConditionStatus_name = map[int32]string{
	0: "UNKNOWN",
	1: "TRUE",
	2: "FALSE",
}
var ConditionStatus_value = map[string]int32{
	"UNKNOWN": 0,
	"TRUE":    1,
	"FALSE":   2,
}

func (x ConditionStatus) String() string {
	return proto.EnumName(ConditionStatus_name, int32(x))
}
func (ConditionStatus) EnumDescriptor() ([]byte, []int) { return fileDescriptorCmd, []int{0} }

// Various phases in lifecycle of a SmartNIC
type NodeCondition_ConditionType int32

const (
	NodeCondition_LEADER NodeCondition_ConditionType = 0
)

var NodeCondition_ConditionType_name = map[int32]string{
	0: "LEADER",
}
var NodeCondition_ConditionType_value = map[string]int32{
	"LEADER": 0,
}

func (x NodeCondition_ConditionType) String() string {
	return proto.EnumName(NodeCondition_ConditionType_name, int32(x))
}
func (NodeCondition_ConditionType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorCmd, []int{8, 0}
}

// These are valid conditions of a SmartNIC
type NodeSpec_NodeRole int32

const (
	NodeSpec_CONTROLLER NodeSpec_NodeRole = 0
	NodeSpec_WORKLOAD   NodeSpec_NodeRole = 1
	NodeSpec_QUORUM     NodeSpec_NodeRole = 2
)

var NodeSpec_NodeRole_name = map[int32]string{
	0: "CONTROLLER",
	1: "WORKLOAD",
	2: "QUORUM",
}
var NodeSpec_NodeRole_value = map[string]int32{
	"CONTROLLER": 0,
	"WORKLOAD":   1,
	"QUORUM":     2,
}

func (x NodeSpec_NodeRole) String() string {
	return proto.EnumName(NodeSpec_NodeRole_name, int32(x))
}
func (NodeSpec_NodeRole) EnumDescriptor() ([]byte, []int) { return fileDescriptorCmd, []int{10, 0} }

type NodeStatus_NodePhase int32

const (
	NodeStatus_UNKNOWN NodeStatus_NodePhase = 0
	NodeStatus_PENDING NodeStatus_NodePhase = 1
	NodeStatus_JOINED  NodeStatus_NodePhase = 2
	NodeStatus_FAILED  NodeStatus_NodePhase = 3
)

var NodeStatus_NodePhase_name = map[int32]string{
	0: "UNKNOWN",
	1: "PENDING",
	2: "JOINED",
	3: "FAILED",
}
var NodeStatus_NodePhase_value = map[string]int32{
	"UNKNOWN": 0,
	"PENDING": 1,
	"JOINED":  2,
	"FAILED":  3,
}

func (x NodeStatus_NodePhase) String() string {
	return proto.EnumName(NodeStatus_NodePhase_name, int32(x))
}
func (NodeStatus_NodePhase) EnumDescriptor() ([]byte, []int) { return fileDescriptorCmd, []int{11, 0} }

type PortCondition_ConditionType int32

const (
	PortCondition_PORT_UP PortCondition_ConditionType = 0
)

var PortCondition_ConditionType_name = map[int32]string{
	0: "PORT_UP",
}
var PortCondition_ConditionType_value = map[string]int32{
	"PORT_UP": 0,
}

func (x PortCondition_ConditionType) String() string {
	return proto.EnumName(PortCondition_ConditionType_name, int32(x))
}
func (PortCondition_ConditionType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorCmd, []int{12, 0}
}

type SmartNICCondition_ConditionType int32

const (
	SmartNICCondition_HEALTHY SmartNICCondition_ConditionType = 0
)

var SmartNICCondition_ConditionType_name = map[int32]string{
	0: "HEALTHY",
}
var SmartNICCondition_ConditionType_value = map[string]int32{
	"HEALTHY": 0,
}

func (x SmartNICCondition_ConditionType) String() string {
	return proto.EnumName(SmartNICCondition_ConditionType_name, int32(x))
}
func (SmartNICCondition_ConditionType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorCmd, []int{16, 0}
}

type SmartNICSpec_SmartNICPhase int32

const (
	SmartNICSpec_UNKNOWN  SmartNICSpec_SmartNICPhase = 0
	SmartNICSpec_REJECTED SmartNICSpec_SmartNICPhase = 1
	SmartNICSpec_PENDING  SmartNICSpec_SmartNICPhase = 2
	SmartNICSpec_ADMITTED SmartNICSpec_SmartNICPhase = 3
)

var SmartNICSpec_SmartNICPhase_name = map[int32]string{
	0: "UNKNOWN",
	1: "REJECTED",
	2: "PENDING",
	3: "ADMITTED",
}
var SmartNICSpec_SmartNICPhase_value = map[string]int32{
	"UNKNOWN":  0,
	"REJECTED": 1,
	"PENDING":  2,
	"ADMITTED": 3,
}

func (x SmartNICSpec_SmartNICPhase) String() string {
	return proto.EnumName(SmartNICSpec_SmartNICPhase_name, int32(x))
}
func (SmartNICSpec_SmartNICPhase) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorCmd, []int{18, 0}
}

// --------------------------------- CLUSTER ---------------------------------------------
//
// Cluster represents a full cluster venice and workload nodes
//
// Entity responsible & scenarios involved in managing this object:
//
//      Create:
//          o NetOps-admin
//              - initial cluster creation
//      Modify:
//          o NetOps-admin
//              - update spec attributes
//          o CMD
//              - update status attributes
//      Delete:
//          o NetOps-admin
//              - TBD
//
type AutoMsgClusterWatchHelper struct {
	Type   string   `protobuf:"bytes,1,opt,name=Type,proto3" json:"Type,omitempty"`
	Object *Cluster `protobuf:"bytes,2,opt,name=Object" json:"Object,omitempty"`
}

func (m *AutoMsgClusterWatchHelper) Reset()                    { *m = AutoMsgClusterWatchHelper{} }
func (m *AutoMsgClusterWatchHelper) String() string            { return proto.CompactTextString(m) }
func (*AutoMsgClusterWatchHelper) ProtoMessage()               {}
func (*AutoMsgClusterWatchHelper) Descriptor() ([]byte, []int) { return fileDescriptorCmd, []int{0} }

func (m *AutoMsgClusterWatchHelper) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *AutoMsgClusterWatchHelper) GetObject() *Cluster {
	if m != nil {
		return m.Object
	}
	return nil
}

// ClusterSpec contains the configuration of the cluster.
type AutoMsgNodeWatchHelper struct {
	// QuorumNodes contains the list of hostnames for nodes configured to be quorum
	// nodes in the cluster.
	Type string `protobuf:"bytes,1,opt,name=Type,proto3" json:"Type,omitempty"`
	// VirtualIP is the IP address for managing the cluster. It will be hosted by
	// the winner of election between quorum nodes.
	Object *Node `protobuf:"bytes,2,opt,name=Object" json:"Object,omitempty"`
}

func (m *AutoMsgNodeWatchHelper) Reset()                    { *m = AutoMsgNodeWatchHelper{} }
func (m *AutoMsgNodeWatchHelper) String() string            { return proto.CompactTextString(m) }
func (*AutoMsgNodeWatchHelper) ProtoMessage()               {}
func (*AutoMsgNodeWatchHelper) Descriptor() ([]byte, []int) { return fileDescriptorCmd, []int{1} }

func (m *AutoMsgNodeWatchHelper) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *AutoMsgNodeWatchHelper) GetObject() *Node {
	if m != nil {
		return m.Object
	}
	return nil
}

// ClusterStatus contains the current state of the Cluster.
type AutoMsgSmartNICWatchHelper struct {
	// Leader contains the node name of the cluster leader.
	Type   string    `protobuf:"bytes,1,opt,name=Type,proto3" json:"Type,omitempty"`
	Object *SmartNIC `protobuf:"bytes,2,opt,name=Object" json:"Object,omitempty"`
}

func (m *AutoMsgSmartNICWatchHelper) Reset()                    { *m = AutoMsgSmartNICWatchHelper{} }
func (m *AutoMsgSmartNICWatchHelper) String() string            { return proto.CompactTextString(m) }
func (*AutoMsgSmartNICWatchHelper) ProtoMessage()               {}
func (*AutoMsgSmartNICWatchHelper) Descriptor() ([]byte, []int) { return fileDescriptorCmd, []int{2} }

func (m *AutoMsgSmartNICWatchHelper) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *AutoMsgSmartNICWatchHelper) GetObject() *SmartNIC {
	if m != nil {
		return m.Object
	}
	return nil
}

// ---------------------------------- NODE -------------------------------------------
//
// Node is representation of a single node in the system.
//
// Entity responsible & scenarios involved in managing this object:
//
//      Create:
//          o NetOps-admin
//              - initial node creation for Baremetal node
//          o CMD
//              - auto created when Hypervisor Node and NIC are
//                discovered via Orchestrator interface, NIC registration
//      Modify:
//          o NetOps-admin
//              - update spec for Baremetal node
//          o CMD
//              - update spec attributes for Hypervisor node
//              - update status attributes
//      Delete:
//          o NetOps-admin
//              - when Baremetal node is decommissioned
//          o CMD
//              - TBD
//
type Cluster struct {
	api.TypeMeta   `protobuf:"bytes,1,opt,name=T,embedded=T" json:",inline"`
	api.ObjectMeta `protobuf:"bytes,2,opt,name=O,embedded=O" json:"meta,omitempty"`
	// Spec contains the configuration of the node.
	Spec ClusterSpec `protobuf:"bytes,3,opt,name=Spec" json:"spec,omitempty"`
	// Status contains the current state of the node.
	Status ClusterStatus `protobuf:"bytes,4,opt,name=Status" json:"status,omitempty"`
}

func (m *Cluster) Reset()                    { *m = Cluster{} }
func (m *Cluster) String() string            { return proto.CompactTextString(m) }
func (*Cluster) ProtoMessage()               {}
func (*Cluster) Descriptor() ([]byte, []int) { return fileDescriptorCmd, []int{3} }

func (m *Cluster) GetSpec() ClusterSpec {
	if m != nil {
		return m.Spec
	}
	return ClusterSpec{}
}

func (m *Cluster) GetStatus() ClusterStatus {
	if m != nil {
		return m.Status
	}
	return ClusterStatus{}
}

// NodeSpec contains the configuration of the node.
type ClusterList struct {
	// Roles is of list of roles a node can be configured with.
	api.TypeMeta `protobuf:"bytes,2,opt,name=T,embedded=T" json:"T"`
	api.ListMeta `protobuf:"bytes,3,opt,name=ListMeta,embedded=ListMeta" json:"ListMeta"`
	Items        []*Cluster `protobuf:"bytes,4,rep,name=Items" json:"Items,omitempty"`
}

func (m *ClusterList) Reset()                    { *m = ClusterList{} }
func (m *ClusterList) String() string            { return proto.CompactTextString(m) }
func (*ClusterList) ProtoMessage()               {}
func (*ClusterList) Descriptor() ([]byte, []int) { return fileDescriptorCmd, []int{4} }

func (m *ClusterList) GetItems() []*Cluster {
	if m != nil {
		return m.Items
	}
	return nil
}

// NodeStatus contains the current state of the node.
type ClusterSpec struct {
	// Current lifecycle phase of the node.
	QuorumNodes []string `protobuf:"bytes,1,rep,name=QuorumNodes" json:"quorum-nodes,omitempty"`
	// List of current node conditions
	VirtualIP string `protobuf:"bytes,2,opt,name=VirtualIP,proto3" json:"virtual-ip,omitempty"`
	// Nics holds a list of Mac addresses each uniquely identifying
	// a SmartNIC subsystem that is part of the Node
	NTPServers    []string `protobuf:"bytes,3,rep,name=NTPServers" json:"ntp-servers,omitempty"`
	DNSSubDomain  string   `protobuf:"bytes,4,opt,name=DNSSubDomain,proto3" json:"dns-subdomain,omitempty"`
	AutoAdmitNICs bool     `protobuf:"varint,5,opt,name=AutoAdmitNICs,proto3" json:"auto-admit-nics,autoAdmitNics, omitempty"`
}

func (m *ClusterSpec) Reset()                    { *m = ClusterSpec{} }
func (m *ClusterSpec) String() string            { return proto.CompactTextString(m) }
func (*ClusterSpec) ProtoMessage()               {}
func (*ClusterSpec) Descriptor() ([]byte, []int) { return fileDescriptorCmd, []int{5} }

func (m *ClusterSpec) GetQuorumNodes() []string {
	if m != nil {
		return m.QuorumNodes
	}
	return nil
}

func (m *ClusterSpec) GetVirtualIP() string {
	if m != nil {
		return m.VirtualIP
	}
	return ""
}

func (m *ClusterSpec) GetNTPServers() []string {
	if m != nil {
		return m.NTPServers
	}
	return nil
}

func (m *ClusterSpec) GetDNSSubDomain() string {
	if m != nil {
		return m.DNSSubDomain
	}
	return ""
}

func (m *ClusterSpec) GetAutoAdmitNICs() bool {
	if m != nil {
		return m.AutoAdmitNICs
	}
	return false
}

// NodeCondition describes the state of a Node at a certain point.
type ClusterStatus struct {
	// Type indicates a certain node condition
	Leader string `protobuf:"bytes,1,opt,name=Leader,proto3" json:"leader,omitempty"`
}

func (m *ClusterStatus) Reset()                    { *m = ClusterStatus{} }
func (m *ClusterStatus) String() string            { return proto.CompactTextString(m) }
func (*ClusterStatus) ProtoMessage()               {}
func (*ClusterStatus) Descriptor() ([]byte, []int) { return fileDescriptorCmd, []int{6} }

func (m *ClusterStatus) GetLeader() string {
	if m != nil {
		return m.Leader
	}
	return ""
}

// ------------------------------------ SMART NIC  -------------------------------------------
//
// SmartNIC represents the Naples I/O subsystem
//
// Entity responsible & scenarios involved in managing this object:
//
//      Create:
//          o CMD
//              - created as part of NIC registration, Admittance
//      Modify:
//          o CMD
//              - update spec attributes
//              - update status attributes
//      Delete:
//          o CMD
//              - aging out stale or rejected NICs (TBD)
//          o NetOps, SecOps
//              - Decomission a NIC (TBD)
//
type Node struct {
	api.TypeMeta `protobuf:"bytes,1,opt,name=T,embedded=T" json:",inline"`
	// Object name is Serial-Number of the SmartNIC
	api.ObjectMeta `protobuf:"bytes,2,opt,name=O,embedded=O" json:"meta,omitempty"`
	// SmartNICSpec contains the configuration of the network adapter.
	Spec NodeSpec `protobuf:"bytes,3,opt,name=Spec" json:"spec,omitempty"`
	// SmartNICStatus contains the current state of the network adapter.
	Status NodeStatus `protobuf:"bytes,4,opt,name=Status" json:"status,omitempty"`
}

func (m *Node) Reset()                    { *m = Node{} }
func (m *Node) String() string            { return proto.CompactTextString(m) }
func (*Node) ProtoMessage()               {}
func (*Node) Descriptor() ([]byte, []int) { return fileDescriptorCmd, []int{7} }

func (m *Node) GetSpec() NodeSpec {
	if m != nil {
		return m.Spec
	}
	return NodeSpec{}
}

func (m *Node) GetStatus() NodeStatus {
	if m != nil {
		return m.Status
	}
	return NodeStatus{}
}

// SmartNICSpec contains configuration of the SmartNIC (Naples I/O subsystem)
type NodeCondition struct {
	// Current phase of the SmartNIC.
	// When auto-admission is enabled, Phase will be set to NIC_ADMITTED
	// by CMD for validated NICs.
	// When auto-admission is not enabled, Phase will be set to NIC_PENDING
	// by CMD for validated NICs since it requires manual approval.
	// To admit the NIC as a part of manual admission, user is expected to
	// set the Phase to NIC_ADMITTED for the NICs that are in NIC_PENDING
	// state. Note : Whitelist mode is not supported yet.
	Type string `protobuf:"bytes,1,opt,name=Type,proto3" json:"type,omitempty"`
	// Ports holds a list of Port Specs
	Status             string `protobuf:"bytes,2,opt,name=Status,proto3" json:"status,omitempty"`
	LastTransitionTime string `protobuf:"bytes,3,opt,name=LastTransitionTime,proto3" json:"last-transition-time,omitempty"`
	Reason             string `protobuf:"bytes,4,opt,name=Reason,proto3" json:"reason,omitempty"`
	Message            string `protobuf:"bytes,5,opt,name=Message,proto3" json:"message,omitempty"`
}

func (m *NodeCondition) Reset()                    { *m = NodeCondition{} }
func (m *NodeCondition) String() string            { return proto.CompactTextString(m) }
func (*NodeCondition) ProtoMessage()               {}
func (*NodeCondition) Descriptor() ([]byte, []int) { return fileDescriptorCmd, []int{8} }

func (m *NodeCondition) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *NodeCondition) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *NodeCondition) GetLastTransitionTime() string {
	if m != nil {
		return m.LastTransitionTime
	}
	return ""
}

func (m *NodeCondition) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

func (m *NodeCondition) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

// SmartNICStatus contains current status of a SmartNIC
type NodeList struct {
	// List of current NIC conditions
	api.TypeMeta `protobuf:"bytes,2,opt,name=T,embedded=T" json:"T"`
	// Serial number
	api.ListMeta `protobuf:"bytes,3,opt,name=ListMeta,embedded=ListMeta" json:"ListMeta"`
	// Primary MAC address, which is MAC address of the primary PF exposed by SmartNIC
	Items []*Node `protobuf:"bytes,4,rep,name=Items" json:"Items,omitempty"`
}

func (m *NodeList) Reset()                    { *m = NodeList{} }
func (m *NodeList) String() string            { return proto.CompactTextString(m) }
func (*NodeList) ProtoMessage()               {}
func (*NodeList) Descriptor() ([]byte, []int) { return fileDescriptorCmd, []int{9} }

func (m *NodeList) GetItems() []*Node {
	if m != nil {
		return m.Items
	}
	return nil
}

// SmartNICCondition describes the state of a SmartNIC at a certain point.
type NodeSpec struct {
	// Type indicates a certain NIC condition
	Roles []string `protobuf:"bytes,1,rep,name=Roles" json:"roles,omitempty"`
}

func (m *NodeSpec) Reset()                    { *m = NodeSpec{} }
func (m *NodeSpec) String() string            { return proto.CompactTextString(m) }
func (*NodeSpec) ProtoMessage()               {}
func (*NodeSpec) Descriptor() ([]byte, []int) { return fileDescriptorCmd, []int{10} }

func (m *NodeSpec) GetRoles() []string {
	if m != nil {
		return m.Roles
	}
	return nil
}

// PortSpec contains configuration of a port in SmartNIC
type NodeStatus struct {
	// Mac address of the Port, which is key identifier of the port
	Phase      string           `protobuf:"bytes,1,opt,name=Phase,proto3" json:"phase,omitempty"`
	Conditions []*NodeCondition `protobuf:"bytes,2,rep,name=Conditions" json:"conditions,omitempty"`
	Nics       []string         `protobuf:"bytes,3,rep,name=Nics" json:"nics,omitempty"`
}

func (m *NodeStatus) Reset()                    { *m = NodeStatus{} }
func (m *NodeStatus) String() string            { return proto.CompactTextString(m) }
func (*NodeStatus) ProtoMessage()               {}
func (*NodeStatus) Descriptor() ([]byte, []int) { return fileDescriptorCmd, []int{11} }

func (m *NodeStatus) GetPhase() string {
	if m != nil {
		return m.Phase
	}
	return ""
}

func (m *NodeStatus) GetConditions() []*NodeCondition {
	if m != nil {
		return m.Conditions
	}
	return nil
}

func (m *NodeStatus) GetNics() []string {
	if m != nil {
		return m.Nics
	}
	return nil
}

// PortStatus contains current status of a Port
type PortCondition struct {
	// Mac address of the Port, which is key identifier of the port
	Type string `protobuf:"bytes,1,opt,name=Type,proto3" json:"type,omitempty"`
	// LinkSpeed of the Port
	Status string `protobuf:"bytes,2,opt,name=Status,proto3" json:"status,omitempty"`
	// List of current Port conditions
	LastTransitionTime string `protobuf:"bytes,3,opt,name=LastTransitionTime,proto3" json:"last-transition-time,omitempty"`
	Reason             string `protobuf:"bytes,4,opt,name=Reason,proto3" json:"reason,omitempty"`
	Message            string `protobuf:"bytes,5,opt,name=Message,proto3" json:"message,omitempty"`
}

func (m *PortCondition) Reset()                    { *m = PortCondition{} }
func (m *PortCondition) String() string            { return proto.CompactTextString(m) }
func (*PortCondition) ProtoMessage()               {}
func (*PortCondition) Descriptor() ([]byte, []int) { return fileDescriptorCmd, []int{12} }

func (m *PortCondition) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *PortCondition) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *PortCondition) GetLastTransitionTime() string {
	if m != nil {
		return m.LastTransitionTime
	}
	return ""
}

func (m *PortCondition) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

func (m *PortCondition) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

// PortCondition describes the state of a Port at a certain point.
type PortSpec struct {
	// Type indicates a certain Port condition
	MacAddress string `protobuf:"bytes,1,opt,name=MacAddress,proto3" json:"mac-address,omitempty"`
}

func (m *PortSpec) Reset()                    { *m = PortSpec{} }
func (m *PortSpec) String() string            { return proto.CompactTextString(m) }
func (*PortSpec) ProtoMessage()               {}
func (*PortSpec) Descriptor() ([]byte, []int) { return fileDescriptorCmd, []int{13} }

func (m *PortSpec) GetMacAddress() string {
	if m != nil {
		return m.MacAddress
	}
	return ""
}

type PortStatus struct {
	MacAddress string           `protobuf:"bytes,1,opt,name=MacAddress,proto3" json:"mac-address,omitempty"`
	LinkSpeed  string           `protobuf:"bytes,2,opt,name=LinkSpeed,proto3" json:"link-speed,omitempty"`
	Conditions []*PortCondition `protobuf:"bytes,3,rep,name=Conditions" json:"conditions,omitempty"`
}

func (m *PortStatus) Reset()                    { *m = PortStatus{} }
func (m *PortStatus) String() string            { return proto.CompactTextString(m) }
func (*PortStatus) ProtoMessage()               {}
func (*PortStatus) Descriptor() ([]byte, []int) { return fileDescriptorCmd, []int{14} }

func (m *PortStatus) GetMacAddress() string {
	if m != nil {
		return m.MacAddress
	}
	return ""
}

func (m *PortStatus) GetLinkSpeed() string {
	if m != nil {
		return m.LinkSpeed
	}
	return ""
}

func (m *PortStatus) GetConditions() []*PortCondition {
	if m != nil {
		return m.Conditions
	}
	return nil
}

type SmartNIC struct {
	api.TypeMeta   `protobuf:"bytes,1,opt,name=T,embedded=T" json:",inline"`
	api.ObjectMeta `protobuf:"bytes,2,opt,name=O,embedded=O" json:"meta,omitempty"`
	Spec           SmartNICSpec   `protobuf:"bytes,3,opt,name=Spec" json:"spec,omitempty"`
	Status         SmartNICStatus `protobuf:"bytes,4,opt,name=Status" json:"status,omitempty"`
}

func (m *SmartNIC) Reset()                    { *m = SmartNIC{} }
func (m *SmartNIC) String() string            { return proto.CompactTextString(m) }
func (*SmartNIC) ProtoMessage()               {}
func (*SmartNIC) Descriptor() ([]byte, []int) { return fileDescriptorCmd, []int{15} }

func (m *SmartNIC) GetSpec() SmartNICSpec {
	if m != nil {
		return m.Spec
	}
	return SmartNICSpec{}
}

func (m *SmartNIC) GetStatus() SmartNICStatus {
	if m != nil {
		return m.Status
	}
	return SmartNICStatus{}
}

type SmartNICCondition struct {
	Type               string `protobuf:"bytes,1,opt,name=Type,proto3" json:"type,omitempty"`
	Status             string `protobuf:"bytes,2,opt,name=Status,proto3" json:"status,omitempty"`
	LastTransitionTime string `protobuf:"bytes,3,opt,name=LastTransitionTime,proto3" json:"last-transition-time,omitempty"`
	Reason             string `protobuf:"bytes,4,opt,name=Reason,proto3" json:"reason,omitempty"`
	Message            string `protobuf:"bytes,5,opt,name=Message,proto3" json:"message,omitempty"`
}

func (m *SmartNICCondition) Reset()                    { *m = SmartNICCondition{} }
func (m *SmartNICCondition) String() string            { return proto.CompactTextString(m) }
func (*SmartNICCondition) ProtoMessage()               {}
func (*SmartNICCondition) Descriptor() ([]byte, []int) { return fileDescriptorCmd, []int{16} }

func (m *SmartNICCondition) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *SmartNICCondition) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *SmartNICCondition) GetLastTransitionTime() string {
	if m != nil {
		return m.LastTransitionTime
	}
	return ""
}

func (m *SmartNICCondition) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

func (m *SmartNICCondition) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

type SmartNICList struct {
	api.TypeMeta `protobuf:"bytes,2,opt,name=T,embedded=T" json:"T"`
	api.ListMeta `protobuf:"bytes,3,opt,name=ListMeta,embedded=ListMeta" json:"ListMeta"`
	Items        []*SmartNIC `protobuf:"bytes,4,rep,name=Items" json:"Items,omitempty"`
}

func (m *SmartNICList) Reset()                    { *m = SmartNICList{} }
func (m *SmartNICList) String() string            { return proto.CompactTextString(m) }
func (*SmartNICList) ProtoMessage()               {}
func (*SmartNICList) Descriptor() ([]byte, []int) { return fileDescriptorCmd, []int{17} }

func (m *SmartNICList) GetItems() []*SmartNIC {
	if m != nil {
		return m.Items
	}
	return nil
}

type SmartNICSpec struct {
	Phase string     `protobuf:"bytes,1,opt,name=Phase,proto3" json:"phase,omitempty"`
	Ports []PortSpec `protobuf:"bytes,2,rep,name=Ports" json:"ports,omitempty"`
}

func (m *SmartNICSpec) Reset()                    { *m = SmartNICSpec{} }
func (m *SmartNICSpec) String() string            { return proto.CompactTextString(m) }
func (*SmartNICSpec) ProtoMessage()               {}
func (*SmartNICSpec) Descriptor() ([]byte, []int) { return fileDescriptorCmd, []int{18} }

func (m *SmartNICSpec) GetPhase() string {
	if m != nil {
		return m.Phase
	}
	return ""
}

func (m *SmartNICSpec) GetPorts() []PortSpec {
	if m != nil {
		return m.Ports
	}
	return nil
}

type SmartNICStatus struct {
	Conditions        []*SmartNICCondition `protobuf:"bytes,1,rep,name=Conditions" json:"conditions,omitempty"`
	SerialNum         string               `protobuf:"bytes,2,opt,name=SerialNum,proto3" json:"serial-num,omitempty"`
	PrimaryMacAddress string               `protobuf:"bytes,3,opt,name=PrimaryMacAddress,proto3" json:"primary-mac-address,omitempty"`
	NodeName          string               `protobuf:"bytes,4,opt,name=NodeName,proto3" json:"node-name,omitempty"`
	Ports             []*PortStatus        `protobuf:"bytes,5,rep,name=Ports" json:"ports,omitempty"`
}

func (m *SmartNICStatus) Reset()                    { *m = SmartNICStatus{} }
func (m *SmartNICStatus) String() string            { return proto.CompactTextString(m) }
func (*SmartNICStatus) ProtoMessage()               {}
func (*SmartNICStatus) Descriptor() ([]byte, []int) { return fileDescriptorCmd, []int{19} }

func (m *SmartNICStatus) GetConditions() []*SmartNICCondition {
	if m != nil {
		return m.Conditions
	}
	return nil
}

func (m *SmartNICStatus) GetSerialNum() string {
	if m != nil {
		return m.SerialNum
	}
	return ""
}

func (m *SmartNICStatus) GetPrimaryMacAddress() string {
	if m != nil {
		return m.PrimaryMacAddress
	}
	return ""
}

func (m *SmartNICStatus) GetNodeName() string {
	if m != nil {
		return m.NodeName
	}
	return ""
}

func (m *SmartNICStatus) GetPorts() []*PortStatus {
	if m != nil {
		return m.Ports
	}
	return nil
}

func init() {
	proto.RegisterType((*AutoMsgClusterWatchHelper)(nil), "cmd.AutoMsgClusterWatchHelper")
	proto.RegisterType((*AutoMsgNodeWatchHelper)(nil), "cmd.AutoMsgNodeWatchHelper")
	proto.RegisterType((*AutoMsgSmartNICWatchHelper)(nil), "cmd.AutoMsgSmartNICWatchHelper")
	proto.RegisterType((*Cluster)(nil), "cmd.Cluster")
	proto.RegisterType((*ClusterList)(nil), "cmd.ClusterList")
	proto.RegisterType((*ClusterSpec)(nil), "cmd.ClusterSpec")
	proto.RegisterType((*ClusterStatus)(nil), "cmd.ClusterStatus")
	proto.RegisterType((*Node)(nil), "cmd.Node")
	proto.RegisterType((*NodeCondition)(nil), "cmd.NodeCondition")
	proto.RegisterType((*NodeList)(nil), "cmd.NodeList")
	proto.RegisterType((*NodeSpec)(nil), "cmd.NodeSpec")
	proto.RegisterType((*NodeStatus)(nil), "cmd.NodeStatus")
	proto.RegisterType((*PortCondition)(nil), "cmd.PortCondition")
	proto.RegisterType((*PortSpec)(nil), "cmd.PortSpec")
	proto.RegisterType((*PortStatus)(nil), "cmd.PortStatus")
	proto.RegisterType((*SmartNIC)(nil), "cmd.SmartNIC")
	proto.RegisterType((*SmartNICCondition)(nil), "cmd.SmartNICCondition")
	proto.RegisterType((*SmartNICList)(nil), "cmd.SmartNICList")
	proto.RegisterType((*SmartNICSpec)(nil), "cmd.SmartNICSpec")
	proto.RegisterType((*SmartNICStatus)(nil), "cmd.SmartNICStatus")
	proto.RegisterEnum("cmd.ConditionStatus", ConditionStatus_name, ConditionStatus_value)
	proto.RegisterEnum("cmd.NodeCondition_ConditionType", NodeCondition_ConditionType_name, NodeCondition_ConditionType_value)
	proto.RegisterEnum("cmd.NodeSpec_NodeRole", NodeSpec_NodeRole_name, NodeSpec_NodeRole_value)
	proto.RegisterEnum("cmd.NodeStatus_NodePhase", NodeStatus_NodePhase_name, NodeStatus_NodePhase_value)
	proto.RegisterEnum("cmd.PortCondition_ConditionType", PortCondition_ConditionType_name, PortCondition_ConditionType_value)
	proto.RegisterEnum("cmd.SmartNICCondition_ConditionType", SmartNICCondition_ConditionType_name, SmartNICCondition_ConditionType_value)
	proto.RegisterEnum("cmd.SmartNICSpec_SmartNICPhase", SmartNICSpec_SmartNICPhase_name, SmartNICSpec_SmartNICPhase_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for CmdV1 service

type CmdV1Client interface {
	AutoAddCluster(ctx context.Context, in *Cluster, opts ...grpc.CallOption) (*Cluster, error)
	AutoAddNode(ctx context.Context, in *Node, opts ...grpc.CallOption) (*Node, error)
	AutoAddSmartNIC(ctx context.Context, in *SmartNIC, opts ...grpc.CallOption) (*SmartNIC, error)
	AutoDeleteCluster(ctx context.Context, in *Cluster, opts ...grpc.CallOption) (*Cluster, error)
	AutoDeleteNode(ctx context.Context, in *Node, opts ...grpc.CallOption) (*Node, error)
	AutoDeleteSmartNIC(ctx context.Context, in *SmartNIC, opts ...grpc.CallOption) (*SmartNIC, error)
	AutoGetCluster(ctx context.Context, in *Cluster, opts ...grpc.CallOption) (*Cluster, error)
	AutoGetNode(ctx context.Context, in *Node, opts ...grpc.CallOption) (*Node, error)
	AutoGetSmartNIC(ctx context.Context, in *SmartNIC, opts ...grpc.CallOption) (*SmartNIC, error)
	AutoListCluster(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (*ClusterList, error)
	AutoListNode(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (*NodeList, error)
	AutoListSmartNIC(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (*SmartNICList, error)
	AutoUpdateCluster(ctx context.Context, in *Cluster, opts ...grpc.CallOption) (*Cluster, error)
	AutoUpdateNode(ctx context.Context, in *Node, opts ...grpc.CallOption) (*Node, error)
	AutoUpdateSmartNIC(ctx context.Context, in *SmartNIC, opts ...grpc.CallOption) (*SmartNIC, error)
	AutoWatchCluster(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (CmdV1_AutoWatchClusterClient, error)
	AutoWatchNode(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (CmdV1_AutoWatchNodeClient, error)
	AutoWatchSmartNIC(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (CmdV1_AutoWatchSmartNICClient, error)
}

type cmdV1Client struct {
	cc *grpc.ClientConn
}

func NewCmdV1Client(cc *grpc.ClientConn) CmdV1Client {
	return &cmdV1Client{cc}
}

func (c *cmdV1Client) AutoAddCluster(ctx context.Context, in *Cluster, opts ...grpc.CallOption) (*Cluster, error) {
	out := new(Cluster)
	err := grpc.Invoke(ctx, "/cmd.CmdV1/AutoAddCluster", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cmdV1Client) AutoAddNode(ctx context.Context, in *Node, opts ...grpc.CallOption) (*Node, error) {
	out := new(Node)
	err := grpc.Invoke(ctx, "/cmd.CmdV1/AutoAddNode", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cmdV1Client) AutoAddSmartNIC(ctx context.Context, in *SmartNIC, opts ...grpc.CallOption) (*SmartNIC, error) {
	out := new(SmartNIC)
	err := grpc.Invoke(ctx, "/cmd.CmdV1/AutoAddSmartNIC", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cmdV1Client) AutoDeleteCluster(ctx context.Context, in *Cluster, opts ...grpc.CallOption) (*Cluster, error) {
	out := new(Cluster)
	err := grpc.Invoke(ctx, "/cmd.CmdV1/AutoDeleteCluster", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cmdV1Client) AutoDeleteNode(ctx context.Context, in *Node, opts ...grpc.CallOption) (*Node, error) {
	out := new(Node)
	err := grpc.Invoke(ctx, "/cmd.CmdV1/AutoDeleteNode", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cmdV1Client) AutoDeleteSmartNIC(ctx context.Context, in *SmartNIC, opts ...grpc.CallOption) (*SmartNIC, error) {
	out := new(SmartNIC)
	err := grpc.Invoke(ctx, "/cmd.CmdV1/AutoDeleteSmartNIC", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cmdV1Client) AutoGetCluster(ctx context.Context, in *Cluster, opts ...grpc.CallOption) (*Cluster, error) {
	out := new(Cluster)
	err := grpc.Invoke(ctx, "/cmd.CmdV1/AutoGetCluster", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cmdV1Client) AutoGetNode(ctx context.Context, in *Node, opts ...grpc.CallOption) (*Node, error) {
	out := new(Node)
	err := grpc.Invoke(ctx, "/cmd.CmdV1/AutoGetNode", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cmdV1Client) AutoGetSmartNIC(ctx context.Context, in *SmartNIC, opts ...grpc.CallOption) (*SmartNIC, error) {
	out := new(SmartNIC)
	err := grpc.Invoke(ctx, "/cmd.CmdV1/AutoGetSmartNIC", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cmdV1Client) AutoListCluster(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (*ClusterList, error) {
	out := new(ClusterList)
	err := grpc.Invoke(ctx, "/cmd.CmdV1/AutoListCluster", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cmdV1Client) AutoListNode(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (*NodeList, error) {
	out := new(NodeList)
	err := grpc.Invoke(ctx, "/cmd.CmdV1/AutoListNode", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cmdV1Client) AutoListSmartNIC(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (*SmartNICList, error) {
	out := new(SmartNICList)
	err := grpc.Invoke(ctx, "/cmd.CmdV1/AutoListSmartNIC", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cmdV1Client) AutoUpdateCluster(ctx context.Context, in *Cluster, opts ...grpc.CallOption) (*Cluster, error) {
	out := new(Cluster)
	err := grpc.Invoke(ctx, "/cmd.CmdV1/AutoUpdateCluster", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cmdV1Client) AutoUpdateNode(ctx context.Context, in *Node, opts ...grpc.CallOption) (*Node, error) {
	out := new(Node)
	err := grpc.Invoke(ctx, "/cmd.CmdV1/AutoUpdateNode", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cmdV1Client) AutoUpdateSmartNIC(ctx context.Context, in *SmartNIC, opts ...grpc.CallOption) (*SmartNIC, error) {
	out := new(SmartNIC)
	err := grpc.Invoke(ctx, "/cmd.CmdV1/AutoUpdateSmartNIC", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cmdV1Client) AutoWatchCluster(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (CmdV1_AutoWatchClusterClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_CmdV1_serviceDesc.Streams[0], c.cc, "/cmd.CmdV1/AutoWatchCluster", opts...)
	if err != nil {
		return nil, err
	}
	x := &cmdV1AutoWatchClusterClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type CmdV1_AutoWatchClusterClient interface {
	Recv() (*AutoMsgClusterWatchHelper, error)
	grpc.ClientStream
}

type cmdV1AutoWatchClusterClient struct {
	grpc.ClientStream
}

func (x *cmdV1AutoWatchClusterClient) Recv() (*AutoMsgClusterWatchHelper, error) {
	m := new(AutoMsgClusterWatchHelper)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *cmdV1Client) AutoWatchNode(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (CmdV1_AutoWatchNodeClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_CmdV1_serviceDesc.Streams[1], c.cc, "/cmd.CmdV1/AutoWatchNode", opts...)
	if err != nil {
		return nil, err
	}
	x := &cmdV1AutoWatchNodeClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type CmdV1_AutoWatchNodeClient interface {
	Recv() (*AutoMsgNodeWatchHelper, error)
	grpc.ClientStream
}

type cmdV1AutoWatchNodeClient struct {
	grpc.ClientStream
}

func (x *cmdV1AutoWatchNodeClient) Recv() (*AutoMsgNodeWatchHelper, error) {
	m := new(AutoMsgNodeWatchHelper)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *cmdV1Client) AutoWatchSmartNIC(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (CmdV1_AutoWatchSmartNICClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_CmdV1_serviceDesc.Streams[2], c.cc, "/cmd.CmdV1/AutoWatchSmartNIC", opts...)
	if err != nil {
		return nil, err
	}
	x := &cmdV1AutoWatchSmartNICClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type CmdV1_AutoWatchSmartNICClient interface {
	Recv() (*AutoMsgSmartNICWatchHelper, error)
	grpc.ClientStream
}

type cmdV1AutoWatchSmartNICClient struct {
	grpc.ClientStream
}

func (x *cmdV1AutoWatchSmartNICClient) Recv() (*AutoMsgSmartNICWatchHelper, error) {
	m := new(AutoMsgSmartNICWatchHelper)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for CmdV1 service

type CmdV1Server interface {
	AutoAddCluster(context.Context, *Cluster) (*Cluster, error)
	AutoAddNode(context.Context, *Node) (*Node, error)
	AutoAddSmartNIC(context.Context, *SmartNIC) (*SmartNIC, error)
	AutoDeleteCluster(context.Context, *Cluster) (*Cluster, error)
	AutoDeleteNode(context.Context, *Node) (*Node, error)
	AutoDeleteSmartNIC(context.Context, *SmartNIC) (*SmartNIC, error)
	AutoGetCluster(context.Context, *Cluster) (*Cluster, error)
	AutoGetNode(context.Context, *Node) (*Node, error)
	AutoGetSmartNIC(context.Context, *SmartNIC) (*SmartNIC, error)
	AutoListCluster(context.Context, *api.ListWatchOptions) (*ClusterList, error)
	AutoListNode(context.Context, *api.ListWatchOptions) (*NodeList, error)
	AutoListSmartNIC(context.Context, *api.ListWatchOptions) (*SmartNICList, error)
	AutoUpdateCluster(context.Context, *Cluster) (*Cluster, error)
	AutoUpdateNode(context.Context, *Node) (*Node, error)
	AutoUpdateSmartNIC(context.Context, *SmartNIC) (*SmartNIC, error)
	AutoWatchCluster(*api.ListWatchOptions, CmdV1_AutoWatchClusterServer) error
	AutoWatchNode(*api.ListWatchOptions, CmdV1_AutoWatchNodeServer) error
	AutoWatchSmartNIC(*api.ListWatchOptions, CmdV1_AutoWatchSmartNICServer) error
}

func RegisterCmdV1Server(s *grpc.Server, srv CmdV1Server) {
	s.RegisterService(&_CmdV1_serviceDesc, srv)
}

func _CmdV1_AutoAddCluster_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Cluster)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CmdV1Server).AutoAddCluster(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cmd.CmdV1/AutoAddCluster",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CmdV1Server).AutoAddCluster(ctx, req.(*Cluster))
	}
	return interceptor(ctx, in, info, handler)
}

func _CmdV1_AutoAddNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Node)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CmdV1Server).AutoAddNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cmd.CmdV1/AutoAddNode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CmdV1Server).AutoAddNode(ctx, req.(*Node))
	}
	return interceptor(ctx, in, info, handler)
}

func _CmdV1_AutoAddSmartNIC_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SmartNIC)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CmdV1Server).AutoAddSmartNIC(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cmd.CmdV1/AutoAddSmartNIC",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CmdV1Server).AutoAddSmartNIC(ctx, req.(*SmartNIC))
	}
	return interceptor(ctx, in, info, handler)
}

func _CmdV1_AutoDeleteCluster_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Cluster)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CmdV1Server).AutoDeleteCluster(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cmd.CmdV1/AutoDeleteCluster",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CmdV1Server).AutoDeleteCluster(ctx, req.(*Cluster))
	}
	return interceptor(ctx, in, info, handler)
}

func _CmdV1_AutoDeleteNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Node)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CmdV1Server).AutoDeleteNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cmd.CmdV1/AutoDeleteNode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CmdV1Server).AutoDeleteNode(ctx, req.(*Node))
	}
	return interceptor(ctx, in, info, handler)
}

func _CmdV1_AutoDeleteSmartNIC_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SmartNIC)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CmdV1Server).AutoDeleteSmartNIC(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cmd.CmdV1/AutoDeleteSmartNIC",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CmdV1Server).AutoDeleteSmartNIC(ctx, req.(*SmartNIC))
	}
	return interceptor(ctx, in, info, handler)
}

func _CmdV1_AutoGetCluster_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Cluster)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CmdV1Server).AutoGetCluster(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cmd.CmdV1/AutoGetCluster",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CmdV1Server).AutoGetCluster(ctx, req.(*Cluster))
	}
	return interceptor(ctx, in, info, handler)
}

func _CmdV1_AutoGetNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Node)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CmdV1Server).AutoGetNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cmd.CmdV1/AutoGetNode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CmdV1Server).AutoGetNode(ctx, req.(*Node))
	}
	return interceptor(ctx, in, info, handler)
}

func _CmdV1_AutoGetSmartNIC_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SmartNIC)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CmdV1Server).AutoGetSmartNIC(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cmd.CmdV1/AutoGetSmartNIC",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CmdV1Server).AutoGetSmartNIC(ctx, req.(*SmartNIC))
	}
	return interceptor(ctx, in, info, handler)
}

func _CmdV1_AutoListCluster_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(api.ListWatchOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CmdV1Server).AutoListCluster(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cmd.CmdV1/AutoListCluster",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CmdV1Server).AutoListCluster(ctx, req.(*api.ListWatchOptions))
	}
	return interceptor(ctx, in, info, handler)
}

func _CmdV1_AutoListNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(api.ListWatchOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CmdV1Server).AutoListNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cmd.CmdV1/AutoListNode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CmdV1Server).AutoListNode(ctx, req.(*api.ListWatchOptions))
	}
	return interceptor(ctx, in, info, handler)
}

func _CmdV1_AutoListSmartNIC_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(api.ListWatchOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CmdV1Server).AutoListSmartNIC(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cmd.CmdV1/AutoListSmartNIC",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CmdV1Server).AutoListSmartNIC(ctx, req.(*api.ListWatchOptions))
	}
	return interceptor(ctx, in, info, handler)
}

func _CmdV1_AutoUpdateCluster_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Cluster)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CmdV1Server).AutoUpdateCluster(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cmd.CmdV1/AutoUpdateCluster",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CmdV1Server).AutoUpdateCluster(ctx, req.(*Cluster))
	}
	return interceptor(ctx, in, info, handler)
}

func _CmdV1_AutoUpdateNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Node)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CmdV1Server).AutoUpdateNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cmd.CmdV1/AutoUpdateNode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CmdV1Server).AutoUpdateNode(ctx, req.(*Node))
	}
	return interceptor(ctx, in, info, handler)
}

func _CmdV1_AutoUpdateSmartNIC_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SmartNIC)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CmdV1Server).AutoUpdateSmartNIC(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cmd.CmdV1/AutoUpdateSmartNIC",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CmdV1Server).AutoUpdateSmartNIC(ctx, req.(*SmartNIC))
	}
	return interceptor(ctx, in, info, handler)
}

func _CmdV1_AutoWatchCluster_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(api.ListWatchOptions)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(CmdV1Server).AutoWatchCluster(m, &cmdV1AutoWatchClusterServer{stream})
}

type CmdV1_AutoWatchClusterServer interface {
	Send(*AutoMsgClusterWatchHelper) error
	grpc.ServerStream
}

type cmdV1AutoWatchClusterServer struct {
	grpc.ServerStream
}

func (x *cmdV1AutoWatchClusterServer) Send(m *AutoMsgClusterWatchHelper) error {
	return x.ServerStream.SendMsg(m)
}

func _CmdV1_AutoWatchNode_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(api.ListWatchOptions)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(CmdV1Server).AutoWatchNode(m, &cmdV1AutoWatchNodeServer{stream})
}

type CmdV1_AutoWatchNodeServer interface {
	Send(*AutoMsgNodeWatchHelper) error
	grpc.ServerStream
}

type cmdV1AutoWatchNodeServer struct {
	grpc.ServerStream
}

func (x *cmdV1AutoWatchNodeServer) Send(m *AutoMsgNodeWatchHelper) error {
	return x.ServerStream.SendMsg(m)
}

func _CmdV1_AutoWatchSmartNIC_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(api.ListWatchOptions)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(CmdV1Server).AutoWatchSmartNIC(m, &cmdV1AutoWatchSmartNICServer{stream})
}

type CmdV1_AutoWatchSmartNICServer interface {
	Send(*AutoMsgSmartNICWatchHelper) error
	grpc.ServerStream
}

type cmdV1AutoWatchSmartNICServer struct {
	grpc.ServerStream
}

func (x *cmdV1AutoWatchSmartNICServer) Send(m *AutoMsgSmartNICWatchHelper) error {
	return x.ServerStream.SendMsg(m)
}

var _CmdV1_serviceDesc = grpc.ServiceDesc{
	ServiceName: "cmd.CmdV1",
	HandlerType: (*CmdV1Server)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AutoAddCluster",
			Handler:    _CmdV1_AutoAddCluster_Handler,
		},
		{
			MethodName: "AutoAddNode",
			Handler:    _CmdV1_AutoAddNode_Handler,
		},
		{
			MethodName: "AutoAddSmartNIC",
			Handler:    _CmdV1_AutoAddSmartNIC_Handler,
		},
		{
			MethodName: "AutoDeleteCluster",
			Handler:    _CmdV1_AutoDeleteCluster_Handler,
		},
		{
			MethodName: "AutoDeleteNode",
			Handler:    _CmdV1_AutoDeleteNode_Handler,
		},
		{
			MethodName: "AutoDeleteSmartNIC",
			Handler:    _CmdV1_AutoDeleteSmartNIC_Handler,
		},
		{
			MethodName: "AutoGetCluster",
			Handler:    _CmdV1_AutoGetCluster_Handler,
		},
		{
			MethodName: "AutoGetNode",
			Handler:    _CmdV1_AutoGetNode_Handler,
		},
		{
			MethodName: "AutoGetSmartNIC",
			Handler:    _CmdV1_AutoGetSmartNIC_Handler,
		},
		{
			MethodName: "AutoListCluster",
			Handler:    _CmdV1_AutoListCluster_Handler,
		},
		{
			MethodName: "AutoListNode",
			Handler:    _CmdV1_AutoListNode_Handler,
		},
		{
			MethodName: "AutoListSmartNIC",
			Handler:    _CmdV1_AutoListSmartNIC_Handler,
		},
		{
			MethodName: "AutoUpdateCluster",
			Handler:    _CmdV1_AutoUpdateCluster_Handler,
		},
		{
			MethodName: "AutoUpdateNode",
			Handler:    _CmdV1_AutoUpdateNode_Handler,
		},
		{
			MethodName: "AutoUpdateSmartNIC",
			Handler:    _CmdV1_AutoUpdateSmartNIC_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "AutoWatchCluster",
			Handler:       _CmdV1_AutoWatchCluster_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "AutoWatchNode",
			Handler:       _CmdV1_AutoWatchNode_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "AutoWatchSmartNIC",
			Handler:       _CmdV1_AutoWatchSmartNIC_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "cmd.proto",
}

func (m *AutoMsgClusterWatchHelper) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AutoMsgClusterWatchHelper) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCmd(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if m.Object != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCmd(dAtA, i, uint64(m.Object.Size()))
		n1, err := m.Object.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	return i, nil
}

func (m *AutoMsgNodeWatchHelper) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AutoMsgNodeWatchHelper) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCmd(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if m.Object != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCmd(dAtA, i, uint64(m.Object.Size()))
		n2, err := m.Object.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}

func (m *AutoMsgSmartNICWatchHelper) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AutoMsgSmartNICWatchHelper) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCmd(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if m.Object != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCmd(dAtA, i, uint64(m.Object.Size()))
		n3, err := m.Object.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}

func (m *Cluster) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Cluster) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintCmd(dAtA, i, uint64(m.TypeMeta.Size()))
	n4, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n4
	dAtA[i] = 0x12
	i++
	i = encodeVarintCmd(dAtA, i, uint64(m.ObjectMeta.Size()))
	n5, err := m.ObjectMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n5
	dAtA[i] = 0x1a
	i++
	i = encodeVarintCmd(dAtA, i, uint64(m.Spec.Size()))
	n6, err := m.Spec.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n6
	dAtA[i] = 0x22
	i++
	i = encodeVarintCmd(dAtA, i, uint64(m.Status.Size()))
	n7, err := m.Status.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n7
	return i, nil
}

func (m *ClusterList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClusterList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x12
	i++
	i = encodeVarintCmd(dAtA, i, uint64(m.TypeMeta.Size()))
	n8, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n8
	dAtA[i] = 0x1a
	i++
	i = encodeVarintCmd(dAtA, i, uint64(m.ListMeta.Size()))
	n9, err := m.ListMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n9
	if len(m.Items) > 0 {
		for _, msg := range m.Items {
			dAtA[i] = 0x22
			i++
			i = encodeVarintCmd(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ClusterSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClusterSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.QuorumNodes) > 0 {
		for _, s := range m.QuorumNodes {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.VirtualIP) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCmd(dAtA, i, uint64(len(m.VirtualIP)))
		i += copy(dAtA[i:], m.VirtualIP)
	}
	if len(m.NTPServers) > 0 {
		for _, s := range m.NTPServers {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.DNSSubDomain) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCmd(dAtA, i, uint64(len(m.DNSSubDomain)))
		i += copy(dAtA[i:], m.DNSSubDomain)
	}
	if m.AutoAdmitNICs {
		dAtA[i] = 0x28
		i++
		if m.AutoAdmitNICs {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *ClusterStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClusterStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Leader) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCmd(dAtA, i, uint64(len(m.Leader)))
		i += copy(dAtA[i:], m.Leader)
	}
	return i, nil
}

func (m *Node) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Node) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintCmd(dAtA, i, uint64(m.TypeMeta.Size()))
	n10, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n10
	dAtA[i] = 0x12
	i++
	i = encodeVarintCmd(dAtA, i, uint64(m.ObjectMeta.Size()))
	n11, err := m.ObjectMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n11
	dAtA[i] = 0x1a
	i++
	i = encodeVarintCmd(dAtA, i, uint64(m.Spec.Size()))
	n12, err := m.Spec.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n12
	dAtA[i] = 0x22
	i++
	i = encodeVarintCmd(dAtA, i, uint64(m.Status.Size()))
	n13, err := m.Status.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n13
	return i, nil
}

func (m *NodeCondition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeCondition) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCmd(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.Status) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCmd(dAtA, i, uint64(len(m.Status)))
		i += copy(dAtA[i:], m.Status)
	}
	if len(m.LastTransitionTime) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCmd(dAtA, i, uint64(len(m.LastTransitionTime)))
		i += copy(dAtA[i:], m.LastTransitionTime)
	}
	if len(m.Reason) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCmd(dAtA, i, uint64(len(m.Reason)))
		i += copy(dAtA[i:], m.Reason)
	}
	if len(m.Message) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintCmd(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	return i, nil
}

func (m *NodeList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x12
	i++
	i = encodeVarintCmd(dAtA, i, uint64(m.TypeMeta.Size()))
	n14, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n14
	dAtA[i] = 0x1a
	i++
	i = encodeVarintCmd(dAtA, i, uint64(m.ListMeta.Size()))
	n15, err := m.ListMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n15
	if len(m.Items) > 0 {
		for _, msg := range m.Items {
			dAtA[i] = 0x22
			i++
			i = encodeVarintCmd(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *NodeSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Roles) > 0 {
		for _, s := range m.Roles {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *NodeStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Phase) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCmd(dAtA, i, uint64(len(m.Phase)))
		i += copy(dAtA[i:], m.Phase)
	}
	if len(m.Conditions) > 0 {
		for _, msg := range m.Conditions {
			dAtA[i] = 0x12
			i++
			i = encodeVarintCmd(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Nics) > 0 {
		for _, s := range m.Nics {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *PortCondition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PortCondition) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCmd(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.Status) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCmd(dAtA, i, uint64(len(m.Status)))
		i += copy(dAtA[i:], m.Status)
	}
	if len(m.LastTransitionTime) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCmd(dAtA, i, uint64(len(m.LastTransitionTime)))
		i += copy(dAtA[i:], m.LastTransitionTime)
	}
	if len(m.Reason) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCmd(dAtA, i, uint64(len(m.Reason)))
		i += copy(dAtA[i:], m.Reason)
	}
	if len(m.Message) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintCmd(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	return i, nil
}

func (m *PortSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PortSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.MacAddress) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCmd(dAtA, i, uint64(len(m.MacAddress)))
		i += copy(dAtA[i:], m.MacAddress)
	}
	return i, nil
}

func (m *PortStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PortStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.MacAddress) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCmd(dAtA, i, uint64(len(m.MacAddress)))
		i += copy(dAtA[i:], m.MacAddress)
	}
	if len(m.LinkSpeed) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCmd(dAtA, i, uint64(len(m.LinkSpeed)))
		i += copy(dAtA[i:], m.LinkSpeed)
	}
	if len(m.Conditions) > 0 {
		for _, msg := range m.Conditions {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintCmd(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SmartNIC) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SmartNIC) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintCmd(dAtA, i, uint64(m.TypeMeta.Size()))
	n16, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n16
	dAtA[i] = 0x12
	i++
	i = encodeVarintCmd(dAtA, i, uint64(m.ObjectMeta.Size()))
	n17, err := m.ObjectMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n17
	dAtA[i] = 0x1a
	i++
	i = encodeVarintCmd(dAtA, i, uint64(m.Spec.Size()))
	n18, err := m.Spec.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n18
	dAtA[i] = 0x22
	i++
	i = encodeVarintCmd(dAtA, i, uint64(m.Status.Size()))
	n19, err := m.Status.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n19
	return i, nil
}

func (m *SmartNICCondition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SmartNICCondition) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCmd(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.Status) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCmd(dAtA, i, uint64(len(m.Status)))
		i += copy(dAtA[i:], m.Status)
	}
	if len(m.LastTransitionTime) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCmd(dAtA, i, uint64(len(m.LastTransitionTime)))
		i += copy(dAtA[i:], m.LastTransitionTime)
	}
	if len(m.Reason) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCmd(dAtA, i, uint64(len(m.Reason)))
		i += copy(dAtA[i:], m.Reason)
	}
	if len(m.Message) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintCmd(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	return i, nil
}

func (m *SmartNICList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SmartNICList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x12
	i++
	i = encodeVarintCmd(dAtA, i, uint64(m.TypeMeta.Size()))
	n20, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n20
	dAtA[i] = 0x1a
	i++
	i = encodeVarintCmd(dAtA, i, uint64(m.ListMeta.Size()))
	n21, err := m.ListMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n21
	if len(m.Items) > 0 {
		for _, msg := range m.Items {
			dAtA[i] = 0x22
			i++
			i = encodeVarintCmd(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SmartNICSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SmartNICSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Phase) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCmd(dAtA, i, uint64(len(m.Phase)))
		i += copy(dAtA[i:], m.Phase)
	}
	if len(m.Ports) > 0 {
		for _, msg := range m.Ports {
			dAtA[i] = 0x12
			i++
			i = encodeVarintCmd(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SmartNICStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SmartNICStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Conditions) > 0 {
		for _, msg := range m.Conditions {
			dAtA[i] = 0xa
			i++
			i = encodeVarintCmd(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.SerialNum) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCmd(dAtA, i, uint64(len(m.SerialNum)))
		i += copy(dAtA[i:], m.SerialNum)
	}
	if len(m.PrimaryMacAddress) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCmd(dAtA, i, uint64(len(m.PrimaryMacAddress)))
		i += copy(dAtA[i:], m.PrimaryMacAddress)
	}
	if len(m.NodeName) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCmd(dAtA, i, uint64(len(m.NodeName)))
		i += copy(dAtA[i:], m.NodeName)
	}
	if len(m.Ports) > 0 {
		for _, msg := range m.Ports {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintCmd(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func encodeFixed64Cmd(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Cmd(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintCmd(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *AutoMsgClusterWatchHelper) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovCmd(uint64(l))
	}
	if m.Object != nil {
		l = m.Object.Size()
		n += 1 + l + sovCmd(uint64(l))
	}
	return n
}

func (m *AutoMsgNodeWatchHelper) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovCmd(uint64(l))
	}
	if m.Object != nil {
		l = m.Object.Size()
		n += 1 + l + sovCmd(uint64(l))
	}
	return n
}

func (m *AutoMsgSmartNICWatchHelper) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovCmd(uint64(l))
	}
	if m.Object != nil {
		l = m.Object.Size()
		n += 1 + l + sovCmd(uint64(l))
	}
	return n
}

func (m *Cluster) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovCmd(uint64(l))
	l = m.ObjectMeta.Size()
	n += 1 + l + sovCmd(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovCmd(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovCmd(uint64(l))
	return n
}

func (m *ClusterList) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovCmd(uint64(l))
	l = m.ListMeta.Size()
	n += 1 + l + sovCmd(uint64(l))
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovCmd(uint64(l))
		}
	}
	return n
}

func (m *ClusterSpec) Size() (n int) {
	var l int
	_ = l
	if len(m.QuorumNodes) > 0 {
		for _, s := range m.QuorumNodes {
			l = len(s)
			n += 1 + l + sovCmd(uint64(l))
		}
	}
	l = len(m.VirtualIP)
	if l > 0 {
		n += 1 + l + sovCmd(uint64(l))
	}
	if len(m.NTPServers) > 0 {
		for _, s := range m.NTPServers {
			l = len(s)
			n += 1 + l + sovCmd(uint64(l))
		}
	}
	l = len(m.DNSSubDomain)
	if l > 0 {
		n += 1 + l + sovCmd(uint64(l))
	}
	if m.AutoAdmitNICs {
		n += 2
	}
	return n
}

func (m *ClusterStatus) Size() (n int) {
	var l int
	_ = l
	l = len(m.Leader)
	if l > 0 {
		n += 1 + l + sovCmd(uint64(l))
	}
	return n
}

func (m *Node) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovCmd(uint64(l))
	l = m.ObjectMeta.Size()
	n += 1 + l + sovCmd(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovCmd(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovCmd(uint64(l))
	return n
}

func (m *NodeCondition) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovCmd(uint64(l))
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovCmd(uint64(l))
	}
	l = len(m.LastTransitionTime)
	if l > 0 {
		n += 1 + l + sovCmd(uint64(l))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovCmd(uint64(l))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovCmd(uint64(l))
	}
	return n
}

func (m *NodeList) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovCmd(uint64(l))
	l = m.ListMeta.Size()
	n += 1 + l + sovCmd(uint64(l))
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovCmd(uint64(l))
		}
	}
	return n
}

func (m *NodeSpec) Size() (n int) {
	var l int
	_ = l
	if len(m.Roles) > 0 {
		for _, s := range m.Roles {
			l = len(s)
			n += 1 + l + sovCmd(uint64(l))
		}
	}
	return n
}

func (m *NodeStatus) Size() (n int) {
	var l int
	_ = l
	l = len(m.Phase)
	if l > 0 {
		n += 1 + l + sovCmd(uint64(l))
	}
	if len(m.Conditions) > 0 {
		for _, e := range m.Conditions {
			l = e.Size()
			n += 1 + l + sovCmd(uint64(l))
		}
	}
	if len(m.Nics) > 0 {
		for _, s := range m.Nics {
			l = len(s)
			n += 1 + l + sovCmd(uint64(l))
		}
	}
	return n
}

func (m *PortCondition) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovCmd(uint64(l))
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovCmd(uint64(l))
	}
	l = len(m.LastTransitionTime)
	if l > 0 {
		n += 1 + l + sovCmd(uint64(l))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovCmd(uint64(l))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovCmd(uint64(l))
	}
	return n
}

func (m *PortSpec) Size() (n int) {
	var l int
	_ = l
	l = len(m.MacAddress)
	if l > 0 {
		n += 1 + l + sovCmd(uint64(l))
	}
	return n
}

func (m *PortStatus) Size() (n int) {
	var l int
	_ = l
	l = len(m.MacAddress)
	if l > 0 {
		n += 1 + l + sovCmd(uint64(l))
	}
	l = len(m.LinkSpeed)
	if l > 0 {
		n += 1 + l + sovCmd(uint64(l))
	}
	if len(m.Conditions) > 0 {
		for _, e := range m.Conditions {
			l = e.Size()
			n += 1 + l + sovCmd(uint64(l))
		}
	}
	return n
}

func (m *SmartNIC) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovCmd(uint64(l))
	l = m.ObjectMeta.Size()
	n += 1 + l + sovCmd(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovCmd(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovCmd(uint64(l))
	return n
}

func (m *SmartNICCondition) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovCmd(uint64(l))
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovCmd(uint64(l))
	}
	l = len(m.LastTransitionTime)
	if l > 0 {
		n += 1 + l + sovCmd(uint64(l))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovCmd(uint64(l))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovCmd(uint64(l))
	}
	return n
}

func (m *SmartNICList) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovCmd(uint64(l))
	l = m.ListMeta.Size()
	n += 1 + l + sovCmd(uint64(l))
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovCmd(uint64(l))
		}
	}
	return n
}

func (m *SmartNICSpec) Size() (n int) {
	var l int
	_ = l
	l = len(m.Phase)
	if l > 0 {
		n += 1 + l + sovCmd(uint64(l))
	}
	if len(m.Ports) > 0 {
		for _, e := range m.Ports {
			l = e.Size()
			n += 1 + l + sovCmd(uint64(l))
		}
	}
	return n
}

func (m *SmartNICStatus) Size() (n int) {
	var l int
	_ = l
	if len(m.Conditions) > 0 {
		for _, e := range m.Conditions {
			l = e.Size()
			n += 1 + l + sovCmd(uint64(l))
		}
	}
	l = len(m.SerialNum)
	if l > 0 {
		n += 1 + l + sovCmd(uint64(l))
	}
	l = len(m.PrimaryMacAddress)
	if l > 0 {
		n += 1 + l + sovCmd(uint64(l))
	}
	l = len(m.NodeName)
	if l > 0 {
		n += 1 + l + sovCmd(uint64(l))
	}
	if len(m.Ports) > 0 {
		for _, e := range m.Ports {
			l = e.Size()
			n += 1 + l + sovCmd(uint64(l))
		}
	}
	return n
}

func sovCmd(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozCmd(x uint64) (n int) {
	return sovCmd(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *AutoMsgClusterWatchHelper) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AutoMsgClusterWatchHelper: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AutoMsgClusterWatchHelper: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Object", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Object == nil {
				m.Object = &Cluster{}
			}
			if err := m.Object.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmd(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AutoMsgNodeWatchHelper) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AutoMsgNodeWatchHelper: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AutoMsgNodeWatchHelper: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Object", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Object == nil {
				m.Object = &Node{}
			}
			if err := m.Object.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmd(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AutoMsgSmartNICWatchHelper) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AutoMsgSmartNICWatchHelper: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AutoMsgSmartNICWatchHelper: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Object", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Object == nil {
				m.Object = &SmartNIC{}
			}
			if err := m.Object.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmd(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Cluster) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Cluster: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Cluster: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmd(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClusterList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClusterList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClusterList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ListMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &Cluster{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmd(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClusterSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClusterSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClusterSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QuorumNodes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QuorumNodes = append(m.QuorumNodes, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VirtualIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VirtualIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NTPServers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NTPServers = append(m.NTPServers, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DNSSubDomain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DNSSubDomain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoAdmitNICs", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AutoAdmitNICs = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCmd(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClusterStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClusterStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClusterStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Leader", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Leader = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmd(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Node) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Node: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Node: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmd(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeCondition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeCondition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeCondition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastTransitionTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastTransitionTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmd(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ListMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &Node{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmd(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Roles", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Roles = append(m.Roles, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmd(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phase", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Phase = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conditions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Conditions = append(m.Conditions, &NodeCondition{})
			if err := m.Conditions[len(m.Conditions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nics", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nics = append(m.Nics, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmd(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PortCondition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PortCondition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PortCondition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastTransitionTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastTransitionTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmd(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PortSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PortSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PortSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MacAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MacAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmd(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PortStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PortStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PortStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MacAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MacAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LinkSpeed", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LinkSpeed = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conditions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Conditions = append(m.Conditions, &PortCondition{})
			if err := m.Conditions[len(m.Conditions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmd(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SmartNIC) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SmartNIC: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SmartNIC: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmd(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SmartNICCondition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SmartNICCondition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SmartNICCondition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastTransitionTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastTransitionTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmd(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SmartNICList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SmartNICList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SmartNICList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ListMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &SmartNIC{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmd(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SmartNICSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SmartNICSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SmartNICSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phase", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Phase = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ports", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ports = append(m.Ports, PortSpec{})
			if err := m.Ports[len(m.Ports)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmd(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SmartNICStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SmartNICStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SmartNICStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conditions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Conditions = append(m.Conditions, &SmartNICCondition{})
			if err := m.Conditions[len(m.Conditions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SerialNum", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SerialNum = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrimaryMacAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrimaryMacAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ports", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ports = append(m.Ports, &PortStatus{})
			if err := m.Ports[len(m.Ports)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmd(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCmd(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCmd
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthCmd
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowCmd
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipCmd(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthCmd = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCmd   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("cmd.proto", fileDescriptorCmd) }

var fileDescriptorCmd = []byte{
	// 2069 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x59, 0xcd, 0x73, 0x1b, 0x49,
	0x15, 0xf7, 0x48, 0x96, 0x23, 0x3d, 0x5b, 0xb6, 0xdc, 0x71, 0x1c, 0x8d, 0xe2, 0xd8, 0x66, 0x60,
	0xb7, 0x1c, 0x63, 0x59, 0xc9, 0x66, 0xf9, 0x88, 0x2b, 0xd9, 0x2d, 0xc9, 0x52, 0x12, 0x6f, 0x64,
	0xc9, 0x91, 0x64, 0x07, 0x96, 0xa5, 0x60, 0x2c, 0x35, 0xce, 0xb0, 0x9a, 0x0f, 0x66, 0x7a, 0xb2,
	0x95, 0xa2, 0xb8, 0x20, 0x62, 0x8a, 0x82, 0xe5, 0x00, 0x29, 0xaa, 0x80, 0x5b, 0x8e, 0x3a, 0xf2,
	0x0f, 0x70, 0xcd, 0x71, 0x2b, 0x7b, 0x81, 0x3d, 0xb8, 0xa8, 0x14, 0x17, 0x7c, 0xe2, 0x0f, 0xe0,
	0x40, 0x75, 0xf7, 0x7c, 0xf4, 0x48, 0x72, 0x56, 0xb5, 0xb0, 0x7b, 0xda, 0x9b, 0xa6, 0xfb, 0xfd,
	0x7e, 0xfd, 0xfa, 0xf5, 0xef, 0xbd, 0x37, 0xd3, 0x82, 0x54, 0x5b, 0xef, 0x6c, 0x5a, 0xb6, 0x49,
	0x4c, 0x14, 0x6f, 0xeb, 0x9d, 0xdc, 0xd2, 0x91, 0x69, 0x1e, 0x75, 0x71, 0x41, 0xb5, 0xb4, 0x82,
	0x6a, 0x18, 0x26, 0x51, 0x89, 0x66, 0x1a, 0x0e, 0x37, 0xc9, 0x55, 0x8e, 0x34, 0xf2, 0xd0, 0x3d,
	0xdc, 0x6c, 0x9b, 0x7a, 0xc1, 0xc2, 0x86, 0xa3, 0x1a, 0x1d, 0xb3, 0xe0, 0x7c, 0x50, 0x78, 0x84,
	0x0d, 0xad, 0x8d, 0x0b, 0x2e, 0xd1, 0xba, 0x0e, 0x85, 0x1e, 0x61, 0x43, 0x44, 0x17, 0x34, 0xa3,
	0xdd, 0x75, 0x3b, 0xd8, 0xa7, 0xc9, 0x0b, 0x34, 0x47, 0xe6, 0x91, 0x59, 0x60, 0xc3, 0x87, 0xee,
	0x8f, 0xd8, 0x13, 0x7b, 0x60, 0xbf, 0x3c, 0xf3, 0xd7, 0xce, 0x58, 0x95, 0xfa, 0xa8, 0x63, 0xa2,
	0x72, 0x33, 0xe5, 0x3b, 0x20, 0x17, 0x5d, 0x62, 0xee, 0x3a, 0x47, 0xdb, 0x5d, 0xd7, 0x21, 0xd8,
	0x7e, 0xa0, 0x92, 0xf6, 0xc3, 0xbb, 0xb8, 0x6b, 0x61, 0x1b, 0xcd, 0xc0, 0x64, 0xeb, 0xb1, 0x85,
	0xb3, 0xd2, 0xaa, 0xb4, 0x96, 0x42, 0x4b, 0x30, 0x55, 0x3f, 0xfc, 0x31, 0x6e, 0x93, 0x6c, 0x6c,
	0x55, 0x5a, 0x9b, 0x7e, 0x63, 0x66, 0x93, 0x86, 0xc1, 0x83, 0x6d, 0xcd, 0x7d, 0xf2, 0x74, 0x61,
	0xfa, 0x03, 0x0a, 0x7e, 0xc8, 0xc0, 0x4a, 0x03, 0x16, 0x3d, 0xe6, 0x9a, 0xd9, 0xc1, 0x67, 0xd3,
	0xca, 0x03, 0xb4, 0x29, 0x46, 0x4b, 0x31, 0xc3, 0x9c, 0xef, 0x42, 0xce, 0xe3, 0x6c, 0xea, 0xaa,
	0x4d, 0x6a, 0x3b, 0xdb, 0x67, 0xf3, 0x5e, 0x1e, 0xe0, 0x4d, 0x33, 0x5e, 0x1f, 0x37, 0xcc, 0xfd,
	0xcb, 0x18, 0x9c, 0xf3, 0x36, 0x83, 0xae, 0x82, 0xd4, 0x62, 0x34, 0x14, 0xa6, 0x5a, 0xda, 0x26,
	0xe5, 0xdd, 0xc5, 0x44, 0x2d, 0x9d, 0x7f, 0x7e, 0xb2, 0x32, 0xf1, 0xd1, 0xc9, 0x8a, 0x74, 0x7a,
	0xb2, 0x72, 0x6e, 0x43, 0x33, 0xba, 0x9a, 0x81, 0x1b, 0x52, 0x0b, 0xdd, 0x00, 0xa9, 0xee, 0x2d,
	0x34, 0xc7, 0x10, 0x7c, 0x6d, 0x86, 0xc9, 0x09, 0x98, 0x59, 0x1a, 0xfb, 0x0d, 0x53, 0xd7, 0x08,
	0xd6, 0x2d, 0xf2, 0xb8, 0x21, 0xd5, 0xd1, 0x4d, 0x98, 0x6c, 0x5a, 0xb8, 0x9d, 0x8d, 0x33, 0x74,
	0x46, 0x8c, 0x2a, 0x1d, 0x2f, 0x2d, 0x52, 0x38, 0x85, 0x3a, 0x16, 0x6e, 0x0b, 0x50, 0x86, 0x42,
	0x65, 0x98, 0x6a, 0x12, 0x95, 0xb8, 0x4e, 0x76, 0x92, 0xe1, 0x51, 0x04, 0xcf, 0x66, 0x4a, 0x59,
	0x8f, 0x21, 0xe3, 0xb0, 0x67, 0x81, 0xc3, 0xc3, 0x6e, 0x4d, 0xbf, 0x78, 0x22, 0x9f, 0x6b, 0x73,
	0x90, 0xf2, 0x2b, 0x09, 0xa6, 0x3d, 0x82, 0xaa, 0xe6, 0x10, 0xa4, 0xd0, 0x68, 0xc4, 0x46, 0x45,
	0x23, 0xe9, 0xef, 0x0c, 0x5d, 0x81, 0x24, 0xb5, 0xa5, 0xa3, 0xde, 0x46, 0xb8, 0xa9, 0x3f, 0x28,
	0x98, 0x5e, 0x82, 0xc4, 0x0e, 0xc1, 0x3a, 0x75, 0x38, 0x3e, 0x24, 0xa3, 0xd9, 0x4f, 0x9e, 0x2e,
	0x40, 0x57, 0x73, 0x88, 0x77, 0x2a, 0x1f, 0xc7, 0x02, 0x5f, 0xd8, 0x76, 0x6f, 0xc2, 0xf4, 0x7d,
	0xd7, 0xb4, 0x5d, 0x9d, 0x0a, 0xc4, 0xc9, 0x4a, 0xab, 0xf1, 0xb5, 0x54, 0x29, 0x77, 0x7a, 0xb2,
	0xb2, 0xf8, 0x13, 0x36, 0x9c, 0x37, 0xe8, 0xb8, 0xb0, 0x43, 0xd1, 0x1c, 0x7d, 0x13, 0x52, 0x07,
	0x9a, 0x4d, 0x5c, 0xb5, 0xbb, 0xb3, 0xc7, 0x76, 0x94, 0x2a, 0x65, 0x4f, 0x4f, 0x56, 0x16, 0x1e,
	0xf1, 0xc1, 0xbc, 0x66, 0x09, 0xc8, 0xd0, 0x14, 0xdd, 0x00, 0xa8, 0xb5, 0xf6, 0x9a, 0xd8, 0x7e,
	0x84, 0x6d, 0x27, 0x1b, 0x67, 0x8b, 0xca, 0xa7, 0x27, 0x2b, 0x17, 0x0c, 0x62, 0xe5, 0x1d, 0x3e,
	0x2c, 0x20, 0x05, 0x63, 0xf4, 0x36, 0xcc, 0x94, 0x6b, 0xcd, 0xa6, 0x7b, 0x58, 0x36, 0x75, 0x55,
	0x33, 0xd8, 0x29, 0xa5, 0x4a, 0x97, 0x4e, 0x4f, 0x56, 0x2e, 0x76, 0x0c, 0x27, 0xef, 0xb8, 0x87,
	0x1d, 0x36, 0x21, 0xc0, 0x23, 0x00, 0xd4, 0x80, 0x34, 0xd5, 0x7c, 0xb1, 0xa3, 0x6b, 0x54, 0xb8,
	0x4e, 0x36, 0xb1, 0x2a, 0xad, 0x25, 0x4b, 0x1b, 0xa7, 0x27, 0x2b, 0x6b, 0xaa, 0x4b, 0xcc, 0xbc,
	0x4a, 0x67, 0xf2, 0x86, 0xd6, 0x76, 0x36, 0xd4, 0xc0, 0x90, 0x3e, 0xad, 0x86, 0x94, 0x51, 0x0a,
	0xe5, 0x16, 0xa4, 0x23, 0x0a, 0x41, 0x1b, 0x30, 0x55, 0xc5, 0x6a, 0x07, 0xdb, 0x3c, 0x79, 0x4a,
	0x0b, 0x54, 0x2d, 0x5d, 0x36, 0x22, 0xaa, 0x85, 0xdb, 0x28, 0xff, 0x91, 0x60, 0x92, 0x06, 0xf4,
	0x8b, 0xcd, 0x93, 0x1b, 0x91, 0x3c, 0x49, 0x07, 0x65, 0x62, 0x8c, 0x24, 0x29, 0x0e, 0x24, 0xc9,
	0x5c, 0x08, 0x1e, 0x37, 0x43, 0x52, 0x2f, 0x9e, 0xc8, 0x09, 0x26, 0x2e, 0xe5, 0xc3, 0x38, 0xa4,
	0x29, 0x76, 0xdb, 0x34, 0x3a, 0x1a, 0xad, 0xd5, 0xa8, 0x21, 0x56, 0x9e, 0xd2, 0x5b, 0xfd, 0x63,
	0xf9, 0x6b, 0x4d, 0x62, 0x57, 0x0c, 0x57, 0x5f, 0x8b, 0x18, 0x6e, 0x06, 0xbf, 0xa8, 0xf9, 0x95,
	0xe7, 0xde, 0x5e, 0xc9, 0x63, 0x0b, 0x8b, 0x3e, 0xd3, 0x49, 0x54, 0x0d, 0x7c, 0xe6, 0x42, 0x7d,
	0xb3, 0x7f, 0x2c, 0x67, 0x7d, 0xd6, 0x80, 0x87, 0x9b, 0xf8, 0x4c, 0x67, 0xba, 0x8f, 0x0e, 0x00,
	0x55, 0x55, 0x87, 0xb4, 0x6c, 0xd5, 0x70, 0xb8, 0x03, 0x9a, 0x8e, 0x59, 0x28, 0x53, 0xa5, 0xd7,
	0x3d, 0xf4, 0x72, 0x57, 0x75, 0x48, 0x9e, 0x04, 0x26, 0x79, 0xa2, 0xe9, 0xa2, 0x5f, 0x23, 0x18,
	0xd0, 0x55, 0x98, 0x6a, 0x60, 0xd5, 0x31, 0x7d, 0x61, 0x67, 0x7d, 0x4f, 0x6c, 0x36, 0x2a, 0x7a,
	0xc2, 0xed, 0xd0, 0x75, 0x38, 0xb7, 0x8b, 0x1d, 0x47, 0x3d, 0xc2, 0x4c, 0xc9, 0xa9, 0x92, 0xec,
	0x41, 0xe6, 0x75, 0x3e, 0x2c, 0x60, 0x7c, 0x4b, 0xe5, 0x12, 0xa4, 0x23, 0xa1, 0x43, 0x00, 0x53,
	0xd5, 0x4a, 0xb1, 0x5c, 0x69, 0x64, 0x26, 0x94, 0x9e, 0x04, 0x49, 0x1a, 0xe6, 0xcf, 0xa3, 0x58,
	0x65, 0xa3, 0xc5, 0x4a, 0x68, 0x4e, 0x83, 0x95, 0xea, 0x43, 0xcf, 0x0b, 0x26, 0xb8, 0x7b, 0x90,
	0x68, 0x98, 0xdd, 0xa0, 0x40, 0x7d, 0xa3, 0x7f, 0x2c, 0xe7, 0x44, 0x45, 0x50, 0x23, 0x46, 0x43,
	0xad, 0xfc, 0xd3, 0x9b, 0xb3, 0x29, 0x44, 0xd8, 0x3e, 0xe7, 0x50, 0xde, 0xe4, 0xc4, 0xf4, 0x01,
	0xcd, 0x02, 0x6c, 0xd7, 0x6b, 0xad, 0x46, 0xbd, 0x5a, 0xa5, 0x7b, 0x47, 0x33, 0x90, 0x7c, 0x50,
	0x6f, 0xdc, 0xab, 0xd6, 0x8b, 0xe5, 0x8c, 0x44, 0xa3, 0x72, 0x7f, 0xbf, 0xde, 0xd8, 0xdf, 0xcd,
	0xc4, 0x94, 0x3f, 0xc6, 0x00, 0x42, 0x85, 0xa3, 0x1a, 0x24, 0xf6, 0x1e, 0xaa, 0x8e, 0xaf, 0xd1,
	0x6f, 0xf7, 0x8f, 0xe5, 0xcb, 0x11, 0x8f, 0x98, 0x19, 0xf3, 0x89, 0xd9, 0x05, 0x4e, 0x59, 0xf4,
	0x49, 0x74, 0x8a, 0x4d, 0xa3, 0x3d, 0x80, 0xe0, 0x44, 0xa8, 0x44, 0xe3, 0x41, 0xef, 0x89, 0x28,
	0xbe, 0xb4, 0xe4, 0xf1, 0x2c, 0xb4, 0x03, 0x6b, 0xb1, 0x52, 0x86, 0x1c, 0x68, 0x1d, 0x26, 0x69,
	0xd9, 0xf2, 0xca, 0xeb, 0xa2, 0x9f, 0x1c, 0xac, 0xb0, 0x09, 0xc9, 0x41, 0x6d, 0x94, 0x5b, 0x90,
	0x0a, 0x3c, 0x45, 0xd3, 0x70, 0x6e, 0xbf, 0x76, 0xaf, 0x56, 0x7f, 0x50, 0xcb, 0x4c, 0xd0, 0x87,
	0xbd, 0x4a, 0xad, 0xbc, 0x53, 0xbb, 0xc3, 0xe3, 0xf1, 0x4e, 0x7d, 0xa7, 0x56, 0x29, 0x67, 0x62,
	0xf4, 0xf7, 0xed, 0xe2, 0x4e, 0xb5, 0x52, 0xce, 0xc4, 0x95, 0xdf, 0xc6, 0x21, 0xbd, 0x67, 0xda,
	0x64, 0xac, 0x0c, 0x8e, 0x18, 0x7e, 0x99, 0xc1, 0x9f, 0x31, 0x83, 0x97, 0x06, 0x33, 0x98, 0x1e,
	0x54, 0xbd, 0xd1, 0xfa, 0xc1, 0xfe, 0x5e, 0x66, 0x42, 0xd9, 0x81, 0x24, 0x0d, 0x33, 0xcb, 0x9d,
	0x5b, 0x00, 0xbb, 0x6a, 0xbb, 0xd8, 0xe9, 0xd8, 0xd8, 0x71, 0xbc, 0x03, 0xb9, 0xec, 0xad, 0x70,
	0x41, 0x57, 0xdb, 0x79, 0x95, 0x4f, 0x89, 0x32, 0x0a, 0x01, 0xca, 0xdf, 0x25, 0x00, 0xc6, 0xc5,
	0xc3, 0xf6, 0xbf, 0xb1, 0xa1, 0x2d, 0x48, 0x55, 0x35, 0xe3, 0xfd, 0xa6, 0x85, 0x71, 0xc7, 0x3b,
	0xc6, 0x40, 0xd1, 0x5d, 0xcd, 0x78, 0x3f, 0xef, 0xd0, 0x19, 0xf1, 0xad, 0x21, 0x30, 0x1f, 0x48,
	0x91, 0xb8, 0x90, 0x22, 0x11, 0x49, 0x8d, 0x9f, 0x22, 0xca, 0x6f, 0x62, 0x90, 0xf4, 0xdf, 0x60,
	0xbf, 0xd8, 0xe6, 0x7b, 0x2b, 0xd2, 0x7c, 0xe7, 0x23, 0xef, 0xd2, 0x63, 0x34, 0xe0, 0xca, 0x40,
	0x03, 0x3e, 0x1f, 0x25, 0x18, 0xb7, 0x09, 0xa7, 0x5f, 0x3c, 0x91, 0x53, 0x0e, 0x45, 0xd1, 0xaa,
	0xa0, 0xfc, 0x21, 0x0e, 0xf3, 0x3e, 0x47, 0x98, 0xca, 0x07, 0x91, 0x54, 0x2e, 0xf5, 0x8f, 0xe5,
	0x35, 0x3f, 0xe9, 0x86, 0x8c, 0xbf, 0x4c, 0xe7, 0xff, 0x63, 0x3a, 0xdf, 0xad, 0x14, 0xab, 0xad,
	0xbb, 0xdf, 0xcd, 0x4c, 0x28, 0xbf, 0x96, 0x60, 0xc6, 0x8f, 0xf5, 0xe7, 0xd1, 0x95, 0x97, 0xa2,
	0x5d, 0x79, 0xe0, 0xd3, 0x6e, 0xb0, 0x33, 0xff, 0x4b, 0xf0, 0x86, 0xa9, 0xb1, 0x15, 0xed, 0x85,
	0xb4, 0xda, 0x7f, 0x75, 0x50, 0x22, 0xac, 0x43, 0xfb, 0x0f, 0x63, 0x75, 0xc4, 0x9b, 0x90, 0xa0,
	0x79, 0xed, 0x37, 0xc3, 0x74, 0x90, 0xe9, 0x2c, 0x3f, 0x2e, 0x7a, 0xe2, 0x9e, 0xb3, 0xa8, 0x4d,
	0x04, 0x4d, 0x07, 0x94, 0x0a, 0xa4, 0x23, 0xab, 0x45, 0xbb, 0xda, 0x0c, 0x24, 0x1b, 0x95, 0x77,
	0x2a, 0xdb, 0xad, 0x0a, 0x6d, 0xf3, 0x42, 0x8f, 0x8b, 0xd1, 0xa9, 0x62, 0x79, 0x77, 0xa7, 0xd5,
	0x62, 0x9d, 0xed, 0xdf, 0x31, 0x98, 0x8d, 0xa6, 0x15, 0x6a, 0x45, 0xca, 0x90, 0xc4, 0x9c, 0x5b,
	0x8c, 0x44, 0xec, 0xb3, 0x74, 0xeb, 0x2d, 0x48, 0x35, 0xb1, 0xad, 0xa9, 0xdd, 0x9a, 0xab, 0x0f,
	0x16, 0x46, 0x87, 0x4d, 0xe4, 0x0d, 0x57, 0x17, 0x0b, 0x63, 0x60, 0x8e, 0x9a, 0x30, 0xbf, 0x67,
	0x6b, 0xba, 0x6a, 0x3f, 0x16, 0x4a, 0x33, 0x97, 0xfe, 0x6b, 0x1e, 0xc7, 0x65, 0x8b, 0x1b, 0xe4,
	0x47, 0x97, 0xe8, 0x61, 0x3c, 0xfa, 0x16, 0x7f, 0x4b, 0xaa, 0xa9, 0x3a, 0xf6, 0x3f, 0xb2, 0x3c,
	0xae, 0xf3, 0xf4, 0xb5, 0x3d, 0x6f, 0xa8, 0x91, 0xdc, 0x09, 0x8c, 0xd1, 0x5b, 0xfe, 0xb9, 0x25,
	0x58, 0x68, 0xe6, 0xc2, 0x73, 0xe3, 0x65, 0xe9, 0x62, 0x70, 0xee, 0x23, 0x4f, 0x6e, 0xfd, 0x3a,
	0xcc, 0x0d, 0x64, 0x7f, 0xf4, 0xec, 0x92, 0x30, 0xd9, 0x6a, 0xec, 0x57, 0x32, 0x12, 0x4a, 0x41,
	0xe2, 0x76, 0xb1, 0xda, 0xac, 0x64, 0x62, 0x6f, 0xfc, 0x75, 0x16, 0x12, 0xdb, 0x7a, 0xe7, 0xe0,
	0x1a, 0xba, 0x09, 0xb3, 0xfc, 0xe3, 0xac, 0xe3, 0xdf, 0x3e, 0x44, 0xbe, 0x88, 0x73, 0x91, 0x27,
	0x65, 0xf6, 0x6f, 0x4f, 0x17, 0xa4, 0xbf, 0xfc, 0x42, 0x9e, 0x6a, 0xdb, 0x58, 0x25, 0x18, 0xdd,
	0x86, 0x69, 0x0f, 0xcd, 0x3e, 0xc8, 0xc2, 0xf7, 0xd3, 0x5c, 0xf8, 0x53, 0xf9, 0x4a, 0x14, 0xf4,
	0xf3, 0x8f, 0xff, 0xf9, 0xfb, 0x58, 0x1a, 0x26, 0xb6, 0xa4, 0x75, 0x65, 0xaa, 0xc0, 0xbe, 0x69,
	0xd0, 0xdb, 0x30, 0xe7, 0xf1, 0x04, 0xfd, 0x25, 0x9a, 0x55, 0xb9, 0xe8, 0xe3, 0x90, 0x23, 0xef,
	0xc1, 0x3c, 0x25, 0x28, 0xe3, 0x2e, 0x26, 0x78, 0x9c, 0x9d, 0x7c, 0xdd, 0x27, 0xe8, 0x30, 0x08,
	0x73, 0xea, 0x22, 0x4c, 0x6c, 0x4d, 0xac, 0xcf, 0x17, 0xbc, 0x9b, 0x88, 0xc2, 0x4f, 0xeb, 0x9b,
	0xf4, 0x88, 0x7e, 0x86, 0xee, 0xf3, 0x20, 0x71, 0xf6, 0x57, 0xec, 0xf4, 0xca, 0x08, 0xd2, 0x0b,
	0x8c, 0x74, 0x8e, 0x6f, 0x34, 0xa4, 0x54, 0x01, 0x85, 0x94, 0x63, 0x6e, 0x3a, 0x3f, 0x82, 0x5e,
	0x66, 0xf4, 0xe7, 0x0b, 0x41, 0x5b, 0x0a, 0x97, 0x38, 0xe0, 0x5e, 0xdf, 0xc1, 0x64, 0x9c, 0x80,
	0xac, 0x79, 0xe4, 0xf1, 0x23, 0x4c, 0xc2, 0x68, 0xa0, 0x11, 0xd1, 0xb8, 0xc7, 0x0f, 0xfd, 0x0e,
	0x26, 0xaf, 0x08, 0xc5, 0xeb, 0x83, 0x74, 0x2c, 0x0e, 0x68, 0x28, 0x0e, 0xdf, 0xe3, 0x27, 0x7f,
	0x07, 0x93, 0x31, 0x83, 0xb0, 0x3e, 0x48, 0xcc, 0x22, 0x80, 0x46, 0x46, 0xe0, 0x3d, 0x4e, 0x4e,
	0x4b, 0xb8, 0x1f, 0x82, 0x0b, 0x41, 0x51, 0x67, 0x77, 0x77, 0x75, 0x8b, 0xd5, 0x93, 0x5c, 0xe4,
	0xde, 0x8b, 0xce, 0x2a, 0xab, 0xde, 0x3a, 0x93, 0xb4, 0x94, 0xb3, 0x85, 0x66, 0xd9, 0x42, 0x49,
	0x3f, 0x20, 0xa8, 0x05, 0x33, 0x3e, 0x3b, 0x0b, 0xc4, 0x19, 0xd4, 0xe1, 0x55, 0x01, 0xe3, 0x5d,
	0x1e, 0xe2, 0x9d, 0x61, 0xbc, 0x7e, 0x2a, 0xfc, 0x10, 0x32, 0x3e, 0x6b, 0x10, 0x91, 0x33, 0x98,
	0xa3, 0xef, 0x41, 0x8c, 0x5d, 0x19, 0x62, 0xcf, 0x30, 0x76, 0x08, 0xc3, 0x83, 0xbe, 0xcf, 0x73,
	0x65, 0xdf, 0xea, 0xa8, 0xe3, 0xe5, 0xca, 0x86, 0xaf, 0x3b, 0x97, 0x41, 0x18, 0x6d, 0x96, 0x25,
	0x70, 0x6e, 0x84, 0x3c, 0x1a, 0x5c, 0x76, 0x9c, 0xfe, 0x15, 0x0a, 0x59, 0x1f, 0xc1, 0xba, 0xc8,
	0x59, 0x87, 0x54, 0x72, 0xc8, 0xb3, 0x85, 0x73, 0x8e, 0x29, 0x94, 0xcd, 0x11, 0xfc, 0x39, 0xce,
	0x3f, 0x52, 0x2c, 0xef, 0xf2, 0xc0, 0xb3, 0x08, 0x7f, 0x8a, 0x5a, 0x96, 0xd9, 0x4a, 0x67, 0xde,
	0x5c, 0x2b, 0x69, 0x6f, 0xe9, 0x04, 0xbb, 0xe1, 0xbd, 0x2a, 0xa1, 0x16, 0xbf, 0x45, 0x63, 0x36,
	0xaf, 0xd2, 0xca, 0x25, 0x91, 0x78, 0xe0, 0xe2, 0x7a, 0x98, 0xd5, 0x2b, 0x7a, 0xcc, 0xe6, 0xd3,
	0xb4, 0xb2, 0x22, 0x32, 0x8f, 0xb8, 0xbe, 0x1e, 0x62, 0xcf, 0xfd, 0x39, 0xf6, 0xbb, 0x9e, 0x1c,
	0x7b, 0x74, 0xed, 0x4f, 0x3d, 0x39, 0xde, 0xd6, 0x3b, 0xcf, 0x7a, 0xb2, 0x7f, 0x41, 0xfd, 0xac,
	0x27, 0xb3, 0x0b, 0xb8, 0x67, 0x3d, 0x39, 0xf8, 0x1e, 0xe8, 0xf7, 0x64, 0x39, 0xbc, 0xc1, 0x66,
	0xf2, 0xcb, 0x05, 0xa9, 0xd2, 0xef, 0xc9, 0x9b, 0xe1, 0x64, 0xdc, 0x72, 0x09, 0xa2, 0xe9, 0x8b,
	0xbc, 0x42, 0x36, 0x42, 0x45, 0xfd, 0x9e, 0x7c, 0xc5, 0xbb, 0xe5, 0x1b, 0x36, 0x1f, 0x94, 0x47,
	0xbf, 0x27, 0xe7, 0x3c, 0xe3, 0x49, 0xcb, 0x74, 0x88, 0xb7, 0xbc, 0x97, 0x51, 0xfd, 0x9e, 0x7c,
	0x4d, 0xf8, 0x6e, 0x19, 0xa6, 0x1b, 0xa5, 0x86, 0x7e, 0x4f, 0x5e, 0x12, 0x40, 0x9c, 0x50, 0x48,
	0xa2, 0xd2, 0xcc, 0xf3, 0x97, 0xcb, 0xd2, 0x47, 0x2f, 0x97, 0xa5, 0x7f, 0xbc, 0x5c, 0x96, 0xf6,
	0xa4, 0xc3, 0x29, 0xf6, 0x87, 0xc6, 0xf5, 0xff, 0x06, 0x00, 0x00, 0xff, 0xff, 0x10, 0xa1, 0x4a,
	0x0c, 0x9d, 0x19, 0x00, 0x00,
}
