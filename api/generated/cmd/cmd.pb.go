// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: cmd.proto

/*
	Package cmd is a generated protocol buffer package.

	Service name

	It is generated from these files:
		cmd.proto

	It has these top-level messages:
		AutoMsgClusterWatchHelper
		AutoMsgNodeWatchHelper
		AutoMsgSmartNICWatchHelper
		Cluster
		ClusterList
		ClusterSpec
		ClusterStatus
		Node
		NodeCondition
		NodeList
		NodeSpec
		NodeStatus
		PortCondition
		PortSpec
		PortStatus
		SmartNIC
		SmartNICCondition
		SmartNICList
		SmartNICSpec
		SmartNICStatus
*/
package cmd

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/pensando/grpc-gateway/third_party/googleapis/google/api"
import _ "github.com/pensando/sw/utils/apigen/annotations"
import _ "github.com/gogo/protobuf/gogoproto"
import api "github.com/pensando/sw/api"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// NodeRole Type
type NodeRole int32

const (
	NodeRole_CONTROLLER_NODE NodeRole = 0
	NodeRole_WORKLOAD_NODE   NodeRole = 1
	NodeRole_QUORUM_NODE     NodeRole = 2
)

var NodeRole_name = map[int32]string{
	0: "CONTROLLER_NODE",
	1: "WORKLOAD_NODE",
	2: "QUORUM_NODE",
}
var NodeRole_value = map[string]int32{
	"CONTROLLER_NODE": 0,
	"WORKLOAD_NODE":   1,
	"QUORUM_NODE":     2,
}

func (x NodeRole) String() string {
	return proto.EnumName(NodeRole_name, int32(x))
}
func (NodeRole) EnumDescriptor() ([]byte, []int) { return fileDescriptorCmd, []int{0} }

// Various phases in lifecycle of a Node
type NodePhase int32

const (
	NodePhase_NODE_UNKNOWN NodePhase = 0
	NodePhase_NODE_PENDING NodePhase = 1
	NodePhase_NODE_JOINED  NodePhase = 2
	NodePhase_NODE_FAILED  NodePhase = 3
)

var NodePhase_name = map[int32]string{
	0: "NODE_UNKNOWN",
	1: "NODE_PENDING",
	2: "NODE_JOINED",
	3: "NODE_FAILED",
}
var NodePhase_value = map[string]int32{
	"NODE_UNKNOWN": 0,
	"NODE_PENDING": 1,
	"NODE_JOINED":  2,
	"NODE_FAILED":  3,
}

func (x NodePhase) String() string {
	return proto.EnumName(NodePhase_name, int32(x))
}
func (NodePhase) EnumDescriptor() ([]byte, []int) { return fileDescriptorCmd, []int{1} }

// These are valid conditions of a Node
type NodeConditionType int32

const (
	NodeConditionType_NODE_LEADER NodeConditionType = 0
)

var NodeConditionType_name = map[int32]string{
	0: "NODE_LEADER",
}
var NodeConditionType_value = map[string]int32{
	"NODE_LEADER": 0,
}

func (x NodeConditionType) String() string {
	return proto.EnumName(NodeConditionType_name, int32(x))
}
func (NodeConditionType) EnumDescriptor() ([]byte, []int) { return fileDescriptorCmd, []int{2} }

// These are valid condition statuses.
type ConditionStatus int32

const (
	ConditionStatus_CONDITION_UNKNOWN ConditionStatus = 0
	ConditionStatus_CONDITION_TRUE    ConditionStatus = 1
	ConditionStatus_CONDITION_FALSE   ConditionStatus = 2
)

var ConditionStatus_name = map[int32]string{
	0: "CONDITION_UNKNOWN",
	1: "CONDITION_TRUE",
	2: "CONDITION_FALSE",
}
var ConditionStatus_value = map[string]int32{
	"CONDITION_UNKNOWN": 0,
	"CONDITION_TRUE":    1,
	"CONDITION_FALSE":   2,
}

func (x ConditionStatus) String() string {
	return proto.EnumName(ConditionStatus_name, int32(x))
}
func (ConditionStatus) EnumDescriptor() ([]byte, []int) { return fileDescriptorCmd, []int{3} }

// Various phases in lifecycle of a SmartNIC
type SmartNICPhase int32

const (
	SmartNICPhase_NIC_UNKNOWN  SmartNICPhase = 0
	SmartNICPhase_NIC_REJECTED SmartNICPhase = 1
	SmartNICPhase_NIC_PENDING  SmartNICPhase = 2
	SmartNICPhase_NIC_ADMITTED SmartNICPhase = 3
)

var SmartNICPhase_name = map[int32]string{
	0: "NIC_UNKNOWN",
	1: "NIC_REJECTED",
	2: "NIC_PENDING",
	3: "NIC_ADMITTED",
}
var SmartNICPhase_value = map[string]int32{
	"NIC_UNKNOWN":  0,
	"NIC_REJECTED": 1,
	"NIC_PENDING":  2,
	"NIC_ADMITTED": 3,
}

func (x SmartNICPhase) String() string {
	return proto.EnumName(SmartNICPhase_name, int32(x))
}
func (SmartNICPhase) EnumDescriptor() ([]byte, []int) { return fileDescriptorCmd, []int{4} }

// These are valid conditions of a SmartNIC
type SmartNICConditionType int32

const (
	SmartNICConditionType_NIC_HEALTHY SmartNICConditionType = 0
)

var SmartNICConditionType_name = map[int32]string{
	0: "NIC_HEALTHY",
}
var SmartNICConditionType_value = map[string]int32{
	"NIC_HEALTHY": 0,
}

func (x SmartNICConditionType) String() string {
	return proto.EnumName(SmartNICConditionType_name, int32(x))
}
func (SmartNICConditionType) EnumDescriptor() ([]byte, []int) { return fileDescriptorCmd, []int{5} }

// These are valid conditions of a Port
type PortConditionType int32

const (
	PortConditionType_PORT_UP PortConditionType = 0
)

var PortConditionType_name = map[int32]string{
	0: "PORT_UP",
}
var PortConditionType_value = map[string]int32{
	"PORT_UP": 0,
}

func (x PortConditionType) String() string {
	return proto.EnumName(PortConditionType_name, int32(x))
}
func (PortConditionType) EnumDescriptor() ([]byte, []int) { return fileDescriptorCmd, []int{6} }

// --------------------------------- CLUSTER ---------------------------------------------
//
// Cluster represents a full cluster
//
// Entity responsible & scenarios involved in managing this object:
//
//      Create:
//          o NetOps-admin
//              - initial cluster creation
//      Modify:
//          o NetOps-admin
//              - update spec attributes
//          o CMD
//              - update status attributes
//      Delete:
//          o NetOps-admin
//              - TBD
//
type AutoMsgClusterWatchHelper struct {
	Type   string   `protobuf:"bytes,1,opt,name=Type,proto3" json:"Type,omitempty"`
	Object *Cluster `protobuf:"bytes,2,opt,name=Object" json:"Object,omitempty"`
}

func (m *AutoMsgClusterWatchHelper) Reset()                    { *m = AutoMsgClusterWatchHelper{} }
func (m *AutoMsgClusterWatchHelper) String() string            { return proto.CompactTextString(m) }
func (*AutoMsgClusterWatchHelper) ProtoMessage()               {}
func (*AutoMsgClusterWatchHelper) Descriptor() ([]byte, []int) { return fileDescriptorCmd, []int{0} }

func (m *AutoMsgClusterWatchHelper) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *AutoMsgClusterWatchHelper) GetObject() *Cluster {
	if m != nil {
		return m.Object
	}
	return nil
}

// ClusterSpec contains the configuration of the cluster.
type AutoMsgNodeWatchHelper struct {
	// QuorumNodes contains the list of hostnames for nodes configured to be quorum
	// nodes in the cluster.
	Type string `protobuf:"bytes,1,opt,name=Type,proto3" json:"Type,omitempty"`
	// VirtualIP is the IP address for managing the cluster. It will be hosted by
	// the winner of election between quorum nodes.
	Object *Node `protobuf:"bytes,2,opt,name=Object" json:"Object,omitempty"`
}

func (m *AutoMsgNodeWatchHelper) Reset()                    { *m = AutoMsgNodeWatchHelper{} }
func (m *AutoMsgNodeWatchHelper) String() string            { return proto.CompactTextString(m) }
func (*AutoMsgNodeWatchHelper) ProtoMessage()               {}
func (*AutoMsgNodeWatchHelper) Descriptor() ([]byte, []int) { return fileDescriptorCmd, []int{1} }

func (m *AutoMsgNodeWatchHelper) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *AutoMsgNodeWatchHelper) GetObject() *Node {
	if m != nil {
		return m.Object
	}
	return nil
}

// ClusterStatus contains the current state of the Cluster.
type AutoMsgSmartNICWatchHelper struct {
	// Leader contains the node name of the cluster leader.
	Type   string    `protobuf:"bytes,1,opt,name=Type,proto3" json:"Type,omitempty"`
	Object *SmartNIC `protobuf:"bytes,2,opt,name=Object" json:"Object,omitempty"`
}

func (m *AutoMsgSmartNICWatchHelper) Reset()                    { *m = AutoMsgSmartNICWatchHelper{} }
func (m *AutoMsgSmartNICWatchHelper) String() string            { return proto.CompactTextString(m) }
func (*AutoMsgSmartNICWatchHelper) ProtoMessage()               {}
func (*AutoMsgSmartNICWatchHelper) Descriptor() ([]byte, []int) { return fileDescriptorCmd, []int{2} }

func (m *AutoMsgSmartNICWatchHelper) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *AutoMsgSmartNICWatchHelper) GetObject() *SmartNIC {
	if m != nil {
		return m.Object
	}
	return nil
}

// ---------------------------------- NODE -------------------------------------------
//
// Node is representation of a single node in the system.
//
// Entity responsible & scenarios involved in managing this object:
//
//      Create:
//          o NetOps-admin
//              - initial node creation for Baremetal node
//          o CMD
//              - auto created when Hypervisor Node and NIC are
//                discovered via Orchestrator interface, NIC registration
//      Modify:
//          o NetOps-admin
//              - update spec for Baremetal node
//          o CMD
//              - update spec attributes for Hypervisor node
//              - update status attributes
//      Delete:
//          o NetOps-admin
//              - when Baremetal node is decommissioned
//          o CMD
//              - TBD
//
type Cluster struct {
	api.TypeMeta   `protobuf:"bytes,1,opt,name=T,embedded=T" json:",inline"`
	api.ObjectMeta `protobuf:"bytes,2,opt,name=O,embedded=O" json:"meta,omitempty"`
	// Spec contains the configuration of the node.
	Spec ClusterSpec `protobuf:"bytes,3,opt,name=Spec" json:"spec,omitempty"`
	// Status contains the current state of the node.
	Status ClusterStatus `protobuf:"bytes,4,opt,name=Status" json:"status,omitempty"`
}

func (m *Cluster) Reset()                    { *m = Cluster{} }
func (m *Cluster) String() string            { return proto.CompactTextString(m) }
func (*Cluster) ProtoMessage()               {}
func (*Cluster) Descriptor() ([]byte, []int) { return fileDescriptorCmd, []int{3} }

func (m *Cluster) GetSpec() ClusterSpec {
	if m != nil {
		return m.Spec
	}
	return ClusterSpec{}
}

func (m *Cluster) GetStatus() ClusterStatus {
	if m != nil {
		return m.Status
	}
	return ClusterStatus{}
}

// NodeSpec contains the configuration of the node.
type ClusterList struct {
	// Roles is of list of roles a node can be configured with.
	api.TypeMeta `protobuf:"bytes,2,opt,name=T,embedded=T" json:"T"`
	api.ListMeta `protobuf:"bytes,3,opt,name=ListMeta,embedded=ListMeta" json:"ListMeta"`
	Items        []*Cluster `protobuf:"bytes,4,rep,name=Items" json:"Items,omitempty"`
}

func (m *ClusterList) Reset()                    { *m = ClusterList{} }
func (m *ClusterList) String() string            { return proto.CompactTextString(m) }
func (*ClusterList) ProtoMessage()               {}
func (*ClusterList) Descriptor() ([]byte, []int) { return fileDescriptorCmd, []int{4} }

func (m *ClusterList) GetItems() []*Cluster {
	if m != nil {
		return m.Items
	}
	return nil
}

// NodeStatus contains the current state of the node.
type ClusterSpec struct {
	// Current lifecycle phase of the node.
	QuorumNodes []string `protobuf:"bytes,1,rep,name=QuorumNodes" json:"quorumNodes,omitempty"`
	// List of current node conditions
	VirtualIP string `protobuf:"bytes,2,opt,name=VirtualIP,proto3" json:"virtualIp,omitempty"`
	// Nics holds a list of Mac addresses each uniquely identifying
	// a SmartNIC subsystem that is part of the Node
	NTPServers   []string `protobuf:"bytes,3,rep,name=NTPServers" json:"ntpServers,omitempty"`
	DNSSubDomain string   `protobuf:"bytes,4,opt,name=DNSSubDomain,proto3" json:"dnsSubdomain,omitempty"`
}

func (m *ClusterSpec) Reset()                    { *m = ClusterSpec{} }
func (m *ClusterSpec) String() string            { return proto.CompactTextString(m) }
func (*ClusterSpec) ProtoMessage()               {}
func (*ClusterSpec) Descriptor() ([]byte, []int) { return fileDescriptorCmd, []int{5} }

func (m *ClusterSpec) GetQuorumNodes() []string {
	if m != nil {
		return m.QuorumNodes
	}
	return nil
}

func (m *ClusterSpec) GetVirtualIP() string {
	if m != nil {
		return m.VirtualIP
	}
	return ""
}

func (m *ClusterSpec) GetNTPServers() []string {
	if m != nil {
		return m.NTPServers
	}
	return nil
}

func (m *ClusterSpec) GetDNSSubDomain() string {
	if m != nil {
		return m.DNSSubDomain
	}
	return ""
}

// NodeCondition describes the state of a Node at a certain point.
type ClusterStatus struct {
	// Type indicates a certain node condition
	Leader string `protobuf:"bytes,1,opt,name=Leader,proto3" json:"leader,omitempty"`
}

func (m *ClusterStatus) Reset()                    { *m = ClusterStatus{} }
func (m *ClusterStatus) String() string            { return proto.CompactTextString(m) }
func (*ClusterStatus) ProtoMessage()               {}
func (*ClusterStatus) Descriptor() ([]byte, []int) { return fileDescriptorCmd, []int{6} }

func (m *ClusterStatus) GetLeader() string {
	if m != nil {
		return m.Leader
	}
	return ""
}

// ------------------------------------ SMART NIC  -------------------------------------------
//
// SmartNIC represents the Naples I/O subsystem
//
// Entity responsible & scenarios involved in managing this object:
//
//      Create:
//          o CMD
//              - created as part of NIC registration, Admittance
//      Modify:
//          o CMD
//              - update spec attributes
//              - update status attributes
//      Delete:
//          o CMD
//              - aging out stale or rejected NICs (TBD)
//          o NetOps, SecOps
//              - Decomission a NIC (TBD)
//
type Node struct {
	api.TypeMeta `protobuf:"bytes,1,opt,name=T,embedded=T" json:",inline"`
	// Object name is Serial-Number of the SmartNIC
	api.ObjectMeta `protobuf:"bytes,2,opt,name=O,embedded=O" json:"meta,omitempty"`
	// SmartNICSpec contains the configuration of the network adapter.
	Spec NodeSpec `protobuf:"bytes,3,opt,name=Spec" json:"spec,omitempty"`
	// SmartNICStatus contains the current state of the network adapter.
	Status NodeStatus `protobuf:"bytes,4,opt,name=Status" json:"status,omitempty"`
}

func (m *Node) Reset()                    { *m = Node{} }
func (m *Node) String() string            { return proto.CompactTextString(m) }
func (*Node) ProtoMessage()               {}
func (*Node) Descriptor() ([]byte, []int) { return fileDescriptorCmd, []int{7} }

func (m *Node) GetSpec() NodeSpec {
	if m != nil {
		return m.Spec
	}
	return NodeSpec{}
}

func (m *Node) GetStatus() NodeStatus {
	if m != nil {
		return m.Status
	}
	return NodeStatus{}
}

// SmartNICSpec contains configuration of the SmartNIC (Naples I/O subsystem)
type NodeCondition struct {
	// Ports holds a list of Port Specs
	Type               NodeConditionType `protobuf:"varint,1,opt,name=Type,proto3,enum=cmd.NodeConditionType" json:"type,omitempty"`
	Status             ConditionStatus   `protobuf:"varint,2,opt,name=Status,proto3,enum=cmd.ConditionStatus" json:"status,omitempty"`
	LastTransitionTime int64             `protobuf:"varint,3,opt,name=LastTransitionTime,proto3" json:"lastTransitionTime,omitempty"`
	Reason             string            `protobuf:"bytes,4,opt,name=Reason,proto3" json:"reason,omitempty"`
	Message            string            `protobuf:"bytes,5,opt,name=Message,proto3" json:"message,omitempty"`
}

func (m *NodeCondition) Reset()                    { *m = NodeCondition{} }
func (m *NodeCondition) String() string            { return proto.CompactTextString(m) }
func (*NodeCondition) ProtoMessage()               {}
func (*NodeCondition) Descriptor() ([]byte, []int) { return fileDescriptorCmd, []int{8} }

func (m *NodeCondition) GetType() NodeConditionType {
	if m != nil {
		return m.Type
	}
	return NodeConditionType_NODE_LEADER
}

func (m *NodeCondition) GetStatus() ConditionStatus {
	if m != nil {
		return m.Status
	}
	return ConditionStatus_CONDITION_UNKNOWN
}

func (m *NodeCondition) GetLastTransitionTime() int64 {
	if m != nil {
		return m.LastTransitionTime
	}
	return 0
}

func (m *NodeCondition) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

func (m *NodeCondition) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

// SmartNICStatus contains current status of a SmartNIC
type NodeList struct {
	// Current lifecycle phase of the SmartNIC.
	api.TypeMeta `protobuf:"bytes,2,opt,name=T,embedded=T" json:"T"`
	// List of current NIC conditions
	api.ListMeta `protobuf:"bytes,3,opt,name=ListMeta,embedded=ListMeta" json:"ListMeta"`
	// Serial number
	Items []*Node `protobuf:"bytes,4,rep,name=Items" json:"Items,omitempty"`
}

func (m *NodeList) Reset()                    { *m = NodeList{} }
func (m *NodeList) String() string            { return proto.CompactTextString(m) }
func (*NodeList) ProtoMessage()               {}
func (*NodeList) Descriptor() ([]byte, []int) { return fileDescriptorCmd, []int{9} }

func (m *NodeList) GetItems() []*Node {
	if m != nil {
		return m.Items
	}
	return nil
}

// SmartNICCondition describes the state of a SmartNIC at a certain point.
type NodeSpec struct {
	// Type indicates a certain NIC condition
	Roles []NodeRole `protobuf:"varint,1,rep,packed,name=Roles,enum=cmd.NodeRole" json:"roles,omitempty"`
}

func (m *NodeSpec) Reset()                    { *m = NodeSpec{} }
func (m *NodeSpec) String() string            { return proto.CompactTextString(m) }
func (*NodeSpec) ProtoMessage()               {}
func (*NodeSpec) Descriptor() ([]byte, []int) { return fileDescriptorCmd, []int{10} }

func (m *NodeSpec) GetRoles() []NodeRole {
	if m != nil {
		return m.Roles
	}
	return nil
}

// PortSpec contains configuration of a port in SmartNIC
type NodeStatus struct {
	// Mac address of the Port, which is key identifier of the port
	Phase      NodePhase        `protobuf:"varint,1,opt,name=Phase,proto3,enum=cmd.NodePhase" json:"phase,omitempty"`
	Conditions []*NodeCondition `protobuf:"bytes,2,rep,name=Conditions" json:"conditions,omitempty"`
	Nics       []string         `protobuf:"bytes,3,rep,name=Nics" json:"nics,omitempty"`
}

func (m *NodeStatus) Reset()                    { *m = NodeStatus{} }
func (m *NodeStatus) String() string            { return proto.CompactTextString(m) }
func (*NodeStatus) ProtoMessage()               {}
func (*NodeStatus) Descriptor() ([]byte, []int) { return fileDescriptorCmd, []int{11} }

func (m *NodeStatus) GetPhase() NodePhase {
	if m != nil {
		return m.Phase
	}
	return NodePhase_NODE_UNKNOWN
}

func (m *NodeStatus) GetConditions() []*NodeCondition {
	if m != nil {
		return m.Conditions
	}
	return nil
}

func (m *NodeStatus) GetNics() []string {
	if m != nil {
		return m.Nics
	}
	return nil
}

// PortStatus contains current status of a Port
type PortCondition struct {
	// Mac address of the Port, which is key identifier of the port
	Type PortConditionType `protobuf:"varint,1,opt,name=Type,proto3,enum=cmd.PortConditionType" json:"type,omitempty"`
	// LinkSpeed of the Port
	Status ConditionStatus `protobuf:"varint,2,opt,name=Status,proto3,enum=cmd.ConditionStatus" json:"status,omitempty"`
	// List of current Port conditions
	LastTransitionTime int64  `protobuf:"varint,3,opt,name=LastTransitionTime,proto3" json:"lastTransitionTime,omitempty"`
	Reason             string `protobuf:"bytes,4,opt,name=Reason,proto3" json:"reason,omitempty"`
	Message            string `protobuf:"bytes,5,opt,name=Message,proto3" json:"message,omitempty"`
}

func (m *PortCondition) Reset()                    { *m = PortCondition{} }
func (m *PortCondition) String() string            { return proto.CompactTextString(m) }
func (*PortCondition) ProtoMessage()               {}
func (*PortCondition) Descriptor() ([]byte, []int) { return fileDescriptorCmd, []int{12} }

func (m *PortCondition) GetType() PortConditionType {
	if m != nil {
		return m.Type
	}
	return PortConditionType_PORT_UP
}

func (m *PortCondition) GetStatus() ConditionStatus {
	if m != nil {
		return m.Status
	}
	return ConditionStatus_CONDITION_UNKNOWN
}

func (m *PortCondition) GetLastTransitionTime() int64 {
	if m != nil {
		return m.LastTransitionTime
	}
	return 0
}

func (m *PortCondition) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

func (m *PortCondition) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

// PortCondition describes the state of a Port at a certain point.
type PortSpec struct {
	// Type indicates a certain Port condition
	MacAddress string `protobuf:"bytes,1,opt,name=MacAddress,proto3" json:"macAddress,omitempty"`
}

func (m *PortSpec) Reset()                    { *m = PortSpec{} }
func (m *PortSpec) String() string            { return proto.CompactTextString(m) }
func (*PortSpec) ProtoMessage()               {}
func (*PortSpec) Descriptor() ([]byte, []int) { return fileDescriptorCmd, []int{13} }

func (m *PortSpec) GetMacAddress() string {
	if m != nil {
		return m.MacAddress
	}
	return ""
}

type PortStatus struct {
	MacAddress string           `protobuf:"bytes,1,opt,name=MacAddress,proto3" json:"macAddress,omitempty"`
	LinkSpeed  string           `protobuf:"bytes,2,opt,name=LinkSpeed,proto3" json:"linkSpeed,omitempty"`
	Conditions []*PortCondition `protobuf:"bytes,3,rep,name=Conditions" json:"conditions,omitempty"`
}

func (m *PortStatus) Reset()                    { *m = PortStatus{} }
func (m *PortStatus) String() string            { return proto.CompactTextString(m) }
func (*PortStatus) ProtoMessage()               {}
func (*PortStatus) Descriptor() ([]byte, []int) { return fileDescriptorCmd, []int{14} }

func (m *PortStatus) GetMacAddress() string {
	if m != nil {
		return m.MacAddress
	}
	return ""
}

func (m *PortStatus) GetLinkSpeed() string {
	if m != nil {
		return m.LinkSpeed
	}
	return ""
}

func (m *PortStatus) GetConditions() []*PortCondition {
	if m != nil {
		return m.Conditions
	}
	return nil
}

type SmartNIC struct {
	api.TypeMeta   `protobuf:"bytes,1,opt,name=T,embedded=T" json:",inline"`
	api.ObjectMeta `protobuf:"bytes,2,opt,name=O,embedded=O" json:"meta,omitempty"`
	Spec           SmartNICSpec   `protobuf:"bytes,3,opt,name=Spec" json:"spec,omitempty"`
	Status         SmartNICStatus `protobuf:"bytes,4,opt,name=Status" json:"status,omitempty"`
}

func (m *SmartNIC) Reset()                    { *m = SmartNIC{} }
func (m *SmartNIC) String() string            { return proto.CompactTextString(m) }
func (*SmartNIC) ProtoMessage()               {}
func (*SmartNIC) Descriptor() ([]byte, []int) { return fileDescriptorCmd, []int{15} }

func (m *SmartNIC) GetSpec() SmartNICSpec {
	if m != nil {
		return m.Spec
	}
	return SmartNICSpec{}
}

func (m *SmartNIC) GetStatus() SmartNICStatus {
	if m != nil {
		return m.Status
	}
	return SmartNICStatus{}
}

type SmartNICCondition struct {
	Type               SmartNICConditionType `protobuf:"varint,1,opt,name=Type,proto3,enum=cmd.SmartNICConditionType" json:"type,omitempty"`
	Status             ConditionStatus       `protobuf:"varint,2,opt,name=Status,proto3,enum=cmd.ConditionStatus" json:"status,omitempty"`
	LastTransitionTime int64                 `protobuf:"varint,3,opt,name=LastTransitionTime,proto3" json:"lastTransitionTime,omitempty"`
	Reason             string                `protobuf:"bytes,4,opt,name=Reason,proto3" json:"reason,omitempty"`
	Message            string                `protobuf:"bytes,5,opt,name=Message,proto3" json:"message,omitempty"`
}

func (m *SmartNICCondition) Reset()                    { *m = SmartNICCondition{} }
func (m *SmartNICCondition) String() string            { return proto.CompactTextString(m) }
func (*SmartNICCondition) ProtoMessage()               {}
func (*SmartNICCondition) Descriptor() ([]byte, []int) { return fileDescriptorCmd, []int{16} }

func (m *SmartNICCondition) GetType() SmartNICConditionType {
	if m != nil {
		return m.Type
	}
	return SmartNICConditionType_NIC_HEALTHY
}

func (m *SmartNICCondition) GetStatus() ConditionStatus {
	if m != nil {
		return m.Status
	}
	return ConditionStatus_CONDITION_UNKNOWN
}

func (m *SmartNICCondition) GetLastTransitionTime() int64 {
	if m != nil {
		return m.LastTransitionTime
	}
	return 0
}

func (m *SmartNICCondition) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

func (m *SmartNICCondition) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

type SmartNICList struct {
	api.TypeMeta `protobuf:"bytes,2,opt,name=T,embedded=T" json:"T"`
	api.ListMeta `protobuf:"bytes,3,opt,name=ListMeta,embedded=ListMeta" json:"ListMeta"`
	Items        []*SmartNIC `protobuf:"bytes,4,rep,name=Items" json:"Items,omitempty"`
}

func (m *SmartNICList) Reset()                    { *m = SmartNICList{} }
func (m *SmartNICList) String() string            { return proto.CompactTextString(m) }
func (*SmartNICList) ProtoMessage()               {}
func (*SmartNICList) Descriptor() ([]byte, []int) { return fileDescriptorCmd, []int{17} }

func (m *SmartNICList) GetItems() []*SmartNIC {
	if m != nil {
		return m.Items
	}
	return nil
}

type SmartNICSpec struct {
	Ports []PortSpec `protobuf:"bytes,1,rep,name=Ports" json:"ports,omitempty"`
}

func (m *SmartNICSpec) Reset()                    { *m = SmartNICSpec{} }
func (m *SmartNICSpec) String() string            { return proto.CompactTextString(m) }
func (*SmartNICSpec) ProtoMessage()               {}
func (*SmartNICSpec) Descriptor() ([]byte, []int) { return fileDescriptorCmd, []int{18} }

func (m *SmartNICSpec) GetPorts() []PortSpec {
	if m != nil {
		return m.Ports
	}
	return nil
}

type SmartNICStatus struct {
	Phase             SmartNICPhase        `protobuf:"varint,1,opt,name=Phase,proto3,enum=cmd.SmartNICPhase" json:"phase,omitempty"`
	Conditions        []*SmartNICCondition `protobuf:"bytes,2,rep,name=Conditions" json:"conditions,omitempty"`
	SerialNum         string               `protobuf:"bytes,3,opt,name=SerialNum,proto3" json:"serialNumber,omitempty"`
	PrimaryMacAddress string               `protobuf:"bytes,4,opt,name=PrimaryMacAddress,proto3" json:"primaryMacAddress,omitempty"`
	NodeName          string               `protobuf:"bytes,5,opt,name=NodeName,proto3" json:"nodeName,omitempty"`
	Ports             []*PortStatus        `protobuf:"bytes,6,rep,name=Ports" json:"ports,omitempty"`
}

func (m *SmartNICStatus) Reset()                    { *m = SmartNICStatus{} }
func (m *SmartNICStatus) String() string            { return proto.CompactTextString(m) }
func (*SmartNICStatus) ProtoMessage()               {}
func (*SmartNICStatus) Descriptor() ([]byte, []int) { return fileDescriptorCmd, []int{19} }

func (m *SmartNICStatus) GetPhase() SmartNICPhase {
	if m != nil {
		return m.Phase
	}
	return SmartNICPhase_NIC_UNKNOWN
}

func (m *SmartNICStatus) GetConditions() []*SmartNICCondition {
	if m != nil {
		return m.Conditions
	}
	return nil
}

func (m *SmartNICStatus) GetSerialNum() string {
	if m != nil {
		return m.SerialNum
	}
	return ""
}

func (m *SmartNICStatus) GetPrimaryMacAddress() string {
	if m != nil {
		return m.PrimaryMacAddress
	}
	return ""
}

func (m *SmartNICStatus) GetNodeName() string {
	if m != nil {
		return m.NodeName
	}
	return ""
}

func (m *SmartNICStatus) GetPorts() []*PortStatus {
	if m != nil {
		return m.Ports
	}
	return nil
}

func init() {
	proto.RegisterType((*AutoMsgClusterWatchHelper)(nil), "cmd.AutoMsgClusterWatchHelper")
	proto.RegisterType((*AutoMsgNodeWatchHelper)(nil), "cmd.AutoMsgNodeWatchHelper")
	proto.RegisterType((*AutoMsgSmartNICWatchHelper)(nil), "cmd.AutoMsgSmartNICWatchHelper")
	proto.RegisterType((*Cluster)(nil), "cmd.Cluster")
	proto.RegisterType((*ClusterList)(nil), "cmd.ClusterList")
	proto.RegisterType((*ClusterSpec)(nil), "cmd.ClusterSpec")
	proto.RegisterType((*ClusterStatus)(nil), "cmd.ClusterStatus")
	proto.RegisterType((*Node)(nil), "cmd.Node")
	proto.RegisterType((*NodeCondition)(nil), "cmd.NodeCondition")
	proto.RegisterType((*NodeList)(nil), "cmd.NodeList")
	proto.RegisterType((*NodeSpec)(nil), "cmd.NodeSpec")
	proto.RegisterType((*NodeStatus)(nil), "cmd.NodeStatus")
	proto.RegisterType((*PortCondition)(nil), "cmd.PortCondition")
	proto.RegisterType((*PortSpec)(nil), "cmd.PortSpec")
	proto.RegisterType((*PortStatus)(nil), "cmd.PortStatus")
	proto.RegisterType((*SmartNIC)(nil), "cmd.SmartNIC")
	proto.RegisterType((*SmartNICCondition)(nil), "cmd.SmartNICCondition")
	proto.RegisterType((*SmartNICList)(nil), "cmd.SmartNICList")
	proto.RegisterType((*SmartNICSpec)(nil), "cmd.SmartNICSpec")
	proto.RegisterType((*SmartNICStatus)(nil), "cmd.SmartNICStatus")
	proto.RegisterEnum("cmd.NodeRole", NodeRole_name, NodeRole_value)
	proto.RegisterEnum("cmd.NodePhase", NodePhase_name, NodePhase_value)
	proto.RegisterEnum("cmd.NodeConditionType", NodeConditionType_name, NodeConditionType_value)
	proto.RegisterEnum("cmd.ConditionStatus", ConditionStatus_name, ConditionStatus_value)
	proto.RegisterEnum("cmd.SmartNICPhase", SmartNICPhase_name, SmartNICPhase_value)
	proto.RegisterEnum("cmd.SmartNICConditionType", SmartNICConditionType_name, SmartNICConditionType_value)
	proto.RegisterEnum("cmd.PortConditionType", PortConditionType_name, PortConditionType_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for CmdV1 service

type CmdV1Client interface {
	AutoAddCluster(ctx context.Context, in *Cluster, opts ...grpc.CallOption) (*Cluster, error)
	AutoAddNode(ctx context.Context, in *Node, opts ...grpc.CallOption) (*Node, error)
	AutoAddSmartNIC(ctx context.Context, in *SmartNIC, opts ...grpc.CallOption) (*SmartNIC, error)
	AutoDeleteCluster(ctx context.Context, in *Cluster, opts ...grpc.CallOption) (*Cluster, error)
	AutoDeleteNode(ctx context.Context, in *Node, opts ...grpc.CallOption) (*Node, error)
	AutoDeleteSmartNIC(ctx context.Context, in *SmartNIC, opts ...grpc.CallOption) (*SmartNIC, error)
	AutoGetCluster(ctx context.Context, in *Cluster, opts ...grpc.CallOption) (*Cluster, error)
	AutoGetNode(ctx context.Context, in *Node, opts ...grpc.CallOption) (*Node, error)
	AutoGetSmartNIC(ctx context.Context, in *SmartNIC, opts ...grpc.CallOption) (*SmartNIC, error)
	AutoListCluster(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (*ClusterList, error)
	AutoListNode(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (*NodeList, error)
	AutoListSmartNIC(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (*SmartNICList, error)
	AutoUpdateCluster(ctx context.Context, in *Cluster, opts ...grpc.CallOption) (*Cluster, error)
	AutoUpdateNode(ctx context.Context, in *Node, opts ...grpc.CallOption) (*Node, error)
	AutoUpdateSmartNIC(ctx context.Context, in *SmartNIC, opts ...grpc.CallOption) (*SmartNIC, error)
	AutoWatchCluster(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (CmdV1_AutoWatchClusterClient, error)
	AutoWatchNode(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (CmdV1_AutoWatchNodeClient, error)
	AutoWatchSmartNIC(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (CmdV1_AutoWatchSmartNICClient, error)
}

type cmdV1Client struct {
	cc *grpc.ClientConn
}

func NewCmdV1Client(cc *grpc.ClientConn) CmdV1Client {
	return &cmdV1Client{cc}
}

func (c *cmdV1Client) AutoAddCluster(ctx context.Context, in *Cluster, opts ...grpc.CallOption) (*Cluster, error) {
	out := new(Cluster)
	err := grpc.Invoke(ctx, "/cmd.CmdV1/AutoAddCluster", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cmdV1Client) AutoAddNode(ctx context.Context, in *Node, opts ...grpc.CallOption) (*Node, error) {
	out := new(Node)
	err := grpc.Invoke(ctx, "/cmd.CmdV1/AutoAddNode", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cmdV1Client) AutoAddSmartNIC(ctx context.Context, in *SmartNIC, opts ...grpc.CallOption) (*SmartNIC, error) {
	out := new(SmartNIC)
	err := grpc.Invoke(ctx, "/cmd.CmdV1/AutoAddSmartNIC", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cmdV1Client) AutoDeleteCluster(ctx context.Context, in *Cluster, opts ...grpc.CallOption) (*Cluster, error) {
	out := new(Cluster)
	err := grpc.Invoke(ctx, "/cmd.CmdV1/AutoDeleteCluster", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cmdV1Client) AutoDeleteNode(ctx context.Context, in *Node, opts ...grpc.CallOption) (*Node, error) {
	out := new(Node)
	err := grpc.Invoke(ctx, "/cmd.CmdV1/AutoDeleteNode", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cmdV1Client) AutoDeleteSmartNIC(ctx context.Context, in *SmartNIC, opts ...grpc.CallOption) (*SmartNIC, error) {
	out := new(SmartNIC)
	err := grpc.Invoke(ctx, "/cmd.CmdV1/AutoDeleteSmartNIC", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cmdV1Client) AutoGetCluster(ctx context.Context, in *Cluster, opts ...grpc.CallOption) (*Cluster, error) {
	out := new(Cluster)
	err := grpc.Invoke(ctx, "/cmd.CmdV1/AutoGetCluster", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cmdV1Client) AutoGetNode(ctx context.Context, in *Node, opts ...grpc.CallOption) (*Node, error) {
	out := new(Node)
	err := grpc.Invoke(ctx, "/cmd.CmdV1/AutoGetNode", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cmdV1Client) AutoGetSmartNIC(ctx context.Context, in *SmartNIC, opts ...grpc.CallOption) (*SmartNIC, error) {
	out := new(SmartNIC)
	err := grpc.Invoke(ctx, "/cmd.CmdV1/AutoGetSmartNIC", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cmdV1Client) AutoListCluster(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (*ClusterList, error) {
	out := new(ClusterList)
	err := grpc.Invoke(ctx, "/cmd.CmdV1/AutoListCluster", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cmdV1Client) AutoListNode(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (*NodeList, error) {
	out := new(NodeList)
	err := grpc.Invoke(ctx, "/cmd.CmdV1/AutoListNode", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cmdV1Client) AutoListSmartNIC(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (*SmartNICList, error) {
	out := new(SmartNICList)
	err := grpc.Invoke(ctx, "/cmd.CmdV1/AutoListSmartNIC", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cmdV1Client) AutoUpdateCluster(ctx context.Context, in *Cluster, opts ...grpc.CallOption) (*Cluster, error) {
	out := new(Cluster)
	err := grpc.Invoke(ctx, "/cmd.CmdV1/AutoUpdateCluster", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cmdV1Client) AutoUpdateNode(ctx context.Context, in *Node, opts ...grpc.CallOption) (*Node, error) {
	out := new(Node)
	err := grpc.Invoke(ctx, "/cmd.CmdV1/AutoUpdateNode", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cmdV1Client) AutoUpdateSmartNIC(ctx context.Context, in *SmartNIC, opts ...grpc.CallOption) (*SmartNIC, error) {
	out := new(SmartNIC)
	err := grpc.Invoke(ctx, "/cmd.CmdV1/AutoUpdateSmartNIC", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cmdV1Client) AutoWatchCluster(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (CmdV1_AutoWatchClusterClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_CmdV1_serviceDesc.Streams[0], c.cc, "/cmd.CmdV1/AutoWatchCluster", opts...)
	if err != nil {
		return nil, err
	}
	x := &cmdV1AutoWatchClusterClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type CmdV1_AutoWatchClusterClient interface {
	Recv() (*AutoMsgClusterWatchHelper, error)
	grpc.ClientStream
}

type cmdV1AutoWatchClusterClient struct {
	grpc.ClientStream
}

func (x *cmdV1AutoWatchClusterClient) Recv() (*AutoMsgClusterWatchHelper, error) {
	m := new(AutoMsgClusterWatchHelper)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *cmdV1Client) AutoWatchNode(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (CmdV1_AutoWatchNodeClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_CmdV1_serviceDesc.Streams[1], c.cc, "/cmd.CmdV1/AutoWatchNode", opts...)
	if err != nil {
		return nil, err
	}
	x := &cmdV1AutoWatchNodeClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type CmdV1_AutoWatchNodeClient interface {
	Recv() (*AutoMsgNodeWatchHelper, error)
	grpc.ClientStream
}

type cmdV1AutoWatchNodeClient struct {
	grpc.ClientStream
}

func (x *cmdV1AutoWatchNodeClient) Recv() (*AutoMsgNodeWatchHelper, error) {
	m := new(AutoMsgNodeWatchHelper)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *cmdV1Client) AutoWatchSmartNIC(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (CmdV1_AutoWatchSmartNICClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_CmdV1_serviceDesc.Streams[2], c.cc, "/cmd.CmdV1/AutoWatchSmartNIC", opts...)
	if err != nil {
		return nil, err
	}
	x := &cmdV1AutoWatchSmartNICClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type CmdV1_AutoWatchSmartNICClient interface {
	Recv() (*AutoMsgSmartNICWatchHelper, error)
	grpc.ClientStream
}

type cmdV1AutoWatchSmartNICClient struct {
	grpc.ClientStream
}

func (x *cmdV1AutoWatchSmartNICClient) Recv() (*AutoMsgSmartNICWatchHelper, error) {
	m := new(AutoMsgSmartNICWatchHelper)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for CmdV1 service

type CmdV1Server interface {
	AutoAddCluster(context.Context, *Cluster) (*Cluster, error)
	AutoAddNode(context.Context, *Node) (*Node, error)
	AutoAddSmartNIC(context.Context, *SmartNIC) (*SmartNIC, error)
	AutoDeleteCluster(context.Context, *Cluster) (*Cluster, error)
	AutoDeleteNode(context.Context, *Node) (*Node, error)
	AutoDeleteSmartNIC(context.Context, *SmartNIC) (*SmartNIC, error)
	AutoGetCluster(context.Context, *Cluster) (*Cluster, error)
	AutoGetNode(context.Context, *Node) (*Node, error)
	AutoGetSmartNIC(context.Context, *SmartNIC) (*SmartNIC, error)
	AutoListCluster(context.Context, *api.ListWatchOptions) (*ClusterList, error)
	AutoListNode(context.Context, *api.ListWatchOptions) (*NodeList, error)
	AutoListSmartNIC(context.Context, *api.ListWatchOptions) (*SmartNICList, error)
	AutoUpdateCluster(context.Context, *Cluster) (*Cluster, error)
	AutoUpdateNode(context.Context, *Node) (*Node, error)
	AutoUpdateSmartNIC(context.Context, *SmartNIC) (*SmartNIC, error)
	AutoWatchCluster(*api.ListWatchOptions, CmdV1_AutoWatchClusterServer) error
	AutoWatchNode(*api.ListWatchOptions, CmdV1_AutoWatchNodeServer) error
	AutoWatchSmartNIC(*api.ListWatchOptions, CmdV1_AutoWatchSmartNICServer) error
}

func RegisterCmdV1Server(s *grpc.Server, srv CmdV1Server) {
	s.RegisterService(&_CmdV1_serviceDesc, srv)
}

func _CmdV1_AutoAddCluster_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Cluster)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CmdV1Server).AutoAddCluster(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cmd.CmdV1/AutoAddCluster",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CmdV1Server).AutoAddCluster(ctx, req.(*Cluster))
	}
	return interceptor(ctx, in, info, handler)
}

func _CmdV1_AutoAddNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Node)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CmdV1Server).AutoAddNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cmd.CmdV1/AutoAddNode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CmdV1Server).AutoAddNode(ctx, req.(*Node))
	}
	return interceptor(ctx, in, info, handler)
}

func _CmdV1_AutoAddSmartNIC_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SmartNIC)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CmdV1Server).AutoAddSmartNIC(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cmd.CmdV1/AutoAddSmartNIC",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CmdV1Server).AutoAddSmartNIC(ctx, req.(*SmartNIC))
	}
	return interceptor(ctx, in, info, handler)
}

func _CmdV1_AutoDeleteCluster_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Cluster)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CmdV1Server).AutoDeleteCluster(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cmd.CmdV1/AutoDeleteCluster",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CmdV1Server).AutoDeleteCluster(ctx, req.(*Cluster))
	}
	return interceptor(ctx, in, info, handler)
}

func _CmdV1_AutoDeleteNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Node)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CmdV1Server).AutoDeleteNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cmd.CmdV1/AutoDeleteNode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CmdV1Server).AutoDeleteNode(ctx, req.(*Node))
	}
	return interceptor(ctx, in, info, handler)
}

func _CmdV1_AutoDeleteSmartNIC_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SmartNIC)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CmdV1Server).AutoDeleteSmartNIC(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cmd.CmdV1/AutoDeleteSmartNIC",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CmdV1Server).AutoDeleteSmartNIC(ctx, req.(*SmartNIC))
	}
	return interceptor(ctx, in, info, handler)
}

func _CmdV1_AutoGetCluster_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Cluster)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CmdV1Server).AutoGetCluster(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cmd.CmdV1/AutoGetCluster",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CmdV1Server).AutoGetCluster(ctx, req.(*Cluster))
	}
	return interceptor(ctx, in, info, handler)
}

func _CmdV1_AutoGetNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Node)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CmdV1Server).AutoGetNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cmd.CmdV1/AutoGetNode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CmdV1Server).AutoGetNode(ctx, req.(*Node))
	}
	return interceptor(ctx, in, info, handler)
}

func _CmdV1_AutoGetSmartNIC_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SmartNIC)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CmdV1Server).AutoGetSmartNIC(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cmd.CmdV1/AutoGetSmartNIC",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CmdV1Server).AutoGetSmartNIC(ctx, req.(*SmartNIC))
	}
	return interceptor(ctx, in, info, handler)
}

func _CmdV1_AutoListCluster_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(api.ListWatchOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CmdV1Server).AutoListCluster(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cmd.CmdV1/AutoListCluster",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CmdV1Server).AutoListCluster(ctx, req.(*api.ListWatchOptions))
	}
	return interceptor(ctx, in, info, handler)
}

func _CmdV1_AutoListNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(api.ListWatchOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CmdV1Server).AutoListNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cmd.CmdV1/AutoListNode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CmdV1Server).AutoListNode(ctx, req.(*api.ListWatchOptions))
	}
	return interceptor(ctx, in, info, handler)
}

func _CmdV1_AutoListSmartNIC_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(api.ListWatchOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CmdV1Server).AutoListSmartNIC(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cmd.CmdV1/AutoListSmartNIC",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CmdV1Server).AutoListSmartNIC(ctx, req.(*api.ListWatchOptions))
	}
	return interceptor(ctx, in, info, handler)
}

func _CmdV1_AutoUpdateCluster_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Cluster)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CmdV1Server).AutoUpdateCluster(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cmd.CmdV1/AutoUpdateCluster",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CmdV1Server).AutoUpdateCluster(ctx, req.(*Cluster))
	}
	return interceptor(ctx, in, info, handler)
}

func _CmdV1_AutoUpdateNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Node)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CmdV1Server).AutoUpdateNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cmd.CmdV1/AutoUpdateNode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CmdV1Server).AutoUpdateNode(ctx, req.(*Node))
	}
	return interceptor(ctx, in, info, handler)
}

func _CmdV1_AutoUpdateSmartNIC_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SmartNIC)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CmdV1Server).AutoUpdateSmartNIC(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cmd.CmdV1/AutoUpdateSmartNIC",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CmdV1Server).AutoUpdateSmartNIC(ctx, req.(*SmartNIC))
	}
	return interceptor(ctx, in, info, handler)
}

func _CmdV1_AutoWatchCluster_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(api.ListWatchOptions)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(CmdV1Server).AutoWatchCluster(m, &cmdV1AutoWatchClusterServer{stream})
}

type CmdV1_AutoWatchClusterServer interface {
	Send(*AutoMsgClusterWatchHelper) error
	grpc.ServerStream
}

type cmdV1AutoWatchClusterServer struct {
	grpc.ServerStream
}

func (x *cmdV1AutoWatchClusterServer) Send(m *AutoMsgClusterWatchHelper) error {
	return x.ServerStream.SendMsg(m)
}

func _CmdV1_AutoWatchNode_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(api.ListWatchOptions)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(CmdV1Server).AutoWatchNode(m, &cmdV1AutoWatchNodeServer{stream})
}

type CmdV1_AutoWatchNodeServer interface {
	Send(*AutoMsgNodeWatchHelper) error
	grpc.ServerStream
}

type cmdV1AutoWatchNodeServer struct {
	grpc.ServerStream
}

func (x *cmdV1AutoWatchNodeServer) Send(m *AutoMsgNodeWatchHelper) error {
	return x.ServerStream.SendMsg(m)
}

func _CmdV1_AutoWatchSmartNIC_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(api.ListWatchOptions)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(CmdV1Server).AutoWatchSmartNIC(m, &cmdV1AutoWatchSmartNICServer{stream})
}

type CmdV1_AutoWatchSmartNICServer interface {
	Send(*AutoMsgSmartNICWatchHelper) error
	grpc.ServerStream
}

type cmdV1AutoWatchSmartNICServer struct {
	grpc.ServerStream
}

func (x *cmdV1AutoWatchSmartNICServer) Send(m *AutoMsgSmartNICWatchHelper) error {
	return x.ServerStream.SendMsg(m)
}

var _CmdV1_serviceDesc = grpc.ServiceDesc{
	ServiceName: "cmd.CmdV1",
	HandlerType: (*CmdV1Server)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AutoAddCluster",
			Handler:    _CmdV1_AutoAddCluster_Handler,
		},
		{
			MethodName: "AutoAddNode",
			Handler:    _CmdV1_AutoAddNode_Handler,
		},
		{
			MethodName: "AutoAddSmartNIC",
			Handler:    _CmdV1_AutoAddSmartNIC_Handler,
		},
		{
			MethodName: "AutoDeleteCluster",
			Handler:    _CmdV1_AutoDeleteCluster_Handler,
		},
		{
			MethodName: "AutoDeleteNode",
			Handler:    _CmdV1_AutoDeleteNode_Handler,
		},
		{
			MethodName: "AutoDeleteSmartNIC",
			Handler:    _CmdV1_AutoDeleteSmartNIC_Handler,
		},
		{
			MethodName: "AutoGetCluster",
			Handler:    _CmdV1_AutoGetCluster_Handler,
		},
		{
			MethodName: "AutoGetNode",
			Handler:    _CmdV1_AutoGetNode_Handler,
		},
		{
			MethodName: "AutoGetSmartNIC",
			Handler:    _CmdV1_AutoGetSmartNIC_Handler,
		},
		{
			MethodName: "AutoListCluster",
			Handler:    _CmdV1_AutoListCluster_Handler,
		},
		{
			MethodName: "AutoListNode",
			Handler:    _CmdV1_AutoListNode_Handler,
		},
		{
			MethodName: "AutoListSmartNIC",
			Handler:    _CmdV1_AutoListSmartNIC_Handler,
		},
		{
			MethodName: "AutoUpdateCluster",
			Handler:    _CmdV1_AutoUpdateCluster_Handler,
		},
		{
			MethodName: "AutoUpdateNode",
			Handler:    _CmdV1_AutoUpdateNode_Handler,
		},
		{
			MethodName: "AutoUpdateSmartNIC",
			Handler:    _CmdV1_AutoUpdateSmartNIC_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "AutoWatchCluster",
			Handler:       _CmdV1_AutoWatchCluster_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "AutoWatchNode",
			Handler:       _CmdV1_AutoWatchNode_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "AutoWatchSmartNIC",
			Handler:       _CmdV1_AutoWatchSmartNIC_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "cmd.proto",
}

func (m *AutoMsgClusterWatchHelper) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AutoMsgClusterWatchHelper) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCmd(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if m.Object != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCmd(dAtA, i, uint64(m.Object.Size()))
		n1, err := m.Object.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	return i, nil
}

func (m *AutoMsgNodeWatchHelper) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AutoMsgNodeWatchHelper) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCmd(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if m.Object != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCmd(dAtA, i, uint64(m.Object.Size()))
		n2, err := m.Object.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}

func (m *AutoMsgSmartNICWatchHelper) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AutoMsgSmartNICWatchHelper) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCmd(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if m.Object != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCmd(dAtA, i, uint64(m.Object.Size()))
		n3, err := m.Object.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}

func (m *Cluster) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Cluster) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintCmd(dAtA, i, uint64(m.TypeMeta.Size()))
	n4, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n4
	dAtA[i] = 0x12
	i++
	i = encodeVarintCmd(dAtA, i, uint64(m.ObjectMeta.Size()))
	n5, err := m.ObjectMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n5
	dAtA[i] = 0x1a
	i++
	i = encodeVarintCmd(dAtA, i, uint64(m.Spec.Size()))
	n6, err := m.Spec.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n6
	dAtA[i] = 0x22
	i++
	i = encodeVarintCmd(dAtA, i, uint64(m.Status.Size()))
	n7, err := m.Status.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n7
	return i, nil
}

func (m *ClusterList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClusterList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x12
	i++
	i = encodeVarintCmd(dAtA, i, uint64(m.TypeMeta.Size()))
	n8, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n8
	dAtA[i] = 0x1a
	i++
	i = encodeVarintCmd(dAtA, i, uint64(m.ListMeta.Size()))
	n9, err := m.ListMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n9
	if len(m.Items) > 0 {
		for _, msg := range m.Items {
			dAtA[i] = 0x22
			i++
			i = encodeVarintCmd(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ClusterSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClusterSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.QuorumNodes) > 0 {
		for _, s := range m.QuorumNodes {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.VirtualIP) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCmd(dAtA, i, uint64(len(m.VirtualIP)))
		i += copy(dAtA[i:], m.VirtualIP)
	}
	if len(m.NTPServers) > 0 {
		for _, s := range m.NTPServers {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.DNSSubDomain) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCmd(dAtA, i, uint64(len(m.DNSSubDomain)))
		i += copy(dAtA[i:], m.DNSSubDomain)
	}
	return i, nil
}

func (m *ClusterStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClusterStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Leader) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCmd(dAtA, i, uint64(len(m.Leader)))
		i += copy(dAtA[i:], m.Leader)
	}
	return i, nil
}

func (m *Node) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Node) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintCmd(dAtA, i, uint64(m.TypeMeta.Size()))
	n10, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n10
	dAtA[i] = 0x12
	i++
	i = encodeVarintCmd(dAtA, i, uint64(m.ObjectMeta.Size()))
	n11, err := m.ObjectMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n11
	dAtA[i] = 0x1a
	i++
	i = encodeVarintCmd(dAtA, i, uint64(m.Spec.Size()))
	n12, err := m.Spec.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n12
	dAtA[i] = 0x22
	i++
	i = encodeVarintCmd(dAtA, i, uint64(m.Status.Size()))
	n13, err := m.Status.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n13
	return i, nil
}

func (m *NodeCondition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeCondition) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCmd(dAtA, i, uint64(m.Type))
	}
	if m.Status != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCmd(dAtA, i, uint64(m.Status))
	}
	if m.LastTransitionTime != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCmd(dAtA, i, uint64(m.LastTransitionTime))
	}
	if len(m.Reason) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCmd(dAtA, i, uint64(len(m.Reason)))
		i += copy(dAtA[i:], m.Reason)
	}
	if len(m.Message) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintCmd(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	return i, nil
}

func (m *NodeList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x12
	i++
	i = encodeVarintCmd(dAtA, i, uint64(m.TypeMeta.Size()))
	n14, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n14
	dAtA[i] = 0x1a
	i++
	i = encodeVarintCmd(dAtA, i, uint64(m.ListMeta.Size()))
	n15, err := m.ListMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n15
	if len(m.Items) > 0 {
		for _, msg := range m.Items {
			dAtA[i] = 0x22
			i++
			i = encodeVarintCmd(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *NodeSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Roles) > 0 {
		dAtA17 := make([]byte, len(m.Roles)*10)
		var j16 int
		for _, num := range m.Roles {
			for num >= 1<<7 {
				dAtA17[j16] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j16++
			}
			dAtA17[j16] = uint8(num)
			j16++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintCmd(dAtA, i, uint64(j16))
		i += copy(dAtA[i:], dAtA17[:j16])
	}
	return i, nil
}

func (m *NodeStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Phase != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCmd(dAtA, i, uint64(m.Phase))
	}
	if len(m.Conditions) > 0 {
		for _, msg := range m.Conditions {
			dAtA[i] = 0x12
			i++
			i = encodeVarintCmd(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Nics) > 0 {
		for _, s := range m.Nics {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *PortCondition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PortCondition) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCmd(dAtA, i, uint64(m.Type))
	}
	if m.Status != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCmd(dAtA, i, uint64(m.Status))
	}
	if m.LastTransitionTime != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCmd(dAtA, i, uint64(m.LastTransitionTime))
	}
	if len(m.Reason) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCmd(dAtA, i, uint64(len(m.Reason)))
		i += copy(dAtA[i:], m.Reason)
	}
	if len(m.Message) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintCmd(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	return i, nil
}

func (m *PortSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PortSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.MacAddress) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCmd(dAtA, i, uint64(len(m.MacAddress)))
		i += copy(dAtA[i:], m.MacAddress)
	}
	return i, nil
}

func (m *PortStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PortStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.MacAddress) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCmd(dAtA, i, uint64(len(m.MacAddress)))
		i += copy(dAtA[i:], m.MacAddress)
	}
	if len(m.LinkSpeed) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCmd(dAtA, i, uint64(len(m.LinkSpeed)))
		i += copy(dAtA[i:], m.LinkSpeed)
	}
	if len(m.Conditions) > 0 {
		for _, msg := range m.Conditions {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintCmd(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SmartNIC) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SmartNIC) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintCmd(dAtA, i, uint64(m.TypeMeta.Size()))
	n18, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n18
	dAtA[i] = 0x12
	i++
	i = encodeVarintCmd(dAtA, i, uint64(m.ObjectMeta.Size()))
	n19, err := m.ObjectMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n19
	dAtA[i] = 0x1a
	i++
	i = encodeVarintCmd(dAtA, i, uint64(m.Spec.Size()))
	n20, err := m.Spec.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n20
	dAtA[i] = 0x22
	i++
	i = encodeVarintCmd(dAtA, i, uint64(m.Status.Size()))
	n21, err := m.Status.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n21
	return i, nil
}

func (m *SmartNICCondition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SmartNICCondition) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCmd(dAtA, i, uint64(m.Type))
	}
	if m.Status != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCmd(dAtA, i, uint64(m.Status))
	}
	if m.LastTransitionTime != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCmd(dAtA, i, uint64(m.LastTransitionTime))
	}
	if len(m.Reason) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCmd(dAtA, i, uint64(len(m.Reason)))
		i += copy(dAtA[i:], m.Reason)
	}
	if len(m.Message) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintCmd(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	return i, nil
}

func (m *SmartNICList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SmartNICList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x12
	i++
	i = encodeVarintCmd(dAtA, i, uint64(m.TypeMeta.Size()))
	n22, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n22
	dAtA[i] = 0x1a
	i++
	i = encodeVarintCmd(dAtA, i, uint64(m.ListMeta.Size()))
	n23, err := m.ListMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n23
	if len(m.Items) > 0 {
		for _, msg := range m.Items {
			dAtA[i] = 0x22
			i++
			i = encodeVarintCmd(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SmartNICSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SmartNICSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Ports) > 0 {
		for _, msg := range m.Ports {
			dAtA[i] = 0xa
			i++
			i = encodeVarintCmd(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SmartNICStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SmartNICStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Phase != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCmd(dAtA, i, uint64(m.Phase))
	}
	if len(m.Conditions) > 0 {
		for _, msg := range m.Conditions {
			dAtA[i] = 0x12
			i++
			i = encodeVarintCmd(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.SerialNum) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCmd(dAtA, i, uint64(len(m.SerialNum)))
		i += copy(dAtA[i:], m.SerialNum)
	}
	if len(m.PrimaryMacAddress) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCmd(dAtA, i, uint64(len(m.PrimaryMacAddress)))
		i += copy(dAtA[i:], m.PrimaryMacAddress)
	}
	if len(m.NodeName) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintCmd(dAtA, i, uint64(len(m.NodeName)))
		i += copy(dAtA[i:], m.NodeName)
	}
	if len(m.Ports) > 0 {
		for _, msg := range m.Ports {
			dAtA[i] = 0x32
			i++
			i = encodeVarintCmd(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func encodeFixed64Cmd(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Cmd(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintCmd(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *AutoMsgClusterWatchHelper) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovCmd(uint64(l))
	}
	if m.Object != nil {
		l = m.Object.Size()
		n += 1 + l + sovCmd(uint64(l))
	}
	return n
}

func (m *AutoMsgNodeWatchHelper) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovCmd(uint64(l))
	}
	if m.Object != nil {
		l = m.Object.Size()
		n += 1 + l + sovCmd(uint64(l))
	}
	return n
}

func (m *AutoMsgSmartNICWatchHelper) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovCmd(uint64(l))
	}
	if m.Object != nil {
		l = m.Object.Size()
		n += 1 + l + sovCmd(uint64(l))
	}
	return n
}

func (m *Cluster) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovCmd(uint64(l))
	l = m.ObjectMeta.Size()
	n += 1 + l + sovCmd(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovCmd(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovCmd(uint64(l))
	return n
}

func (m *ClusterList) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovCmd(uint64(l))
	l = m.ListMeta.Size()
	n += 1 + l + sovCmd(uint64(l))
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovCmd(uint64(l))
		}
	}
	return n
}

func (m *ClusterSpec) Size() (n int) {
	var l int
	_ = l
	if len(m.QuorumNodes) > 0 {
		for _, s := range m.QuorumNodes {
			l = len(s)
			n += 1 + l + sovCmd(uint64(l))
		}
	}
	l = len(m.VirtualIP)
	if l > 0 {
		n += 1 + l + sovCmd(uint64(l))
	}
	if len(m.NTPServers) > 0 {
		for _, s := range m.NTPServers {
			l = len(s)
			n += 1 + l + sovCmd(uint64(l))
		}
	}
	l = len(m.DNSSubDomain)
	if l > 0 {
		n += 1 + l + sovCmd(uint64(l))
	}
	return n
}

func (m *ClusterStatus) Size() (n int) {
	var l int
	_ = l
	l = len(m.Leader)
	if l > 0 {
		n += 1 + l + sovCmd(uint64(l))
	}
	return n
}

func (m *Node) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovCmd(uint64(l))
	l = m.ObjectMeta.Size()
	n += 1 + l + sovCmd(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovCmd(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovCmd(uint64(l))
	return n
}

func (m *NodeCondition) Size() (n int) {
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovCmd(uint64(m.Type))
	}
	if m.Status != 0 {
		n += 1 + sovCmd(uint64(m.Status))
	}
	if m.LastTransitionTime != 0 {
		n += 1 + sovCmd(uint64(m.LastTransitionTime))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovCmd(uint64(l))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovCmd(uint64(l))
	}
	return n
}

func (m *NodeList) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovCmd(uint64(l))
	l = m.ListMeta.Size()
	n += 1 + l + sovCmd(uint64(l))
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovCmd(uint64(l))
		}
	}
	return n
}

func (m *NodeSpec) Size() (n int) {
	var l int
	_ = l
	if len(m.Roles) > 0 {
		l = 0
		for _, e := range m.Roles {
			l += sovCmd(uint64(e))
		}
		n += 1 + sovCmd(uint64(l)) + l
	}
	return n
}

func (m *NodeStatus) Size() (n int) {
	var l int
	_ = l
	if m.Phase != 0 {
		n += 1 + sovCmd(uint64(m.Phase))
	}
	if len(m.Conditions) > 0 {
		for _, e := range m.Conditions {
			l = e.Size()
			n += 1 + l + sovCmd(uint64(l))
		}
	}
	if len(m.Nics) > 0 {
		for _, s := range m.Nics {
			l = len(s)
			n += 1 + l + sovCmd(uint64(l))
		}
	}
	return n
}

func (m *PortCondition) Size() (n int) {
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovCmd(uint64(m.Type))
	}
	if m.Status != 0 {
		n += 1 + sovCmd(uint64(m.Status))
	}
	if m.LastTransitionTime != 0 {
		n += 1 + sovCmd(uint64(m.LastTransitionTime))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovCmd(uint64(l))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovCmd(uint64(l))
	}
	return n
}

func (m *PortSpec) Size() (n int) {
	var l int
	_ = l
	l = len(m.MacAddress)
	if l > 0 {
		n += 1 + l + sovCmd(uint64(l))
	}
	return n
}

func (m *PortStatus) Size() (n int) {
	var l int
	_ = l
	l = len(m.MacAddress)
	if l > 0 {
		n += 1 + l + sovCmd(uint64(l))
	}
	l = len(m.LinkSpeed)
	if l > 0 {
		n += 1 + l + sovCmd(uint64(l))
	}
	if len(m.Conditions) > 0 {
		for _, e := range m.Conditions {
			l = e.Size()
			n += 1 + l + sovCmd(uint64(l))
		}
	}
	return n
}

func (m *SmartNIC) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovCmd(uint64(l))
	l = m.ObjectMeta.Size()
	n += 1 + l + sovCmd(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovCmd(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovCmd(uint64(l))
	return n
}

func (m *SmartNICCondition) Size() (n int) {
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovCmd(uint64(m.Type))
	}
	if m.Status != 0 {
		n += 1 + sovCmd(uint64(m.Status))
	}
	if m.LastTransitionTime != 0 {
		n += 1 + sovCmd(uint64(m.LastTransitionTime))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovCmd(uint64(l))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovCmd(uint64(l))
	}
	return n
}

func (m *SmartNICList) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovCmd(uint64(l))
	l = m.ListMeta.Size()
	n += 1 + l + sovCmd(uint64(l))
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovCmd(uint64(l))
		}
	}
	return n
}

func (m *SmartNICSpec) Size() (n int) {
	var l int
	_ = l
	if len(m.Ports) > 0 {
		for _, e := range m.Ports {
			l = e.Size()
			n += 1 + l + sovCmd(uint64(l))
		}
	}
	return n
}

func (m *SmartNICStatus) Size() (n int) {
	var l int
	_ = l
	if m.Phase != 0 {
		n += 1 + sovCmd(uint64(m.Phase))
	}
	if len(m.Conditions) > 0 {
		for _, e := range m.Conditions {
			l = e.Size()
			n += 1 + l + sovCmd(uint64(l))
		}
	}
	l = len(m.SerialNum)
	if l > 0 {
		n += 1 + l + sovCmd(uint64(l))
	}
	l = len(m.PrimaryMacAddress)
	if l > 0 {
		n += 1 + l + sovCmd(uint64(l))
	}
	l = len(m.NodeName)
	if l > 0 {
		n += 1 + l + sovCmd(uint64(l))
	}
	if len(m.Ports) > 0 {
		for _, e := range m.Ports {
			l = e.Size()
			n += 1 + l + sovCmd(uint64(l))
		}
	}
	return n
}

func sovCmd(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozCmd(x uint64) (n int) {
	return sovCmd(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *AutoMsgClusterWatchHelper) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AutoMsgClusterWatchHelper: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AutoMsgClusterWatchHelper: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Object", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Object == nil {
				m.Object = &Cluster{}
			}
			if err := m.Object.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmd(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AutoMsgNodeWatchHelper) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AutoMsgNodeWatchHelper: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AutoMsgNodeWatchHelper: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Object", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Object == nil {
				m.Object = &Node{}
			}
			if err := m.Object.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmd(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AutoMsgSmartNICWatchHelper) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AutoMsgSmartNICWatchHelper: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AutoMsgSmartNICWatchHelper: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Object", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Object == nil {
				m.Object = &SmartNIC{}
			}
			if err := m.Object.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmd(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Cluster) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Cluster: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Cluster: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmd(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClusterList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClusterList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClusterList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ListMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &Cluster{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmd(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClusterSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClusterSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClusterSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QuorumNodes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QuorumNodes = append(m.QuorumNodes, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VirtualIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VirtualIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NTPServers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NTPServers = append(m.NTPServers, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DNSSubDomain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DNSSubDomain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmd(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClusterStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClusterStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClusterStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Leader", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Leader = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmd(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Node) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Node: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Node: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmd(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeCondition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeCondition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeCondition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (NodeConditionType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (ConditionStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastTransitionTime", wireType)
			}
			m.LastTransitionTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastTransitionTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmd(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ListMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &Node{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmd(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v NodeRole
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCmd
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (NodeRole(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Roles = append(m.Roles, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCmd
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCmd
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v NodeRole
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCmd
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (NodeRole(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Roles = append(m.Roles, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Roles", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCmd(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phase", wireType)
			}
			m.Phase = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Phase |= (NodePhase(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conditions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Conditions = append(m.Conditions, &NodeCondition{})
			if err := m.Conditions[len(m.Conditions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nics", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nics = append(m.Nics, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmd(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PortCondition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PortCondition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PortCondition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (PortConditionType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (ConditionStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastTransitionTime", wireType)
			}
			m.LastTransitionTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastTransitionTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmd(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PortSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PortSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PortSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MacAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MacAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmd(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PortStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PortStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PortStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MacAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MacAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LinkSpeed", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LinkSpeed = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conditions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Conditions = append(m.Conditions, &PortCondition{})
			if err := m.Conditions[len(m.Conditions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmd(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SmartNIC) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SmartNIC: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SmartNIC: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmd(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SmartNICCondition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SmartNICCondition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SmartNICCondition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (SmartNICConditionType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (ConditionStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastTransitionTime", wireType)
			}
			m.LastTransitionTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastTransitionTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmd(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SmartNICList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SmartNICList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SmartNICList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ListMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &SmartNIC{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmd(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SmartNICSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SmartNICSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SmartNICSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ports", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ports = append(m.Ports, PortSpec{})
			if err := m.Ports[len(m.Ports)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmd(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SmartNICStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SmartNICStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SmartNICStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phase", wireType)
			}
			m.Phase = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Phase |= (SmartNICPhase(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conditions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Conditions = append(m.Conditions, &SmartNICCondition{})
			if err := m.Conditions[len(m.Conditions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SerialNum", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SerialNum = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrimaryMacAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrimaryMacAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ports", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ports = append(m.Ports, &PortStatus{})
			if err := m.Ports[len(m.Ports)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmd(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCmd(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCmd
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthCmd
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowCmd
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipCmd(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthCmd = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCmd   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("cmd.proto", fileDescriptorCmd) }

var fileDescriptorCmd = []byte{
	// 2001 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x59, 0xcd, 0x73, 0x1b, 0x49,
	0x15, 0xd7, 0x48, 0xfe, 0xd2, 0xb3, 0xf5, 0xd5, 0xfe, 0x88, 0x46, 0x31, 0xb6, 0x19, 0x16, 0xca,
	0x11, 0x59, 0x2b, 0xc9, 0x16, 0x54, 0x62, 0x92, 0x50, 0xfa, 0x4a, 0xa2, 0x8d, 0x2c, 0xc9, 0x92,
	0x9c, 0xc0, 0xb2, 0x54, 0x18, 0x4b, 0x8d, 0x3d, 0x20, 0xcd, 0x0c, 0x33, 0xa3, 0x6c, 0xa5, 0x28,
	0x2e, 0x2b, 0x52, 0x14, 0x05, 0x27, 0xc8, 0x69, 0xb9, 0xe5, 0xe8, 0xe3, 0xfe, 0x03, 0x5c, 0x97,
	0xdb, 0x56, 0x38, 0xb0, 0xb5, 0x07, 0xd7, 0x56, 0x8a, 0x93, 0xff, 0x05, 0x38, 0x50, 0xfd, 0x31,
	0x33, 0x3d, 0x92, 0xec, 0xd5, 0x16, 0xb5, 0x7b, 0xca, 0xcd, 0x7a, 0xfd, 0x7e, 0xbf, 0xee, 0xf7,
	0xfa, 0xd7, 0xef, 0xf5, 0xb4, 0x21, 0xda, 0xe9, 0x77, 0x77, 0x4c, 0xcb, 0x70, 0x0c, 0x14, 0xe9,
	0xf4, 0xbb, 0x99, 0xf5, 0x23, 0xc3, 0x38, 0xea, 0xe1, 0x9c, 0x6a, 0x6a, 0x39, 0x55, 0xd7, 0x0d,
	0x47, 0x75, 0x34, 0x43, 0xb7, 0x99, 0x4b, 0xe6, 0xee, 0x91, 0xe6, 0x1c, 0x0f, 0x0e, 0x77, 0x3a,
	0x46, 0x3f, 0x67, 0x62, 0xdd, 0x56, 0xf5, 0xae, 0x91, 0xb3, 0x3f, 0xc8, 0x0d, 0x1c, 0xad, 0x67,
	0x13, 0xcc, 0x11, 0xd6, 0x45, 0x58, 0x4e, 0xd3, 0x3b, 0xbd, 0x41, 0x17, 0xbb, 0xf8, 0xb7, 0x05,
	0xfc, 0x91, 0x71, 0x64, 0xe4, 0xa8, 0xf9, 0x70, 0xf0, 0x4b, 0xfa, 0x8b, 0xfe, 0xa0, 0x7f, 0x71,
	0xf7, 0xef, 0x9e, 0x33, 0x1d, 0x59, 0x5c, 0x1f, 0x3b, 0x2a, 0x73, 0x53, 0x7e, 0x02, 0x72, 0x7e,
	0xe0, 0x18, 0x7b, 0xf6, 0x51, 0xb1, 0x37, 0xb0, 0x1d, 0x6c, 0x3d, 0x56, 0x9d, 0xce, 0xf1, 0x03,
	0xdc, 0x33, 0xb1, 0x85, 0x96, 0x60, 0xa6, 0xfd, 0xcc, 0xc4, 0x69, 0x69, 0x4b, 0xda, 0x8e, 0xa2,
	0x75, 0x98, 0xab, 0x1f, 0xfe, 0x0a, 0x77, 0x9c, 0x74, 0x78, 0x4b, 0xda, 0x5e, 0xbc, 0xb1, 0xb4,
	0x43, 0xe2, 0xe7, 0xb0, 0xdd, 0xc4, 0xe7, 0x2f, 0x56, 0x16, 0x3f, 0x20, 0xe0, 0x63, 0x0a, 0x56,
	0x9a, 0xb0, 0xc6, 0x99, 0x6b, 0x46, 0x17, 0x9f, 0x4f, 0x2b, 0x8f, 0xd0, 0x46, 0x29, 0x2d, 0xc1,
	0x8c, 0x73, 0xbe, 0x07, 0x19, 0xce, 0xd9, 0xea, 0xab, 0x96, 0x53, 0xab, 0x14, 0xcf, 0xe7, 0xfd,
	0xd6, 0x08, 0x6f, 0x8c, 0xf2, 0xba, 0xb8, 0x71, 0xee, 0x3f, 0x84, 0x61, 0x9e, 0x07, 0x83, 0xae,
	0x81, 0xd4, 0xa6, 0x34, 0x04, 0xa6, 0x9a, 0xda, 0x0e, 0xe1, 0xdd, 0xc3, 0x8e, 0x5a, 0x58, 0xfe,
	0xe4, 0x74, 0x33, 0xf4, 0xe9, 0xe9, 0xa6, 0x74, 0x76, 0xba, 0x39, 0x7f, 0x55, 0xd3, 0x7b, 0x9a,
	0x8e, 0x9b, 0x52, 0x1b, 0xdd, 0x02, 0xa9, 0xce, 0x27, 0x4a, 0x50, 0x04, 0x9b, 0x9b, 0x62, 0x32,
	0x02, 0x26, 0x4e, 0x72, 0x7f, 0xd5, 0xe8, 0x6b, 0x0e, 0xee, 0x9b, 0xce, 0xb3, 0xa6, 0x54, 0x47,
	0xb7, 0x61, 0xa6, 0x65, 0xe2, 0x4e, 0x3a, 0x42, 0xd1, 0x49, 0x31, 0xab, 0xc4, 0x5e, 0x58, 0x23,
	0x70, 0x02, 0xb5, 0x4d, 0xdc, 0x11, 0xa0, 0x14, 0x85, 0x4a, 0x30, 0xd7, 0x72, 0x54, 0x67, 0x60,
	0xa7, 0x67, 0x28, 0x1e, 0x05, 0xf0, 0x74, 0xa4, 0x90, 0xe6, 0x0c, 0x49, 0x9b, 0xfe, 0x16, 0x38,
	0x38, 0x76, 0x77, 0xf1, 0xd5, 0x73, 0x79, 0xbe, 0xc3, 0x40, 0xca, 0x1f, 0x25, 0x58, 0xe4, 0x04,
	0x55, 0xcd, 0x76, 0x90, 0x42, 0xb2, 0x11, 0x9e, 0x94, 0x8d, 0x05, 0x37, 0x32, 0x74, 0x05, 0x16,
	0x88, 0x2f, 0xb1, 0xf2, 0x40, 0x98, 0xab, 0x6b, 0x14, 0x5c, 0x2f, 0xc3, 0x6c, 0xc5, 0xc1, 0x7d,
	0xb2, 0xe0, 0xc8, 0x98, 0x8c, 0xe2, 0x9f, 0xbf, 0x58, 0x81, 0x9e, 0x66, 0x3b, 0x7c, 0x57, 0xfe,
	0xe3, 0xaf, 0x85, 0x86, 0xfb, 0x23, 0x58, 0xdc, 0x1f, 0x18, 0xd6, 0xa0, 0x4f, 0x04, 0x62, 0xa7,
	0xa5, 0xad, 0xc8, 0x76, 0xb4, 0x20, 0x9f, 0x9d, 0x6e, 0xae, 0xfe, 0xc6, 0x37, 0x0b, 0x01, 0x8a,
	0xde, 0xe8, 0x07, 0x10, 0x7d, 0xa4, 0x59, 0xce, 0x40, 0xed, 0x55, 0x1a, 0x34, 0xa0, 0x68, 0xe1,
	0xd2, 0xd9, 0xe9, 0xe6, 0xf2, 0x53, 0x6e, 0x34, 0x05, 0xa0, 0xef, 0x89, 0x6e, 0x02, 0xd4, 0xda,
	0x8d, 0x16, 0xb6, 0x9e, 0x62, 0xcb, 0x4e, 0x47, 0xe8, 0x94, 0xe9, 0xb3, 0xd3, 0xcd, 0x15, 0xdd,
	0x31, 0xb9, 0x55, 0x00, 0x0a, 0xbe, 0xe8, 0x2e, 0x2c, 0x95, 0x6a, 0xad, 0xd6, 0xe0, 0xb0, 0x64,
	0xf4, 0x55, 0x4d, 0xa7, 0x5b, 0x14, 0x2d, 0x64, 0xce, 0x4e, 0x37, 0xd7, 0xba, 0xba, 0xdd, 0x1a,
	0x1c, 0x76, 0xa9, 0x5d, 0x40, 0x07, 0xfc, 0x95, 0x3b, 0x10, 0x0b, 0xec, 0x24, 0xba, 0x0a, 0x73,
	0x55, 0xac, 0x76, 0xb1, 0xc5, 0x44, 0x5e, 0x58, 0x21, 0xbb, 0xda, 0xa3, 0x16, 0x71, 0x57, 0x99,
	0x8f, 0xf2, 0x5f, 0x09, 0x66, 0x48, 0xe4, 0xdf, 0xac, 0x9e, 0x6f, 0x05, 0xf4, 0x1c, 0xf3, 0x8e,
	0xf3, 0x14, 0x62, 0xce, 0x8f, 0x88, 0x39, 0xe1, 0x83, 0xa7, 0x55, 0x72, 0xf4, 0xd5, 0x73, 0x79,
	0x56, 0x27, 0xdb, 0xad, 0x7c, 0x16, 0x86, 0x18, 0xc1, 0x16, 0x0d, 0xbd, 0xab, 0x91, 0x9a, 0x8a,
	0x0a, 0x42, 0x85, 0x88, 0xdf, 0x58, 0xf3, 0xd8, 0x3d, 0x0f, 0x32, 0x4a, 0xd7, 0x48, 0x63, 0x73,
	0x9e, 0x99, 0x58, 0x5c, 0x23, 0x19, 0x45, 0xf7, 0xbc, 0x35, 0x86, 0x29, 0xcb, 0x0a, 0xd3, 0xaf,
	0xcb, 0x20, 0x2c, 0x54, 0xba, 0x68, 0xa1, 0xa8, 0x0d, 0xa8, 0xaa, 0xda, 0x4e, 0xdb, 0x52, 0x75,
	0x9b, 0xcd, 0xad, 0xf5, 0x31, 0x4d, 0x5a, 0xa4, 0xf0, 0x16, 0x47, 0xaf, 0xf7, 0xc6, 0x3c, 0x04,
	0xa6, 0x09, 0x78, 0x74, 0x0d, 0xe6, 0x9a, 0x58, 0xb5, 0x0d, 0x57, 0x6b, 0xde, 0x3a, 0x2c, 0x6a,
	0x15, 0xd7, 0xc1, 0xfc, 0xd0, 0x3b, 0x30, 0xbf, 0x87, 0x6d, 0x5b, 0x3d, 0xc2, 0xe9, 0x59, 0x0a,
	0x91, 0x39, 0x24, 0xd5, 0x67, 0x66, 0x01, 0xe3, 0x7a, 0x2a, 0x43, 0x09, 0x16, 0x48, 0xe2, 0xbe,
	0x8e, 0xfa, 0x90, 0x0e, 0xd6, 0x07, 0xa1, 0x1f, 0x8c, 0x16, 0x87, 0x12, 0x5b, 0x04, 0x95, 0xce,
	0x4d, 0x98, 0x6d, 0x1a, 0x3d, 0x5e, 0x12, 0xe2, 0x82, 0xec, 0x88, 0xb5, 0xb0, 0x7c, 0x76, 0xba,
	0x99, 0xb0, 0xc8, 0xb8, 0x10, 0x0d, 0x03, 0x28, 0xff, 0x90, 0x00, 0x7c, 0x89, 0xa1, 0x3b, 0x30,
	0xdb, 0x38, 0x56, 0x6d, 0x57, 0x24, 0x71, 0x8f, 0x88, 0x5a, 0x0b, 0x97, 0x78, 0x76, 0x12, 0x26,
	0xf9, 0x29, 0xb2, 0xd1, 0x71, 0xd4, 0x00, 0xf0, 0xb4, 0x40, 0x24, 0x12, 0xf1, 0x6a, 0x72, 0x40,
	0x68, 0x85, 0x75, 0xce, 0xb3, 0xd2, 0xf1, 0xbc, 0xc5, 0x22, 0xe2, 0x73, 0xa0, 0x2c, 0xcc, 0xd4,
	0xb4, 0x8e, 0x5b, 0x78, 0x3c, 0x71, 0xea, 0x5a, 0x47, 0x44, 0x50, 0x1f, 0x2a, 0xf9, 0x86, 0x61,
	0x39, 0x17, 0x4b, 0x3e, 0xe0, 0xf1, 0x46, 0xf2, 0xd3, 0x49, 0xfe, 0x01, 0x2c, 0x90, 0xbc, 0x51,
	0xb1, 0xdd, 0x06, 0xd8, 0x53, 0x3b, 0xf9, 0x6e, 0xd7, 0xc2, 0xb6, 0xcd, 0x4b, 0xb1, 0xb7, 0xa1,
	0x7d, 0x6f, 0x44, 0xdc, 0x50, 0xdf, 0x5f, 0xf9, 0x97, 0x04, 0x40, 0xa9, 0x58, 0x56, 0xfe, 0x2f,
	0x32, 0x74, 0x0b, 0xa2, 0x55, 0x4d, 0xff, 0x75, 0xcb, 0xc4, 0xb8, 0xcb, 0x7b, 0xda, 0x65, 0x0e,
	0x5e, 0xee, 0xb9, 0x03, 0x62, 0x5f, 0xf3, 0xbc, 0x47, 0xa4, 0x1a, 0x11, 0xa4, 0x1a, 0x10, 0xc8,
	0xf4, 0x52, 0x55, 0xfe, 0x1c, 0x86, 0x05, 0xf7, 0x86, 0xf5, 0xcd, 0x36, 0x9d, 0x3b, 0x81, 0xa6,
	0x93, 0x0a, 0xdc, 0xf5, 0xa6, 0x68, 0x3c, 0xe5, 0x91, 0xc6, 0xb3, 0x1c, 0x24, 0x98, 0xb6, 0xf9,
	0xc4, 0x5e, 0x3d, 0x97, 0xa3, 0x36, 0x41, 0x91, 0xd3, 0xa9, 0x7c, 0x11, 0x86, 0x94, 0xcb, 0xe1,
	0x9f, 0xc8, 0x7b, 0x81, 0x13, 0x99, 0x09, 0xcc, 0xf4, 0xe6, 0x54, 0x7e, 0xc5, 0x53, 0xf9, 0x27,
	0x09, 0x96, 0xdc, 0xe4, 0x7d, 0x1d, 0xcd, 0x68, 0x3d, 0xd8, 0x8c, 0x46, 0x3e, 0x22, 0x46, 0x1b,
	0x52, 0xd5, 0x5f, 0x0c, 0xaf, 0x13, 0xb3, 0xe4, 0x28, 0xb1, 0xa6, 0xe4, 0xa2, 0xdd, 0x2a, 0x42,
	0x5b, 0x49, 0x88, 0xb6, 0x12, 0xe2, 0x13, 0x68, 0x25, 0xc4, 0xa0, 0x7c, 0x1c, 0x81, 0x78, 0x50,
	0x82, 0x28, 0x1f, 0x6c, 0x4e, 0x28, 0xb0, 0x9c, 0xe9, 0x1a, 0x54, 0x7b, 0x42, 0x83, 0x5a, 0x9b,
	0x2c, 0xc2, 0xaf, 0xd0, 0xa4, 0x6e, 0x43, 0xb4, 0x85, 0x2d, 0x4d, 0xed, 0xd5, 0x06, 0x7d, 0x9a,
	0xd3, 0x68, 0x61, 0x83, 0x83, 0xd7, 0x6c, 0x77, 0xe0, 0x30, 0x70, 0x4b, 0xf5, 0x01, 0x68, 0x1f,
	0x52, 0x0d, 0x4b, 0xeb, 0xab, 0xd6, 0x33, 0xa1, 0x12, 0x32, 0xdd, 0x7c, 0x87, 0xb3, 0x5c, 0x36,
	0x47, 0x1d, 0x04, 0xaa, 0x71, 0x34, 0xfa, 0x21, 0xbb, 0x1b, 0xd4, 0xd4, 0xbe, 0x2b, 0xa7, 0x0c,
	0x67, 0x42, 0x3a, 0xb7, 0x0b, 0x04, 0x9e, 0x2f, 0xba, 0xeb, 0x6e, 0xd9, 0x1c, 0xcd, 0x4c, 0xc2,
	0xdf, 0x32, 0x76, 0x9e, 0xfc, 0xf4, 0x4e, 0xdc, 0xb4, 0x6c, 0x91, 0xcd, 0x4b, 0xae, 0x16, 0x68,
	0x19, 0x12, 0xc5, 0x7a, 0xad, 0xdd, 0xac, 0x57, 0xab, 0xe5, 0xe6, 0x93, 0x5a, 0xbd, 0x54, 0x4e,
	0x86, 0x50, 0x0a, 0x62, 0x8f, 0xeb, 0xcd, 0x87, 0xd5, 0x7a, 0xbe, 0xc4, 0x4c, 0x12, 0x4a, 0xc0,
	0xe2, 0xfe, 0x41, 0xbd, 0x79, 0xb0, 0xc7, 0x0c, 0xe1, 0xec, 0x3e, 0x44, 0xbd, 0x1b, 0x07, 0x4a,
	0xc2, 0x12, 0x31, 0x3f, 0x39, 0xa8, 0x3d, 0xac, 0xd5, 0x1f, 0xd7, 0x92, 0x21, 0xcf, 0xd2, 0x28,
	0xd7, 0x4a, 0x95, 0xda, 0x7d, 0xc6, 0x40, 0x2d, 0xef, 0xd6, 0x2b, 0xb5, 0x72, 0x29, 0x19, 0xf6,
	0x0c, 0xf7, 0xf2, 0x95, 0x6a, 0xb9, 0x94, 0x8c, 0x64, 0xdf, 0x82, 0xd4, 0xd8, 0x4d, 0xd7, 0xf3,
	0xaa, 0x96, 0xf3, 0xa5, 0x72, 0x33, 0x19, 0xca, 0xee, 0x43, 0x62, 0xa4, 0x80, 0xa0, 0x55, 0x48,
	0x15, 0xeb, 0xb5, 0x52, 0xa5, 0x5d, 0xa9, 0xd7, 0x84, 0x35, 0x20, 0x88, 0xfb, 0xe6, 0x76, 0xf3,
	0x80, 0xc4, 0xc1, 0xe2, 0xe5, 0xb6, 0x7b, 0xf9, 0x6a, 0x8b, 0xc4, 0x72, 0x00, 0xb1, 0x80, 0x40,
	0xe9, 0xa4, 0x95, 0xe2, 0x48, 0x38, 0x95, 0xe2, 0x93, 0x66, 0xf9, 0xdd, 0x72, 0xb1, 0x5d, 0x2e,
	0xf1, 0x70, 0x2a, 0x45, 0x2f, 0xbe, 0xb0, 0xeb, 0x92, 0x2f, 0xed, 0x55, 0xda, 0x6d, 0x1a, 0xcf,
	0x36, 0xac, 0x4e, 0x2c, 0x9a, 0x2e, 0xf6, 0x41, 0x39, 0x5f, 0x6d, 0x3f, 0xf8, 0x69, 0x32, 0x94,
	0xdd, 0x82, 0xd4, 0xd8, 0x85, 0x07, 0x2d, 0xc2, 0x7c, 0xa3, 0xde, 0x6c, 0x3f, 0x39, 0x68, 0x24,
	0x43, 0x37, 0xfe, 0x1e, 0x87, 0xd9, 0x62, 0xbf, 0xfb, 0xe8, 0x3a, 0xba, 0x0d, 0xf1, 0xfc, 0xc0,
	0x31, 0xf2, 0xdd, 0xae, 0xfb, 0x14, 0x10, 0xf8, 0x3c, 0xcd, 0x04, 0x7e, 0x29, 0xf1, 0xcf, 0x5e,
	0xac, 0x48, 0x1f, 0xff, 0x5e, 0x9e, 0xeb, 0x58, 0x58, 0x75, 0x48, 0x45, 0x5e, 0xe4, 0x68, 0xfa,
	0xd5, 0xe5, 0xdf, 0x5c, 0x33, 0xfe, 0x9f, 0xca, 0xb7, 0x83, 0xa0, 0x0f, 0xff, 0xf9, 0xef, 0xbf,
	0x86, 0x63, 0x10, 0xda, 0x95, 0xb2, 0xca, 0x5c, 0x8e, 0x7e, 0xb8, 0xa0, 0x1f, 0x43, 0x82, 0xf3,
	0x78, 0xcd, 0x34, 0x58, 0x78, 0x32, 0xc1, 0x9f, 0x63, 0x0b, 0x79, 0x1f, 0x52, 0x84, 0xa0, 0x84,
	0x7b, 0xd8, 0xc1, 0xd3, 0x44, 0xf2, 0x7d, 0x97, 0xa0, 0x4b, 0x21, 0x74, 0x51, 0x97, 0x20, 0xb4,
	0x1b, 0xca, 0xa6, 0x72, 0xfc, 0x59, 0x20, 0xf7, 0xdb, 0xfa, 0x0e, 0x39, 0x21, 0xbf, 0x43, 0xfb,
	0x2c, 0x49, 0x8c, 0xfd, 0x82, 0x48, 0xaf, 0x4c, 0x20, 0x5d, 0xa5, 0xa4, 0x09, 0x16, 0xa8, 0x4f,
	0xa9, 0x02, 0xf2, 0x29, 0xa7, 0x0c, 0xfa, 0xed, 0x09, 0xf4, 0x32, 0xa5, 0x5f, 0xce, 0x79, 0x3d,
	0xd8, 0x9f, 0xe2, 0x11, 0x5b, 0xf5, 0x7d, 0xec, 0x4c, 0x93, 0x90, 0x6d, 0x4e, 0x1e, 0x39, 0xc2,
	0x8e, 0x9f, 0x0d, 0x34, 0x21, 0x1b, 0x0f, 0xd9, 0xa6, 0xdf, 0xc7, 0xce, 0x05, 0xa9, 0xf8, 0xde,
	0x28, 0x1d, 0xcd, 0x03, 0x1a, 0xcb, 0xc3, 0xcf, 0xd8, 0xce, 0xdf, 0xc7, 0xce, 0x94, 0x49, 0xc8,
	0x8e, 0x12, 0xd3, 0x0c, 0xa0, 0x89, 0x19, 0x78, 0x9f, 0x91, 0x93, 0x2e, 0xe7, 0xa6, 0x60, 0xd5,
	0xeb, 0x7b, 0xf4, 0x21, 0xad, 0x6e, 0xd2, 0x6a, 0x9e, 0x09, 0x3c, 0x42, 0x91, 0x51, 0x65, 0x8b,
	0xcf, 0x33, 0x43, 0xba, 0x1d, 0x9d, 0x28, 0x4e, 0x27, 0x5a, 0x70, 0x13, 0x82, 0xda, 0xb0, 0xe4,
	0xb2, 0xd3, 0x44, 0x9c, 0x43, 0xed, 0x7f, 0x98, 0x51, 0xde, 0x8d, 0x31, 0xde, 0x25, 0xca, 0xeb,
	0x1e, 0x85, 0x5f, 0x40, 0xd2, 0x65, 0xf5, 0x32, 0x72, 0x0e, 0x73, 0xf0, 0xd2, 0x47, 0xd9, 0x95,
	0x31, 0xf6, 0x24, 0x65, 0x07, 0x3f, 0x3d, 0xe8, 0xe7, 0xec, 0xac, 0x1c, 0x98, 0x5d, 0x75, 0xba,
	0xb3, 0x72, 0xd5, 0xd5, 0xdd, 0x80, 0x42, 0x28, 0x6d, 0x9a, 0x1e, 0xe0, 0xcc, 0x04, 0x79, 0x34,
	0x99, 0xec, 0x18, 0xfd, 0x05, 0x0a, 0xc9, 0x4e, 0x60, 0x5d, 0x63, 0xac, 0x63, 0x2a, 0x39, 0x64,
	0xa7, 0x85, 0x71, 0x4e, 0x29, 0x94, 0x9d, 0x09, 0xfc, 0x19, 0xc6, 0x3f, 0x51, 0x2c, 0xef, 0xb1,
	0xc4, 0xd3, 0x0c, 0x7f, 0x89, 0x5a, 0x36, 0xe8, 0x4c, 0xe7, 0x3e, 0x23, 0x2b, 0x31, 0x3e, 0xf5,
	0x2c, 0x7d, 0x6e, 0xbd, 0x26, 0xa1, 0x36, 0xc4, 0x3c, 0xee, 0x8b, 0xb4, 0x72, 0x59, 0x24, 0x1e,
	0x79, 0x45, 0x1e, 0x67, 0xe5, 0x45, 0x8f, 0xfa, 0x7c, 0x99, 0x56, 0x36, 0x45, 0xe6, 0x09, 0x6f,
	0xc9, 0x63, 0xec, 0x99, 0xbf, 0x85, 0xff, 0x32, 0x94, 0xc3, 0x4f, 0xaf, 0x7f, 0x34, 0x94, 0x23,
	0x9d, 0x7e, 0xf7, 0xe5, 0x50, 0x76, 0x5f, 0x8b, 0x5f, 0x0e, 0x65, 0xfa, 0xca, 0xf6, 0x72, 0x28,
	0x7b, 0x1f, 0x3f, 0x27, 0x43, 0x59, 0xf6, 0x9f, 0x93, 0xa9, 0xfc, 0x32, 0xde, 0x51, 0x39, 0x19,
	0xca, 0x3b, 0xfe, 0x60, 0xc4, 0x1c, 0x38, 0x88, 0x1c, 0x5f, 0xc4, 0x0b, 0xd9, 0x04, 0x15, 0x9d,
	0x0c, 0xe5, 0x2b, 0xfc, 0x29, 0x6f, 0xdc, 0x7d, 0x54, 0x1e, 0x27, 0x43, 0x39, 0xc3, 0x9d, 0x67,
	0x4c, 0xc3, 0x76, 0xf8, 0xf4, 0xfc, 0x44, 0x9d, 0x0c, 0xe5, 0xeb, 0xc2, 0x47, 0xda, 0x38, 0xdd,
	0x24, 0x35, 0x9c, 0x0c, 0xe5, 0x75, 0x01, 0xc4, 0x08, 0x85, 0x43, 0x54, 0xd8, 0xf8, 0xe8, 0x43,
	0x39, 0xde, 0x33, 0x3a, 0x6a, 0xef, 0xd8, 0xb0, 0x9d, 0xdd, 0x9b, 0xd7, 0x6e, 0xde, 0xf8, 0xe4,
	0xf5, 0x86, 0xf4, 0xe9, 0xeb, 0x0d, 0xe9, 0x8b, 0xd7, 0x1b, 0x52, 0x43, 0x3a, 0x9c, 0xa3, 0xff,
	0x6f, 0x78, 0xe7, 0x7f, 0x01, 0x00, 0x00, 0xff, 0xff, 0x2b, 0xfb, 0x63, 0xd0, 0x35, 0x19, 0x00,
	0x00,
}
