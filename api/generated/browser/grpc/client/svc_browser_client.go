// Code generated by protoc-gen-grpc-pensando DO NOT EDIT.

package grpcclient

import (
	"context"
	"errors"
	"net/http"

	"github.com/go-kit/kit/endpoint"
	grpctransport "github.com/go-kit/kit/transport/grpc"
	"google.golang.org/grpc"

	api "github.com/pensando/sw/api"
	browser "github.com/pensando/sw/api/generated/browser"
	listerwatcher "github.com/pensando/sw/api/listerwatcher"
	"github.com/pensando/sw/venice/utils/kvstore"
	"github.com/pensando/sw/venice/utils/log"
	"github.com/pensando/sw/venice/utils/trace"
)

// Dummy vars to suppress import errors
var _ api.TypeMeta
var _ listerwatcher.WatcherClient
var _ kvstore.Interface

// NewBrowserV1 sets up a new client for BrowserV1
func NewBrowserV1(conn *grpc.ClientConn, logger log.Logger) browser.ServiceBrowserV1Client {

	var lQueryEndpoint endpoint.Endpoint
	{
		lQueryEndpoint = grpctransport.NewClient(
			conn,
			"browser.BrowserV1",
			"Query",
			browser.EncodeGrpcReqBrowseRequestList,
			browser.DecodeGrpcRespBrowseResponseList,
			&browser.BrowseResponseList{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lQueryEndpoint = trace.ClientEndPoint("BrowserV1:Query")(lQueryEndpoint)
	}
	var lReferencesEndpoint endpoint.Endpoint
	{
		lReferencesEndpoint = grpctransport.NewClient(
			conn,
			"browser.BrowserV1",
			"References",
			browser.EncodeGrpcReqBrowseRequest,
			browser.DecodeGrpcRespBrowseResponse,
			&browser.BrowseResponse{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lReferencesEndpoint = trace.ClientEndPoint("BrowserV1:References")(lReferencesEndpoint)
	}
	var lReferrersEndpoint endpoint.Endpoint
	{
		lReferrersEndpoint = grpctransport.NewClient(
			conn,
			"browser.BrowserV1",
			"Referrers",
			browser.EncodeGrpcReqBrowseRequest,
			browser.DecodeGrpcRespBrowseResponse,
			&browser.BrowseResponse{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lReferrersEndpoint = trace.ClientEndPoint("BrowserV1:Referrers")(lReferrersEndpoint)
	}
	return browser.EndpointsBrowserV1Client{
		Client: browser.NewBrowserV1Client(conn),

		QueryEndpoint:      lQueryEndpoint,
		ReferencesEndpoint: lReferencesEndpoint,
		ReferrersEndpoint:  lReferrersEndpoint,
	}
}

// NewBrowserV1Backend creates an instrumented client with middleware
func NewBrowserV1Backend(conn *grpc.ClientConn, logger log.Logger) browser.ServiceBrowserV1Client {
	cl := NewBrowserV1(conn, logger)
	cl = browser.LoggingBrowserV1MiddlewareClient(logger)(cl)
	return cl
}

type crudClientBrowserV1 struct {
	logger log.Logger
	client browser.ServiceBrowserV1Client
}

// NewGrpcCrudClientBrowserV1 creates a GRPC client for the service
func NewGrpcCrudClientBrowserV1(conn *grpc.ClientConn, logger log.Logger) browser.BrowserV1Interface {
	client := NewBrowserV1Backend(conn, logger)
	return &crudClientBrowserV1{
		logger: logger,
		client: client,
	}
}

func (a *crudClientBrowserV1) Watch(ctx context.Context, options *api.AggWatchOptions) (kvstore.Watcher, error) {
	a.logger.DebugLog("msg", "received call", "object", "BrowserV1", "oper", "WatchOper")
	nctx := addVersion(ctx, "v1")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	stream, err := a.client.AutoWatchSvcBrowserV1(nctx, options)
	if err != nil {
		return nil, err
	}
	wstream := stream.(browser.BrowserV1_AutoWatchSvcBrowserV1Client)
	bridgefn := func(lw *listerwatcher.WatcherClient) {
		for {
			r, err := wstream.Recv()
			if err != nil {
				a.logger.ErrorLog("msg", "error on receive", "err", err)
				close(lw.OutCh)
				return
			}
			for _, e := range r.Events {
				ev := kvstore.WatchEvent{Type: kvstore.WatchEventType(e.Type)}
				switch e.Type {
				case string(kvstore.Created), string(kvstore.Updated), string(kvstore.Deleted):
					robj, err := listerwatcher.GetObject(e)
					if err != nil {
						a.logger.ErrorLog("msg", "error on receive unmarshall", "err", err)
						close(lw.OutCh)
						return
					}
					ev.Object = robj
				case string(kvstore.WatcherControl):
					ev.Control = &kvstore.WatchControl{
						Code:    e.Control.Code,
						Message: e.Control.Message,
					}
				}
				select {
				case lw.OutCh <- &ev:
				case <-wstream.Context().Done():
					close(lw.OutCh)
					return
				}
			}
		}
	}
	lw := listerwatcher.NewWatcherClient(wstream, bridgefn)
	lw.Run()
	return lw, nil
}

type crudRestClientBrowserV1 struct {
}

// NewRestCrudClientBrowserV1 creates a REST client for the service.
func NewRestCrudClientBrowserV1(url string, httpClient *http.Client) browser.BrowserV1Interface {
	return &crudRestClientBrowserV1{}
}

// NewStagedRestCrudClientBrowserV1 creates a REST client for the service.
func NewStagedRestCrudClientBrowserV1(url string, id string, httpClient *http.Client) browser.BrowserV1Interface {
	return &crudRestClientBrowserV1{}
}

func (a *crudRestClientBrowserV1) Watch(ctx context.Context, options *api.AggWatchOptions) (kvstore.Watcher, error) {
	return nil, errors.New("method unimplemented")
}
