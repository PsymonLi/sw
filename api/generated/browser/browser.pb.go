// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: browser.proto

/*
	Package browser is a generated protocol buffer package.

	Service name

	It is generated from these files:
		browser.proto
		svc_browser.proto

	It has these top-level messages:
		BrowseRequest
		BrowseResponse
		Object
*/
package browser

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/pensando/grpc-gateway/third_party/googleapis/google/api"
import _ "github.com/pensando/sw/venice/utils/apigen/annotations"
import _ "github.com/gogo/protobuf/gogoproto"
import api "github.com/pensando/sw/api"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// QueryType defines the type of query
//  Dependencies - walks the dependency tree in the forward direction,
//    i.e. all objects that this object depends on.
// DependedBy = walks the dependency tree in the reverse direction,
//   i.e. all objects that depend on this node.
type QueryType int32

const (
	//
	QueryType_Dependencies QueryType = 0
	//
	QueryType_DependedBy QueryType = 1
)

var QueryType_name = map[int32]string{
	0: "Dependencies",
	1: "DependedBy",
}
var QueryType_value = map[string]int32{
	"Dependencies": 0,
	"DependedBy":   1,
}

func (QueryType) EnumDescriptor() ([]byte, []int) { return fileDescriptorBrowser, []int{0} }

//
type ReferenceTypes int32

const (
	//
	ReferenceTypes_NamedReference ReferenceTypes = 0
	//
	ReferenceTypes_WeakReference ReferenceTypes = 1
	//
	ReferenceTypes_SelectorReference ReferenceTypes = 2
)

var ReferenceTypes_name = map[int32]string{
	0: "NamedReference",
	1: "WeakReference",
	2: "SelectorReference",
}
var ReferenceTypes_value = map[string]int32{
	"NamedReference":    0,
	"WeakReference":     1,
	"SelectorReference": 2,
}

func (ReferenceTypes) EnumDescriptor() ([]byte, []int) { return fileDescriptorBrowser, []int{1} }

// BrowseRequest is the query request for the dependency tree
type BrowseRequest struct {
	//
	api.TypeMeta `protobuf:"bytes,1,opt,name=T,json=,inline,embedded=T" json:",inline"`
	//
	api.ObjectMeta `protobuf:"bytes,2,opt,name=O,json=meta,omitempty,embedded=O" json:"meta,omitempty"`
	// URI is the root node from where to query
	URI string `protobuf:"bytes,3,opt,name=URI,json=uri,proto3" json:"uri"`
	// QueryType is the direction of the query
	QueryType string `protobuf:"bytes,4,opt,name=QueryType,json=query-type,proto3" json:"query-type"`
	// Max-Depth specifies how deep the query should explore. By default depth is set to 1 which means immediate relations
	//  0 means to maximum depth.
	MaxDepth uint32 `protobuf:"varint,5,opt,name=MaxDepth,json=max-depth,proto3" json:"max-depth"`
	// When CountOnly is set the response only contains counts and not the actual objects.
	CountOnly bool `protobuf:"varint,6,opt,name=CountOnly,json=count-only,proto3" json:"count-only"`
}

func (m *BrowseRequest) Reset()                    { *m = BrowseRequest{} }
func (m *BrowseRequest) String() string            { return proto.CompactTextString(m) }
func (*BrowseRequest) ProtoMessage()               {}
func (*BrowseRequest) Descriptor() ([]byte, []int) { return fileDescriptorBrowser, []int{0} }

func (m *BrowseRequest) GetURI() string {
	if m != nil {
		return m.URI
	}
	return ""
}

func (m *BrowseRequest) GetQueryType() string {
	if m != nil {
		return m.QueryType
	}
	return ""
}

func (m *BrowseRequest) GetMaxDepth() uint32 {
	if m != nil {
		return m.MaxDepth
	}
	return 0
}

func (m *BrowseRequest) GetCountOnly() bool {
	if m != nil {
		return m.CountOnly
	}
	return false
}

// BrowseResponse is the response to a query request
type BrowseResponse struct {
	//
	api.TypeMeta `protobuf:"bytes,1,opt,name=T,json=,inline,embedded=T" json:",inline"`
	//
	api.ObjectMeta `protobuf:"bytes,2,opt,name=O,json=meta,omitempty,embedded=O" json:"meta,omitempty"`
	// RootURI is the root node for the response
	RootURI string `protobuf:"bytes,3,opt,name=RootURI,json=root-uri,proto3" json:"root-uri"`
	// QueryType is the direction of the query
	QueryType string `protobuf:"bytes,4,opt,name=QueryType,json=query-type,proto3" json:"query-type"`
	// MaxDepth that the response explored. Reflects the value specified in the query
	MaxDepth uint32 `protobuf:"varint,5,opt,name=MaxDepth,json=max-depth,proto3" json:"max-depth"`
	// TotalCount of objects in the response
	TotalCount uint32 `protobuf:"varint,6,opt,name=TotalCount,json=total-count,proto3" json:"total-count"`
	// map of results. Key to the map is the URI of the  Object.
	Objects map[string]Object `protobuf:"bytes,7,rep,name=Objects,json=objects" json:"objects" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *BrowseResponse) Reset()                    { *m = BrowseResponse{} }
func (m *BrowseResponse) String() string            { return proto.CompactTextString(m) }
func (*BrowseResponse) ProtoMessage()               {}
func (*BrowseResponse) Descriptor() ([]byte, []int) { return fileDescriptorBrowser, []int{1} }

func (m *BrowseResponse) GetRootURI() string {
	if m != nil {
		return m.RootURI
	}
	return ""
}

func (m *BrowseResponse) GetQueryType() string {
	if m != nil {
		return m.QueryType
	}
	return ""
}

func (m *BrowseResponse) GetMaxDepth() uint32 {
	if m != nil {
		return m.MaxDepth
	}
	return 0
}

func (m *BrowseResponse) GetTotalCount() uint32 {
	if m != nil {
		return m.TotalCount
	}
	return 0
}

func (m *BrowseResponse) GetObjects() map[string]Object {
	if m != nil {
		return m.Objects
	}
	return nil
}

// Object is a node in the dependency tree representing a config object with links to related
//  objects
type Object struct {
	//
	api.TypeMeta `protobuf:"bytes,1,opt,name=T,json=,inline,embedded=T" json:",inline"`
	//
	api.ObjectMeta `protobuf:"bytes,2,opt,name=O,json=meta,omitempty,embedded=O" json:"meta,omitempty"`
	// URI is the Browser URI for this object
	URI string `protobuf:"bytes,3,opt,name=URI,json=uri,proto3" json:"uri"`
	// Reverse is the view from the object looking back in the reverse direction of the dependency tree
	Reverse string `protobuf:"bytes,4,opt,name=Reverse,json=reverse,proto3" json:"reverse"`
	// QueryType specifies the direction of the relations in Links
	QueryType string `protobuf:"bytes,5,opt,name=QueryType,json=query-type,proto3" json:"query-type"`
	// Links points to the relations of the object. The key for the map is the path to the filed which
	//   is causing the relation.
	Links map[string]Object_URIs `protobuf:"bytes,6,rep,name=Links,json=links" json:"links" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *Object) Reset()                    { *m = Object{} }
func (m *Object) String() string            { return proto.CompactTextString(m) }
func (*Object) ProtoMessage()               {}
func (*Object) Descriptor() ([]byte, []int) { return fileDescriptorBrowser, []int{2} }

func (m *Object) GetURI() string {
	if m != nil {
		return m.URI
	}
	return ""
}

func (m *Object) GetReverse() string {
	if m != nil {
		return m.Reverse
	}
	return ""
}

func (m *Object) GetQueryType() string {
	if m != nil {
		return m.QueryType
	}
	return ""
}

func (m *Object) GetLinks() map[string]Object_URIs {
	if m != nil {
		return m.Links
	}
	return nil
}

type Object_URIs struct {
	RefType string          `protobuf:"bytes,1,opt,name=RefType,proto3" json:"ref-type"`
	URI     []api.ObjectRef `protobuf:"bytes,2,rep,name=URI" json:"uri"`
}

func (m *Object_URIs) Reset()                    { *m = Object_URIs{} }
func (m *Object_URIs) String() string            { return proto.CompactTextString(m) }
func (*Object_URIs) ProtoMessage()               {}
func (*Object_URIs) Descriptor() ([]byte, []int) { return fileDescriptorBrowser, []int{2, 0} }

func (m *Object_URIs) GetRefType() string {
	if m != nil {
		return m.RefType
	}
	return ""
}

func (m *Object_URIs) GetURI() []api.ObjectRef {
	if m != nil {
		return m.URI
	}
	return nil
}

func init() {
	proto.RegisterType((*BrowseRequest)(nil), "browser.BrowseRequest")
	proto.RegisterType((*BrowseResponse)(nil), "browser.BrowseResponse")
	proto.RegisterType((*Object)(nil), "browser.Object")
	proto.RegisterType((*Object_URIs)(nil), "browser.Object.URIs")
	proto.RegisterEnum("browser.QueryType", QueryType_name, QueryType_value)
	proto.RegisterEnum("browser.ReferenceTypes", ReferenceTypes_name, ReferenceTypes_value)
}
func (m *BrowseRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BrowseRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintBrowser(dAtA, i, uint64(m.TypeMeta.Size()))
	n1, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n1
	dAtA[i] = 0x12
	i++
	i = encodeVarintBrowser(dAtA, i, uint64(m.ObjectMeta.Size()))
	n2, err := m.ObjectMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n2
	if len(m.URI) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintBrowser(dAtA, i, uint64(len(m.URI)))
		i += copy(dAtA[i:], m.URI)
	}
	if len(m.QueryType) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintBrowser(dAtA, i, uint64(len(m.QueryType)))
		i += copy(dAtA[i:], m.QueryType)
	}
	if m.MaxDepth != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintBrowser(dAtA, i, uint64(m.MaxDepth))
	}
	if m.CountOnly {
		dAtA[i] = 0x30
		i++
		if m.CountOnly {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *BrowseResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BrowseResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintBrowser(dAtA, i, uint64(m.TypeMeta.Size()))
	n3, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n3
	dAtA[i] = 0x12
	i++
	i = encodeVarintBrowser(dAtA, i, uint64(m.ObjectMeta.Size()))
	n4, err := m.ObjectMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n4
	if len(m.RootURI) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintBrowser(dAtA, i, uint64(len(m.RootURI)))
		i += copy(dAtA[i:], m.RootURI)
	}
	if len(m.QueryType) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintBrowser(dAtA, i, uint64(len(m.QueryType)))
		i += copy(dAtA[i:], m.QueryType)
	}
	if m.MaxDepth != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintBrowser(dAtA, i, uint64(m.MaxDepth))
	}
	if m.TotalCount != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintBrowser(dAtA, i, uint64(m.TotalCount))
	}
	if len(m.Objects) > 0 {
		for k, _ := range m.Objects {
			dAtA[i] = 0x3a
			i++
			v := m.Objects[k]
			msgSize := 0
			if (&v) != nil {
				msgSize = (&v).Size()
				msgSize += 1 + sovBrowser(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovBrowser(uint64(len(k))) + msgSize
			i = encodeVarintBrowser(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintBrowser(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintBrowser(dAtA, i, uint64((&v).Size()))
			n5, err := (&v).MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n5
		}
	}
	return i, nil
}

func (m *Object) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Object) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintBrowser(dAtA, i, uint64(m.TypeMeta.Size()))
	n6, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n6
	dAtA[i] = 0x12
	i++
	i = encodeVarintBrowser(dAtA, i, uint64(m.ObjectMeta.Size()))
	n7, err := m.ObjectMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n7
	if len(m.URI) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintBrowser(dAtA, i, uint64(len(m.URI)))
		i += copy(dAtA[i:], m.URI)
	}
	if len(m.Reverse) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintBrowser(dAtA, i, uint64(len(m.Reverse)))
		i += copy(dAtA[i:], m.Reverse)
	}
	if len(m.QueryType) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintBrowser(dAtA, i, uint64(len(m.QueryType)))
		i += copy(dAtA[i:], m.QueryType)
	}
	if len(m.Links) > 0 {
		for k, _ := range m.Links {
			dAtA[i] = 0x32
			i++
			v := m.Links[k]
			msgSize := 0
			if (&v) != nil {
				msgSize = (&v).Size()
				msgSize += 1 + sovBrowser(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovBrowser(uint64(len(k))) + msgSize
			i = encodeVarintBrowser(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintBrowser(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintBrowser(dAtA, i, uint64((&v).Size()))
			n8, err := (&v).MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n8
		}
	}
	return i, nil
}

func (m *Object_URIs) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Object_URIs) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RefType) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBrowser(dAtA, i, uint64(len(m.RefType)))
		i += copy(dAtA[i:], m.RefType)
	}
	if len(m.URI) > 0 {
		for _, msg := range m.URI {
			dAtA[i] = 0x12
			i++
			i = encodeVarintBrowser(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func encodeVarintBrowser(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *BrowseRequest) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovBrowser(uint64(l))
	l = m.ObjectMeta.Size()
	n += 1 + l + sovBrowser(uint64(l))
	l = len(m.URI)
	if l > 0 {
		n += 1 + l + sovBrowser(uint64(l))
	}
	l = len(m.QueryType)
	if l > 0 {
		n += 1 + l + sovBrowser(uint64(l))
	}
	if m.MaxDepth != 0 {
		n += 1 + sovBrowser(uint64(m.MaxDepth))
	}
	if m.CountOnly {
		n += 2
	}
	return n
}

func (m *BrowseResponse) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovBrowser(uint64(l))
	l = m.ObjectMeta.Size()
	n += 1 + l + sovBrowser(uint64(l))
	l = len(m.RootURI)
	if l > 0 {
		n += 1 + l + sovBrowser(uint64(l))
	}
	l = len(m.QueryType)
	if l > 0 {
		n += 1 + l + sovBrowser(uint64(l))
	}
	if m.MaxDepth != 0 {
		n += 1 + sovBrowser(uint64(m.MaxDepth))
	}
	if m.TotalCount != 0 {
		n += 1 + sovBrowser(uint64(m.TotalCount))
	}
	if len(m.Objects) > 0 {
		for k, v := range m.Objects {
			_ = k
			_ = v
			l = v.Size()
			mapEntrySize := 1 + len(k) + sovBrowser(uint64(len(k))) + 1 + l + sovBrowser(uint64(l))
			n += mapEntrySize + 1 + sovBrowser(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *Object) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovBrowser(uint64(l))
	l = m.ObjectMeta.Size()
	n += 1 + l + sovBrowser(uint64(l))
	l = len(m.URI)
	if l > 0 {
		n += 1 + l + sovBrowser(uint64(l))
	}
	l = len(m.Reverse)
	if l > 0 {
		n += 1 + l + sovBrowser(uint64(l))
	}
	l = len(m.QueryType)
	if l > 0 {
		n += 1 + l + sovBrowser(uint64(l))
	}
	if len(m.Links) > 0 {
		for k, v := range m.Links {
			_ = k
			_ = v
			l = v.Size()
			mapEntrySize := 1 + len(k) + sovBrowser(uint64(len(k))) + 1 + l + sovBrowser(uint64(l))
			n += mapEntrySize + 1 + sovBrowser(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *Object_URIs) Size() (n int) {
	var l int
	_ = l
	l = len(m.RefType)
	if l > 0 {
		n += 1 + l + sovBrowser(uint64(l))
	}
	if len(m.URI) > 0 {
		for _, e := range m.URI {
			l = e.Size()
			n += 1 + l + sovBrowser(uint64(l))
		}
	}
	return n
}

func sovBrowser(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozBrowser(x uint64) (n int) {
	return sovBrowser(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *BrowseRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrowser
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BrowseRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BrowseRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrowser
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrowser
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrowser
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrowser
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URI", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrowser
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrowser
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.URI = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueryType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrowser
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrowser
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QueryType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxDepth", wireType)
			}
			m.MaxDepth = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrowser
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxDepth |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CountOnly", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrowser
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CountOnly = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipBrowser(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBrowser
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BrowseResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrowser
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BrowseResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BrowseResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrowser
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrowser
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrowser
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrowser
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RootURI", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrowser
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrowser
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RootURI = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueryType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrowser
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrowser
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QueryType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxDepth", wireType)
			}
			m.MaxDepth = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrowser
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxDepth |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalCount", wireType)
			}
			m.TotalCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrowser
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalCount |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Objects", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrowser
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrowser
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Objects == nil {
				m.Objects = make(map[string]Object)
			}
			var mapkey string
			mapvalue := &Object{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBrowser
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBrowser
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthBrowser
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBrowser
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthBrowser
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthBrowser
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Object{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipBrowser(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthBrowser
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Objects[mapkey] = *mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrowser(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBrowser
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Object) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrowser
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Object: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Object: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrowser
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrowser
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrowser
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrowser
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URI", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrowser
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrowser
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.URI = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reverse", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrowser
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrowser
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reverse = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueryType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrowser
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrowser
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QueryType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Links", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrowser
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrowser
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Links == nil {
				m.Links = make(map[string]Object_URIs)
			}
			var mapkey string
			mapvalue := &Object_URIs{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBrowser
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBrowser
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthBrowser
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBrowser
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthBrowser
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthBrowser
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Object_URIs{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipBrowser(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthBrowser
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Links[mapkey] = *mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrowser(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBrowser
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Object_URIs) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrowser
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: URIs: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: URIs: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrowser
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrowser
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RefType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URI", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrowser
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrowser
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.URI = append(m.URI, api.ObjectRef{})
			if err := m.URI[len(m.URI)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrowser(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBrowser
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipBrowser(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowBrowser
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBrowser
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBrowser
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthBrowser
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowBrowser
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipBrowser(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthBrowser = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowBrowser   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("browser.proto", fileDescriptorBrowser) }

var fileDescriptorBrowser = []byte{
	// 848 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x95, 0x41, 0x6f, 0xe3, 0x44,
	0x14, 0xc7, 0x3b, 0x49, 0xd3, 0x34, 0x93, 0x3a, 0x09, 0x53, 0x04, 0xb6, 0x85, 0x9a, 0xa8, 0xda,
	0xaa, 0xd9, 0xa8, 0x8e, 0xd9, 0x22, 0x10, 0xda, 0x03, 0x08, 0xef, 0x16, 0xa9, 0x62, 0x77, 0x0b,
	0xd3, 0x56, 0x9c, 0x9d, 0xe4, 0x25, 0x6b, 0xea, 0xcc, 0x78, 0xed, 0x71, 0x5b, 0x7f, 0x00, 0xaa,
	0xde, 0xb8, 0xf3, 0x11, 0x7a, 0xe4, 0x53, 0xec, 0x71, 0xc5, 0x07, 0x88, 0x50, 0xc4, 0x01, 0xe5,
	0xce, 0x1d, 0xcd, 0x38, 0x6e, 0x9c, 0xc0, 0x72, 0xd8, 0xcb, 0x5e, 0x92, 0xf7, 0xfe, 0xf3, 0xde,
	0xcc, 0x9b, 0xdf, 0x9b, 0x27, 0x63, 0xad, 0x17, 0xf2, 0xab, 0x08, 0xc2, 0x6e, 0x10, 0x72, 0xc1,
	0x49, 0x79, 0xee, 0x9a, 0x9f, 0x8c, 0x38, 0x1f, 0xf9, 0x60, 0xbb, 0x81, 0x67, 0xbb, 0x8c, 0x71,
	0xe1, 0x0a, 0x8f, 0xb3, 0x28, 0x0d, 0x33, 0x8f, 0x46, 0x9e, 0x78, 0x19, 0xf7, 0xba, 0x7d, 0x3e,
	0xb6, 0x03, 0x60, 0x91, 0xcb, 0x06, 0xdc, 0x8e, 0xae, 0xec, 0x4b, 0x60, 0x5e, 0x1f, 0xec, 0x58,
	0x78, 0x7e, 0x24, 0x53, 0x47, 0xc0, 0xf2, 0xd9, 0xb6, 0xc7, 0xfa, 0x7e, 0x3c, 0x80, 0x6c, 0x1b,
	0x2b, 0xb7, 0xcd, 0x88, 0x8f, 0xb8, 0xad, 0xe4, 0x5e, 0x3c, 0x54, 0x9e, 0x72, 0x94, 0x35, 0x0f,
	0xdf, 0x7b, 0xcb, 0xa9, 0xb2, 0xc6, 0x31, 0x08, 0x37, 0x0d, 0xdb, 0xfd, 0xbb, 0x80, 0x35, 0x47,
	0x5d, 0x83, 0xc2, 0xab, 0x18, 0x22, 0x41, 0xbe, 0xc0, 0xe8, 0x4c, 0x47, 0x2d, 0xd4, 0xae, 0x1e,
	0x6a, 0x5d, 0x37, 0xf0, 0xba, 0x67, 0x49, 0x00, 0xcf, 0x41, 0xb8, 0xce, 0xf6, 0xeb, 0x49, 0x73,
	0xed, 0xcd, 0xa4, 0x89, 0x66, 0x93, 0x66, 0xf9, 0xc0, 0x63, 0xbe, 0xc7, 0x80, 0x66, 0x06, 0xf9,
	0x16, 0xa3, 0x13, 0xbd, 0xa0, 0xf2, 0xea, 0x2a, 0xef, 0xa4, 0xf7, 0x13, 0xf4, 0x85, 0xca, 0x34,
	0x73, 0x99, 0x35, 0x79, 0xfa, 0x01, 0x1f, 0x7b, 0x02, 0xc6, 0x81, 0x48, 0xe8, 0x8a, 0x4f, 0x3a,
	0xb8, 0x78, 0x4e, 0x8f, 0xf5, 0x62, 0x0b, 0xb5, 0x2b, 0x8e, 0x7e, 0x77, 0x63, 0x68, 0xa7, 0x22,
	0x7c, 0x06, 0xac, 0x7d, 0x78, 0xf0, 0xf9, 0xa3, 0xc3, 0x87, 0xb3, 0x49, 0xb3, 0x18, 0x87, 0x1e,
	0x95, 0x3f, 0xe4, 0x09, 0xae, 0xfc, 0x10, 0x43, 0x98, 0xc8, 0x12, 0xf5, 0x75, 0x95, 0xf1, 0xe0,
	0xee, 0xc6, 0x20, 0xa7, 0x22, 0x3c, 0x62, 0xf1, 0xb8, 0x7d, 0xbf, 0x28, 0xd3, 0xf0, 0x2b, 0xe9,
	0x59, 0x22, 0x09, 0x80, 0xe6, 0x6c, 0x62, 0xe3, 0xcd, 0xe7, 0xee, 0xf5, 0x53, 0x08, 0xc4, 0x4b,
	0xbd, 0xd4, 0x42, 0x6d, 0xcd, 0x21, 0xbf, 0xdd, 0x18, 0xe8, 0xd1, 0x6c, 0xd2, 0xac, 0x8c, 0xdd,
	0x6b, 0x6b, 0x20, 0x57, 0xe8, 0xc2, 0x24, 0x16, 0xae, 0x3c, 0xe1, 0x31, 0x13, 0x27, 0xcc, 0x4f,
	0xf4, 0x8d, 0x16, 0x6a, 0x6f, 0x3a, 0x35, 0xb9, 0x7f, 0x5f, 0x8a, 0x16, 0x67, 0x7e, 0x42, 0x73,
	0xf6, 0xe3, 0xed, 0xdf, 0x7f, 0x36, 0xea, 0xe6, 0x32, 0xe5, 0xdd, 0x3f, 0x8b, 0xb8, 0x96, 0x29,
	0x51, 0xc0, 0x59, 0x04, 0xef, 0x1d, 0xfc, 0x3e, 0x2e, 0x53, 0xce, 0xc5, 0x02, 0xfe, 0xd6, 0x6c,
	0xd2, 0xdc, 0x0c, 0x39, 0x17, 0x96, 0x04, 0x7e, 0x6f, 0xc9, 0xfb, 0xaf, 0x52, 0xaf, 0xfd, 0x0f,
	0xdf, 0xce, 0xbf, 0xf8, 0x6a, 0x6f, 0x45, 0xfb, 0x29, 0xc6, 0x67, 0x5c, 0xb8, 0xbe, 0xe2, 0xab,
	0xd8, 0x6a, 0x4e, 0x7d, 0x36, 0x69, 0x56, 0x85, 0x54, 0x2d, 0x45, 0x95, 0xe6, 0x1d, 0x72, 0x82,
	0xcb, 0xe9, 0x7d, 0x23, 0xbd, 0xdc, 0x2a, 0xb6, 0xab, 0x87, 0x0f, 0xba, 0xd9, 0x94, 0x2e, 0xf3,
	0x9d, 0x63, 0x89, 0x8e, 0x98, 0x08, 0x13, 0xa7, 0x2e, 0xc1, 0x48, 0x9c, 0x3c, 0x55, 0x69, 0x66,
	0x98, 0xdf, 0xe1, 0xad, 0x7c, 0x24, 0x69, 0xe0, 0xe2, 0x05, 0x24, 0xaa, 0x31, 0x15, 0x2a, 0x4d,
	0xb2, 0x87, 0x4b, 0x97, 0xae, 0x1f, 0xc3, 0x3d, 0xf4, 0xec, 0xc0, 0x34, 0x8f, 0xa6, 0xab, 0x8f,
	0x0b, 0x5f, 0xa2, 0xdd, 0x5f, 0xd7, 0xf1, 0x46, 0xaa, 0xbe, 0xf7, 0xf6, 0x1a, 0xf9, 0xb9, 0x2a,
	0x2f, 0x8d, 0xd1, 0x1e, 0x2e, 0x53, 0xb8, 0x84, 0x30, 0xca, 0xda, 0x59, 0x95, 0x95, 0x84, 0xa9,
	0x44, 0x33, 0x63, 0x79, 0xda, 0x4a, 0xef, 0x38, 0x6d, 0x5f, 0xe3, 0xd2, 0x33, 0x8f, 0x5d, 0x44,
	0xfa, 0x86, 0xea, 0x96, 0xb9, 0x02, 0xaf, 0xab, 0x16, 0xd3, 0x1e, 0x69, 0xf3, 0x1e, 0x95, 0x7c,
	0xa9, 0xd1, 0xf4, 0xcf, 0xbc, 0xc6, 0xeb, 0xe7, 0xf4, 0x38, 0x22, 0xdf, 0xc8, 0xa2, 0x87, 0xaa,
	0x16, 0xd5, 0x1b, 0x67, 0xff, 0xee, 0xc6, 0xf8, 0x38, 0xab, 0x85, 0xc2, 0x10, 0x42, 0x60, 0x7d,
	0x90, 0x01, 0xd1, 0x43, 0xf5, 0x92, 0x61, 0x98, 0x96, 0x93, 0xe5, 0x11, 0x2b, 0x45, 0x52, 0x50,
	0x95, 0xd4, 0x72, 0x70, 0x29, 0x0c, 0x9d, 0xea, 0xfc, 0xf4, 0x14, 0xd3, 0x39, 0x3d, 0x36, 0x5f,
	0x60, 0xbc, 0xa8, 0xee, 0x3f, 0xde, 0x45, 0x67, 0xf9, 0x5d, 0x7c, 0xb8, 0x7a, 0x35, 0x59, 0x76,
	0xee, 0x71, 0x74, 0xbe, 0xca, 0xf1, 0x24, 0x0d, 0xbc, 0xf5, 0x14, 0x02, 0x60, 0x03, 0x60, 0x7d,
	0x0f, 0xa2, 0xc6, 0x1a, 0x69, 0x62, 0x3c, 0x57, 0x06, 0x4e, 0xd2, 0x40, 0x66, 0x7d, 0x7a, 0x6b,
	0x54, 0x07, 0x73, 0xc5, 0xea, 0x25, 0x9d, 0x5f, 0x10, 0xae, 0x2d, 0xdf, 0x93, 0xec, 0xe3, 0xda,
	0x0b, 0x77, 0x0c, 0x83, 0x7b, 0xb9, 0xb1, 0x66, 0x6e, 0x4f, 0x6f, 0x8d, 0x3a, 0x93, 0xaa, 0x15,
	0x66, 0x32, 0xd9, 0xc3, 0xda, 0x8f, 0xe0, 0x5e, 0x2c, 0xe2, 0x90, 0x49, 0xa6, 0xb7, 0x46, 0xed,
	0x0a, 0xdc, 0x8b, 0x5c, 0x98, 0x85, 0x3f, 0x38, 0x05, 0x1f, 0xfa, 0x82, 0x87, 0x8b, 0xd0, 0x82,
	0xf9, 0xd1, 0xf4, 0xd6, 0x20, 0xd1, 0x7c, 0x61, 0x11, 0xee, 0x34, 0x5e, 0x4f, 0x77, 0xd0, 0x9b,
	0xe9, 0x0e, 0xfa, 0x63, 0xba, 0x83, 0xfe, 0x9a, 0xee, 0xac, 0x7d, 0x8f, 0x7a, 0x1b, 0xea, 0x43,
	0xf3, 0xd9, 0x3f, 0x01, 0x00, 0x00, 0xff, 0xff, 0xa2, 0x72, 0x06, 0x4d, 0x3d, 0x07, 0x00, 0x00,
}
