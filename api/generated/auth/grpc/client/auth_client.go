// Code generated by protoc-gen-grpc-pensando DO NOT EDIT.

package grpcclient

import (
	"context"
	"errors"
	oldlog "log"

	"github.com/go-kit/kit/endpoint"
	grpctransport "github.com/go-kit/kit/transport/grpc"
	"google.golang.org/grpc"

	api "github.com/pensando/sw/api"
	auth "github.com/pensando/sw/api/generated/auth"
	listerwatcher "github.com/pensando/sw/api/listerwatcher"
	apiserver "github.com/pensando/sw/venice/apiserver"
	"github.com/pensando/sw/venice/utils/kvstore"
	"github.com/pensando/sw/venice/utils/log"
	"github.com/pensando/sw/venice/utils/trace"
)

// Dummy vars to suppress import errors
var _ api.TypeMeta
var _ listerwatcher.WatcherClient
var _ kvstore.Interface

// NewAuthV1 sets up a new client for AuthV1
func NewAuthV1(conn *grpc.ClientConn, logger log.Logger) auth.ServiceAuthV1Client {

	var lAutoAddAuthenticationPolicyEndpoint endpoint.Endpoint
	{
		lAutoAddAuthenticationPolicyEndpoint = grpctransport.NewClient(
			conn,
			"auth.AuthV1",
			"AutoAddAuthenticationPolicy",
			auth.EncodeGrpcReqAuthenticationPolicy,
			auth.DecodeGrpcRespAuthenticationPolicy,
			&auth.AuthenticationPolicy{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoAddAuthenticationPolicyEndpoint = trace.ClientEndPoint("AuthV1:AutoAddAuthenticationPolicy")(lAutoAddAuthenticationPolicyEndpoint)
	}
	var lAutoAddUserEndpoint endpoint.Endpoint
	{
		lAutoAddUserEndpoint = grpctransport.NewClient(
			conn,
			"auth.AuthV1",
			"AutoAddUser",
			auth.EncodeGrpcReqUser,
			auth.DecodeGrpcRespUser,
			&auth.User{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoAddUserEndpoint = trace.ClientEndPoint("AuthV1:AutoAddUser")(lAutoAddUserEndpoint)
	}
	var lAutoDeleteAuthenticationPolicyEndpoint endpoint.Endpoint
	{
		lAutoDeleteAuthenticationPolicyEndpoint = grpctransport.NewClient(
			conn,
			"auth.AuthV1",
			"AutoDeleteAuthenticationPolicy",
			auth.EncodeGrpcReqAuthenticationPolicy,
			auth.DecodeGrpcRespAuthenticationPolicy,
			&auth.AuthenticationPolicy{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoDeleteAuthenticationPolicyEndpoint = trace.ClientEndPoint("AuthV1:AutoDeleteAuthenticationPolicy")(lAutoDeleteAuthenticationPolicyEndpoint)
	}
	var lAutoDeleteUserEndpoint endpoint.Endpoint
	{
		lAutoDeleteUserEndpoint = grpctransport.NewClient(
			conn,
			"auth.AuthV1",
			"AutoDeleteUser",
			auth.EncodeGrpcReqUser,
			auth.DecodeGrpcRespUser,
			&auth.User{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoDeleteUserEndpoint = trace.ClientEndPoint("AuthV1:AutoDeleteUser")(lAutoDeleteUserEndpoint)
	}
	var lAutoGetAuthenticationPolicyEndpoint endpoint.Endpoint
	{
		lAutoGetAuthenticationPolicyEndpoint = grpctransport.NewClient(
			conn,
			"auth.AuthV1",
			"AutoGetAuthenticationPolicy",
			auth.EncodeGrpcReqAuthenticationPolicy,
			auth.DecodeGrpcRespAuthenticationPolicy,
			&auth.AuthenticationPolicy{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoGetAuthenticationPolicyEndpoint = trace.ClientEndPoint("AuthV1:AutoGetAuthenticationPolicy")(lAutoGetAuthenticationPolicyEndpoint)
	}
	var lAutoGetUserEndpoint endpoint.Endpoint
	{
		lAutoGetUserEndpoint = grpctransport.NewClient(
			conn,
			"auth.AuthV1",
			"AutoGetUser",
			auth.EncodeGrpcReqUser,
			auth.DecodeGrpcRespUser,
			&auth.User{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoGetUserEndpoint = trace.ClientEndPoint("AuthV1:AutoGetUser")(lAutoGetUserEndpoint)
	}
	var lAutoListAuthenticationPolicyEndpoint endpoint.Endpoint
	{
		lAutoListAuthenticationPolicyEndpoint = grpctransport.NewClient(
			conn,
			"auth.AuthV1",
			"AutoListAuthenticationPolicy",
			auth.EncodeGrpcReqListWatchOptions,
			auth.DecodeGrpcRespAuthenticationPolicyList,
			&auth.AuthenticationPolicyList{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoListAuthenticationPolicyEndpoint = trace.ClientEndPoint("AuthV1:AutoListAuthenticationPolicy")(lAutoListAuthenticationPolicyEndpoint)
	}
	var lAutoListUserEndpoint endpoint.Endpoint
	{
		lAutoListUserEndpoint = grpctransport.NewClient(
			conn,
			"auth.AuthV1",
			"AutoListUser",
			auth.EncodeGrpcReqListWatchOptions,
			auth.DecodeGrpcRespUserList,
			&auth.UserList{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoListUserEndpoint = trace.ClientEndPoint("AuthV1:AutoListUser")(lAutoListUserEndpoint)
	}
	var lAutoUpdateAuthenticationPolicyEndpoint endpoint.Endpoint
	{
		lAutoUpdateAuthenticationPolicyEndpoint = grpctransport.NewClient(
			conn,
			"auth.AuthV1",
			"AutoUpdateAuthenticationPolicy",
			auth.EncodeGrpcReqAuthenticationPolicy,
			auth.DecodeGrpcRespAuthenticationPolicy,
			&auth.AuthenticationPolicy{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoUpdateAuthenticationPolicyEndpoint = trace.ClientEndPoint("AuthV1:AutoUpdateAuthenticationPolicy")(lAutoUpdateAuthenticationPolicyEndpoint)
	}
	var lAutoUpdateUserEndpoint endpoint.Endpoint
	{
		lAutoUpdateUserEndpoint = grpctransport.NewClient(
			conn,
			"auth.AuthV1",
			"AutoUpdateUser",
			auth.EncodeGrpcReqUser,
			auth.DecodeGrpcRespUser,
			&auth.User{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoUpdateUserEndpoint = trace.ClientEndPoint("AuthV1:AutoUpdateUser")(lAutoUpdateUserEndpoint)
	}
	return auth.EndpointsAuthV1Client{
		Client: auth.NewAuthV1Client(conn),

		AutoAddAuthenticationPolicyEndpoint:    lAutoAddAuthenticationPolicyEndpoint,
		AutoAddUserEndpoint:                    lAutoAddUserEndpoint,
		AutoDeleteAuthenticationPolicyEndpoint: lAutoDeleteAuthenticationPolicyEndpoint,
		AutoDeleteUserEndpoint:                 lAutoDeleteUserEndpoint,
		AutoGetAuthenticationPolicyEndpoint:    lAutoGetAuthenticationPolicyEndpoint,
		AutoGetUserEndpoint:                    lAutoGetUserEndpoint,
		AutoListAuthenticationPolicyEndpoint:   lAutoListAuthenticationPolicyEndpoint,
		AutoListUserEndpoint:                   lAutoListUserEndpoint,
		AutoUpdateAuthenticationPolicyEndpoint: lAutoUpdateAuthenticationPolicyEndpoint,
		AutoUpdateUserEndpoint:                 lAutoUpdateUserEndpoint,
	}
}

// NewAuthV1Backend creates an instrumented client with middleware
func NewAuthV1Backend(conn *grpc.ClientConn, logger log.Logger) auth.ServiceAuthV1Client {
	cl := NewAuthV1(conn, logger)
	cl = auth.LoggingAuthV1MiddlewareClient(logger)(cl)
	return cl
}

type grpcObjAuthV1User struct {
	logger log.Logger
	client auth.ServiceAuthV1Client
}

func (a *grpcObjAuthV1User) Create(ctx context.Context, in *auth.User) (*auth.User, error) {
	a.logger.DebugLog("msg", "received call", "object", "User", "oper", "create")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoAddUser(nctx, in)
}

func (a *grpcObjAuthV1User) Update(ctx context.Context, in *auth.User) (*auth.User, error) {
	a.logger.DebugLog("msg", "received call", "object", "User", "oper", "update")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoUpdateUser(nctx, in)
}

func (a *grpcObjAuthV1User) Get(ctx context.Context, objMeta *api.ObjectMeta) (*auth.User, error) {
	a.logger.DebugLog("msg", "received call", "object", "User", "oper", "get")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := auth.User{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoGetUser(nctx, &in)
}

func (a *grpcObjAuthV1User) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*auth.User, error) {
	a.logger.DebugLog("msg", "received call", "object", "User", "oper", "delete")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := auth.User{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoDeleteUser(nctx, &in)
}

func (a *grpcObjAuthV1User) List(ctx context.Context, options *api.ListWatchOptions) ([]*auth.User, error) {
	a.logger.DebugLog("msg", "received call", "object", "User", "oper", "list")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	r, err := a.client.AutoListUser(nctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *grpcObjAuthV1User) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	a.logger.DebugLog("msg", "received call", "object", "User", "oper", "WatchOper")
	nctx := addVersion(ctx, "v1")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	stream, err := a.client.AutoWatchUser(nctx, options)
	if err != nil {
		return nil, err
	}
	wstream := stream.(auth.AuthV1_AutoWatchUserClient)
	bridgefn := func(lw *listerwatcher.WatcherClient) {
		for {
			r, err := wstream.Recv()
			if err != nil {
				a.logger.ErrorLog("msg", "error on receive", "error", err)
				close(lw.OutCh)
				return
			}
			ev := kvstore.WatchEvent{
				Type:   kvstore.WatchEventType(r.Type),
				Object: r.Object,
			}
			select {
			case lw.OutCh <- &ev:
			case <-wstream.Context().Done():
				close(lw.OutCh)
				return
			}
		}
	}
	lw := listerwatcher.NewWatcherClient(wstream, bridgefn)
	lw.Run()
	return lw, nil
}

func (a *grpcObjAuthV1User) Allowed(oper apiserver.APIOperType) bool {
	return true
}

type restObjAuthV1User struct {
	endpoints auth.EndpointsAuthV1RestClient
	instance  string
}

func (a *restObjAuthV1User) Create(ctx context.Context, in *auth.User) (*auth.User, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoAddUser(ctx, in)
}

func (a *restObjAuthV1User) Update(ctx context.Context, in *auth.User) (*auth.User, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoUpdateUser(ctx, in)
}

func (a *restObjAuthV1User) Get(ctx context.Context, objMeta *api.ObjectMeta) (*auth.User, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := auth.User{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoGetUser(ctx, &in)
}

func (a *restObjAuthV1User) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*auth.User, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := auth.User{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoDeleteUser(ctx, &in)
}

func (a *restObjAuthV1User) List(ctx context.Context, options *api.ListWatchOptions) ([]*auth.User, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}
	r, err := a.endpoints.AutoListUser(ctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *restObjAuthV1User) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	return nil, errors.New("not allowed")
}

func (a *restObjAuthV1User) Allowed(oper apiserver.APIOperType) bool {
	switch oper {
	case apiserver.CreateOper:
		return true
	case apiserver.UpdateOper:
		return true
	case apiserver.GetOper:
		return true
	case apiserver.DeleteOper:
		return true
	case apiserver.ListOper:
		return true
	case apiserver.WatchOper:
		return false
	default:
		return false
	}
}

type grpcObjAuthV1AuthenticationPolicy struct {
	logger log.Logger
	client auth.ServiceAuthV1Client
}

func (a *grpcObjAuthV1AuthenticationPolicy) Create(ctx context.Context, in *auth.AuthenticationPolicy) (*auth.AuthenticationPolicy, error) {
	a.logger.DebugLog("msg", "received call", "object", "AuthenticationPolicy", "oper", "create")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoAddAuthenticationPolicy(nctx, in)
}

func (a *grpcObjAuthV1AuthenticationPolicy) Update(ctx context.Context, in *auth.AuthenticationPolicy) (*auth.AuthenticationPolicy, error) {
	a.logger.DebugLog("msg", "received call", "object", "AuthenticationPolicy", "oper", "update")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoUpdateAuthenticationPolicy(nctx, in)
}

func (a *grpcObjAuthV1AuthenticationPolicy) Get(ctx context.Context, objMeta *api.ObjectMeta) (*auth.AuthenticationPolicy, error) {
	a.logger.DebugLog("msg", "received call", "object", "AuthenticationPolicy", "oper", "get")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := auth.AuthenticationPolicy{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoGetAuthenticationPolicy(nctx, &in)
}

func (a *grpcObjAuthV1AuthenticationPolicy) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*auth.AuthenticationPolicy, error) {
	a.logger.DebugLog("msg", "received call", "object", "AuthenticationPolicy", "oper", "delete")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := auth.AuthenticationPolicy{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoDeleteAuthenticationPolicy(nctx, &in)
}

func (a *grpcObjAuthV1AuthenticationPolicy) List(ctx context.Context, options *api.ListWatchOptions) ([]*auth.AuthenticationPolicy, error) {
	a.logger.DebugLog("msg", "received call", "object", "AuthenticationPolicy", "oper", "list")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	r, err := a.client.AutoListAuthenticationPolicy(nctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *grpcObjAuthV1AuthenticationPolicy) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	a.logger.DebugLog("msg", "received call", "object", "AuthenticationPolicy", "oper", "WatchOper")
	nctx := addVersion(ctx, "v1")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	stream, err := a.client.AutoWatchAuthenticationPolicy(nctx, options)
	if err != nil {
		return nil, err
	}
	wstream := stream.(auth.AuthV1_AutoWatchAuthenticationPolicyClient)
	bridgefn := func(lw *listerwatcher.WatcherClient) {
		for {
			r, err := wstream.Recv()
			if err != nil {
				a.logger.ErrorLog("msg", "error on receive", "error", err)
				close(lw.OutCh)
				return
			}
			ev := kvstore.WatchEvent{
				Type:   kvstore.WatchEventType(r.Type),
				Object: r.Object,
			}
			select {
			case lw.OutCh <- &ev:
			case <-wstream.Context().Done():
				close(lw.OutCh)
				return
			}
		}
	}
	lw := listerwatcher.NewWatcherClient(wstream, bridgefn)
	lw.Run()
	return lw, nil
}

func (a *grpcObjAuthV1AuthenticationPolicy) Allowed(oper apiserver.APIOperType) bool {
	return true
}

type restObjAuthV1AuthenticationPolicy struct {
	endpoints auth.EndpointsAuthV1RestClient
	instance  string
}

func (a *restObjAuthV1AuthenticationPolicy) Create(ctx context.Context, in *auth.AuthenticationPolicy) (*auth.AuthenticationPolicy, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoAddAuthenticationPolicy(ctx, in)
}

func (a *restObjAuthV1AuthenticationPolicy) Update(ctx context.Context, in *auth.AuthenticationPolicy) (*auth.AuthenticationPolicy, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoUpdateAuthenticationPolicy(ctx, in)
}

func (a *restObjAuthV1AuthenticationPolicy) Get(ctx context.Context, objMeta *api.ObjectMeta) (*auth.AuthenticationPolicy, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := auth.AuthenticationPolicy{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoGetAuthenticationPolicy(ctx, &in)
}

func (a *restObjAuthV1AuthenticationPolicy) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*auth.AuthenticationPolicy, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := auth.AuthenticationPolicy{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoDeleteAuthenticationPolicy(ctx, &in)
}

func (a *restObjAuthV1AuthenticationPolicy) List(ctx context.Context, options *api.ListWatchOptions) ([]*auth.AuthenticationPolicy, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}
	r, err := a.endpoints.AutoListAuthenticationPolicy(ctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *restObjAuthV1AuthenticationPolicy) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	return nil, errors.New("not allowed")
}

func (a *restObjAuthV1AuthenticationPolicy) Allowed(oper apiserver.APIOperType) bool {
	switch oper {
	case apiserver.CreateOper:
		return true
	case apiserver.UpdateOper:
		return true
	case apiserver.GetOper:
		return true
	case apiserver.DeleteOper:
		return true
	case apiserver.ListOper:
		return false
	case apiserver.WatchOper:
		return false
	default:
		return false
	}
}

type crudClientAuthV1 struct {
	grpcUser                 auth.UserInterface
	grpcAuthenticationPolicy auth.AuthenticationPolicyInterface
}

// NewGrpcCrudClientAuthV1 creates a GRPC client for the service
func NewGrpcCrudClientAuthV1(conn *grpc.ClientConn, logger log.Logger) auth.AuthV1Interface {
	client := NewAuthV1Backend(conn, logger)
	return &crudClientAuthV1{

		grpcUser:                 &grpcObjAuthV1User{client: client, logger: logger},
		grpcAuthenticationPolicy: &grpcObjAuthV1AuthenticationPolicy{client: client, logger: logger},
	}
}

func (a *crudClientAuthV1) User() auth.UserInterface {
	return a.grpcUser
}

func (a *crudClientAuthV1) AuthenticationPolicy() auth.AuthenticationPolicyInterface {
	return a.grpcAuthenticationPolicy
}

type crudRestClientAuthV1 struct {
	restUser                 auth.UserInterface
	restAuthenticationPolicy auth.AuthenticationPolicyInterface
}

// NewRestCrudClientAuthV1 creates a REST client for the service.
func NewRestCrudClientAuthV1(url string) auth.AuthV1Interface {
	endpoints, err := auth.MakeAuthV1RestClientEndpoints(url)
	if err != nil {
		oldlog.Fatal("failed to create client")
	}
	return &crudRestClientAuthV1{

		restUser:                 &restObjAuthV1User{endpoints: endpoints, instance: url},
		restAuthenticationPolicy: &restObjAuthV1AuthenticationPolicy{endpoints: endpoints, instance: url},
	}
}

func (a *crudRestClientAuthV1) User() auth.UserInterface {
	return a.restUser
}

func (a *crudRestClientAuthV1) AuthenticationPolicy() auth.AuthenticationPolicyInterface {
	return a.restAuthenticationPolicy
}
