// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: auth.proto

/*
	Package auth is a generated protocol buffer package.

	Service name

	It is generated from these files:
		auth.proto
		svc_auth.proto

	It has these top-level messages:
		AuthenticationPolicy
		AuthenticationPolicySpec
		AuthenticationPolicyStatus
		Authenticators
		Ldap
		LdapAttributeMapping
		Local
		PasswordCredential
		Permission
		Radius
		Role
		RoleBinding
		RoleBindingSpec
		RoleBindingStatus
		RoleSpec
		RoleStatus
		TLSOptions
		User
		UserSpec
		UserStatus
		AuthenticationPolicyList
		AutoMsgAuthenticationPolicyWatchHelper
		AutoMsgRoleBindingWatchHelper
		AutoMsgRoleWatchHelper
		AutoMsgUserWatchHelper
		RoleBindingList
		RoleList
		UserList
*/
package auth

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/pensando/grpc-gateway/third_party/googleapis/google/api"
import _ "github.com/pensando/sw/venice/utils/apigen/annotations"
import _ "github.com/gogo/protobuf/gogoproto"
import api "github.com/pensando/sw/api"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type Authenticators_AuthenticatorType int32

const (
	Authenticators_LOCAL  Authenticators_AuthenticatorType = 0
	Authenticators_LDAP   Authenticators_AuthenticatorType = 1
	Authenticators_RADIUS Authenticators_AuthenticatorType = 2
)

var Authenticators_AuthenticatorType_name = map[int32]string{
	0: "LOCAL",
	1: "LDAP",
	2: "RADIUS",
}
var Authenticators_AuthenticatorType_value = map[string]int32{
	"LOCAL":  0,
	"LDAP":   1,
	"RADIUS": 2,
}

func (x Authenticators_AuthenticatorType) String() string {
	return proto.EnumName(Authenticators_AuthenticatorType_name, int32(x))
}
func (Authenticators_AuthenticatorType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorAuth, []int{3, 0}
}

type Permission_ResrcKind int32

const (
	Permission_ALL_RESOURCE_KINDS Permission_ResrcKind = 0
	Permission_TENANT             Permission_ResrcKind = 1
	Permission_CLUSTER            Permission_ResrcKind = 2
	Permission_NODE               Permission_ResrcKind = 3
	Permission_SMARTNIC           Permission_ResrcKind = 4
	Permission_CERTIFICATE        Permission_ResrcKind = 5
	Permission_NETWORK            Permission_ResrcKind = 6
	Permission_SERVICE            Permission_ResrcKind = 7
	Permission_LBPOLICY           Permission_ResrcKind = 8
	Permission_ENDPOINT           Permission_ResrcKind = 9
	Permission_SECURITYGROUP      Permission_ResrcKind = 10
	Permission_SGPOLICY           Permission_ResrcKind = 11
	Permission_APP                Permission_ResrcKind = 12
	Permission_ENCRYPTIONPOLICY   Permission_ResrcKind = 13
	Permission_ALERT              Permission_ResrcKind = 14
	Permission_ALERTPOLICY        Permission_ResrcKind = 15
	Permission_ALERTDESTINATION   Permission_ResrcKind = 16
	Permission_EVENTPOLICY        Permission_ResrcKind = 17
	Permission_STATSPOLICY        Permission_ResrcKind = 18
	Permission_FWLOGPOLICY        Permission_ResrcKind = 19
	Permission_FLOWEXPORTPOLICY   Permission_ResrcKind = 20
	Permission_USER               Permission_ResrcKind = 21
	Permission_AUTHPOLICY         Permission_ResrcKind = 22
	Permission_ROLE               Permission_ResrcKind = 23
	Permission_ROLEBINDING        Permission_ResrcKind = 24
	Permission_APIENDPOINT        Permission_ResrcKind = 25
)

var Permission_ResrcKind_name = map[int32]string{
	0:  "ALL_RESOURCE_KINDS",
	1:  "TENANT",
	2:  "CLUSTER",
	3:  "NODE",
	4:  "SMARTNIC",
	5:  "CERTIFICATE",
	6:  "NETWORK",
	7:  "SERVICE",
	8:  "LBPOLICY",
	9:  "ENDPOINT",
	10: "SECURITYGROUP",
	11: "SGPOLICY",
	12: "APP",
	13: "ENCRYPTIONPOLICY",
	14: "ALERT",
	15: "ALERTPOLICY",
	16: "ALERTDESTINATION",
	17: "EVENTPOLICY",
	18: "STATSPOLICY",
	19: "FWLOGPOLICY",
	20: "FLOWEXPORTPOLICY",
	21: "USER",
	22: "AUTHPOLICY",
	23: "ROLE",
	24: "ROLEBINDING",
	25: "APIENDPOINT",
}
var Permission_ResrcKind_value = map[string]int32{
	"ALL_RESOURCE_KINDS": 0,
	"TENANT":             1,
	"CLUSTER":            2,
	"NODE":               3,
	"SMARTNIC":           4,
	"CERTIFICATE":        5,
	"NETWORK":            6,
	"SERVICE":            7,
	"LBPOLICY":           8,
	"ENDPOINT":           9,
	"SECURITYGROUP":      10,
	"SGPOLICY":           11,
	"APP":                12,
	"ENCRYPTIONPOLICY":   13,
	"ALERT":              14,
	"ALERTPOLICY":        15,
	"ALERTDESTINATION":   16,
	"EVENTPOLICY":        17,
	"STATSPOLICY":        18,
	"FWLOGPOLICY":        19,
	"FLOWEXPORTPOLICY":   20,
	"USER":               21,
	"AUTHPOLICY":         22,
	"ROLE":               23,
	"ROLEBINDING":        24,
	"APIENDPOINT":        25,
}

func (x Permission_ResrcKind) String() string {
	return proto.EnumName(Permission_ResrcKind_name, int32(x))
}
func (Permission_ResrcKind) EnumDescriptor() ([]byte, []int) { return fileDescriptorAuth, []int{8, 0} }

type Permission_ActionType int32

const (
	Permission_ALL_ACTIONS Permission_ActionType = 0
	Permission_CREATE      Permission_ActionType = 1
	Permission_READ        Permission_ActionType = 2
	Permission_UPDATE      Permission_ActionType = 3
	Permission_DELETE      Permission_ActionType = 4
	Permission_COMMIT      Permission_ActionType = 5
)

var Permission_ActionType_name = map[int32]string{
	0: "ALL_ACTIONS",
	1: "CREATE",
	2: "READ",
	3: "UPDATE",
	4: "DELETE",
	5: "COMMIT",
}
var Permission_ActionType_value = map[string]int32{
	"ALL_ACTIONS": 0,
	"CREATE":      1,
	"READ":        2,
	"UPDATE":      3,
	"DELETE":      4,
	"COMMIT":      5,
}

func (x Permission_ActionType) String() string {
	return proto.EnumName(Permission_ActionType_name, int32(x))
}
func (Permission_ActionType) EnumDescriptor() ([]byte, []int) { return fileDescriptorAuth, []int{8, 1} }

type UserSpec_UserType int32

const (
	UserSpec_LOCAL    UserSpec_UserType = 0
	UserSpec_EXTERNAL UserSpec_UserType = 1
)

var UserSpec_UserType_name = map[int32]string{
	0: "LOCAL",
	1: "EXTERNAL",
}
var UserSpec_UserType_value = map[string]int32{
	"LOCAL":    0,
	"EXTERNAL": 1,
}

func (x UserSpec_UserType) String() string {
	return proto.EnumName(UserSpec_UserType_name, int32(x))
}
func (UserSpec_UserType) EnumDescriptor() ([]byte, []int) { return fileDescriptorAuth, []int{18, 0} }

// spec part of user object
type AuthenticationPolicy struct {
	api.TypeMeta   `protobuf:"bytes,1,opt,name=T,embedded=T" json:",inline"`
	api.ObjectMeta `protobuf:"bytes,2,opt,name=O,embedded=O" json:"meta,omitempty"`
	Spec           AuthenticationPolicySpec   `protobuf:"bytes,3,opt,name=Spec" json:"spec,omitempty"`
	Status         AuthenticationPolicyStatus `protobuf:"bytes,4,opt,name=Status" json:"status,omitempty"`
}

func (m *AuthenticationPolicy) Reset()                    { *m = AuthenticationPolicy{} }
func (m *AuthenticationPolicy) String() string            { return proto.CompactTextString(m) }
func (*AuthenticationPolicy) ProtoMessage()               {}
func (*AuthenticationPolicy) Descriptor() ([]byte, []int) { return fileDescriptorAuth, []int{0} }

func (m *AuthenticationPolicy) GetSpec() AuthenticationPolicySpec {
	if m != nil {
		return m.Spec
	}
	return AuthenticationPolicySpec{}
}

func (m *AuthenticationPolicy) GetStatus() AuthenticationPolicyStatus {
	if m != nil {
		return m.Status
	}
	return AuthenticationPolicyStatus{}
}

// status part of user object
type AuthenticationPolicySpec struct {
	Authenticators Authenticators `protobuf:"bytes,1,opt,name=Authenticators" json:"authenticators,omitempty"`
	Secret         []byte         `protobuf:"bytes,2,opt,name=Secret,proto3" json:"secret,omitempty"`
}

func (m *AuthenticationPolicySpec) Reset()                    { *m = AuthenticationPolicySpec{} }
func (m *AuthenticationPolicySpec) String() string            { return proto.CompactTextString(m) }
func (*AuthenticationPolicySpec) ProtoMessage()               {}
func (*AuthenticationPolicySpec) Descriptor() ([]byte, []int) { return fileDescriptorAuth, []int{1} }

func (m *AuthenticationPolicySpec) GetAuthenticators() Authenticators {
	if m != nil {
		return m.Authenticators
	}
	return Authenticators{}
}

func (m *AuthenticationPolicySpec) GetSecret() []byte {
	if m != nil {
		return m.Secret
	}
	return nil
}

// User could be local or external
type AuthenticationPolicyStatus struct {
}

func (m *AuthenticationPolicyStatus) Reset()                    { *m = AuthenticationPolicyStatus{} }
func (m *AuthenticationPolicyStatus) String() string            { return proto.CompactTextString(m) }
func (*AuthenticationPolicyStatus) ProtoMessage()               {}
func (*AuthenticationPolicyStatus) Descriptor() ([]byte, []int) { return fileDescriptorAuth, []int{2} }

// spec part of authentication policy object
type Authenticators struct {
	Ldap *Ldap `protobuf:"bytes,1,opt,name=Ldap" json:"ldap,omitempty"`
	// Secret used to sign JWT token
	Local              *Local   `protobuf:"bytes,2,opt,name=Local" json:"local,omitempty"`
	Radius             *Radius  `protobuf:"bytes,3,opt,name=Radius" json:"radius,omitempty"`
	AuthenticatorOrder []string `protobuf:"bytes,9,rep,name=AuthenticatorOrder" json:"authenticator-order,omitempty"`
}

func (m *Authenticators) Reset()                    { *m = Authenticators{} }
func (m *Authenticators) String() string            { return proto.CompactTextString(m) }
func (*Authenticators) ProtoMessage()               {}
func (*Authenticators) Descriptor() ([]byte, []int) { return fileDescriptorAuth, []int{3} }

func (m *Authenticators) GetLdap() *Ldap {
	if m != nil {
		return m.Ldap
	}
	return nil
}

func (m *Authenticators) GetLocal() *Local {
	if m != nil {
		return m.Local
	}
	return nil
}

func (m *Authenticators) GetRadius() *Radius {
	if m != nil {
		return m.Radius
	}
	return nil
}

func (m *Authenticators) GetAuthenticatorOrder() []string {
	if m != nil {
		return m.AuthenticatorOrder
	}
	return nil
}

type Ldap struct {
	Enabled    bool        `protobuf:"varint,1,opt,name=Enabled,proto3" json:"enabled,omitempty"`
	Url        string      `protobuf:"bytes,2,opt,name=Url,proto3" json:"url,omitempty"`
	TLSOptions *TLSOptions `protobuf:"bytes,3,opt,name=TLSOptions" json:"tls-options,omitempty"`
	// Order in which authenticators are applied. If an authenticator returns success, others are skipped
	BaseDN           string                `protobuf:"bytes,4,opt,name=BaseDN,proto3" json:"base-dn,omitempty"`
	BindDN           string                `protobuf:"bytes,5,opt,name=BindDN,proto3" json:"bind-dn,omitempty"`
	BindPassword     string                `protobuf:"bytes,6,opt,name=BindPassword,proto3" json:"bind-password,omitempty"`
	AttributeMapping *LdapAttributeMapping `protobuf:"bytes,7,opt,name=AttributeMapping" json:"attribute-mapping,omitempty"`
}

func (m *Ldap) Reset()                    { *m = Ldap{} }
func (m *Ldap) String() string            { return proto.CompactTextString(m) }
func (*Ldap) ProtoMessage()               {}
func (*Ldap) Descriptor() ([]byte, []int) { return fileDescriptorAuth, []int{4} }

func (m *Ldap) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

func (m *Ldap) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *Ldap) GetTLSOptions() *TLSOptions {
	if m != nil {
		return m.TLSOptions
	}
	return nil
}

func (m *Ldap) GetBaseDN() string {
	if m != nil {
		return m.BaseDN
	}
	return ""
}

func (m *Ldap) GetBindDN() string {
	if m != nil {
		return m.BindDN
	}
	return ""
}

func (m *Ldap) GetBindPassword() string {
	if m != nil {
		return m.BindPassword
	}
	return ""
}

func (m *Ldap) GetAttributeMapping() *LdapAttributeMapping {
	if m != nil {
		return m.AttributeMapping
	}
	return nil
}

type LdapAttributeMapping struct {
	User             string `protobuf:"bytes,1,opt,name=User,proto3" json:"user,omitempty"`
	UserObjectClass  string `protobuf:"bytes,2,opt,name=UserObjectClass,proto3" json:"user-object-class,omitempty"`
	Tenant           string `protobuf:"bytes,3,opt,name=Tenant,proto3" json:"tenant,omitempty"`
	Group            string `protobuf:"bytes,4,opt,name=Group,proto3" json:"group,omitempty"`
	GroupObjectClass string `protobuf:"bytes,5,opt,name=GroupObjectClass,proto3" json:"group-object-class,omitempty"`
	Email            string `protobuf:"bytes,6,opt,name=Email,proto3" json:"email,omitempty"`
	Fullname         string `protobuf:"bytes,7,opt,name=Fullname,proto3" json:"fullname,omitempty"`
}

func (m *LdapAttributeMapping) Reset()                    { *m = LdapAttributeMapping{} }
func (m *LdapAttributeMapping) String() string            { return proto.CompactTextString(m) }
func (*LdapAttributeMapping) ProtoMessage()               {}
func (*LdapAttributeMapping) Descriptor() ([]byte, []int) { return fileDescriptorAuth, []int{5} }

func (m *LdapAttributeMapping) GetUser() string {
	if m != nil {
		return m.User
	}
	return ""
}

func (m *LdapAttributeMapping) GetUserObjectClass() string {
	if m != nil {
		return m.UserObjectClass
	}
	return ""
}

func (m *LdapAttributeMapping) GetTenant() string {
	if m != nil {
		return m.Tenant
	}
	return ""
}

func (m *LdapAttributeMapping) GetGroup() string {
	if m != nil {
		return m.Group
	}
	return ""
}

func (m *LdapAttributeMapping) GetGroupObjectClass() string {
	if m != nil {
		return m.GroupObjectClass
	}
	return ""
}

func (m *LdapAttributeMapping) GetEmail() string {
	if m != nil {
		return m.Email
	}
	return ""
}

func (m *LdapAttributeMapping) GetFullname() string {
	if m != nil {
		return m.Fullname
	}
	return ""
}

type Local struct {
	// StartTLS determines if ldap connection uses TLS
	Enabled bool `protobuf:"varint,1,opt,name=Enabled,proto3" json:"enabled,omitempty"`
}

func (m *Local) Reset()                    { *m = Local{} }
func (m *Local) String() string            { return proto.CompactTextString(m) }
func (*Local) ProtoMessage()               {}
func (*Local) Descriptor() ([]byte, []int) { return fileDescriptorAuth, []int{6} }

func (m *Local) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

type PasswordCredential struct {
	Username string `protobuf:"bytes,1,opt,name=Username,proto3" json:"username,omitempty"`
	// UserObjectClass is the STRUCTURAL object class for user entry in LDAP. It is used as a filter for user search
	Password string `protobuf:"bytes,2,opt,name=Password,proto3" json:"password,omitempty"`
	Tenant   string `protobuf:"bytes,3,opt,name=Tenant,proto3" json:"tenant,omitempty"`
}

func (m *PasswordCredential) Reset()                    { *m = PasswordCredential{} }
func (m *PasswordCredential) String() string            { return proto.CompactTextString(m) }
func (*PasswordCredential) ProtoMessage()               {}
func (*PasswordCredential) Descriptor() ([]byte, []int) { return fileDescriptorAuth, []int{7} }

func (m *PasswordCredential) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *PasswordCredential) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

func (m *PasswordCredential) GetTenant() string {
	if m != nil {
		return m.Tenant
	}
	return ""
}

type Permission struct {
	ResourceTenant    string   `protobuf:"bytes,1,opt,name=ResourceTenant,proto3" json:"resource-tenant,omitempty"`
	ResourceGroup     string   `protobuf:"bytes,2,opt,name=ResourceGroup,proto3" json:"resource-group,omitempty"`
	ResourceKind      string   `protobuf:"bytes,3,opt,name=ResourceKind,proto3" json:"resource-kind,omitempty"`
	ResourceNamespace string   `protobuf:"bytes,4,opt,name=ResourceNamespace,proto3" json:"resource-namespace,omitempty"`
	ResourceNames     []string `protobuf:"bytes,5,rep,name=ResourceNames" json:"resource-names,omitempty"`
	Actions           []string `protobuf:"bytes,6,rep,name=Actions" json:"actions,omitempty"`
}

func (m *Permission) Reset()                    { *m = Permission{} }
func (m *Permission) String() string            { return proto.CompactTextString(m) }
func (*Permission) ProtoMessage()               {}
func (*Permission) Descriptor() ([]byte, []int) { return fileDescriptorAuth, []int{8} }

func (m *Permission) GetResourceTenant() string {
	if m != nil {
		return m.ResourceTenant
	}
	return ""
}

func (m *Permission) GetResourceGroup() string {
	if m != nil {
		return m.ResourceGroup
	}
	return ""
}

func (m *Permission) GetResourceKind() string {
	if m != nil {
		return m.ResourceKind
	}
	return ""
}

func (m *Permission) GetResourceNamespace() string {
	if m != nil {
		return m.ResourceNamespace
	}
	return ""
}

func (m *Permission) GetResourceNames() []string {
	if m != nil {
		return m.ResourceNames
	}
	return nil
}

func (m *Permission) GetActions() []string {
	if m != nil {
		return m.Actions
	}
	return nil
}

type Radius struct {
	Enabled bool   `protobuf:"varint,1,opt,name=Enabled,proto3" json:"enabled,omitempty"`
	Ip      string `protobuf:"bytes,2,opt,name=Ip,proto3" json:"ip,omitempty"`
	Port    string `protobuf:"bytes,3,opt,name=Port,proto3" json:"port,omitempty"`
	NasIp   string `protobuf:"bytes,4,opt,name=NasIp,proto3" json:"nas-ip,omitempty"`
	Secret  string `protobuf:"bytes,5,opt,name=Secret,proto3" json:"secret,omitempty"`
}

func (m *Radius) Reset()                    { *m = Radius{} }
func (m *Radius) String() string            { return proto.CompactTextString(m) }
func (*Radius) ProtoMessage()               {}
func (*Radius) Descriptor() ([]byte, []int) { return fileDescriptorAuth, []int{9} }

func (m *Radius) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

func (m *Radius) GetIp() string {
	if m != nil {
		return m.Ip
	}
	return ""
}

func (m *Radius) GetPort() string {
	if m != nil {
		return m.Port
	}
	return ""
}

func (m *Radius) GetNasIp() string {
	if m != nil {
		return m.NasIp
	}
	return ""
}

func (m *Radius) GetSecret() string {
	if m != nil {
		return m.Secret
	}
	return ""
}

// status part of authentication policy object
type Role struct {
	api.TypeMeta   `protobuf:"bytes,1,opt,name=T,embedded=T" json:",inline"`
	api.ObjectMeta `protobuf:"bytes,2,opt,name=O,embedded=O" json:"meta,omitempty"`
	Spec           RoleSpec   `protobuf:"bytes,3,opt,name=Spec" json:"spec,omitempty"`
	Status         RoleStatus `protobuf:"bytes,4,opt,name=Status" json:"status,omitempty"`
}

func (m *Role) Reset()                    { *m = Role{} }
func (m *Role) String() string            { return proto.CompactTextString(m) }
func (*Role) ProtoMessage()               {}
func (*Role) Descriptor() ([]byte, []int) { return fileDescriptorAuth, []int{10} }

func (m *Role) GetSpec() RoleSpec {
	if m != nil {
		return m.Spec
	}
	return RoleSpec{}
}

func (m *Role) GetStatus() RoleStatus {
	if m != nil {
		return m.Status
	}
	return RoleStatus{}
}

// AuthenticationPolicy defines various authentication mechanisms available and order in which they are used
type RoleBinding struct {
	api.TypeMeta   `protobuf:"bytes,1,opt,name=T,embedded=T" json:",inline"`
	api.ObjectMeta `protobuf:"bytes,2,opt,name=O,embedded=O" json:"meta,omitempty"`
	// Spec contains configuration of authentication mechanisms.
	Spec RoleBindingSpec `protobuf:"bytes,3,opt,name=Spec" json:"spec,omitempty"`
	// Status contains the current state of the authentication policy.
	Status RoleBindingStatus `protobuf:"bytes,4,opt,name=Status" json:"status,omitempty"`
}

func (m *RoleBinding) Reset()                    { *m = RoleBinding{} }
func (m *RoleBinding) String() string            { return proto.CompactTextString(m) }
func (*RoleBinding) ProtoMessage()               {}
func (*RoleBinding) Descriptor() ([]byte, []int) { return fileDescriptorAuth, []int{11} }

func (m *RoleBinding) GetSpec() RoleBindingSpec {
	if m != nil {
		return m.Spec
	}
	return RoleBindingSpec{}
}

func (m *RoleBinding) GetStatus() RoleBindingStatus {
	if m != nil {
		return m.Status
	}
	return RoleBindingStatus{}
}

// Permission defines if actions are allowed on resource group, resource type, resource name or arbitrary API endpoints.
type RoleBindingSpec struct {
	// ResourceTenant is the tenant to which resource belongs. For tenant scoped roles it will be automatically set to the tenant
	// to which role object belongs. For cluster roles, if specified will give permission for resource belonging to that tenant.
	Users []string `protobuf:"bytes,1,rep,name=Users" json:"users,omitempty"`
	// ResourceGroup is grouping of resource types for which a permission is defined
	UserGroups []string `protobuf:"bytes,2,rep,name=UserGroups" json:"user-groups,omitempty"`
	// ResourceKind is a resource kind for which permission is defined. It can be an API Server object or an arbitrary API endpoint
	Role string `protobuf:"bytes,3,opt,name=Role,proto3" json:"role,omitempty"`
}

func (m *RoleBindingSpec) Reset()                    { *m = RoleBindingSpec{} }
func (m *RoleBindingSpec) String() string            { return proto.CompactTextString(m) }
func (*RoleBindingSpec) ProtoMessage()               {}
func (*RoleBindingSpec) Descriptor() ([]byte, []int) { return fileDescriptorAuth, []int{12} }

func (m *RoleBindingSpec) GetUsers() []string {
	if m != nil {
		return m.Users
	}
	return nil
}

func (m *RoleBindingSpec) GetUserGroups() []string {
	if m != nil {
		return m.UserGroups
	}
	return nil
}

func (m *RoleBindingSpec) GetRole() string {
	if m != nil {
		return m.Role
	}
	return ""
}

// spec part of role object
type RoleBindingStatus struct {
}

func (m *RoleBindingStatus) Reset()                    { *m = RoleBindingStatus{} }
func (m *RoleBindingStatus) String() string            { return proto.CompactTextString(m) }
func (*RoleBindingStatus) ProtoMessage()               {}
func (*RoleBindingStatus) Descriptor() ([]byte, []int) { return fileDescriptorAuth, []int{13} }

// status part of role object
type RoleSpec struct {
	Permissions []Permission `protobuf:"bytes,1,rep,name=Permissions" json:"permissions,omitempty"`
}

func (m *RoleSpec) Reset()                    { *m = RoleSpec{} }
func (m *RoleSpec) String() string            { return proto.CompactTextString(m) }
func (*RoleSpec) ProtoMessage()               {}
func (*RoleSpec) Descriptor() ([]byte, []int) { return fileDescriptorAuth, []int{14} }

func (m *RoleSpec) GetPermissions() []Permission {
	if m != nil {
		return m.Permissions
	}
	return nil
}

// Role is a collection of permissions
type RoleStatus struct {
}

func (m *RoleStatus) Reset()                    { *m = RoleStatus{} }
func (m *RoleStatus) String() string            { return proto.CompactTextString(m) }
func (*RoleStatus) ProtoMessage()               {}
func (*RoleStatus) Descriptor() ([]byte, []int) { return fileDescriptorAuth, []int{15} }

// spec part of role binding object
type TLSOptions struct {
	StartTLS                   bool   `protobuf:"varint,1,opt,name=StartTLS,proto3" json:"start-tls,omitempty"`
	SkipServerCertVerification bool   `protobuf:"varint,2,opt,name=SkipServerCertVerification,proto3" json:"skip-server-cert-verification,omitempty"`
	ServerName                 string `protobuf:"bytes,3,opt,name=ServerName,proto3" json:"server-name,omitempty"`
	TrustedCerts               string `protobuf:"bytes,4,opt,name=TrustedCerts,proto3" json:"trusted-certs,omitempty"`
}

func (m *TLSOptions) Reset()                    { *m = TLSOptions{} }
func (m *TLSOptions) String() string            { return proto.CompactTextString(m) }
func (*TLSOptions) ProtoMessage()               {}
func (*TLSOptions) Descriptor() ([]byte, []int) { return fileDescriptorAuth, []int{16} }

func (m *TLSOptions) GetStartTLS() bool {
	if m != nil {
		return m.StartTLS
	}
	return false
}

func (m *TLSOptions) GetSkipServerCertVerification() bool {
	if m != nil {
		return m.SkipServerCertVerification
	}
	return false
}

func (m *TLSOptions) GetServerName() string {
	if m != nil {
		return m.ServerName
	}
	return ""
}

func (m *TLSOptions) GetTrustedCerts() string {
	if m != nil {
		return m.TrustedCerts
	}
	return ""
}

// status part of role binding object
type User struct {
	api.TypeMeta   `protobuf:"bytes,1,opt,name=T,embedded=T" json:",inline"`
	api.ObjectMeta `protobuf:"bytes,2,opt,name=O,embedded=O" json:"meta,omitempty"`
	Spec           UserSpec   `protobuf:"bytes,3,opt,name=Spec" json:"spec,omitempty"`
	Status         UserStatus `protobuf:"bytes,4,opt,name=Status" json:"status,omitempty"`
}

func (m *User) Reset()                    { *m = User{} }
func (m *User) String() string            { return proto.CompactTextString(m) }
func (*User) ProtoMessage()               {}
func (*User) Descriptor() ([]byte, []int) { return fileDescriptorAuth, []int{17} }

func (m *User) GetSpec() UserSpec {
	if m != nil {
		return m.Spec
	}
	return UserSpec{}
}

func (m *User) GetStatus() UserStatus {
	if m != nil {
		return m.Status
	}
	return UserStatus{}
}

// RoleBinding is an assignment of a role to users or groups
type UserSpec struct {
	Fullname string `protobuf:"bytes,1,opt,name=Fullname,proto3" json:"fullname,omitempty"`
	Email    string `protobuf:"bytes,2,opt,name=Email,proto3" json:"email,omitempty"`
	// Spec contains the configuration of the role binding.
	Password string `protobuf:"bytes,3,opt,name=Password,proto3" json:"password,omitempty"`
	// Status contains the current state of the role binding.
	Type string `protobuf:"bytes,4,opt,name=Type,proto3" json:"type,omitempty"`
}

func (m *UserSpec) Reset()                    { *m = UserSpec{} }
func (m *UserSpec) String() string            { return proto.CompactTextString(m) }
func (*UserSpec) ProtoMessage()               {}
func (*UserSpec) Descriptor() ([]byte, []int) { return fileDescriptorAuth, []int{18} }

func (m *UserSpec) GetFullname() string {
	if m != nil {
		return m.Fullname
	}
	return ""
}

func (m *UserSpec) GetEmail() string {
	if m != nil {
		return m.Email
	}
	return ""
}

func (m *UserSpec) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

func (m *UserSpec) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

// PasswordCredential is user credential to login to Venice. It consists of username, password and tenant.
type UserStatus struct {
	Roles               []string       `protobuf:"bytes,1,rep,name=Roles" json:"roles,omitempty"`
	UserGroups          []string       `protobuf:"bytes,2,rep,name=UserGroups" json:"user-groups,omitempty"`
	LastSuccessfulLogin *api.Timestamp `protobuf:"bytes,3,opt,name=LastSuccessfulLogin" json:"last-successful-login,omitempty"`
}

func (m *UserStatus) Reset()                    { *m = UserStatus{} }
func (m *UserStatus) String() string            { return proto.CompactTextString(m) }
func (*UserStatus) ProtoMessage()               {}
func (*UserStatus) Descriptor() ([]byte, []int) { return fileDescriptorAuth, []int{19} }

func (m *UserStatus) GetRoles() []string {
	if m != nil {
		return m.Roles
	}
	return nil
}

func (m *UserStatus) GetUserGroups() []string {
	if m != nil {
		return m.UserGroups
	}
	return nil
}

func (m *UserStatus) GetLastSuccessfulLogin() *api.Timestamp {
	if m != nil {
		return m.LastSuccessfulLogin
	}
	return nil
}

func init() {
	proto.RegisterType((*AuthenticationPolicy)(nil), "auth.AuthenticationPolicy")
	proto.RegisterType((*AuthenticationPolicySpec)(nil), "auth.AuthenticationPolicySpec")
	proto.RegisterType((*AuthenticationPolicyStatus)(nil), "auth.AuthenticationPolicyStatus")
	proto.RegisterType((*Authenticators)(nil), "auth.Authenticators")
	proto.RegisterType((*Ldap)(nil), "auth.Ldap")
	proto.RegisterType((*LdapAttributeMapping)(nil), "auth.LdapAttributeMapping")
	proto.RegisterType((*Local)(nil), "auth.Local")
	proto.RegisterType((*PasswordCredential)(nil), "auth.PasswordCredential")
	proto.RegisterType((*Permission)(nil), "auth.Permission")
	proto.RegisterType((*Radius)(nil), "auth.Radius")
	proto.RegisterType((*Role)(nil), "auth.Role")
	proto.RegisterType((*RoleBinding)(nil), "auth.RoleBinding")
	proto.RegisterType((*RoleBindingSpec)(nil), "auth.RoleBindingSpec")
	proto.RegisterType((*RoleBindingStatus)(nil), "auth.RoleBindingStatus")
	proto.RegisterType((*RoleSpec)(nil), "auth.RoleSpec")
	proto.RegisterType((*RoleStatus)(nil), "auth.RoleStatus")
	proto.RegisterType((*TLSOptions)(nil), "auth.TLSOptions")
	proto.RegisterType((*User)(nil), "auth.User")
	proto.RegisterType((*UserSpec)(nil), "auth.UserSpec")
	proto.RegisterType((*UserStatus)(nil), "auth.UserStatus")
	proto.RegisterEnum("auth.Authenticators_AuthenticatorType", Authenticators_AuthenticatorType_name, Authenticators_AuthenticatorType_value)
	proto.RegisterEnum("auth.Permission_ResrcKind", Permission_ResrcKind_name, Permission_ResrcKind_value)
	proto.RegisterEnum("auth.Permission_ActionType", Permission_ActionType_name, Permission_ActionType_value)
	proto.RegisterEnum("auth.UserSpec_UserType", UserSpec_UserType_name, UserSpec_UserType_value)
}
func (m *AuthenticationPolicy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuthenticationPolicy) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintAuth(dAtA, i, uint64(m.TypeMeta.Size()))
	n1, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n1
	dAtA[i] = 0x12
	i++
	i = encodeVarintAuth(dAtA, i, uint64(m.ObjectMeta.Size()))
	n2, err := m.ObjectMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n2
	dAtA[i] = 0x1a
	i++
	i = encodeVarintAuth(dAtA, i, uint64(m.Spec.Size()))
	n3, err := m.Spec.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n3
	dAtA[i] = 0x22
	i++
	i = encodeVarintAuth(dAtA, i, uint64(m.Status.Size()))
	n4, err := m.Status.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n4
	return i, nil
}

func (m *AuthenticationPolicySpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuthenticationPolicySpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintAuth(dAtA, i, uint64(m.Authenticators.Size()))
	n5, err := m.Authenticators.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n5
	if len(m.Secret) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAuth(dAtA, i, uint64(len(m.Secret)))
		i += copy(dAtA[i:], m.Secret)
	}
	return i, nil
}

func (m *AuthenticationPolicyStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuthenticationPolicyStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *Authenticators) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Authenticators) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Ldap != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAuth(dAtA, i, uint64(m.Ldap.Size()))
		n6, err := m.Ldap.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.Local != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAuth(dAtA, i, uint64(m.Local.Size()))
		n7, err := m.Local.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.Radius != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAuth(dAtA, i, uint64(m.Radius.Size()))
		n8, err := m.Radius.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if len(m.AuthenticatorOrder) > 0 {
		for _, s := range m.AuthenticatorOrder {
			dAtA[i] = 0x4a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *Ldap) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Ldap) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Enabled {
		dAtA[i] = 0x8
		i++
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Url) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAuth(dAtA, i, uint64(len(m.Url)))
		i += copy(dAtA[i:], m.Url)
	}
	if m.TLSOptions != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAuth(dAtA, i, uint64(m.TLSOptions.Size()))
		n9, err := m.TLSOptions.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if len(m.BaseDN) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAuth(dAtA, i, uint64(len(m.BaseDN)))
		i += copy(dAtA[i:], m.BaseDN)
	}
	if len(m.BindDN) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintAuth(dAtA, i, uint64(len(m.BindDN)))
		i += copy(dAtA[i:], m.BindDN)
	}
	if len(m.BindPassword) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintAuth(dAtA, i, uint64(len(m.BindPassword)))
		i += copy(dAtA[i:], m.BindPassword)
	}
	if m.AttributeMapping != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintAuth(dAtA, i, uint64(m.AttributeMapping.Size()))
		n10, err := m.AttributeMapping.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	return i, nil
}

func (m *LdapAttributeMapping) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LdapAttributeMapping) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.User) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAuth(dAtA, i, uint64(len(m.User)))
		i += copy(dAtA[i:], m.User)
	}
	if len(m.UserObjectClass) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAuth(dAtA, i, uint64(len(m.UserObjectClass)))
		i += copy(dAtA[i:], m.UserObjectClass)
	}
	if len(m.Tenant) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAuth(dAtA, i, uint64(len(m.Tenant)))
		i += copy(dAtA[i:], m.Tenant)
	}
	if len(m.Group) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAuth(dAtA, i, uint64(len(m.Group)))
		i += copy(dAtA[i:], m.Group)
	}
	if len(m.GroupObjectClass) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintAuth(dAtA, i, uint64(len(m.GroupObjectClass)))
		i += copy(dAtA[i:], m.GroupObjectClass)
	}
	if len(m.Email) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintAuth(dAtA, i, uint64(len(m.Email)))
		i += copy(dAtA[i:], m.Email)
	}
	if len(m.Fullname) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintAuth(dAtA, i, uint64(len(m.Fullname)))
		i += copy(dAtA[i:], m.Fullname)
	}
	return i, nil
}

func (m *Local) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Local) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Enabled {
		dAtA[i] = 0x8
		i++
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *PasswordCredential) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PasswordCredential) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Username) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAuth(dAtA, i, uint64(len(m.Username)))
		i += copy(dAtA[i:], m.Username)
	}
	if len(m.Password) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAuth(dAtA, i, uint64(len(m.Password)))
		i += copy(dAtA[i:], m.Password)
	}
	if len(m.Tenant) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAuth(dAtA, i, uint64(len(m.Tenant)))
		i += copy(dAtA[i:], m.Tenant)
	}
	return i, nil
}

func (m *Permission) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Permission) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ResourceTenant) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAuth(dAtA, i, uint64(len(m.ResourceTenant)))
		i += copy(dAtA[i:], m.ResourceTenant)
	}
	if len(m.ResourceGroup) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAuth(dAtA, i, uint64(len(m.ResourceGroup)))
		i += copy(dAtA[i:], m.ResourceGroup)
	}
	if len(m.ResourceKind) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAuth(dAtA, i, uint64(len(m.ResourceKind)))
		i += copy(dAtA[i:], m.ResourceKind)
	}
	if len(m.ResourceNamespace) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAuth(dAtA, i, uint64(len(m.ResourceNamespace)))
		i += copy(dAtA[i:], m.ResourceNamespace)
	}
	if len(m.ResourceNames) > 0 {
		for _, s := range m.ResourceNames {
			dAtA[i] = 0x2a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Actions) > 0 {
		for _, s := range m.Actions {
			dAtA[i] = 0x32
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *Radius) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Radius) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Enabled {
		dAtA[i] = 0x8
		i++
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Ip) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAuth(dAtA, i, uint64(len(m.Ip)))
		i += copy(dAtA[i:], m.Ip)
	}
	if len(m.Port) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAuth(dAtA, i, uint64(len(m.Port)))
		i += copy(dAtA[i:], m.Port)
	}
	if len(m.NasIp) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAuth(dAtA, i, uint64(len(m.NasIp)))
		i += copy(dAtA[i:], m.NasIp)
	}
	if len(m.Secret) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintAuth(dAtA, i, uint64(len(m.Secret)))
		i += copy(dAtA[i:], m.Secret)
	}
	return i, nil
}

func (m *Role) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Role) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintAuth(dAtA, i, uint64(m.TypeMeta.Size()))
	n11, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n11
	dAtA[i] = 0x12
	i++
	i = encodeVarintAuth(dAtA, i, uint64(m.ObjectMeta.Size()))
	n12, err := m.ObjectMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n12
	dAtA[i] = 0x1a
	i++
	i = encodeVarintAuth(dAtA, i, uint64(m.Spec.Size()))
	n13, err := m.Spec.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n13
	dAtA[i] = 0x22
	i++
	i = encodeVarintAuth(dAtA, i, uint64(m.Status.Size()))
	n14, err := m.Status.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n14
	return i, nil
}

func (m *RoleBinding) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoleBinding) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintAuth(dAtA, i, uint64(m.TypeMeta.Size()))
	n15, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n15
	dAtA[i] = 0x12
	i++
	i = encodeVarintAuth(dAtA, i, uint64(m.ObjectMeta.Size()))
	n16, err := m.ObjectMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n16
	dAtA[i] = 0x1a
	i++
	i = encodeVarintAuth(dAtA, i, uint64(m.Spec.Size()))
	n17, err := m.Spec.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n17
	dAtA[i] = 0x22
	i++
	i = encodeVarintAuth(dAtA, i, uint64(m.Status.Size()))
	n18, err := m.Status.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n18
	return i, nil
}

func (m *RoleBindingSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoleBindingSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Users) > 0 {
		for _, s := range m.Users {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.UserGroups) > 0 {
		for _, s := range m.UserGroups {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Role) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAuth(dAtA, i, uint64(len(m.Role)))
		i += copy(dAtA[i:], m.Role)
	}
	return i, nil
}

func (m *RoleBindingStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoleBindingStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *RoleSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoleSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Permissions) > 0 {
		for _, msg := range m.Permissions {
			dAtA[i] = 0xa
			i++
			i = encodeVarintAuth(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *RoleStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoleStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *TLSOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLSOptions) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.StartTLS {
		dAtA[i] = 0x8
		i++
		if m.StartTLS {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.SkipServerCertVerification {
		dAtA[i] = 0x10
		i++
		if m.SkipServerCertVerification {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.ServerName) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAuth(dAtA, i, uint64(len(m.ServerName)))
		i += copy(dAtA[i:], m.ServerName)
	}
	if len(m.TrustedCerts) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAuth(dAtA, i, uint64(len(m.TrustedCerts)))
		i += copy(dAtA[i:], m.TrustedCerts)
	}
	return i, nil
}

func (m *User) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *User) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintAuth(dAtA, i, uint64(m.TypeMeta.Size()))
	n19, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n19
	dAtA[i] = 0x12
	i++
	i = encodeVarintAuth(dAtA, i, uint64(m.ObjectMeta.Size()))
	n20, err := m.ObjectMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n20
	dAtA[i] = 0x1a
	i++
	i = encodeVarintAuth(dAtA, i, uint64(m.Spec.Size()))
	n21, err := m.Spec.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n21
	dAtA[i] = 0x22
	i++
	i = encodeVarintAuth(dAtA, i, uint64(m.Status.Size()))
	n22, err := m.Status.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n22
	return i, nil
}

func (m *UserSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Fullname) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAuth(dAtA, i, uint64(len(m.Fullname)))
		i += copy(dAtA[i:], m.Fullname)
	}
	if len(m.Email) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAuth(dAtA, i, uint64(len(m.Email)))
		i += copy(dAtA[i:], m.Email)
	}
	if len(m.Password) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAuth(dAtA, i, uint64(len(m.Password)))
		i += copy(dAtA[i:], m.Password)
	}
	if len(m.Type) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAuth(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	return i, nil
}

func (m *UserStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Roles) > 0 {
		for _, s := range m.Roles {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.UserGroups) > 0 {
		for _, s := range m.UserGroups {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.LastSuccessfulLogin != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAuth(dAtA, i, uint64(m.LastSuccessfulLogin.Size()))
		n23, err := m.LastSuccessfulLogin.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	return i, nil
}

func encodeVarintAuth(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *AuthenticationPolicy) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovAuth(uint64(l))
	l = m.ObjectMeta.Size()
	n += 1 + l + sovAuth(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovAuth(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovAuth(uint64(l))
	return n
}

func (m *AuthenticationPolicySpec) Size() (n int) {
	var l int
	_ = l
	l = m.Authenticators.Size()
	n += 1 + l + sovAuth(uint64(l))
	l = len(m.Secret)
	if l > 0 {
		n += 1 + l + sovAuth(uint64(l))
	}
	return n
}

func (m *AuthenticationPolicyStatus) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *Authenticators) Size() (n int) {
	var l int
	_ = l
	if m.Ldap != nil {
		l = m.Ldap.Size()
		n += 1 + l + sovAuth(uint64(l))
	}
	if m.Local != nil {
		l = m.Local.Size()
		n += 1 + l + sovAuth(uint64(l))
	}
	if m.Radius != nil {
		l = m.Radius.Size()
		n += 1 + l + sovAuth(uint64(l))
	}
	if len(m.AuthenticatorOrder) > 0 {
		for _, s := range m.AuthenticatorOrder {
			l = len(s)
			n += 1 + l + sovAuth(uint64(l))
		}
	}
	return n
}

func (m *Ldap) Size() (n int) {
	var l int
	_ = l
	if m.Enabled {
		n += 2
	}
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovAuth(uint64(l))
	}
	if m.TLSOptions != nil {
		l = m.TLSOptions.Size()
		n += 1 + l + sovAuth(uint64(l))
	}
	l = len(m.BaseDN)
	if l > 0 {
		n += 1 + l + sovAuth(uint64(l))
	}
	l = len(m.BindDN)
	if l > 0 {
		n += 1 + l + sovAuth(uint64(l))
	}
	l = len(m.BindPassword)
	if l > 0 {
		n += 1 + l + sovAuth(uint64(l))
	}
	if m.AttributeMapping != nil {
		l = m.AttributeMapping.Size()
		n += 1 + l + sovAuth(uint64(l))
	}
	return n
}

func (m *LdapAttributeMapping) Size() (n int) {
	var l int
	_ = l
	l = len(m.User)
	if l > 0 {
		n += 1 + l + sovAuth(uint64(l))
	}
	l = len(m.UserObjectClass)
	if l > 0 {
		n += 1 + l + sovAuth(uint64(l))
	}
	l = len(m.Tenant)
	if l > 0 {
		n += 1 + l + sovAuth(uint64(l))
	}
	l = len(m.Group)
	if l > 0 {
		n += 1 + l + sovAuth(uint64(l))
	}
	l = len(m.GroupObjectClass)
	if l > 0 {
		n += 1 + l + sovAuth(uint64(l))
	}
	l = len(m.Email)
	if l > 0 {
		n += 1 + l + sovAuth(uint64(l))
	}
	l = len(m.Fullname)
	if l > 0 {
		n += 1 + l + sovAuth(uint64(l))
	}
	return n
}

func (m *Local) Size() (n int) {
	var l int
	_ = l
	if m.Enabled {
		n += 2
	}
	return n
}

func (m *PasswordCredential) Size() (n int) {
	var l int
	_ = l
	l = len(m.Username)
	if l > 0 {
		n += 1 + l + sovAuth(uint64(l))
	}
	l = len(m.Password)
	if l > 0 {
		n += 1 + l + sovAuth(uint64(l))
	}
	l = len(m.Tenant)
	if l > 0 {
		n += 1 + l + sovAuth(uint64(l))
	}
	return n
}

func (m *Permission) Size() (n int) {
	var l int
	_ = l
	l = len(m.ResourceTenant)
	if l > 0 {
		n += 1 + l + sovAuth(uint64(l))
	}
	l = len(m.ResourceGroup)
	if l > 0 {
		n += 1 + l + sovAuth(uint64(l))
	}
	l = len(m.ResourceKind)
	if l > 0 {
		n += 1 + l + sovAuth(uint64(l))
	}
	l = len(m.ResourceNamespace)
	if l > 0 {
		n += 1 + l + sovAuth(uint64(l))
	}
	if len(m.ResourceNames) > 0 {
		for _, s := range m.ResourceNames {
			l = len(s)
			n += 1 + l + sovAuth(uint64(l))
		}
	}
	if len(m.Actions) > 0 {
		for _, s := range m.Actions {
			l = len(s)
			n += 1 + l + sovAuth(uint64(l))
		}
	}
	return n
}

func (m *Radius) Size() (n int) {
	var l int
	_ = l
	if m.Enabled {
		n += 2
	}
	l = len(m.Ip)
	if l > 0 {
		n += 1 + l + sovAuth(uint64(l))
	}
	l = len(m.Port)
	if l > 0 {
		n += 1 + l + sovAuth(uint64(l))
	}
	l = len(m.NasIp)
	if l > 0 {
		n += 1 + l + sovAuth(uint64(l))
	}
	l = len(m.Secret)
	if l > 0 {
		n += 1 + l + sovAuth(uint64(l))
	}
	return n
}

func (m *Role) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovAuth(uint64(l))
	l = m.ObjectMeta.Size()
	n += 1 + l + sovAuth(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovAuth(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovAuth(uint64(l))
	return n
}

func (m *RoleBinding) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovAuth(uint64(l))
	l = m.ObjectMeta.Size()
	n += 1 + l + sovAuth(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovAuth(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovAuth(uint64(l))
	return n
}

func (m *RoleBindingSpec) Size() (n int) {
	var l int
	_ = l
	if len(m.Users) > 0 {
		for _, s := range m.Users {
			l = len(s)
			n += 1 + l + sovAuth(uint64(l))
		}
	}
	if len(m.UserGroups) > 0 {
		for _, s := range m.UserGroups {
			l = len(s)
			n += 1 + l + sovAuth(uint64(l))
		}
	}
	l = len(m.Role)
	if l > 0 {
		n += 1 + l + sovAuth(uint64(l))
	}
	return n
}

func (m *RoleBindingStatus) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *RoleSpec) Size() (n int) {
	var l int
	_ = l
	if len(m.Permissions) > 0 {
		for _, e := range m.Permissions {
			l = e.Size()
			n += 1 + l + sovAuth(uint64(l))
		}
	}
	return n
}

func (m *RoleStatus) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *TLSOptions) Size() (n int) {
	var l int
	_ = l
	if m.StartTLS {
		n += 2
	}
	if m.SkipServerCertVerification {
		n += 2
	}
	l = len(m.ServerName)
	if l > 0 {
		n += 1 + l + sovAuth(uint64(l))
	}
	l = len(m.TrustedCerts)
	if l > 0 {
		n += 1 + l + sovAuth(uint64(l))
	}
	return n
}

func (m *User) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovAuth(uint64(l))
	l = m.ObjectMeta.Size()
	n += 1 + l + sovAuth(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovAuth(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovAuth(uint64(l))
	return n
}

func (m *UserSpec) Size() (n int) {
	var l int
	_ = l
	l = len(m.Fullname)
	if l > 0 {
		n += 1 + l + sovAuth(uint64(l))
	}
	l = len(m.Email)
	if l > 0 {
		n += 1 + l + sovAuth(uint64(l))
	}
	l = len(m.Password)
	if l > 0 {
		n += 1 + l + sovAuth(uint64(l))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovAuth(uint64(l))
	}
	return n
}

func (m *UserStatus) Size() (n int) {
	var l int
	_ = l
	if len(m.Roles) > 0 {
		for _, s := range m.Roles {
			l = len(s)
			n += 1 + l + sovAuth(uint64(l))
		}
	}
	if len(m.UserGroups) > 0 {
		for _, s := range m.UserGroups {
			l = len(s)
			n += 1 + l + sovAuth(uint64(l))
		}
	}
	if m.LastSuccessfulLogin != nil {
		l = m.LastSuccessfulLogin.Size()
		n += 1 + l + sovAuth(uint64(l))
	}
	return n
}

func sovAuth(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozAuth(x uint64) (n int) {
	return sovAuth(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *AuthenticationPolicy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuth
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuthenticationPolicy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuthenticationPolicy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuth(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuth
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuthenticationPolicySpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuth
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuthenticationPolicySpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuthenticationPolicySpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authenticators", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Authenticators.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Secret", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Secret = append(m.Secret[:0], dAtA[iNdEx:postIndex]...)
			if m.Secret == nil {
				m.Secret = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuth(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuth
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuthenticationPolicyStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuth
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuthenticationPolicyStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuthenticationPolicyStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAuth(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuth
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Authenticators) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuth
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Authenticators: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Authenticators: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ldap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ldap == nil {
				m.Ldap = &Ldap{}
			}
			if err := m.Ldap.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Local", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Local == nil {
				m.Local = &Local{}
			}
			if err := m.Local.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Radius", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Radius == nil {
				m.Radius = &Radius{}
			}
			if err := m.Radius.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthenticatorOrder", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuthenticatorOrder = append(m.AuthenticatorOrder, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuth(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuth
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Ldap) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuth
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Ldap: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Ldap: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TLSOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TLSOptions == nil {
				m.TLSOptions = &TLSOptions{}
			}
			if err := m.TLSOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseDN", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BaseDN = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BindDN", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BindDN = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BindPassword", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BindPassword = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttributeMapping", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AttributeMapping == nil {
				m.AttributeMapping = &LdapAttributeMapping{}
			}
			if err := m.AttributeMapping.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuth(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuth
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LdapAttributeMapping) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuth
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LdapAttributeMapping: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LdapAttributeMapping: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.User = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserObjectClass", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserObjectClass = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tenant", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tenant = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Group", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Group = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupObjectClass", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupObjectClass = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Email", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Email = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fullname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fullname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuth(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuth
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Local) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuth
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Local: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Local: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipAuth(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuth
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PasswordCredential) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuth
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PasswordCredential: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PasswordCredential: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Password", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Password = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tenant", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tenant = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuth(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuth
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Permission) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuth
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Permission: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Permission: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceTenant", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceTenant = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceGroup", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceGroup = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceKind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceKind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceNamespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceNamespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceNames", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceNames = append(m.ResourceNames, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Actions", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Actions = append(m.Actions, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuth(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuth
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Radius) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuth
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Radius: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Radius: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ip = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Port = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NasIp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NasIp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Secret", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Secret = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuth(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuth
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Role) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuth
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Role: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Role: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuth(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuth
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoleBinding) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuth
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoleBinding: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoleBinding: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuth(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuth
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoleBindingSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuth
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoleBindingSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoleBindingSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Users", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Users = append(m.Users, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserGroups", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserGroups = append(m.UserGroups, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Role", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Role = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuth(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuth
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoleBindingStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuth
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoleBindingStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoleBindingStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAuth(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuth
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoleSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuth
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoleSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoleSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Permissions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Permissions = append(m.Permissions, Permission{})
			if err := m.Permissions[len(m.Permissions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuth(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuth
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoleStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuth
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoleStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoleStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAuth(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuth
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLSOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuth
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TLSOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TLSOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTLS", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.StartTLS = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkipServerCertVerification", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SkipServerCertVerification = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrustedCerts", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TrustedCerts = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuth(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuth
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *User) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuth
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: User: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: User: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuth(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuth
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuth
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fullname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fullname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Email", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Email = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Password", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Password = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuth(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuth
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuth
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Roles", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Roles = append(m.Roles, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserGroups", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserGroups = append(m.UserGroups, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastSuccessfulLogin", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastSuccessfulLogin == nil {
				m.LastSuccessfulLogin = &api.Timestamp{}
			}
			if err := m.LastSuccessfulLogin.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuth(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuth
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipAuth(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowAuth
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthAuth
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowAuth
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipAuth(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthAuth = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowAuth   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("auth.proto", fileDescriptorAuth) }

var fileDescriptorAuth = []byte{
	// 2033 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x58, 0x4f, 0x6f, 0xdb, 0xc8,
	0x15, 0x0f, 0xf5, 0xc7, 0xb6, 0xc6, 0xb2, 0x4d, 0x8f, 0xed, 0x58, 0x72, 0x1d, 0xdb, 0xe0, 0x6e,
	0x9b, 0xa4, 0x8d, 0xac, 0xed, 0xee, 0x62, 0xd1, 0xa6, 0x7f, 0x00, 0xfd, 0xa1, 0xb3, 0x6a, 0x68,
	0x52, 0x25, 0xa9, 0x64, 0x73, 0x68, 0x53, 0x5a, 0x9a, 0x38, 0xac, 0x29, 0x92, 0xe0, 0x50, 0x59,
	0x04, 0x45, 0x2f, 0x05, 0x92, 0x5b, 0xef, 0x3d, 0xf4, 0x5e, 0xc0, 0xed, 0xa9, 0x97, 0x7e, 0x85,
	0xed, 0x6d, 0x91, 0x0f, 0x60, 0x2c, 0x02, 0xf4, 0x62, 0xa0, 0x9f, 0xa1, 0xc5, 0x1b, 0x0e, 0xa9,
	0xa1, 0x6c, 0x07, 0xde, 0x2e, 0xb0, 0x3d, 0x89, 0xf3, 0xe6, 0xfd, 0x7e, 0xf3, 0xe6, 0xbd, 0x37,
	0x6f, 0xde, 0x08, 0x21, 0x67, 0x12, 0x3f, 0xdf, 0x0f, 0xa3, 0x20, 0x0e, 0x70, 0x09, 0xbe, 0xb7,
	0xb6, 0x8f, 0x83, 0xe0, 0xd8, 0x23, 0x4d, 0x27, 0x74, 0x9b, 0x8e, 0xef, 0x07, 0xb1, 0x13, 0xbb,
	0x81, 0x4f, 0x13, 0x9d, 0x2d, 0xf5, 0xd8, 0x8d, 0x9f, 0x4f, 0x8e, 0xf6, 0x87, 0xc1, 0xb8, 0x19,
	0x12, 0x9f, 0x3a, 0xfe, 0x28, 0x68, 0xd2, 0xcf, 0x9b, 0x2f, 0x88, 0xef, 0x0e, 0x49, 0x73, 0x12,
	0xbb, 0x1e, 0x05, 0xe8, 0x31, 0xf1, 0x45, 0x74, 0xd3, 0xf5, 0x87, 0xde, 0x64, 0x44, 0x52, 0x9a,
	0x86, 0x40, 0x73, 0x1c, 0x1c, 0x07, 0x4d, 0x26, 0x3e, 0x9a, 0x3c, 0x63, 0x23, 0x36, 0x60, 0x5f,
	0x5c, 0xfd, 0xbb, 0x57, 0xac, 0x0a, 0x36, 0x8e, 0x49, 0xec, 0x24, 0x6a, 0xca, 0x3f, 0x0a, 0x68,
	0xbd, 0x35, 0x89, 0x9f, 0x13, 0x3f, 0x76, 0x87, 0x6c, 0xe1, 0x7e, 0xe0, 0xb9, 0xc3, 0x97, 0xf8,
	0x03, 0x24, 0xd9, 0x35, 0x69, 0x4f, 0xba, 0xb3, 0xf8, 0xe1, 0xd2, 0xbe, 0x13, 0xba, 0xfb, 0xf6,
	0xcb, 0x90, 0x1c, 0x92, 0xd8, 0x69, 0xaf, 0x7d, 0x71, 0xb6, 0x7b, 0xe3, 0xcb, 0xb3, 0x5d, 0xe9,
	0xfc, 0x6c, 0x77, 0xfe, 0x9e, 0xeb, 0x7b, 0xae, 0x4f, 0x4c, 0xc9, 0xc6, 0x3f, 0x46, 0x92, 0x51,
	0x2b, 0x30, 0xc4, 0x0a, 0x43, 0x18, 0x47, 0xbf, 0x25, 0xc3, 0x98, 0x61, 0xb6, 0x04, 0xcc, 0x32,
	0x2c, 0x7f, 0x2f, 0x18, 0xbb, 0x31, 0x19, 0x87, 0xf1, 0x4b, 0x53, 0x32, 0xf0, 0x2f, 0x50, 0xc9,
	0x0a, 0xc9, 0xb0, 0x56, 0x64, 0xe8, 0x9d, 0x7d, 0xe6, 0xe1, 0xcb, 0xcc, 0x02, 0xad, 0xf6, 0x4d,
	0x20, 0x03, 0x22, 0x1a, 0x92, 0xa1, 0x40, 0xc4, 0x38, 0xb0, 0x89, 0xe6, 0xac, 0xd8, 0x89, 0x27,
	0xb4, 0x56, 0x62, 0x6c, 0x7b, 0xef, 0x60, 0x63, 0x7a, 0xed, 0x1a, 0xe7, 0x93, 0x29, 0x1b, 0x0b,
	0x8c, 0x9c, 0xe9, 0x3e, 0x7e, 0xf3, 0xaa, 0xbe, 0x8c, 0xab, 0x40, 0xe4, 0x37, 0x42, 0x86, 0x55,
	0xfe, 0x26, 0xa1, 0xda, 0x55, 0x26, 0xe2, 0x5f, 0xa3, 0x65, 0x61, 0x2e, 0x88, 0x28, 0x77, 0xe5,
	0xfa, 0x05, 0x63, 0x82, 0x88, 0xb6, 0xf7, 0xb8, 0x01, 0x35, 0x27, 0x27, 0x17, 0x0c, 0x99, 0x61,
	0xc3, 0x1f, 0xa0, 0x39, 0x8b, 0x0c, 0x23, 0x12, 0x33, 0x87, 0x57, 0xd9, 0x16, 0x24, 0xb6, 0x05,
	0x26, 0xcd, 0x6d, 0x81, 0x49, 0x94, 0x6d, 0xb4, 0x75, 0xb5, 0x0b, 0x94, 0xff, 0x14, 0x66, 0x0d,
	0xc6, 0x9f, 0xa0, 0x92, 0x36, 0x72, 0x42, 0x6e, 0x38, 0x4a, 0x0c, 0x07, 0x09, 0xf3, 0x3f, 0x0b,
	0xa4, 0x37, 0x72, 0x42, 0xd1, 0xff, 0x30, 0x8b, 0xef, 0xa3, 0xb2, 0x16, 0x0c, 0x1d, 0x8f, 0xa7,
	0xc2, 0x22, 0x07, 0x82, 0xa8, 0xbd, 0xc9, 0x91, 0x2b, 0x1e, 0x0c, 0x05, 0x68, 0x02, 0xc1, 0x3f,
	0x47, 0x73, 0xa6, 0x33, 0x72, 0x27, 0x94, 0x67, 0x42, 0x35, 0x01, 0x27, 0xb2, 0xe9, 0x26, 0x23,
	0x36, 0x16, 0x37, 0x99, 0x68, 0xe0, 0x3f, 0x48, 0x08, 0xe7, 0xb6, 0x61, 0x44, 0x23, 0x12, 0xd5,
	0x2a, 0x7b, 0xc5, 0x3b, 0x95, 0xb6, 0x79, 0xfa, 0xba, 0x7e, 0xd7, 0x8a, 0x23, 0xd5, 0x9f, 0x8c,
	0xef, 0xe4, 0x37, 0x9b, 0x0f, 0x08, 0x64, 0xfa, 0x5d, 0xbe, 0xd6, 0xad, 0x5c, 0x48, 0x1a, 0x01,
	0xf0, 0x09, 0x0b, 0x5f, 0xb2, 0x9a, 0xf2, 0x31, 0x5a, 0xbd, 0x40, 0x87, 0x2b, 0xa8, 0xac, 0x19,
	0x9d, 0x96, 0x26, 0xdf, 0xc0, 0x0b, 0xa8, 0xa4, 0x75, 0x5b, 0x7d, 0x59, 0xc2, 0x08, 0xcd, 0x99,
	0xad, 0x6e, 0x6f, 0x60, 0xc9, 0x05, 0xe5, 0x9f, 0xc5, 0xc4, 0xdf, 0xb8, 0x89, 0xe6, 0x55, 0xdf,
	0x39, 0xf2, 0xc8, 0x88, 0xb9, 0x7e, 0xa1, 0xbd, 0x71, 0x7e, 0xb6, 0xbb, 0x4a, 0x12, 0x91, 0xb0,
	0x74, 0xaa, 0x85, 0x6f, 0xa3, 0xe2, 0x20, 0x4a, 0xdc, 0x5d, 0x69, 0x6f, 0x70, 0xbb, 0x97, 0x26,
	0x91, 0xe8, 0x5f, 0xd0, 0xc0, 0x06, 0x42, 0xb6, 0x66, 0x19, 0x21, 0x2b, 0x2f, 0xdc, 0xc3, 0x72,
	0xe2, 0xe1, 0xa9, 0xbc, 0x7d, 0x8b, 0x33, 0x6c, 0xc4, 0x1e, 0x6d, 0x04, 0x89, 0x50, 0x60, 0x12,
	0x28, 0xf0, 0x0f, 0xd1, 0x5c, 0xdb, 0xa1, 0xa4, 0xab, 0xb3, 0xa3, 0x56, 0x69, 0xd7, 0x39, 0x74,
	0xf5, 0xc8, 0xa1, 0xa4, 0x31, 0xf2, 0xc5, 0x08, 0x25, 0x8a, 0x0c, 0xe2, 0xfa, 0xa3, 0xae, 0x5e,
	0x2b, 0xcf, 0x40, 0x5c, 0x7f, 0x34, 0x0b, 0x61, 0x8a, 0xb8, 0x83, 0xaa, 0xf0, 0xd5, 0x77, 0x28,
	0xfd, 0x3c, 0x88, 0x46, 0xb5, 0x39, 0x06, 0xdc, 0xe5, 0xc0, 0x4d, 0x06, 0x0c, 0xf9, 0xa4, 0x00,
	0xcf, 0x81, 0xf0, 0x09, 0x92, 0x5b, 0x71, 0x1c, 0xb9, 0x47, 0x93, 0x98, 0x1c, 0x3a, 0x61, 0xe8,
	0xfa, 0xc7, 0xb5, 0x79, 0xe6, 0x81, 0xad, 0x69, 0x66, 0xcf, 0x6a, 0xb4, 0xdf, 0xe3, 0x8b, 0x7c,
	0xc7, 0x49, 0x67, 0x1a, 0xe3, 0x64, 0x4a, 0x58, 0xe8, 0x02, 0xb1, 0xf2, 0xd7, 0x22, 0x5a, 0xbf,
	0x8c, 0x0f, 0x7f, 0x1f, 0x95, 0x06, 0x94, 0x44, 0x2c, 0xb0, 0x95, 0xe9, 0x39, 0x9a, 0xd0, 0x5c,
	0x52, 0x31, 0x1d, 0x7c, 0x88, 0x56, 0xe0, 0x37, 0x29, 0xa2, 0x1d, 0xcf, 0xa1, 0x94, 0x87, 0x38,
	0x33, 0x0a, 0x60, 0x8d, 0x80, 0xcd, 0x37, 0x86, 0xa0, 0x20, 0x70, 0xcc, 0x62, 0xa1, 0x62, 0xd8,
	0xc4, 0x77, 0xfc, 0x98, 0x05, 0xbe, 0x32, 0x3d, 0x4c, 0x31, 0x93, 0x8a, 0x7e, 0x4f, 0xf4, 0x70,
	0x03, 0x95, 0x1f, 0x44, 0xc1, 0x24, 0xe4, 0xc1, 0xcd, 0xce, 0xee, 0x31, 0x08, 0xc5, 0xb3, 0xcb,
	0xb4, 0x70, 0x1f, 0xc9, 0xec, 0x43, 0x34, 0x38, 0x89, 0xf1, 0xfb, 0x1c, 0xb9, 0xcd, 0x90, 0x57,
	0x59, 0x7c, 0x01, 0x0d, 0x06, 0xa8, 0x63, 0xc7, 0xf5, 0x78, 0xc4, 0x33, 0x03, 0x08, 0x08, 0x45,
	0x03, 0x98, 0x16, 0xfe, 0x04, 0x2d, 0x1c, 0x4c, 0x3c, 0xcf, 0x77, 0xc6, 0x84, 0x85, 0xb6, 0xc2,
	0x6e, 0x1d, 0x40, 0xe0, 0x67, 0x5c, 0x2e, 0x80, 0x32, 0x5d, 0xe5, 0x47, 0xbc, 0x60, 0x7d, 0xed,
	0x93, 0xa7, 0x9c, 0x4a, 0x08, 0xa7, 0x19, 0xd6, 0x89, 0xc8, 0x08, 0x8e, 0xbc, 0xe3, 0xe1, 0x0f,
	0xd1, 0x02, 0x78, 0x9f, 0x19, 0xc2, 0x23, 0x0d, 0x46, 0x4c, 0xb8, 0x4c, 0x34, 0x22, 0xd5, 0x03,
	0x4c, 0x96, 0xe0, 0x85, 0x29, 0xe6, 0x92, 0xbc, 0xce, 0xf4, 0xf0, 0xbd, 0x99, 0x90, 0xae, 0xbf,
	0x2b, 0x9c, 0xca, 0x57, 0xf3, 0x08, 0xf5, 0x49, 0x34, 0x76, 0x29, 0x75, 0x03, 0x1f, 0xab, 0x68,
	0xd9, 0x24, 0x34, 0x98, 0x44, 0x43, 0xc2, 0x49, 0x12, 0x53, 0x6f, 0x9d, 0x9f, 0xed, 0xd6, 0x23,
	0x3e, 0xd3, 0xb8, 0xc0, 0x36, 0x03, 0xc2, 0x6d, 0xb4, 0x94, 0x4a, 0x92, 0x64, 0x49, 0x8c, 0xdf,
	0x86, 0xdb, 0x2c, 0x63, 0x99, 0xcd, 0x98, 0x3c, 0x04, 0xff, 0x06, 0x55, 0x53, 0xc1, 0x43, 0xd7,
	0x1f, 0xf1, 0xdd, 0xfc, 0xf4, 0xf4, 0x75, 0xfd, 0x56, 0x5a, 0xae, 0xa7, 0x86, 0xef, 0x9b, 0x84,
	0x46, 0x43, 0xd0, 0xbb, 0x0b, 0xa7, 0x3f, 0x5b, 0xe3, 0xc4, 0xf5, 0x73, 0xa7, 0x5f, 0x64, 0xc4,
	0x3a, 0x5a, 0x4d, 0xc7, 0xba, 0x33, 0x26, 0x34, 0x74, 0x86, 0x84, 0xa7, 0xf5, 0x1e, 0x24, 0x66,
	0xc6, 0xe2, 0xa7, 0xb3, 0x02, 0xd5, 0x45, 0x28, 0x3e, 0x98, 0xee, 0x9a, 0x09, 0x6b, 0x65, 0x76,
	0xc3, 0xec, 0xf1, 0x7c, 0xab, 0xe5, 0xf9, 0x2e, 0xdb, 0x39, 0x83, 0xe1, 0x01, 0x9a, 0x6f, 0x0d,
	0x93, 0x72, 0x3c, 0xc7, 0x18, 0x7e, 0x72, 0xfa, 0xba, 0xbe, 0x73, 0xc9, 0xa6, 0x13, 0x2d, 0xf1,
	0x62, 0x5a, 0x75, 0x86, 0xb3, 0xa5, 0x39, 0xe5, 0x52, 0xfe, 0x5c, 0x44, 0x95, 0xcc, 0x4d, 0xf8,
	0x26, 0xc2, 0x2d, 0x4d, 0x7b, 0x6a, 0xaa, 0x96, 0x31, 0x30, 0x3b, 0xea, 0xd3, 0x87, 0x3d, 0xbd,
	0x6b, 0xc9, 0x37, 0xe0, 0xf6, 0xb1, 0x55, 0xbd, 0xa5, 0xdb, 0xb2, 0x84, 0x17, 0xd1, 0x7c, 0x47,
	0x1b, 0x58, 0xb6, 0x6a, 0xca, 0x05, 0xb8, 0xa0, 0x74, 0xa3, 0xab, 0xca, 0x45, 0x5c, 0x45, 0x0b,
	0xd6, 0x61, 0xcb, 0xb4, 0xf5, 0x5e, 0x47, 0x2e, 0xe1, 0x15, 0xb4, 0xd8, 0x51, 0x4d, 0xbb, 0x77,
	0xd0, 0xeb, 0xb4, 0x6c, 0x55, 0x2e, 0x03, 0x4a, 0x57, 0xed, 0xc7, 0x86, 0xf9, 0x50, 0x9e, 0x83,
	0x81, 0xa5, 0x9a, 0x8f, 0x7a, 0x1d, 0x55, 0x9e, 0x07, 0xa0, 0xd6, 0xee, 0x1b, 0x5a, 0xaf, 0xf3,
	0x44, 0x5e, 0x80, 0x91, 0xaa, 0x77, 0xfb, 0x46, 0x4f, 0xb7, 0xe5, 0x0a, 0x5e, 0x45, 0x4b, 0x96,
	0xda, 0x19, 0x98, 0x3d, 0xfb, 0xc9, 0x03, 0xd3, 0x18, 0xf4, 0x65, 0xc4, 0xd6, 0x79, 0xc0, 0xd5,
	0x17, 0xf1, 0x3c, 0x2a, 0xb6, 0xfa, 0x7d, 0xb9, 0x8a, 0xd7, 0x91, 0xac, 0xea, 0x1d, 0xf3, 0x49,
	0xdf, 0xee, 0x19, 0x3a, 0x9f, 0x5e, 0x82, 0xab, 0xb4, 0xa5, 0xa9, 0xa6, 0x2d, 0x2f, 0x83, 0x45,
	0xec, 0x93, 0xcf, 0xad, 0x00, 0x82, 0x09, 0xba, 0xaa, 0x65, 0xf7, 0xf4, 0x16, 0xe0, 0x64, 0x19,
	0xd4, 0xd4, 0x47, 0xaa, 0x9e, 0xaa, 0xad, 0x82, 0xc0, 0xb2, 0x5b, 0xb6, 0xc5, 0x05, 0x18, 0x04,
	0x07, 0x8f, 0x35, 0x23, 0xb5, 0x61, 0x0d, 0x88, 0x0e, 0x34, 0xe3, 0xb1, 0xfa, 0x59, 0xdf, 0xc8,
	0xe8, 0xd7, 0xc1, 0x33, 0x03, 0x4b, 0x35, 0xe5, 0x0d, 0xbc, 0x8c, 0x50, 0x6b, 0x60, 0x7f, 0xca,
	0x67, 0x6e, 0xc2, 0x8c, 0x69, 0x68, 0xaa, 0xbc, 0x09, 0x54, 0xf0, 0xd5, 0xee, 0xe9, 0xdd, 0x9e,
	0xfe, 0x40, 0xae, 0x31, 0x23, 0xfb, 0xbd, 0xcc, 0x01, 0x75, 0xe5, 0x31, 0x42, 0xd3, 0x78, 0x26,
	0x7b, 0xd0, 0x9e, 0xb6, 0x3a, 0x60, 0x2c, 0x8f, 0x4b, 0xc7, 0x54, 0xc1, 0xc3, 0x12, 0xa3, 0x55,
	0x5b, 0x5d, 0xb9, 0x00, 0xd2, 0x41, 0xbf, 0x0b, 0xd2, 0x22, 0x7c, 0x77, 0x55, 0x4d, 0xb5, 0x55,
	0xb9, 0xc4, 0xb4, 0x8d, 0xc3, 0xc3, 0x9e, 0x2d, 0x97, 0x95, 0x7f, 0x4b, 0x69, 0xff, 0xf4, 0xf5,
	0xbb, 0x88, 0xf7, 0x51, 0xa1, 0x97, 0x9e, 0xde, 0x75, 0x9e, 0x63, 0x55, 0x57, 0x3c, 0xb5, 0x85,
	0x5e, 0x08, 0x17, 0x58, 0x3f, 0x88, 0xd2, 0x82, 0x93, 0x5d, 0x60, 0x61, 0x10, 0x89, 0x45, 0x82,
	0xe9, 0xe0, 0x7d, 0x54, 0xd6, 0x1d, 0xda, 0x4b, 0xef, 0x8f, 0xec, 0xc2, 0xf1, 0x1d, 0xda, 0xc8,
	0x11, 0x27, 0x6a, 0x42, 0x4f, 0x5b, 0xce, 0x03, 0xae, 0xec, 0x69, 0xff, 0x58, 0x40, 0x25, 0x33,
	0xf0, 0xc8, 0xb7, 0xfb, 0x58, 0xb9, 0x9f, 0x7b, 0xac, 0x2c, 0xf3, 0x16, 0x35, 0xf0, 0xc8, 0x35,
	0x1e, 0x27, 0xed, 0x99, 0xc7, 0x89, 0x2c, 0xa0, 0xaf, 0xfb, 0x18, 0xa9, 0xbd, 0x79, 0x55, 0x5f,
	0x47, 0x8b, 0xcd, 0xdf, 0x19, 0xfb, 0x49, 0x11, 0xfe, 0x3d, 0x2e, 0x47, 0x81, 0x47, 0xa8, 0x72,
	0x5a, 0x40, 0x8b, 0x40, 0x05, 0x9d, 0x0f, 0xb4, 0x1b, 0xdf, 0xaa, 0x5b, 0x5a, 0x39, 0xb7, 0x6c,
	0x4c, 0x37, 0xc6, 0xad, 0xb9, 0x86, 0x77, 0x7a, 0x33, 0xde, 0xd9, 0xbc, 0x48, 0x72, 0x5d, 0x27,
	0xed, 0xbd, 0x79, 0x55, 0xdf, 0xce, 0x3b, 0x69, 0x09, 0x9c, 0xd4, 0x38, 0x4a, 0x88, 0xa8, 0xf2,
	0x17, 0x09, 0xad, 0xcc, 0x98, 0x07, 0x1d, 0x07, 0xdc, 0xc8, 0xf0, 0x5a, 0x2b, 0x8a, 0x1d, 0x07,
	0x5c, 0xdd, 0xe2, 0x2a, 0x89, 0x16, 0xfe, 0x19, 0x42, 0xf0, 0xc1, 0x6e, 0x31, 0xe8, 0xce, 0x00,
	0x93, 0xb5, 0xcf, 0xac, 0x3b, 0x63, 0x37, 0x5f, 0xae, 0x7d, 0x9e, 0x02, 0xf0, 0xf7, 0x92, 0xec,
	0xe5, 0x87, 0x09, 0x83, 0x5b, 0xc0, 0x44, 0xd1, 0x2d, 0x30, 0xaf, 0xac, 0xa1, 0xd5, 0x0b, 0x2e,
	0x50, 0x7e, 0x85, 0x16, 0xd2, 0x9c, 0xc3, 0xbf, 0x44, 0x8b, 0xd3, 0xbb, 0x22, 0x31, 0x3e, 0x4b,
	0xad, 0xe9, 0x04, 0x33, 0x0d, 0xbc, 0xb6, 0x11, 0x4e, 0x95, 0x85, 0xc5, 0x44, 0x0e, 0xa5, 0x8a,
	0xd0, 0x34, 0x29, 0x95, 0xbf, 0x17, 0xc4, 0xa7, 0x03, 0xfe, 0x08, 0x2d, 0x58, 0xb1, 0x13, 0xc5,
	0xb6, 0x66, 0xf1, 0xea, 0xb2, 0x79, 0x7e, 0xb6, 0xbb, 0x46, 0x41, 0xd6, 0x88, 0x3d, 0x91, 0x34,
	0x53, 0xc4, 0x27, 0x68, 0xcb, 0x3a, 0x71, 0x43, 0x8b, 0x44, 0x2f, 0x48, 0xd4, 0x21, 0x51, 0xfc,
	0x88, 0x44, 0xee, 0x33, 0xfe, 0x18, 0x65, 0x39, 0xb7, 0xd0, 0xfe, 0xc1, 0xf9, 0xd9, 0xee, 0x6d,
	0x7a, 0xe2, 0x86, 0x0d, 0xca, 0xd4, 0x1a, 0x43, 0x12, 0xc5, 0x8d, 0x17, 0x82, 0xa2, 0x40, 0xfd,
	0x0e, 0x3a, 0x88, 0x4c, 0x32, 0x03, 0xf7, 0x2c, 0x77, 0x70, 0x16, 0x19, 0xce, 0x3d, 0xd3, 0x8b,
	0x09, 0x00, 0x78, 0x72, 0xd8, 0xd1, 0x84, 0xc6, 0x64, 0x04, 0xcc, 0x94, 0x57, 0xb0, 0xec, 0xc9,
	0x11, 0x27, 0x73, 0xcc, 0x3a, 0x71, 0xb3, 0x39, 0x10, 0xab, 0x4e, 0xac, 0x93, 0xff, 0xff, 0x57,
	0x27, 0x30, 0xe3, 0x7f, 0xaf, 0x4e, 0x0c, 0xfd, 0x4d, 0xaa, 0x13, 0x3b, 0x3e, 0xca, 0x9f, 0x0a,
	0x49, 0x5f, 0xcc, 0x96, 0x12, 0x9b, 0x75, 0xe9, 0xfa, 0xcd, 0xfa, 0xf4, 0x4d, 0x50, 0xb8, 0xee,
	0x9b, 0x20, 0x6b, 0xab, 0x8b, 0xf9, 0x65, 0xde, 0xd9, 0x5a, 0x7f, 0x8a, 0x4a, 0x10, 0x24, 0x1e,
	0xf8, 0x8f, 0x4f, 0x5f, 0xd7, 0xb7, 0xd2, 0xae, 0x2c, 0xdd, 0x02, 0x73, 0x8b, 0xd8, 0x91, 0x2d,
	0xc7, 0x2f, 0xc3, 0xdc, 0xe1, 0x85, 0x49, 0xe5, 0xbd, 0x64, 0xd3, 0xb3, 0x7f, 0x02, 0x40, 0x4b,
	0xf4, 0x99, 0xad, 0x9a, 0x7a, 0x4b, 0x93, 0x25, 0xe5, 0x5f, 0x52, 0x52, 0x49, 0x12, 0x1f, 0xc2,
	0x26, 0xe1, 0xf0, 0x5d, 0x28, 0x43, 0xac, 0xca, 0x8b, 0x9b, 0x64, 0x5a, 0xdf, 0xb4, 0x0c, 0xb9,
	0x68, 0x4d, 0x73, 0x68, 0x6c, 0x4d, 0x86, 0x43, 0x42, 0xe9, 0xb3, 0x89, 0xa7, 0x05, 0xc7, 0xae,
	0x3f, 0x4d, 0x20, 0x48, 0x58, 0x77, 0x4c, 0x68, 0xec, 0x8c, 0xc3, 0xf6, 0x6d, 0xce, 0xbb, 0xeb,
	0x39, 0x34, 0x6e, 0xd0, 0x0c, 0xd3, 0xf0, 0x00, 0x24, 0xac, 0x70, 0x19, 0x67, 0xbb, 0xfa, 0xc5,
	0xdb, 0x1d, 0xe9, 0xcb, 0xb7, 0x3b, 0xd2, 0x57, 0x6f, 0x77, 0xa4, 0xbe, 0x74, 0x34, 0xc7, 0xfe,
	0x84, 0xfc, 0xe8, 0xbf, 0x01, 0x00, 0x00, 0xff, 0xff, 0xe0, 0xcd, 0x44, 0xf7, 0x53, 0x15, 0x00,
	0x00,
}
