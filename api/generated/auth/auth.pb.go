// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: auth.proto

/*
	Package auth is a generated protocol buffer package.

	Service name

	It is generated from these files:
		auth.proto
		svc_auth.proto

	It has these top-level messages:
		AuthenticationPolicy
		AuthenticationPolicySpec
		AuthenticationPolicyStatus
		Authenticators
		Ldap
		LdapAttributeMapping
		LdapServer
		LdapServerStatus
		Local
		PasswordCredential
		Permission
		Radius
		RadiusServer
		RadiusServerStatus
		Role
		RoleBinding
		RoleBindingSpec
		RoleBindingStatus
		RoleSpec
		RoleStatus
		TLSOptions
		User
		UserSpec
		UserStatus
		AuthenticationPolicyList
		AutoMsgAuthenticationPolicyWatchHelper
		AutoMsgRoleBindingWatchHelper
		AutoMsgRoleWatchHelper
		AutoMsgUserWatchHelper
		RoleBindingList
		RoleList
		UserList
*/
package auth

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/pensando/grpc-gateway/third_party/googleapis/google/api"
import _ "github.com/pensando/sw/venice/utils/apigen/annotations"
import _ "github.com/gogo/protobuf/gogoproto"
import api "github.com/pensando/sw/api"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

//
type Authenticators_AuthenticatorType int32

const (
	//
	Authenticators_LOCAL Authenticators_AuthenticatorType = 0
	//
	Authenticators_LDAP Authenticators_AuthenticatorType = 1
	//
	Authenticators_RADIUS Authenticators_AuthenticatorType = 2
)

var Authenticators_AuthenticatorType_name = map[int32]string{
	0: "LOCAL",
	1: "LDAP",
	2: "RADIUS",
}
var Authenticators_AuthenticatorType_value = map[string]int32{
	"LOCAL":  0,
	"LDAP":   1,
	"RADIUS": 2,
}

func (x Authenticators_AuthenticatorType) String() string {
	return proto.EnumName(Authenticators_AuthenticatorType_name, int32(x))
}
func (Authenticators_AuthenticatorType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorAuth, []int{3, 0}
}

//
type LdapServerStatus_LdapResult int32

const (
	//
	LdapServerStatus_Connect_Success LdapServerStatus_LdapResult = 0
	//
	LdapServerStatus_Connect_Failure LdapServerStatus_LdapResult = 1
	//
	LdapServerStatus_Bind_Success LdapServerStatus_LdapResult = 2
	//
	LdapServerStatus_Bind_Failure LdapServerStatus_LdapResult = 3
)

var LdapServerStatus_LdapResult_name = map[int32]string{
	0: "Connect_Success",
	1: "Connect_Failure",
	2: "Bind_Success",
	3: "Bind_Failure",
}
var LdapServerStatus_LdapResult_value = map[string]int32{
	"Connect_Success": 0,
	"Connect_Failure": 1,
	"Bind_Success":    2,
	"Bind_Failure":    3,
}

func (x LdapServerStatus_LdapResult) String() string {
	return proto.EnumName(LdapServerStatus_LdapResult_name, int32(x))
}
func (LdapServerStatus_LdapResult) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorAuth, []int{7, 0}
}

// ResourceKind is a resource kind for which permission is defined
type Permission_ResrcKind int32

const (
	// Reserved keyword to imply all resources
	Permission_AllResourceKinds Permission_ResrcKind = 0
	// Arbitrary API endpoint as a resource
	Permission_APIEndpoint Permission_ResrcKind = 1
	// Search
	Permission_Search Permission_ResrcKind = 2
	// Events
	Permission_Event Permission_ResrcKind = 3
	// Cluster wide resources
	Permission_Tenant Permission_ResrcKind = 4
	//
	Permission_Cluster Permission_ResrcKind = 5
	//
	Permission_Node Permission_ResrcKind = 6
	//
	Permission_Host Permission_ResrcKind = 7
	//
	Permission_SmartNIC Permission_ResrcKind = 8
	//
	Permission_Rollout Permission_ResrcKind = 9
	// Network related resources
	Permission_Network Permission_ResrcKind = 10
	//
	Permission_Service Permission_ResrcKind = 11
	//
	Permission_LbPolicy Permission_ResrcKind = 12
	// Workload
	Permission_Workload Permission_ResrcKind = 13
	//
	Permission_Endpoint Permission_ResrcKind = 14
	// Security related resources
	Permission_SecurityGroup Permission_ResrcKind = 15
	//
	Permission_SGPolicy Permission_ResrcKind = 16
	//
	Permission_App Permission_ResrcKind = 17
	//
	Permission_TrafficEncryptionPolicy Permission_ResrcKind = 18
	//
	Permission_Certificate Permission_ResrcKind = 19
	// Monitoring related resources
	Permission_Alert Permission_ResrcKind = 20
	//
	Permission_AlertPolicy Permission_ResrcKind = 21
	//
	Permission_AlertDestination Permission_ResrcKind = 22
	//
	Permission_EventPolicy Permission_ResrcKind = 23
	//
	Permission_StatsPolicy Permission_ResrcKind = 24
	//
	Permission_FwlogPolicy Permission_ResrcKind = 25
	//
	Permission_FlowExportPolicy Permission_ResrcKind = 26
	//
	Permission_MirrorSession Permission_ResrcKind = 27
	//
	Permission_MetricsQuery Permission_ResrcKind = 28
	// User management related resources
	Permission_User Permission_ResrcKind = 29
	//
	Permission_AuthenticationPolicy Permission_ResrcKind = 30
	//
	Permission_Role Permission_ResrcKind = 31
	//
	Permission_RoleBinding Permission_ResrcKind = 32
)

var Permission_ResrcKind_name = map[int32]string{
	0:  "AllResourceKinds",
	1:  "APIEndpoint",
	2:  "Search",
	3:  "Event",
	4:  "Tenant",
	5:  "Cluster",
	6:  "Node",
	7:  "Host",
	8:  "SmartNIC",
	9:  "Rollout",
	10: "Network",
	11: "Service",
	12: "LbPolicy",
	13: "Workload",
	14: "Endpoint",
	15: "SecurityGroup",
	16: "SGPolicy",
	17: "App",
	18: "TrafficEncryptionPolicy",
	19: "Certificate",
	20: "Alert",
	21: "AlertPolicy",
	22: "AlertDestination",
	23: "EventPolicy",
	24: "StatsPolicy",
	25: "FwlogPolicy",
	26: "FlowExportPolicy",
	27: "MirrorSession",
	28: "MetricsQuery",
	29: "User",
	30: "AuthenticationPolicy",
	31: "Role",
	32: "RoleBinding",
}
var Permission_ResrcKind_value = map[string]int32{
	"AllResourceKinds": 0,
	"APIEndpoint":      1,
	"Search":           2,
	"Event":            3,
	"Tenant":           4,
	"Cluster":          5,
	"Node":             6,
	"Host":             7,
	"SmartNIC":         8,
	"Rollout":          9,
	"Network":          10,
	"Service":          11,
	"LbPolicy":         12,
	"Workload":         13,
	"Endpoint":         14,
	"SecurityGroup":    15,
	"SGPolicy":         16,
	"App":              17,
	"TrafficEncryptionPolicy": 18,
	"Certificate":             19,
	"Alert":                   20,
	"AlertPolicy":             21,
	"AlertDestination":        22,
	"EventPolicy":             23,
	"StatsPolicy":             24,
	"FwlogPolicy":             25,
	"FlowExportPolicy":        26,
	"MirrorSession":           27,
	"MetricsQuery":            28,
	"User":                    29,
	"AuthenticationPolicy":    30,
	"Role":                    31,
	"RoleBinding":             32,
}

func (x Permission_ResrcKind) String() string {
	return proto.EnumName(Permission_ResrcKind_name, int32(x))
}
func (Permission_ResrcKind) EnumDescriptor() ([]byte, []int) { return fileDescriptorAuth, []int{10, 0} }

// ActionType is an action on a resource that a permission allows
type Permission_ActionType int32

const (
	// Reserved keyword to imply all action types
	Permission_ALL_ACTIONS Permission_ActionType = 0
	//
	Permission_CREATE Permission_ActionType = 1
	//
	Permission_READ Permission_ActionType = 2
	//
	Permission_UPDATE Permission_ActionType = 3
	//
	Permission_DELETE Permission_ActionType = 4
	// Commit action on staging buffer
	Permission_COMMIT Permission_ActionType = 5
)

var Permission_ActionType_name = map[int32]string{
	0: "ALL_ACTIONS",
	1: "CREATE",
	2: "READ",
	3: "UPDATE",
	4: "DELETE",
	5: "COMMIT",
}
var Permission_ActionType_value = map[string]int32{
	"ALL_ACTIONS": 0,
	"CREATE":      1,
	"READ":        2,
	"UPDATE":      3,
	"DELETE":      4,
	"COMMIT":      5,
}

func (x Permission_ActionType) String() string {
	return proto.EnumName(Permission_ActionType_name, int32(x))
}
func (Permission_ActionType) EnumDescriptor() ([]byte, []int) { return fileDescriptorAuth, []int{10, 1} }

// RadiusAuthMethod describes how the communication between API Gw and RADIUS server is secured. These auth methods are not for end user
// authentication. Currently only PAP is supported.
type Radius_AuthMethod int32

const (
	// PAP is password auth protocol with only password attribute encrypted
	Radius_PAP Radius_AuthMethod = 0
	// PEAP_MSCHAPv2 sends user credentials using TLS tunnel
	Radius_PEAP_MSCHAPv2 Radius_AuthMethod = 1
	// EAP_TTLS sends user credentials using TLS tunnel
	Radius_EAP_TTLS_PAP Radius_AuthMethod = 2
)

var Radius_AuthMethod_name = map[int32]string{
	0: "PAP",
	1: "PEAP_MSCHAPv2",
	2: "EAP_TTLS_PAP",
}
var Radius_AuthMethod_value = map[string]int32{
	"PAP":           0,
	"PEAP_MSCHAPv2": 1,
	"EAP_TTLS_PAP":  2,
}

func (x Radius_AuthMethod) String() string {
	return proto.EnumName(Radius_AuthMethod_name, int32(x))
}
func (Radius_AuthMethod) EnumDescriptor() ([]byte, []int) { return fileDescriptorAuth, []int{11, 0} }

//
type RadiusServerStatus_RadiusResult int32

const (
	//
	RadiusServerStatus_Connect_Success RadiusServerStatus_RadiusResult = 0
	//
	RadiusServerStatus_Connect_Failure RadiusServerStatus_RadiusResult = 1
)

var RadiusServerStatus_RadiusResult_name = map[int32]string{
	0: "Connect_Success",
	1: "Connect_Failure",
}
var RadiusServerStatus_RadiusResult_value = map[string]int32{
	"Connect_Success": 0,
	"Connect_Failure": 1,
}

func (x RadiusServerStatus_RadiusResult) String() string {
	return proto.EnumName(RadiusServerStatus_RadiusResult_name, int32(x))
}
func (RadiusServerStatus_RadiusResult) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorAuth, []int{13, 0}
}

// User could be local or external like in LDAP
type UserSpec_UserType int32

const (
	// ui-hint: Local
	UserSpec_LOCAL UserSpec_UserType = 0
	// ui-hint: External
	UserSpec_EXTERNAL UserSpec_UserType = 1
)

var UserSpec_UserType_name = map[int32]string{
	0: "LOCAL",
	1: "EXTERNAL",
}
var UserSpec_UserType_value = map[string]int32{
	"LOCAL":    0,
	"EXTERNAL": 1,
}

func (x UserSpec_UserType) String() string {
	return proto.EnumName(UserSpec_UserType_name, int32(x))
}
func (UserSpec_UserType) EnumDescriptor() ([]byte, []int) { return fileDescriptorAuth, []int{22, 0} }

// AuthenticationPolicy defines various authentication mechanisms available and order in which they are used
type AuthenticationPolicy struct {
	//
	api.TypeMeta `protobuf:"bytes,1,opt,name=T,json=,inline,embedded=T" json:",inline"`
	//
	api.ObjectMeta `protobuf:"bytes,2,opt,name=O,json=meta,omitempty,embedded=O" json:"meta,omitempty"`
	// Spec contains configuration of authentication mechanisms.
	Spec AuthenticationPolicySpec `protobuf:"bytes,3,opt,name=Spec,json=spec,omitempty" json:"spec,omitempty"`
	// Status contains the current state of the authentication policy.
	Status AuthenticationPolicyStatus `protobuf:"bytes,4,opt,name=Status,json=status,omitempty" json:"status,omitempty"`
}

func (m *AuthenticationPolicy) Reset()                    { *m = AuthenticationPolicy{} }
func (m *AuthenticationPolicy) String() string            { return proto.CompactTextString(m) }
func (*AuthenticationPolicy) ProtoMessage()               {}
func (*AuthenticationPolicy) Descriptor() ([]byte, []int) { return fileDescriptorAuth, []int{0} }

func (m *AuthenticationPolicy) GetSpec() AuthenticationPolicySpec {
	if m != nil {
		return m.Spec
	}
	return AuthenticationPolicySpec{}
}

func (m *AuthenticationPolicy) GetStatus() AuthenticationPolicyStatus {
	if m != nil {
		return m.Status
	}
	return AuthenticationPolicyStatus{}
}

// spec part of authentication policy object
type AuthenticationPolicySpec struct {
	//
	Authenticators Authenticators `protobuf:"bytes,1,opt,name=Authenticators,json=authenticators,omitempty" json:"authenticators,omitempty"`
	// Secret used to sign JWT token
	Secret []byte `protobuf:"bytes,2,opt,name=Secret,json=secret,omitempty,proto3" json:"secret,omitempty"`
}

func (m *AuthenticationPolicySpec) Reset()                    { *m = AuthenticationPolicySpec{} }
func (m *AuthenticationPolicySpec) String() string            { return proto.CompactTextString(m) }
func (*AuthenticationPolicySpec) ProtoMessage()               {}
func (*AuthenticationPolicySpec) Descriptor() ([]byte, []int) { return fileDescriptorAuth, []int{1} }

func (m *AuthenticationPolicySpec) GetAuthenticators() Authenticators {
	if m != nil {
		return m.Authenticators
	}
	return Authenticators{}
}

func (m *AuthenticationPolicySpec) GetSecret() []byte {
	if m != nil {
		return m.Secret
	}
	return nil
}

// status part of authentication policy object
type AuthenticationPolicyStatus struct {
	//
	LdapServers []*LdapServerStatus `protobuf:"bytes,1,rep,name=LdapServers,json=ldap-servers,omitempty" json:"ldap-servers,omitempty"`
	//
	RadiusServers []*RadiusServerStatus `protobuf:"bytes,2,rep,name=RadiusServers,json=radius-servers,omitempty" json:"radius-servers,omitempty"`
}

func (m *AuthenticationPolicyStatus) Reset()                    { *m = AuthenticationPolicyStatus{} }
func (m *AuthenticationPolicyStatus) String() string            { return proto.CompactTextString(m) }
func (*AuthenticationPolicyStatus) ProtoMessage()               {}
func (*AuthenticationPolicyStatus) Descriptor() ([]byte, []int) { return fileDescriptorAuth, []int{2} }

func (m *AuthenticationPolicyStatus) GetLdapServers() []*LdapServerStatus {
	if m != nil {
		return m.LdapServers
	}
	return nil
}

func (m *AuthenticationPolicyStatus) GetRadiusServers() []*RadiusServerStatus {
	if m != nil {
		return m.RadiusServers
	}
	return nil
}

//
type Authenticators struct {
	// Order in which authenticators are applied. If an authenticator returns success, others are skipped
	AuthenticatorOrder []string `protobuf:"bytes,1,rep,name=AuthenticatorOrder,json=authenticator-order,omitempty" json:"authenticator-order,omitempty"`
	//
	Ldap *Ldap `protobuf:"bytes,2,opt,name=Ldap,json=ldap,omitempty" json:"ldap,omitempty"`
	//
	Local *Local `protobuf:"bytes,3,opt,name=Local,json=local,omitempty" json:"local,omitempty"`
	//
	Radius *Radius `protobuf:"bytes,4,opt,name=Radius,json=radius,omitempty" json:"radius,omitempty"`
}

func (m *Authenticators) Reset()                    { *m = Authenticators{} }
func (m *Authenticators) String() string            { return proto.CompactTextString(m) }
func (*Authenticators) ProtoMessage()               {}
func (*Authenticators) Descriptor() ([]byte, []int) { return fileDescriptorAuth, []int{3} }

func (m *Authenticators) GetAuthenticatorOrder() []string {
	if m != nil {
		return m.AuthenticatorOrder
	}
	return nil
}

func (m *Authenticators) GetLdap() *Ldap {
	if m != nil {
		return m.Ldap
	}
	return nil
}

func (m *Authenticators) GetLocal() *Local {
	if m != nil {
		return m.Local
	}
	return nil
}

func (m *Authenticators) GetRadius() *Radius {
	if m != nil {
		return m.Radius
	}
	return nil
}

//
type Ldap struct {
	//
	Enabled bool `protobuf:"varint,1,opt,name=Enabled,json=enabled,omitempty,proto3" json:"enabled,omitempty"`
	//
	BaseDN string `protobuf:"bytes,2,opt,name=BaseDN,json=base-dn,omitempty,proto3" json:"base-dn,omitempty"`
	//
	BindDN string `protobuf:"bytes,3,opt,name=BindDN,json=bind-dn,omitempty,proto3" json:"bind-dn,omitempty"`
	//
	BindPassword string `protobuf:"bytes,4,opt,name=BindPassword,json=bind-password,omitempty,proto3" json:"bind-password,omitempty"`
	//
	AttributeMapping *LdapAttributeMapping `protobuf:"bytes,5,opt,name=AttributeMapping,json=attribute-mapping,omitempty" json:"attribute-mapping,omitempty"`
	// Servers is a list that lets you configure multiple LDAP servers for high availability
	Servers []*LdapServer `protobuf:"bytes,6,rep,name=Servers,json=servers,omitempty" json:"servers,omitempty"`
}

func (m *Ldap) Reset()                    { *m = Ldap{} }
func (m *Ldap) String() string            { return proto.CompactTextString(m) }
func (*Ldap) ProtoMessage()               {}
func (*Ldap) Descriptor() ([]byte, []int) { return fileDescriptorAuth, []int{4} }

func (m *Ldap) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

func (m *Ldap) GetBaseDN() string {
	if m != nil {
		return m.BaseDN
	}
	return ""
}

func (m *Ldap) GetBindDN() string {
	if m != nil {
		return m.BindDN
	}
	return ""
}

func (m *Ldap) GetBindPassword() string {
	if m != nil {
		return m.BindPassword
	}
	return ""
}

func (m *Ldap) GetAttributeMapping() *LdapAttributeMapping {
	if m != nil {
		return m.AttributeMapping
	}
	return nil
}

func (m *Ldap) GetServers() []*LdapServer {
	if m != nil {
		return m.Servers
	}
	return nil
}

//
type LdapAttributeMapping struct {
	//
	User string `protobuf:"bytes,1,opt,name=User,json=user,omitempty,proto3" json:"user,omitempty"`
	// UserObjectClass is the STRUCTURAL object class for user entry in LDAP. It is used as a filter for user search
	UserObjectClass string `protobuf:"bytes,2,opt,name=UserObjectClass,json=user-object-class,omitempty,proto3" json:"user-object-class,omitempty"`
	//
	Tenant string `protobuf:"bytes,3,opt,name=Tenant,json=tenant,omitempty,proto3" json:"tenant,omitempty"`
	//
	Group string `protobuf:"bytes,4,opt,name=Group,json=group,omitempty,proto3" json:"group,omitempty"`
	// GroupObjectClass is the STRUCTURAL object class for group entry in LDAP. It is used as a filter for group search
	GroupObjectClass string `protobuf:"bytes,5,opt,name=GroupObjectClass,json=group-object-class,omitempty,proto3" json:"group-object-class,omitempty"`
	//
	Email string `protobuf:"bytes,6,opt,name=Email,json=email,omitempty,proto3" json:"email,omitempty"`
	//
	Fullname string `protobuf:"bytes,7,opt,name=Fullname,json=fullname,omitempty,proto3" json:"fullname,omitempty"`
}

func (m *LdapAttributeMapping) Reset()                    { *m = LdapAttributeMapping{} }
func (m *LdapAttributeMapping) String() string            { return proto.CompactTextString(m) }
func (*LdapAttributeMapping) ProtoMessage()               {}
func (*LdapAttributeMapping) Descriptor() ([]byte, []int) { return fileDescriptorAuth, []int{5} }

func (m *LdapAttributeMapping) GetUser() string {
	if m != nil {
		return m.User
	}
	return ""
}

func (m *LdapAttributeMapping) GetUserObjectClass() string {
	if m != nil {
		return m.UserObjectClass
	}
	return ""
}

func (m *LdapAttributeMapping) GetTenant() string {
	if m != nil {
		return m.Tenant
	}
	return ""
}

func (m *LdapAttributeMapping) GetGroup() string {
	if m != nil {
		return m.Group
	}
	return ""
}

func (m *LdapAttributeMapping) GetGroupObjectClass() string {
	if m != nil {
		return m.GroupObjectClass
	}
	return ""
}

func (m *LdapAttributeMapping) GetEmail() string {
	if m != nil {
		return m.Email
	}
	return ""
}

func (m *LdapAttributeMapping) GetFullname() string {
	if m != nil {
		return m.Fullname
	}
	return ""
}

//
type LdapServer struct {
	//
	Url string `protobuf:"bytes,1,opt,name=Url,json=url,omitempty,proto3" json:"url,omitempty"`
	//
	TLSOptions *TLSOptions `protobuf:"bytes,2,opt,name=TLSOptions,json=tls-options,omitempty" json:"tls-options,omitempty"`
}

func (m *LdapServer) Reset()                    { *m = LdapServer{} }
func (m *LdapServer) String() string            { return proto.CompactTextString(m) }
func (*LdapServer) ProtoMessage()               {}
func (*LdapServer) Descriptor() ([]byte, []int) { return fileDescriptorAuth, []int{6} }

func (m *LdapServer) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *LdapServer) GetTLSOptions() *TLSOptions {
	if m != nil {
		return m.TLSOptions
	}
	return nil
}

//
type LdapServerStatus struct {
	// Result indicates if ldap check was successful
	Result string `protobuf:"bytes,1,opt,name=Result,json=result,omitempty,proto3" json:"result,omitempty"`
	// Message contains error message in case of failed check or a success message
	Message string `protobuf:"bytes,2,opt,name=Message,json=message,inline,proto3" json:"message,inline"`
	// LdapServer contains the ldap server configuration that was checked
	Server *LdapServer `protobuf:"bytes,3,opt,name=Server,json=server,omitempty" json:"server,omitempty"`
}

func (m *LdapServerStatus) Reset()                    { *m = LdapServerStatus{} }
func (m *LdapServerStatus) String() string            { return proto.CompactTextString(m) }
func (*LdapServerStatus) ProtoMessage()               {}
func (*LdapServerStatus) Descriptor() ([]byte, []int) { return fileDescriptorAuth, []int{7} }

func (m *LdapServerStatus) GetResult() string {
	if m != nil {
		return m.Result
	}
	return ""
}

func (m *LdapServerStatus) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *LdapServerStatus) GetServer() *LdapServer {
	if m != nil {
		return m.Server
	}
	return nil
}

//
type Local struct {
	//
	Enabled bool `protobuf:"varint,1,opt,name=Enabled,json=enabled,omitempty,proto3" json:"enabled,omitempty"`
}

func (m *Local) Reset()                    { *m = Local{} }
func (m *Local) String() string            { return proto.CompactTextString(m) }
func (*Local) ProtoMessage()               {}
func (*Local) Descriptor() ([]byte, []int) { return fileDescriptorAuth, []int{8} }

func (m *Local) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

// PasswordCredential is user credential to login to Venice. It consists of username, password and tenant.
type PasswordCredential struct {
	//
	Username string `protobuf:"bytes,1,opt,name=Username,json=username,omitempty,proto3" json:"username,omitempty"`
	//
	Password string `protobuf:"bytes,2,opt,name=Password,json=password,omitempty,proto3" json:"password,omitempty"`
	//
	Tenant string `protobuf:"bytes,3,opt,name=Tenant,json=tenant,omitempty,proto3" json:"tenant,omitempty"`
}

func (m *PasswordCredential) Reset()                    { *m = PasswordCredential{} }
func (m *PasswordCredential) String() string            { return proto.CompactTextString(m) }
func (*PasswordCredential) ProtoMessage()               {}
func (*PasswordCredential) Descriptor() ([]byte, []int) { return fileDescriptorAuth, []int{9} }

func (m *PasswordCredential) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *PasswordCredential) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

func (m *PasswordCredential) GetTenant() string {
	if m != nil {
		return m.Tenant
	}
	return ""
}

// Permission defines if actions are allowed on resource group, resource type, resource name or arbitrary API endpoints.
type Permission struct {
	// ResourceTenant is the tenant to which resource belongs. For tenant scoped roles it will be automatically set to the tenant
	// to which role object belongs. For cluster roles, if specified will give permission for resource belonging to that tenant.
	ResourceTenant string `protobuf:"bytes,1,opt,name=ResourceTenant,json=resource-tenant,omitempty,proto3" json:"resource-tenant,omitempty"`
	// ResourceGroup is grouping of resource types for which a permission is defined
	ResourceGroup string `protobuf:"bytes,2,opt,name=ResourceGroup,json=resource-group,omitempty,proto3" json:"resource-group,omitempty"`
	// ResourceKind is a resource kind for which permission is defined. It can be an API Server object or an arbitrary API endpoint
	ResourceKind string `protobuf:"bytes,3,opt,name=ResourceKind,json=resource-kind,omitempty,proto3" json:"resource-kind,omitempty"`
	// ResourceNamespace is a namespace to which a resource (API Server object) belongs
	ResourceNamespace string `protobuf:"bytes,4,opt,name=ResourceNamespace,json=resource-namespace,omitempty,proto3" json:"resource-namespace,omitempty"`
	// ResourceNames identify specific objects on which this permission applies.
	ResourceNames []string `protobuf:"bytes,5,rep,name=ResourceNames,json=resource-names,omitempty" json:"resource-names,omitempty"`
	// Actions are actions on a resource that a permission allows
	Actions []string `protobuf:"bytes,6,rep,name=Actions,json=actions,omitempty" json:"actions,omitempty"`
}

func (m *Permission) Reset()                    { *m = Permission{} }
func (m *Permission) String() string            { return proto.CompactTextString(m) }
func (*Permission) ProtoMessage()               {}
func (*Permission) Descriptor() ([]byte, []int) { return fileDescriptorAuth, []int{10} }

func (m *Permission) GetResourceTenant() string {
	if m != nil {
		return m.ResourceTenant
	}
	return ""
}

func (m *Permission) GetResourceGroup() string {
	if m != nil {
		return m.ResourceGroup
	}
	return ""
}

func (m *Permission) GetResourceKind() string {
	if m != nil {
		return m.ResourceKind
	}
	return ""
}

func (m *Permission) GetResourceNamespace() string {
	if m != nil {
		return m.ResourceNamespace
	}
	return ""
}

func (m *Permission) GetResourceNames() []string {
	if m != nil {
		return m.ResourceNames
	}
	return nil
}

func (m *Permission) GetActions() []string {
	if m != nil {
		return m.Actions
	}
	return nil
}

//
type Radius struct {
	//
	Enabled bool `protobuf:"varint,1,opt,name=Enabled,json=enabled,omitempty,proto3" json:"enabled,omitempty"`
	// NasID is a string identifying the NAS(API Gw) originating the Access-Request
	NasID string `protobuf:"bytes,2,opt,name=NasID,json=nas-id,omitempty,proto3" json:"nas-id,omitempty"`
	//
	Servers []*RadiusServer `protobuf:"bytes,3,rep,name=Servers,json=servers,omitempty" json:"servers,omitempty"`
}

func (m *Radius) Reset()                    { *m = Radius{} }
func (m *Radius) String() string            { return proto.CompactTextString(m) }
func (*Radius) ProtoMessage()               {}
func (*Radius) Descriptor() ([]byte, []int) { return fileDescriptorAuth, []int{11} }

func (m *Radius) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

func (m *Radius) GetNasID() string {
	if m != nil {
		return m.NasID
	}
	return ""
}

func (m *Radius) GetServers() []*RadiusServer {
	if m != nil {
		return m.Servers
	}
	return nil
}

//
type RadiusServer struct {
	// <IP address>:<Port> of the RADIUS server
	Url string `protobuf:"bytes,1,opt,name=Url,json=url,omitempty,proto3" json:"url,omitempty"`
	// Secret is the shared secret between API Gw and RADIUS server
	Secret string `protobuf:"bytes,2,opt,name=Secret,json=secret,omitempty,proto3" json:"secret,omitempty"`
	// AuthMethod is authentication method to use with the RADIUS server
	AuthMethod string `protobuf:"bytes,3,opt,name=AuthMethod,json=auth-method,omitempty,proto3" json:"auth-method,omitempty"`
	// TrustedCerts defines the set of PEM encoded root certificate authorities that will be used when verifying server certificates. It is
	// used in PEAP and EAP_TTLS auth methods
	TrustedCerts string `protobuf:"bytes,4,opt,name=TrustedCerts,json=trusted-certs,omitempty,proto3" json:"trusted-certs,omitempty"`
}

func (m *RadiusServer) Reset()                    { *m = RadiusServer{} }
func (m *RadiusServer) String() string            { return proto.CompactTextString(m) }
func (*RadiusServer) ProtoMessage()               {}
func (*RadiusServer) Descriptor() ([]byte, []int) { return fileDescriptorAuth, []int{12} }

func (m *RadiusServer) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *RadiusServer) GetSecret() string {
	if m != nil {
		return m.Secret
	}
	return ""
}

func (m *RadiusServer) GetAuthMethod() string {
	if m != nil {
		return m.AuthMethod
	}
	return ""
}

func (m *RadiusServer) GetTrustedCerts() string {
	if m != nil {
		return m.TrustedCerts
	}
	return ""
}

//
type RadiusServerStatus struct {
	// Result indicates if radius check was successful
	Result string `protobuf:"bytes,1,opt,name=Result,json=result,omitempty,proto3" json:"result,omitempty"`
	// Message contains error message in case of failed check or a success message
	Message string `protobuf:"bytes,2,opt,name=Message,json=message,inline,proto3" json:"message,inline"`
	// RadiusServer contains the radius server configuration that was checked
	Server *RadiusServer `protobuf:"bytes,3,opt,name=Server,json=server,omitempty" json:"server,omitempty"`
}

func (m *RadiusServerStatus) Reset()                    { *m = RadiusServerStatus{} }
func (m *RadiusServerStatus) String() string            { return proto.CompactTextString(m) }
func (*RadiusServerStatus) ProtoMessage()               {}
func (*RadiusServerStatus) Descriptor() ([]byte, []int) { return fileDescriptorAuth, []int{13} }

func (m *RadiusServerStatus) GetResult() string {
	if m != nil {
		return m.Result
	}
	return ""
}

func (m *RadiusServerStatus) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *RadiusServerStatus) GetServer() *RadiusServer {
	if m != nil {
		return m.Server
	}
	return nil
}

// Role is a collection of permissions
type Role struct {
	//
	api.TypeMeta `protobuf:"bytes,1,opt,name=T,json=,inline,embedded=T" json:",inline"`
	//
	api.ObjectMeta `protobuf:"bytes,2,opt,name=O,json=meta,omitempty,embedded=O" json:"meta,omitempty"`
	// Spec contains the configuration of the role.
	Spec RoleSpec `protobuf:"bytes,3,opt,name=Spec,json=spec,omitempty" json:"spec,omitempty"`
	// Status contains the current state of the role.
	Status RoleStatus `protobuf:"bytes,4,opt,name=Status,json=status,omitempty" json:"status,omitempty"`
}

func (m *Role) Reset()                    { *m = Role{} }
func (m *Role) String() string            { return proto.CompactTextString(m) }
func (*Role) ProtoMessage()               {}
func (*Role) Descriptor() ([]byte, []int) { return fileDescriptorAuth, []int{14} }

func (m *Role) GetSpec() RoleSpec {
	if m != nil {
		return m.Spec
	}
	return RoleSpec{}
}

func (m *Role) GetStatus() RoleStatus {
	if m != nil {
		return m.Status
	}
	return RoleStatus{}
}

// RoleBinding is an assignment of a role to users or groups
type RoleBinding struct {
	//
	api.TypeMeta `protobuf:"bytes,1,opt,name=T,json=,inline,embedded=T" json:",inline"`
	//
	api.ObjectMeta `protobuf:"bytes,2,opt,name=O,json=meta,omitempty,embedded=O" json:"meta,omitempty"`
	// Spec contains the configuration of the role binding.
	Spec RoleBindingSpec `protobuf:"bytes,3,opt,name=Spec,json=spec,omitempty" json:"spec,omitempty"`
	// Status contains the current state of the role binding.
	Status RoleBindingStatus `protobuf:"bytes,4,opt,name=Status,json=status,omitempty" json:"status,omitempty"`
}

func (m *RoleBinding) Reset()                    { *m = RoleBinding{} }
func (m *RoleBinding) String() string            { return proto.CompactTextString(m) }
func (*RoleBinding) ProtoMessage()               {}
func (*RoleBinding) Descriptor() ([]byte, []int) { return fileDescriptorAuth, []int{15} }

func (m *RoleBinding) GetSpec() RoleBindingSpec {
	if m != nil {
		return m.Spec
	}
	return RoleBindingSpec{}
}

func (m *RoleBinding) GetStatus() RoleBindingStatus {
	if m != nil {
		return m.Status
	}
	return RoleBindingStatus{}
}

// spec part of role binding object
type RoleBindingSpec struct {
	//
	Users []string `protobuf:"bytes,1,rep,name=Users,json=users,omitempty" json:"users,omitempty"`
	//
	UserGroups []string `protobuf:"bytes,2,rep,name=UserGroups,json=user-groups,omitempty" json:"user-groups,omitempty"`
	//
	Role string `protobuf:"bytes,3,opt,name=Role,json=role,omitempty,proto3" json:"role,omitempty"`
}

func (m *RoleBindingSpec) Reset()                    { *m = RoleBindingSpec{} }
func (m *RoleBindingSpec) String() string            { return proto.CompactTextString(m) }
func (*RoleBindingSpec) ProtoMessage()               {}
func (*RoleBindingSpec) Descriptor() ([]byte, []int) { return fileDescriptorAuth, []int{16} }

func (m *RoleBindingSpec) GetUsers() []string {
	if m != nil {
		return m.Users
	}
	return nil
}

func (m *RoleBindingSpec) GetUserGroups() []string {
	if m != nil {
		return m.UserGroups
	}
	return nil
}

func (m *RoleBindingSpec) GetRole() string {
	if m != nil {
		return m.Role
	}
	return ""
}

// status part of role binding object
type RoleBindingStatus struct {
}

func (m *RoleBindingStatus) Reset()                    { *m = RoleBindingStatus{} }
func (m *RoleBindingStatus) String() string            { return proto.CompactTextString(m) }
func (*RoleBindingStatus) ProtoMessage()               {}
func (*RoleBindingStatus) Descriptor() ([]byte, []int) { return fileDescriptorAuth, []int{17} }

// spec part of role object
type RoleSpec struct {
	// Permissions define actions allowed on resources. A resource can be an API Server object or an arbitrary API endpoint
	Permissions []Permission `protobuf:"bytes,1,rep,name=Permissions,json=permissions,omitempty" json:"permissions,omitempty"`
}

func (m *RoleSpec) Reset()                    { *m = RoleSpec{} }
func (m *RoleSpec) String() string            { return proto.CompactTextString(m) }
func (*RoleSpec) ProtoMessage()               {}
func (*RoleSpec) Descriptor() ([]byte, []int) { return fileDescriptorAuth, []int{18} }

func (m *RoleSpec) GetPermissions() []Permission {
	if m != nil {
		return m.Permissions
	}
	return nil
}

// status part of role object
type RoleStatus struct {
}

func (m *RoleStatus) Reset()                    { *m = RoleStatus{} }
func (m *RoleStatus) String() string            { return proto.CompactTextString(m) }
func (*RoleStatus) ProtoMessage()               {}
func (*RoleStatus) Descriptor() ([]byte, []int) { return fileDescriptorAuth, []int{19} }

//
type TLSOptions struct {
	// StartTLS determines if ldap connection uses TLS
	StartTLS bool `protobuf:"varint,1,opt,name=StartTLS,json=start-tls,omitempty,proto3" json:"start-tls,omitempty"`
	// SkipServerCertVerification controls whether a client verifies the server's certificate chain and host name.
	// If SkipServerCertVerification is true, TLS accepts any certificate presented by the server and any host name in that certificate.
	// In this mode, TLS is susceptible to man-in-the-middle attacks. This should be used only for testing.
	SkipServerCertVerification bool `protobuf:"varint,2,opt,name=SkipServerCertVerification,json=skip-server-cert-verification,omitempty,proto3" json:"skip-server-cert-verification,omitempty"`
	// ServerName is used to verify the hostname on the returned certificates unless SkipServerCertVerification is true.
	ServerName string `protobuf:"bytes,3,opt,name=ServerName,json=server-name,omitempty,proto3" json:"server-name,omitempty"`
	// TrustedCerts defines the set of PEM encoded root certificate authorities that will be used when verifying server certificates.
	TrustedCerts string `protobuf:"bytes,4,opt,name=TrustedCerts,json=trusted-certs,omitempty,proto3" json:"trusted-certs,omitempty"`
}

func (m *TLSOptions) Reset()                    { *m = TLSOptions{} }
func (m *TLSOptions) String() string            { return proto.CompactTextString(m) }
func (*TLSOptions) ProtoMessage()               {}
func (*TLSOptions) Descriptor() ([]byte, []int) { return fileDescriptorAuth, []int{20} }

func (m *TLSOptions) GetStartTLS() bool {
	if m != nil {
		return m.StartTLS
	}
	return false
}

func (m *TLSOptions) GetSkipServerCertVerification() bool {
	if m != nil {
		return m.SkipServerCertVerification
	}
	return false
}

func (m *TLSOptions) GetServerName() string {
	if m != nil {
		return m.ServerName
	}
	return ""
}

func (m *TLSOptions) GetTrustedCerts() string {
	if m != nil {
		return m.TrustedCerts
	}
	return ""
}

// User could be local or external
type User struct {
	//
	api.TypeMeta `protobuf:"bytes,1,opt,name=T,json=,inline,embedded=T" json:",inline"`
	//
	api.ObjectMeta `protobuf:"bytes,2,opt,name=O,json=meta,omitempty,embedded=O" json:"meta,omitempty"`
	// Spec contains the configuration of the user.
	Spec UserSpec `protobuf:"bytes,3,opt,name=Spec,json=spec,omitempty" json:"spec,omitempty"`
	// Status contains the current state of the role binding.
	Status UserStatus `protobuf:"bytes,4,opt,name=Status,json=status,omitempty" json:"status,omitempty"`
}

func (m *User) Reset()                    { *m = User{} }
func (m *User) String() string            { return proto.CompactTextString(m) }
func (*User) ProtoMessage()               {}
func (*User) Descriptor() ([]byte, []int) { return fileDescriptorAuth, []int{21} }

func (m *User) GetSpec() UserSpec {
	if m != nil {
		return m.Spec
	}
	return UserSpec{}
}

func (m *User) GetStatus() UserStatus {
	if m != nil {
		return m.Status
	}
	return UserStatus{}
}

// spec part of user object
type UserSpec struct {
	//
	Fullname string `protobuf:"bytes,1,opt,name=Fullname,json=fullname,omitempty,proto3" json:"fullname,omitempty"`
	//
	Email string `protobuf:"bytes,2,opt,name=Email,json=email,omitempty,proto3" json:"email,omitempty"`
	//
	Password string `protobuf:"bytes,3,opt,name=Password,json=password,omitempty,proto3" json:"password,omitempty"`
	//
	Type string `protobuf:"bytes,4,opt,name=Type,json=type,omitempty,proto3" json:"type,omitempty"`
}

func (m *UserSpec) Reset()                    { *m = UserSpec{} }
func (m *UserSpec) String() string            { return proto.CompactTextString(m) }
func (*UserSpec) ProtoMessage()               {}
func (*UserSpec) Descriptor() ([]byte, []int) { return fileDescriptorAuth, []int{22} }

func (m *UserSpec) GetFullname() string {
	if m != nil {
		return m.Fullname
	}
	return ""
}

func (m *UserSpec) GetEmail() string {
	if m != nil {
		return m.Email
	}
	return ""
}

func (m *UserSpec) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

func (m *UserSpec) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

// status part of user object
type UserStatus struct {
	// Roles assigned to user
	Roles []string `protobuf:"bytes,1,rep,name=Roles,json=roles,omitempty" json:"roles,omitempty"`
	// Groups that external user belongs to
	UserGroups []string `protobuf:"bytes,2,rep,name=UserGroups,json=user-groups,omitempty" json:"user-groups,omitempty"`
	// Last successful login time
	LastSuccessfulLogin *api.Timestamp `protobuf:"bytes,3,opt,name=LastSuccessfulLogin,json=last-successful-login,omitempty" json:"last-successful-login,omitempty"`
	// Authenticators used for last successful login
	Authenticators []string `protobuf:"bytes,4,rep,name=Authenticators,json=authenticators,omitempty" json:"authenticators,omitempty"`
}

func (m *UserStatus) Reset()                    { *m = UserStatus{} }
func (m *UserStatus) String() string            { return proto.CompactTextString(m) }
func (*UserStatus) ProtoMessage()               {}
func (*UserStatus) Descriptor() ([]byte, []int) { return fileDescriptorAuth, []int{23} }

func (m *UserStatus) GetRoles() []string {
	if m != nil {
		return m.Roles
	}
	return nil
}

func (m *UserStatus) GetUserGroups() []string {
	if m != nil {
		return m.UserGroups
	}
	return nil
}

func (m *UserStatus) GetLastSuccessfulLogin() *api.Timestamp {
	if m != nil {
		return m.LastSuccessfulLogin
	}
	return nil
}

func (m *UserStatus) GetAuthenticators() []string {
	if m != nil {
		return m.Authenticators
	}
	return nil
}

func init() {
	proto.RegisterType((*AuthenticationPolicy)(nil), "auth.AuthenticationPolicy")
	proto.RegisterType((*AuthenticationPolicySpec)(nil), "auth.AuthenticationPolicySpec")
	proto.RegisterType((*AuthenticationPolicyStatus)(nil), "auth.AuthenticationPolicyStatus")
	proto.RegisterType((*Authenticators)(nil), "auth.Authenticators")
	proto.RegisterType((*Ldap)(nil), "auth.Ldap")
	proto.RegisterType((*LdapAttributeMapping)(nil), "auth.LdapAttributeMapping")
	proto.RegisterType((*LdapServer)(nil), "auth.LdapServer")
	proto.RegisterType((*LdapServerStatus)(nil), "auth.LdapServerStatus")
	proto.RegisterType((*Local)(nil), "auth.Local")
	proto.RegisterType((*PasswordCredential)(nil), "auth.PasswordCredential")
	proto.RegisterType((*Permission)(nil), "auth.Permission")
	proto.RegisterType((*Radius)(nil), "auth.Radius")
	proto.RegisterType((*RadiusServer)(nil), "auth.RadiusServer")
	proto.RegisterType((*RadiusServerStatus)(nil), "auth.RadiusServerStatus")
	proto.RegisterType((*Role)(nil), "auth.Role")
	proto.RegisterType((*RoleBinding)(nil), "auth.RoleBinding")
	proto.RegisterType((*RoleBindingSpec)(nil), "auth.RoleBindingSpec")
	proto.RegisterType((*RoleBindingStatus)(nil), "auth.RoleBindingStatus")
	proto.RegisterType((*RoleSpec)(nil), "auth.RoleSpec")
	proto.RegisterType((*RoleStatus)(nil), "auth.RoleStatus")
	proto.RegisterType((*TLSOptions)(nil), "auth.TLSOptions")
	proto.RegisterType((*User)(nil), "auth.User")
	proto.RegisterType((*UserSpec)(nil), "auth.UserSpec")
	proto.RegisterType((*UserStatus)(nil), "auth.UserStatus")
	proto.RegisterEnum("auth.Authenticators_AuthenticatorType", Authenticators_AuthenticatorType_name, Authenticators_AuthenticatorType_value)
	proto.RegisterEnum("auth.LdapServerStatus_LdapResult", LdapServerStatus_LdapResult_name, LdapServerStatus_LdapResult_value)
	proto.RegisterEnum("auth.Permission_ResrcKind", Permission_ResrcKind_name, Permission_ResrcKind_value)
	proto.RegisterEnum("auth.Permission_ActionType", Permission_ActionType_name, Permission_ActionType_value)
	proto.RegisterEnum("auth.Radius_AuthMethod", Radius_AuthMethod_name, Radius_AuthMethod_value)
	proto.RegisterEnum("auth.RadiusServerStatus_RadiusResult", RadiusServerStatus_RadiusResult_name, RadiusServerStatus_RadiusResult_value)
	proto.RegisterEnum("auth.UserSpec_UserType", UserSpec_UserType_name, UserSpec_UserType_value)
}
func (m *AuthenticationPolicy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuthenticationPolicy) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintAuth(dAtA, i, uint64(m.TypeMeta.Size()))
	n1, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n1
	dAtA[i] = 0x12
	i++
	i = encodeVarintAuth(dAtA, i, uint64(m.ObjectMeta.Size()))
	n2, err := m.ObjectMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n2
	dAtA[i] = 0x1a
	i++
	i = encodeVarintAuth(dAtA, i, uint64(m.Spec.Size()))
	n3, err := m.Spec.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n3
	dAtA[i] = 0x22
	i++
	i = encodeVarintAuth(dAtA, i, uint64(m.Status.Size()))
	n4, err := m.Status.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n4
	return i, nil
}

func (m *AuthenticationPolicySpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuthenticationPolicySpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintAuth(dAtA, i, uint64(m.Authenticators.Size()))
	n5, err := m.Authenticators.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n5
	if len(m.Secret) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAuth(dAtA, i, uint64(len(m.Secret)))
		i += copy(dAtA[i:], m.Secret)
	}
	return i, nil
}

func (m *AuthenticationPolicyStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuthenticationPolicyStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.LdapServers) > 0 {
		for _, msg := range m.LdapServers {
			dAtA[i] = 0xa
			i++
			i = encodeVarintAuth(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.RadiusServers) > 0 {
		for _, msg := range m.RadiusServers {
			dAtA[i] = 0x12
			i++
			i = encodeVarintAuth(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Authenticators) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Authenticators) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AuthenticatorOrder) > 0 {
		for _, s := range m.AuthenticatorOrder {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.Ldap != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAuth(dAtA, i, uint64(m.Ldap.Size()))
		n6, err := m.Ldap.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.Local != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAuth(dAtA, i, uint64(m.Local.Size()))
		n7, err := m.Local.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.Radius != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAuth(dAtA, i, uint64(m.Radius.Size()))
		n8, err := m.Radius.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	return i, nil
}

func (m *Ldap) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Ldap) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Enabled {
		dAtA[i] = 0x8
		i++
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.BaseDN) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAuth(dAtA, i, uint64(len(m.BaseDN)))
		i += copy(dAtA[i:], m.BaseDN)
	}
	if len(m.BindDN) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAuth(dAtA, i, uint64(len(m.BindDN)))
		i += copy(dAtA[i:], m.BindDN)
	}
	if len(m.BindPassword) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAuth(dAtA, i, uint64(len(m.BindPassword)))
		i += copy(dAtA[i:], m.BindPassword)
	}
	if m.AttributeMapping != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintAuth(dAtA, i, uint64(m.AttributeMapping.Size()))
		n9, err := m.AttributeMapping.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if len(m.Servers) > 0 {
		for _, msg := range m.Servers {
			dAtA[i] = 0x32
			i++
			i = encodeVarintAuth(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *LdapAttributeMapping) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LdapAttributeMapping) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.User) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAuth(dAtA, i, uint64(len(m.User)))
		i += copy(dAtA[i:], m.User)
	}
	if len(m.UserObjectClass) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAuth(dAtA, i, uint64(len(m.UserObjectClass)))
		i += copy(dAtA[i:], m.UserObjectClass)
	}
	if len(m.Tenant) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAuth(dAtA, i, uint64(len(m.Tenant)))
		i += copy(dAtA[i:], m.Tenant)
	}
	if len(m.Group) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAuth(dAtA, i, uint64(len(m.Group)))
		i += copy(dAtA[i:], m.Group)
	}
	if len(m.GroupObjectClass) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintAuth(dAtA, i, uint64(len(m.GroupObjectClass)))
		i += copy(dAtA[i:], m.GroupObjectClass)
	}
	if len(m.Email) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintAuth(dAtA, i, uint64(len(m.Email)))
		i += copy(dAtA[i:], m.Email)
	}
	if len(m.Fullname) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintAuth(dAtA, i, uint64(len(m.Fullname)))
		i += copy(dAtA[i:], m.Fullname)
	}
	return i, nil
}

func (m *LdapServer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LdapServer) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Url) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAuth(dAtA, i, uint64(len(m.Url)))
		i += copy(dAtA[i:], m.Url)
	}
	if m.TLSOptions != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAuth(dAtA, i, uint64(m.TLSOptions.Size()))
		n10, err := m.TLSOptions.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	return i, nil
}

func (m *LdapServerStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LdapServerStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Result) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAuth(dAtA, i, uint64(len(m.Result)))
		i += copy(dAtA[i:], m.Result)
	}
	if len(m.Message) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAuth(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	if m.Server != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAuth(dAtA, i, uint64(m.Server.Size()))
		n11, err := m.Server.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	return i, nil
}

func (m *Local) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Local) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Enabled {
		dAtA[i] = 0x8
		i++
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *PasswordCredential) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PasswordCredential) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Username) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAuth(dAtA, i, uint64(len(m.Username)))
		i += copy(dAtA[i:], m.Username)
	}
	if len(m.Password) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAuth(dAtA, i, uint64(len(m.Password)))
		i += copy(dAtA[i:], m.Password)
	}
	if len(m.Tenant) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAuth(dAtA, i, uint64(len(m.Tenant)))
		i += copy(dAtA[i:], m.Tenant)
	}
	return i, nil
}

func (m *Permission) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Permission) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ResourceTenant) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAuth(dAtA, i, uint64(len(m.ResourceTenant)))
		i += copy(dAtA[i:], m.ResourceTenant)
	}
	if len(m.ResourceGroup) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAuth(dAtA, i, uint64(len(m.ResourceGroup)))
		i += copy(dAtA[i:], m.ResourceGroup)
	}
	if len(m.ResourceKind) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAuth(dAtA, i, uint64(len(m.ResourceKind)))
		i += copy(dAtA[i:], m.ResourceKind)
	}
	if len(m.ResourceNamespace) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAuth(dAtA, i, uint64(len(m.ResourceNamespace)))
		i += copy(dAtA[i:], m.ResourceNamespace)
	}
	if len(m.ResourceNames) > 0 {
		for _, s := range m.ResourceNames {
			dAtA[i] = 0x2a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Actions) > 0 {
		for _, s := range m.Actions {
			dAtA[i] = 0x32
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *Radius) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Radius) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Enabled {
		dAtA[i] = 0x8
		i++
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.NasID) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAuth(dAtA, i, uint64(len(m.NasID)))
		i += copy(dAtA[i:], m.NasID)
	}
	if len(m.Servers) > 0 {
		for _, msg := range m.Servers {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintAuth(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *RadiusServer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RadiusServer) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Url) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAuth(dAtA, i, uint64(len(m.Url)))
		i += copy(dAtA[i:], m.Url)
	}
	if len(m.Secret) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAuth(dAtA, i, uint64(len(m.Secret)))
		i += copy(dAtA[i:], m.Secret)
	}
	if len(m.AuthMethod) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAuth(dAtA, i, uint64(len(m.AuthMethod)))
		i += copy(dAtA[i:], m.AuthMethod)
	}
	if len(m.TrustedCerts) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAuth(dAtA, i, uint64(len(m.TrustedCerts)))
		i += copy(dAtA[i:], m.TrustedCerts)
	}
	return i, nil
}

func (m *RadiusServerStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RadiusServerStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Result) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAuth(dAtA, i, uint64(len(m.Result)))
		i += copy(dAtA[i:], m.Result)
	}
	if len(m.Message) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAuth(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	if m.Server != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAuth(dAtA, i, uint64(m.Server.Size()))
		n12, err := m.Server.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	return i, nil
}

func (m *Role) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Role) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintAuth(dAtA, i, uint64(m.TypeMeta.Size()))
	n13, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n13
	dAtA[i] = 0x12
	i++
	i = encodeVarintAuth(dAtA, i, uint64(m.ObjectMeta.Size()))
	n14, err := m.ObjectMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n14
	dAtA[i] = 0x1a
	i++
	i = encodeVarintAuth(dAtA, i, uint64(m.Spec.Size()))
	n15, err := m.Spec.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n15
	dAtA[i] = 0x22
	i++
	i = encodeVarintAuth(dAtA, i, uint64(m.Status.Size()))
	n16, err := m.Status.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n16
	return i, nil
}

func (m *RoleBinding) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoleBinding) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintAuth(dAtA, i, uint64(m.TypeMeta.Size()))
	n17, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n17
	dAtA[i] = 0x12
	i++
	i = encodeVarintAuth(dAtA, i, uint64(m.ObjectMeta.Size()))
	n18, err := m.ObjectMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n18
	dAtA[i] = 0x1a
	i++
	i = encodeVarintAuth(dAtA, i, uint64(m.Spec.Size()))
	n19, err := m.Spec.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n19
	dAtA[i] = 0x22
	i++
	i = encodeVarintAuth(dAtA, i, uint64(m.Status.Size()))
	n20, err := m.Status.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n20
	return i, nil
}

func (m *RoleBindingSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoleBindingSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Users) > 0 {
		for _, s := range m.Users {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.UserGroups) > 0 {
		for _, s := range m.UserGroups {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Role) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAuth(dAtA, i, uint64(len(m.Role)))
		i += copy(dAtA[i:], m.Role)
	}
	return i, nil
}

func (m *RoleBindingStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoleBindingStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *RoleSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoleSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Permissions) > 0 {
		for _, msg := range m.Permissions {
			dAtA[i] = 0xa
			i++
			i = encodeVarintAuth(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *RoleStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoleStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *TLSOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLSOptions) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.StartTLS {
		dAtA[i] = 0x8
		i++
		if m.StartTLS {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.SkipServerCertVerification {
		dAtA[i] = 0x10
		i++
		if m.SkipServerCertVerification {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.ServerName) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAuth(dAtA, i, uint64(len(m.ServerName)))
		i += copy(dAtA[i:], m.ServerName)
	}
	if len(m.TrustedCerts) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAuth(dAtA, i, uint64(len(m.TrustedCerts)))
		i += copy(dAtA[i:], m.TrustedCerts)
	}
	return i, nil
}

func (m *User) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *User) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintAuth(dAtA, i, uint64(m.TypeMeta.Size()))
	n21, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n21
	dAtA[i] = 0x12
	i++
	i = encodeVarintAuth(dAtA, i, uint64(m.ObjectMeta.Size()))
	n22, err := m.ObjectMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n22
	dAtA[i] = 0x1a
	i++
	i = encodeVarintAuth(dAtA, i, uint64(m.Spec.Size()))
	n23, err := m.Spec.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n23
	dAtA[i] = 0x22
	i++
	i = encodeVarintAuth(dAtA, i, uint64(m.Status.Size()))
	n24, err := m.Status.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n24
	return i, nil
}

func (m *UserSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Fullname) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAuth(dAtA, i, uint64(len(m.Fullname)))
		i += copy(dAtA[i:], m.Fullname)
	}
	if len(m.Email) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAuth(dAtA, i, uint64(len(m.Email)))
		i += copy(dAtA[i:], m.Email)
	}
	if len(m.Password) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAuth(dAtA, i, uint64(len(m.Password)))
		i += copy(dAtA[i:], m.Password)
	}
	if len(m.Type) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAuth(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	return i, nil
}

func (m *UserStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Roles) > 0 {
		for _, s := range m.Roles {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.UserGroups) > 0 {
		for _, s := range m.UserGroups {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.LastSuccessfulLogin != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAuth(dAtA, i, uint64(m.LastSuccessfulLogin.Size()))
		n25, err := m.LastSuccessfulLogin.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	if len(m.Authenticators) > 0 {
		for _, s := range m.Authenticators {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func encodeVarintAuth(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *AuthenticationPolicy) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovAuth(uint64(l))
	l = m.ObjectMeta.Size()
	n += 1 + l + sovAuth(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovAuth(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovAuth(uint64(l))
	return n
}

func (m *AuthenticationPolicySpec) Size() (n int) {
	var l int
	_ = l
	l = m.Authenticators.Size()
	n += 1 + l + sovAuth(uint64(l))
	l = len(m.Secret)
	if l > 0 {
		n += 1 + l + sovAuth(uint64(l))
	}
	return n
}

func (m *AuthenticationPolicyStatus) Size() (n int) {
	var l int
	_ = l
	if len(m.LdapServers) > 0 {
		for _, e := range m.LdapServers {
			l = e.Size()
			n += 1 + l + sovAuth(uint64(l))
		}
	}
	if len(m.RadiusServers) > 0 {
		for _, e := range m.RadiusServers {
			l = e.Size()
			n += 1 + l + sovAuth(uint64(l))
		}
	}
	return n
}

func (m *Authenticators) Size() (n int) {
	var l int
	_ = l
	if len(m.AuthenticatorOrder) > 0 {
		for _, s := range m.AuthenticatorOrder {
			l = len(s)
			n += 1 + l + sovAuth(uint64(l))
		}
	}
	if m.Ldap != nil {
		l = m.Ldap.Size()
		n += 1 + l + sovAuth(uint64(l))
	}
	if m.Local != nil {
		l = m.Local.Size()
		n += 1 + l + sovAuth(uint64(l))
	}
	if m.Radius != nil {
		l = m.Radius.Size()
		n += 1 + l + sovAuth(uint64(l))
	}
	return n
}

func (m *Ldap) Size() (n int) {
	var l int
	_ = l
	if m.Enabled {
		n += 2
	}
	l = len(m.BaseDN)
	if l > 0 {
		n += 1 + l + sovAuth(uint64(l))
	}
	l = len(m.BindDN)
	if l > 0 {
		n += 1 + l + sovAuth(uint64(l))
	}
	l = len(m.BindPassword)
	if l > 0 {
		n += 1 + l + sovAuth(uint64(l))
	}
	if m.AttributeMapping != nil {
		l = m.AttributeMapping.Size()
		n += 1 + l + sovAuth(uint64(l))
	}
	if len(m.Servers) > 0 {
		for _, e := range m.Servers {
			l = e.Size()
			n += 1 + l + sovAuth(uint64(l))
		}
	}
	return n
}

func (m *LdapAttributeMapping) Size() (n int) {
	var l int
	_ = l
	l = len(m.User)
	if l > 0 {
		n += 1 + l + sovAuth(uint64(l))
	}
	l = len(m.UserObjectClass)
	if l > 0 {
		n += 1 + l + sovAuth(uint64(l))
	}
	l = len(m.Tenant)
	if l > 0 {
		n += 1 + l + sovAuth(uint64(l))
	}
	l = len(m.Group)
	if l > 0 {
		n += 1 + l + sovAuth(uint64(l))
	}
	l = len(m.GroupObjectClass)
	if l > 0 {
		n += 1 + l + sovAuth(uint64(l))
	}
	l = len(m.Email)
	if l > 0 {
		n += 1 + l + sovAuth(uint64(l))
	}
	l = len(m.Fullname)
	if l > 0 {
		n += 1 + l + sovAuth(uint64(l))
	}
	return n
}

func (m *LdapServer) Size() (n int) {
	var l int
	_ = l
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovAuth(uint64(l))
	}
	if m.TLSOptions != nil {
		l = m.TLSOptions.Size()
		n += 1 + l + sovAuth(uint64(l))
	}
	return n
}

func (m *LdapServerStatus) Size() (n int) {
	var l int
	_ = l
	l = len(m.Result)
	if l > 0 {
		n += 1 + l + sovAuth(uint64(l))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovAuth(uint64(l))
	}
	if m.Server != nil {
		l = m.Server.Size()
		n += 1 + l + sovAuth(uint64(l))
	}
	return n
}

func (m *Local) Size() (n int) {
	var l int
	_ = l
	if m.Enabled {
		n += 2
	}
	return n
}

func (m *PasswordCredential) Size() (n int) {
	var l int
	_ = l
	l = len(m.Username)
	if l > 0 {
		n += 1 + l + sovAuth(uint64(l))
	}
	l = len(m.Password)
	if l > 0 {
		n += 1 + l + sovAuth(uint64(l))
	}
	l = len(m.Tenant)
	if l > 0 {
		n += 1 + l + sovAuth(uint64(l))
	}
	return n
}

func (m *Permission) Size() (n int) {
	var l int
	_ = l
	l = len(m.ResourceTenant)
	if l > 0 {
		n += 1 + l + sovAuth(uint64(l))
	}
	l = len(m.ResourceGroup)
	if l > 0 {
		n += 1 + l + sovAuth(uint64(l))
	}
	l = len(m.ResourceKind)
	if l > 0 {
		n += 1 + l + sovAuth(uint64(l))
	}
	l = len(m.ResourceNamespace)
	if l > 0 {
		n += 1 + l + sovAuth(uint64(l))
	}
	if len(m.ResourceNames) > 0 {
		for _, s := range m.ResourceNames {
			l = len(s)
			n += 1 + l + sovAuth(uint64(l))
		}
	}
	if len(m.Actions) > 0 {
		for _, s := range m.Actions {
			l = len(s)
			n += 1 + l + sovAuth(uint64(l))
		}
	}
	return n
}

func (m *Radius) Size() (n int) {
	var l int
	_ = l
	if m.Enabled {
		n += 2
	}
	l = len(m.NasID)
	if l > 0 {
		n += 1 + l + sovAuth(uint64(l))
	}
	if len(m.Servers) > 0 {
		for _, e := range m.Servers {
			l = e.Size()
			n += 1 + l + sovAuth(uint64(l))
		}
	}
	return n
}

func (m *RadiusServer) Size() (n int) {
	var l int
	_ = l
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovAuth(uint64(l))
	}
	l = len(m.Secret)
	if l > 0 {
		n += 1 + l + sovAuth(uint64(l))
	}
	l = len(m.AuthMethod)
	if l > 0 {
		n += 1 + l + sovAuth(uint64(l))
	}
	l = len(m.TrustedCerts)
	if l > 0 {
		n += 1 + l + sovAuth(uint64(l))
	}
	return n
}

func (m *RadiusServerStatus) Size() (n int) {
	var l int
	_ = l
	l = len(m.Result)
	if l > 0 {
		n += 1 + l + sovAuth(uint64(l))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovAuth(uint64(l))
	}
	if m.Server != nil {
		l = m.Server.Size()
		n += 1 + l + sovAuth(uint64(l))
	}
	return n
}

func (m *Role) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovAuth(uint64(l))
	l = m.ObjectMeta.Size()
	n += 1 + l + sovAuth(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovAuth(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovAuth(uint64(l))
	return n
}

func (m *RoleBinding) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovAuth(uint64(l))
	l = m.ObjectMeta.Size()
	n += 1 + l + sovAuth(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovAuth(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovAuth(uint64(l))
	return n
}

func (m *RoleBindingSpec) Size() (n int) {
	var l int
	_ = l
	if len(m.Users) > 0 {
		for _, s := range m.Users {
			l = len(s)
			n += 1 + l + sovAuth(uint64(l))
		}
	}
	if len(m.UserGroups) > 0 {
		for _, s := range m.UserGroups {
			l = len(s)
			n += 1 + l + sovAuth(uint64(l))
		}
	}
	l = len(m.Role)
	if l > 0 {
		n += 1 + l + sovAuth(uint64(l))
	}
	return n
}

func (m *RoleBindingStatus) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *RoleSpec) Size() (n int) {
	var l int
	_ = l
	if len(m.Permissions) > 0 {
		for _, e := range m.Permissions {
			l = e.Size()
			n += 1 + l + sovAuth(uint64(l))
		}
	}
	return n
}

func (m *RoleStatus) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *TLSOptions) Size() (n int) {
	var l int
	_ = l
	if m.StartTLS {
		n += 2
	}
	if m.SkipServerCertVerification {
		n += 2
	}
	l = len(m.ServerName)
	if l > 0 {
		n += 1 + l + sovAuth(uint64(l))
	}
	l = len(m.TrustedCerts)
	if l > 0 {
		n += 1 + l + sovAuth(uint64(l))
	}
	return n
}

func (m *User) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovAuth(uint64(l))
	l = m.ObjectMeta.Size()
	n += 1 + l + sovAuth(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovAuth(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovAuth(uint64(l))
	return n
}

func (m *UserSpec) Size() (n int) {
	var l int
	_ = l
	l = len(m.Fullname)
	if l > 0 {
		n += 1 + l + sovAuth(uint64(l))
	}
	l = len(m.Email)
	if l > 0 {
		n += 1 + l + sovAuth(uint64(l))
	}
	l = len(m.Password)
	if l > 0 {
		n += 1 + l + sovAuth(uint64(l))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovAuth(uint64(l))
	}
	return n
}

func (m *UserStatus) Size() (n int) {
	var l int
	_ = l
	if len(m.Roles) > 0 {
		for _, s := range m.Roles {
			l = len(s)
			n += 1 + l + sovAuth(uint64(l))
		}
	}
	if len(m.UserGroups) > 0 {
		for _, s := range m.UserGroups {
			l = len(s)
			n += 1 + l + sovAuth(uint64(l))
		}
	}
	if m.LastSuccessfulLogin != nil {
		l = m.LastSuccessfulLogin.Size()
		n += 1 + l + sovAuth(uint64(l))
	}
	if len(m.Authenticators) > 0 {
		for _, s := range m.Authenticators {
			l = len(s)
			n += 1 + l + sovAuth(uint64(l))
		}
	}
	return n
}

func sovAuth(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozAuth(x uint64) (n int) {
	return sovAuth(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *AuthenticationPolicy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuth
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuthenticationPolicy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuthenticationPolicy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuth(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuth
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuthenticationPolicySpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuth
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuthenticationPolicySpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuthenticationPolicySpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authenticators", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Authenticators.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Secret", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Secret = append(m.Secret[:0], dAtA[iNdEx:postIndex]...)
			if m.Secret == nil {
				m.Secret = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuth(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuth
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuthenticationPolicyStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuth
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuthenticationPolicyStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuthenticationPolicyStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LdapServers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LdapServers = append(m.LdapServers, &LdapServerStatus{})
			if err := m.LdapServers[len(m.LdapServers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RadiusServers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RadiusServers = append(m.RadiusServers, &RadiusServerStatus{})
			if err := m.RadiusServers[len(m.RadiusServers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuth(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuth
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Authenticators) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuth
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Authenticators: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Authenticators: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthenticatorOrder", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuthenticatorOrder = append(m.AuthenticatorOrder, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ldap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ldap == nil {
				m.Ldap = &Ldap{}
			}
			if err := m.Ldap.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Local", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Local == nil {
				m.Local = &Local{}
			}
			if err := m.Local.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Radius", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Radius == nil {
				m.Radius = &Radius{}
			}
			if err := m.Radius.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuth(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuth
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Ldap) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuth
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Ldap: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Ldap: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseDN", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BaseDN = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BindDN", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BindDN = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BindPassword", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BindPassword = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttributeMapping", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AttributeMapping == nil {
				m.AttributeMapping = &LdapAttributeMapping{}
			}
			if err := m.AttributeMapping.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Servers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Servers = append(m.Servers, &LdapServer{})
			if err := m.Servers[len(m.Servers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuth(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuth
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LdapAttributeMapping) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuth
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LdapAttributeMapping: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LdapAttributeMapping: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.User = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserObjectClass", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserObjectClass = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tenant", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tenant = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Group", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Group = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupObjectClass", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupObjectClass = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Email", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Email = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fullname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fullname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuth(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuth
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LdapServer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuth
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LdapServer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LdapServer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TLSOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TLSOptions == nil {
				m.TLSOptions = &TLSOptions{}
			}
			if err := m.TLSOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuth(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuth
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LdapServerStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuth
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LdapServerStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LdapServerStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Result = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Server", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Server == nil {
				m.Server = &LdapServer{}
			}
			if err := m.Server.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuth(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuth
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Local) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuth
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Local: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Local: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipAuth(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuth
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PasswordCredential) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuth
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PasswordCredential: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PasswordCredential: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Password", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Password = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tenant", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tenant = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuth(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuth
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Permission) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuth
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Permission: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Permission: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceTenant", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceTenant = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceGroup", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceGroup = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceKind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceKind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceNamespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceNamespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceNames", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceNames = append(m.ResourceNames, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Actions", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Actions = append(m.Actions, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuth(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuth
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Radius) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuth
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Radius: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Radius: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NasID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NasID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Servers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Servers = append(m.Servers, &RadiusServer{})
			if err := m.Servers[len(m.Servers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuth(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuth
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RadiusServer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuth
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RadiusServer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RadiusServer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Secret", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Secret = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthMethod", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuthMethod = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrustedCerts", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TrustedCerts = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuth(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuth
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RadiusServerStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuth
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RadiusServerStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RadiusServerStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Result = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Server", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Server == nil {
				m.Server = &RadiusServer{}
			}
			if err := m.Server.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuth(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuth
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Role) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuth
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Role: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Role: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuth(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuth
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoleBinding) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuth
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoleBinding: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoleBinding: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuth(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuth
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoleBindingSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuth
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoleBindingSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoleBindingSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Users", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Users = append(m.Users, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserGroups", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserGroups = append(m.UserGroups, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Role", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Role = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuth(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuth
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoleBindingStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuth
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoleBindingStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoleBindingStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAuth(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuth
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoleSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuth
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoleSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoleSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Permissions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Permissions = append(m.Permissions, Permission{})
			if err := m.Permissions[len(m.Permissions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuth(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuth
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoleStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuth
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoleStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoleStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAuth(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuth
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLSOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuth
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TLSOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TLSOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTLS", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.StartTLS = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkipServerCertVerification", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SkipServerCertVerification = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrustedCerts", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TrustedCerts = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuth(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuth
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *User) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuth
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: User: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: User: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuth(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuth
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuth
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fullname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fullname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Email", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Email = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Password", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Password = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuth(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuth
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuth
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Roles", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Roles = append(m.Roles, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserGroups", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserGroups = append(m.UserGroups, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastSuccessfulLogin", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastSuccessfulLogin == nil {
				m.LastSuccessfulLogin = &api.Timestamp{}
			}
			if err := m.LastSuccessfulLogin.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authenticators", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Authenticators = append(m.Authenticators, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuth(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuth
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipAuth(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowAuth
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthAuth
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowAuth
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipAuth(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthAuth = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowAuth   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("auth.proto", fileDescriptorAuth) }

var fileDescriptorAuth = []byte{
	// 2405 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x59, 0xcd, 0x6f, 0x1b, 0xc7,
	0x15, 0x37, 0x49, 0x51, 0x1f, 0xa3, 0xaf, 0xd1, 0x48, 0xb2, 0x48, 0xd9, 0x16, 0x85, 0x4d, 0x8b,
	0xd8, 0x68, 0x28, 0xa5, 0x76, 0x1b, 0xa7, 0x69, 0x50, 0x84, 0x14, 0xe9, 0x58, 0x0d, 0x25, 0xd1,
	0x24, 0xdd, 0xa4, 0x69, 0x51, 0x63, 0xb9, 0x1c, 0x51, 0x5b, 0x2d, 0x77, 0x17, 0x3b, 0xb3, 0x72,
	0x84, 0xa0, 0xa7, 0xc2, 0x06, 0x0a, 0xb4, 0x87, 0x9e, 0x7b, 0x2e, 0x50, 0xf8, 0xd4, 0x43, 0x81,
	0x5e, 0x7a, 0x2e, 0x8c, 0x9e, 0x52, 0x9f, 0xda, 0x0b, 0x51, 0xf8, 0xa8, 0x43, 0xff, 0x86, 0xe2,
	0xcd, 0xce, 0x72, 0x67, 0x97, 0xa4, 0x12, 0x26, 0x46, 0x93, 0xdb, 0xce, 0xef, 0x7d, 0xcc, 0x9b,
	0x37, 0xef, 0xbd, 0x79, 0x33, 0x8b, 0x90, 0xee, 0xf3, 0x93, 0x1d, 0xd7, 0x73, 0xb8, 0x43, 0xa6,
	0xe0, 0x7b, 0xf3, 0x7a, 0xd7, 0x71, 0xba, 0x16, 0xdd, 0xd5, 0x5d, 0x73, 0x57, 0xb7, 0x6d, 0x87,
	0xeb, 0xdc, 0x74, 0x6c, 0x16, 0xf0, 0x6c, 0x56, 0xbb, 0x26, 0x3f, 0xf1, 0xdb, 0x3b, 0x86, 0xd3,
	0xdb, 0x75, 0xa9, 0xcd, 0x74, 0xbb, 0xe3, 0xec, 0xb2, 0xc7, 0xbb, 0x67, 0xd4, 0x36, 0x0d, 0xba,
	0xeb, 0x73, 0xd3, 0x62, 0x20, 0xda, 0xa5, 0xb6, 0x2a, 0xbd, 0x6b, 0xda, 0x86, 0xe5, 0x77, 0x68,
	0xa8, 0xa6, 0xa8, 0xa8, 0xe9, 0x3a, 0x5d, 0x67, 0x57, 0xc0, 0x6d, 0xff, 0x58, 0x8c, 0xc4, 0x40,
	0x7c, 0x49, 0xf6, 0x6f, 0x8f, 0x99, 0x15, 0x6c, 0xec, 0x51, 0xae, 0x07, 0x6c, 0x5a, 0x3f, 0x8d,
	0xd6, 0x4a, 0x3e, 0x3f, 0xa1, 0x36, 0x37, 0x0d, 0x31, 0x71, 0xdd, 0xb1, 0x4c, 0xe3, 0x9c, 0xbc,
	0x85, 0x52, 0xad, 0x5c, 0x6a, 0x3b, 0x75, 0x73, 0xfe, 0xf6, 0xe2, 0x8e, 0xee, 0x9a, 0x3b, 0xad,
	0x73, 0x97, 0x1e, 0x50, 0xae, 0x97, 0x57, 0x9f, 0xf7, 0x0b, 0x57, 0x3e, 0xeb, 0x17, 0x52, 0x17,
	0xfd, 0xc2, 0xcc, 0x1b, 0xa6, 0x6d, 0x99, 0x36, 0x6d, 0x84, 0x1f, 0xe4, 0x1e, 0x4a, 0x1d, 0xe5,
	0xd2, 0x42, 0x6e, 0x59, 0xc8, 0x1d, 0xb5, 0x7f, 0x49, 0x0d, 0x2e, 0x24, 0x37, 0x15, 0xc9, 0x25,
	0x30, 0xe2, 0x0d, 0xa7, 0x67, 0x72, 0xda, 0x73, 0xf9, 0x79, 0x23, 0x31, 0x26, 0x2d, 0x34, 0xd5,
	0x74, 0xa9, 0x91, 0xcb, 0x08, 0x55, 0x5b, 0x3b, 0xc2, 0xe9, 0xa3, 0x2c, 0x05, 0xae, 0xf2, 0x55,
	0xd0, 0x0c, 0x5a, 0x99, 0x4b, 0x0d, 0x55, 0x6b, 0x7c, 0x4c, 0x7e, 0x8e, 0xa6, 0x9b, 0x5c, 0xe7,
	0x3e, 0xcb, 0x4d, 0x09, 0xbd, 0xdb, 0x97, 0xe8, 0x15, 0x7c, 0xe5, 0x9c, 0xd4, 0x8c, 0x99, 0x18,
	0x2b, 0xba, 0x87, 0x90, 0x77, 0xc8, 0x8b, 0x27, 0xf9, 0xa5, 0xcd, 0x05, 0x50, 0x69, 0x17, 0x5d,
	0xa1, 0x45, 0xfb, 0x5b, 0x0a, 0xe5, 0xc6, 0x99, 0x4d, 0x4e, 0xd0, 0x92, 0x42, 0x73, 0x3c, 0x26,
	0x3d, 0xbe, 0x36, 0x64, 0x96, 0xe3, 0xb1, 0xf2, 0xb6, 0x34, 0x25, 0xa7, 0xc7, 0x70, 0xc5, 0xa4,
	0xb1, 0x14, 0xf2, 0x16, 0x9a, 0x6e, 0x52, 0xc3, 0xa3, 0x5c, 0xec, 0xcd, 0x42, 0x79, 0x4d, 0x2c,
	0x49, 0x20, 0xb1, 0x25, 0x25, 0x10, 0xed, 0xbf, 0x29, 0xb4, 0x39, 0xde, 0x3b, 0xc4, 0x40, 0xf3,
	0xb5, 0x8e, 0xee, 0x36, 0xa9, 0x77, 0x46, 0x85, 0xf5, 0x99, 0x9b, 0xf3, 0xb7, 0xaf, 0x06, 0xd6,
	0x47, 0x04, 0xe9, 0xca, 0xad, 0xe7, 0xc1, 0xd6, 0x5f, 0xb5, 0x3a, 0xba, 0x5b, 0x64, 0x81, 0x8c,
	0x32, 0xfb, 0x18, 0x9c, 0x9c, 0xa2, 0xc5, 0x86, 0xde, 0x31, 0x7d, 0x16, 0x4e, 0x93, 0x16, 0xd3,
	0xe4, 0x82, 0x69, 0x54, 0x92, 0x9c, 0x68, 0x5b, 0x4e, 0x94, 0xf3, 0x04, 0x6d, 0xc4, 0x54, 0x63,
	0x29, 0xda, 0x9f, 0x32, 0xc9, 0x3d, 0x21, 0xbf, 0x4b, 0x21, 0x12, 0x83, 0x8e, 0xbc, 0x0e, 0xf5,
	0xc4, 0x62, 0xe7, 0xca, 0x8d, 0x67, 0x4f, 0xf3, 0xb7, 0x9a, 0xdc, 0xab, 0xda, 0x7e, 0xef, 0x66,
	0x5c, 0x30, 0xbe, 0x7f, 0x90, 0x3f, 0xb7, 0xa4, 0x61, 0x37, 0x62, 0xfb, 0x54, 0x74, 0x40, 0x9f,
	0x62, 0xdd, 0xe5, 0x64, 0xf2, 0x1e, 0x9a, 0x02, 0xdf, 0xca, 0x2c, 0x43, 0x91, 0xb7, 0x45, 0x1a,
	0x88, 0xe4, 0x02, 0x4f, 0xaa, 0x69, 0x10, 0x1f, 0x93, 0x0a, 0xca, 0xd6, 0x1c, 0x43, 0xb7, 0x64,
	0x76, 0xcd, 0x4b, 0x15, 0x00, 0x95, 0x37, 0xa4, 0x8e, 0x65, 0x0b, 0x86, 0x8a, 0x92, 0x24, 0x40,
	0xee, 0xa3, 0xe9, 0xc0, 0xf9, 0x32, 0x99, 0x16, 0xd4, 0x0d, 0x11, 0x89, 0x03, 0x7a, 0x70, 0xe0,
	0x6a, 0x35, 0xca, 0x92, 0x88, 0xf6, 0x3d, 0xb4, 0x32, 0xe4, 0x2b, 0x32, 0x87, 0xb2, 0xb5, 0xa3,
	0xbd, 0x52, 0x0d, 0x5f, 0x21, 0xb3, 0x68, 0xaa, 0x56, 0x29, 0xd5, 0x71, 0x8a, 0x20, 0x34, 0xdd,
	0x28, 0x55, 0xf6, 0x1f, 0x36, 0x71, 0x5a, 0xfb, 0x47, 0x26, 0x70, 0x04, 0xf9, 0x01, 0x9a, 0xa9,
	0xda, 0x7a, 0xdb, 0xa2, 0x1d, 0x91, 0x3f, 0xb3, 0xe5, 0xf5, 0x8b, 0x7e, 0x61, 0x85, 0x06, 0x90,
	0x32, 0xf1, 0x30, 0x44, 0xde, 0x46, 0xd3, 0x65, 0x9d, 0xd1, 0xca, 0xa1, 0xf0, 0xe6, 0x5c, 0x20,
	0xd9, 0xd6, 0x19, 0x2d, 0x76, 0x6c, 0x55, 0x72, 0x08, 0x12, 0x92, 0xa6, 0xdd, 0xa9, 0x1c, 0x0a,
	0x27, 0x86, 0x92, 0xa6, 0xdd, 0x49, 0x4a, 0x26, 0x21, 0xf2, 0x63, 0xb4, 0x00, 0x92, 0x75, 0x9d,
	0xb1, 0xc7, 0x8e, 0xd7, 0x11, 0xde, 0x9b, 0x2b, 0x5f, 0xbb, 0xe8, 0x17, 0x36, 0x04, 0xb3, 0x2b,
	0x09, 0x8a, 0x96, 0x71, 0x04, 0x72, 0x86, 0x70, 0x89, 0x73, 0xcf, 0x6c, 0xfb, 0x9c, 0x1e, 0xe8,
	0xae, 0x6b, 0xda, 0xdd, 0x5c, 0x56, 0xec, 0xc6, 0x66, 0x14, 0x17, 0x49, 0x8e, 0xf2, 0x6b, 0x72,
	0x6f, 0xae, 0xe9, 0x21, 0xa5, 0xd8, 0x0b, 0x48, 0xca, 0x9c, 0x97, 0x11, 0xc9, 0x11, 0x9a, 0x09,
	0xb3, 0x71, 0x5a, 0x64, 0x23, 0x4e, 0x26, 0x7d, 0x39, 0x2f, 0x27, 0x59, 0x19, 0x4e, 0xbf, 0x61,
	0x48, 0xfb, 0x77, 0x06, 0xad, 0x8d, 0xb2, 0x95, 0xbc, 0x89, 0xa6, 0x1e, 0x32, 0x91, 0x6e, 0xe0,
	0x25, 0x02, 0xd1, 0xed, 0xb3, 0x58, 0xba, 0x24, 0xc6, 0xe4, 0x21, 0x5a, 0x06, 0x89, 0xe0, 0xe0,
	0xd9, 0xb3, 0x74, 0xc6, 0xe4, 0xe6, 0x16, 0x60, 0xc9, 0xc0, 0x5c, 0x74, 0x04, 0xad, 0x68, 0x00,
	0x51, 0x5d, 0xf2, 0x25, 0x44, 0x28, 0xa1, 0x2d, 0x6a, 0xeb, 0x36, 0x97, 0x1b, 0x2e, 0x4a, 0x28,
	0x17, 0x88, 0x1a, 0xdc, 0x49, 0x84, 0xdc, 0x41, 0xd9, 0xf7, 0x3d, 0xc7, 0x77, 0xe5, 0x3e, 0xaf,
	0x42, 0x6e, 0x75, 0x01, 0x50, 0x73, 0x2b, 0x01, 0x90, 0x8f, 0x10, 0x16, 0x42, 0xea, 0x22, 0xb2,
	0x42, 0x7e, 0xfb, 0xa2, 0x5f, 0xb8, 0x2e, 0xd8, 0xc7, 0xad, 0xe2, 0x52, 0x2a, 0x98, 0x53, 0xed,
	0xe9, 0xa6, 0x95, 0x9b, 0x8e, 0xcc, 0xa1, 0x00, 0xa8, 0xe6, 0x24, 0x00, 0xf2, 0x2e, 0x9a, 0xbd,
	0xe7, 0x5b, 0x96, 0xad, 0xf7, 0x68, 0x6e, 0x46, 0xc8, 0x5d, 0xbd, 0xe8, 0x17, 0xc8, 0xb1, 0xc4,
	0x14, 0xd1, 0x11, 0x98, 0xf6, 0x87, 0x14, 0x42, 0x51, 0x60, 0x90, 0xef, 0xa2, 0xcc, 0x43, 0xcf,
	0x92, 0x1b, 0xba, 0x2e, 0xa3, 0x64, 0xd1, 0xf7, 0x54, 0x0b, 0xe2, 0x43, 0xf2, 0x31, 0x42, 0xad,
	0x5a, 0xf3, 0xc8, 0x15, 0x9d, 0x91, 0x2c, 0x7c, 0x32, 0xe2, 0x22, 0xbc, 0x7c, 0x43, 0xea, 0x5a,
	0xe7, 0x16, 0x2b, 0x3a, 0x01, 0xa8, 0xe8, 0x1c, 0x0d, 0x6b, 0xff, 0x4c, 0x23, 0x9c, 0x3c, 0xab,
	0xc8, 0x2f, 0xd0, 0x74, 0x83, 0x32, 0xdf, 0xe2, 0xd2, 0xcc, 0x77, 0x9f, 0x3d, 0xcd, 0x7f, 0x2b,
	0x2c, 0xf3, 0x49, 0x6e, 0x11, 0xf5, 0x01, 0xfb, 0x2d, 0x51, 0xf1, 0xc4, 0x67, 0xac, 0xe2, 0x25,
	0x10, 0x72, 0x07, 0xcd, 0x1c, 0x50, 0xc6, 0xf4, 0x2e, 0x95, 0xb1, 0x49, 0x82, 0x9e, 0x48, 0x40,
	0x61, 0x53, 0x95, 0x18, 0x93, 0x1a, 0x1c, 0xe2, 0x30, 0xad, 0xac, 0xdb, 0xc3, 0x39, 0x37, 0x28,
	0xba, 0x41, 0x82, 0xc5, 0x8f, 0xf6, 0x38, 0xa2, 0x7d, 0x1c, 0x6c, 0x4a, 0x60, 0x37, 0x59, 0x45,
	0xcb, 0x7b, 0x8e, 0x6d, 0x53, 0x83, 0x3f, 0x6a, 0xfa, 0x86, 0x41, 0x19, 0xc3, 0x57, 0x54, 0xf0,
	0x9e, 0x6e, 0x5a, 0xbe, 0x47, 0x71, 0x8a, 0xe0, 0xa0, 0x7c, 0x0d, 0xd8, 0xd2, 0x03, 0x24, 0xe4,
	0xc9, 0x68, 0x65, 0x79, 0xc0, 0x7c, 0x85, 0xd2, 0xac, 0x3d, 0x4f, 0x21, 0x12, 0xd6, 0xc8, 0x3d,
	0x8f, 0x76, 0xe0, 0x74, 0xd0, 0x2d, 0x08, 0x45, 0xc8, 0x6e, 0x11, 0x8a, 0xa9, 0x28, 0x14, 0x7d,
	0x89, 0xa9, 0xa1, 0x38, 0x8c, 0x81, 0xf4, 0xa0, 0xee, 0xa6, 0x23, 0xe9, 0x11, 0x25, 0x77, 0x04,
	0xf6, 0x65, 0x4b, 0x80, 0xf6, 0xfb, 0x39, 0x84, 0xea, 0xd4, 0xeb, 0x99, 0x8c, 0x99, 0x8e, 0x4d,
	0xea, 0x68, 0xa9, 0x41, 0x99, 0xe3, 0x7b, 0x06, 0x95, 0xea, 0x82, 0x85, 0xdc, 0xb8, 0xe8, 0x17,
	0xf2, 0x9e, 0xa4, 0x14, 0x87, 0xf4, 0x8e, 0x27, 0x91, 0x03, 0xb4, 0x18, 0x6a, 0x0c, 0x6a, 0x4d,
	0xb0, 0xb6, 0xeb, 0xa2, 0x09, 0x0a, 0xa5, 0x92, 0x45, 0x67, 0x2c, 0x85, 0x9c, 0xa2, 0x85, 0x50,
	0xdd, 0x07, 0xa6, 0xdd, 0x91, 0xab, 0x85, 0x1c, 0xb8, 0x11, 0xe6, 0x40, 0xb4, 0x9c, 0x9d, 0x06,
	0x65, 0x9e, 0x01, 0x7c, 0x10, 0xfc, 0x1b, 0x03, 0xa5, 0xa7, 0xa6, 0x1d, 0x3b, 0xc2, 0xc6, 0x10,
	0xc8, 0x4f, 0xd1, 0x4a, 0x38, 0xd9, 0xa1, 0xde, 0xa3, 0xcc, 0xd5, 0x0d, 0x2a, 0x6b, 0xa5, 0xa8,
	0x75, 0x03, 0x39, 0x3b, 0xa4, 0xaa, 0xb5, 0xee, 0x32, 0x2a, 0x79, 0x10, 0xb9, 0x45, 0xa8, 0xce,
	0x65, 0x45, 0xcf, 0x16, 0xf5, 0x87, 0x31, 0xe1, 0x91, 0xae, 0x49, 0x50, 0xc8, 0x23, 0x34, 0x53,
	0x32, 0x82, 0x32, 0x34, 0x2d, 0x94, 0xfd, 0xf0, 0xd9, 0xd3, 0xfc, 0xd6, 0x08, 0xaf, 0x04, 0x5c,
	0x6a, 0xd7, 0xb7, 0xa2, 0x1b, 0xc9, 0x92, 0x34, 0x0c, 0x69, 0xbf, 0x9d, 0x42, 0x73, 0x03, 0x8f,
	0x92, 0x35, 0x84, 0x4b, 0x96, 0xa5, 0x6e, 0x06, 0xe4, 0xe5, 0x32, 0x9a, 0x2f, 0xd5, 0xf7, 0xab,
	0x76, 0xc7, 0x75, 0x4c, 0x9b, 0x07, 0x6d, 0x51, 0x93, 0xea, 0x9e, 0x71, 0x82, 0xd3, 0xd0, 0x37,
	0x55, 0xcf, 0xa8, 0xcd, 0x71, 0x06, 0xe0, 0x20, 0xc0, 0xf0, 0x14, 0x99, 0x47, 0x33, 0x7b, 0x96,
	0xcf, 0x38, 0xf5, 0x70, 0x16, 0x1a, 0xaa, 0x43, 0xa7, 0x43, 0xf1, 0x34, 0x7c, 0xdd, 0x77, 0x18,
	0xc7, 0x33, 0x64, 0x01, 0xcd, 0x36, 0x7b, 0xba, 0xc7, 0x0f, 0xf7, 0xf7, 0xf0, 0x2c, 0xb0, 0x37,
	0x1c, 0xcb, 0x72, 0x7c, 0x8e, 0xe7, 0x60, 0x70, 0x48, 0xf9, 0x63, 0xc7, 0x3b, 0xc5, 0x08, 0x06,
	0x50, 0x6d, 0x4c, 0x83, 0xe2, 0x79, 0x10, 0xaa, 0xb5, 0x83, 0x2b, 0x01, 0x5e, 0x80, 0xd1, 0x87,
	0x8e, 0x77, 0x6a, 0x39, 0x7a, 0x07, 0x2f, 0xc2, 0x68, 0x60, 0xe2, 0x12, 0x59, 0x41, 0x8b, 0x4d,
	0x6a, 0xf8, 0x9e, 0xc9, 0xcf, 0x45, 0x88, 0xe2, 0x65, 0x31, 0xe3, 0xfb, 0x52, 0x18, 0x93, 0x19,
	0x94, 0x29, 0xb9, 0x2e, 0x5e, 0x21, 0xd7, 0xd0, 0x46, 0xcb, 0xd3, 0x8f, 0x8f, 0x4d, 0xa3, 0x6a,
	0x1b, 0xde, 0xb9, 0x1b, 0xdd, 0x3a, 0x30, 0x81, 0xa5, 0xef, 0x51, 0x8f, 0x9b, 0xc7, 0xd0, 0x29,
	0x52, 0xbc, 0x0a, 0xcb, 0x2d, 0x59, 0xd4, 0xe3, 0x78, 0x4d, 0xb8, 0x05, 0x3e, 0x25, 0xf3, 0x7a,
	0xe0, 0x3d, 0xea, 0xf1, 0x0a, 0x65, 0xdc, 0xb4, 0xc5, 0xf5, 0x05, 0x5f, 0x05, 0x36, 0xe1, 0x20,
	0xc9, 0xb6, 0x01, 0x00, 0x14, 0x72, 0x26, 0x81, 0x1c, 0x00, 0xf7, 0x1e, 0x5b, 0x4e, 0x57, 0x02,
	0x79, 0x50, 0x74, 0xcf, 0x72, 0x1e, 0x57, 0x3f, 0x71, 0x9d, 0x81, 0xfa, 0x4d, 0x58, 0xd2, 0x81,
	0xe9, 0x79, 0x8e, 0xd7, 0xa4, 0x62, 0xcf, 0xf1, 0x35, 0x28, 0x85, 0x07, 0x94, 0x7b, 0xa6, 0xc1,
	0x1e, 0xf8, 0xd4, 0x3b, 0xc7, 0xd7, 0xc1, 0xc1, 0x50, 0xaf, 0xf0, 0x0d, 0x92, 0x1b, 0x7d, 0xd5,
	0xc6, 0x5b, 0xc0, 0xd3, 0x70, 0x2c, 0x8a, 0x0b, 0x30, 0x33, 0x7c, 0x41, 0x39, 0x35, 0xed, 0x2e,
	0xde, 0xd6, 0x3e, 0x44, 0x28, 0x8a, 0x24, 0xb1, 0xc2, 0x5a, 0xed, 0x51, 0x69, 0xaf, 0xb5, 0x7f,
	0x74, 0xd8, 0xc4, 0x57, 0x60, 0x87, 0xf7, 0x1a, 0xd5, 0x52, 0xab, 0x8a, 0x53, 0x42, 0x4b, 0xb5,
	0x54, 0xc1, 0x69, 0x40, 0x1f, 0xd6, 0x2b, 0x80, 0x8a, 0x18, 0xa8, 0x54, 0x6b, 0xd5, 0x56, 0x15,
	0x4f, 0x09, 0xee, 0xa3, 0x83, 0x83, 0xfd, 0x16, 0xce, 0x6a, 0xbf, 0x49, 0x87, 0xed, 0xfb, 0x57,
	0xe9, 0x9f, 0xbf, 0x8f, 0xb2, 0x87, 0x3a, 0xdb, 0xaf, 0xc8, 0x82, 0x23, 0x0a, 0xa2, 0xad, 0xb3,
	0xa2, 0xa9, 0xca, 0x0d, 0x21, 0xe4, 0x41, 0xd4, 0x3e, 0x66, 0x44, 0xfb, 0x48, 0x86, 0x2f, 0x73,
	0x13, 0x36, 0x90, 0xef, 0x20, 0x04, 0xde, 0x3d, 0xa0, 0xfc, 0xc4, 0xe9, 0x40, 0x30, 0xd5, 0x4b,
	0x75, 0x7c, 0x05, 0xf6, 0xa8, 0x5e, 0x2d, 0xd5, 0x1f, 0x1d, 0x34, 0xf7, 0xee, 0x97, 0xea, 0x67,
	0xb7, 0x83, 0x03, 0x0c, 0x90, 0x56, 0xab, 0xd6, 0x7c, 0x04, 0x4c, 0x69, 0xed, 0x8f, 0x69, 0xb4,
	0xa0, 0x4e, 0x4d, 0x8a, 0x6a, 0x8b, 0xb2, 0xf2, 0xb9, 0xed, 0x49, 0xfc, 0x76, 0x3d, 0xf7, 0x45,
	0x6f, 0xd7, 0xa4, 0xad, 0xda, 0x2c, 0xab, 0xec, 0xdd, 0x67, 0x4f, 0xf3, 0x9b, 0x61, 0x3d, 0x09,
	0x8c, 0xda, 0x89, 0x98, 0xa0, 0xc4, 0xae, 0x83, 0xab, 0x8a, 0x3d, 0x31, 0x56, 0xdb, 0x9b, 0x91,
	0x30, 0xdc, 0x36, 0x5a, 0x1e, 0xe4, 0x7d, 0x07, 0xf2, 0x86, 0xa9, 0xb7, 0x0d, 0x1e, 0xe0, 0x45,
	0x03, 0x08, 0x6a, 0xa9, 0x1e, 0x43, 0xd0, 0xfe, 0x9a, 0x46, 0x64, 0xf8, 0xbe, 0x4d, 0xda, 0x89,
	0x66, 0xe9, 0xbd, 0x67, 0x4f, 0xf3, 0x37, 0xe3, 0x4b, 0x88, 0xb5, 0x4b, 0x01, 0xf4, 0x7f, 0x68,
	0x98, 0x0e, 0x13, 0x0d, 0xd3, 0xa8, 0x28, 0x9b, 0xa4, 0x65, 0x7a, 0x3b, 0x0c, 0x93, 0x49, 0x9b,
	0x26, 0xed, 0x2f, 0xe9, 0x20, 0xc5, 0xbf, 0xf6, 0x77, 0xb5, 0x4a, 0xec, 0x5d, 0x6d, 0x49, 0x3a,
	0xc4, 0xb1, 0xe8, 0x44, 0xef, 0x68, 0xb5, 0xc4, 0x3b, 0x1a, 0x56, 0xf4, 0x4c, 0xfe, 0x6e, 0x96,
	0x7b, 0xf1, 0x24, 0xbf, 0x86, 0xe6, 0x77, 0x3f, 0x3d, 0xda, 0x09, 0x8e, 0xab, 0x5f, 0x91, 0xac,
	0xe7, 0x58, 0x94, 0x41, 0x6f, 0xae, 0xd6, 0xc3, 0xaf, 0xdd, 0x7b, 0x1f, 0xc4, 0xbc, 0xb7, 0x1e,
	0xad, 0x5a, 0x1a, 0x38, 0x91, 0x13, 0x9b, 0x09, 0x27, 0x6e, 0x0c, 0xab, 0x9b, 0xdc, 0x97, 0xdb,
	0x2f, 0x9e, 0xe4, 0xaf, 0xc7, 0x7d, 0xb9, 0x08, 0xbe, 0x2c, 0xb6, 0x03, 0x95, 0x4c, 0xfb, 0x7b,
	0x0a, 0x2d, 0x27, 0x4c, 0x26, 0x77, 0x51, 0x16, 0x0e, 0x29, 0x26, 0x1f, 0xb5, 0x06, 0x6f, 0x40,
	0xd0, 0x41, 0xab, 0xf3, 0x25, 0x01, 0x72, 0x1f, 0x21, 0x10, 0x14, 0x27, 0x7a, 0xf0, 0x30, 0x37,
	0x17, 0x5d, 0xc3, 0xc4, 0x6d, 0x5a, 0xf4, 0x96, 0xb1, 0x6b, 0xd8, 0x48, 0x18, 0xee, 0xf9, 0x60,
	0x95, 0xac, 0x82, 0x22, 0xbb, 0xc1, 0x6e, 0xd5, 0x7f, 0xf1, 0xb1, 0xb6, 0x8a, 0x56, 0x86, 0x7c,
	0xa5, 0x75, 0xd1, 0x6c, 0x18, 0xcd, 0xe4, 0x67, 0x68, 0x3e, 0x6a, 0xc8, 0xc2, 0xd7, 0x49, 0x19,
	0xaa, 0x11, 0x41, 0xd8, 0x0b, 0xee, 0x5d, 0x77, 0x23, 0x66, 0xd5, 0xde, 0x91, 0xb0, 0xb6, 0x80,
	0x50, 0x14, 0xee, 0xda, 0xbf, 0xd2, 0xea, 0x0d, 0x95, 0xfc, 0x08, 0xcd, 0x36, 0xb9, 0xee, 0xf1,
	0x56, 0xad, 0x29, 0x8f, 0xd4, 0x8d, 0x8b, 0x7e, 0x61, 0x95, 0x01, 0x56, 0xe4, 0x96, 0xaa, 0x7e,
	0x14, 0x48, 0x3e, 0x41, 0x9b, 0xcd, 0x53, 0x53, 0xde, 0xea, 0xa0, 0x6e, 0xff, 0x84, 0x7a, 0x41,
	0xcb, 0x63, 0x3a, 0xb6, 0x08, 0xe4, 0xd9, 0xf2, 0x77, 0x2e, 0xfa, 0x85, 0xd7, 0xd9, 0xa9, 0x19,
	0x3e, 0x99, 0x8a, 0x6a, 0x5d, 0x3c, 0x53, 0x18, 0x95, 0x59, 0xbe, 0x28, 0x23, 0xa9, 0x20, 0x14,
	0xcc, 0x0a, 0x0d, 0xb3, 0xdc, 0x8c, 0x3c, 0x38, 0x47, 0xca, 0x26, 0xee, 0x58, 0xa3, 0xe1, 0x57,
	0x7a, 0xe8, 0x40, 0xe9, 0x84, 0x18, 0xfb, 0x66, 0x96, 0x4e, 0xb0, 0xec, 0x55, 0x94, 0x4e, 0xa1,
	0xe7, 0xd5, 0x94, 0x4e, 0x91, 0xa3, 0xda, 0x9f, 0xd3, 0xc1, 0x45, 0x59, 0x64, 0x82, 0xfa, 0x7e,
	0x93, 0x9a, 0xf4, 0xfd, 0x26, 0x7a, 0x32, 0x4a, 0x4f, 0xf6, 0x64, 0x34, 0xb8, 0x69, 0x67, 0x26,
	0xbe, 0x69, 0x1f, 0xa2, 0x29, 0xd8, 0x5d, 0x19, 0x38, 0x6f, 0xaa, 0x3d, 0x51, 0xb8, 0x28, 0xe1,
	0x32, 0x71, 0xbf, 0x02, 0xaf, 0xf3, 0x73, 0x37, 0x56, 0x2b, 0xe2, 0x63, 0xed, 0xb5, 0xc0, 0x19,
	0xc9, 0x87, 0x65, 0xb8, 0xa2, 0x7c, 0xd4, 0xaa, 0x36, 0x0e, 0x4b, 0x35, 0x9c, 0xd2, 0x7e, 0x9d,
	0x09, 0xaa, 0x99, 0x6c, 0x6b, 0xee, 0xa2, 0x2c, 0x64, 0xf8, 0x50, 0x51, 0x14, 0x47, 0x93, 0xba,
	0xf4, 0x04, 0xf0, 0x0a, 0x8b, 0xa2, 0x8f, 0x56, 0x6b, 0x3a, 0xe3, 0xb2, 0xb9, 0x38, 0xf6, 0xad,
	0x9a, 0xd3, 0x35, 0xed, 0x28, 0x02, 0x21, 0x09, 0xcc, 0x1e, 0x65, 0x5c, 0xef, 0xb9, 0xe5, 0xd7,
	0xe5, 0x14, 0x05, 0x4b, 0x67, 0xbc, 0xc8, 0x06, 0x32, 0x45, 0x0b, 0x84, 0x94, 0xc9, 0x3e, 0x8f,
	0x81, 0x7c, 0x3a, 0xf4, 0x5f, 0x6a, 0x4a, 0x2c, 0x62, 0x7f, 0xa2, 0x9f, 0x1d, 0x5f, 0xee, 0x57,
	0x55, 0x79, 0xe1, 0xf9, 0xcb, 0xad, 0xd4, 0x67, 0x2f, 0xb7, 0x52, 0xff, 0x79, 0xb9, 0x95, 0xaa,
	0xa7, 0xda, 0xd3, 0xe2, 0x4f, 0xe5, 0x9d, 0xff, 0x05, 0x00, 0x00, 0xff, 0xff, 0xda, 0x75, 0x29,
	0x73, 0x78, 0x1d, 0x00, 0x00,
}
