// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: auth.proto

/*
	Package auth is a generated protocol buffer package.

	Service name

	It is generated from these files:
		auth.proto

	It has these top-level messages:
		AuthenticationPolicy
		AuthenticationPolicyList
		AuthenticationPolicySpec
		AuthenticationPolicyStatus
		Authenticators
		AutoMsgAuthenticationPolicyWatchHelper
		AutoMsgUserWatchHelper
		Ldap
		LdapAttributeMapping
		Local
		Radius
		TLSOptions
		User
		UserList
		UserSpec
		UserStatus
*/
package auth

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/pensando/grpc-gateway/third_party/googleapis/google/api"
import _ "github.com/pensando/sw/venice/utils/apigen/annotations"
import _ "github.com/gogo/protobuf/gogoproto"
import api "github.com/pensando/sw/api"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type Authenticators_AuthenticatorType int32

const (
	Authenticators_LOCAL  Authenticators_AuthenticatorType = 0
	Authenticators_LDAP   Authenticators_AuthenticatorType = 1
	Authenticators_RADIUS Authenticators_AuthenticatorType = 2
)

var Authenticators_AuthenticatorType_name = map[int32]string{
	0: "LOCAL",
	1: "LDAP",
	2: "RADIUS",
}
var Authenticators_AuthenticatorType_value = map[string]int32{
	"LOCAL":  0,
	"LDAP":   1,
	"RADIUS": 2,
}

func (x Authenticators_AuthenticatorType) String() string {
	return proto.EnumName(Authenticators_AuthenticatorType_name, int32(x))
}
func (Authenticators_AuthenticatorType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorAuth, []int{4, 0}
}

type UserSpec_UserType int32

const (
	UserSpec_LOCAL    UserSpec_UserType = 0
	UserSpec_EXTERNAL UserSpec_UserType = 1
)

var UserSpec_UserType_name = map[int32]string{
	0: "LOCAL",
	1: "EXTERNAL",
}
var UserSpec_UserType_value = map[string]int32{
	"LOCAL":    0,
	"EXTERNAL": 1,
}

func (x UserSpec_UserType) String() string {
	return proto.EnumName(UserSpec_UserType_name, int32(x))
}
func (UserSpec_UserType) EnumDescriptor() ([]byte, []int) { return fileDescriptorAuth, []int{14, 0} }

// spec part of user object
type AuthenticationPolicy struct {
	api.TypeMeta   `protobuf:"bytes,1,opt,name=T,embedded=T" json:",inline"`
	api.ObjectMeta `protobuf:"bytes,2,opt,name=O,embedded=O" json:"meta,omitempty"`
	Spec           AuthenticationPolicySpec   `protobuf:"bytes,3,opt,name=Spec" json:"spec,omitempty"`
	Status         AuthenticationPolicyStatus `protobuf:"bytes,4,opt,name=Status" json:"status,omitempty"`
}

func (m *AuthenticationPolicy) Reset()                    { *m = AuthenticationPolicy{} }
func (m *AuthenticationPolicy) String() string            { return proto.CompactTextString(m) }
func (*AuthenticationPolicy) ProtoMessage()               {}
func (*AuthenticationPolicy) Descriptor() ([]byte, []int) { return fileDescriptorAuth, []int{0} }

func (m *AuthenticationPolicy) GetSpec() AuthenticationPolicySpec {
	if m != nil {
		return m.Spec
	}
	return AuthenticationPolicySpec{}
}

func (m *AuthenticationPolicy) GetStatus() AuthenticationPolicyStatus {
	if m != nil {
		return m.Status
	}
	return AuthenticationPolicyStatus{}
}

// status part of user object
type AuthenticationPolicyList struct {
	api.TypeMeta `protobuf:"bytes,2,opt,name=T,embedded=T" json:"T"`
	api.ListMeta `protobuf:"bytes,3,opt,name=ListMeta,embedded=ListMeta" json:"ListMeta"`
	Items        []*AuthenticationPolicy `protobuf:"bytes,4,rep,name=Items" json:"Items,omitempty"`
}

func (m *AuthenticationPolicyList) Reset()                    { *m = AuthenticationPolicyList{} }
func (m *AuthenticationPolicyList) String() string            { return proto.CompactTextString(m) }
func (*AuthenticationPolicyList) ProtoMessage()               {}
func (*AuthenticationPolicyList) Descriptor() ([]byte, []int) { return fileDescriptorAuth, []int{1} }

func (m *AuthenticationPolicyList) GetItems() []*AuthenticationPolicy {
	if m != nil {
		return m.Items
	}
	return nil
}

// User could be local or external
type AuthenticationPolicySpec struct {
	Authenticators Authenticators `protobuf:"bytes,1,opt,name=Authenticators" json:"authenticators,omitempty"`
	Secret         []byte         `protobuf:"bytes,2,opt,name=Secret,proto3" json:"secret,omitempty"`
}

func (m *AuthenticationPolicySpec) Reset()                    { *m = AuthenticationPolicySpec{} }
func (m *AuthenticationPolicySpec) String() string            { return proto.CompactTextString(m) }
func (*AuthenticationPolicySpec) ProtoMessage()               {}
func (*AuthenticationPolicySpec) Descriptor() ([]byte, []int) { return fileDescriptorAuth, []int{2} }

func (m *AuthenticationPolicySpec) GetAuthenticators() Authenticators {
	if m != nil {
		return m.Authenticators
	}
	return Authenticators{}
}

func (m *AuthenticationPolicySpec) GetSecret() []byte {
	if m != nil {
		return m.Secret
	}
	return nil
}

// spec part of authentication policy object
type AuthenticationPolicyStatus struct {
}

func (m *AuthenticationPolicyStatus) Reset()                    { *m = AuthenticationPolicyStatus{} }
func (m *AuthenticationPolicyStatus) String() string            { return proto.CompactTextString(m) }
func (*AuthenticationPolicyStatus) ProtoMessage()               {}
func (*AuthenticationPolicyStatus) Descriptor() ([]byte, []int) { return fileDescriptorAuth, []int{3} }

type Authenticators struct {
	Ldap   *Ldap   `protobuf:"bytes,1,opt,name=Ldap" json:"ldap,omitempty"`
	Local  *Local  `protobuf:"bytes,2,opt,name=Local" json:"local,omitempty"`
	Radius *Radius `protobuf:"bytes,3,opt,name=Radius" json:"radius,omitempty"`
	// Order in which authenticators are applied. If an authenticator returns success, others are skipped
	AuthenticatorOrder []string `protobuf:"bytes,9,rep,name=AuthenticatorOrder" json:"authenticator-order,omitempty"`
}

func (m *Authenticators) Reset()                    { *m = Authenticators{} }
func (m *Authenticators) String() string            { return proto.CompactTextString(m) }
func (*Authenticators) ProtoMessage()               {}
func (*Authenticators) Descriptor() ([]byte, []int) { return fileDescriptorAuth, []int{4} }

func (m *Authenticators) GetLdap() *Ldap {
	if m != nil {
		return m.Ldap
	}
	return nil
}

func (m *Authenticators) GetLocal() *Local {
	if m != nil {
		return m.Local
	}
	return nil
}

func (m *Authenticators) GetRadius() *Radius {
	if m != nil {
		return m.Radius
	}
	return nil
}

func (m *Authenticators) GetAuthenticatorOrder() []string {
	if m != nil {
		return m.AuthenticatorOrder
	}
	return nil
}

type AutoMsgAuthenticationPolicyWatchHelper struct {
	Type   string                `protobuf:"bytes,1,opt,name=Type,proto3" json:"Type,omitempty"`
	Object *AuthenticationPolicy `protobuf:"bytes,2,opt,name=Object" json:"Object,omitempty"`
}

func (m *AutoMsgAuthenticationPolicyWatchHelper) Reset() {
	*m = AutoMsgAuthenticationPolicyWatchHelper{}
}
func (m *AutoMsgAuthenticationPolicyWatchHelper) String() string { return proto.CompactTextString(m) }
func (*AutoMsgAuthenticationPolicyWatchHelper) ProtoMessage()    {}
func (*AutoMsgAuthenticationPolicyWatchHelper) Descriptor() ([]byte, []int) {
	return fileDescriptorAuth, []int{5}
}

func (m *AutoMsgAuthenticationPolicyWatchHelper) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *AutoMsgAuthenticationPolicyWatchHelper) GetObject() *AuthenticationPolicy {
	if m != nil {
		return m.Object
	}
	return nil
}

type AutoMsgUserWatchHelper struct {
	// StartTLS determines if ldap connection uses TLS
	Type string `protobuf:"bytes,1,opt,name=Type,proto3" json:"Type,omitempty"`
	// SkipServerCertVerification controls whether a client verifies the server's certificate chain and host name.
	// If SkipServerCertVerification is true, TLS accepts any certificate presented by the server and any host name in that certificate.
	// In this mode, TLS is susceptible to man-in-the-middle attacks. This should be used only for testing.
	Object *User `protobuf:"bytes,2,opt,name=Object" json:"Object,omitempty"`
}

func (m *AutoMsgUserWatchHelper) Reset()                    { *m = AutoMsgUserWatchHelper{} }
func (m *AutoMsgUserWatchHelper) String() string            { return proto.CompactTextString(m) }
func (*AutoMsgUserWatchHelper) ProtoMessage()               {}
func (*AutoMsgUserWatchHelper) Descriptor() ([]byte, []int) { return fileDescriptorAuth, []int{6} }

func (m *AutoMsgUserWatchHelper) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *AutoMsgUserWatchHelper) GetObject() *User {
	if m != nil {
		return m.Object
	}
	return nil
}

type Ldap struct {
	Enabled bool `protobuf:"varint,1,opt,name=Enabled,proto3" json:"enabled,omitempty"`
	// UserObjectClass is the STRUCTURAL object class for user entry in LDAP. It is used as a filter for user search
	Url        string      `protobuf:"bytes,2,opt,name=Url,proto3" json:"url,omitempty"`
	TLSOptions *TLSOptions `protobuf:"bytes,3,opt,name=TLSOptions" json:"tls-options,omitempty"`
	BaseDN     string      `protobuf:"bytes,4,opt,name=BaseDN,proto3" json:"base-dn,omitempty"`
	// GroupObjectClass is the STRUCTURAL object class for group entry in LDAP. It is used as a filter for group search
	BindDN           string                `protobuf:"bytes,5,opt,name=BindDN,proto3" json:"bind-dn,omitempty"`
	BindPassword     string                `protobuf:"bytes,6,opt,name=BindPassword,proto3" json:"bind-password,omitempty"`
	AttributeMapping *LdapAttributeMapping `protobuf:"bytes,7,opt,name=AttributeMapping" json:"attribute-mapping,omitempty"`
}

func (m *Ldap) Reset()                    { *m = Ldap{} }
func (m *Ldap) String() string            { return proto.CompactTextString(m) }
func (*Ldap) ProtoMessage()               {}
func (*Ldap) Descriptor() ([]byte, []int) { return fileDescriptorAuth, []int{7} }

func (m *Ldap) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

func (m *Ldap) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *Ldap) GetTLSOptions() *TLSOptions {
	if m != nil {
		return m.TLSOptions
	}
	return nil
}

func (m *Ldap) GetBaseDN() string {
	if m != nil {
		return m.BaseDN
	}
	return ""
}

func (m *Ldap) GetBindDN() string {
	if m != nil {
		return m.BindDN
	}
	return ""
}

func (m *Ldap) GetBindPassword() string {
	if m != nil {
		return m.BindPassword
	}
	return ""
}

func (m *Ldap) GetAttributeMapping() *LdapAttributeMapping {
	if m != nil {
		return m.AttributeMapping
	}
	return nil
}

type LdapAttributeMapping struct {
	User             string `protobuf:"bytes,1,opt,name=User,proto3" json:"user,omitempty"`
	UserObjectClass  string `protobuf:"bytes,2,opt,name=UserObjectClass,proto3" json:"user-object-class,omitempty"`
	Tenant           string `protobuf:"bytes,3,opt,name=Tenant,proto3" json:"tenant,omitempty"`
	Group            string `protobuf:"bytes,4,opt,name=Group,proto3" json:"group,omitempty"`
	GroupObjectClass string `protobuf:"bytes,5,opt,name=GroupObjectClass,proto3" json:"group-object-class,omitempty"`
	Email            string `protobuf:"bytes,6,opt,name=Email,proto3" json:"email,omitempty"`
	Fullname         string `protobuf:"bytes,7,opt,name=Fullname,proto3" json:"fullname,omitempty"`
}

func (m *LdapAttributeMapping) Reset()                    { *m = LdapAttributeMapping{} }
func (m *LdapAttributeMapping) String() string            { return proto.CompactTextString(m) }
func (*LdapAttributeMapping) ProtoMessage()               {}
func (*LdapAttributeMapping) Descriptor() ([]byte, []int) { return fileDescriptorAuth, []int{8} }

func (m *LdapAttributeMapping) GetUser() string {
	if m != nil {
		return m.User
	}
	return ""
}

func (m *LdapAttributeMapping) GetUserObjectClass() string {
	if m != nil {
		return m.UserObjectClass
	}
	return ""
}

func (m *LdapAttributeMapping) GetTenant() string {
	if m != nil {
		return m.Tenant
	}
	return ""
}

func (m *LdapAttributeMapping) GetGroup() string {
	if m != nil {
		return m.Group
	}
	return ""
}

func (m *LdapAttributeMapping) GetGroupObjectClass() string {
	if m != nil {
		return m.GroupObjectClass
	}
	return ""
}

func (m *LdapAttributeMapping) GetEmail() string {
	if m != nil {
		return m.Email
	}
	return ""
}

func (m *LdapAttributeMapping) GetFullname() string {
	if m != nil {
		return m.Fullname
	}
	return ""
}

type Local struct {
	Enabled bool `protobuf:"varint,1,opt,name=Enabled,proto3" json:"enabled,omitempty"`
}

func (m *Local) Reset()                    { *m = Local{} }
func (m *Local) String() string            { return proto.CompactTextString(m) }
func (*Local) ProtoMessage()               {}
func (*Local) Descriptor() ([]byte, []int) { return fileDescriptorAuth, []int{9} }

func (m *Local) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

// status part of authentication policy object
type Radius struct {
	Enabled bool   `protobuf:"varint,1,opt,name=Enabled,proto3" json:"enabled,omitempty"`
	Ip      string `protobuf:"bytes,2,opt,name=Ip,proto3" json:"ip,omitempty"`
	Port    string `protobuf:"bytes,3,opt,name=Port,proto3" json:"port,omitempty"`
	NasIp   string `protobuf:"bytes,4,opt,name=NasIp,proto3" json:"nas-ip,omitempty"`
	Secret  string `protobuf:"bytes,5,opt,name=Secret,proto3" json:"secret,omitempty"`
}

func (m *Radius) Reset()                    { *m = Radius{} }
func (m *Radius) String() string            { return proto.CompactTextString(m) }
func (*Radius) ProtoMessage()               {}
func (*Radius) Descriptor() ([]byte, []int) { return fileDescriptorAuth, []int{10} }

func (m *Radius) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

func (m *Radius) GetIp() string {
	if m != nil {
		return m.Ip
	}
	return ""
}

func (m *Radius) GetPort() string {
	if m != nil {
		return m.Port
	}
	return ""
}

func (m *Radius) GetNasIp() string {
	if m != nil {
		return m.NasIp
	}
	return ""
}

func (m *Radius) GetSecret() string {
	if m != nil {
		return m.Secret
	}
	return ""
}

// AuthenticationPolicy defines various authentication mechanisms available and order in which they are used
type TLSOptions struct {
	StartTLS                   bool `protobuf:"varint,1,opt,name=StartTLS,proto3" json:"start-tls,omitempty"`
	SkipServerCertVerification bool `protobuf:"varint,2,opt,name=SkipServerCertVerification,proto3" json:"skip-server-cert-verification,omitempty"`
	// Spec contains configuration of authentication mechanisms.
	ServerName string `protobuf:"bytes,3,opt,name=ServerName,proto3" json:"server-name,omitempty"`
	// Status contains the current state of the authentication policy.
	TrustedCerts string `protobuf:"bytes,4,opt,name=TrustedCerts,proto3" json:"trusted-certs,omitempty"`
}

func (m *TLSOptions) Reset()                    { *m = TLSOptions{} }
func (m *TLSOptions) String() string            { return proto.CompactTextString(m) }
func (*TLSOptions) ProtoMessage()               {}
func (*TLSOptions) Descriptor() ([]byte, []int) { return fileDescriptorAuth, []int{11} }

func (m *TLSOptions) GetStartTLS() bool {
	if m != nil {
		return m.StartTLS
	}
	return false
}

func (m *TLSOptions) GetSkipServerCertVerification() bool {
	if m != nil {
		return m.SkipServerCertVerification
	}
	return false
}

func (m *TLSOptions) GetServerName() string {
	if m != nil {
		return m.ServerName
	}
	return ""
}

func (m *TLSOptions) GetTrustedCerts() string {
	if m != nil {
		return m.TrustedCerts
	}
	return ""
}

type User struct {
	api.TypeMeta   `protobuf:"bytes,1,opt,name=T,embedded=T" json:",inline"`
	api.ObjectMeta `protobuf:"bytes,2,opt,name=O,embedded=O" json:"meta,omitempty"`
	Spec           UserSpec   `protobuf:"bytes,3,opt,name=Spec" json:"spec,omitempty"`
	Status         UserStatus `protobuf:"bytes,4,opt,name=Status" json:"status,omitempty"`
}

func (m *User) Reset()                    { *m = User{} }
func (m *User) String() string            { return proto.CompactTextString(m) }
func (*User) ProtoMessage()               {}
func (*User) Descriptor() ([]byte, []int) { return fileDescriptorAuth, []int{12} }

func (m *User) GetSpec() UserSpec {
	if m != nil {
		return m.Spec
	}
	return UserSpec{}
}

func (m *User) GetStatus() UserStatus {
	if m != nil {
		return m.Status
	}
	return UserStatus{}
}

type UserList struct {
	api.TypeMeta `protobuf:"bytes,2,opt,name=T,embedded=T" json:"T"`
	api.ListMeta `protobuf:"bytes,3,opt,name=ListMeta,embedded=ListMeta" json:"ListMeta"`
	Items        []*User `protobuf:"bytes,4,rep,name=Items" json:"Items,omitempty"`
}

func (m *UserList) Reset()                    { *m = UserList{} }
func (m *UserList) String() string            { return proto.CompactTextString(m) }
func (*UserList) ProtoMessage()               {}
func (*UserList) Descriptor() ([]byte, []int) { return fileDescriptorAuth, []int{13} }

func (m *UserList) GetItems() []*User {
	if m != nil {
		return m.Items
	}
	return nil
}

type UserSpec struct {
	Fullname string `protobuf:"bytes,1,opt,name=Fullname,proto3" json:"fullname,omitempty"`
	Email    string `protobuf:"bytes,2,opt,name=Email,proto3" json:"email,omitempty"`
	Password string `protobuf:"bytes,3,opt,name=Password,proto3" json:"password,omitempty"`
	Type     string `protobuf:"bytes,4,opt,name=Type,proto3" json:"type,omitempty"`
}

func (m *UserSpec) Reset()                    { *m = UserSpec{} }
func (m *UserSpec) String() string            { return proto.CompactTextString(m) }
func (*UserSpec) ProtoMessage()               {}
func (*UserSpec) Descriptor() ([]byte, []int) { return fileDescriptorAuth, []int{14} }

func (m *UserSpec) GetFullname() string {
	if m != nil {
		return m.Fullname
	}
	return ""
}

func (m *UserSpec) GetEmail() string {
	if m != nil {
		return m.Email
	}
	return ""
}

func (m *UserSpec) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

func (m *UserSpec) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

type UserStatus struct {
	Roles               []string       `protobuf:"bytes,1,rep,name=Roles" json:"roles,omitempty"`
	UserGroups          []string       `protobuf:"bytes,2,rep,name=UserGroups" json:"user-groups,omitempty"`
	LastSuccessfulLogin *api.Timestamp `protobuf:"bytes,3,opt,name=LastSuccessfulLogin" json:"last-successful-login,omitempty"`
}

func (m *UserStatus) Reset()                    { *m = UserStatus{} }
func (m *UserStatus) String() string            { return proto.CompactTextString(m) }
func (*UserStatus) ProtoMessage()               {}
func (*UserStatus) Descriptor() ([]byte, []int) { return fileDescriptorAuth, []int{15} }

func (m *UserStatus) GetRoles() []string {
	if m != nil {
		return m.Roles
	}
	return nil
}

func (m *UserStatus) GetUserGroups() []string {
	if m != nil {
		return m.UserGroups
	}
	return nil
}

func (m *UserStatus) GetLastSuccessfulLogin() *api.Timestamp {
	if m != nil {
		return m.LastSuccessfulLogin
	}
	return nil
}

func init() {
	proto.RegisterType((*AuthenticationPolicy)(nil), "auth.AuthenticationPolicy")
	proto.RegisterType((*AuthenticationPolicyList)(nil), "auth.AuthenticationPolicyList")
	proto.RegisterType((*AuthenticationPolicySpec)(nil), "auth.AuthenticationPolicySpec")
	proto.RegisterType((*AuthenticationPolicyStatus)(nil), "auth.AuthenticationPolicyStatus")
	proto.RegisterType((*Authenticators)(nil), "auth.Authenticators")
	proto.RegisterType((*AutoMsgAuthenticationPolicyWatchHelper)(nil), "auth.AutoMsgAuthenticationPolicyWatchHelper")
	proto.RegisterType((*AutoMsgUserWatchHelper)(nil), "auth.AutoMsgUserWatchHelper")
	proto.RegisterType((*Ldap)(nil), "auth.Ldap")
	proto.RegisterType((*LdapAttributeMapping)(nil), "auth.LdapAttributeMapping")
	proto.RegisterType((*Local)(nil), "auth.Local")
	proto.RegisterType((*Radius)(nil), "auth.Radius")
	proto.RegisterType((*TLSOptions)(nil), "auth.TLSOptions")
	proto.RegisterType((*User)(nil), "auth.User")
	proto.RegisterType((*UserList)(nil), "auth.UserList")
	proto.RegisterType((*UserSpec)(nil), "auth.UserSpec")
	proto.RegisterType((*UserStatus)(nil), "auth.UserStatus")
	proto.RegisterEnum("auth.Authenticators_AuthenticatorType", Authenticators_AuthenticatorType_name, Authenticators_AuthenticatorType_value)
	proto.RegisterEnum("auth.UserSpec_UserType", UserSpec_UserType_name, UserSpec_UserType_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for AuthV1 service

type AuthV1Client interface {
	AutoAddAuthenticationPolicy(ctx context.Context, in *AuthenticationPolicy, opts ...grpc.CallOption) (*AuthenticationPolicy, error)
	AutoAddUser(ctx context.Context, in *User, opts ...grpc.CallOption) (*User, error)
	AutoDeleteAuthenticationPolicy(ctx context.Context, in *AuthenticationPolicy, opts ...grpc.CallOption) (*AuthenticationPolicy, error)
	AutoDeleteUser(ctx context.Context, in *User, opts ...grpc.CallOption) (*User, error)
	AutoGetAuthenticationPolicy(ctx context.Context, in *AuthenticationPolicy, opts ...grpc.CallOption) (*AuthenticationPolicy, error)
	AutoGetUser(ctx context.Context, in *User, opts ...grpc.CallOption) (*User, error)
	AutoListAuthenticationPolicy(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (*AuthenticationPolicyList, error)
	AutoListUser(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (*UserList, error)
	AutoUpdateAuthenticationPolicy(ctx context.Context, in *AuthenticationPolicy, opts ...grpc.CallOption) (*AuthenticationPolicy, error)
	AutoUpdateUser(ctx context.Context, in *User, opts ...grpc.CallOption) (*User, error)
	AutoWatchAuthenticationPolicy(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (AuthV1_AutoWatchAuthenticationPolicyClient, error)
	AutoWatchUser(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (AuthV1_AutoWatchUserClient, error)
}

type authV1Client struct {
	cc *grpc.ClientConn
}

func NewAuthV1Client(cc *grpc.ClientConn) AuthV1Client {
	return &authV1Client{cc}
}

func (c *authV1Client) AutoAddAuthenticationPolicy(ctx context.Context, in *AuthenticationPolicy, opts ...grpc.CallOption) (*AuthenticationPolicy, error) {
	out := new(AuthenticationPolicy)
	err := grpc.Invoke(ctx, "/auth.AuthV1/AutoAddAuthenticationPolicy", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authV1Client) AutoAddUser(ctx context.Context, in *User, opts ...grpc.CallOption) (*User, error) {
	out := new(User)
	err := grpc.Invoke(ctx, "/auth.AuthV1/AutoAddUser", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authV1Client) AutoDeleteAuthenticationPolicy(ctx context.Context, in *AuthenticationPolicy, opts ...grpc.CallOption) (*AuthenticationPolicy, error) {
	out := new(AuthenticationPolicy)
	err := grpc.Invoke(ctx, "/auth.AuthV1/AutoDeleteAuthenticationPolicy", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authV1Client) AutoDeleteUser(ctx context.Context, in *User, opts ...grpc.CallOption) (*User, error) {
	out := new(User)
	err := grpc.Invoke(ctx, "/auth.AuthV1/AutoDeleteUser", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authV1Client) AutoGetAuthenticationPolicy(ctx context.Context, in *AuthenticationPolicy, opts ...grpc.CallOption) (*AuthenticationPolicy, error) {
	out := new(AuthenticationPolicy)
	err := grpc.Invoke(ctx, "/auth.AuthV1/AutoGetAuthenticationPolicy", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authV1Client) AutoGetUser(ctx context.Context, in *User, opts ...grpc.CallOption) (*User, error) {
	out := new(User)
	err := grpc.Invoke(ctx, "/auth.AuthV1/AutoGetUser", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authV1Client) AutoListAuthenticationPolicy(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (*AuthenticationPolicyList, error) {
	out := new(AuthenticationPolicyList)
	err := grpc.Invoke(ctx, "/auth.AuthV1/AutoListAuthenticationPolicy", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authV1Client) AutoListUser(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (*UserList, error) {
	out := new(UserList)
	err := grpc.Invoke(ctx, "/auth.AuthV1/AutoListUser", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authV1Client) AutoUpdateAuthenticationPolicy(ctx context.Context, in *AuthenticationPolicy, opts ...grpc.CallOption) (*AuthenticationPolicy, error) {
	out := new(AuthenticationPolicy)
	err := grpc.Invoke(ctx, "/auth.AuthV1/AutoUpdateAuthenticationPolicy", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authV1Client) AutoUpdateUser(ctx context.Context, in *User, opts ...grpc.CallOption) (*User, error) {
	out := new(User)
	err := grpc.Invoke(ctx, "/auth.AuthV1/AutoUpdateUser", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authV1Client) AutoWatchAuthenticationPolicy(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (AuthV1_AutoWatchAuthenticationPolicyClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_AuthV1_serviceDesc.Streams[0], c.cc, "/auth.AuthV1/AutoWatchAuthenticationPolicy", opts...)
	if err != nil {
		return nil, err
	}
	x := &authV1AutoWatchAuthenticationPolicyClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type AuthV1_AutoWatchAuthenticationPolicyClient interface {
	Recv() (*AutoMsgAuthenticationPolicyWatchHelper, error)
	grpc.ClientStream
}

type authV1AutoWatchAuthenticationPolicyClient struct {
	grpc.ClientStream
}

func (x *authV1AutoWatchAuthenticationPolicyClient) Recv() (*AutoMsgAuthenticationPolicyWatchHelper, error) {
	m := new(AutoMsgAuthenticationPolicyWatchHelper)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *authV1Client) AutoWatchUser(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (AuthV1_AutoWatchUserClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_AuthV1_serviceDesc.Streams[1], c.cc, "/auth.AuthV1/AutoWatchUser", opts...)
	if err != nil {
		return nil, err
	}
	x := &authV1AutoWatchUserClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type AuthV1_AutoWatchUserClient interface {
	Recv() (*AutoMsgUserWatchHelper, error)
	grpc.ClientStream
}

type authV1AutoWatchUserClient struct {
	grpc.ClientStream
}

func (x *authV1AutoWatchUserClient) Recv() (*AutoMsgUserWatchHelper, error) {
	m := new(AutoMsgUserWatchHelper)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for AuthV1 service

type AuthV1Server interface {
	AutoAddAuthenticationPolicy(context.Context, *AuthenticationPolicy) (*AuthenticationPolicy, error)
	AutoAddUser(context.Context, *User) (*User, error)
	AutoDeleteAuthenticationPolicy(context.Context, *AuthenticationPolicy) (*AuthenticationPolicy, error)
	AutoDeleteUser(context.Context, *User) (*User, error)
	AutoGetAuthenticationPolicy(context.Context, *AuthenticationPolicy) (*AuthenticationPolicy, error)
	AutoGetUser(context.Context, *User) (*User, error)
	AutoListAuthenticationPolicy(context.Context, *api.ListWatchOptions) (*AuthenticationPolicyList, error)
	AutoListUser(context.Context, *api.ListWatchOptions) (*UserList, error)
	AutoUpdateAuthenticationPolicy(context.Context, *AuthenticationPolicy) (*AuthenticationPolicy, error)
	AutoUpdateUser(context.Context, *User) (*User, error)
	AutoWatchAuthenticationPolicy(*api.ListWatchOptions, AuthV1_AutoWatchAuthenticationPolicyServer) error
	AutoWatchUser(*api.ListWatchOptions, AuthV1_AutoWatchUserServer) error
}

func RegisterAuthV1Server(s *grpc.Server, srv AuthV1Server) {
	s.RegisterService(&_AuthV1_serviceDesc, srv)
}

func _AuthV1_AutoAddAuthenticationPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AuthenticationPolicy)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthV1Server).AutoAddAuthenticationPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/auth.AuthV1/AutoAddAuthenticationPolicy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthV1Server).AutoAddAuthenticationPolicy(ctx, req.(*AuthenticationPolicy))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthV1_AutoAddUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(User)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthV1Server).AutoAddUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/auth.AuthV1/AutoAddUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthV1Server).AutoAddUser(ctx, req.(*User))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthV1_AutoDeleteAuthenticationPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AuthenticationPolicy)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthV1Server).AutoDeleteAuthenticationPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/auth.AuthV1/AutoDeleteAuthenticationPolicy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthV1Server).AutoDeleteAuthenticationPolicy(ctx, req.(*AuthenticationPolicy))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthV1_AutoDeleteUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(User)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthV1Server).AutoDeleteUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/auth.AuthV1/AutoDeleteUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthV1Server).AutoDeleteUser(ctx, req.(*User))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthV1_AutoGetAuthenticationPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AuthenticationPolicy)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthV1Server).AutoGetAuthenticationPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/auth.AuthV1/AutoGetAuthenticationPolicy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthV1Server).AutoGetAuthenticationPolicy(ctx, req.(*AuthenticationPolicy))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthV1_AutoGetUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(User)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthV1Server).AutoGetUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/auth.AuthV1/AutoGetUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthV1Server).AutoGetUser(ctx, req.(*User))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthV1_AutoListAuthenticationPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(api.ListWatchOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthV1Server).AutoListAuthenticationPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/auth.AuthV1/AutoListAuthenticationPolicy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthV1Server).AutoListAuthenticationPolicy(ctx, req.(*api.ListWatchOptions))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthV1_AutoListUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(api.ListWatchOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthV1Server).AutoListUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/auth.AuthV1/AutoListUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthV1Server).AutoListUser(ctx, req.(*api.ListWatchOptions))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthV1_AutoUpdateAuthenticationPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AuthenticationPolicy)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthV1Server).AutoUpdateAuthenticationPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/auth.AuthV1/AutoUpdateAuthenticationPolicy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthV1Server).AutoUpdateAuthenticationPolicy(ctx, req.(*AuthenticationPolicy))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthV1_AutoUpdateUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(User)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthV1Server).AutoUpdateUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/auth.AuthV1/AutoUpdateUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthV1Server).AutoUpdateUser(ctx, req.(*User))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthV1_AutoWatchAuthenticationPolicy_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(api.ListWatchOptions)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AuthV1Server).AutoWatchAuthenticationPolicy(m, &authV1AutoWatchAuthenticationPolicyServer{stream})
}

type AuthV1_AutoWatchAuthenticationPolicyServer interface {
	Send(*AutoMsgAuthenticationPolicyWatchHelper) error
	grpc.ServerStream
}

type authV1AutoWatchAuthenticationPolicyServer struct {
	grpc.ServerStream
}

func (x *authV1AutoWatchAuthenticationPolicyServer) Send(m *AutoMsgAuthenticationPolicyWatchHelper) error {
	return x.ServerStream.SendMsg(m)
}

func _AuthV1_AutoWatchUser_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(api.ListWatchOptions)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AuthV1Server).AutoWatchUser(m, &authV1AutoWatchUserServer{stream})
}

type AuthV1_AutoWatchUserServer interface {
	Send(*AutoMsgUserWatchHelper) error
	grpc.ServerStream
}

type authV1AutoWatchUserServer struct {
	grpc.ServerStream
}

func (x *authV1AutoWatchUserServer) Send(m *AutoMsgUserWatchHelper) error {
	return x.ServerStream.SendMsg(m)
}

var _AuthV1_serviceDesc = grpc.ServiceDesc{
	ServiceName: "auth.AuthV1",
	HandlerType: (*AuthV1Server)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AutoAddAuthenticationPolicy",
			Handler:    _AuthV1_AutoAddAuthenticationPolicy_Handler,
		},
		{
			MethodName: "AutoAddUser",
			Handler:    _AuthV1_AutoAddUser_Handler,
		},
		{
			MethodName: "AutoDeleteAuthenticationPolicy",
			Handler:    _AuthV1_AutoDeleteAuthenticationPolicy_Handler,
		},
		{
			MethodName: "AutoDeleteUser",
			Handler:    _AuthV1_AutoDeleteUser_Handler,
		},
		{
			MethodName: "AutoGetAuthenticationPolicy",
			Handler:    _AuthV1_AutoGetAuthenticationPolicy_Handler,
		},
		{
			MethodName: "AutoGetUser",
			Handler:    _AuthV1_AutoGetUser_Handler,
		},
		{
			MethodName: "AutoListAuthenticationPolicy",
			Handler:    _AuthV1_AutoListAuthenticationPolicy_Handler,
		},
		{
			MethodName: "AutoListUser",
			Handler:    _AuthV1_AutoListUser_Handler,
		},
		{
			MethodName: "AutoUpdateAuthenticationPolicy",
			Handler:    _AuthV1_AutoUpdateAuthenticationPolicy_Handler,
		},
		{
			MethodName: "AutoUpdateUser",
			Handler:    _AuthV1_AutoUpdateUser_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "AutoWatchAuthenticationPolicy",
			Handler:       _AuthV1_AutoWatchAuthenticationPolicy_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "AutoWatchUser",
			Handler:       _AuthV1_AutoWatchUser_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "auth.proto",
}

func (m *AuthenticationPolicy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuthenticationPolicy) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintAuth(dAtA, i, uint64(m.TypeMeta.Size()))
	n1, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n1
	dAtA[i] = 0x12
	i++
	i = encodeVarintAuth(dAtA, i, uint64(m.ObjectMeta.Size()))
	n2, err := m.ObjectMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n2
	dAtA[i] = 0x1a
	i++
	i = encodeVarintAuth(dAtA, i, uint64(m.Spec.Size()))
	n3, err := m.Spec.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n3
	dAtA[i] = 0x22
	i++
	i = encodeVarintAuth(dAtA, i, uint64(m.Status.Size()))
	n4, err := m.Status.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n4
	return i, nil
}

func (m *AuthenticationPolicyList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuthenticationPolicyList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x12
	i++
	i = encodeVarintAuth(dAtA, i, uint64(m.TypeMeta.Size()))
	n5, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n5
	dAtA[i] = 0x1a
	i++
	i = encodeVarintAuth(dAtA, i, uint64(m.ListMeta.Size()))
	n6, err := m.ListMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n6
	if len(m.Items) > 0 {
		for _, msg := range m.Items {
			dAtA[i] = 0x22
			i++
			i = encodeVarintAuth(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *AuthenticationPolicySpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuthenticationPolicySpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintAuth(dAtA, i, uint64(m.Authenticators.Size()))
	n7, err := m.Authenticators.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n7
	if len(m.Secret) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAuth(dAtA, i, uint64(len(m.Secret)))
		i += copy(dAtA[i:], m.Secret)
	}
	return i, nil
}

func (m *AuthenticationPolicyStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuthenticationPolicyStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *Authenticators) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Authenticators) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Ldap != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAuth(dAtA, i, uint64(m.Ldap.Size()))
		n8, err := m.Ldap.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.Local != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAuth(dAtA, i, uint64(m.Local.Size()))
		n9, err := m.Local.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.Radius != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAuth(dAtA, i, uint64(m.Radius.Size()))
		n10, err := m.Radius.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if len(m.AuthenticatorOrder) > 0 {
		for _, s := range m.AuthenticatorOrder {
			dAtA[i] = 0x4a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *AutoMsgAuthenticationPolicyWatchHelper) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AutoMsgAuthenticationPolicyWatchHelper) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAuth(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if m.Object != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAuth(dAtA, i, uint64(m.Object.Size()))
		n11, err := m.Object.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	return i, nil
}

func (m *AutoMsgUserWatchHelper) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AutoMsgUserWatchHelper) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAuth(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if m.Object != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAuth(dAtA, i, uint64(m.Object.Size()))
		n12, err := m.Object.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	return i, nil
}

func (m *Ldap) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Ldap) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Enabled {
		dAtA[i] = 0x8
		i++
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Url) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAuth(dAtA, i, uint64(len(m.Url)))
		i += copy(dAtA[i:], m.Url)
	}
	if m.TLSOptions != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAuth(dAtA, i, uint64(m.TLSOptions.Size()))
		n13, err := m.TLSOptions.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if len(m.BaseDN) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAuth(dAtA, i, uint64(len(m.BaseDN)))
		i += copy(dAtA[i:], m.BaseDN)
	}
	if len(m.BindDN) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintAuth(dAtA, i, uint64(len(m.BindDN)))
		i += copy(dAtA[i:], m.BindDN)
	}
	if len(m.BindPassword) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintAuth(dAtA, i, uint64(len(m.BindPassword)))
		i += copy(dAtA[i:], m.BindPassword)
	}
	if m.AttributeMapping != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintAuth(dAtA, i, uint64(m.AttributeMapping.Size()))
		n14, err := m.AttributeMapping.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	return i, nil
}

func (m *LdapAttributeMapping) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LdapAttributeMapping) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.User) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAuth(dAtA, i, uint64(len(m.User)))
		i += copy(dAtA[i:], m.User)
	}
	if len(m.UserObjectClass) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAuth(dAtA, i, uint64(len(m.UserObjectClass)))
		i += copy(dAtA[i:], m.UserObjectClass)
	}
	if len(m.Tenant) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAuth(dAtA, i, uint64(len(m.Tenant)))
		i += copy(dAtA[i:], m.Tenant)
	}
	if len(m.Group) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAuth(dAtA, i, uint64(len(m.Group)))
		i += copy(dAtA[i:], m.Group)
	}
	if len(m.GroupObjectClass) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintAuth(dAtA, i, uint64(len(m.GroupObjectClass)))
		i += copy(dAtA[i:], m.GroupObjectClass)
	}
	if len(m.Email) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintAuth(dAtA, i, uint64(len(m.Email)))
		i += copy(dAtA[i:], m.Email)
	}
	if len(m.Fullname) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintAuth(dAtA, i, uint64(len(m.Fullname)))
		i += copy(dAtA[i:], m.Fullname)
	}
	return i, nil
}

func (m *Local) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Local) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Enabled {
		dAtA[i] = 0x8
		i++
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *Radius) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Radius) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Enabled {
		dAtA[i] = 0x8
		i++
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Ip) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAuth(dAtA, i, uint64(len(m.Ip)))
		i += copy(dAtA[i:], m.Ip)
	}
	if len(m.Port) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAuth(dAtA, i, uint64(len(m.Port)))
		i += copy(dAtA[i:], m.Port)
	}
	if len(m.NasIp) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAuth(dAtA, i, uint64(len(m.NasIp)))
		i += copy(dAtA[i:], m.NasIp)
	}
	if len(m.Secret) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintAuth(dAtA, i, uint64(len(m.Secret)))
		i += copy(dAtA[i:], m.Secret)
	}
	return i, nil
}

func (m *TLSOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLSOptions) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.StartTLS {
		dAtA[i] = 0x8
		i++
		if m.StartTLS {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.SkipServerCertVerification {
		dAtA[i] = 0x10
		i++
		if m.SkipServerCertVerification {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.ServerName) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAuth(dAtA, i, uint64(len(m.ServerName)))
		i += copy(dAtA[i:], m.ServerName)
	}
	if len(m.TrustedCerts) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAuth(dAtA, i, uint64(len(m.TrustedCerts)))
		i += copy(dAtA[i:], m.TrustedCerts)
	}
	return i, nil
}

func (m *User) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *User) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintAuth(dAtA, i, uint64(m.TypeMeta.Size()))
	n15, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n15
	dAtA[i] = 0x12
	i++
	i = encodeVarintAuth(dAtA, i, uint64(m.ObjectMeta.Size()))
	n16, err := m.ObjectMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n16
	dAtA[i] = 0x1a
	i++
	i = encodeVarintAuth(dAtA, i, uint64(m.Spec.Size()))
	n17, err := m.Spec.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n17
	dAtA[i] = 0x22
	i++
	i = encodeVarintAuth(dAtA, i, uint64(m.Status.Size()))
	n18, err := m.Status.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n18
	return i, nil
}

func (m *UserList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x12
	i++
	i = encodeVarintAuth(dAtA, i, uint64(m.TypeMeta.Size()))
	n19, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n19
	dAtA[i] = 0x1a
	i++
	i = encodeVarintAuth(dAtA, i, uint64(m.ListMeta.Size()))
	n20, err := m.ListMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n20
	if len(m.Items) > 0 {
		for _, msg := range m.Items {
			dAtA[i] = 0x22
			i++
			i = encodeVarintAuth(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *UserSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Fullname) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAuth(dAtA, i, uint64(len(m.Fullname)))
		i += copy(dAtA[i:], m.Fullname)
	}
	if len(m.Email) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAuth(dAtA, i, uint64(len(m.Email)))
		i += copy(dAtA[i:], m.Email)
	}
	if len(m.Password) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAuth(dAtA, i, uint64(len(m.Password)))
		i += copy(dAtA[i:], m.Password)
	}
	if len(m.Type) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAuth(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	return i, nil
}

func (m *UserStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Roles) > 0 {
		for _, s := range m.Roles {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.UserGroups) > 0 {
		for _, s := range m.UserGroups {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.LastSuccessfulLogin != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAuth(dAtA, i, uint64(m.LastSuccessfulLogin.Size()))
		n21, err := m.LastSuccessfulLogin.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	return i, nil
}

func encodeVarintAuth(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *AuthenticationPolicy) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovAuth(uint64(l))
	l = m.ObjectMeta.Size()
	n += 1 + l + sovAuth(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovAuth(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovAuth(uint64(l))
	return n
}

func (m *AuthenticationPolicyList) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovAuth(uint64(l))
	l = m.ListMeta.Size()
	n += 1 + l + sovAuth(uint64(l))
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovAuth(uint64(l))
		}
	}
	return n
}

func (m *AuthenticationPolicySpec) Size() (n int) {
	var l int
	_ = l
	l = m.Authenticators.Size()
	n += 1 + l + sovAuth(uint64(l))
	l = len(m.Secret)
	if l > 0 {
		n += 1 + l + sovAuth(uint64(l))
	}
	return n
}

func (m *AuthenticationPolicyStatus) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *Authenticators) Size() (n int) {
	var l int
	_ = l
	if m.Ldap != nil {
		l = m.Ldap.Size()
		n += 1 + l + sovAuth(uint64(l))
	}
	if m.Local != nil {
		l = m.Local.Size()
		n += 1 + l + sovAuth(uint64(l))
	}
	if m.Radius != nil {
		l = m.Radius.Size()
		n += 1 + l + sovAuth(uint64(l))
	}
	if len(m.AuthenticatorOrder) > 0 {
		for _, s := range m.AuthenticatorOrder {
			l = len(s)
			n += 1 + l + sovAuth(uint64(l))
		}
	}
	return n
}

func (m *AutoMsgAuthenticationPolicyWatchHelper) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovAuth(uint64(l))
	}
	if m.Object != nil {
		l = m.Object.Size()
		n += 1 + l + sovAuth(uint64(l))
	}
	return n
}

func (m *AutoMsgUserWatchHelper) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovAuth(uint64(l))
	}
	if m.Object != nil {
		l = m.Object.Size()
		n += 1 + l + sovAuth(uint64(l))
	}
	return n
}

func (m *Ldap) Size() (n int) {
	var l int
	_ = l
	if m.Enabled {
		n += 2
	}
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovAuth(uint64(l))
	}
	if m.TLSOptions != nil {
		l = m.TLSOptions.Size()
		n += 1 + l + sovAuth(uint64(l))
	}
	l = len(m.BaseDN)
	if l > 0 {
		n += 1 + l + sovAuth(uint64(l))
	}
	l = len(m.BindDN)
	if l > 0 {
		n += 1 + l + sovAuth(uint64(l))
	}
	l = len(m.BindPassword)
	if l > 0 {
		n += 1 + l + sovAuth(uint64(l))
	}
	if m.AttributeMapping != nil {
		l = m.AttributeMapping.Size()
		n += 1 + l + sovAuth(uint64(l))
	}
	return n
}

func (m *LdapAttributeMapping) Size() (n int) {
	var l int
	_ = l
	l = len(m.User)
	if l > 0 {
		n += 1 + l + sovAuth(uint64(l))
	}
	l = len(m.UserObjectClass)
	if l > 0 {
		n += 1 + l + sovAuth(uint64(l))
	}
	l = len(m.Tenant)
	if l > 0 {
		n += 1 + l + sovAuth(uint64(l))
	}
	l = len(m.Group)
	if l > 0 {
		n += 1 + l + sovAuth(uint64(l))
	}
	l = len(m.GroupObjectClass)
	if l > 0 {
		n += 1 + l + sovAuth(uint64(l))
	}
	l = len(m.Email)
	if l > 0 {
		n += 1 + l + sovAuth(uint64(l))
	}
	l = len(m.Fullname)
	if l > 0 {
		n += 1 + l + sovAuth(uint64(l))
	}
	return n
}

func (m *Local) Size() (n int) {
	var l int
	_ = l
	if m.Enabled {
		n += 2
	}
	return n
}

func (m *Radius) Size() (n int) {
	var l int
	_ = l
	if m.Enabled {
		n += 2
	}
	l = len(m.Ip)
	if l > 0 {
		n += 1 + l + sovAuth(uint64(l))
	}
	l = len(m.Port)
	if l > 0 {
		n += 1 + l + sovAuth(uint64(l))
	}
	l = len(m.NasIp)
	if l > 0 {
		n += 1 + l + sovAuth(uint64(l))
	}
	l = len(m.Secret)
	if l > 0 {
		n += 1 + l + sovAuth(uint64(l))
	}
	return n
}

func (m *TLSOptions) Size() (n int) {
	var l int
	_ = l
	if m.StartTLS {
		n += 2
	}
	if m.SkipServerCertVerification {
		n += 2
	}
	l = len(m.ServerName)
	if l > 0 {
		n += 1 + l + sovAuth(uint64(l))
	}
	l = len(m.TrustedCerts)
	if l > 0 {
		n += 1 + l + sovAuth(uint64(l))
	}
	return n
}

func (m *User) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovAuth(uint64(l))
	l = m.ObjectMeta.Size()
	n += 1 + l + sovAuth(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovAuth(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovAuth(uint64(l))
	return n
}

func (m *UserList) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovAuth(uint64(l))
	l = m.ListMeta.Size()
	n += 1 + l + sovAuth(uint64(l))
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovAuth(uint64(l))
		}
	}
	return n
}

func (m *UserSpec) Size() (n int) {
	var l int
	_ = l
	l = len(m.Fullname)
	if l > 0 {
		n += 1 + l + sovAuth(uint64(l))
	}
	l = len(m.Email)
	if l > 0 {
		n += 1 + l + sovAuth(uint64(l))
	}
	l = len(m.Password)
	if l > 0 {
		n += 1 + l + sovAuth(uint64(l))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovAuth(uint64(l))
	}
	return n
}

func (m *UserStatus) Size() (n int) {
	var l int
	_ = l
	if len(m.Roles) > 0 {
		for _, s := range m.Roles {
			l = len(s)
			n += 1 + l + sovAuth(uint64(l))
		}
	}
	if len(m.UserGroups) > 0 {
		for _, s := range m.UserGroups {
			l = len(s)
			n += 1 + l + sovAuth(uint64(l))
		}
	}
	if m.LastSuccessfulLogin != nil {
		l = m.LastSuccessfulLogin.Size()
		n += 1 + l + sovAuth(uint64(l))
	}
	return n
}

func sovAuth(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozAuth(x uint64) (n int) {
	return sovAuth(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *AuthenticationPolicy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuth
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuthenticationPolicy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuthenticationPolicy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuth(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuth
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuthenticationPolicyList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuth
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuthenticationPolicyList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuthenticationPolicyList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ListMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &AuthenticationPolicy{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuth(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuth
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuthenticationPolicySpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuth
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuthenticationPolicySpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuthenticationPolicySpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authenticators", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Authenticators.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Secret", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Secret = append(m.Secret[:0], dAtA[iNdEx:postIndex]...)
			if m.Secret == nil {
				m.Secret = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuth(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuth
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuthenticationPolicyStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuth
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuthenticationPolicyStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuthenticationPolicyStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAuth(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuth
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Authenticators) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuth
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Authenticators: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Authenticators: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ldap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ldap == nil {
				m.Ldap = &Ldap{}
			}
			if err := m.Ldap.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Local", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Local == nil {
				m.Local = &Local{}
			}
			if err := m.Local.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Radius", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Radius == nil {
				m.Radius = &Radius{}
			}
			if err := m.Radius.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthenticatorOrder", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuthenticatorOrder = append(m.AuthenticatorOrder, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuth(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuth
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AutoMsgAuthenticationPolicyWatchHelper) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuth
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AutoMsgAuthenticationPolicyWatchHelper: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AutoMsgAuthenticationPolicyWatchHelper: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Object", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Object == nil {
				m.Object = &AuthenticationPolicy{}
			}
			if err := m.Object.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuth(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuth
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AutoMsgUserWatchHelper) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuth
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AutoMsgUserWatchHelper: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AutoMsgUserWatchHelper: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Object", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Object == nil {
				m.Object = &User{}
			}
			if err := m.Object.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuth(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuth
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Ldap) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuth
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Ldap: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Ldap: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TLSOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TLSOptions == nil {
				m.TLSOptions = &TLSOptions{}
			}
			if err := m.TLSOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseDN", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BaseDN = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BindDN", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BindDN = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BindPassword", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BindPassword = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttributeMapping", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AttributeMapping == nil {
				m.AttributeMapping = &LdapAttributeMapping{}
			}
			if err := m.AttributeMapping.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuth(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuth
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LdapAttributeMapping) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuth
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LdapAttributeMapping: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LdapAttributeMapping: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.User = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserObjectClass", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserObjectClass = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tenant", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tenant = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Group", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Group = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupObjectClass", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupObjectClass = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Email", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Email = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fullname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fullname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuth(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuth
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Local) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuth
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Local: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Local: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipAuth(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuth
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Radius) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuth
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Radius: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Radius: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ip = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Port = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NasIp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NasIp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Secret", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Secret = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuth(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuth
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLSOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuth
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TLSOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TLSOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTLS", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.StartTLS = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkipServerCertVerification", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SkipServerCertVerification = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrustedCerts", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TrustedCerts = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuth(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuth
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *User) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuth
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: User: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: User: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuth(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuth
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuth
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ListMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &User{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuth(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuth
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuth
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fullname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fullname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Email", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Email = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Password", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Password = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuth(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuth
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuth
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Roles", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Roles = append(m.Roles, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserGroups", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserGroups = append(m.UserGroups, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastSuccessfulLogin", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastSuccessfulLogin == nil {
				m.LastSuccessfulLogin = &api.Timestamp{}
			}
			if err := m.LastSuccessfulLogin.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuth(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuth
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipAuth(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowAuth
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthAuth
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowAuth
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipAuth(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthAuth = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowAuth   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("auth.proto", fileDescriptorAuth) }

var fileDescriptorAuth = []byte{
	// 1863 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x58, 0x4f, 0x6f, 0x1c, 0x49,
	0x15, 0x77, 0xcf, 0xbf, 0x8c, 0xcb, 0x63, 0x67, 0x52, 0x71, 0x92, 0xe9, 0x59, 0xc7, 0x36, 0xbd,
	0x81, 0x38, 0x21, 0xed, 0x49, 0xb2, 0x61, 0x05, 0x96, 0x40, 0xf2, 0xc4, 0x26, 0x6b, 0x34, 0xb1,
	0x2d, 0x8f, 0xbd, 0xec, 0x09, 0x28, 0x77, 0x57, 0xc6, 0x4d, 0x7a, 0xba, 0x5b, 0x5d, 0xd5, 0x89,
	0x22, 0xb4, 0x42, 0x5a, 0x3b, 0x2b, 0x04, 0xe2, 0x02, 0x17, 0xc4, 0x71, 0xc5, 0x29, 0x70, 0xf2,
	0x05, 0x24, 0xbe, 0xc0, 0x72, 0x5b, 0x2d, 0xb7, 0x3d, 0x58, 0x28, 0x82, 0x8b, 0x25, 0x3e, 0x03,
	0xa8, 0x5e, 0xd5, 0xf4, 0x54, 0x8f, 0x67, 0x46, 0x8e, 0x14, 0x38, 0xcd, 0x74, 0xd5, 0xfb, 0xfd,
	0xde, 0xdf, 0x7a, 0xf5, 0xba, 0x11, 0x22, 0x09, 0x3f, 0x58, 0x8e, 0xe2, 0x90, 0x87, 0xb8, 0x20,
	0xfe, 0xd7, 0xe7, 0x3a, 0x61, 0xd8, 0xf1, 0x69, 0x83, 0x44, 0x5e, 0x83, 0x04, 0x41, 0xc8, 0x09,
	0xf7, 0xc2, 0x80, 0x49, 0x99, 0xfa, 0x7a, 0xc7, 0xe3, 0x07, 0xc9, 0xfe, 0xb2, 0x13, 0x76, 0x1b,
	0x11, 0x0d, 0x18, 0x09, 0xdc, 0xb0, 0xc1, 0x9e, 0x37, 0x9e, 0xd1, 0xc0, 0x73, 0x68, 0x23, 0xe1,
	0x9e, 0xcf, 0x04, 0xb4, 0x43, 0x03, 0x1d, 0xdd, 0xf0, 0x02, 0xc7, 0x4f, 0x5c, 0xda, 0xa3, 0xb1,
	0x35, 0x9a, 0x4e, 0xd8, 0x09, 0x1b, 0xb0, 0xbc, 0x9f, 0x3c, 0x81, 0x27, 0x78, 0x80, 0x7f, 0x4a,
	0xfc, 0xeb, 0x23, 0xb4, 0x0a, 0x1b, 0xbb, 0x94, 0x13, 0x29, 0x66, 0xfd, 0x39, 0x87, 0x66, 0x57,
	0x13, 0x7e, 0x40, 0x03, 0xee, 0x39, 0xa0, 0x78, 0x3b, 0xf4, 0x3d, 0xe7, 0x05, 0xbe, 0x8b, 0x8c,
	0xdd, 0x9a, 0xb1, 0x68, 0x2c, 0x4d, 0xdd, 0x9f, 0x5e, 0x26, 0x91, 0xb7, 0xbc, 0xfb, 0x22, 0xa2,
	0x8f, 0x29, 0x27, 0xcd, 0xcb, 0x9f, 0x9f, 0x2c, 0x4c, 0x7c, 0x71, 0xb2, 0x60, 0x9c, 0x9e, 0x2c,
	0x5c, 0xb8, 0xe3, 0x05, 0xbe, 0x17, 0xd0, 0x1d, 0x63, 0x17, 0x7f, 0x07, 0x19, 0x5b, 0xb5, 0x1c,
	0x20, 0x2e, 0x02, 0x62, 0x6b, 0xff, 0xa7, 0xd4, 0xe1, 0x80, 0xa9, 0x6b, 0x98, 0x19, 0xa1, 0xfe,
	0x4e, 0xd8, 0xf5, 0x38, 0xed, 0x46, 0xfc, 0xc5, 0x8e, 0xb1, 0x85, 0x7f, 0x80, 0x0a, 0xed, 0x88,
	0x3a, 0xb5, 0x3c, 0xa0, 0xe7, 0x97, 0x21, 0xc2, 0xc3, 0xcc, 0x12, 0x52, 0xcd, 0xab, 0x82, 0x4c,
	0x10, 0xb1, 0x88, 0x3a, 0x1a, 0x11, 0x70, 0xe0, 0x1d, 0x54, 0x6a, 0x73, 0xc2, 0x13, 0x56, 0x2b,
	0x00, 0xdb, 0xe2, 0x18, 0x36, 0x90, 0x6b, 0xd6, 0x14, 0x5f, 0x95, 0xc1, 0xb3, 0xc6, 0xa8, 0x98,
	0x56, 0xf0, 0x97, 0x2f, 0xcd, 0x19, 0x5c, 0x11, 0x44, 0x81, 0x1d, 0x01, 0xd6, 0xfa, 0x83, 0x81,
	0x6a, 0xc3, 0x48, 0x5b, 0x1e, 0xe3, 0xd8, 0x12, 0xd1, 0xcb, 0x0d, 0x8b, 0x5e, 0xb9, 0x17, 0x09,
	0x7c, 0x0b, 0x95, 0x85, 0xac, 0x58, 0x55, 0x8e, 0x4b, 0xd1, 0xde, 0x62, 0x46, 0xb4, 0xb8, 0xc1,
	0x69, 0x57, 0xb8, 0x94, 0x5f, 0x9a, 0xba, 0x5f, 0x1f, 0xed, 0xd2, 0xca, 0xcc, 0x57, 0x2f, 0x4d,
	0xe4, 0x7b, 0x8c, 0x1f, 0x50, 0x3f, 0xa2, 0xb1, 0xf5, 0xa7, 0x11, 0x66, 0x42, 0xac, 0x7e, 0x84,
	0x66, 0xb4, 0xbd, 0x30, 0x66, 0x2a, 0xe3, 0xb3, 0x67, 0x14, 0x84, 0x31, 0x6b, 0x2e, 0xaa, 0x38,
	0xd5, 0x48, 0x66, 0x5d, 0x8b, 0xd7, 0x00, 0x1b, 0xbe, 0x8b, 0x4a, 0x6d, 0xea, 0xc4, 0x94, 0x43,
	0x2c, 0x2a, 0x10, 0x69, 0x03, 0x22, 0x0d, 0xab, 0x99, 0x48, 0xc3, 0x8a, 0x35, 0x87, 0xea, 0xa3,
	0x33, 0x65, 0xfd, 0x27, 0x37, 0x68, 0x30, 0x7e, 0x1f, 0x15, 0x5a, 0x2e, 0x89, 0x94, 0xe1, 0x48,
	0x1a, 0x2e, 0x56, 0xa0, 0x4c, 0xa0, 0xde, 0x7c, 0x97, 0x44, 0x7a, 0x99, 0x88, 0x5d, 0xbc, 0x82,
	0x8a, 0xad, 0xd0, 0x21, 0xbe, 0xca, 0xd2, 0x94, 0x02, 0x8a, 0xa5, 0xe6, 0x35, 0x85, 0xbc, 0xe8,
	0x8b, 0x47, 0x0d, 0x2a, 0x21, 0xf8, 0x7b, 0xa8, 0xb4, 0x43, 0x5c, 0x2f, 0x61, 0x2a, 0x6f, 0x15,
	0x09, 0x96, 0x6b, 0x7d, 0x27, 0x63, 0x78, 0xd6, 0x9d, 0x94, 0x12, 0xf8, 0x13, 0x03, 0xe1, 0x8c,
	0x1b, 0x5b, 0xb1, 0x4b, 0xe3, 0xda, 0xe4, 0x62, 0x7e, 0x69, 0xb2, 0xb9, 0xf3, 0xea, 0x53, 0xf3,
	0x56, 0x9b, 0xc7, 0xeb, 0x41, 0xd2, 0x5d, 0xca, 0x3a, 0x9b, 0x4d, 0x88, 0x28, 0xa9, 0x5b, 0x4a,
	0xd7, 0xf5, 0x4c, 0x4a, 0xec, 0x50, 0xf0, 0x69, 0x8a, 0x87, 0x68, 0xb3, 0x1e, 0xa0, 0x4b, 0x67,
	0xe8, 0xf0, 0x24, 0x2a, 0xb6, 0xb6, 0x1e, 0xae, 0xb6, 0xaa, 0x13, 0xb8, 0x8c, 0x0a, 0xad, 0xb5,
	0xd5, 0xed, 0xaa, 0x81, 0x11, 0x2a, 0xed, 0xac, 0xae, 0x6d, 0xec, 0xb5, 0xab, 0x39, 0x8b, 0xa1,
	0x6f, 0xac, 0x26, 0x3c, 0x7c, 0xcc, 0x3a, 0xc3, 0xd2, 0xf4, 0x43, 0xc2, 0x9d, 0x83, 0x0f, 0xa0,
	0xf0, 0x70, 0x05, 0x15, 0x04, 0x25, 0x24, 0x66, 0x12, 0xdf, 0x46, 0x25, 0xd9, 0x0e, 0x54, 0xbc,
	0xc7, 0x95, 0xf0, 0xc5, 0xaf, 0x5e, 0x9a, 0x53, 0xcf, 0x05, 0x95, 0xaa, 0xe1, 0x36, 0xba, 0xaa,
	0x94, 0xee, 0x31, 0x1a, 0x8f, 0x56, 0x52, 0x1f, 0x50, 0xa2, 0xaa, 0x41, 0x80, 0xce, 0x92, 0xfe,
	0x2d, 0x2f, 0x2b, 0x07, 0x37, 0xd0, 0x85, 0xf5, 0x80, 0xec, 0xfb, 0xd4, 0x05, 0x9a, 0x72, 0xf3,
	0xca, 0xe9, 0xc9, 0xc2, 0x25, 0x2a, 0x97, 0xb4, 0x20, 0xf6, 0xa4, 0xf0, 0x4d, 0x94, 0xdf, 0x8b,
	0x65, 0xe1, 0x4c, 0x36, 0xaf, 0xa8, 0x0c, 0x4c, 0x27, 0xb1, 0x5e, 0x29, 0x42, 0x02, 0x6f, 0x21,
	0xb4, 0xdb, 0x6a, 0x6f, 0x45, 0xd0, 0xcf, 0x55, 0xad, 0x54, 0xa5, 0x4d, 0xfd, 0xf5, 0xe6, 0x75,
	0xc5, 0x70, 0x85, 0xfb, 0xcc, 0x0e, 0xe5, 0xa2, 0xc6, 0xa4, 0x51, 0xe0, 0x7b, 0xa8, 0xd4, 0x24,
	0x8c, 0xae, 0x6d, 0x42, 0x6f, 0x9b, 0x6c, 0x9a, 0x0a, 0x7a, 0x69, 0x9f, 0x30, 0x6a, 0xbb, 0x81,
	0x5e, 0x6b, 0x52, 0x10, 0x20, 0x5e, 0xe0, 0xae, 0x6d, 0xd6, 0x8a, 0x03, 0x10, 0x2f, 0x70, 0x07,
	0x21, 0x20, 0x88, 0x1f, 0xa2, 0x8a, 0xf8, 0xb7, 0x4d, 0x18, 0x7b, 0x1e, 0xc6, 0x6e, 0xad, 0x04,
	0xc0, 0x05, 0x05, 0xbc, 0x06, 0xc0, 0x48, 0x6d, 0x6a, 0xf0, 0x0c, 0x08, 0x3f, 0x45, 0xd5, 0x55,
	0xce, 0x63, 0x6f, 0x3f, 0xe1, 0xf4, 0x31, 0x89, 0x22, 0x2f, 0xe8, 0xd4, 0x2e, 0xe8, 0xa9, 0x17,
	0xb1, 0x1f, 0x94, 0x68, 0xbe, 0xab, 0x94, 0xbc, 0x43, 0x7a, 0x3b, 0x76, 0x57, 0x6e, 0x69, 0x8a,
	0xce, 0x10, 0x5b, 0x7f, 0xcc, 0xa3, 0xd9, 0x61, 0x7c, 0xf8, 0x36, 0x2a, 0x88, 0xec, 0xcb, 0xfa,
	0xe8, 0x77, 0x84, 0x84, 0x65, 0x8e, 0x07, 0xc8, 0xe0, 0xc7, 0xe8, 0xa2, 0xf8, 0x95, 0x15, 0xf4,
	0xd0, 0x27, 0x8c, 0xa9, 0x14, 0xa7, 0x46, 0x09, 0x98, 0x1d, 0xc2, 0xbe, 0xed, 0x08, 0x01, 0x8d,
	0x63, 0x10, 0x2b, 0x7a, 0xdf, 0x2e, 0x0d, 0x48, 0xc0, 0x21, 0xf1, 0x93, 0xfd, 0xb6, 0xc0, 0x61,
	0x55, 0x8f, 0xbb, 0x94, 0xc3, 0x36, 0x2a, 0x3e, 0x8a, 0xc3, 0x24, 0x52, 0xc9, 0x4d, 0xbb, 0x50,
	0x47, 0x2c, 0xea, 0x5d, 0x08, 0xa4, 0xf0, 0x36, 0xaa, 0xc2, 0x1f, 0xdd, 0x60, 0x99, 0xe3, 0x1b,
	0x0a, 0x39, 0x07, 0xc8, 0x51, 0x16, 0x9f, 0x41, 0x0b, 0x03, 0xd6, 0xbb, 0xc4, 0xf3, 0x55, 0xc6,
	0x53, 0x03, 0xa8, 0x58, 0xd4, 0x0d, 0x00, 0x29, 0xfc, 0x3e, 0x2a, 0x7f, 0x3f, 0xf1, 0xfd, 0x80,
	0x74, 0x29, 0xa4, 0x76, 0x12, 0xae, 0x79, 0x81, 0xc0, 0x4f, 0xd4, 0xba, 0x06, 0x4a, 0x65, 0xad,
	0x6f, 0xab, 0xd6, 0xfb, 0xc6, 0x27, 0xcf, 0xfa, 0xb7, 0xd1, 0xeb, 0xbc, 0x6f, 0x7e, 0x6a, 0x6f,
	0xa0, 0xdc, 0x46, 0xa4, 0x32, 0x3a, 0xab, 0xec, 0xac, 0x78, 0x7a, 0x5c, 0x73, 0x1b, 0x91, 0x28,
	0x98, 0xed, 0x30, 0xee, 0xe5, 0x2c, 0x2d, 0x98, 0x28, 0x8c, 0xf5, 0x8c, 0x81, 0x0c, 0x5e, 0x46,
	0xc5, 0x4d, 0xc2, 0x36, 0x7a, 0xf9, 0x4a, 0x13, 0x1c, 0x10, 0x66, 0x67, 0x88, 0xa5, 0x98, 0x76,
	0x1b, 0x16, 0xb3, 0x80, 0x91, 0xb7, 0xe1, 0x71, 0x4e, 0xef, 0x20, 0xf8, 0x3d, 0x54, 0x6e, 0x73,
	0x12, 0xf3, 0xdd, 0x56, 0x5b, 0x39, 0x7d, 0xed, 0xf4, 0x64, 0xe1, 0x32, 0x13, 0x6b, 0x36, 0xf7,
	0xf5, 0xe4, 0xa6, 0x82, 0xf8, 0x29, 0xaa, 0xb7, 0x9f, 0x7a, 0x51, 0x9b, 0xc6, 0xcf, 0x68, 0xfc,
	0x90, 0xc6, 0xfc, 0x43, 0x1a, 0x7b, 0x4f, 0x54, 0xc7, 0x85, 0x78, 0x94, 0x9b, 0xdf, 0x3c, 0x3d,
	0x59, 0xb8, 0xc9, 0x9e, 0x7a, 0x91, 0xcd, 0x40, 0xcc, 0x76, 0x68, 0xcc, 0xed, 0x67, 0x9a, 0xa0,
	0x46, 0x3d, 0x86, 0x0e, 0x7f, 0x17, 0x21, 0xb9, 0xb3, 0x29, 0x8a, 0x42, 0x06, 0x31, 0xed, 0x6f,
	0x8a, 0x7b, 0xa0, 0x2e, 0x34, 0x80, 0xe8, 0x3c, 0xbb, 0x71, 0xc2, 0x38, 0x75, 0x05, 0x33, 0x53,
	0x81, 0x4d, 0x3b, 0x0f, 0x97, 0x7b, 0x60, 0x9d, 0xee, 0x6c, 0x06, 0x64, 0xfd, 0x3a, 0x27, 0x0f,
	0xfd, 0xff, 0x77, 0x84, 0x5d, 0xc9, 0x8c, 0xb0, 0x33, 0xfd, 0x9b, 0xe7, 0x1c, 0x23, 0x6b, 0x73,
	0x60, 0x64, 0xad, 0x6a, 0xe8, 0xf3, 0x8e, 0xa8, 0xb5, 0x2f, 0x5f, 0x9a, 0xb3, 0x68, 0xaa, 0xf1,
	0xb3, 0xad, 0x65, 0xd9, 0x4e, 0x3e, 0xc6, 0x45, 0xd1, 0xaf, 0x98, 0x75, 0x64, 0xa0, 0xb2, 0xa0,
	0xfa, 0x5f, 0x0c, 0xa6, 0x66, 0x76, 0x30, 0xd5, 0x2f, 0xdc, 0xc1, 0x41, 0xf4, 0x77, 0x39, 0x69,
	0x06, 0x78, 0xac, 0xb7, 0x0e, 0xe3, 0xfc, 0xad, 0xa3, 0xdf, 0xa1, 0x72, 0xe7, 0xed, 0x50, 0xe9,
	0x2d, 0x96, 0xcf, 0xaa, 0x19, 0x72, 0x81, 0xa5, 0xb2, 0xf8, 0x03, 0x35, 0x56, 0xc8, 0xfa, 0x7b,
	0xf0, 0xea, 0x53, 0xb3, 0xde, 0x9b, 0xc8, 0x7a, 0x2e, 0x80, 0x93, 0xfa, 0x08, 0x36, 0xc3, 0x5f,
	0x44, 0xba, 0xd1, 0xc0, 0x60, 0xbd, 0x2b, 0x9d, 0x1e, 0x1c, 0xae, 0x2a, 0xa8, 0xbc, 0xfe, 0xd1,
	0xee, 0xfa, 0xce, 0xe6, 0x6a, 0xab, 0x6a, 0x58, 0xff, 0x32, 0x10, 0xea, 0x27, 0x5b, 0x38, 0xb9,
	0x13, 0xfa, 0x54, 0x0c, 0xe3, 0x79, 0xdd, 0xc9, 0x58, 0x2c, 0xea, 0x4e, 0x82, 0x94, 0x38, 0x73,
	0x02, 0x0c, 0xdd, 0x5c, 0x5c, 0x59, 0x79, 0xfd, 0xcc, 0xc1, 0x95, 0x05, 0xd7, 0x40, 0x66, 0xa6,
	0xe8, 0x03, 0xb0, 0x87, 0x2e, 0xb7, 0x08, 0xe3, 0xed, 0xc4, 0x71, 0x28, 0x63, 0x4f, 0x12, 0xbf,
	0x15, 0x76, 0xbc, 0xa0, 0x5f, 0xc7, 0xa2, 0x46, 0xbc, 0x2e, 0x65, 0x9c, 0x74, 0xa3, 0xe6, 0x4d,
	0xc5, 0xbb, 0xe0, 0x13, 0xc6, 0x6d, 0x96, 0x62, 0x6c, 0x5f, 0x80, 0x34, 0x0d, 0xc3, 0x38, 0xef,
	0xff, 0x75, 0x0a, 0x95, 0xc4, 0xc4, 0xf7, 0xe1, 0x3d, 0xfc, 0x73, 0xf4, 0x8e, 0x18, 0xe9, 0x56,
	0x5d, 0x77, 0xe8, 0xdb, 0xe7, 0x98, 0xf1, 0xb0, 0x3e, 0x66, 0xcf, 0x5a, 0x3a, 0x3e, 0x32, 0x4b,
	0x4e, 0x4c, 0x09, 0xa7, 0x7f, 0x39, 0x32, 0x8d, 0x4f, 0xfe, 0xfe, 0xcf, 0xdf, 0xe6, 0x66, 0xd1,
	0xc4, 0x8a, 0x71, 0xdb, 0x9a, 0x6e, 0xe8, 0xaf, 0x6f, 0xb8, 0x8d, 0xa6, 0x94, 0x01, 0xd0, 0x2b,
	0xb4, 0xca, 0xad, 0x6b, 0xff, 0xad, 0x3b, 0x43, 0x08, 0x6b, 0x92, 0xf0, 0x92, 0x76, 0xd6, 0x1a,
	0x70, 0xd4, 0xf0, 0x2f, 0x0d, 0x34, 0x2f, 0x58, 0xd7, 0xa8, 0x4f, 0x39, 0x7d, 0xab, 0x9e, 0xdd,
	0x15, 0x86, 0xb8, 0xc0, 0x9b, 0x1a, 0x32, 0x87, 0x26, 0x56, 0x26, 0x6e, 0x5f, 0xcd, 0x38, 0x26,
	0x8c, 0x12, 0xbd, 0xf4, 0x63, 0xf5, 0x72, 0xa7, 0x6c, 0x19, 0xeb, 0xe4, 0x83, 0x21, 0xdc, 0x8b,
	0xc0, 0x5d, 0x3f, 0xe3, 0x63, 0x9f, 0xff, 0xc8, 0x90, 0x39, 0x7c, 0x44, 0xf9, 0x5b, 0xf5, 0xd4,
	0x3e, 0x3e, 0x32, 0xf3, 0x1d, 0xca, 0xb3, 0x6e, 0xe2, 0x51, 0x6e, 0x7e, 0x24, 0x13, 0xf9, 0x88,
	0xf2, 0xb1, 0x3e, 0xde, 0x1b, 0x64, 0x05, 0x07, 0xf1, 0x38, 0x07, 0x1d, 0x34, 0x27, 0x98, 0x45,
	0xdb, 0x1b, 0xea, 0xe0, 0x95, 0xb4, 0x2b, 0xc2, 0x2b, 0x89, 0xba, 0xa5, 0xeb, 0x63, 0x3e, 0x5f,
	0x08, 0x59, 0xab, 0x72, 0x7c, 0x64, 0x16, 0x44, 0x63, 0x14, 0xa6, 0xe0, 0x9f, 0xa0, 0x4a, 0x4f,
	0x09, 0xd8, 0x3f, 0x82, 0x54, 0xbb, 0x50, 0x80, 0xe4, 0x96, 0x4e, 0x02, 0xfe, 0x5c, 0x03, 0x7f,
	0x86, 0x14, 0xe5, 0xaf, 0x54, 0x51, 0xee, 0x45, 0x2e, 0x79, 0xcb, 0x45, 0x29, 0x82, 0x5a, 0x4a,
	0x80, 0x37, 0xb5, 0xe3, 0x3a, 0x9c, 0x8e, 0xfa, 0xa8, 0x74, 0xfd, 0x58, 0x56, 0xa5, 0x34, 0x66,
	0x6c, 0xc6, 0xbe, 0x35, 0x84, 0xfc, 0x6b, 0x92, 0x7c, 0x5c, 0xd6, 0x12, 0x74, 0x5d, 0x28, 0x80,
	0xe8, 0xbd, 0x49, 0xda, 0xee, 0xa4, 0x7e, 0x9e, 0xe3, 0xed, 0xd6, 0x9a, 0x3e, 0x3e, 0x32, 0x8b,
	0xf0, 0x3a, 0x29, 0x6c, 0xbb, 0x6b, 0xe0, 0x3d, 0x34, 0x9d, 0xaa, 0x1d, 0x97, 0xc8, 0xb9, 0x8c,
	0x9a, 0x81, 0xf7, 0xd9, 0x33, 0xb4, 0xf5, 0x5f, 0x18, 0xbf, 0x39, 0x34, 0x73, 0xcf, 0xee, 0xfd,
	0xfe, 0xd0, 0x84, 0x6f, 0x8d, 0x9f, 0x1d, 0x9a, 0x30, 0xdc, 0x7c, 0x76, 0x68, 0x0e, 0xfd, 0x6e,
	0xf7, 0xea, 0xd0, 0xbc, 0xa1, 0xc6, 0x1f, 0x51, 0xed, 0x38, 0x1f, 0x25, 0x1c, 0xab, 0xb3, 0x8d,
	0x0b, 0x51, 0xc8, 0x38, 0x86, 0xb2, 0x79, 0x75, 0x68, 0x2e, 0x8f, 0xf8, 0xf2, 0x07, 0xb8, 0x1e,
	0x04, 0xf0, 0x80, 0x6b, 0x56, 0x3e, 0x7f, 0x3d, 0x6f, 0x7c, 0xf1, 0x7a, 0xde, 0xf8, 0xc7, 0xeb,
	0x79, 0x63, 0xdb, 0xd8, 0x2f, 0xc1, 0x17, 0xc4, 0xf7, 0xfe, 0x1b, 0x00, 0x00, 0xff, 0xff, 0xad,
	0xe9, 0x35, 0x08, 0x10, 0x15, 0x00, 0x00,
}
