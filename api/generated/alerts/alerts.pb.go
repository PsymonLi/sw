// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: alerts.proto

/*
	Package alerts is a generated protocol buffer package.

	Service name

	It is generated from these files:
		alerts.proto

	It has these top-level messages:
		Alert
		AlertDestination
		AlertDestinationList
		AlertDestinationSpec
		AlertDestinationStatus
		AlertPolicy
		AlertPolicyList
		AlertPolicySpec
		AlertPolicyStatus
		AlertReason
		AlertSource
		AlertSpec
		AlertStatus
		AuditInfo
		AutoMsgAlertDestinationWatchHelper
		AutoMsgAlertPolicyWatchHelper
		MatchedRequirement
		Requirement
*/
package alerts

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/pensando/grpc-gateway/third_party/googleapis/google/api"
import _ "github.com/pensando/sw/venice/utils/apigen/annotations"
import _ "github.com/gogo/protobuf/gogoproto"
import api "github.com/pensando/sw/api"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// Severity of an alert
type AlertSeverity int32

const (
	AlertSeverity_WARNING  AlertSeverity = 0
	AlertSeverity_CRITICAL AlertSeverity = 1
)

var AlertSeverity_name = map[int32]string{
	0: "WARNING",
	1: "CRITICAL",
}
var AlertSeverity_value = map[string]int32{
	"WARNING":  0,
	"CRITICAL": 1,
}

func (x AlertSeverity) String() string {
	return proto.EnumName(AlertSeverity_name, int32(x))
}
func (AlertSeverity) EnumDescriptor() ([]byte, []int) { return fileDescriptorAlerts, []int{0} }

type AlertSpec_AlertState int32

const (
	AlertSpec_OPEN         AlertSpec_AlertState = 0
	AlertSpec_RESOLVED     AlertSpec_AlertState = 1
	AlertSpec_ACKNOWLEDGED AlertSpec_AlertState = 2
)

var AlertSpec_AlertState_name = map[int32]string{
	0: "OPEN",
	1: "RESOLVED",
	2: "ACKNOWLEDGED",
}
var AlertSpec_AlertState_value = map[string]int32{
	"OPEN":         0,
	"RESOLVED":     1,
	"ACKNOWLEDGED": 2,
}

func (x AlertSpec_AlertState) String() string {
	return proto.EnumName(AlertSpec_AlertState_name, int32(x))
}
func (AlertSpec_AlertState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorAlerts, []int{11, 0}
}

type Requirement_AllowedOperators int32

const (
	Requirement_Equals    Requirement_AllowedOperators = 0
	Requirement_In        Requirement_AllowedOperators = 1
	Requirement_NotEquals Requirement_AllowedOperators = 2
	Requirement_NotIn     Requirement_AllowedOperators = 3
	Requirement_Gt        Requirement_AllowedOperators = 4
	Requirement_Lt        Requirement_AllowedOperators = 5
)

var Requirement_AllowedOperators_name = map[int32]string{
	0: "Equals",
	1: "In",
	2: "NotEquals",
	3: "NotIn",
	4: "Gt",
	5: "Lt",
}
var Requirement_AllowedOperators_value = map[string]int32{
	"Equals":    0,
	"In":        1,
	"NotEquals": 2,
	"NotIn":     3,
	"Gt":        4,
	"Lt":        5,
}

func (x Requirement_AllowedOperators) String() string {
	return proto.EnumName(Requirement_AllowedOperators_name, int32(x))
}
func (Requirement_AllowedOperators) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorAlerts, []int{17, 0}
}

// Source of an alert; for alerts generated from events, it maps to event.Source
type Alert struct {
	api.TypeMeta   `protobuf:"bytes,1,opt,name=T,embedded=T" json:",inline"`
	api.ObjectMeta `protobuf:"bytes,2,opt,name=O,embedded=O" json:"meta, omitempty"`
	Spec           AlertSpec   `protobuf:"bytes,3,opt,name=Spec" json:"spec, omitempty"`
	Status         AlertStatus `protobuf:"bytes,4,opt,name=Status" json:"status, omitempty"`
}

func (m *Alert) Reset()                    { *m = Alert{} }
func (m *Alert) String() string            { return proto.CompactTextString(m) }
func (*Alert) ProtoMessage()               {}
func (*Alert) Descriptor() ([]byte, []int) { return fileDescriptorAlerts, []int{0} }

func (m *Alert) GetSpec() AlertSpec {
	if m != nil {
		return m.Spec
	}
	return AlertSpec{}
}

func (m *Alert) GetStatus() AlertStatus {
	if m != nil {
		return m.Status
	}
	return AlertStatus{}
}

// One of the requirement from the expression that was met
type AlertDestination struct {
	// Requirement from the alert rule that was met
	api.TypeMeta `protobuf:"bytes,1,opt,name=T,embedded=T" json:",inline"`
	// The value at which the requirement was met.
	// same as Requirement.value for operator `Equals` but could vary for other operators
	// e.g. requirement - CPU;Gt;90 could have a matching value 96
	api.ObjectMeta `protobuf:"bytes,2,opt,name=O,embedded=O" json:"meta, omitempty"`
	Spec           AlertDestinationSpec   `protobuf:"bytes,3,opt,name=Spec" json:"spec, omitempty"`
	Status         AlertDestinationStatus `protobuf:"bytes,4,opt,name=Status" json:"status, omitempty"`
}

func (m *AlertDestination) Reset()                    { *m = AlertDestination{} }
func (m *AlertDestination) String() string            { return proto.CompactTextString(m) }
func (*AlertDestination) ProtoMessage()               {}
func (*AlertDestination) Descriptor() ([]byte, []int) { return fileDescriptorAlerts, []int{1} }

func (m *AlertDestination) GetSpec() AlertDestinationSpec {
	if m != nil {
		return m.Spec
	}
	return AlertDestinationSpec{}
}

func (m *AlertDestination) GetStatus() AlertDestinationStatus {
	if m != nil {
		return m.Status
	}
	return AlertDestinationStatus{}
}

// AlertReason captures all the requirements with matched value from the alert policy rule
// at the time of creating an alert.
// e.g. "matched-requirements": [{"field": "cpu", "operator": "Gt", "values": [90], "observed-value": 95}]
type AlertDestinationList struct {
	// List of requirements from the alert policy with it's matched value
	api.TypeMeta `protobuf:"bytes,2,opt,name=T,embedded=T" json:"T"`
	// Alert Policy ID that matched
	api.ListMeta `protobuf:"bytes,3,opt,name=ListMeta,embedded=ListMeta" json:"ListMeta"`
	Items        []*AlertDestination `protobuf:"bytes,4,rep,name=Items" json:"Items,omitempty"`
}

func (m *AlertDestinationList) Reset()                    { *m = AlertDestinationList{} }
func (m *AlertDestinationList) String() string            { return proto.CompactTextString(m) }
func (*AlertDestinationList) ProtoMessage()               {}
func (*AlertDestinationList) Descriptor() ([]byte, []int) { return fileDescriptorAlerts, []int{2} }

func (m *AlertDestinationList) GetItems() []*AlertDestination {
	if m != nil {
		return m.Items
	}
	return nil
}

// AuditInfo captures the user performed the action and the time at which the
// action was performed.
type AlertDestinationSpec struct {
	// Name of the user performed some action.
	Default bool `protobuf:"varint,1,opt,name=default,proto3" json:"default, omitempty"`
	// Time at which the action was performed.
	EmailList []string `protobuf:"bytes,2,rep,name=EmailList" json:"email-list, omitempty"`
}

func (m *AlertDestinationSpec) Reset()                    { *m = AlertDestinationSpec{} }
func (m *AlertDestinationSpec) String() string            { return proto.CompactTextString(m) }
func (*AlertDestinationSpec) ProtoMessage()               {}
func (*AlertDestinationSpec) Descriptor() ([]byte, []int) { return fileDescriptorAlerts, []int{3} }

func (m *AlertDestinationSpec) GetDefault() bool {
	if m != nil {
		return m.Default
	}
	return false
}

func (m *AlertDestinationSpec) GetEmailList() []string {
	if m != nil {
		return m.EmailList
	}
	return nil
}

// User can change the state of the alert by changing the spec
type AlertDestinationStatus struct {
	TotalNotificationsSent int32 `protobuf:"varint,1,opt,name=totalNotificationsSent,proto3" json:"total-notifications-sent, omitempty"`
}

func (m *AlertDestinationStatus) Reset()                    { *m = AlertDestinationStatus{} }
func (m *AlertDestinationStatus) String() string            { return proto.CompactTextString(m) }
func (*AlertDestinationStatus) ProtoMessage()               {}
func (*AlertDestinationStatus) Descriptor() ([]byte, []int) { return fileDescriptorAlerts, []int{4} }

func (m *AlertDestinationStatus) GetTotalNotificationsSent() int32 {
	if m != nil {
		return m.TotalNotificationsSent
	}
	return 0
}

// Status part of the alert object
type AlertPolicy struct {
	// Severity of an alert
	api.TypeMeta `protobuf:"bytes,1,opt,name=T,embedded=T" json:",inline"`
	// Alert source or origin
	api.ObjectMeta `protobuf:"bytes,2,opt,name=O,embedded=O" json:"meta, omitempty"`
	// Affected object
	Spec AlertPolicySpec `protobuf:"bytes,3,opt,name=Spec" json:"spec, omitempty"`
	// Message from the alert rule that triggered the alert
	Status AlertPolicyStatus `protobuf:"bytes,4,opt,name=Status" json:"status, omitempty"`
}

func (m *AlertPolicy) Reset()                    { *m = AlertPolicy{} }
func (m *AlertPolicy) String() string            { return proto.CompactTextString(m) }
func (*AlertPolicy) ProtoMessage()               {}
func (*AlertPolicy) Descriptor() ([]byte, []int) { return fileDescriptorAlerts, []int{5} }

func (m *AlertPolicy) GetSpec() AlertPolicySpec {
	if m != nil {
		return m.Spec
	}
	return AlertPolicySpec{}
}

func (m *AlertPolicy) GetStatus() AlertPolicyStatus {
	if m != nil {
		return m.Status
	}
	return AlertPolicyStatus{}
}

// Alert defines an alert object
type AlertPolicyList struct {
	api.TypeMeta `protobuf:"bytes,2,opt,name=T,embedded=T" json:"T"`
	api.ListMeta `protobuf:"bytes,3,opt,name=ListMeta,embedded=ListMeta" json:"ListMeta"`
	Items        []*AlertPolicy `protobuf:"bytes,4,rep,name=Items" json:"Items,omitempty"`
}

func (m *AlertPolicyList) Reset()                    { *m = AlertPolicyList{} }
func (m *AlertPolicyList) String() string            { return proto.CompactTextString(m) }
func (*AlertPolicyList) ProtoMessage()               {}
func (*AlertPolicyList) Descriptor() ([]byte, []int) { return fileDescriptorAlerts, []int{6} }

func (m *AlertPolicyList) GetItems() []*AlertPolicy {
	if m != nil {
		return m.Items
	}
	return nil
}

// Requirement specifies each
// {"field": "Status.Phase", "operator":"Equals", "values":["JOINED"]}
type AlertPolicySpec struct {
	// name of the field or metric
	Resource string `protobuf:"bytes,1,opt,name=Resource,proto3" json:"resource, omitempty"`
	Severity string `protobuf:"bytes,2,opt,name=Severity,proto3" json:"severity, omitempty"`
	// Values contains one or more values corresponding to the field-or-metric. "Equals",
	// "NotEquals", "Gt" and "Lt" operators need a single value. "In" and "NotIn" operators
	// can have one or more values.
	Message             string        `protobuf:"bytes,3,opt,name=Message,proto3" json:"message, omitempty"`
	Requirements        []Requirement `protobuf:"bytes,4,rep,name=Requirements" json:"requirements, omitempty"`
	PersistenceDuration string        `protobuf:"bytes,5,opt,name=PersistenceDuration,proto3" json:"persistence-duration, omitempty"`
	ClearDuration       string        `protobuf:"bytes,6,opt,name=ClearDuration,proto3" json:"clear-duration, omitempty"`
	Enable              bool          `protobuf:"varint,7,opt,name=Enable,proto3" json:"enable, omitempty"`
	AutoResolve         bool          `protobuf:"varint,8,opt,name=AutoResolve,proto3" json:"auto-resolve, omitempty"`
	Destinations        []string      `protobuf:"bytes,9,rep,name=Destinations" json:"destinations, omitempty"`
}

func (m *AlertPolicySpec) Reset()                    { *m = AlertPolicySpec{} }
func (m *AlertPolicySpec) String() string            { return proto.CompactTextString(m) }
func (*AlertPolicySpec) ProtoMessage()               {}
func (*AlertPolicySpec) Descriptor() ([]byte, []int) { return fileDescriptorAlerts, []int{7} }

func (m *AlertPolicySpec) GetResource() string {
	if m != nil {
		return m.Resource
	}
	return ""
}

func (m *AlertPolicySpec) GetSeverity() string {
	if m != nil {
		return m.Severity
	}
	return ""
}

func (m *AlertPolicySpec) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *AlertPolicySpec) GetRequirements() []Requirement {
	if m != nil {
		return m.Requirements
	}
	return nil
}

func (m *AlertPolicySpec) GetPersistenceDuration() string {
	if m != nil {
		return m.PersistenceDuration
	}
	return ""
}

func (m *AlertPolicySpec) GetClearDuration() string {
	if m != nil {
		return m.ClearDuration
	}
	return ""
}

func (m *AlertPolicySpec) GetEnable() bool {
	if m != nil {
		return m.Enable
	}
	return false
}

func (m *AlertPolicySpec) GetAutoResolve() bool {
	if m != nil {
		return m.AutoResolve
	}
	return false
}

func (m *AlertPolicySpec) GetDestinations() []string {
	if m != nil {
		return m.Destinations
	}
	return nil
}

type AlertPolicyStatus struct {
	// Resource type - target resource to run this policy.
	// e.g. Network, Endpoint - object based alert policy
	//      Event - event based alert policy
	//      EndpointMetrics - metric based alert policy
	// based on the resource type, the policy gets interpreted.
	TotalHits int32 `protobuf:"varint,1,opt,name=TotalHits,proto3" json:"total-hits, omitempty"`
	// Severity to be set for an alert that gets triggered from this rule
	OpenAlerts int32 `protobuf:"varint,2,opt,name=OpenAlerts,proto3" json:"open-alerts, omitempty"`
	// Message to be used while generating the alert
	// XXX: Event based alerts should not carry a message. It will be derived from the event.
	AcknowledgedAlerts int32 `protobuf:"varint,3,opt,name=AcknowledgedAlerts,proto3" json:"acknowledged-alerts, omitempty"`
}

func (m *AlertPolicyStatus) Reset()                    { *m = AlertPolicyStatus{} }
func (m *AlertPolicyStatus) String() string            { return proto.CompactTextString(m) }
func (*AlertPolicyStatus) ProtoMessage()               {}
func (*AlertPolicyStatus) Descriptor() ([]byte, []int) { return fileDescriptorAlerts, []int{8} }

func (m *AlertPolicyStatus) GetTotalHits() int32 {
	if m != nil {
		return m.TotalHits
	}
	return 0
}

func (m *AlertPolicyStatus) GetOpenAlerts() int32 {
	if m != nil {
		return m.OpenAlerts
	}
	return 0
}

func (m *AlertPolicyStatus) GetAcknowledgedAlerts() int32 {
	if m != nil {
		return m.AcknowledgedAlerts
	}
	return 0
}

type AlertReason struct {
	// Total hits on this policy
	MatchedRequirements []*MatchedRequirement `protobuf:"bytes,1,rep,name=MatchedRequirements" json:"matched-requirements, omitempty"`
	// Open alerts based on this policy
	PolicyID string `protobuf:"bytes,2,opt,name=PolicyID,proto3" json:"alert-policy-id, omitempty"`
}

func (m *AlertReason) Reset()                    { *m = AlertReason{} }
func (m *AlertReason) String() string            { return proto.CompactTextString(m) }
func (*AlertReason) ProtoMessage()               {}
func (*AlertReason) Descriptor() ([]byte, []int) { return fileDescriptorAlerts, []int{9} }

func (m *AlertReason) GetMatchedRequirements() []*MatchedRequirement {
	if m != nil {
		return m.MatchedRequirements
	}
	return nil
}

func (m *AlertReason) GetPolicyID() string {
	if m != nil {
		return m.PolicyID
	}
	return ""
}

// AlertPolicy - tenant scoped
type AlertSource struct {
	Component string `protobuf:"bytes,1,opt,name=Component,proto3" json:"component, omitempty"`
	NodeName  string `protobuf:"bytes,2,opt,name=NodeName,proto3" json:"node-name, omitempty"`
}

func (m *AlertSource) Reset()                    { *m = AlertSource{} }
func (m *AlertSource) String() string            { return proto.CompactTextString(m) }
func (*AlertSource) ProtoMessage()               {}
func (*AlertSource) Descriptor() ([]byte, []int) { return fileDescriptorAlerts, []int{10} }

func (m *AlertSource) GetComponent() string {
	if m != nil {
		return m.Component
	}
	return ""
}

func (m *AlertSource) GetNodeName() string {
	if m != nil {
		return m.NodeName
	}
	return ""
}

type AlertSpec struct {
	// If set, this will be the default notification option for the alert policies unless otherwise
	// something else is mentioned.
	State string `protobuf:"bytes,1,opt,name=State,proto3" json:"state, omitempty"`
}

func (m *AlertSpec) Reset()                    { *m = AlertSpec{} }
func (m *AlertSpec) String() string            { return proto.CompactTextString(m) }
func (*AlertSpec) ProtoMessage()               {}
func (*AlertSpec) Descriptor() ([]byte, []int) { return fileDescriptorAlerts, []int{11} }

func (m *AlertSpec) GetState() string {
	if m != nil {
		return m.State
	}
	return ""
}

type AlertStatus struct {
	// total number of notifications sent using this notification mechanism
	Severity     string        `protobuf:"bytes,1,opt,name=Severity,proto3" json:"severity, omitempty"`
	Source       *AlertSource  `protobuf:"bytes,2,opt,name=Source" json:"source, omitempty"`
	ObjectRef    api.ObjectRef `protobuf:"bytes,3,opt,name=ObjectRef" json:"object-ref, omitempty"`
	Message      string        `protobuf:"bytes,4,opt,name=Message,proto3" json:"message, omitempty"`
	Reason       AlertReason   `protobuf:"bytes,5,opt,name=Reason" json:"reason, omitempty"`
	Acknowledged *AuditInfo    `protobuf:"bytes,6,opt,name=Acknowledged" json:"acknowledged, omitempty"`
	Resolved     *AuditInfo    `protobuf:"bytes,7,opt,name=Resolved" json:"resolved, omitempty"`
}

func (m *AlertStatus) Reset()                    { *m = AlertStatus{} }
func (m *AlertStatus) String() string            { return proto.CompactTextString(m) }
func (*AlertStatus) ProtoMessage()               {}
func (*AlertStatus) Descriptor() ([]byte, []int) { return fileDescriptorAlerts, []int{12} }

func (m *AlertStatus) GetSeverity() string {
	if m != nil {
		return m.Severity
	}
	return ""
}

func (m *AlertStatus) GetSource() *AlertSource {
	if m != nil {
		return m.Source
	}
	return nil
}

func (m *AlertStatus) GetObjectRef() api.ObjectRef {
	if m != nil {
		return m.ObjectRef
	}
	return api.ObjectRef{}
}

func (m *AlertStatus) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *AlertStatus) GetReason() AlertReason {
	if m != nil {
		return m.Reason
	}
	return AlertReason{}
}

func (m *AlertStatus) GetAcknowledged() *AuditInfo {
	if m != nil {
		return m.Acknowledged
	}
	return nil
}

func (m *AlertStatus) GetResolved() *AuditInfo {
	if m != nil {
		return m.Resolved
	}
	return nil
}

// AlertDestination - tenant scoped
type AuditInfo struct {
	User string         `protobuf:"bytes,1,opt,name=User,proto3" json:"user, omitempty"`
	Time *api.Timestamp `protobuf:"bytes,2,opt,name=Time" json:"time, omitempty"`
}

func (m *AuditInfo) Reset()                    { *m = AuditInfo{} }
func (m *AuditInfo) String() string            { return proto.CompactTextString(m) }
func (*AuditInfo) ProtoMessage()               {}
func (*AuditInfo) Descriptor() ([]byte, []int) { return fileDescriptorAlerts, []int{13} }

func (m *AuditInfo) GetUser() string {
	if m != nil {
		return m.User
	}
	return ""
}

func (m *AuditInfo) GetTime() *api.Timestamp {
	if m != nil {
		return m.Time
	}
	return nil
}

type AutoMsgAlertDestinationWatchHelper struct {
	Type   string            `protobuf:"bytes,1,opt,name=Type,proto3" json:"Type,omitempty"`
	Object *AlertDestination `protobuf:"bytes,2,opt,name=Object" json:"Object,omitempty"`
}

func (m *AutoMsgAlertDestinationWatchHelper) Reset()         { *m = AutoMsgAlertDestinationWatchHelper{} }
func (m *AutoMsgAlertDestinationWatchHelper) String() string { return proto.CompactTextString(m) }
func (*AutoMsgAlertDestinationWatchHelper) ProtoMessage()    {}
func (*AutoMsgAlertDestinationWatchHelper) Descriptor() ([]byte, []int) {
	return fileDescriptorAlerts, []int{14}
}

func (m *AutoMsgAlertDestinationWatchHelper) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *AutoMsgAlertDestinationWatchHelper) GetObject() *AlertDestination {
	if m != nil {
		return m.Object
	}
	return nil
}

type AutoMsgAlertPolicyWatchHelper struct {
	Type   string       `protobuf:"bytes,1,opt,name=Type,proto3" json:"Type,omitempty"`
	Object *AlertPolicy `protobuf:"bytes,2,opt,name=Object" json:"Object,omitempty"`
}

func (m *AutoMsgAlertPolicyWatchHelper) Reset()         { *m = AutoMsgAlertPolicyWatchHelper{} }
func (m *AutoMsgAlertPolicyWatchHelper) String() string { return proto.CompactTextString(m) }
func (*AutoMsgAlertPolicyWatchHelper) ProtoMessage()    {}
func (*AutoMsgAlertPolicyWatchHelper) Descriptor() ([]byte, []int) {
	return fileDescriptorAlerts, []int{15}
}

func (m *AutoMsgAlertPolicyWatchHelper) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *AutoMsgAlertPolicyWatchHelper) GetObject() *AlertPolicy {
	if m != nil {
		return m.Object
	}
	return nil
}

type MatchedRequirement struct {
	Requirement   `protobuf:"bytes,1,opt,name=Requirement,embedded=Requirement" json:",inline"`
	ObservedValue string `protobuf:"bytes,2,opt,name=ObservedValue,proto3" json:"observed-value, omitempty"`
}

func (m *MatchedRequirement) Reset()                    { *m = MatchedRequirement{} }
func (m *MatchedRequirement) String() string            { return proto.CompactTextString(m) }
func (*MatchedRequirement) ProtoMessage()               {}
func (*MatchedRequirement) Descriptor() ([]byte, []int) { return fileDescriptorAlerts, []int{16} }

func (m *MatchedRequirement) GetObservedValue() string {
	if m != nil {
		return m.ObservedValue
	}
	return ""
}

type Requirement struct {
	FieldOrMetric string   `protobuf:"bytes,1,opt,name=FieldOrMetric,proto3" json:"field-or-metric, omitempty"`
	Operator      string   `protobuf:"bytes,2,opt,name=Operator,proto3" json:"operator, omitempty"`
	Values        []string `protobuf:"bytes,3,rep,name=Values" json:"values, omitempty"`
}

func (m *Requirement) Reset()                    { *m = Requirement{} }
func (m *Requirement) String() string            { return proto.CompactTextString(m) }
func (*Requirement) ProtoMessage()               {}
func (*Requirement) Descriptor() ([]byte, []int) { return fileDescriptorAlerts, []int{17} }

func (m *Requirement) GetFieldOrMetric() string {
	if m != nil {
		return m.FieldOrMetric
	}
	return ""
}

func (m *Requirement) GetOperator() string {
	if m != nil {
		return m.Operator
	}
	return ""
}

func (m *Requirement) GetValues() []string {
	if m != nil {
		return m.Values
	}
	return nil
}

func init() {
	proto.RegisterType((*Alert)(nil), "alerts.Alert")
	proto.RegisterType((*AlertDestination)(nil), "alerts.AlertDestination")
	proto.RegisterType((*AlertDestinationList)(nil), "alerts.AlertDestinationList")
	proto.RegisterType((*AlertDestinationSpec)(nil), "alerts.AlertDestinationSpec")
	proto.RegisterType((*AlertDestinationStatus)(nil), "alerts.AlertDestinationStatus")
	proto.RegisterType((*AlertPolicy)(nil), "alerts.AlertPolicy")
	proto.RegisterType((*AlertPolicyList)(nil), "alerts.AlertPolicyList")
	proto.RegisterType((*AlertPolicySpec)(nil), "alerts.AlertPolicySpec")
	proto.RegisterType((*AlertPolicyStatus)(nil), "alerts.AlertPolicyStatus")
	proto.RegisterType((*AlertReason)(nil), "alerts.AlertReason")
	proto.RegisterType((*AlertSource)(nil), "alerts.AlertSource")
	proto.RegisterType((*AlertSpec)(nil), "alerts.AlertSpec")
	proto.RegisterType((*AlertStatus)(nil), "alerts.AlertStatus")
	proto.RegisterType((*AuditInfo)(nil), "alerts.AuditInfo")
	proto.RegisterType((*AutoMsgAlertDestinationWatchHelper)(nil), "alerts.AutoMsgAlertDestinationWatchHelper")
	proto.RegisterType((*AutoMsgAlertPolicyWatchHelper)(nil), "alerts.AutoMsgAlertPolicyWatchHelper")
	proto.RegisterType((*MatchedRequirement)(nil), "alerts.MatchedRequirement")
	proto.RegisterType((*Requirement)(nil), "alerts.Requirement")
	proto.RegisterEnum("alerts.AlertSeverity", AlertSeverity_name, AlertSeverity_value)
	proto.RegisterEnum("alerts.AlertSpec_AlertState", AlertSpec_AlertState_name, AlertSpec_AlertState_value)
	proto.RegisterEnum("alerts.Requirement_AllowedOperators", Requirement_AllowedOperators_name, Requirement_AllowedOperators_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for AlertDestinationV1 service

type AlertDestinationV1Client interface {
	AutoAddAlertDestination(ctx context.Context, in *AlertDestination, opts ...grpc.CallOption) (*AlertDestination, error)
	AutoDeleteAlertDestination(ctx context.Context, in *AlertDestination, opts ...grpc.CallOption) (*AlertDestination, error)
	AutoGetAlertDestination(ctx context.Context, in *AlertDestination, opts ...grpc.CallOption) (*AlertDestination, error)
	AutoListAlertDestination(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (*AlertDestinationList, error)
	AutoUpdateAlertDestination(ctx context.Context, in *AlertDestination, opts ...grpc.CallOption) (*AlertDestination, error)
	AutoWatchAlertDestination(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (AlertDestinationV1_AutoWatchAlertDestinationClient, error)
}

type alertDestinationV1Client struct {
	cc *grpc.ClientConn
}

func NewAlertDestinationV1Client(cc *grpc.ClientConn) AlertDestinationV1Client {
	return &alertDestinationV1Client{cc}
}

func (c *alertDestinationV1Client) AutoAddAlertDestination(ctx context.Context, in *AlertDestination, opts ...grpc.CallOption) (*AlertDestination, error) {
	out := new(AlertDestination)
	err := grpc.Invoke(ctx, "/alerts.AlertDestinationV1/AutoAddAlertDestination", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *alertDestinationV1Client) AutoDeleteAlertDestination(ctx context.Context, in *AlertDestination, opts ...grpc.CallOption) (*AlertDestination, error) {
	out := new(AlertDestination)
	err := grpc.Invoke(ctx, "/alerts.AlertDestinationV1/AutoDeleteAlertDestination", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *alertDestinationV1Client) AutoGetAlertDestination(ctx context.Context, in *AlertDestination, opts ...grpc.CallOption) (*AlertDestination, error) {
	out := new(AlertDestination)
	err := grpc.Invoke(ctx, "/alerts.AlertDestinationV1/AutoGetAlertDestination", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *alertDestinationV1Client) AutoListAlertDestination(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (*AlertDestinationList, error) {
	out := new(AlertDestinationList)
	err := grpc.Invoke(ctx, "/alerts.AlertDestinationV1/AutoListAlertDestination", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *alertDestinationV1Client) AutoUpdateAlertDestination(ctx context.Context, in *AlertDestination, opts ...grpc.CallOption) (*AlertDestination, error) {
	out := new(AlertDestination)
	err := grpc.Invoke(ctx, "/alerts.AlertDestinationV1/AutoUpdateAlertDestination", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *alertDestinationV1Client) AutoWatchAlertDestination(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (AlertDestinationV1_AutoWatchAlertDestinationClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_AlertDestinationV1_serviceDesc.Streams[0], c.cc, "/alerts.AlertDestinationV1/AutoWatchAlertDestination", opts...)
	if err != nil {
		return nil, err
	}
	x := &alertDestinationV1AutoWatchAlertDestinationClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type AlertDestinationV1_AutoWatchAlertDestinationClient interface {
	Recv() (*AutoMsgAlertDestinationWatchHelper, error)
	grpc.ClientStream
}

type alertDestinationV1AutoWatchAlertDestinationClient struct {
	grpc.ClientStream
}

func (x *alertDestinationV1AutoWatchAlertDestinationClient) Recv() (*AutoMsgAlertDestinationWatchHelper, error) {
	m := new(AutoMsgAlertDestinationWatchHelper)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for AlertDestinationV1 service

type AlertDestinationV1Server interface {
	AutoAddAlertDestination(context.Context, *AlertDestination) (*AlertDestination, error)
	AutoDeleteAlertDestination(context.Context, *AlertDestination) (*AlertDestination, error)
	AutoGetAlertDestination(context.Context, *AlertDestination) (*AlertDestination, error)
	AutoListAlertDestination(context.Context, *api.ListWatchOptions) (*AlertDestinationList, error)
	AutoUpdateAlertDestination(context.Context, *AlertDestination) (*AlertDestination, error)
	AutoWatchAlertDestination(*api.ListWatchOptions, AlertDestinationV1_AutoWatchAlertDestinationServer) error
}

func RegisterAlertDestinationV1Server(s *grpc.Server, srv AlertDestinationV1Server) {
	s.RegisterService(&_AlertDestinationV1_serviceDesc, srv)
}

func _AlertDestinationV1_AutoAddAlertDestination_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AlertDestination)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AlertDestinationV1Server).AutoAddAlertDestination(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/alerts.AlertDestinationV1/AutoAddAlertDestination",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AlertDestinationV1Server).AutoAddAlertDestination(ctx, req.(*AlertDestination))
	}
	return interceptor(ctx, in, info, handler)
}

func _AlertDestinationV1_AutoDeleteAlertDestination_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AlertDestination)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AlertDestinationV1Server).AutoDeleteAlertDestination(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/alerts.AlertDestinationV1/AutoDeleteAlertDestination",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AlertDestinationV1Server).AutoDeleteAlertDestination(ctx, req.(*AlertDestination))
	}
	return interceptor(ctx, in, info, handler)
}

func _AlertDestinationV1_AutoGetAlertDestination_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AlertDestination)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AlertDestinationV1Server).AutoGetAlertDestination(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/alerts.AlertDestinationV1/AutoGetAlertDestination",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AlertDestinationV1Server).AutoGetAlertDestination(ctx, req.(*AlertDestination))
	}
	return interceptor(ctx, in, info, handler)
}

func _AlertDestinationV1_AutoListAlertDestination_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(api.ListWatchOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AlertDestinationV1Server).AutoListAlertDestination(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/alerts.AlertDestinationV1/AutoListAlertDestination",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AlertDestinationV1Server).AutoListAlertDestination(ctx, req.(*api.ListWatchOptions))
	}
	return interceptor(ctx, in, info, handler)
}

func _AlertDestinationV1_AutoUpdateAlertDestination_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AlertDestination)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AlertDestinationV1Server).AutoUpdateAlertDestination(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/alerts.AlertDestinationV1/AutoUpdateAlertDestination",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AlertDestinationV1Server).AutoUpdateAlertDestination(ctx, req.(*AlertDestination))
	}
	return interceptor(ctx, in, info, handler)
}

func _AlertDestinationV1_AutoWatchAlertDestination_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(api.ListWatchOptions)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AlertDestinationV1Server).AutoWatchAlertDestination(m, &alertDestinationV1AutoWatchAlertDestinationServer{stream})
}

type AlertDestinationV1_AutoWatchAlertDestinationServer interface {
	Send(*AutoMsgAlertDestinationWatchHelper) error
	grpc.ServerStream
}

type alertDestinationV1AutoWatchAlertDestinationServer struct {
	grpc.ServerStream
}

func (x *alertDestinationV1AutoWatchAlertDestinationServer) Send(m *AutoMsgAlertDestinationWatchHelper) error {
	return x.ServerStream.SendMsg(m)
}

var _AlertDestinationV1_serviceDesc = grpc.ServiceDesc{
	ServiceName: "alerts.AlertDestinationV1",
	HandlerType: (*AlertDestinationV1Server)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AutoAddAlertDestination",
			Handler:    _AlertDestinationV1_AutoAddAlertDestination_Handler,
		},
		{
			MethodName: "AutoDeleteAlertDestination",
			Handler:    _AlertDestinationV1_AutoDeleteAlertDestination_Handler,
		},
		{
			MethodName: "AutoGetAlertDestination",
			Handler:    _AlertDestinationV1_AutoGetAlertDestination_Handler,
		},
		{
			MethodName: "AutoListAlertDestination",
			Handler:    _AlertDestinationV1_AutoListAlertDestination_Handler,
		},
		{
			MethodName: "AutoUpdateAlertDestination",
			Handler:    _AlertDestinationV1_AutoUpdateAlertDestination_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "AutoWatchAlertDestination",
			Handler:       _AlertDestinationV1_AutoWatchAlertDestination_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "alerts.proto",
}

// Client API for AlertPolicyV1 service

type AlertPolicyV1Client interface {
	AutoAddAlertPolicy(ctx context.Context, in *AlertPolicy, opts ...grpc.CallOption) (*AlertPolicy, error)
	AutoDeleteAlertPolicy(ctx context.Context, in *AlertPolicy, opts ...grpc.CallOption) (*AlertPolicy, error)
	AutoGetAlertPolicy(ctx context.Context, in *AlertPolicy, opts ...grpc.CallOption) (*AlertPolicy, error)
	AutoListAlertPolicy(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (*AlertPolicyList, error)
	AutoUpdateAlertPolicy(ctx context.Context, in *AlertPolicy, opts ...grpc.CallOption) (*AlertPolicy, error)
	AutoWatchAlertPolicy(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (AlertPolicyV1_AutoWatchAlertPolicyClient, error)
}

type alertPolicyV1Client struct {
	cc *grpc.ClientConn
}

func NewAlertPolicyV1Client(cc *grpc.ClientConn) AlertPolicyV1Client {
	return &alertPolicyV1Client{cc}
}

func (c *alertPolicyV1Client) AutoAddAlertPolicy(ctx context.Context, in *AlertPolicy, opts ...grpc.CallOption) (*AlertPolicy, error) {
	out := new(AlertPolicy)
	err := grpc.Invoke(ctx, "/alerts.AlertPolicyV1/AutoAddAlertPolicy", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *alertPolicyV1Client) AutoDeleteAlertPolicy(ctx context.Context, in *AlertPolicy, opts ...grpc.CallOption) (*AlertPolicy, error) {
	out := new(AlertPolicy)
	err := grpc.Invoke(ctx, "/alerts.AlertPolicyV1/AutoDeleteAlertPolicy", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *alertPolicyV1Client) AutoGetAlertPolicy(ctx context.Context, in *AlertPolicy, opts ...grpc.CallOption) (*AlertPolicy, error) {
	out := new(AlertPolicy)
	err := grpc.Invoke(ctx, "/alerts.AlertPolicyV1/AutoGetAlertPolicy", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *alertPolicyV1Client) AutoListAlertPolicy(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (*AlertPolicyList, error) {
	out := new(AlertPolicyList)
	err := grpc.Invoke(ctx, "/alerts.AlertPolicyV1/AutoListAlertPolicy", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *alertPolicyV1Client) AutoUpdateAlertPolicy(ctx context.Context, in *AlertPolicy, opts ...grpc.CallOption) (*AlertPolicy, error) {
	out := new(AlertPolicy)
	err := grpc.Invoke(ctx, "/alerts.AlertPolicyV1/AutoUpdateAlertPolicy", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *alertPolicyV1Client) AutoWatchAlertPolicy(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (AlertPolicyV1_AutoWatchAlertPolicyClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_AlertPolicyV1_serviceDesc.Streams[0], c.cc, "/alerts.AlertPolicyV1/AutoWatchAlertPolicy", opts...)
	if err != nil {
		return nil, err
	}
	x := &alertPolicyV1AutoWatchAlertPolicyClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type AlertPolicyV1_AutoWatchAlertPolicyClient interface {
	Recv() (*AutoMsgAlertPolicyWatchHelper, error)
	grpc.ClientStream
}

type alertPolicyV1AutoWatchAlertPolicyClient struct {
	grpc.ClientStream
}

func (x *alertPolicyV1AutoWatchAlertPolicyClient) Recv() (*AutoMsgAlertPolicyWatchHelper, error) {
	m := new(AutoMsgAlertPolicyWatchHelper)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for AlertPolicyV1 service

type AlertPolicyV1Server interface {
	AutoAddAlertPolicy(context.Context, *AlertPolicy) (*AlertPolicy, error)
	AutoDeleteAlertPolicy(context.Context, *AlertPolicy) (*AlertPolicy, error)
	AutoGetAlertPolicy(context.Context, *AlertPolicy) (*AlertPolicy, error)
	AutoListAlertPolicy(context.Context, *api.ListWatchOptions) (*AlertPolicyList, error)
	AutoUpdateAlertPolicy(context.Context, *AlertPolicy) (*AlertPolicy, error)
	AutoWatchAlertPolicy(*api.ListWatchOptions, AlertPolicyV1_AutoWatchAlertPolicyServer) error
}

func RegisterAlertPolicyV1Server(s *grpc.Server, srv AlertPolicyV1Server) {
	s.RegisterService(&_AlertPolicyV1_serviceDesc, srv)
}

func _AlertPolicyV1_AutoAddAlertPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AlertPolicy)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AlertPolicyV1Server).AutoAddAlertPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/alerts.AlertPolicyV1/AutoAddAlertPolicy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AlertPolicyV1Server).AutoAddAlertPolicy(ctx, req.(*AlertPolicy))
	}
	return interceptor(ctx, in, info, handler)
}

func _AlertPolicyV1_AutoDeleteAlertPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AlertPolicy)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AlertPolicyV1Server).AutoDeleteAlertPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/alerts.AlertPolicyV1/AutoDeleteAlertPolicy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AlertPolicyV1Server).AutoDeleteAlertPolicy(ctx, req.(*AlertPolicy))
	}
	return interceptor(ctx, in, info, handler)
}

func _AlertPolicyV1_AutoGetAlertPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AlertPolicy)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AlertPolicyV1Server).AutoGetAlertPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/alerts.AlertPolicyV1/AutoGetAlertPolicy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AlertPolicyV1Server).AutoGetAlertPolicy(ctx, req.(*AlertPolicy))
	}
	return interceptor(ctx, in, info, handler)
}

func _AlertPolicyV1_AutoListAlertPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(api.ListWatchOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AlertPolicyV1Server).AutoListAlertPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/alerts.AlertPolicyV1/AutoListAlertPolicy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AlertPolicyV1Server).AutoListAlertPolicy(ctx, req.(*api.ListWatchOptions))
	}
	return interceptor(ctx, in, info, handler)
}

func _AlertPolicyV1_AutoUpdateAlertPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AlertPolicy)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AlertPolicyV1Server).AutoUpdateAlertPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/alerts.AlertPolicyV1/AutoUpdateAlertPolicy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AlertPolicyV1Server).AutoUpdateAlertPolicy(ctx, req.(*AlertPolicy))
	}
	return interceptor(ctx, in, info, handler)
}

func _AlertPolicyV1_AutoWatchAlertPolicy_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(api.ListWatchOptions)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AlertPolicyV1Server).AutoWatchAlertPolicy(m, &alertPolicyV1AutoWatchAlertPolicyServer{stream})
}

type AlertPolicyV1_AutoWatchAlertPolicyServer interface {
	Send(*AutoMsgAlertPolicyWatchHelper) error
	grpc.ServerStream
}

type alertPolicyV1AutoWatchAlertPolicyServer struct {
	grpc.ServerStream
}

func (x *alertPolicyV1AutoWatchAlertPolicyServer) Send(m *AutoMsgAlertPolicyWatchHelper) error {
	return x.ServerStream.SendMsg(m)
}

var _AlertPolicyV1_serviceDesc = grpc.ServiceDesc{
	ServiceName: "alerts.AlertPolicyV1",
	HandlerType: (*AlertPolicyV1Server)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AutoAddAlertPolicy",
			Handler:    _AlertPolicyV1_AutoAddAlertPolicy_Handler,
		},
		{
			MethodName: "AutoDeleteAlertPolicy",
			Handler:    _AlertPolicyV1_AutoDeleteAlertPolicy_Handler,
		},
		{
			MethodName: "AutoGetAlertPolicy",
			Handler:    _AlertPolicyV1_AutoGetAlertPolicy_Handler,
		},
		{
			MethodName: "AutoListAlertPolicy",
			Handler:    _AlertPolicyV1_AutoListAlertPolicy_Handler,
		},
		{
			MethodName: "AutoUpdateAlertPolicy",
			Handler:    _AlertPolicyV1_AutoUpdateAlertPolicy_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "AutoWatchAlertPolicy",
			Handler:       _AlertPolicyV1_AutoWatchAlertPolicy_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "alerts.proto",
}

// Client API for AlertsV1 service

type AlertsV1Client interface {
}

type alertsV1Client struct {
	cc *grpc.ClientConn
}

func NewAlertsV1Client(cc *grpc.ClientConn) AlertsV1Client {
	return &alertsV1Client{cc}
}

// Server API for AlertsV1 service

type AlertsV1Server interface {
}

func RegisterAlertsV1Server(s *grpc.Server, srv AlertsV1Server) {
	s.RegisterService(&_AlertsV1_serviceDesc, srv)
}

var _AlertsV1_serviceDesc = grpc.ServiceDesc{
	ServiceName: "alerts.AlertsV1",
	HandlerType: (*AlertsV1Server)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams:     []grpc.StreamDesc{},
	Metadata:    "alerts.proto",
}

func (m *Alert) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Alert) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintAlerts(dAtA, i, uint64(m.TypeMeta.Size()))
	n1, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n1
	dAtA[i] = 0x12
	i++
	i = encodeVarintAlerts(dAtA, i, uint64(m.ObjectMeta.Size()))
	n2, err := m.ObjectMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n2
	dAtA[i] = 0x1a
	i++
	i = encodeVarintAlerts(dAtA, i, uint64(m.Spec.Size()))
	n3, err := m.Spec.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n3
	dAtA[i] = 0x22
	i++
	i = encodeVarintAlerts(dAtA, i, uint64(m.Status.Size()))
	n4, err := m.Status.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n4
	return i, nil
}

func (m *AlertDestination) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AlertDestination) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintAlerts(dAtA, i, uint64(m.TypeMeta.Size()))
	n5, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n5
	dAtA[i] = 0x12
	i++
	i = encodeVarintAlerts(dAtA, i, uint64(m.ObjectMeta.Size()))
	n6, err := m.ObjectMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n6
	dAtA[i] = 0x1a
	i++
	i = encodeVarintAlerts(dAtA, i, uint64(m.Spec.Size()))
	n7, err := m.Spec.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n7
	dAtA[i] = 0x22
	i++
	i = encodeVarintAlerts(dAtA, i, uint64(m.Status.Size()))
	n8, err := m.Status.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n8
	return i, nil
}

func (m *AlertDestinationList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AlertDestinationList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x12
	i++
	i = encodeVarintAlerts(dAtA, i, uint64(m.TypeMeta.Size()))
	n9, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n9
	dAtA[i] = 0x1a
	i++
	i = encodeVarintAlerts(dAtA, i, uint64(m.ListMeta.Size()))
	n10, err := m.ListMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n10
	if len(m.Items) > 0 {
		for _, msg := range m.Items {
			dAtA[i] = 0x22
			i++
			i = encodeVarintAlerts(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *AlertDestinationSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AlertDestinationSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Default {
		dAtA[i] = 0x8
		i++
		if m.Default {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.EmailList) > 0 {
		for _, s := range m.EmailList {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *AlertDestinationStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AlertDestinationStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TotalNotificationsSent != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(m.TotalNotificationsSent))
	}
	return i, nil
}

func (m *AlertPolicy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AlertPolicy) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintAlerts(dAtA, i, uint64(m.TypeMeta.Size()))
	n11, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n11
	dAtA[i] = 0x12
	i++
	i = encodeVarintAlerts(dAtA, i, uint64(m.ObjectMeta.Size()))
	n12, err := m.ObjectMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n12
	dAtA[i] = 0x1a
	i++
	i = encodeVarintAlerts(dAtA, i, uint64(m.Spec.Size()))
	n13, err := m.Spec.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n13
	dAtA[i] = 0x22
	i++
	i = encodeVarintAlerts(dAtA, i, uint64(m.Status.Size()))
	n14, err := m.Status.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n14
	return i, nil
}

func (m *AlertPolicyList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AlertPolicyList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x12
	i++
	i = encodeVarintAlerts(dAtA, i, uint64(m.TypeMeta.Size()))
	n15, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n15
	dAtA[i] = 0x1a
	i++
	i = encodeVarintAlerts(dAtA, i, uint64(m.ListMeta.Size()))
	n16, err := m.ListMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n16
	if len(m.Items) > 0 {
		for _, msg := range m.Items {
			dAtA[i] = 0x22
			i++
			i = encodeVarintAlerts(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *AlertPolicySpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AlertPolicySpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Resource) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(len(m.Resource)))
		i += copy(dAtA[i:], m.Resource)
	}
	if len(m.Severity) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(len(m.Severity)))
		i += copy(dAtA[i:], m.Severity)
	}
	if len(m.Message) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	if len(m.Requirements) > 0 {
		for _, msg := range m.Requirements {
			dAtA[i] = 0x22
			i++
			i = encodeVarintAlerts(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.PersistenceDuration) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(len(m.PersistenceDuration)))
		i += copy(dAtA[i:], m.PersistenceDuration)
	}
	if len(m.ClearDuration) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(len(m.ClearDuration)))
		i += copy(dAtA[i:], m.ClearDuration)
	}
	if m.Enable {
		dAtA[i] = 0x38
		i++
		if m.Enable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.AutoResolve {
		dAtA[i] = 0x40
		i++
		if m.AutoResolve {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Destinations) > 0 {
		for _, s := range m.Destinations {
			dAtA[i] = 0x4a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *AlertPolicyStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AlertPolicyStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TotalHits != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(m.TotalHits))
	}
	if m.OpenAlerts != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(m.OpenAlerts))
	}
	if m.AcknowledgedAlerts != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(m.AcknowledgedAlerts))
	}
	return i, nil
}

func (m *AlertReason) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AlertReason) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.MatchedRequirements) > 0 {
		for _, msg := range m.MatchedRequirements {
			dAtA[i] = 0xa
			i++
			i = encodeVarintAlerts(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.PolicyID) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(len(m.PolicyID)))
		i += copy(dAtA[i:], m.PolicyID)
	}
	return i, nil
}

func (m *AlertSource) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AlertSource) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Component) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(len(m.Component)))
		i += copy(dAtA[i:], m.Component)
	}
	if len(m.NodeName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(len(m.NodeName)))
		i += copy(dAtA[i:], m.NodeName)
	}
	return i, nil
}

func (m *AlertSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AlertSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.State) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(len(m.State)))
		i += copy(dAtA[i:], m.State)
	}
	return i, nil
}

func (m *AlertStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AlertStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Severity) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(len(m.Severity)))
		i += copy(dAtA[i:], m.Severity)
	}
	if m.Source != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(m.Source.Size()))
		n17, err := m.Source.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	dAtA[i] = 0x1a
	i++
	i = encodeVarintAlerts(dAtA, i, uint64(m.ObjectRef.Size()))
	n18, err := m.ObjectRef.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n18
	if len(m.Message) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	dAtA[i] = 0x2a
	i++
	i = encodeVarintAlerts(dAtA, i, uint64(m.Reason.Size()))
	n19, err := m.Reason.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n19
	if m.Acknowledged != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(m.Acknowledged.Size()))
		n20, err := m.Acknowledged.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	if m.Resolved != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(m.Resolved.Size()))
		n21, err := m.Resolved.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	return i, nil
}

func (m *AuditInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuditInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.User) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(len(m.User)))
		i += copy(dAtA[i:], m.User)
	}
	if m.Time != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(m.Time.Size()))
		n22, err := m.Time.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	return i, nil
}

func (m *AutoMsgAlertDestinationWatchHelper) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AutoMsgAlertDestinationWatchHelper) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if m.Object != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(m.Object.Size()))
		n23, err := m.Object.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	return i, nil
}

func (m *AutoMsgAlertPolicyWatchHelper) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AutoMsgAlertPolicyWatchHelper) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if m.Object != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(m.Object.Size()))
		n24, err := m.Object.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	return i, nil
}

func (m *MatchedRequirement) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MatchedRequirement) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintAlerts(dAtA, i, uint64(m.Requirement.Size()))
	n25, err := m.Requirement.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n25
	if len(m.ObservedValue) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(len(m.ObservedValue)))
		i += copy(dAtA[i:], m.ObservedValue)
	}
	return i, nil
}

func (m *Requirement) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Requirement) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.FieldOrMetric) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(len(m.FieldOrMetric)))
		i += copy(dAtA[i:], m.FieldOrMetric)
	}
	if len(m.Operator) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(len(m.Operator)))
		i += copy(dAtA[i:], m.Operator)
	}
	if len(m.Values) > 0 {
		for _, s := range m.Values {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func encodeVarintAlerts(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Alert) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovAlerts(uint64(l))
	l = m.ObjectMeta.Size()
	n += 1 + l + sovAlerts(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovAlerts(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovAlerts(uint64(l))
	return n
}

func (m *AlertDestination) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovAlerts(uint64(l))
	l = m.ObjectMeta.Size()
	n += 1 + l + sovAlerts(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovAlerts(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovAlerts(uint64(l))
	return n
}

func (m *AlertDestinationList) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovAlerts(uint64(l))
	l = m.ListMeta.Size()
	n += 1 + l + sovAlerts(uint64(l))
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovAlerts(uint64(l))
		}
	}
	return n
}

func (m *AlertDestinationSpec) Size() (n int) {
	var l int
	_ = l
	if m.Default {
		n += 2
	}
	if len(m.EmailList) > 0 {
		for _, s := range m.EmailList {
			l = len(s)
			n += 1 + l + sovAlerts(uint64(l))
		}
	}
	return n
}

func (m *AlertDestinationStatus) Size() (n int) {
	var l int
	_ = l
	if m.TotalNotificationsSent != 0 {
		n += 1 + sovAlerts(uint64(m.TotalNotificationsSent))
	}
	return n
}

func (m *AlertPolicy) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovAlerts(uint64(l))
	l = m.ObjectMeta.Size()
	n += 1 + l + sovAlerts(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovAlerts(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovAlerts(uint64(l))
	return n
}

func (m *AlertPolicyList) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovAlerts(uint64(l))
	l = m.ListMeta.Size()
	n += 1 + l + sovAlerts(uint64(l))
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovAlerts(uint64(l))
		}
	}
	return n
}

func (m *AlertPolicySpec) Size() (n int) {
	var l int
	_ = l
	l = len(m.Resource)
	if l > 0 {
		n += 1 + l + sovAlerts(uint64(l))
	}
	l = len(m.Severity)
	if l > 0 {
		n += 1 + l + sovAlerts(uint64(l))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovAlerts(uint64(l))
	}
	if len(m.Requirements) > 0 {
		for _, e := range m.Requirements {
			l = e.Size()
			n += 1 + l + sovAlerts(uint64(l))
		}
	}
	l = len(m.PersistenceDuration)
	if l > 0 {
		n += 1 + l + sovAlerts(uint64(l))
	}
	l = len(m.ClearDuration)
	if l > 0 {
		n += 1 + l + sovAlerts(uint64(l))
	}
	if m.Enable {
		n += 2
	}
	if m.AutoResolve {
		n += 2
	}
	if len(m.Destinations) > 0 {
		for _, s := range m.Destinations {
			l = len(s)
			n += 1 + l + sovAlerts(uint64(l))
		}
	}
	return n
}

func (m *AlertPolicyStatus) Size() (n int) {
	var l int
	_ = l
	if m.TotalHits != 0 {
		n += 1 + sovAlerts(uint64(m.TotalHits))
	}
	if m.OpenAlerts != 0 {
		n += 1 + sovAlerts(uint64(m.OpenAlerts))
	}
	if m.AcknowledgedAlerts != 0 {
		n += 1 + sovAlerts(uint64(m.AcknowledgedAlerts))
	}
	return n
}

func (m *AlertReason) Size() (n int) {
	var l int
	_ = l
	if len(m.MatchedRequirements) > 0 {
		for _, e := range m.MatchedRequirements {
			l = e.Size()
			n += 1 + l + sovAlerts(uint64(l))
		}
	}
	l = len(m.PolicyID)
	if l > 0 {
		n += 1 + l + sovAlerts(uint64(l))
	}
	return n
}

func (m *AlertSource) Size() (n int) {
	var l int
	_ = l
	l = len(m.Component)
	if l > 0 {
		n += 1 + l + sovAlerts(uint64(l))
	}
	l = len(m.NodeName)
	if l > 0 {
		n += 1 + l + sovAlerts(uint64(l))
	}
	return n
}

func (m *AlertSpec) Size() (n int) {
	var l int
	_ = l
	l = len(m.State)
	if l > 0 {
		n += 1 + l + sovAlerts(uint64(l))
	}
	return n
}

func (m *AlertStatus) Size() (n int) {
	var l int
	_ = l
	l = len(m.Severity)
	if l > 0 {
		n += 1 + l + sovAlerts(uint64(l))
	}
	if m.Source != nil {
		l = m.Source.Size()
		n += 1 + l + sovAlerts(uint64(l))
	}
	l = m.ObjectRef.Size()
	n += 1 + l + sovAlerts(uint64(l))
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovAlerts(uint64(l))
	}
	l = m.Reason.Size()
	n += 1 + l + sovAlerts(uint64(l))
	if m.Acknowledged != nil {
		l = m.Acknowledged.Size()
		n += 1 + l + sovAlerts(uint64(l))
	}
	if m.Resolved != nil {
		l = m.Resolved.Size()
		n += 1 + l + sovAlerts(uint64(l))
	}
	return n
}

func (m *AuditInfo) Size() (n int) {
	var l int
	_ = l
	l = len(m.User)
	if l > 0 {
		n += 1 + l + sovAlerts(uint64(l))
	}
	if m.Time != nil {
		l = m.Time.Size()
		n += 1 + l + sovAlerts(uint64(l))
	}
	return n
}

func (m *AutoMsgAlertDestinationWatchHelper) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovAlerts(uint64(l))
	}
	if m.Object != nil {
		l = m.Object.Size()
		n += 1 + l + sovAlerts(uint64(l))
	}
	return n
}

func (m *AutoMsgAlertPolicyWatchHelper) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovAlerts(uint64(l))
	}
	if m.Object != nil {
		l = m.Object.Size()
		n += 1 + l + sovAlerts(uint64(l))
	}
	return n
}

func (m *MatchedRequirement) Size() (n int) {
	var l int
	_ = l
	l = m.Requirement.Size()
	n += 1 + l + sovAlerts(uint64(l))
	l = len(m.ObservedValue)
	if l > 0 {
		n += 1 + l + sovAlerts(uint64(l))
	}
	return n
}

func (m *Requirement) Size() (n int) {
	var l int
	_ = l
	l = len(m.FieldOrMetric)
	if l > 0 {
		n += 1 + l + sovAlerts(uint64(l))
	}
	l = len(m.Operator)
	if l > 0 {
		n += 1 + l + sovAlerts(uint64(l))
	}
	if len(m.Values) > 0 {
		for _, s := range m.Values {
			l = len(s)
			n += 1 + l + sovAlerts(uint64(l))
		}
	}
	return n
}

func sovAlerts(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozAlerts(x uint64) (n int) {
	return sovAlerts(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Alert) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAlerts
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Alert: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Alert: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAlerts(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAlerts
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AlertDestination) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAlerts
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AlertDestination: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AlertDestination: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAlerts(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAlerts
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AlertDestinationList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAlerts
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AlertDestinationList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AlertDestinationList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ListMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &AlertDestination{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAlerts(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAlerts
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AlertDestinationSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAlerts
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AlertDestinationSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AlertDestinationSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Default", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Default = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EmailList", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EmailList = append(m.EmailList, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAlerts(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAlerts
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AlertDestinationStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAlerts
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AlertDestinationStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AlertDestinationStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalNotificationsSent", wireType)
			}
			m.TotalNotificationsSent = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalNotificationsSent |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAlerts(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAlerts
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AlertPolicy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAlerts
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AlertPolicy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AlertPolicy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAlerts(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAlerts
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AlertPolicyList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAlerts
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AlertPolicyList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AlertPolicyList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ListMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &AlertPolicy{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAlerts(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAlerts
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AlertPolicySpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAlerts
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AlertPolicySpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AlertPolicySpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resource", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Resource = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Severity", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Severity = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Requirements", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Requirements = append(m.Requirements, Requirement{})
			if err := m.Requirements[len(m.Requirements)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PersistenceDuration", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PersistenceDuration = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClearDuration", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClearDuration = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enable = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoResolve", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AutoResolve = bool(v != 0)
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Destinations", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Destinations = append(m.Destinations, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAlerts(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAlerts
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AlertPolicyStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAlerts
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AlertPolicyStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AlertPolicyStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalHits", wireType)
			}
			m.TotalHits = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalHits |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenAlerts", wireType)
			}
			m.OpenAlerts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OpenAlerts |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AcknowledgedAlerts", wireType)
			}
			m.AcknowledgedAlerts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AcknowledgedAlerts |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAlerts(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAlerts
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AlertReason) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAlerts
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AlertReason: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AlertReason: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchedRequirements", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MatchedRequirements = append(m.MatchedRequirements, &MatchedRequirement{})
			if err := m.MatchedRequirements[len(m.MatchedRequirements)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PolicyID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PolicyID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAlerts(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAlerts
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AlertSource) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAlerts
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AlertSource: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AlertSource: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Component", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Component = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAlerts(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAlerts
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AlertSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAlerts
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AlertSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AlertSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAlerts(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAlerts
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AlertStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAlerts
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AlertStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AlertStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Severity", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Severity = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Source == nil {
				m.Source = &AlertSource{}
			}
			if err := m.Source.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectRef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectRef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Reason.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Acknowledged", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Acknowledged == nil {
				m.Acknowledged = &AuditInfo{}
			}
			if err := m.Acknowledged.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resolved", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Resolved == nil {
				m.Resolved = &AuditInfo{}
			}
			if err := m.Resolved.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAlerts(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAlerts
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuditInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAlerts
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuditInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuditInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.User = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Time == nil {
				m.Time = &api.Timestamp{}
			}
			if err := m.Time.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAlerts(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAlerts
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AutoMsgAlertDestinationWatchHelper) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAlerts
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AutoMsgAlertDestinationWatchHelper: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AutoMsgAlertDestinationWatchHelper: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Object", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Object == nil {
				m.Object = &AlertDestination{}
			}
			if err := m.Object.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAlerts(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAlerts
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AutoMsgAlertPolicyWatchHelper) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAlerts
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AutoMsgAlertPolicyWatchHelper: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AutoMsgAlertPolicyWatchHelper: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Object", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Object == nil {
				m.Object = &AlertPolicy{}
			}
			if err := m.Object.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAlerts(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAlerts
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MatchedRequirement) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAlerts
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MatchedRequirement: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MatchedRequirement: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Requirement", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Requirement.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObservedValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ObservedValue = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAlerts(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAlerts
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Requirement) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAlerts
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Requirement: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Requirement: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FieldOrMetric", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FieldOrMetric = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Operator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Values", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Values = append(m.Values, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAlerts(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAlerts
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipAlerts(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowAlerts
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthAlerts
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowAlerts
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipAlerts(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthAlerts = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowAlerts   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("alerts.proto", fileDescriptorAlerts) }

var fileDescriptorAlerts = []byte{
	// 2148 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x59, 0xcf, 0x53, 0x1b, 0xc9,
	0x15, 0x66, 0x84, 0x10, 0x52, 0x03, 0x8b, 0xdc, 0x18, 0xd0, 0xc8, 0x06, 0xb1, 0xe3, 0xf5, 0x2e,
	0x66, 0x2d, 0x64, 0x58, 0x6f, 0x6a, 0x97, 0x8d, 0x9d, 0x20, 0x90, 0x31, 0xbb, 0x80, 0x58, 0x81,
	0x71, 0x8e, 0x19, 0x34, 0x8d, 0x3c, 0xc9, 0x68, 0x66, 0x76, 0xa6, 0x07, 0x87, 0x4a, 0xb9, 0x92,
	0x8a, 0xc0, 0xb9, 0x24, 0x97, 0xdd, 0xa4, 0x92, 0xca, 0x21, 0x87, 0xad, 0xca, 0x21, 0xdc, 0xe2,
	0x53, 0x4e, 0xa9, 0x1c, 0xf6, 0xe0, 0xe3, 0x96, 0x73, 0xdb, 0x03, 0x95, 0x72, 0xe5, 0x90, 0xe2,
	0x9c, 0x3f, 0x20, 0xd5, 0x3d, 0x3d, 0xa3, 0x6e, 0xcd, 0xc8, 0x2b, 0x57, 0x79, 0x7d, 0xb2, 0xd5,
	0xfd, 0xde, 0xf7, 0x5e, 0xbf, 0x1f, 0xdf, 0xeb, 0x69, 0xc0, 0xb0, 0x6a, 0x20, 0x07, 0xbb, 0xf3,
	0xb6, 0x63, 0x61, 0x0b, 0xa6, 0xfc, 0x5f, 0xf9, 0xcb, 0x0d, 0xcb, 0x6a, 0x18, 0xa8, 0xa4, 0xda,
	0x7a, 0x49, 0x35, 0x4d, 0x0b, 0xab, 0x58, 0xb7, 0x4c, 0x26, 0x95, 0xaf, 0x34, 0x74, 0xfc, 0xc0,
	0xdb, 0x9f, 0xaf, 0x5b, 0xcd, 0x92, 0x8d, 0x4c, 0x57, 0x35, 0x35, 0xab, 0xe4, 0x3e, 0x2c, 0x1d,
	0x22, 0x53, 0xaf, 0xa3, 0x92, 0x87, 0x75, 0xc3, 0x25, 0xaa, 0x0d, 0x64, 0xf2, 0xda, 0x25, 0xdd,
	0xac, 0x1b, 0x9e, 0x86, 0x02, 0x98, 0x22, 0x07, 0xd3, 0xb0, 0x1a, 0x56, 0x89, 0x2e, 0xef, 0x7b,
	0x07, 0xf4, 0x17, 0xfd, 0x41, 0xff, 0xc7, 0xc4, 0xaf, 0x76, 0xb1, 0x4a, 0x7c, 0x6c, 0x22, 0xac,
	0xfa, 0x62, 0xca, 0x1f, 0x13, 0x60, 0x60, 0x99, 0x9c, 0x02, 0xde, 0x00, 0xd2, 0x6e, 0x4e, 0x9a,
	0x91, 0x66, 0x87, 0x16, 0x47, 0xe6, 0x55, 0x5b, 0x9f, 0xdf, 0x3d, 0xb2, 0xd1, 0x26, 0xc2, 0x6a,
	0x79, 0xec, 0xe9, 0x59, 0xa1, 0xef, 0xeb, 0xb3, 0x82, 0x74, 0x7e, 0x56, 0x18, 0xbc, 0xae, 0x9b,
	0x86, 0x6e, 0xa2, 0x9a, 0xb4, 0x0b, 0x97, 0x80, 0x54, 0xcd, 0x25, 0xa8, 0xc6, 0x28, 0xd5, 0xa8,
	0xee, 0xff, 0x04, 0xd5, 0x31, 0xd5, 0xb9, 0xc4, 0xe9, 0x8c, 0x12, 0x7b, 0xd7, 0x67, 0xac, 0xa6,
	0x8e, 0x51, 0xd3, 0xc6, 0x47, 0x35, 0xa9, 0x0a, 0x6f, 0x83, 0xe4, 0x8e, 0x8d, 0xea, 0xb9, 0x7e,
	0xaa, 0x7e, 0x61, 0x9e, 0xc5, 0x95, 0xba, 0x42, 0x36, 0xca, 0x93, 0x04, 0x80, 0x28, 0xbb, 0x36,
	0xaa, 0xf3, 0xca, 0x54, 0x0f, 0xde, 0x01, 0xa9, 0x1d, 0xac, 0x62, 0xcf, 0xcd, 0x25, 0x29, 0xc2,
	0x98, 0x88, 0x40, 0xb7, 0xca, 0x32, 0xc3, 0xb8, 0xe0, 0xd2, 0xdf, 0x3c, 0x0a, 0xd3, 0x5e, 0x92,
	0x9f, 0x9d, 0xc8, 0xe3, 0x60, 0xa8, 0xf4, 0xf3, 0xea, 0xfc, 0x2e, 0x32, 0x55, 0x13, 0x3f, 0x0a,
	0xb2, 0xaa, 0x7c, 0x95, 0x00, 0x59, 0x8a, 0xb6, 0x8a, 0x5c, 0xac, 0x9b, 0x34, 0x2b, 0xaf, 0x39,
	0x4a, 0xeb, 0x42, 0x94, 0x2e, 0x0b, 0x67, 0xe4, 0xbc, 0xea, 0x25, 0x60, 0x9f, 0x76, 0x04, 0x6c,
	0xba, 0x2b, 0x58, 0xcf, 0xb1, 0x7b, 0xeb, 0xd9, 0x89, 0x3c, 0x23, 0xc6, 0xee, 0x82, 0xda, 0x81,
	0xe6, 0x2a, 0x7f, 0x96, 0xc0, 0xc5, 0x4e, 0x1b, 0x1b, 0xba, 0x8b, 0xa1, 0x42, 0x42, 0x99, 0x88,
	0x0b, 0x65, 0x3a, 0x08, 0x0b, 0xbc, 0x06, 0xd2, 0x44, 0x96, 0xac, 0xb2, 0x20, 0xf8, 0xa2, 0xc1,
	0x22, 0x27, 0xfa, 0x0e, 0x18, 0x58, 0xc7, 0xa8, 0x49, 0xce, 0xd7, 0x3f, 0x3b, 0xb4, 0x98, 0xeb,
	0x76, 0xbe, 0xa5, 0x37, 0xbe, 0x39, 0x91, 0x81, 0xa1, 0xbb, 0xf8, 0x01, 0x32, 0x6c, 0xe4, 0x28,
	0x27, 0x31, 0x0e, 0xd2, 0x90, 0xdd, 0x00, 0x83, 0x1a, 0x3a, 0x50, 0x3d, 0x03, 0xd3, 0x8c, 0xa7,
	0xcb, 0x13, 0xe7, 0x67, 0x05, 0xc8, 0x96, 0xf8, 0x80, 0x04, 0x62, 0xf0, 0x23, 0x90, 0xa9, 0x34,
	0x55, 0xdd, 0x20, 0xee, 0xe5, 0x12, 0x33, 0xfd, 0xb3, 0x99, 0xf2, 0xd4, 0x53, 0x3f, 0xbd, 0xe3,
	0x88, 0x6c, 0x14, 0x89, 0x5d, 0x5e, 0xb5, 0x2d, 0xaf, 0x3c, 0x02, 0x13, 0xf1, 0xb9, 0x80, 0x75,
	0x30, 0x81, 0x2d, 0xac, 0x1a, 0x5b, 0x16, 0xd6, 0x0f, 0xf4, 0xba, 0x1f, 0xd8, 0x1d, 0x64, 0xfa,
	0x7e, 0x0d, 0x94, 0xdf, 0x65, 0x36, 0xae, 0x50, 0xa9, 0xa2, 0xc9, 0x8b, 0x15, 0x5d, 0x64, 0x0a,
	0x16, 0xbb, 0x40, 0x29, 0x7f, 0x4b, 0x80, 0x21, 0x6a, 0x7f, 0xdb, 0x32, 0xf4, 0xfa, 0xd1, 0x6b,
	0xae, 0xf4, 0x55, 0xa1, 0xd2, 0x27, 0x85, 0xe4, 0xf9, 0x0e, 0xf5, 0x52, 0xe4, 0x1b, 0x1d, 0x45,
	0x2e, 0xc7, 0xe1, 0xf4, 0x5c, 0xdf, 0x33, 0xcf, 0x4e, 0xe4, 0xcb, 0x62, 0x7d, 0x8f, 0xa8, 0x21,
	0x90, 0x8e, 0x5c, 0xe5, 0x77, 0x12, 0x18, 0xe5, 0xa0, 0xbf, 0x8b, 0xb2, 0x56, 0xc4, 0xb2, 0x1e,
	0x8b, 0x39, 0x51, 0xa4, 0xa2, 0xff, 0x97, 0x14, 0xdc, 0xa2, 0xa1, 0x79, 0x0f, 0xa4, 0x6b, 0xc8,
	0xb5, 0x3c, 0xa7, 0x8e, 0x68, 0x56, 0x33, 0xe5, 0xc9, 0xf3, 0xb3, 0xc2, 0x98, 0xc3, 0xd6, 0xf8,
	0xf3, 0x87, 0x82, 0xf0, 0x53, 0x90, 0xde, 0x41, 0x87, 0xc8, 0xd1, 0xf1, 0x11, 0x3d, 0x52, 0xa6,
	0xfc, 0xfe, 0xe9, 0x63, 0x79, 0x62, 0x07, 0x3b, 0x15, 0xd3, 0x6b, 0xce, 0xfa, 0x5c, 0xcb, 0x04,
	0xae, 0xb1, 0x22, 0x1c, 0x73, 0xd9, 0x82, 0x00, 0x19, 0x48, 0xc1, 0x9b, 0x60, 0x70, 0x13, 0xb9,
	0xae, 0xda, 0x40, 0xf4, 0xe4, 0x99, 0x72, 0x9e, 0xe9, 0xc1, 0xa6, 0xbf, 0x2c, 0x34, 0x16, 0x13,
	0x85, 0x3f, 0x02, 0xc3, 0x35, 0xf4, 0x99, 0xa7, 0x3b, 0xa8, 0x89, 0x4c, 0x1c, 0x09, 0x06, 0xb7,
	0x57, 0x2e, 0xb0, 0xc4, 0x4e, 0x3a, 0x9c, 0x02, 0x0f, 0x2a, 0x20, 0xc1, 0x7b, 0x60, 0x6c, 0x1b,
	0x39, 0xae, 0xee, 0x62, 0x64, 0xd6, 0xd1, 0xaa, 0xe7, 0xd0, 0x96, 0xc8, 0x0d, 0x50, 0xdf, 0xae,
	0x9c, 0x9f, 0x15, 0x0a, 0x76, 0x7b, 0xbb, 0xa8, 0xb1, 0x7d, 0x1e, 0x2f, 0x4e, 0x1f, 0xae, 0x80,
	0x91, 0x15, 0x03, 0xa9, 0x4e, 0x08, 0x98, 0xa2, 0x80, 0x53, 0xe7, 0x67, 0x05, 0xb9, 0x4e, 0x36,
	0x62, 0xa1, 0x44, 0x1d, 0x58, 0x04, 0xa9, 0x8a, 0xa9, 0xee, 0x1b, 0x28, 0x37, 0x48, 0xf9, 0x67,
	0x9c, 0xd4, 0x2b, 0xa2, 0x2b, 0x42, 0xbd, 0xfa, 0x42, 0xf0, 0x16, 0x18, 0x5a, 0xf6, 0xb0, 0x45,
	0xb2, 0x67, 0x1c, 0xa2, 0x5c, 0x9a, 0xea, 0x5c, 0x22, 0xa1, 0x50, 0x3d, 0x6c, 0x15, 0x1d, 0x7f,
	0x9d, 0xd7, 0xe4, 0xe5, 0xe1, 0x0f, 0xc0, 0x30, 0x4f, 0xdc, 0xb9, 0x0c, 0xe5, 0x2f, 0xaa, 0xaf,
	0x71, 0xeb, 0x42, 0x28, 0x05, 0xa6, 0xff, 0xaf, 0x04, 0x2e, 0x44, 0x1a, 0x8d, 0x70, 0xe2, 0x2e,
	0x61, 0x9c, 0xbb, 0x3a, 0x76, 0x19, 0x5f, 0x85, 0x9c, 0xe8, 0xf3, 0xd5, 0x03, 0x5d, 0x4c, 0x50,
	0x5b, 0x1e, 0xde, 0x06, 0xa0, 0x6a, 0x23, 0x93, 0xa2, 0xba, 0xb4, 0x04, 0x07, 0xca, 0xd3, 0x4c,
	0x7b, 0xc2, 0xb2, 0x91, 0x59, 0xf4, 0x2b, 0x80, 0x57, 0xe7, 0x34, 0xe0, 0x1e, 0x80, 0xcb, 0xf5,
	0x9f, 0x9a, 0xd6, 0x43, 0x03, 0x69, 0x0d, 0xa4, 0x31, 0x9c, 0x7e, 0x8a, 0xf3, 0x36, 0xc3, 0x99,
	0x56, 0x39, 0x89, 0x18, 0xbc, 0x18, 0x04, 0xe5, 0x2b, 0x89, 0x91, 0x65, 0x0d, 0xa9, 0xae, 0x65,
	0x42, 0x0f, 0x8c, 0x6d, 0xaa, 0xb8, 0xfe, 0x00, 0x69, 0x42, 0x99, 0x4a, 0xb4, 0x4c, 0xf3, 0x41,
	0x99, 0x46, 0x45, 0xca, 0xef, 0x30, 0x27, 0x0a, 0x4d, 0x7f, 0xaf, 0xd8, 0xad, 0x6a, 0xe3, 0xf0,
	0xe1, 0x6d, 0x90, 0xf6, 0x63, 0xbd, 0xbe, 0xca, 0xfa, 0x53, 0x61, 0x78, 0x79, 0x6a, 0xb2, 0x68,
	0xd3, 0xdd, 0xa2, 0xae, 0x09, 0xcd, 0x18, 0xe8, 0x28, 0xad, 0xe0, 0x18, 0x3b, 0x7e, 0xbf, 0x2f,
	0x81, 0xcc, 0x8a, 0xd5, 0xb4, 0x2d, 0x33, 0x98, 0x2d, 0x99, 0xf2, 0x65, 0x06, 0x78, 0xb1, 0x1e,
	0x6c, 0x08, 0xa9, 0x0a, 0xc5, 0xe1, 0x07, 0x20, 0xbd, 0x65, 0x69, 0x68, 0x4b, 0x6d, 0x22, 0xe6,
	0x4b, 0xa8, 0x6a, 0x5a, 0x1a, 0x2a, 0x9a, 0x6a, 0x53, 0x64, 0x99, 0x40, 0x9a, 0xb0, 0x68, 0x26,
	0xbc, 0xf8, 0xc1, 0x2a, 0x18, 0x20, 0x95, 0x13, 0xb0, 0xd4, 0x87, 0xa7, 0x8f, 0xe5, 0x29, 0x91,
	0x70, 0x6c, 0x54, 0x6f, 0x5f, 0xf3, 0x50, 0xc0, 0x3b, 0x59, 0x42, 0xe4, 0x82, 0x05, 0x1f, 0x47,
	0xf9, 0x1e, 0x00, 0x6d, 0x69, 0x98, 0x06, 0xc9, 0xea, 0x76, 0x65, 0x2b, 0xdb, 0x07, 0x87, 0x41,
	0xba, 0x56, 0xd9, 0xa9, 0x6e, 0xec, 0x55, 0x56, 0xb3, 0x12, 0xcc, 0x82, 0xe1, 0xe5, 0x95, 0x4f,
	0xb6, 0xaa, 0xf7, 0x37, 0x2a, 0xab, 0x6b, 0x95, 0xd5, 0x6c, 0x42, 0xf9, 0x43, 0x32, 0x08, 0x8e,
	0x5f, 0xc8, 0x3c, 0x19, 0x4a, 0xaf, 0x86, 0x0c, 0xc9, 0x2d, 0xd6, 0xa7, 0xe4, 0x44, 0xdc, 0x2d,
	0x96, 0x6e, 0xd1, 0x49, 0x25, 0xd1, 0x49, 0x15, 0x61, 0x6a, 0xa6, 0x0d, 0x3f, 0x01, 0x19, 0x7f,
	0xd6, 0xd6, 0xd0, 0x01, 0x1b, 0x28, 0x6f, 0x70, 0x13, 0xb8, 0x86, 0x0e, 0x68, 0xcf, 0x11, 0x5a,
	0x1c, 0xb7, 0xe8, 0x52, 0xd1, 0x41, 0x07, 0x42, 0x22, 0x43, 0x49, 0x9e, 0xa1, 0x93, 0xbd, 0x33,
	0xf4, 0x1d, 0x90, 0xf2, 0x7b, 0x81, 0x52, 0x67, 0xe7, 0x51, 0xfc, 0xad, 0xf6, 0xd0, 0x75, 0xe8,
	0x6f, 0xe1, 0x28, 0xac, 0x93, 0xf6, 0xc0, 0x30, 0xdf, 0x6f, 0x94, 0x37, 0xf9, 0x0f, 0x04, 0x4f,
	0xd3, 0xf1, 0xba, 0x79, 0x60, 0x51, 0x9e, 0x97, 0x28, 0xb9, 0x71, 0xe2, 0x02, 0x39, 0xf1, 0x38,
	0xf0, 0x63, 0x7f, 0xfe, 0x19, 0x87, 0x48, 0xa3, 0x6c, 0x1a, 0x8b, 0x79, 0x29, 0x48, 0x1b, 0xe3,
	0x4a, 0x2d, 0x32, 0x16, 0xc9, 0xa2, 0xe2, 0x81, 0x4c, 0xa8, 0x03, 0xdf, 0x05, 0xc9, 0x7b, 0x2e,
	0x72, 0x82, 0xa1, 0xca, 0x10, 0x46, 0x3d, 0x17, 0x39, 0xc2, 0x05, 0x85, 0x08, 0xc1, 0x8f, 0x40,
	0x72, 0x57, 0x6f, 0x06, 0xe9, 0xf6, 0x73, 0x44, 0x16, 0x5c, 0xac, 0x36, 0xed, 0xb6, 0x32, 0xd6,
	0xc5, 0x5e, 0xa1, 0x4a, 0x4a, 0x13, 0x28, 0x84, 0xaf, 0x37, 0xdd, 0x46, 0xe7, 0x3d, 0xf1, 0x3e,
	0xe1, 0x86, 0xbb, 0x74, 0xf8, 0xc3, 0x61, 0x90, 0x24, 0x37, 0x0e, 0xdf, 0x1f, 0x38, 0x0b, 0x52,
	0x7e, 0x66, 0x99, 0xc9, 0xee, 0xd7, 0xe2, 0xd1, 0x6f, 0x4e, 0xe4, 0xa1, 0x87, 0x04, 0x88, 0xdd,
	0x22, 0xea, 0x60, 0x8a, 0x37, 0xe7, 0x93, 0x46, 0x77, 0x4b, 0x57, 0x3a, 0x2c, 0xc5, 0xde, 0x54,
	0x22, 0x46, 0xfe, 0x2a, 0x01, 0x18, 0x65, 0x36, 0xf8, 0x31, 0x18, 0xe2, 0x7e, 0xb2, 0x6b, 0x68,
	0xec, 0xb8, 0x8f, 0xbd, 0x8c, 0xf2, 0xca, 0x70, 0x0d, 0x8c, 0x54, 0xf7, 0x5d, 0xe4, 0x1c, 0x22,
	0x6d, 0x4f, 0x35, 0xbc, 0x80, 0x9d, 0xde, 0x64, 0xc1, 0x96, 0x2d, 0xb6, 0x59, 0x3c, 0x24, 0xbb,
	0xc2, 0x38, 0x16, 0xf4, 0x94, 0x7f, 0x24, 0x04, 0xaf, 0xe0, 0x5d, 0x30, 0x72, 0x47, 0x47, 0x86,
	0x56, 0x75, 0x36, 0x11, 0x76, 0xf4, 0x3a, 0x2b, 0x81, 0x90, 0x82, 0x0f, 0xc8, 0x66, 0xd1, 0x72,
	0x8a, 0x4d, 0xba, 0x2d, 0x20, 0x0b, 0x8a, 0xf0, 0xc7, 0x20, 0x5d, 0xb5, 0x91, 0xa3, 0x62, 0xcb,
	0x61, 0xde, 0xad, 0x9e, 0x3e, 0x96, 0xaf, 0x06, 0xd4, 0xc2, 0x19, 0x9d, 0x5f, 0x36, 0x0c, 0xeb,
	0x21, 0xd2, 0x02, 0x71, 0x37, 0x64, 0x1a, 0x8b, 0xad, 0x08, 0x25, 0x1b, 0x88, 0xc1, 0x05, 0x90,
	0xa2, 0x87, 0x20, 0xc3, 0x8f, 0x8c, 0xf5, 0x90, 0x54, 0xe8, 0xa1, 0xc5, 0xeb, 0xaf, 0x2f, 0xa8,
	0x6c, 0x93, 0xcf, 0x5f, 0xd1, 0x18, 0x04, 0x20, 0x55, 0xf9, 0xcc, 0x53, 0x0d, 0x37, 0xdb, 0x07,
	0x53, 0x20, 0xb1, 0x6e, 0x66, 0x25, 0x38, 0x02, 0x32, 0x5b, 0x16, 0x66, 0xcb, 0x09, 0x98, 0x01,
	0x03, 0x5b, 0x16, 0x5e, 0x37, 0xb3, 0xfd, 0x44, 0x62, 0x0d, 0x67, 0x93, 0xe4, 0xdf, 0x0d, 0x9c,
	0x1d, 0x98, 0x9b, 0x03, 0x23, 0x02, 0x4b, 0xc2, 0x21, 0x30, 0x78, 0x7f, 0xb9, 0xb6, 0xb5, 0xbe,
	0xb5, 0xe6, 0xf3, 0xf1, 0x4a, 0x6d, 0x7d, 0x77, 0x7d, 0x65, 0x79, 0x23, 0x2b, 0x2d, 0xfe, 0x3e,
	0x0d, 0x60, 0x67, 0x8d, 0xee, 0x2d, 0xc0, 0x5f, 0x4b, 0x60, 0x92, 0x54, 0xe5, 0xb2, 0xa6, 0x45,
	0xbe, 0xcd, 0xbb, 0xd6, 0x76, 0xbe, 0xeb, 0x8e, 0xf2, 0xc1, 0x93, 0x63, 0x39, 0x55, 0x77, 0x90,
	0x8a, 0xd1, 0xdf, 0x8f, 0x65, 0xe9, 0x57, 0xff, 0xfa, 0xcf, 0x17, 0x89, 0xb7, 0x40, 0xdf, 0x92,
	0x34, 0xa7, 0x4c, 0x71, 0x17, 0xff, 0x52, 0xe4, 0xbb, 0x16, 0x7e, 0x2e, 0x81, 0x3c, 0xf1, 0x64,
	0x15, 0x19, 0x08, 0xa3, 0x57, 0xe2, 0xcc, 0x0f, 0x89, 0x33, 0x1a, 0xc5, 0x0b, 0x9d, 0xb9, 0x0e,
	0xfa, 0x96, 0xfa, 0xe6, 0xde, 0x7e, 0xa1, 0x2f, 0x64, 0x93, 0x4c, 0xd2, 0x47, 0xf0, 0x37, 0x2c,
	0x3c, 0x6b, 0x08, 0xbf, 0x12, 0x8f, 0x6e, 0x3d, 0x39, 0x96, 0xfb, 0x1b, 0x08, 0x8b, 0xee, 0xc0,
	0x5e, 0xdd, 0x79, 0x2c, 0x81, 0x1c, 0x71, 0x87, 0x7c, 0xd7, 0x44, 0xfc, 0x19, 0x0f, 0x3f, 0x79,
	0x28, 0xa9, 0x54, 0x6d, 0xaa, 0x9c, 0xef, 0xfa, 0xca, 0x41, 0x3f, 0x92, 0xdf, 0x7f, 0x72, 0x2c,
	0x27, 0xc9, 0xa7, 0x4e, 0xe8, 0xd1, 0x15, 0xea, 0xd1, 0xb7, 0x24, 0xeb, 0x0b, 0x96, 0xac, 0x7b,
	0xb6, 0xa6, 0xbe, 0xa2, 0x64, 0x2d, 0x93, 0x64, 0x79, 0x14, 0x2f, 0xf4, 0xa5, 0x48, 0x2b, 0x27,
	0xdf, 0x6b, 0x78, 0x2c, 0x20, 0x13, 0xa7, 0xe8, 0xf1, 0x7b, 0x0d, 0xcf, 0x5c, 0x7b, 0x6a, 0x7d,
	0xdb, 0x28, 0x50, 0x46, 0x9e, 0x1c, 0xcb, 0x03, 0x94, 0x6d, 0x89, 0x87, 0x37, 0xa4, 0xfc, 0x3f,
	0xa5, 0xcf, 0x5b, 0x72, 0xe2, 0x70, 0xe1, 0x4f, 0x2d, 0x39, 0xfa, 0x52, 0xf3, 0x65, 0x4b, 0x8e,
	0xbc, 0x77, 0x9d, 0xb6, 0xe4, 0x5b, 0x31, 0xaf, 0x60, 0x49, 0xdb, 0x72, 0x31, 0xa4, 0x79, 0xc8,
	0xbf, 0x38, 0xf2, 0xa7, 0x2d, 0x79, 0x23, 0x06, 0xa0, 0xdf, 0xf6, 0x30, 0x24, 0x85, 0x05, 0x59,
	0xbd, 0xf7, 0x1a, 0xb3, 0xc5, 0xdf, 0x0e, 0x32, 0x12, 0xf1, 0x27, 0xca, 0xde, 0x02, 0xc4, 0x00,
	0xf2, 0x8c, 0xc0, 0x9e, 0x2f, 0xe2, 0xc6, 0x4f, 0x3e, 0x6e, 0x51, 0xb9, 0x19, 0x43, 0x01, 0x33,
	0x3e, 0x05, 0xc8, 0x11, 0xa7, 0x82, 0x4f, 0x7f, 0xf8, 0x0b, 0x30, 0xde, 0xd1, 0xfd, 0x2f, 0x6d,
	0xf8, 0xfb, 0x31, 0xed, 0x3e, 0x4b, 0xdb, 0x5d, 0xe9, 0x6a, 0xb7, 0x5d, 0x3c, 0x47, 0xfe, 0xb1,
	0x83, 0x4e, 0x7f, 0x69, 0xeb, 0x1f, 0x76, 0xb6, 0x36, 0x35, 0x0d, 0x7b, 0x31, 0xfd, 0x33, 0x30,
	0x26, 0x74, 0x35, 0xb3, 0xdd, 0xa5, 0x62, 0xe3, 0x1e, 0x73, 0x68, 0x2f, 0x2f, 0x44, 0x7a, 0xb9,
	0x40, 0x5d, 0x78, 0x41, 0xd4, 0x7f, 0x29, 0xf9, 0x61, 0xe7, 0xfa, 0xf8, 0xa5, 0x0f, 0x7e, 0x2b,
	0xa6, 0x71, 0xaf, 0xf9, 0x8d, 0xdb, 0xcb, 0xe1, 0x11, 0xb8, 0x28, 0x36, 0xed, 0x8b, 0x4f, 0x7f,
	0x35, 0xae, 0x5f, 0x23, 0x77, 0xa9, 0x68, 0xab, 0xfe, 0xa5, 0xdd, 0xaa, 0xe2, 0xa3, 0xd3, 0x97,
	0x2d, 0x99, 0x7f, 0xa7, 0x3b, 0x6d, 0xc9, 0x37, 0xc5, 0x87, 0x3b, 0xbe, 0x39, 0xbb, 0x87, 0xf2,
	0xb4, 0x25, 0xaf, 0x88, 0x7a, 0xd1, 0x9e, 0xec, 0x21, 0x1c, 0x8b, 0x2e, 0x48, 0xfb, 0xdf, 0xc4,
	0x7b, 0x0b, 0xf9, 0x46, 0xe8, 0x32, 0x7b, 0x43, 0x3f, 0x6d, 0xc9, 0x6f, 0x06, 0x7f, 0x5f, 0xf0,
	0x1d, 0x82, 0x11, 0x48, 0x22, 0x34, 0x1f, 0x08, 0x85, 0x3e, 0xe4, 0x2f, 0x45, 0x05, 0x43, 0xa3,
	0xe5, 0xe1, 0xa7, 0xcf, 0xa7, 0xa5, 0xaf, 0x9f, 0x4f, 0x4b, 0xff, 0x7e, 0x3e, 0x2d, 0x6d, 0x4b,
	0xfb, 0x29, 0xfa, 0xc7, 0x8c, 0xf7, 0xfe, 0x1f, 0x00, 0x00, 0xff, 0xff, 0x41, 0xbd, 0x64, 0x00,
	0x9f, 0x19, 0x00, 0x00,
}
