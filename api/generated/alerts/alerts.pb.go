// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: alerts.proto

/*
	Package alerts is a generated protocol buffer package.

	Service name

	It is generated from these files:
		alerts.proto

	It has these top-level messages:
		Alert
		AlertDestination
		AlertDestinationList
		AlertDestinationSpec
		AlertDestinationStatus
		AlertList
		AlertPolicy
		AlertPolicyList
		AlertPolicySpec
		AlertPolicyStatus
		AlertReason
		AlertSource
		AlertSpec
		AlertStatus
		AuditInfo
		AuthConfig
		AutoMsgAlertDestinationWatchHelper
		AutoMsgAlertPolicyWatchHelper
		AutoMsgAlertWatchHelper
		MatchedRequirement
		PrivacyConfig
		Requirement
		SNMPTrapServer
*/
package alerts

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/pensando/grpc-gateway/third_party/googleapis/google/api"
import _ "github.com/pensando/sw/venice/utils/apigen/annotations"
import _ "github.com/gogo/protobuf/gogoproto"
import api "github.com/pensando/sw/api"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// Severity of an alert
type AlertSeverity int32

const (
	AlertSeverity_WARNING  AlertSeverity = 0
	AlertSeverity_CRITICAL AlertSeverity = 1
)

var AlertSeverity_name = map[int32]string{
	0: "WARNING",
	1: "CRITICAL",
}
var AlertSeverity_value = map[string]int32{
	"WARNING":  0,
	"CRITICAL": 1,
}

func (x AlertSeverity) String() string {
	return proto.EnumName(AlertSeverity_name, int32(x))
}
func (AlertSeverity) EnumDescriptor() ([]byte, []int) { return fileDescriptorAlerts, []int{0} }

// Algos contains the encryption algorithm to be used when SecurityMethod
// has PRIVACY.
type AlertSpec_AlertState int32

const (
	AlertSpec_OPEN         AlertSpec_AlertState = 0
	AlertSpec_RESOLVED     AlertSpec_AlertState = 1
	AlertSpec_ACKNOWLEDGED AlertSpec_AlertState = 2
)

var AlertSpec_AlertState_name = map[int32]string{
	0: "OPEN",
	1: "RESOLVED",
	2: "ACKNOWLEDGED",
}
var AlertSpec_AlertState_value = map[string]int32{
	"OPEN":         0,
	"RESOLVED":     1,
	"ACKNOWLEDGED": 2,
}

func (x AlertSpec_AlertState) String() string {
	return proto.EnumName(AlertSpec_AlertState_name, int32(x))
}
func (AlertSpec_AlertState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorAlerts, []int{12, 0}
}

type AuthConfig_Algos int32

const (
	AuthConfig_MD5  AuthConfig_Algos = 0
	AuthConfig_SHA1 AuthConfig_Algos = 1
)

var AuthConfig_Algos_name = map[int32]string{
	0: "MD5",
	1: "SHA1",
}
var AuthConfig_Algos_value = map[string]int32{
	"MD5":  0,
	"SHA1": 1,
}

func (x AuthConfig_Algos) String() string {
	return proto.EnumName(AuthConfig_Algos_name, int32(x))
}
func (AuthConfig_Algos) EnumDescriptor() ([]byte, []int) { return fileDescriptorAlerts, []int{15, 0} }

type PrivacyConfig_Algos int32

const (
	PrivacyConfig_DES56  PrivacyConfig_Algos = 0
	PrivacyConfig_AES128 PrivacyConfig_Algos = 1
)

var PrivacyConfig_Algos_name = map[int32]string{
	0: "DES56",
	1: "AES128",
}
var PrivacyConfig_Algos_value = map[string]int32{
	"DES56":  0,
	"AES128": 1,
}

func (x PrivacyConfig_Algos) String() string {
	return proto.EnumName(PrivacyConfig_Algos_name, int32(x))
}
func (PrivacyConfig_Algos) EnumDescriptor() ([]byte, []int) { return fileDescriptorAlerts, []int{20, 0} }

type Requirement_AllowedOperators int32

const (
	Requirement_Equals    Requirement_AllowedOperators = 0
	Requirement_In        Requirement_AllowedOperators = 1
	Requirement_NotEquals Requirement_AllowedOperators = 2
	Requirement_NotIn     Requirement_AllowedOperators = 3
	Requirement_Gt        Requirement_AllowedOperators = 4
	Requirement_Lt        Requirement_AllowedOperators = 5
)

var Requirement_AllowedOperators_name = map[int32]string{
	0: "Equals",
	1: "In",
	2: "NotEquals",
	3: "NotIn",
	4: "Gt",
	5: "Lt",
}
var Requirement_AllowedOperators_value = map[string]int32{
	"Equals":    0,
	"In":        1,
	"NotEquals": 2,
	"NotIn":     3,
	"Gt":        4,
	"Lt":        5,
}

func (x Requirement_AllowedOperators) String() string {
	return proto.EnumName(Requirement_AllowedOperators_name, int32(x))
}
func (Requirement_AllowedOperators) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorAlerts, []int{21, 0}
}

type SNMPTrapServer_SNMPVersions int32

const (
	SNMPTrapServer_V2C SNMPTrapServer_SNMPVersions = 0
	SNMPTrapServer_V3  SNMPTrapServer_SNMPVersions = 1
)

var SNMPTrapServer_SNMPVersions_name = map[int32]string{
	0: "V2C",
	1: "V3",
}
var SNMPTrapServer_SNMPVersions_value = map[string]int32{
	"V2C": 0,
	"V3":  1,
}

func (x SNMPTrapServer_SNMPVersions) String() string {
	return proto.EnumName(SNMPTrapServer_SNMPVersions_name, int32(x))
}
func (SNMPTrapServer_SNMPVersions) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorAlerts, []int{22, 0}
}

// Source of an alert; for alerts generated from events, it maps to event.Source
type Alert struct {
	api.TypeMeta   `protobuf:"bytes,1,opt,name=T,embedded=T" json:",inline"`
	api.ObjectMeta `protobuf:"bytes,2,opt,name=O,embedded=O" json:"meta, omitempty"`
	Spec           AlertSpec   `protobuf:"bytes,3,opt,name=Spec" json:"spec, omitempty"`
	Status         AlertStatus `protobuf:"bytes,4,opt,name=Status" json:"status, omitempty"`
}

func (m *Alert) Reset()                    { *m = Alert{} }
func (m *Alert) String() string            { return proto.CompactTextString(m) }
func (*Alert) ProtoMessage()               {}
func (*Alert) Descriptor() ([]byte, []int) { return fileDescriptorAlerts, []int{0} }

func (m *Alert) GetSpec() AlertSpec {
	if m != nil {
		return m.Spec
	}
	return AlertSpec{}
}

func (m *Alert) GetStatus() AlertStatus {
	if m != nil {
		return m.Status
	}
	return AlertStatus{}
}

// One of the requirement from the expression that was met
type AlertDestination struct {
	// Requirement from the alert rule that was met
	api.TypeMeta `protobuf:"bytes,1,opt,name=T,embedded=T" json:",inline"`
	// The value at which the requirement was met.
	// same as Requirement.value for operator `Equals` but could vary for other operators
	// e.g. requirement - CPU;Gt;90 could have a matching value 96
	api.ObjectMeta `protobuf:"bytes,2,opt,name=O,embedded=O" json:"meta, omitempty"`
	Spec           AlertDestinationSpec   `protobuf:"bytes,3,opt,name=Spec" json:"spec, omitempty"`
	Status         AlertDestinationStatus `protobuf:"bytes,4,opt,name=Status" json:"status, omitempty"`
}

func (m *AlertDestination) Reset()                    { *m = AlertDestination{} }
func (m *AlertDestination) String() string            { return proto.CompactTextString(m) }
func (*AlertDestination) ProtoMessage()               {}
func (*AlertDestination) Descriptor() ([]byte, []int) { return fileDescriptorAlerts, []int{1} }

func (m *AlertDestination) GetSpec() AlertDestinationSpec {
	if m != nil {
		return m.Spec
	}
	return AlertDestinationSpec{}
}

func (m *AlertDestination) GetStatus() AlertDestinationStatus {
	if m != nil {
		return m.Status
	}
	return AlertDestinationStatus{}
}

// AlertReason captures all the requirements with matched value from the alert policy rule
// at the time of creating an alert.
// e.g. "matched-requirements": [{"field": "cpu", "operator": "Gt", "values": [90], "observed-value": 95}]
type AlertDestinationList struct {
	// List of requirements from the alert policy with it's matched value
	api.TypeMeta `protobuf:"bytes,2,opt,name=T,embedded=T" json:"T"`
	// Alert Policy ID that matched
	api.ListMeta `protobuf:"bytes,3,opt,name=ListMeta,embedded=ListMeta" json:"ListMeta"`
	Items        []*AlertDestination `protobuf:"bytes,4,rep,name=Items" json:"Items,omitempty"`
}

func (m *AlertDestinationList) Reset()                    { *m = AlertDestinationList{} }
func (m *AlertDestinationList) String() string            { return proto.CompactTextString(m) }
func (*AlertDestinationList) ProtoMessage()               {}
func (*AlertDestinationList) Descriptor() ([]byte, []int) { return fileDescriptorAlerts, []int{2} }

func (m *AlertDestinationList) GetItems() []*AlertDestination {
	if m != nil {
		return m.Items
	}
	return nil
}

// AuditInfo captures the user performed the action and the time at which the
// action was performed.
type AlertDestinationSpec struct {
	// Name of the user performed some action.
	Default bool `protobuf:"varint,1,opt,name=Default,proto3" json:"default, omitempty"`
	// Time at which the action was performed.
	EmailList       []string          `protobuf:"bytes,2,rep,name=EmailList" json:"email-list, omitempty"`
	SNMPTrapServers []*SNMPTrapServer `protobuf:"bytes,3,rep,name=SNMPTrapServers" json:"snmp-trap-servers, omitempty"`
}

func (m *AlertDestinationSpec) Reset()                    { *m = AlertDestinationSpec{} }
func (m *AlertDestinationSpec) String() string            { return proto.CompactTextString(m) }
func (*AlertDestinationSpec) ProtoMessage()               {}
func (*AlertDestinationSpec) Descriptor() ([]byte, []int) { return fileDescriptorAlerts, []int{3} }

func (m *AlertDestinationSpec) GetDefault() bool {
	if m != nil {
		return m.Default
	}
	return false
}

func (m *AlertDestinationSpec) GetEmailList() []string {
	if m != nil {
		return m.EmailList
	}
	return nil
}

func (m *AlertDestinationSpec) GetSNMPTrapServers() []*SNMPTrapServer {
	if m != nil {
		return m.SNMPTrapServers
	}
	return nil
}

// User can change the state of the alert by changing the spec
type AlertDestinationStatus struct {
	TotalNotificationsSent int32 `protobuf:"varint,1,opt,name=totalNotificationsSent,proto3" json:"total-notifications-sent, omitempty"`
}

func (m *AlertDestinationStatus) Reset()                    { *m = AlertDestinationStatus{} }
func (m *AlertDestinationStatus) String() string            { return proto.CompactTextString(m) }
func (*AlertDestinationStatus) ProtoMessage()               {}
func (*AlertDestinationStatus) Descriptor() ([]byte, []int) { return fileDescriptorAlerts, []int{4} }

func (m *AlertDestinationStatus) GetTotalNotificationsSent() int32 {
	if m != nil {
		return m.TotalNotificationsSent
	}
	return 0
}

// Status part of the alert object
type AlertList struct {
	// Severity of an alert
	api.TypeMeta `protobuf:"bytes,2,opt,name=T,embedded=T" json:"T"`
	// Alert source or origin
	api.ListMeta `protobuf:"bytes,3,opt,name=ListMeta,embedded=ListMeta" json:"ListMeta"`
	// Affected object
	Items []*Alert `protobuf:"bytes,4,rep,name=Items" json:"Items,omitempty"`
}

func (m *AlertList) Reset()                    { *m = AlertList{} }
func (m *AlertList) String() string            { return proto.CompactTextString(m) }
func (*AlertList) ProtoMessage()               {}
func (*AlertList) Descriptor() ([]byte, []int) { return fileDescriptorAlerts, []int{5} }

func (m *AlertList) GetItems() []*Alert {
	if m != nil {
		return m.Items
	}
	return nil
}

// Alert defines an alert object
type AlertPolicy struct {
	api.TypeMeta   `protobuf:"bytes,1,opt,name=T,embedded=T" json:",inline"`
	api.ObjectMeta `protobuf:"bytes,2,opt,name=O,embedded=O" json:"meta, omitempty"`
	Spec           AlertPolicySpec   `protobuf:"bytes,3,opt,name=Spec" json:"spec, omitempty"`
	Status         AlertPolicyStatus `protobuf:"bytes,4,opt,name=Status" json:"status, omitempty"`
}

func (m *AlertPolicy) Reset()                    { *m = AlertPolicy{} }
func (m *AlertPolicy) String() string            { return proto.CompactTextString(m) }
func (*AlertPolicy) ProtoMessage()               {}
func (*AlertPolicy) Descriptor() ([]byte, []int) { return fileDescriptorAlerts, []int{6} }

func (m *AlertPolicy) GetSpec() AlertPolicySpec {
	if m != nil {
		return m.Spec
	}
	return AlertPolicySpec{}
}

func (m *AlertPolicy) GetStatus() AlertPolicyStatus {
	if m != nil {
		return m.Status
	}
	return AlertPolicyStatus{}
}

// Requirement specifies each
// {"field": "Status.Phase", "operator":"Equals", "values":["JOINED"]}
type AlertPolicyList struct {
	// name of the field or metric
	api.TypeMeta `protobuf:"bytes,2,opt,name=T,embedded=T" json:"T"`
	api.ListMeta `protobuf:"bytes,3,opt,name=ListMeta,embedded=ListMeta" json:"ListMeta"`
	// Values contains one or more values corresponding to the field-or-metric. "Equals",
	// "NotEquals", "Gt" and "Lt" operators need a single value. "In" and "NotIn" operators
	// can have one or more values.
	Items []*AlertPolicy `protobuf:"bytes,4,rep,name=Items" json:"Items,omitempty"`
}

func (m *AlertPolicyList) Reset()                    { *m = AlertPolicyList{} }
func (m *AlertPolicyList) String() string            { return proto.CompactTextString(m) }
func (*AlertPolicyList) ProtoMessage()               {}
func (*AlertPolicyList) Descriptor() ([]byte, []int) { return fileDescriptorAlerts, []int{7} }

func (m *AlertPolicyList) GetItems() []*AlertPolicy {
	if m != nil {
		return m.Items
	}
	return nil
}

type AlertPolicySpec struct {
	// Resource type - target resource to run this policy.
	// e.g. Network, Endpoint - object based alert policy
	//      Event - event based alert policy
	//      EndpointMetrics - metric based alert policy
	// based on the resource type, the policy gets interpreted.
	Resource string `protobuf:"bytes,1,opt,name=Resource,proto3" json:"resource, omitempty"`
	// Severity to be set for an alert that gets triggered from this rule
	Severity string `protobuf:"bytes,2,opt,name=Severity,proto3" json:"severity, omitempty"`
	// Message to be used while generating the alert
	// XXX: Event based alerts should not carry a message. It will be derived from the event.
	Message string `protobuf:"bytes,3,opt,name=Message,proto3" json:"message, omitempty"`
	// List of requirements that needs to be met to trigger an alert
	Requirements []Requirement `protobuf:"bytes,4,rep,name=Requirements" json:"requirements, omitempty"`
	// Met rule (requirements) needs to sustain for the given duration to qualify to be an alert
	PersistenceDuration string `protobuf:"bytes,5,opt,name=PersistenceDuration,proto3" json:"persistence-duration, omitempty"`
	// Met rule (requirements) needs to be cleared for the given duration to resolve an alert
	ClearDuration string `protobuf:"bytes,6,opt,name=ClearDuration,proto3" json:"clear-duration, omitempty"`
	// User can disable the policy by setting this field.
	// Disabled policies will not generate any more alerts but the outstanding ones will remain as is.
	Enable bool `protobuf:"varint,7,opt,name=Enable,proto3" json:"enable, omitempty"`
	// If set, the underlying alert will be auto-resolved if the rule that
	// triggered the alert is cleared
	AutoResolve bool `protobuf:"varint,8,opt,name=AutoResolve,proto3" json:"auto-resolve, omitempty"`
	// name of the alert destinations to be used to send out notification when an alert
	// gets generated.
	Destinations []string `protobuf:"bytes,9,rep,name=Destinations" json:"destinations, omitempty"`
}

func (m *AlertPolicySpec) Reset()                    { *m = AlertPolicySpec{} }
func (m *AlertPolicySpec) String() string            { return proto.CompactTextString(m) }
func (*AlertPolicySpec) ProtoMessage()               {}
func (*AlertPolicySpec) Descriptor() ([]byte, []int) { return fileDescriptorAlerts, []int{8} }

func (m *AlertPolicySpec) GetResource() string {
	if m != nil {
		return m.Resource
	}
	return ""
}

func (m *AlertPolicySpec) GetSeverity() string {
	if m != nil {
		return m.Severity
	}
	return ""
}

func (m *AlertPolicySpec) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *AlertPolicySpec) GetRequirements() []Requirement {
	if m != nil {
		return m.Requirements
	}
	return nil
}

func (m *AlertPolicySpec) GetPersistenceDuration() string {
	if m != nil {
		return m.PersistenceDuration
	}
	return ""
}

func (m *AlertPolicySpec) GetClearDuration() string {
	if m != nil {
		return m.ClearDuration
	}
	return ""
}

func (m *AlertPolicySpec) GetEnable() bool {
	if m != nil {
		return m.Enable
	}
	return false
}

func (m *AlertPolicySpec) GetAutoResolve() bool {
	if m != nil {
		return m.AutoResolve
	}
	return false
}

func (m *AlertPolicySpec) GetDestinations() []string {
	if m != nil {
		return m.Destinations
	}
	return nil
}

type AlertPolicyStatus struct {
	// Total hits on this policy
	TotalHits int32 `protobuf:"varint,1,opt,name=TotalHits,proto3" json:"total-hits, omitempty"`
	// Open alerts based on this policy
	OpenAlerts int32 `protobuf:"varint,2,opt,name=OpenAlerts,proto3" json:"open-alerts, omitempty"`
	// Acknowledged alerts based on this policy
	AcknowledgedAlerts int32 `protobuf:"varint,3,opt,name=AcknowledgedAlerts,proto3" json:"acknowledged-alerts, omitempty"`
}

func (m *AlertPolicyStatus) Reset()                    { *m = AlertPolicyStatus{} }
func (m *AlertPolicyStatus) String() string            { return proto.CompactTextString(m) }
func (*AlertPolicyStatus) ProtoMessage()               {}
func (*AlertPolicyStatus) Descriptor() ([]byte, []int) { return fileDescriptorAlerts, []int{9} }

func (m *AlertPolicyStatus) GetTotalHits() int32 {
	if m != nil {
		return m.TotalHits
	}
	return 0
}

func (m *AlertPolicyStatus) GetOpenAlerts() int32 {
	if m != nil {
		return m.OpenAlerts
	}
	return 0
}

func (m *AlertPolicyStatus) GetAcknowledgedAlerts() int32 {
	if m != nil {
		return m.AcknowledgedAlerts
	}
	return 0
}

// AlertPolicy - tenant scoped
type AlertReason struct {
	MatchedRequirements []*MatchedRequirement `protobuf:"bytes,1,rep,name=MatchedRequirements" json:"matched-requirements, omitempty"`
	PolicyID            string                `protobuf:"bytes,2,opt,name=PolicyID,proto3" json:"alert-policy-id, omitempty"`
}

func (m *AlertReason) Reset()                    { *m = AlertReason{} }
func (m *AlertReason) String() string            { return proto.CompactTextString(m) }
func (*AlertReason) ProtoMessage()               {}
func (*AlertReason) Descriptor() ([]byte, []int) { return fileDescriptorAlerts, []int{10} }

func (m *AlertReason) GetMatchedRequirements() []*MatchedRequirement {
	if m != nil {
		return m.MatchedRequirements
	}
	return nil
}

func (m *AlertReason) GetPolicyID() string {
	if m != nil {
		return m.PolicyID
	}
	return ""
}

// AuthConfig contains the configuration for SNMP Trap authentication.
type AlertSource struct {
	Component string `protobuf:"bytes,1,opt,name=Component,proto3" json:"component, omitempty"`
	// Password contains the authentication password.
	NodeName string `protobuf:"bytes,2,opt,name=NodeName,proto3" json:"node-name, omitempty"`
}

func (m *AlertSource) Reset()                    { *m = AlertSource{} }
func (m *AlertSource) String() string            { return proto.CompactTextString(m) }
func (*AlertSource) ProtoMessage()               {}
func (*AlertSource) Descriptor() ([]byte, []int) { return fileDescriptorAlerts, []int{11} }

func (m *AlertSource) GetComponent() string {
	if m != nil {
		return m.Component
	}
	return ""
}

func (m *AlertSource) GetNodeName() string {
	if m != nil {
		return m.NodeName
	}
	return ""
}

// PrivacyConfig contains the configuration for SNMP Trap encryption.
type AlertSpec struct {
	State string `protobuf:"bytes,1,opt,name=State,proto3" json:"state, omitempty"`
}

func (m *AlertSpec) Reset()                    { *m = AlertSpec{} }
func (m *AlertSpec) String() string            { return proto.CompactTextString(m) }
func (*AlertSpec) ProtoMessage()               {}
func (*AlertSpec) Descriptor() ([]byte, []int) { return fileDescriptorAlerts, []int{12} }

func (m *AlertSpec) GetState() string {
	if m != nil {
		return m.State
	}
	return ""
}

// SNMPTrapServer contains the configuration for sending SNMP traps to a receiver.
type AlertStatus struct {
	// Host where the trap needs to be sent.
	Severity string `protobuf:"bytes,1,opt,name=Severity,proto3" json:"severity, omitempty"`
	// Port on the Host where the trap needs to be sent, default is 162.
	Source    *AlertSource  `protobuf:"bytes,2,opt,name=Source" json:"source, omitempty"`
	ObjectRef api.ObjectRef `protobuf:"bytes,3,opt,name=ObjectRef" json:"object-ref, omitempty"`
	// CommunityOrUser contains community string for v2c, user for v3.
	Message string `protobuf:"bytes,4,opt,name=Message,proto3" json:"message, omitempty"`
	// AuthConfig contains the configuration for authentication, valid only for v3.
	Reason AlertReason `protobuf:"bytes,5,opt,name=Reason" json:"reason, omitempty"`
	// PrivacyConfig contains the configuration for encryption, valid only for v3.
	Acknowledged *AuditInfo `protobuf:"bytes,6,opt,name=Acknowledged" json:"acknowledged, omitempty"`
	Resolved     *AuditInfo `protobuf:"bytes,7,opt,name=Resolved" json:"resolved, omitempty"`
}

func (m *AlertStatus) Reset()                    { *m = AlertStatus{} }
func (m *AlertStatus) String() string            { return proto.CompactTextString(m) }
func (*AlertStatus) ProtoMessage()               {}
func (*AlertStatus) Descriptor() ([]byte, []int) { return fileDescriptorAlerts, []int{13} }

func (m *AlertStatus) GetSeverity() string {
	if m != nil {
		return m.Severity
	}
	return ""
}

func (m *AlertStatus) GetSource() *AlertSource {
	if m != nil {
		return m.Source
	}
	return nil
}

func (m *AlertStatus) GetObjectRef() api.ObjectRef {
	if m != nil {
		return m.ObjectRef
	}
	return api.ObjectRef{}
}

func (m *AlertStatus) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *AlertStatus) GetReason() AlertReason {
	if m != nil {
		return m.Reason
	}
	return AlertReason{}
}

func (m *AlertStatus) GetAcknowledged() *AuditInfo {
	if m != nil {
		return m.Acknowledged
	}
	return nil
}

func (m *AlertStatus) GetResolved() *AuditInfo {
	if m != nil {
		return m.Resolved
	}
	return nil
}

type AuditInfo struct {
	// If set, this will be the default notification option for the alert policies unless otherwise
	// something else is mentioned.
	User string `protobuf:"bytes,1,opt,name=User,proto3" json:"user, omitempty"`
	// Email notification
	Time *api.Timestamp `protobuf:"bytes,2,opt,name=Time" json:"time, omitempty"`
}

func (m *AuditInfo) Reset()                    { *m = AuditInfo{} }
func (m *AuditInfo) String() string            { return proto.CompactTextString(m) }
func (*AuditInfo) ProtoMessage()               {}
func (*AuditInfo) Descriptor() ([]byte, []int) { return fileDescriptorAlerts, []int{14} }

func (m *AuditInfo) GetUser() string {
	if m != nil {
		return m.User
	}
	return ""
}

func (m *AuditInfo) GetTime() *api.Timestamp {
	if m != nil {
		return m.Time
	}
	return nil
}

type AuthConfig struct {
	// total number of notifications sent using this notification mechanism
	Algo     string `protobuf:"bytes,1,opt,name=Algo,proto3" json:"algo, omitempty"`
	Password string `protobuf:"bytes,2,opt,name=Password,proto3" json:"password, omitempty"`
}

func (m *AuthConfig) Reset()                    { *m = AuthConfig{} }
func (m *AuthConfig) String() string            { return proto.CompactTextString(m) }
func (*AuthConfig) ProtoMessage()               {}
func (*AuthConfig) Descriptor() ([]byte, []int) { return fileDescriptorAlerts, []int{15} }

func (m *AuthConfig) GetAlgo() string {
	if m != nil {
		return m.Algo
	}
	return ""
}

func (m *AuthConfig) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

// AlertDestination - tenant scoped
type AutoMsgAlertDestinationWatchHelper struct {
	Type   string            `protobuf:"bytes,1,opt,name=Type,proto3" json:"Type,omitempty"`
	Object *AlertDestination `protobuf:"bytes,2,opt,name=Object" json:"Object,omitempty"`
}

func (m *AutoMsgAlertDestinationWatchHelper) Reset()         { *m = AutoMsgAlertDestinationWatchHelper{} }
func (m *AutoMsgAlertDestinationWatchHelper) String() string { return proto.CompactTextString(m) }
func (*AutoMsgAlertDestinationWatchHelper) ProtoMessage()    {}
func (*AutoMsgAlertDestinationWatchHelper) Descriptor() ([]byte, []int) {
	return fileDescriptorAlerts, []int{16}
}

func (m *AutoMsgAlertDestinationWatchHelper) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *AutoMsgAlertDestinationWatchHelper) GetObject() *AlertDestination {
	if m != nil {
		return m.Object
	}
	return nil
}

type AutoMsgAlertPolicyWatchHelper struct {
	Type   string       `protobuf:"bytes,1,opt,name=Type,proto3" json:"Type,omitempty"`
	Object *AlertPolicy `protobuf:"bytes,2,opt,name=Object" json:"Object,omitempty"`
}

func (m *AutoMsgAlertPolicyWatchHelper) Reset()         { *m = AutoMsgAlertPolicyWatchHelper{} }
func (m *AutoMsgAlertPolicyWatchHelper) String() string { return proto.CompactTextString(m) }
func (*AutoMsgAlertPolicyWatchHelper) ProtoMessage()    {}
func (*AutoMsgAlertPolicyWatchHelper) Descriptor() ([]byte, []int) {
	return fileDescriptorAlerts, []int{17}
}

func (m *AutoMsgAlertPolicyWatchHelper) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *AutoMsgAlertPolicyWatchHelper) GetObject() *AlertPolicy {
	if m != nil {
		return m.Object
	}
	return nil
}

type AutoMsgAlertWatchHelper struct {
	Type   string `protobuf:"bytes,1,opt,name=Type,proto3" json:"Type,omitempty"`
	Object *Alert `protobuf:"bytes,2,opt,name=Object" json:"Object,omitempty"`
}

func (m *AutoMsgAlertWatchHelper) Reset()                    { *m = AutoMsgAlertWatchHelper{} }
func (m *AutoMsgAlertWatchHelper) String() string            { return proto.CompactTextString(m) }
func (*AutoMsgAlertWatchHelper) ProtoMessage()               {}
func (*AutoMsgAlertWatchHelper) Descriptor() ([]byte, []int) { return fileDescriptorAlerts, []int{18} }

func (m *AutoMsgAlertWatchHelper) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *AutoMsgAlertWatchHelper) GetObject() *Alert {
	if m != nil {
		return m.Object
	}
	return nil
}

type MatchedRequirement struct {
	Requirement   `protobuf:"bytes,1,opt,name=Requirement,embedded=Requirement" json:",inline"`
	ObservedValue string `protobuf:"bytes,2,opt,name=ObservedValue,proto3" json:"observed-value, omitempty"`
}

func (m *MatchedRequirement) Reset()                    { *m = MatchedRequirement{} }
func (m *MatchedRequirement) String() string            { return proto.CompactTextString(m) }
func (*MatchedRequirement) ProtoMessage()               {}
func (*MatchedRequirement) Descriptor() ([]byte, []int) { return fileDescriptorAlerts, []int{19} }

func (m *MatchedRequirement) GetObservedValue() string {
	if m != nil {
		return m.ObservedValue
	}
	return ""
}

type PrivacyConfig struct {
	Algo     string `protobuf:"bytes,1,opt,name=Algo,proto3" json:"algo, omitempty"`
	Password string `protobuf:"bytes,2,opt,name=Password,proto3" json:"password, omitempty"`
}

func (m *PrivacyConfig) Reset()                    { *m = PrivacyConfig{} }
func (m *PrivacyConfig) String() string            { return proto.CompactTextString(m) }
func (*PrivacyConfig) ProtoMessage()               {}
func (*PrivacyConfig) Descriptor() ([]byte, []int) { return fileDescriptorAlerts, []int{20} }

func (m *PrivacyConfig) GetAlgo() string {
	if m != nil {
		return m.Algo
	}
	return ""
}

func (m *PrivacyConfig) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

type Requirement struct {
	FieldOrMetric string   `protobuf:"bytes,1,opt,name=FieldOrMetric,proto3" json:"field-or-metric, omitempty"`
	Operator      string   `protobuf:"bytes,2,opt,name=Operator,proto3" json:"operator, omitempty"`
	Values        []string `protobuf:"bytes,3,rep,name=Values" json:"values, omitempty"`
}

func (m *Requirement) Reset()                    { *m = Requirement{} }
func (m *Requirement) String() string            { return proto.CompactTextString(m) }
func (*Requirement) ProtoMessage()               {}
func (*Requirement) Descriptor() ([]byte, []int) { return fileDescriptorAlerts, []int{21} }

func (m *Requirement) GetFieldOrMetric() string {
	if m != nil {
		return m.FieldOrMetric
	}
	return ""
}

func (m *Requirement) GetOperator() string {
	if m != nil {
		return m.Operator
	}
	return ""
}

func (m *Requirement) GetValues() []string {
	if m != nil {
		return m.Values
	}
	return nil
}

type SNMPTrapServer struct {
	Host            string         `protobuf:"bytes,1,opt,name=Host,proto3" json:"host, omitempty"`
	Port            string         `protobuf:"bytes,2,opt,name=Port,proto3" json:"port, omitempty"`
	Version         string         `protobuf:"bytes,3,opt,name=Version,proto3" json:"version, omitempty"`
	CommunityOrUser string         `protobuf:"bytes,4,opt,name=CommunityOrUser,proto3" json:"community-or-user, omitempty"`
	AuthConfig      *AuthConfig    `protobuf:"bytes,5,opt,name=AuthConfig" json:"auth-config, omitempty"`
	PrivacyConfig   *PrivacyConfig `protobuf:"bytes,6,opt,name=PrivacyConfig" json:"privacy-config, omitempty"`
}

func (m *SNMPTrapServer) Reset()                    { *m = SNMPTrapServer{} }
func (m *SNMPTrapServer) String() string            { return proto.CompactTextString(m) }
func (*SNMPTrapServer) ProtoMessage()               {}
func (*SNMPTrapServer) Descriptor() ([]byte, []int) { return fileDescriptorAlerts, []int{22} }

func (m *SNMPTrapServer) GetHost() string {
	if m != nil {
		return m.Host
	}
	return ""
}

func (m *SNMPTrapServer) GetPort() string {
	if m != nil {
		return m.Port
	}
	return ""
}

func (m *SNMPTrapServer) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *SNMPTrapServer) GetCommunityOrUser() string {
	if m != nil {
		return m.CommunityOrUser
	}
	return ""
}

func (m *SNMPTrapServer) GetAuthConfig() *AuthConfig {
	if m != nil {
		return m.AuthConfig
	}
	return nil
}

func (m *SNMPTrapServer) GetPrivacyConfig() *PrivacyConfig {
	if m != nil {
		return m.PrivacyConfig
	}
	return nil
}

func init() {
	proto.RegisterType((*Alert)(nil), "alerts.Alert")
	proto.RegisterType((*AlertDestination)(nil), "alerts.AlertDestination")
	proto.RegisterType((*AlertDestinationList)(nil), "alerts.AlertDestinationList")
	proto.RegisterType((*AlertDestinationSpec)(nil), "alerts.AlertDestinationSpec")
	proto.RegisterType((*AlertDestinationStatus)(nil), "alerts.AlertDestinationStatus")
	proto.RegisterType((*AlertList)(nil), "alerts.AlertList")
	proto.RegisterType((*AlertPolicy)(nil), "alerts.AlertPolicy")
	proto.RegisterType((*AlertPolicyList)(nil), "alerts.AlertPolicyList")
	proto.RegisterType((*AlertPolicySpec)(nil), "alerts.AlertPolicySpec")
	proto.RegisterType((*AlertPolicyStatus)(nil), "alerts.AlertPolicyStatus")
	proto.RegisterType((*AlertReason)(nil), "alerts.AlertReason")
	proto.RegisterType((*AlertSource)(nil), "alerts.AlertSource")
	proto.RegisterType((*AlertSpec)(nil), "alerts.AlertSpec")
	proto.RegisterType((*AlertStatus)(nil), "alerts.AlertStatus")
	proto.RegisterType((*AuditInfo)(nil), "alerts.AuditInfo")
	proto.RegisterType((*AuthConfig)(nil), "alerts.AuthConfig")
	proto.RegisterType((*AutoMsgAlertDestinationWatchHelper)(nil), "alerts.AutoMsgAlertDestinationWatchHelper")
	proto.RegisterType((*AutoMsgAlertPolicyWatchHelper)(nil), "alerts.AutoMsgAlertPolicyWatchHelper")
	proto.RegisterType((*AutoMsgAlertWatchHelper)(nil), "alerts.AutoMsgAlertWatchHelper")
	proto.RegisterType((*MatchedRequirement)(nil), "alerts.MatchedRequirement")
	proto.RegisterType((*PrivacyConfig)(nil), "alerts.PrivacyConfig")
	proto.RegisterType((*Requirement)(nil), "alerts.Requirement")
	proto.RegisterType((*SNMPTrapServer)(nil), "alerts.SNMPTrapServer")
	proto.RegisterEnum("alerts.AlertSeverity", AlertSeverity_name, AlertSeverity_value)
	proto.RegisterEnum("alerts.AlertSpec_AlertState", AlertSpec_AlertState_name, AlertSpec_AlertState_value)
	proto.RegisterEnum("alerts.AuthConfig_Algos", AuthConfig_Algos_name, AuthConfig_Algos_value)
	proto.RegisterEnum("alerts.PrivacyConfig_Algos", PrivacyConfig_Algos_name, PrivacyConfig_Algos_value)
	proto.RegisterEnum("alerts.Requirement_AllowedOperators", Requirement_AllowedOperators_name, Requirement_AllowedOperators_value)
	proto.RegisterEnum("alerts.SNMPTrapServer_SNMPVersions", SNMPTrapServer_SNMPVersions_name, SNMPTrapServer_SNMPVersions_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for AlertDestinationV1 service

type AlertDestinationV1Client interface {
	AutoAddAlertDestination(ctx context.Context, in *AlertDestination, opts ...grpc.CallOption) (*AlertDestination, error)
	AutoDeleteAlertDestination(ctx context.Context, in *AlertDestination, opts ...grpc.CallOption) (*AlertDestination, error)
	AutoGetAlertDestination(ctx context.Context, in *AlertDestination, opts ...grpc.CallOption) (*AlertDestination, error)
	AutoListAlertDestination(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (*AlertDestinationList, error)
	AutoUpdateAlertDestination(ctx context.Context, in *AlertDestination, opts ...grpc.CallOption) (*AlertDestination, error)
	AutoWatchAlertDestination(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (AlertDestinationV1_AutoWatchAlertDestinationClient, error)
}

type alertDestinationV1Client struct {
	cc *grpc.ClientConn
}

func NewAlertDestinationV1Client(cc *grpc.ClientConn) AlertDestinationV1Client {
	return &alertDestinationV1Client{cc}
}

func (c *alertDestinationV1Client) AutoAddAlertDestination(ctx context.Context, in *AlertDestination, opts ...grpc.CallOption) (*AlertDestination, error) {
	out := new(AlertDestination)
	err := grpc.Invoke(ctx, "/alerts.AlertDestinationV1/AutoAddAlertDestination", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *alertDestinationV1Client) AutoDeleteAlertDestination(ctx context.Context, in *AlertDestination, opts ...grpc.CallOption) (*AlertDestination, error) {
	out := new(AlertDestination)
	err := grpc.Invoke(ctx, "/alerts.AlertDestinationV1/AutoDeleteAlertDestination", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *alertDestinationV1Client) AutoGetAlertDestination(ctx context.Context, in *AlertDestination, opts ...grpc.CallOption) (*AlertDestination, error) {
	out := new(AlertDestination)
	err := grpc.Invoke(ctx, "/alerts.AlertDestinationV1/AutoGetAlertDestination", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *alertDestinationV1Client) AutoListAlertDestination(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (*AlertDestinationList, error) {
	out := new(AlertDestinationList)
	err := grpc.Invoke(ctx, "/alerts.AlertDestinationV1/AutoListAlertDestination", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *alertDestinationV1Client) AutoUpdateAlertDestination(ctx context.Context, in *AlertDestination, opts ...grpc.CallOption) (*AlertDestination, error) {
	out := new(AlertDestination)
	err := grpc.Invoke(ctx, "/alerts.AlertDestinationV1/AutoUpdateAlertDestination", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *alertDestinationV1Client) AutoWatchAlertDestination(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (AlertDestinationV1_AutoWatchAlertDestinationClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_AlertDestinationV1_serviceDesc.Streams[0], c.cc, "/alerts.AlertDestinationV1/AutoWatchAlertDestination", opts...)
	if err != nil {
		return nil, err
	}
	x := &alertDestinationV1AutoWatchAlertDestinationClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type AlertDestinationV1_AutoWatchAlertDestinationClient interface {
	Recv() (*AutoMsgAlertDestinationWatchHelper, error)
	grpc.ClientStream
}

type alertDestinationV1AutoWatchAlertDestinationClient struct {
	grpc.ClientStream
}

func (x *alertDestinationV1AutoWatchAlertDestinationClient) Recv() (*AutoMsgAlertDestinationWatchHelper, error) {
	m := new(AutoMsgAlertDestinationWatchHelper)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for AlertDestinationV1 service

type AlertDestinationV1Server interface {
	AutoAddAlertDestination(context.Context, *AlertDestination) (*AlertDestination, error)
	AutoDeleteAlertDestination(context.Context, *AlertDestination) (*AlertDestination, error)
	AutoGetAlertDestination(context.Context, *AlertDestination) (*AlertDestination, error)
	AutoListAlertDestination(context.Context, *api.ListWatchOptions) (*AlertDestinationList, error)
	AutoUpdateAlertDestination(context.Context, *AlertDestination) (*AlertDestination, error)
	AutoWatchAlertDestination(*api.ListWatchOptions, AlertDestinationV1_AutoWatchAlertDestinationServer) error
}

func RegisterAlertDestinationV1Server(s *grpc.Server, srv AlertDestinationV1Server) {
	s.RegisterService(&_AlertDestinationV1_serviceDesc, srv)
}

func _AlertDestinationV1_AutoAddAlertDestination_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AlertDestination)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AlertDestinationV1Server).AutoAddAlertDestination(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/alerts.AlertDestinationV1/AutoAddAlertDestination",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AlertDestinationV1Server).AutoAddAlertDestination(ctx, req.(*AlertDestination))
	}
	return interceptor(ctx, in, info, handler)
}

func _AlertDestinationV1_AutoDeleteAlertDestination_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AlertDestination)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AlertDestinationV1Server).AutoDeleteAlertDestination(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/alerts.AlertDestinationV1/AutoDeleteAlertDestination",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AlertDestinationV1Server).AutoDeleteAlertDestination(ctx, req.(*AlertDestination))
	}
	return interceptor(ctx, in, info, handler)
}

func _AlertDestinationV1_AutoGetAlertDestination_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AlertDestination)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AlertDestinationV1Server).AutoGetAlertDestination(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/alerts.AlertDestinationV1/AutoGetAlertDestination",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AlertDestinationV1Server).AutoGetAlertDestination(ctx, req.(*AlertDestination))
	}
	return interceptor(ctx, in, info, handler)
}

func _AlertDestinationV1_AutoListAlertDestination_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(api.ListWatchOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AlertDestinationV1Server).AutoListAlertDestination(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/alerts.AlertDestinationV1/AutoListAlertDestination",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AlertDestinationV1Server).AutoListAlertDestination(ctx, req.(*api.ListWatchOptions))
	}
	return interceptor(ctx, in, info, handler)
}

func _AlertDestinationV1_AutoUpdateAlertDestination_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AlertDestination)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AlertDestinationV1Server).AutoUpdateAlertDestination(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/alerts.AlertDestinationV1/AutoUpdateAlertDestination",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AlertDestinationV1Server).AutoUpdateAlertDestination(ctx, req.(*AlertDestination))
	}
	return interceptor(ctx, in, info, handler)
}

func _AlertDestinationV1_AutoWatchAlertDestination_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(api.ListWatchOptions)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AlertDestinationV1Server).AutoWatchAlertDestination(m, &alertDestinationV1AutoWatchAlertDestinationServer{stream})
}

type AlertDestinationV1_AutoWatchAlertDestinationServer interface {
	Send(*AutoMsgAlertDestinationWatchHelper) error
	grpc.ServerStream
}

type alertDestinationV1AutoWatchAlertDestinationServer struct {
	grpc.ServerStream
}

func (x *alertDestinationV1AutoWatchAlertDestinationServer) Send(m *AutoMsgAlertDestinationWatchHelper) error {
	return x.ServerStream.SendMsg(m)
}

var _AlertDestinationV1_serviceDesc = grpc.ServiceDesc{
	ServiceName: "alerts.AlertDestinationV1",
	HandlerType: (*AlertDestinationV1Server)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AutoAddAlertDestination",
			Handler:    _AlertDestinationV1_AutoAddAlertDestination_Handler,
		},
		{
			MethodName: "AutoDeleteAlertDestination",
			Handler:    _AlertDestinationV1_AutoDeleteAlertDestination_Handler,
		},
		{
			MethodName: "AutoGetAlertDestination",
			Handler:    _AlertDestinationV1_AutoGetAlertDestination_Handler,
		},
		{
			MethodName: "AutoListAlertDestination",
			Handler:    _AlertDestinationV1_AutoListAlertDestination_Handler,
		},
		{
			MethodName: "AutoUpdateAlertDestination",
			Handler:    _AlertDestinationV1_AutoUpdateAlertDestination_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "AutoWatchAlertDestination",
			Handler:       _AlertDestinationV1_AutoWatchAlertDestination_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "alerts.proto",
}

// Client API for AlertPolicyV1 service

type AlertPolicyV1Client interface {
	AutoAddAlertPolicy(ctx context.Context, in *AlertPolicy, opts ...grpc.CallOption) (*AlertPolicy, error)
	AutoDeleteAlertPolicy(ctx context.Context, in *AlertPolicy, opts ...grpc.CallOption) (*AlertPolicy, error)
	AutoGetAlertPolicy(ctx context.Context, in *AlertPolicy, opts ...grpc.CallOption) (*AlertPolicy, error)
	AutoListAlertPolicy(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (*AlertPolicyList, error)
	AutoUpdateAlertPolicy(ctx context.Context, in *AlertPolicy, opts ...grpc.CallOption) (*AlertPolicy, error)
	AutoWatchAlertPolicy(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (AlertPolicyV1_AutoWatchAlertPolicyClient, error)
}

type alertPolicyV1Client struct {
	cc *grpc.ClientConn
}

func NewAlertPolicyV1Client(cc *grpc.ClientConn) AlertPolicyV1Client {
	return &alertPolicyV1Client{cc}
}

func (c *alertPolicyV1Client) AutoAddAlertPolicy(ctx context.Context, in *AlertPolicy, opts ...grpc.CallOption) (*AlertPolicy, error) {
	out := new(AlertPolicy)
	err := grpc.Invoke(ctx, "/alerts.AlertPolicyV1/AutoAddAlertPolicy", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *alertPolicyV1Client) AutoDeleteAlertPolicy(ctx context.Context, in *AlertPolicy, opts ...grpc.CallOption) (*AlertPolicy, error) {
	out := new(AlertPolicy)
	err := grpc.Invoke(ctx, "/alerts.AlertPolicyV1/AutoDeleteAlertPolicy", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *alertPolicyV1Client) AutoGetAlertPolicy(ctx context.Context, in *AlertPolicy, opts ...grpc.CallOption) (*AlertPolicy, error) {
	out := new(AlertPolicy)
	err := grpc.Invoke(ctx, "/alerts.AlertPolicyV1/AutoGetAlertPolicy", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *alertPolicyV1Client) AutoListAlertPolicy(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (*AlertPolicyList, error) {
	out := new(AlertPolicyList)
	err := grpc.Invoke(ctx, "/alerts.AlertPolicyV1/AutoListAlertPolicy", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *alertPolicyV1Client) AutoUpdateAlertPolicy(ctx context.Context, in *AlertPolicy, opts ...grpc.CallOption) (*AlertPolicy, error) {
	out := new(AlertPolicy)
	err := grpc.Invoke(ctx, "/alerts.AlertPolicyV1/AutoUpdateAlertPolicy", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *alertPolicyV1Client) AutoWatchAlertPolicy(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (AlertPolicyV1_AutoWatchAlertPolicyClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_AlertPolicyV1_serviceDesc.Streams[0], c.cc, "/alerts.AlertPolicyV1/AutoWatchAlertPolicy", opts...)
	if err != nil {
		return nil, err
	}
	x := &alertPolicyV1AutoWatchAlertPolicyClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type AlertPolicyV1_AutoWatchAlertPolicyClient interface {
	Recv() (*AutoMsgAlertPolicyWatchHelper, error)
	grpc.ClientStream
}

type alertPolicyV1AutoWatchAlertPolicyClient struct {
	grpc.ClientStream
}

func (x *alertPolicyV1AutoWatchAlertPolicyClient) Recv() (*AutoMsgAlertPolicyWatchHelper, error) {
	m := new(AutoMsgAlertPolicyWatchHelper)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for AlertPolicyV1 service

type AlertPolicyV1Server interface {
	AutoAddAlertPolicy(context.Context, *AlertPolicy) (*AlertPolicy, error)
	AutoDeleteAlertPolicy(context.Context, *AlertPolicy) (*AlertPolicy, error)
	AutoGetAlertPolicy(context.Context, *AlertPolicy) (*AlertPolicy, error)
	AutoListAlertPolicy(context.Context, *api.ListWatchOptions) (*AlertPolicyList, error)
	AutoUpdateAlertPolicy(context.Context, *AlertPolicy) (*AlertPolicy, error)
	AutoWatchAlertPolicy(*api.ListWatchOptions, AlertPolicyV1_AutoWatchAlertPolicyServer) error
}

func RegisterAlertPolicyV1Server(s *grpc.Server, srv AlertPolicyV1Server) {
	s.RegisterService(&_AlertPolicyV1_serviceDesc, srv)
}

func _AlertPolicyV1_AutoAddAlertPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AlertPolicy)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AlertPolicyV1Server).AutoAddAlertPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/alerts.AlertPolicyV1/AutoAddAlertPolicy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AlertPolicyV1Server).AutoAddAlertPolicy(ctx, req.(*AlertPolicy))
	}
	return interceptor(ctx, in, info, handler)
}

func _AlertPolicyV1_AutoDeleteAlertPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AlertPolicy)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AlertPolicyV1Server).AutoDeleteAlertPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/alerts.AlertPolicyV1/AutoDeleteAlertPolicy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AlertPolicyV1Server).AutoDeleteAlertPolicy(ctx, req.(*AlertPolicy))
	}
	return interceptor(ctx, in, info, handler)
}

func _AlertPolicyV1_AutoGetAlertPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AlertPolicy)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AlertPolicyV1Server).AutoGetAlertPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/alerts.AlertPolicyV1/AutoGetAlertPolicy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AlertPolicyV1Server).AutoGetAlertPolicy(ctx, req.(*AlertPolicy))
	}
	return interceptor(ctx, in, info, handler)
}

func _AlertPolicyV1_AutoListAlertPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(api.ListWatchOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AlertPolicyV1Server).AutoListAlertPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/alerts.AlertPolicyV1/AutoListAlertPolicy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AlertPolicyV1Server).AutoListAlertPolicy(ctx, req.(*api.ListWatchOptions))
	}
	return interceptor(ctx, in, info, handler)
}

func _AlertPolicyV1_AutoUpdateAlertPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AlertPolicy)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AlertPolicyV1Server).AutoUpdateAlertPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/alerts.AlertPolicyV1/AutoUpdateAlertPolicy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AlertPolicyV1Server).AutoUpdateAlertPolicy(ctx, req.(*AlertPolicy))
	}
	return interceptor(ctx, in, info, handler)
}

func _AlertPolicyV1_AutoWatchAlertPolicy_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(api.ListWatchOptions)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AlertPolicyV1Server).AutoWatchAlertPolicy(m, &alertPolicyV1AutoWatchAlertPolicyServer{stream})
}

type AlertPolicyV1_AutoWatchAlertPolicyServer interface {
	Send(*AutoMsgAlertPolicyWatchHelper) error
	grpc.ServerStream
}

type alertPolicyV1AutoWatchAlertPolicyServer struct {
	grpc.ServerStream
}

func (x *alertPolicyV1AutoWatchAlertPolicyServer) Send(m *AutoMsgAlertPolicyWatchHelper) error {
	return x.ServerStream.SendMsg(m)
}

var _AlertPolicyV1_serviceDesc = grpc.ServiceDesc{
	ServiceName: "alerts.AlertPolicyV1",
	HandlerType: (*AlertPolicyV1Server)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AutoAddAlertPolicy",
			Handler:    _AlertPolicyV1_AutoAddAlertPolicy_Handler,
		},
		{
			MethodName: "AutoDeleteAlertPolicy",
			Handler:    _AlertPolicyV1_AutoDeleteAlertPolicy_Handler,
		},
		{
			MethodName: "AutoGetAlertPolicy",
			Handler:    _AlertPolicyV1_AutoGetAlertPolicy_Handler,
		},
		{
			MethodName: "AutoListAlertPolicy",
			Handler:    _AlertPolicyV1_AutoListAlertPolicy_Handler,
		},
		{
			MethodName: "AutoUpdateAlertPolicy",
			Handler:    _AlertPolicyV1_AutoUpdateAlertPolicy_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "AutoWatchAlertPolicy",
			Handler:       _AlertPolicyV1_AutoWatchAlertPolicy_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "alerts.proto",
}

// Client API for AlertsV1 service

type AlertsV1Client interface {
	AutoAddAlert(ctx context.Context, in *Alert, opts ...grpc.CallOption) (*Alert, error)
	AutoDeleteAlert(ctx context.Context, in *Alert, opts ...grpc.CallOption) (*Alert, error)
	AutoGetAlert(ctx context.Context, in *Alert, opts ...grpc.CallOption) (*Alert, error)
	AutoListAlert(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (*AlertList, error)
	AutoUpdateAlert(ctx context.Context, in *Alert, opts ...grpc.CallOption) (*Alert, error)
	AutoWatchAlert(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (AlertsV1_AutoWatchAlertClient, error)
}

type alertsV1Client struct {
	cc *grpc.ClientConn
}

func NewAlertsV1Client(cc *grpc.ClientConn) AlertsV1Client {
	return &alertsV1Client{cc}
}

func (c *alertsV1Client) AutoAddAlert(ctx context.Context, in *Alert, opts ...grpc.CallOption) (*Alert, error) {
	out := new(Alert)
	err := grpc.Invoke(ctx, "/alerts.AlertsV1/AutoAddAlert", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *alertsV1Client) AutoDeleteAlert(ctx context.Context, in *Alert, opts ...grpc.CallOption) (*Alert, error) {
	out := new(Alert)
	err := grpc.Invoke(ctx, "/alerts.AlertsV1/AutoDeleteAlert", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *alertsV1Client) AutoGetAlert(ctx context.Context, in *Alert, opts ...grpc.CallOption) (*Alert, error) {
	out := new(Alert)
	err := grpc.Invoke(ctx, "/alerts.AlertsV1/AutoGetAlert", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *alertsV1Client) AutoListAlert(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (*AlertList, error) {
	out := new(AlertList)
	err := grpc.Invoke(ctx, "/alerts.AlertsV1/AutoListAlert", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *alertsV1Client) AutoUpdateAlert(ctx context.Context, in *Alert, opts ...grpc.CallOption) (*Alert, error) {
	out := new(Alert)
	err := grpc.Invoke(ctx, "/alerts.AlertsV1/AutoUpdateAlert", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *alertsV1Client) AutoWatchAlert(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (AlertsV1_AutoWatchAlertClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_AlertsV1_serviceDesc.Streams[0], c.cc, "/alerts.AlertsV1/AutoWatchAlert", opts...)
	if err != nil {
		return nil, err
	}
	x := &alertsV1AutoWatchAlertClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type AlertsV1_AutoWatchAlertClient interface {
	Recv() (*AutoMsgAlertWatchHelper, error)
	grpc.ClientStream
}

type alertsV1AutoWatchAlertClient struct {
	grpc.ClientStream
}

func (x *alertsV1AutoWatchAlertClient) Recv() (*AutoMsgAlertWatchHelper, error) {
	m := new(AutoMsgAlertWatchHelper)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for AlertsV1 service

type AlertsV1Server interface {
	AutoAddAlert(context.Context, *Alert) (*Alert, error)
	AutoDeleteAlert(context.Context, *Alert) (*Alert, error)
	AutoGetAlert(context.Context, *Alert) (*Alert, error)
	AutoListAlert(context.Context, *api.ListWatchOptions) (*AlertList, error)
	AutoUpdateAlert(context.Context, *Alert) (*Alert, error)
	AutoWatchAlert(*api.ListWatchOptions, AlertsV1_AutoWatchAlertServer) error
}

func RegisterAlertsV1Server(s *grpc.Server, srv AlertsV1Server) {
	s.RegisterService(&_AlertsV1_serviceDesc, srv)
}

func _AlertsV1_AutoAddAlert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Alert)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AlertsV1Server).AutoAddAlert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/alerts.AlertsV1/AutoAddAlert",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AlertsV1Server).AutoAddAlert(ctx, req.(*Alert))
	}
	return interceptor(ctx, in, info, handler)
}

func _AlertsV1_AutoDeleteAlert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Alert)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AlertsV1Server).AutoDeleteAlert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/alerts.AlertsV1/AutoDeleteAlert",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AlertsV1Server).AutoDeleteAlert(ctx, req.(*Alert))
	}
	return interceptor(ctx, in, info, handler)
}

func _AlertsV1_AutoGetAlert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Alert)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AlertsV1Server).AutoGetAlert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/alerts.AlertsV1/AutoGetAlert",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AlertsV1Server).AutoGetAlert(ctx, req.(*Alert))
	}
	return interceptor(ctx, in, info, handler)
}

func _AlertsV1_AutoListAlert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(api.ListWatchOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AlertsV1Server).AutoListAlert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/alerts.AlertsV1/AutoListAlert",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AlertsV1Server).AutoListAlert(ctx, req.(*api.ListWatchOptions))
	}
	return interceptor(ctx, in, info, handler)
}

func _AlertsV1_AutoUpdateAlert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Alert)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AlertsV1Server).AutoUpdateAlert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/alerts.AlertsV1/AutoUpdateAlert",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AlertsV1Server).AutoUpdateAlert(ctx, req.(*Alert))
	}
	return interceptor(ctx, in, info, handler)
}

func _AlertsV1_AutoWatchAlert_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(api.ListWatchOptions)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AlertsV1Server).AutoWatchAlert(m, &alertsV1AutoWatchAlertServer{stream})
}

type AlertsV1_AutoWatchAlertServer interface {
	Send(*AutoMsgAlertWatchHelper) error
	grpc.ServerStream
}

type alertsV1AutoWatchAlertServer struct {
	grpc.ServerStream
}

func (x *alertsV1AutoWatchAlertServer) Send(m *AutoMsgAlertWatchHelper) error {
	return x.ServerStream.SendMsg(m)
}

var _AlertsV1_serviceDesc = grpc.ServiceDesc{
	ServiceName: "alerts.AlertsV1",
	HandlerType: (*AlertsV1Server)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AutoAddAlert",
			Handler:    _AlertsV1_AutoAddAlert_Handler,
		},
		{
			MethodName: "AutoDeleteAlert",
			Handler:    _AlertsV1_AutoDeleteAlert_Handler,
		},
		{
			MethodName: "AutoGetAlert",
			Handler:    _AlertsV1_AutoGetAlert_Handler,
		},
		{
			MethodName: "AutoListAlert",
			Handler:    _AlertsV1_AutoListAlert_Handler,
		},
		{
			MethodName: "AutoUpdateAlert",
			Handler:    _AlertsV1_AutoUpdateAlert_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "AutoWatchAlert",
			Handler:       _AlertsV1_AutoWatchAlert_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "alerts.proto",
}

func (m *Alert) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Alert) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintAlerts(dAtA, i, uint64(m.TypeMeta.Size()))
	n1, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n1
	dAtA[i] = 0x12
	i++
	i = encodeVarintAlerts(dAtA, i, uint64(m.ObjectMeta.Size()))
	n2, err := m.ObjectMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n2
	dAtA[i] = 0x1a
	i++
	i = encodeVarintAlerts(dAtA, i, uint64(m.Spec.Size()))
	n3, err := m.Spec.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n3
	dAtA[i] = 0x22
	i++
	i = encodeVarintAlerts(dAtA, i, uint64(m.Status.Size()))
	n4, err := m.Status.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n4
	return i, nil
}

func (m *AlertDestination) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AlertDestination) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintAlerts(dAtA, i, uint64(m.TypeMeta.Size()))
	n5, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n5
	dAtA[i] = 0x12
	i++
	i = encodeVarintAlerts(dAtA, i, uint64(m.ObjectMeta.Size()))
	n6, err := m.ObjectMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n6
	dAtA[i] = 0x1a
	i++
	i = encodeVarintAlerts(dAtA, i, uint64(m.Spec.Size()))
	n7, err := m.Spec.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n7
	dAtA[i] = 0x22
	i++
	i = encodeVarintAlerts(dAtA, i, uint64(m.Status.Size()))
	n8, err := m.Status.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n8
	return i, nil
}

func (m *AlertDestinationList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AlertDestinationList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x12
	i++
	i = encodeVarintAlerts(dAtA, i, uint64(m.TypeMeta.Size()))
	n9, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n9
	dAtA[i] = 0x1a
	i++
	i = encodeVarintAlerts(dAtA, i, uint64(m.ListMeta.Size()))
	n10, err := m.ListMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n10
	if len(m.Items) > 0 {
		for _, msg := range m.Items {
			dAtA[i] = 0x22
			i++
			i = encodeVarintAlerts(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *AlertDestinationSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AlertDestinationSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Default {
		dAtA[i] = 0x8
		i++
		if m.Default {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.EmailList) > 0 {
		for _, s := range m.EmailList {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.SNMPTrapServers) > 0 {
		for _, msg := range m.SNMPTrapServers {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintAlerts(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *AlertDestinationStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AlertDestinationStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TotalNotificationsSent != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(m.TotalNotificationsSent))
	}
	return i, nil
}

func (m *AlertList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AlertList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x12
	i++
	i = encodeVarintAlerts(dAtA, i, uint64(m.TypeMeta.Size()))
	n11, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n11
	dAtA[i] = 0x1a
	i++
	i = encodeVarintAlerts(dAtA, i, uint64(m.ListMeta.Size()))
	n12, err := m.ListMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n12
	if len(m.Items) > 0 {
		for _, msg := range m.Items {
			dAtA[i] = 0x22
			i++
			i = encodeVarintAlerts(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *AlertPolicy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AlertPolicy) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintAlerts(dAtA, i, uint64(m.TypeMeta.Size()))
	n13, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n13
	dAtA[i] = 0x12
	i++
	i = encodeVarintAlerts(dAtA, i, uint64(m.ObjectMeta.Size()))
	n14, err := m.ObjectMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n14
	dAtA[i] = 0x1a
	i++
	i = encodeVarintAlerts(dAtA, i, uint64(m.Spec.Size()))
	n15, err := m.Spec.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n15
	dAtA[i] = 0x22
	i++
	i = encodeVarintAlerts(dAtA, i, uint64(m.Status.Size()))
	n16, err := m.Status.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n16
	return i, nil
}

func (m *AlertPolicyList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AlertPolicyList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x12
	i++
	i = encodeVarintAlerts(dAtA, i, uint64(m.TypeMeta.Size()))
	n17, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n17
	dAtA[i] = 0x1a
	i++
	i = encodeVarintAlerts(dAtA, i, uint64(m.ListMeta.Size()))
	n18, err := m.ListMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n18
	if len(m.Items) > 0 {
		for _, msg := range m.Items {
			dAtA[i] = 0x22
			i++
			i = encodeVarintAlerts(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *AlertPolicySpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AlertPolicySpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Resource) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(len(m.Resource)))
		i += copy(dAtA[i:], m.Resource)
	}
	if len(m.Severity) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(len(m.Severity)))
		i += copy(dAtA[i:], m.Severity)
	}
	if len(m.Message) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	if len(m.Requirements) > 0 {
		for _, msg := range m.Requirements {
			dAtA[i] = 0x22
			i++
			i = encodeVarintAlerts(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.PersistenceDuration) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(len(m.PersistenceDuration)))
		i += copy(dAtA[i:], m.PersistenceDuration)
	}
	if len(m.ClearDuration) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(len(m.ClearDuration)))
		i += copy(dAtA[i:], m.ClearDuration)
	}
	if m.Enable {
		dAtA[i] = 0x38
		i++
		if m.Enable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.AutoResolve {
		dAtA[i] = 0x40
		i++
		if m.AutoResolve {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Destinations) > 0 {
		for _, s := range m.Destinations {
			dAtA[i] = 0x4a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *AlertPolicyStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AlertPolicyStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TotalHits != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(m.TotalHits))
	}
	if m.OpenAlerts != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(m.OpenAlerts))
	}
	if m.AcknowledgedAlerts != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(m.AcknowledgedAlerts))
	}
	return i, nil
}

func (m *AlertReason) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AlertReason) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.MatchedRequirements) > 0 {
		for _, msg := range m.MatchedRequirements {
			dAtA[i] = 0xa
			i++
			i = encodeVarintAlerts(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.PolicyID) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(len(m.PolicyID)))
		i += copy(dAtA[i:], m.PolicyID)
	}
	return i, nil
}

func (m *AlertSource) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AlertSource) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Component) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(len(m.Component)))
		i += copy(dAtA[i:], m.Component)
	}
	if len(m.NodeName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(len(m.NodeName)))
		i += copy(dAtA[i:], m.NodeName)
	}
	return i, nil
}

func (m *AlertSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AlertSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.State) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(len(m.State)))
		i += copy(dAtA[i:], m.State)
	}
	return i, nil
}

func (m *AlertStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AlertStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Severity) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(len(m.Severity)))
		i += copy(dAtA[i:], m.Severity)
	}
	if m.Source != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(m.Source.Size()))
		n19, err := m.Source.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	dAtA[i] = 0x1a
	i++
	i = encodeVarintAlerts(dAtA, i, uint64(m.ObjectRef.Size()))
	n20, err := m.ObjectRef.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n20
	if len(m.Message) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	dAtA[i] = 0x2a
	i++
	i = encodeVarintAlerts(dAtA, i, uint64(m.Reason.Size()))
	n21, err := m.Reason.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n21
	if m.Acknowledged != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(m.Acknowledged.Size()))
		n22, err := m.Acknowledged.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	if m.Resolved != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(m.Resolved.Size()))
		n23, err := m.Resolved.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	return i, nil
}

func (m *AuditInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuditInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.User) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(len(m.User)))
		i += copy(dAtA[i:], m.User)
	}
	if m.Time != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(m.Time.Size()))
		n24, err := m.Time.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	return i, nil
}

func (m *AuthConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuthConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Algo) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(len(m.Algo)))
		i += copy(dAtA[i:], m.Algo)
	}
	if len(m.Password) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(len(m.Password)))
		i += copy(dAtA[i:], m.Password)
	}
	return i, nil
}

func (m *AutoMsgAlertDestinationWatchHelper) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AutoMsgAlertDestinationWatchHelper) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if m.Object != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(m.Object.Size()))
		n25, err := m.Object.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	return i, nil
}

func (m *AutoMsgAlertPolicyWatchHelper) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AutoMsgAlertPolicyWatchHelper) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if m.Object != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(m.Object.Size()))
		n26, err := m.Object.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n26
	}
	return i, nil
}

func (m *AutoMsgAlertWatchHelper) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AutoMsgAlertWatchHelper) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if m.Object != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(m.Object.Size()))
		n27, err := m.Object.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n27
	}
	return i, nil
}

func (m *MatchedRequirement) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MatchedRequirement) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintAlerts(dAtA, i, uint64(m.Requirement.Size()))
	n28, err := m.Requirement.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n28
	if len(m.ObservedValue) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(len(m.ObservedValue)))
		i += copy(dAtA[i:], m.ObservedValue)
	}
	return i, nil
}

func (m *PrivacyConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PrivacyConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Algo) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(len(m.Algo)))
		i += copy(dAtA[i:], m.Algo)
	}
	if len(m.Password) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(len(m.Password)))
		i += copy(dAtA[i:], m.Password)
	}
	return i, nil
}

func (m *Requirement) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Requirement) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.FieldOrMetric) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(len(m.FieldOrMetric)))
		i += copy(dAtA[i:], m.FieldOrMetric)
	}
	if len(m.Operator) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(len(m.Operator)))
		i += copy(dAtA[i:], m.Operator)
	}
	if len(m.Values) > 0 {
		for _, s := range m.Values {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *SNMPTrapServer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SNMPTrapServer) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Host) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(len(m.Host)))
		i += copy(dAtA[i:], m.Host)
	}
	if len(m.Port) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(len(m.Port)))
		i += copy(dAtA[i:], m.Port)
	}
	if len(m.Version) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(len(m.Version)))
		i += copy(dAtA[i:], m.Version)
	}
	if len(m.CommunityOrUser) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(len(m.CommunityOrUser)))
		i += copy(dAtA[i:], m.CommunityOrUser)
	}
	if m.AuthConfig != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(m.AuthConfig.Size()))
		n29, err := m.AuthConfig.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n29
	}
	if m.PrivacyConfig != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(m.PrivacyConfig.Size()))
		n30, err := m.PrivacyConfig.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n30
	}
	return i, nil
}

func encodeVarintAlerts(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Alert) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovAlerts(uint64(l))
	l = m.ObjectMeta.Size()
	n += 1 + l + sovAlerts(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovAlerts(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovAlerts(uint64(l))
	return n
}

func (m *AlertDestination) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovAlerts(uint64(l))
	l = m.ObjectMeta.Size()
	n += 1 + l + sovAlerts(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovAlerts(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovAlerts(uint64(l))
	return n
}

func (m *AlertDestinationList) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovAlerts(uint64(l))
	l = m.ListMeta.Size()
	n += 1 + l + sovAlerts(uint64(l))
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovAlerts(uint64(l))
		}
	}
	return n
}

func (m *AlertDestinationSpec) Size() (n int) {
	var l int
	_ = l
	if m.Default {
		n += 2
	}
	if len(m.EmailList) > 0 {
		for _, s := range m.EmailList {
			l = len(s)
			n += 1 + l + sovAlerts(uint64(l))
		}
	}
	if len(m.SNMPTrapServers) > 0 {
		for _, e := range m.SNMPTrapServers {
			l = e.Size()
			n += 1 + l + sovAlerts(uint64(l))
		}
	}
	return n
}

func (m *AlertDestinationStatus) Size() (n int) {
	var l int
	_ = l
	if m.TotalNotificationsSent != 0 {
		n += 1 + sovAlerts(uint64(m.TotalNotificationsSent))
	}
	return n
}

func (m *AlertList) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovAlerts(uint64(l))
	l = m.ListMeta.Size()
	n += 1 + l + sovAlerts(uint64(l))
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovAlerts(uint64(l))
		}
	}
	return n
}

func (m *AlertPolicy) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovAlerts(uint64(l))
	l = m.ObjectMeta.Size()
	n += 1 + l + sovAlerts(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovAlerts(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovAlerts(uint64(l))
	return n
}

func (m *AlertPolicyList) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovAlerts(uint64(l))
	l = m.ListMeta.Size()
	n += 1 + l + sovAlerts(uint64(l))
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovAlerts(uint64(l))
		}
	}
	return n
}

func (m *AlertPolicySpec) Size() (n int) {
	var l int
	_ = l
	l = len(m.Resource)
	if l > 0 {
		n += 1 + l + sovAlerts(uint64(l))
	}
	l = len(m.Severity)
	if l > 0 {
		n += 1 + l + sovAlerts(uint64(l))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovAlerts(uint64(l))
	}
	if len(m.Requirements) > 0 {
		for _, e := range m.Requirements {
			l = e.Size()
			n += 1 + l + sovAlerts(uint64(l))
		}
	}
	l = len(m.PersistenceDuration)
	if l > 0 {
		n += 1 + l + sovAlerts(uint64(l))
	}
	l = len(m.ClearDuration)
	if l > 0 {
		n += 1 + l + sovAlerts(uint64(l))
	}
	if m.Enable {
		n += 2
	}
	if m.AutoResolve {
		n += 2
	}
	if len(m.Destinations) > 0 {
		for _, s := range m.Destinations {
			l = len(s)
			n += 1 + l + sovAlerts(uint64(l))
		}
	}
	return n
}

func (m *AlertPolicyStatus) Size() (n int) {
	var l int
	_ = l
	if m.TotalHits != 0 {
		n += 1 + sovAlerts(uint64(m.TotalHits))
	}
	if m.OpenAlerts != 0 {
		n += 1 + sovAlerts(uint64(m.OpenAlerts))
	}
	if m.AcknowledgedAlerts != 0 {
		n += 1 + sovAlerts(uint64(m.AcknowledgedAlerts))
	}
	return n
}

func (m *AlertReason) Size() (n int) {
	var l int
	_ = l
	if len(m.MatchedRequirements) > 0 {
		for _, e := range m.MatchedRequirements {
			l = e.Size()
			n += 1 + l + sovAlerts(uint64(l))
		}
	}
	l = len(m.PolicyID)
	if l > 0 {
		n += 1 + l + sovAlerts(uint64(l))
	}
	return n
}

func (m *AlertSource) Size() (n int) {
	var l int
	_ = l
	l = len(m.Component)
	if l > 0 {
		n += 1 + l + sovAlerts(uint64(l))
	}
	l = len(m.NodeName)
	if l > 0 {
		n += 1 + l + sovAlerts(uint64(l))
	}
	return n
}

func (m *AlertSpec) Size() (n int) {
	var l int
	_ = l
	l = len(m.State)
	if l > 0 {
		n += 1 + l + sovAlerts(uint64(l))
	}
	return n
}

func (m *AlertStatus) Size() (n int) {
	var l int
	_ = l
	l = len(m.Severity)
	if l > 0 {
		n += 1 + l + sovAlerts(uint64(l))
	}
	if m.Source != nil {
		l = m.Source.Size()
		n += 1 + l + sovAlerts(uint64(l))
	}
	l = m.ObjectRef.Size()
	n += 1 + l + sovAlerts(uint64(l))
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovAlerts(uint64(l))
	}
	l = m.Reason.Size()
	n += 1 + l + sovAlerts(uint64(l))
	if m.Acknowledged != nil {
		l = m.Acknowledged.Size()
		n += 1 + l + sovAlerts(uint64(l))
	}
	if m.Resolved != nil {
		l = m.Resolved.Size()
		n += 1 + l + sovAlerts(uint64(l))
	}
	return n
}

func (m *AuditInfo) Size() (n int) {
	var l int
	_ = l
	l = len(m.User)
	if l > 0 {
		n += 1 + l + sovAlerts(uint64(l))
	}
	if m.Time != nil {
		l = m.Time.Size()
		n += 1 + l + sovAlerts(uint64(l))
	}
	return n
}

func (m *AuthConfig) Size() (n int) {
	var l int
	_ = l
	l = len(m.Algo)
	if l > 0 {
		n += 1 + l + sovAlerts(uint64(l))
	}
	l = len(m.Password)
	if l > 0 {
		n += 1 + l + sovAlerts(uint64(l))
	}
	return n
}

func (m *AutoMsgAlertDestinationWatchHelper) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovAlerts(uint64(l))
	}
	if m.Object != nil {
		l = m.Object.Size()
		n += 1 + l + sovAlerts(uint64(l))
	}
	return n
}

func (m *AutoMsgAlertPolicyWatchHelper) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovAlerts(uint64(l))
	}
	if m.Object != nil {
		l = m.Object.Size()
		n += 1 + l + sovAlerts(uint64(l))
	}
	return n
}

func (m *AutoMsgAlertWatchHelper) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovAlerts(uint64(l))
	}
	if m.Object != nil {
		l = m.Object.Size()
		n += 1 + l + sovAlerts(uint64(l))
	}
	return n
}

func (m *MatchedRequirement) Size() (n int) {
	var l int
	_ = l
	l = m.Requirement.Size()
	n += 1 + l + sovAlerts(uint64(l))
	l = len(m.ObservedValue)
	if l > 0 {
		n += 1 + l + sovAlerts(uint64(l))
	}
	return n
}

func (m *PrivacyConfig) Size() (n int) {
	var l int
	_ = l
	l = len(m.Algo)
	if l > 0 {
		n += 1 + l + sovAlerts(uint64(l))
	}
	l = len(m.Password)
	if l > 0 {
		n += 1 + l + sovAlerts(uint64(l))
	}
	return n
}

func (m *Requirement) Size() (n int) {
	var l int
	_ = l
	l = len(m.FieldOrMetric)
	if l > 0 {
		n += 1 + l + sovAlerts(uint64(l))
	}
	l = len(m.Operator)
	if l > 0 {
		n += 1 + l + sovAlerts(uint64(l))
	}
	if len(m.Values) > 0 {
		for _, s := range m.Values {
			l = len(s)
			n += 1 + l + sovAlerts(uint64(l))
		}
	}
	return n
}

func (m *SNMPTrapServer) Size() (n int) {
	var l int
	_ = l
	l = len(m.Host)
	if l > 0 {
		n += 1 + l + sovAlerts(uint64(l))
	}
	l = len(m.Port)
	if l > 0 {
		n += 1 + l + sovAlerts(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovAlerts(uint64(l))
	}
	l = len(m.CommunityOrUser)
	if l > 0 {
		n += 1 + l + sovAlerts(uint64(l))
	}
	if m.AuthConfig != nil {
		l = m.AuthConfig.Size()
		n += 1 + l + sovAlerts(uint64(l))
	}
	if m.PrivacyConfig != nil {
		l = m.PrivacyConfig.Size()
		n += 1 + l + sovAlerts(uint64(l))
	}
	return n
}

func sovAlerts(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozAlerts(x uint64) (n int) {
	return sovAlerts(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Alert) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAlerts
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Alert: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Alert: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAlerts(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAlerts
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AlertDestination) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAlerts
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AlertDestination: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AlertDestination: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAlerts(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAlerts
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AlertDestinationList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAlerts
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AlertDestinationList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AlertDestinationList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ListMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &AlertDestination{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAlerts(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAlerts
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AlertDestinationSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAlerts
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AlertDestinationSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AlertDestinationSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Default", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Default = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EmailList", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EmailList = append(m.EmailList, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SNMPTrapServers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SNMPTrapServers = append(m.SNMPTrapServers, &SNMPTrapServer{})
			if err := m.SNMPTrapServers[len(m.SNMPTrapServers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAlerts(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAlerts
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AlertDestinationStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAlerts
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AlertDestinationStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AlertDestinationStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalNotificationsSent", wireType)
			}
			m.TotalNotificationsSent = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalNotificationsSent |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAlerts(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAlerts
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AlertList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAlerts
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AlertList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AlertList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ListMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &Alert{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAlerts(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAlerts
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AlertPolicy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAlerts
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AlertPolicy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AlertPolicy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAlerts(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAlerts
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AlertPolicyList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAlerts
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AlertPolicyList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AlertPolicyList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ListMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &AlertPolicy{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAlerts(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAlerts
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AlertPolicySpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAlerts
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AlertPolicySpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AlertPolicySpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resource", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Resource = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Severity", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Severity = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Requirements", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Requirements = append(m.Requirements, Requirement{})
			if err := m.Requirements[len(m.Requirements)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PersistenceDuration", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PersistenceDuration = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClearDuration", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClearDuration = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enable = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoResolve", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AutoResolve = bool(v != 0)
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Destinations", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Destinations = append(m.Destinations, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAlerts(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAlerts
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AlertPolicyStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAlerts
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AlertPolicyStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AlertPolicyStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalHits", wireType)
			}
			m.TotalHits = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalHits |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenAlerts", wireType)
			}
			m.OpenAlerts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OpenAlerts |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AcknowledgedAlerts", wireType)
			}
			m.AcknowledgedAlerts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AcknowledgedAlerts |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAlerts(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAlerts
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AlertReason) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAlerts
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AlertReason: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AlertReason: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchedRequirements", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MatchedRequirements = append(m.MatchedRequirements, &MatchedRequirement{})
			if err := m.MatchedRequirements[len(m.MatchedRequirements)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PolicyID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PolicyID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAlerts(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAlerts
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AlertSource) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAlerts
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AlertSource: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AlertSource: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Component", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Component = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAlerts(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAlerts
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AlertSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAlerts
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AlertSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AlertSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAlerts(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAlerts
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AlertStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAlerts
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AlertStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AlertStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Severity", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Severity = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Source == nil {
				m.Source = &AlertSource{}
			}
			if err := m.Source.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectRef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectRef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Reason.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Acknowledged", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Acknowledged == nil {
				m.Acknowledged = &AuditInfo{}
			}
			if err := m.Acknowledged.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resolved", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Resolved == nil {
				m.Resolved = &AuditInfo{}
			}
			if err := m.Resolved.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAlerts(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAlerts
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuditInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAlerts
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuditInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuditInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.User = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Time == nil {
				m.Time = &api.Timestamp{}
			}
			if err := m.Time.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAlerts(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAlerts
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuthConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAlerts
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuthConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuthConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Algo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Algo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Password", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Password = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAlerts(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAlerts
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AutoMsgAlertDestinationWatchHelper) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAlerts
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AutoMsgAlertDestinationWatchHelper: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AutoMsgAlertDestinationWatchHelper: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Object", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Object == nil {
				m.Object = &AlertDestination{}
			}
			if err := m.Object.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAlerts(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAlerts
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AutoMsgAlertPolicyWatchHelper) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAlerts
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AutoMsgAlertPolicyWatchHelper: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AutoMsgAlertPolicyWatchHelper: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Object", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Object == nil {
				m.Object = &AlertPolicy{}
			}
			if err := m.Object.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAlerts(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAlerts
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AutoMsgAlertWatchHelper) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAlerts
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AutoMsgAlertWatchHelper: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AutoMsgAlertWatchHelper: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Object", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Object == nil {
				m.Object = &Alert{}
			}
			if err := m.Object.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAlerts(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAlerts
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MatchedRequirement) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAlerts
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MatchedRequirement: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MatchedRequirement: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Requirement", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Requirement.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObservedValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ObservedValue = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAlerts(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAlerts
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PrivacyConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAlerts
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PrivacyConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PrivacyConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Algo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Algo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Password", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Password = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAlerts(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAlerts
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Requirement) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAlerts
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Requirement: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Requirement: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FieldOrMetric", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FieldOrMetric = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Operator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Values", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Values = append(m.Values, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAlerts(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAlerts
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SNMPTrapServer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAlerts
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SNMPTrapServer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SNMPTrapServer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Host", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Host = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Port = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommunityOrUser", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CommunityOrUser = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AuthConfig == nil {
				m.AuthConfig = &AuthConfig{}
			}
			if err := m.AuthConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrivacyConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PrivacyConfig == nil {
				m.PrivacyConfig = &PrivacyConfig{}
			}
			if err := m.PrivacyConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAlerts(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAlerts
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipAlerts(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowAlerts
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthAlerts
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowAlerts
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipAlerts(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthAlerts = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowAlerts   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("alerts.proto", fileDescriptorAlerts) }

var fileDescriptorAlerts = []byte{
	// 2631 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x59, 0xcb, 0x6f, 0x1b, 0xc7,
	0xfd, 0xd7, 0x52, 0x94, 0x44, 0x8e, 0x24, 0x8b, 0x1e, 0x45, 0x32, 0x97, 0x96, 0x44, 0x65, 0xed,
	0x24, 0x8a, 0x12, 0x4a, 0x96, 0xfc, 0x88, 0xa3, 0xc4, 0xce, 0x8f, 0x14, 0x69, 0x4b, 0xb1, 0x24,
	0x2a, 0xa2, 0x2c, 0xff, 0x0a, 0x14, 0x45, 0x56, 0xe4, 0x88, 0xda, 0x76, 0xb9, 0xbb, 0xd9, 0x1d,
	0xca, 0x15, 0x0a, 0xa3, 0x45, 0x69, 0xab, 0x39, 0xb4, 0x97, 0xa4, 0x45, 0x8b, 0x1e, 0x7a, 0x30,
	0xd0, 0x43, 0xd9, 0x53, 0x0d, 0x14, 0xe8, 0xa9, 0xe8, 0x21, 0x07, 0x1f, 0x03, 0xf7, 0x96, 0x83,
	0x50, 0x18, 0x3d, 0xb4, 0x06, 0x7a, 0xeb, 0x1f, 0x50, 0xcc, 0x63, 0xc9, 0x19, 0x72, 0x29, 0xd3,
	0x80, 0x9d, 0x93, 0xb4, 0x33, 0xdf, 0xf7, 0xe3, 0x33, 0xdf, 0x19, 0x82, 0x21, 0xdd, 0x44, 0x2e,
	0xf6, 0xe6, 0x1c, 0xd7, 0xc6, 0x36, 0xec, 0x67, 0x5f, 0x89, 0x89, 0xb2, 0x6d, 0x97, 0x4d, 0x34,
	0xaf, 0x3b, 0xc6, 0xbc, 0x6e, 0x59, 0x36, 0xd6, 0xb1, 0x61, 0x5b, 0x9c, 0x2a, 0x91, 0x2b, 0x1b,
	0x78, 0xbf, 0xba, 0x3b, 0x57, 0xb4, 0x2b, 0xf3, 0x0e, 0xb2, 0x3c, 0xdd, 0x2a, 0xd9, 0xf3, 0xde,
	0xdd, 0xf9, 0x03, 0x64, 0x19, 0x45, 0x34, 0x5f, 0xc5, 0x86, 0xe9, 0x11, 0xd6, 0x32, 0xb2, 0x44,
	0xee, 0x79, 0xc3, 0x2a, 0x9a, 0xd5, 0x12, 0xf2, 0xc5, 0xa4, 0x04, 0x31, 0x65, 0xbb, 0x6c, 0xcf,
	0xd3, 0xe5, 0xdd, 0xea, 0x1e, 0xfd, 0xa2, 0x1f, 0xf4, 0x3f, 0x4e, 0xfe, 0x46, 0x07, 0xad, 0xc4,
	0xc6, 0x0a, 0xc2, 0x3a, 0x23, 0xd3, 0x7e, 0x13, 0x02, 0x7d, 0x69, 0xe2, 0x05, 0xbc, 0x00, 0x94,
	0xed, 0xb8, 0x32, 0xad, 0xcc, 0x0c, 0x2e, 0x0e, 0xcf, 0xe9, 0x8e, 0x31, 0xb7, 0x7d, 0xe8, 0xa0,
	0x75, 0x84, 0xf5, 0xcc, 0xe8, 0xe3, 0xe3, 0x64, 0xcf, 0xd7, 0xc7, 0x49, 0xe5, 0xd9, 0x71, 0x72,
	0xe0, 0x5d, 0xc3, 0x32, 0x0d, 0x0b, 0x6d, 0x29, 0xdb, 0x70, 0x09, 0x28, 0xf9, 0x78, 0x88, 0x72,
	0x8c, 0x50, 0x8e, 0xfc, 0xee, 0xf7, 0x51, 0x11, 0x53, 0x9e, 0xb3, 0x02, 0xcf, 0x08, 0xd1, 0xf7,
	0xee, 0xb4, 0x5d, 0x31, 0x30, 0xaa, 0x38, 0xf8, 0x70, 0x4b, 0xc9, 0xc3, 0xeb, 0x20, 0x5c, 0x70,
	0x50, 0x31, 0xde, 0x4b, 0xd9, 0x4f, 0xcf, 0xf1, 0xb8, 0x52, 0x53, 0xc8, 0x46, 0xe6, 0x0c, 0x11,
	0x40, 0x98, 0x3d, 0x07, 0x15, 0x45, 0x66, 0xca, 0x07, 0x6f, 0x80, 0xfe, 0x02, 0xd6, 0x71, 0xd5,
	0x8b, 0x87, 0xa9, 0x84, 0x51, 0x59, 0x02, 0xdd, 0xca, 0xa8, 0x5c, 0xc6, 0x69, 0x8f, 0x7e, 0x8b,
	0x52, 0x38, 0xf7, 0x92, 0xfa, 0xe4, 0x81, 0x3a, 0x06, 0x06, 0xe7, 0x7f, 0x94, 0x9f, 0xdb, 0x46,
	0x96, 0x6e, 0xe1, 0x7b, 0x7e, 0x56, 0xb5, 0xaf, 0x42, 0x20, 0x46, 0xa5, 0x65, 0x91, 0x87, 0x0d,
	0x8b, 0x66, 0xe5, 0x5b, 0x8e, 0xd2, 0xaa, 0x14, 0xa5, 0x09, 0xc9, 0x47, 0xc1, 0xaa, 0x6e, 0x02,
	0xf6, 0x49, 0x4b, 0xc0, 0xa6, 0x3a, 0x0a, 0xeb, 0x3a, 0x76, 0xe7, 0x9f, 0x3c, 0x50, 0xa7, 0xe5,
	0xd8, 0x9d, 0xd6, 0x5b, 0xa4, 0x79, 0xda, 0xef, 0x14, 0xf0, 0x5a, 0xab, 0x8e, 0x35, 0xc3, 0xc3,
	0x50, 0x23, 0xa1, 0x0c, 0x05, 0x85, 0x32, 0xe2, 0x87, 0x05, 0xbe, 0x0d, 0x22, 0x84, 0x96, 0xac,
	0xf2, 0x20, 0x30, 0x52, 0x7f, 0x51, 0x20, 0x7d, 0x0b, 0xf4, 0xad, 0x62, 0x54, 0x21, 0xfe, 0xf5,
	0xce, 0x0c, 0x2e, 0xc6, 0x3b, 0xf9, 0xb7, 0x74, 0xea, 0x9b, 0x07, 0x2a, 0x30, 0x0d, 0x0f, 0xef,
	0x23, 0xd3, 0x41, 0xae, 0xf6, 0x9f, 0x00, 0x03, 0x69, 0xc8, 0x2e, 0x80, 0x81, 0x2c, 0xda, 0xd3,
	0xab, 0x26, 0xa6, 0x19, 0x8f, 0x64, 0xc6, 0x9f, 0x1d, 0x27, 0x61, 0x89, 0x2d, 0x89, 0x01, 0xf1,
	0xc9, 0xe0, 0x07, 0x20, 0x9a, 0xab, 0xe8, 0x86, 0x49, 0xcc, 0x8b, 0x87, 0xa6, 0x7b, 0x67, 0xa2,
	0x99, 0xc9, 0xc7, 0x2c, 0xbd, 0x63, 0x88, 0x6c, 0xa4, 0x88, 0x5e, 0x91, 0xb5, 0x49, 0x0f, 0xf7,
	0xc0, 0x48, 0x61, 0x63, 0x7d, 0x73, 0xdb, 0xd5, 0x9d, 0x02, 0x72, 0x0f, 0x90, 0xeb, 0xc5, 0x7b,
	0xa9, 0x2b, 0xe3, 0xbe, 0x2b, 0xf2, 0x76, 0xe6, 0x3c, 0x17, 0x3d, 0xe1, 0x59, 0x15, 0x27, 0x85,
	0x5d, 0xdd, 0x49, 0x79, 0x8c, 0x51, 0xd4, 0xd0, 0x2a, 0x54, 0xbb, 0x07, 0xc6, 0x83, 0x73, 0x0e,
	0x8b, 0x60, 0x1c, 0xdb, 0x58, 0x37, 0x37, 0x6c, 0x6c, 0xec, 0x19, 0x45, 0x96, 0xc0, 0x02, 0xb2,
	0x98, 0xff, 0x7d, 0x99, 0x77, 0xb8, 0xc2, 0x73, 0x94, 0x2a, 0x65, 0x89, 0x64, 0x29, 0x0f, 0x59,
	0x92, 0x67, 0x1d, 0x44, 0x69, 0x9f, 0x2b, 0x20, 0x4a, 0xf5, 0xbf, 0x8a, 0x22, 0x98, 0x90, 0x8b,
	0x60, 0x58, 0x2a, 0x82, 0xb6, 0xcc, 0xff, 0x29, 0x04, 0x06, 0xe9, 0xce, 0xa6, 0x6d, 0x1a, 0xc5,
	0xc3, 0x6f, 0xb9, 0xb9, 0xb3, 0x52, 0x73, 0x9f, 0x91, 0x4c, 0x65, 0x06, 0x75, 0xd3, 0xd7, 0x6b,
	0x2d, 0x7d, 0xad, 0x06, 0xc9, 0xe9, 0xba, 0xa5, 0xa7, 0x9f, 0x3c, 0x50, 0x27, 0xe4, 0x96, 0x1e,
	0xd6, 0x1b, 0x82, 0x0c, 0xe4, 0x69, 0xbf, 0x54, 0xc0, 0x88, 0x20, 0xfa, 0x55, 0x24, 0x51, 0x93,
	0x93, 0x38, 0x1a, 0xe0, 0x51, 0x5b, 0x2a, 0xff, 0x1b, 0x96, 0xcc, 0xa2, 0xa1, 0xb9, 0x08, 0x22,
	0x5b, 0xc8, 0xb3, 0xab, 0x6e, 0x11, 0xd1, 0xac, 0x46, 0x33, 0x67, 0x9e, 0x1d, 0x27, 0x47, 0x5d,
	0xbe, 0x26, 0xfa, 0xdf, 0x20, 0x84, 0x9f, 0x80, 0x48, 0x01, 0x1d, 0x20, 0xd7, 0xc0, 0x87, 0xd4,
	0xa5, 0x68, 0xe6, 0x72, 0xfd, 0x48, 0x1d, 0x2f, 0x60, 0x37, 0x67, 0x55, 0x2b, 0x33, 0xec, 0x78,
	0xe1, 0x04, 0x6f, 0xf3, 0x7e, 0x18, 0xf5, 0xf8, 0x82, 0x24, 0xd2, 0xa7, 0x82, 0x97, 0xc0, 0xc0,
	0x3a, 0xf2, 0x3c, 0xbd, 0x8c, 0xa8, 0xe7, 0xd1, 0x4c, 0x82, 0xf3, 0xc1, 0x0a, 0x5b, 0x96, 0xb0,
	0x84, 0x93, 0xc2, 0xff, 0x07, 0x43, 0x5b, 0xe8, 0xb3, 0xaa, 0xe1, 0xa2, 0x0a, 0xb2, 0x70, 0x5b,
	0x30, 0x84, 0xbd, 0x4c, 0x92, 0x27, 0xf6, 0x8c, 0x2b, 0x30, 0x88, 0x42, 0x25, 0x49, 0xf0, 0x36,
	0x18, 0xdd, 0x44, 0xae, 0x67, 0x78, 0x18, 0x59, 0x45, 0x94, 0xad, 0xba, 0xb4, 0x3b, 0xe3, 0x7d,
	0xd4, 0xb6, 0x73, 0xcf, 0x8e, 0x93, 0x49, 0xa7, 0xb9, 0x9d, 0x2a, 0xf1, 0x7d, 0x51, 0x5e, 0x10,
	0x3f, 0x5c, 0x06, 0xc3, 0xcb, 0x26, 0xd2, 0xdd, 0x86, 0xc0, 0x7e, 0x2a, 0x70, 0xf2, 0xd9, 0x71,
	0x52, 0x2d, 0x92, 0x8d, 0x40, 0x51, 0x32, 0x0f, 0x4c, 0x81, 0xfe, 0x9c, 0xa5, 0xef, 0x9a, 0x28,
	0x3e, 0x40, 0x21, 0x77, 0x8c, 0xd4, 0x2b, 0xa2, 0x2b, 0x52, 0xbd, 0x32, 0x22, 0x78, 0x0d, 0x0c,
	0xa6, 0xab, 0xd8, 0x26, 0xd9, 0x33, 0x0f, 0x50, 0x3c, 0x42, 0x79, 0xce, 0x92, 0x50, 0xe8, 0x55,
	0x6c, 0xa7, 0x5c, 0xb6, 0x2e, 0x72, 0x8a, 0xf4, 0xf0, 0x23, 0x30, 0x24, 0x9e, 0x55, 0xf1, 0x28,
	0x85, 0x6c, 0xca, 0x5f, 0x12, 0xd6, 0xa5, 0x50, 0x4a, 0x87, 0xdb, 0xbf, 0x14, 0x70, 0xba, 0xad,
	0xd1, 0xc8, 0x31, 0xb0, 0x4d, 0xc0, 0x6f, 0xc5, 0xc0, 0x1e, 0x87, 0xce, 0xc6, 0x31, 0xc0, 0xa0,
	0x73, 0xdf, 0x90, 0x13, 0xd4, 0xa4, 0x87, 0xd7, 0x01, 0xc8, 0x3b, 0xc8, 0xa2, 0x52, 0x3d, 0x5a,
	0x82, 0x7d, 0x99, 0x29, 0xce, 0x3d, 0x6e, 0x3b, 0xc8, 0x4a, 0xb1, 0x0a, 0x10, 0xd9, 0x05, 0x0e,
	0xb8, 0x03, 0x60, 0xba, 0xf8, 0x03, 0xcb, 0xbe, 0x6b, 0xa2, 0x52, 0x19, 0x95, 0xb8, 0x9c, 0x5e,
	0x2a, 0xe7, 0x4d, 0x2e, 0x67, 0x4a, 0x17, 0x28, 0x02, 0xe4, 0x05, 0x48, 0xd0, 0xbe, 0x52, 0x38,
	0x58, 0x6e, 0x21, 0xdd, 0xb3, 0x2d, 0x58, 0x05, 0xa3, 0xeb, 0x3a, 0x2e, 0xee, 0xa3, 0x92, 0x54,
	0xa6, 0x0a, 0x2d, 0xd3, 0x84, 0x5f, 0xa6, 0xed, 0x24, 0x99, 0xb7, 0xb8, 0x11, 0xc9, 0x0a, 0xdb,
	0x4b, 0x75, 0xaa, 0xda, 0x20, 0xf9, 0xf0, 0x3a, 0x88, 0xb0, 0x58, 0xaf, 0x66, 0x79, 0x7f, 0x6a,
	0x5c, 0x5e, 0x82, 0xaa, 0x4c, 0x39, 0x74, 0x37, 0x65, 0x94, 0xa4, 0x66, 0xf4, 0x79, 0xb4, 0x9a,
	0xef, 0x46, 0x81, 0xf5, 0xfb, 0x12, 0x88, 0x2e, 0xdb, 0x15, 0xc7, 0xb6, 0xfc, 0x63, 0x2e, 0x9a,
	0x99, 0xe0, 0x02, 0x5f, 0x2b, 0xfa, 0x1b, 0x52, 0xaa, 0x1a, 0xe4, 0xf0, 0x2a, 0x88, 0x6c, 0xd8,
	0x25, 0xb4, 0xa1, 0x57, 0x10, 0xb7, 0xa5, 0xc1, 0x6a, 0xd9, 0x25, 0x94, 0xb2, 0xf4, 0x8a, 0x8c,
	0x32, 0x3e, 0x35, 0x41, 0xd1, 0x68, 0x63, 0xd6, 0x85, 0x79, 0xd0, 0x47, 0x2a, 0xc7, 0x47, 0xa9,
	0xf7, 0xeb, 0x47, 0xea, 0xa4, 0x0c, 0x38, 0x0e, 0x2a, 0x36, 0x27, 0x5b, 0xe4, 0xe3, 0x4e, 0x8c,
	0x00, 0xb9, 0xa4, 0x81, 0xc9, 0xd1, 0xae, 0x00, 0xd0, 0xa4, 0x86, 0x11, 0x10, 0xce, 0x6f, 0xe6,
	0x36, 0x62, 0x3d, 0x70, 0x08, 0x44, 0xb6, 0x72, 0x85, 0xfc, 0xda, 0x4e, 0x2e, 0x1b, 0x53, 0x60,
	0x0c, 0x0c, 0xa5, 0x97, 0x6f, 0x6d, 0xe4, 0xef, 0xac, 0xe5, 0xb2, 0x37, 0x73, 0xd9, 0x58, 0x48,
	0xfb, 0x75, 0xd8, 0x0f, 0x0e, 0x2b, 0x64, 0x11, 0x0c, 0x95, 0x97, 0x03, 0x86, 0x64, 0x70, 0x67,
	0x90, 0x1c, 0x0a, 0x1a, 0xdc, 0xe9, 0x16, 0x3d, 0xa9, 0x14, 0x7a, 0x52, 0xb5, 0x21, 0x35, 0xe7,
	0x86, 0xb7, 0x40, 0x94, 0x9d, 0xb5, 0x5b, 0x68, 0x8f, 0x1f, 0x28, 0xa7, 0x84, 0x13, 0x78, 0x0b,
	0xed, 0xd1, 0x9e, 0x23, 0xb0, 0x38, 0x66, 0xd3, 0xa5, 0x94, 0x8b, 0xf6, 0xa4, 0x44, 0x36, 0x28,
	0x45, 0x84, 0x0e, 0x77, 0x8f, 0xd0, 0x37, 0x40, 0x3f, 0xeb, 0x05, 0x0a, 0x9d, 0xad, 0xae, 0xb0,
	0xad, 0xe6, 0xa1, 0xeb, 0xd2, 0x6f, 0xc9, 0x15, 0xde, 0x49, 0x3b, 0x60, 0x48, 0xec, 0x37, 0x8a,
	0x9b, 0xe2, 0x9d, 0xa8, 0x5a, 0x32, 0xf0, 0xaa, 0xb5, 0x67, 0x53, 0x9c, 0x57, 0x28, 0xb8, 0x09,
	0xe4, 0x12, 0x38, 0x89, 0x72, 0xe0, 0xc7, 0xec, 0xfc, 0x33, 0x0f, 0x50, 0x89, 0xa2, 0x69, 0xa0,
	0xcc, 0xb3, 0x7e, 0xda, 0x38, 0x56, 0x96, 0xda, 0x8e, 0x45, 0xb2, 0xa8, 0x55, 0x41, 0xb4, 0xc1,
	0x03, 0xdf, 0x01, 0xe1, 0xdb, 0x1e, 0x72, 0xfd, 0x43, 0x95, 0x4b, 0x18, 0xa9, 0x7a, 0xc8, 0x95,
	0x06, 0x14, 0x42, 0x04, 0x3f, 0x00, 0xe1, 0x6d, 0xa3, 0xe2, 0xa7, 0x9b, 0xe5, 0x88, 0x2c, 0x78,
	0x58, 0xaf, 0x38, 0x4d, 0x66, 0x6c, 0xc8, 0xbd, 0x42, 0x99, 0xb4, 0x3f, 0x2a, 0x00, 0xa4, 0xab,
	0x78, 0x7f, 0xd9, 0xb6, 0xf6, 0x8c, 0x32, 0x5c, 0x01, 0xe1, 0xb4, 0x59, 0xb6, 0xb9, 0xe2, 0x4b,
	0xf5, 0x23, 0x55, 0x6d, 0xd4, 0x62, 0x83, 0x6a, 0x8e, 0x90, 0x78, 0x7e, 0x39, 0x8e, 0xe8, 0x66,
	0xd9, 0x96, 0x04, 0x93, 0x6d, 0xf8, 0x1e, 0x88, 0x6c, 0xea, 0x9e, 0x77, 0xd7, 0x76, 0x4b, 0xbc,
	0x75, 0x1b, 0x81, 0x70, 0xf8, 0xba, 0x8c, 0x1f, 0x7c, 0x51, 0x4b, 0x90, 0xfb, 0x72, 0xd9, 0xf6,
	0xe0, 0x00, 0xe8, 0x5d, 0xcf, 0x5e, 0x8e, 0xf5, 0x90, 0xf6, 0x2a, 0xac, 0xa4, 0x17, 0x62, 0x8a,
	0x56, 0x01, 0x1a, 0x39, 0x5d, 0xd6, 0xbd, 0x72, 0xeb, 0x80, 0x7d, 0x87, 0x20, 0xd9, 0x0a, 0x1d,
	0x55, 0xe0, 0x10, 0x08, 0x93, 0xf9, 0x88, 0x39, 0x01, 0x67, 0x40, 0x3f, 0xab, 0x43, 0x1e, 0xa0,
	0xce, 0xf7, 0x96, 0x91, 0x6f, 0x1e, 0xa8, 0x83, 0x77, 0x89, 0x20, 0x3e, 0xf3, 0x14, 0xc1, 0xa4,
	0xa8, 0x8e, 0x41, 0x5c, 0x67, 0x4d, 0xe7, 0x5a, 0x34, 0x05, 0xce, 0x55, 0x6d, 0x4a, 0xee, 0x80,
	0x33, 0xa2, 0x92, 0xce, 0xe2, 0x27, 0x5b, 0xc4, 0xb7, 0xcc, 0xde, 0x6d, 0x82, 0xff, 0xa0, 0x00,
	0xd8, 0x0e, 0xf0, 0xf0, 0x63, 0x30, 0x28, 0x7c, 0xf2, 0x69, 0x3c, 0x70, 0xea, 0x09, 0x9c, 0xc9,
	0x45, 0x66, 0x78, 0x13, 0x0c, 0xe7, 0x77, 0xe9, 0x95, 0xa8, 0xb4, 0xa3, 0x9b, 0x55, 0x1f, 0xa4,
	0x5f, 0xe7, 0x99, 0x56, 0x6d, 0xbe, 0x99, 0x3a, 0x20, 0xbb, 0xd2, 0x54, 0x22, 0xf1, 0x69, 0x7f,
	0x56, 0xc0, 0xf0, 0xa6, 0x6b, 0x1c, 0xe8, 0xc5, 0x43, 0x5e, 0x89, 0xb7, 0xa4, 0x4a, 0x7c, 0xaf,
	0x7e, 0xa4, 0x4e, 0xf8, 0x95, 0x28, 0x11, 0xbe, 0xda, 0x62, 0x9c, 0xf2, 0x8b, 0x31, 0x0a, 0xfa,
	0xb2, 0xb9, 0xc2, 0xe5, 0x2b, 0xb1, 0x1e, 0x08, 0x40, 0x7f, 0x3a, 0x57, 0x58, 0x58, 0xbc, 0x1a,
	0x53, 0xb4, 0xbf, 0x86, 0xa4, 0x68, 0xc2, 0x15, 0x30, 0x7c, 0xc3, 0x40, 0x66, 0x29, 0xef, 0xae,
	0x23, 0xec, 0x1a, 0x45, 0x6e, 0x7e, 0xe3, 0x04, 0xdd, 0x23, 0x9b, 0x29, 0xdb, 0x4d, 0x55, 0xe8,
	0xb6, 0x14, 0x11, 0x89, 0x11, 0x7e, 0x0a, 0x22, 0x79, 0x07, 0xb9, 0x3a, 0xb6, 0x5d, 0x6e, 0x72,
	0xb6, 0x7e, 0xa4, 0xbe, 0xe1, 0xc7, 0x40, 0x50, 0x3a, 0x97, 0x36, 0x4d, 0xfb, 0x2e, 0x2a, 0xf9,
	0xe4, 0x8d, 0x60, 0x8c, 0xda, 0x7c, 0x45, 0xf2, 0xcd, 0x27, 0x83, 0x0b, 0xa0, 0x9f, 0x06, 0x9f,
	0xdd, 0x82, 0xa3, 0xcd, 0x33, 0x81, 0x26, 0x4b, 0xbe, 0xbd, 0x30, 0x42, 0x6d, 0x13, 0xc4, 0x5a,
	0x95, 0x91, 0x70, 0xe4, 0x3e, 0xab, 0xea, 0xa6, 0x17, 0xeb, 0x81, 0xfd, 0x20, 0xb4, 0x6a, 0xc5,
	0x14, 0x38, 0x0c, 0xa2, 0x1b, 0x36, 0xe6, 0xcb, 0x21, 0x12, 0xbc, 0x0d, 0x1b, 0xaf, 0x5a, 0xb1,
	0x5e, 0x42, 0x71, 0x13, 0xc7, 0xc2, 0xe4, 0xef, 0x1a, 0x8e, 0xf5, 0x69, 0xff, 0xee, 0x05, 0xa7,
	0xe4, 0xfb, 0x33, 0x7c, 0x0b, 0x84, 0x57, 0x6c, 0xcf, 0x9f, 0x15, 0x46, 0x49, 0x56, 0xf7, 0x6d,
	0xf9, 0x52, 0x4f, 0x09, 0x08, 0x4a, 0x6e, 0xda, 0x2e, 0xe6, 0xe1, 0x69, 0x00, 0x9d, 0x63, 0xbb,
	0x32, 0x31, 0x21, 0x82, 0xdf, 0x05, 0x03, 0x3b, 0x64, 0xa6, 0xb6, 0x2d, 0x7e, 0x47, 0xc8, 0xd4,
	0x8f, 0xd4, 0xf3, 0x7e, 0x38, 0x65, 0x13, 0xe8, 0x3b, 0x00, 0xa7, 0x6e, 0x44, 0x13, 0x1e, 0xb0,
	0x05, 0xe9, 0xa4, 0xe2, 0x44, 0x70, 0x03, 0x8c, 0x2c, 0xdb, 0x95, 0x4a, 0xd5, 0x32, 0xf0, 0x61,
	0xde, 0xa5, 0xd8, 0xcd, 0xce, 0xb9, 0xc6, 0x13, 0x42, 0xd1, 0xdf, 0x26, 0xd9, 0x6f, 0x05, 0xf2,
	0x56, 0x66, 0xb8, 0x25, 0xa2, 0x32, 0x3f, 0xfd, 0x60, 0xf3, 0x6c, 0xf1, 0x77, 0x9a, 0x73, 0xab,
	0x5e, 0xc5, 0xfb, 0xa9, 0x22, 0x5d, 0x94, 0xe6, 0x56, 0x01, 0xdb, 0xbf, 0xd7, 0xd2, 0x62, 0xfc,
	0x18, 0x1c, 0xf3, 0xc5, 0x4a, 0x9b, 0xcd, 0x1e, 0x76, 0xd8, 0x72, 0x80, 0x70, 0x59, 0x9c, 0x96,
	0x04, 0x43, 0x62, 0xdc, 0x08, 0x7e, 0xef, 0x2c, 0x2e, 0xb3, 0xaa, 0xd8, 0xb9, 0x18, 0x53, 0x66,
	0x67, 0xc1, 0xb0, 0x34, 0xd0, 0xc0, 0x41, 0x30, 0x70, 0x27, 0xbd, 0xb5, 0xb1, 0xba, 0x71, 0x93,
	0x8d, 0x4e, 0xcb, 0x5b, 0xab, 0xdb, 0xab, 0xcb, 0xe9, 0xb5, 0x98, 0xb2, 0xf8, 0xab, 0x08, 0x80,
	0xad, 0x00, 0xbd, 0xb3, 0x00, 0x7f, 0xa6, 0x30, 0xb4, 0x4c, 0x97, 0x4a, 0x6d, 0x2f, 0x87, 0x1d,
	0x81, 0x3d, 0xd1, 0x71, 0x47, 0xbb, 0xfa, 0xe8, 0xbe, 0xda, 0x5f, 0x74, 0x91, 0x8e, 0xd1, 0x5f,
	0xee, 0xab, 0xca, 0x4f, 0xff, 0xfe, 0xcf, 0x2f, 0x43, 0xe7, 0x41, 0xcf, 0x92, 0x32, 0xab, 0x4d,
	0x0a, 0x77, 0xf4, 0xf9, 0xb6, 0x57, 0x37, 0xf8, 0x85, 0x02, 0x12, 0xc4, 0x92, 0x2c, 0x32, 0x11,
	0x46, 0x2f, 0xc5, 0x98, 0xff, 0x23, 0xc6, 0x94, 0xa8, 0xbc, 0x86, 0x31, 0xef, 0x82, 0x9e, 0xa5,
	0x9e, 0xd9, 0x37, 0x4f, 0xb4, 0x85, 0x6c, 0x92, 0xa1, 0xf7, 0x1e, 0xfc, 0x39, 0x0f, 0xcf, 0x4d,
	0x84, 0x5f, 0x8a, 0x45, 0xd7, 0x1e, 0xdd, 0x57, 0x7b, 0xcb, 0x08, 0xcb, 0xe6, 0xc0, 0x6e, 0xcd,
	0x39, 0x52, 0x40, 0x9c, 0x98, 0xb3, 0x66, 0x78, 0xed, 0xf6, 0x8c, 0x35, 0x5e, 0x27, 0xe8, 0x91,
	0x97, 0x77, 0x28, 0x73, 0xa2, 0xe3, 0x1b, 0x2c, 0xa1, 0xd4, 0x2e, 0x3f, 0xba, 0xaf, 0x86, 0x4d,
	0xc3, 0x6b, 0x5a, 0x74, 0x8e, 0x5a, 0xf4, 0x9c, 0x64, 0x7d, 0xc9, 0x93, 0x75, 0xdb, 0x29, 0xe9,
	0x2f, 0x29, 0x59, 0x69, 0x92, 0xac, 0x2a, 0x95, 0xd7, 0xb0, 0x25, 0x45, 0x2b, 0x27, 0xd1, 0x6d,
	0x78, 0x6c, 0xa0, 0x12, 0xa3, 0xa8, 0xfb, 0xdd, 0x86, 0x67, 0x56, 0x00, 0x81, 0xe7, 0xcc, 0x41,
	0xda, 0xf0, 0xa3, 0xfb, 0x6a, 0x1f, 0x9d, 0x08, 0x88, 0x85, 0x17, 0x94, 0xc4, 0xdf, 0x94, 0x2f,
	0x6a, 0x6a, 0xe8, 0x60, 0xe1, 0xb7, 0x35, 0xb5, 0xfd, 0x1d, 0xf9, 0x61, 0x4d, 0x6d, 0x7b, 0x8d,
	0xaf, 0xd7, 0xd4, 0x6b, 0x01, 0x6f, 0xf4, 0x61, 0x87, 0xc0, 0x2f, 0xcd, 0x43, 0xe2, 0xe4, 0xc8,
	0xd7, 0x6b, 0xea, 0x5a, 0x80, 0x80, 0x5e, 0xa7, 0x8a, 0x21, 0x29, 0x2c, 0xc8, 0xeb, 0xbd, 0xdb,
	0x98, 0x2d, 0xfe, 0x62, 0x80, 0x83, 0x08, 0x1b, 0xa7, 0x76, 0x16, 0x20, 0x06, 0x50, 0x44, 0x04,
	0xfe, 0xd2, 0x18, 0x34, 0x7b, 0x25, 0x82, 0x16, 0xb5, 0x4b, 0x01, 0x10, 0x30, 0xcd, 0x20, 0x40,
	0x6d, 0x33, 0xca, 0x7f, 0xa5, 0x83, 0x3f, 0x06, 0x63, 0x2d, 0xdd, 0xff, 0xc2, 0x8a, 0x3f, 0x0c,
	0x68, 0xf7, 0x19, 0xda, 0xee, 0x5a, 0x47, 0xbd, 0xcd, 0xe2, 0x39, 0x64, 0x6e, 0xfb, 0x9d, 0xfe,
	0xc2, 0xda, 0xdf, 0x6f, 0x6d, 0x6d, 0xaa, 0x1a, 0x76, 0xa3, 0xfa, 0x87, 0x60, 0x54, 0xea, 0x6a,
	0xae, 0xbb, 0x43, 0xc5, 0x06, 0xbd, 0xbb, 0xd2, 0x5e, 0x5e, 0x68, 0xeb, 0xe5, 0x24, 0x35, 0xe1,
	0x84, 0xa8, 0xff, 0x44, 0x61, 0x61, 0x17, 0xfa, 0xf8, 0x85, 0x1d, 0xbf, 0x16, 0xd0, 0xb8, 0x6f,
	0xb3, 0xc6, 0xed, 0xc6, 0x79, 0x04, 0x5e, 0x93, 0x9b, 0xf6, 0x64, 0xef, 0xdf, 0x08, 0xea, 0xd7,
	0xb6, 0x8b, 0x44, 0x7b, 0xab, 0xfe, 0xbe, 0xd9, 0xaa, 0xf2, 0xfb, 0xf0, 0xc3, 0x9a, 0x2a, 0x3e,
	0xa9, 0xd7, 0x6b, 0xea, 0x25, 0xf9, 0x8d, 0x5d, 0x6c, 0xce, 0xce, 0xa1, 0xac, 0xd7, 0xd4, 0x65,
	0x99, 0xaf, 0xbd, 0x27, 0xbb, 0x08, 0xc7, 0xe2, 0xe7, 0x7d, 0x20, 0xc2, 0xde, 0xaf, 0x76, 0x16,
	0xe0, 0x87, 0x60, 0x48, 0x6c, 0x45, 0x28, 0xdf, 0x50, 0x12, 0xf2, 0xa7, 0x76, 0x4a, 0x6e, 0x3c,
	0xf8, 0x11, 0x18, 0x69, 0x69, 0xa9, 0x6e, 0x04, 0x34, 0x1b, 0x08, 0x7e, 0xca, 0xd4, 0xfb, 0x2d,
	0xf1, 0x1c, 0xee, 0xc5, 0xd6, 0x06, 0x78, 0x9d, 0x56, 0xdf, 0xd9, 0x36, 0xa7, 0xa5, 0xe4, 0x0f,
	0x4b, 0x95, 0xdf, 0x29, 0xeb, 0xf2, 0xcf, 0xad, 0xb4, 0xda, 0x67, 0xdb, 0xaa, 0x3d, 0x4e, 0xf5,
	0xc1, 0x76, 0x7d, 0xb0, 0xcc, 0x22, 0x21, 0x54, 0xf9, 0x73, 0x7c, 0xb9, 0x12, 0x50, 0xd3, 0x1a,
	0xab, 0xe9, 0x13, 0xfd, 0xf9, 0x0e, 0x38, 0x25, 0x17, 0x73, 0x27, 0x87, 0x92, 0x41, 0x65, 0x7c,
	0x62, 0x01, 0x3b, 0x8d, 0xfa, 0xe5, 0x3f, 0xf7, 0x3e, 0xac, 0xa9, 0xec, 0x87, 0xf0, 0x7a, 0x4d,
	0x7d, 0xdd, 0xff, 0x4d, 0x9c, 0x95, 0x69, 0x40, 0x0c, 0xea, 0x35, 0x75, 0xce, 0x27, 0x6a, 0x54,
	0xe6, 0x89, 0xce, 0x64, 0x86, 0x1e, 0x3f, 0x9d, 0x52, 0xbe, 0x7e, 0x3a, 0xa5, 0xfc, 0xe3, 0xe9,
	0x94, 0xb2, 0xa9, 0xec, 0xf6, 0xd3, 0x1f, 0xe0, 0x2f, 0xfe, 0x2f, 0x00, 0x00, 0xff, 0xff, 0x62,
	0xac, 0x83, 0x06, 0x53, 0x20, 0x00, 0x00,
}
