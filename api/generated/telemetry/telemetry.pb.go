// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: telemetry.proto

/*
	Package telemetry is a generated protocol buffer package.

	Service name

	It is generated from these files:
		telemetry.proto

	It has these top-level messages:
		AutoMsgFlowExportPolicyWatchHelper
		AutoMsgFwlogPolicyWatchHelper
		AutoMsgStatsPolicyWatchHelper
		FlowExportPolicy
		FlowExportPolicyList
		FlowExportSpec
		FlowExportStatus
		FlowExportTarget
		FwlogExport
		FwlogPolicy
		FwlogPolicyList
		FwlogSpec
		FwlogStatus
		StatsPolicy
		StatsPolicyList
		StatsSpec
		StatsStatus
*/
package telemetry

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/pensando/grpc-gateway/third_party/googleapis/google/api"
import _ "github.com/pensando/sw/venice/utils/apigen/annotations"
import _ "github.com/gogo/protobuf/gogoproto"
import api "github.com/pensando/sw/api"
import api1 "github.com/pensando/sw/api"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// firewall log export formats
type FwlogExportFormat int32

const (
	FwlogExportFormat_SYSLOG_BSD     FwlogExportFormat = 0
	FwlogExportFormat_SYSLOG_RFC5424 FwlogExportFormat = 1
)

var FwlogExportFormat_name = map[int32]string{
	0: "SYSLOG_BSD",
	1: "SYSLOG_RFC5424",
}
var FwlogExportFormat_value = map[string]int32{
	"SYSLOG_BSD":     0,
	"SYSLOG_RFC5424": 1,
}

func (x FwlogExportFormat) String() string {
	return proto.EnumName(FwlogExportFormat_name, int32(x))
}
func (FwlogExportFormat) EnumDescriptor() ([]byte, []int) { return fileDescriptorTelemetry, []int{0} }

type FwlogFilter int32

const (
	FwlogFilter_FWLOG_ALL    FwlogFilter = 0
	FwlogFilter_FWLOG_ACCEPT FwlogFilter = 1
	FwlogFilter_FWLOG_REJECT FwlogFilter = 2
	FwlogFilter_FWLOG_DENY   FwlogFilter = 3
)

var FwlogFilter_name = map[int32]string{
	0: "FWLOG_ALL",
	1: "FWLOG_ACCEPT",
	2: "FWLOG_REJECT",
	3: "FWLOG_DENY",
}
var FwlogFilter_value = map[string]int32{
	"FWLOG_ALL":    0,
	"FWLOG_ACCEPT": 1,
	"FWLOG_REJECT": 2,
	"FWLOG_DENY":   3,
}

func (x FwlogFilter) String() string {
	return proto.EnumName(FwlogFilter_name, int32(x))
}
func (FwlogFilter) EnumDescriptor() ([]byte, []int) { return fileDescriptorTelemetry, []int{1} }

type FlowExportTarget_Formats int32

const (
	FlowExportTarget_Ipfix FlowExportTarget_Formats = 0
)

var FlowExportTarget_Formats_name = map[int32]string{
	0: "Ipfix",
}
var FlowExportTarget_Formats_value = map[string]int32{
	"Ipfix": 0,
}

func (x FlowExportTarget_Formats) String() string {
	return proto.EnumName(FlowExportTarget_Formats_name, int32(x))
}
func (FlowExportTarget_Formats) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorTelemetry, []int{7, 0}
}

// telemetry policies:
// -------------------------------------------------------------------------------
// policy name         |  intended for        |     description                 |
// -------------------------------------------------------------------------------
// stats               |  sys admins          |    for all stats other than     |
//                     |                      |    fwlog/netflow.               |
//                     |                      |    includes retention,compaction|
// -------------------------------------------------------------------------------
// fwlog               |  security admins     |    firewall log policy          |
//                     |                      |    includes retention,          |
//                     |                      |    export parameters            |
// -------------------------------------------------------------------------------
//                     |                      |                                 |
// flowexport          |  network admins      |    netflow export policy        |
//                     |                      |    includes interval,           |
//                     |                      |    export parameters            |
// -------------------------------------------------------------------------------
//
// =========================================================================================
//  stats policy
// =========================================================================================
type AutoMsgFlowExportPolicyWatchHelper struct {
	Type   string            `protobuf:"bytes,1,opt,name=Type,proto3" json:"Type,omitempty"`
	Object *FlowExportPolicy `protobuf:"bytes,2,opt,name=Object" json:"Object,omitempty"`
}

func (m *AutoMsgFlowExportPolicyWatchHelper) Reset()         { *m = AutoMsgFlowExportPolicyWatchHelper{} }
func (m *AutoMsgFlowExportPolicyWatchHelper) String() string { return proto.CompactTextString(m) }
func (*AutoMsgFlowExportPolicyWatchHelper) ProtoMessage()    {}
func (*AutoMsgFlowExportPolicyWatchHelper) Descriptor() ([]byte, []int) {
	return fileDescriptorTelemetry, []int{0}
}

func (m *AutoMsgFlowExportPolicyWatchHelper) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *AutoMsgFlowExportPolicyWatchHelper) GetObject() *FlowExportPolicy {
	if m != nil {
		return m.Object
	}
	return nil
}

// compaction method will be selected by Venice based on the mesaurement/table
// collection interval will be selected by Venice based on workloads
type AutoMsgFwlogPolicyWatchHelper struct {
	// Compaction Interval is the down sampling interval in minutes, hours or days
	// this would be mapped to GROUP BY TIME() in influxdb CQ
	// example: SELECT MAX(*) INTO downsampled_xxx FROM xxx GROUP BY time(CompactionInterval),host
	Type string `protobuf:"bytes,1,opt,name=Type,proto3" json:"Type,omitempty"`
	// RetentionTime defines for how long to keep the stats data before it is deleted
	// The value is specified as a string format to be hours, days, or months etc.
	// e.g. '24hrs', '72hours', '4days', '6d', '2months', '4mo', '1yr'
	Object *FwlogPolicy `protobuf:"bytes,2,opt,name=Object" json:"Object,omitempty"`
}

func (m *AutoMsgFwlogPolicyWatchHelper) Reset()         { *m = AutoMsgFwlogPolicyWatchHelper{} }
func (m *AutoMsgFwlogPolicyWatchHelper) String() string { return proto.CompactTextString(m) }
func (*AutoMsgFwlogPolicyWatchHelper) ProtoMessage()    {}
func (*AutoMsgFwlogPolicyWatchHelper) Descriptor() ([]byte, []int) {
	return fileDescriptorTelemetry, []int{1}
}

func (m *AutoMsgFwlogPolicyWatchHelper) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *AutoMsgFwlogPolicyWatchHelper) GetObject() *FwlogPolicy {
	if m != nil {
		return m.Object
	}
	return nil
}

type AutoMsgStatsPolicyWatchHelper struct {
	Type   string       `protobuf:"bytes,1,opt,name=Type,proto3" json:"Type,omitempty"`
	Object *StatsPolicy `protobuf:"bytes,2,opt,name=Object" json:"Object,omitempty"`
}

func (m *AutoMsgStatsPolicyWatchHelper) Reset()         { *m = AutoMsgStatsPolicyWatchHelper{} }
func (m *AutoMsgStatsPolicyWatchHelper) String() string { return proto.CompactTextString(m) }
func (*AutoMsgStatsPolicyWatchHelper) ProtoMessage()    {}
func (*AutoMsgStatsPolicyWatchHelper) Descriptor() ([]byte, []int) {
	return fileDescriptorTelemetry, []int{2}
}

func (m *AutoMsgStatsPolicyWatchHelper) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *AutoMsgStatsPolicyWatchHelper) GetObject() *StatsPolicy {
	if m != nil {
		return m.Object
	}
	return nil
}

type FlowExportPolicy struct {
	api.TypeMeta   `protobuf:"bytes,1,opt,name=T,embedded=T" json:",inline"`
	api.ObjectMeta `protobuf:"bytes,2,opt,name=O,embedded=O" json:"meta,omitempty"`
	Spec           FlowExportSpec   `protobuf:"bytes,3,opt,name=Spec" json:"spec,omitempty"`
	Status         FlowExportStatus `protobuf:"bytes,4,opt,name=Status" json:"status,omitempty"`
}

func (m *FlowExportPolicy) Reset()                    { *m = FlowExportPolicy{} }
func (m *FlowExportPolicy) String() string            { return proto.CompactTextString(m) }
func (*FlowExportPolicy) ProtoMessage()               {}
func (*FlowExportPolicy) Descriptor() ([]byte, []int) { return fileDescriptorTelemetry, []int{3} }

func (m *FlowExportPolicy) GetSpec() FlowExportSpec {
	if m != nil {
		return m.Spec
	}
	return FlowExportSpec{}
}

func (m *FlowExportPolicy) GetStatus() FlowExportStatus {
	if m != nil {
		return m.Status
	}
	return FlowExportStatus{}
}

// firewall log export config
type FlowExportPolicyList struct {
	// Target contains ip/port/protocol
	api.TypeMeta `protobuf:"bytes,2,opt,name=T,embedded=T" json:"T"`
	// fwlog format, SYSLOG_BSD default
	api.ListMeta `protobuf:"bytes,3,opt,name=ListMeta,embedded=ListMeta" json:"ListMeta"`
	// filter firewall logs, FWLOG_ALL default
	Items []*FlowExportPolicy `protobuf:"bytes,4,rep,name=Items" json:"Items,omitempty"`
}

func (m *FlowExportPolicyList) Reset()                    { *m = FlowExportPolicyList{} }
func (m *FlowExportPolicyList) String() string            { return proto.CompactTextString(m) }
func (*FlowExportPolicyList) ProtoMessage()               {}
func (*FlowExportPolicyList) Descriptor() ([]byte, []int) { return fileDescriptorTelemetry, []int{4} }

func (m *FlowExportPolicyList) GetItems() []*FlowExportPolicy {
	if m != nil {
		return m.Items
	}
	return nil
}

// Venice collects fwlog irrespective of the export config
type FlowExportSpec struct {
	// RetentionTime defines for how long to keep the fwlog before it is deleted
	Targets []FlowExportTarget `protobuf:"bytes,1,rep,name=Targets" json:"targets,omitempty"`
}

func (m *FlowExportSpec) Reset()                    { *m = FlowExportSpec{} }
func (m *FlowExportSpec) String() string            { return proto.CompactTextString(m) }
func (*FlowExportSpec) ProtoMessage()               {}
func (*FlowExportSpec) Descriptor() ([]byte, []int) { return fileDescriptorTelemetry, []int{5} }

func (m *FlowExportSpec) GetTargets() []FlowExportTarget {
	if m != nil {
		return m.Targets
	}
	return nil
}

type FlowExportStatus struct {
}

func (m *FlowExportStatus) Reset()                    { *m = FlowExportStatus{} }
func (m *FlowExportStatus) String() string            { return proto.CompactTextString(m) }
func (*FlowExportStatus) ProtoMessage()               {}
func (*FlowExportStatus) Descriptor() ([]byte, []int) { return fileDescriptorTelemetry, []int{6} }

// ========================================================================================
//  flow export policy
// ========================================================================================
type FlowExportTarget struct {
	Interval string              `protobuf:"bytes,1,opt,name=Interval,proto3" json:"interval,omitempty"`
	Format   string              `protobuf:"bytes,2,opt,name=Format,proto3" json:"format,omitempty"`
	Exports  []api1.ExportConfig `protobuf:"bytes,3,rep,name=Exports" json:"exports,omitempty"`
}

func (m *FlowExportTarget) Reset()                    { *m = FlowExportTarget{} }
func (m *FlowExportTarget) String() string            { return proto.CompactTextString(m) }
func (*FlowExportTarget) ProtoMessage()               {}
func (*FlowExportTarget) Descriptor() ([]byte, []int) { return fileDescriptorTelemetry, []int{7} }

func (m *FlowExportTarget) GetInterval() string {
	if m != nil {
		return m.Interval
	}
	return ""
}

func (m *FlowExportTarget) GetFormat() string {
	if m != nil {
		return m.Format
	}
	return ""
}

func (m *FlowExportTarget) GetExports() []api1.ExportConfig {
	if m != nil {
		return m.Exports
	}
	return nil
}

type FwlogExport struct {
	// Interval defines how often to push the records to an external or internal collector
	// The value is specified as a string format to be '10s', '20m', '20mins', '10secs', '10seconds'
	Targets []api1.ExportConfig `protobuf:"bytes,1,rep,name=Targets" json:"targets,omitempty"`
	Format  string              `protobuf:"bytes,2,opt,name=Format,proto3" json:"format,omitempty"`
	// Export contains export parameters.
	Filter       []string                 `protobuf:"bytes,3,rep,name=Filter" json:"export-filter,omitempty"`
	SyslogConfig *api1.SyslogExportConfig `protobuf:"bytes,4,opt,name=SyslogConfig" json:"syslog-config,omitempty"`
}

func (m *FwlogExport) Reset()                    { *m = FwlogExport{} }
func (m *FwlogExport) String() string            { return proto.CompactTextString(m) }
func (*FwlogExport) ProtoMessage()               {}
func (*FwlogExport) Descriptor() ([]byte, []int) { return fileDescriptorTelemetry, []int{8} }

func (m *FwlogExport) GetTargets() []api1.ExportConfig {
	if m != nil {
		return m.Targets
	}
	return nil
}

func (m *FwlogExport) GetFormat() string {
	if m != nil {
		return m.Format
	}
	return ""
}

func (m *FwlogExport) GetFilter() []string {
	if m != nil {
		return m.Filter
	}
	return nil
}

func (m *FwlogExport) GetSyslogConfig() *api1.SyslogExportConfig {
	if m != nil {
		return m.SyslogConfig
	}
	return nil
}

type FwlogPolicy struct {
	api.TypeMeta   `protobuf:"bytes,1,opt,name=T,embedded=T" json:",inline"`
	api.ObjectMeta `protobuf:"bytes,2,opt,name=O,embedded=O" json:"meta,omitempty"`
	Spec           FwlogSpec   `protobuf:"bytes,3,opt,name=Spec" json:"spec,omitempty"`
	Status         FwlogStatus `protobuf:"bytes,4,opt,name=Status" json:"status,omitempty"`
}

func (m *FwlogPolicy) Reset()                    { *m = FwlogPolicy{} }
func (m *FwlogPolicy) String() string            { return proto.CompactTextString(m) }
func (*FwlogPolicy) ProtoMessage()               {}
func (*FwlogPolicy) Descriptor() ([]byte, []int) { return fileDescriptorTelemetry, []int{9} }

func (m *FwlogPolicy) GetSpec() FwlogSpec {
	if m != nil {
		return m.Spec
	}
	return FwlogSpec{}
}

func (m *FwlogPolicy) GetStatus() FwlogStatus {
	if m != nil {
		return m.Status
	}
	return FwlogStatus{}
}

type FwlogPolicyList struct {
	api.TypeMeta `protobuf:"bytes,2,opt,name=T,embedded=T" json:"T"`
	api.ListMeta `protobuf:"bytes,3,opt,name=ListMeta,embedded=ListMeta" json:"ListMeta"`
	Items        []*FwlogPolicy `protobuf:"bytes,4,rep,name=Items" json:"Items,omitempty"`
}

func (m *FwlogPolicyList) Reset()                    { *m = FwlogPolicyList{} }
func (m *FwlogPolicyList) String() string            { return proto.CompactTextString(m) }
func (*FwlogPolicyList) ProtoMessage()               {}
func (*FwlogPolicyList) Descriptor() ([]byte, []int) { return fileDescriptorTelemetry, []int{10} }

func (m *FwlogPolicyList) GetItems() []*FwlogPolicy {
	if m != nil {
		return m.Items
	}
	return nil
}

type FwlogSpec struct {
	RetentionTime string         `protobuf:"bytes,1,opt,name=RetentionTime,proto3" json:"retention-time,omitempty"`
	Filter        []string       `protobuf:"bytes,2,rep,name=Filter" json:"filter,omitempty"`
	Exports       []*FwlogExport `protobuf:"bytes,3,rep,name=Exports" json:"exports,omitempty"`
}

func (m *FwlogSpec) Reset()                    { *m = FwlogSpec{} }
func (m *FwlogSpec) String() string            { return proto.CompactTextString(m) }
func (*FwlogSpec) ProtoMessage()               {}
func (*FwlogSpec) Descriptor() ([]byte, []int) { return fileDescriptorTelemetry, []int{11} }

func (m *FwlogSpec) GetRetentionTime() string {
	if m != nil {
		return m.RetentionTime
	}
	return ""
}

func (m *FwlogSpec) GetFilter() []string {
	if m != nil {
		return m.Filter
	}
	return nil
}

func (m *FwlogSpec) GetExports() []*FwlogExport {
	if m != nil {
		return m.Exports
	}
	return nil
}

type FwlogStatus struct {
}

func (m *FwlogStatus) Reset()                    { *m = FwlogStatus{} }
func (m *FwlogStatus) String() string            { return proto.CompactTextString(m) }
func (*FwlogStatus) ProtoMessage()               {}
func (*FwlogStatus) Descriptor() ([]byte, []int) { return fileDescriptorTelemetry, []int{12} }

type StatsPolicy struct {
	api.TypeMeta   `protobuf:"bytes,1,opt,name=T,embedded=T" json:",inline"`
	api.ObjectMeta `protobuf:"bytes,2,opt,name=O,embedded=O" json:"meta,omitempty"`
	Spec           StatsSpec   `protobuf:"bytes,3,opt,name=Spec" json:"spec,omitempty"`
	Status         StatsStatus `protobuf:"bytes,4,opt,name=Status" json:"status,omitempty"`
}

func (m *StatsPolicy) Reset()                    { *m = StatsPolicy{} }
func (m *StatsPolicy) String() string            { return proto.CompactTextString(m) }
func (*StatsPolicy) ProtoMessage()               {}
func (*StatsPolicy) Descriptor() ([]byte, []int) { return fileDescriptorTelemetry, []int{13} }

func (m *StatsPolicy) GetSpec() StatsSpec {
	if m != nil {
		return m.Spec
	}
	return StatsSpec{}
}

func (m *StatsPolicy) GetStatus() StatsStatus {
	if m != nil {
		return m.Status
	}
	return StatsStatus{}
}

type StatsPolicyList struct {
	api.TypeMeta `protobuf:"bytes,2,opt,name=T,embedded=T" json:"T"`
	api.ListMeta `protobuf:"bytes,3,opt,name=ListMeta,embedded=ListMeta" json:"ListMeta"`
	Items        []*StatsPolicy `protobuf:"bytes,4,rep,name=Items" json:"Items,omitempty"`
}

func (m *StatsPolicyList) Reset()                    { *m = StatsPolicyList{} }
func (m *StatsPolicyList) String() string            { return proto.CompactTextString(m) }
func (*StatsPolicyList) ProtoMessage()               {}
func (*StatsPolicyList) Descriptor() ([]byte, []int) { return fileDescriptorTelemetry, []int{14} }

func (m *StatsPolicyList) GetItems() []*StatsPolicy {
	if m != nil {
		return m.Items
	}
	return nil
}

type StatsSpec struct {
	CompactionInterval      string `protobuf:"bytes,1,opt,name=CompactionInterval,proto3" json:"compaction-interval ,omitempty"`
	RetentionTime           string `protobuf:"bytes,2,opt,name=RetentionTime,proto3" json:"retention-time,omitempty"`
	DownSampleRetentionTime string `protobuf:"bytes,3,opt,name=DownSampleRetentionTime,proto3" json:"downsample-retention-time,omitempty"`
}

func (m *StatsSpec) Reset()                    { *m = StatsSpec{} }
func (m *StatsSpec) String() string            { return proto.CompactTextString(m) }
func (*StatsSpec) ProtoMessage()               {}
func (*StatsSpec) Descriptor() ([]byte, []int) { return fileDescriptorTelemetry, []int{15} }

func (m *StatsSpec) GetCompactionInterval() string {
	if m != nil {
		return m.CompactionInterval
	}
	return ""
}

func (m *StatsSpec) GetRetentionTime() string {
	if m != nil {
		return m.RetentionTime
	}
	return ""
}

func (m *StatsSpec) GetDownSampleRetentionTime() string {
	if m != nil {
		return m.DownSampleRetentionTime
	}
	return ""
}

type StatsStatus struct {
}

func (m *StatsStatus) Reset()                    { *m = StatsStatus{} }
func (m *StatsStatus) String() string            { return proto.CompactTextString(m) }
func (*StatsStatus) ProtoMessage()               {}
func (*StatsStatus) Descriptor() ([]byte, []int) { return fileDescriptorTelemetry, []int{16} }

func init() {
	proto.RegisterType((*AutoMsgFlowExportPolicyWatchHelper)(nil), "telemetry.AutoMsgFlowExportPolicyWatchHelper")
	proto.RegisterType((*AutoMsgFwlogPolicyWatchHelper)(nil), "telemetry.AutoMsgFwlogPolicyWatchHelper")
	proto.RegisterType((*AutoMsgStatsPolicyWatchHelper)(nil), "telemetry.AutoMsgStatsPolicyWatchHelper")
	proto.RegisterType((*FlowExportPolicy)(nil), "telemetry.FlowExportPolicy")
	proto.RegisterType((*FlowExportPolicyList)(nil), "telemetry.FlowExportPolicyList")
	proto.RegisterType((*FlowExportSpec)(nil), "telemetry.FlowExportSpec")
	proto.RegisterType((*FlowExportStatus)(nil), "telemetry.FlowExportStatus")
	proto.RegisterType((*FlowExportTarget)(nil), "telemetry.FlowExportTarget")
	proto.RegisterType((*FwlogExport)(nil), "telemetry.FwlogExport")
	proto.RegisterType((*FwlogPolicy)(nil), "telemetry.FwlogPolicy")
	proto.RegisterType((*FwlogPolicyList)(nil), "telemetry.FwlogPolicyList")
	proto.RegisterType((*FwlogSpec)(nil), "telemetry.FwlogSpec")
	proto.RegisterType((*FwlogStatus)(nil), "telemetry.FwlogStatus")
	proto.RegisterType((*StatsPolicy)(nil), "telemetry.StatsPolicy")
	proto.RegisterType((*StatsPolicyList)(nil), "telemetry.StatsPolicyList")
	proto.RegisterType((*StatsSpec)(nil), "telemetry.StatsSpec")
	proto.RegisterType((*StatsStatus)(nil), "telemetry.StatsStatus")
	proto.RegisterEnum("telemetry.FwlogExportFormat", FwlogExportFormat_name, FwlogExportFormat_value)
	proto.RegisterEnum("telemetry.FwlogFilter", FwlogFilter_name, FwlogFilter_value)
	proto.RegisterEnum("telemetry.FlowExportTarget_Formats", FlowExportTarget_Formats_name, FlowExportTarget_Formats_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for FlowExportPolicyV1 service

type FlowExportPolicyV1Client interface {
	AutoAddFlowExportPolicy(ctx context.Context, in *FlowExportPolicy, opts ...grpc.CallOption) (*FlowExportPolicy, error)
	AutoDeleteFlowExportPolicy(ctx context.Context, in *FlowExportPolicy, opts ...grpc.CallOption) (*FlowExportPolicy, error)
	AutoGetFlowExportPolicy(ctx context.Context, in *FlowExportPolicy, opts ...grpc.CallOption) (*FlowExportPolicy, error)
	AutoListFlowExportPolicy(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (*FlowExportPolicyList, error)
	AutoUpdateFlowExportPolicy(ctx context.Context, in *FlowExportPolicy, opts ...grpc.CallOption) (*FlowExportPolicy, error)
	AutoWatchFlowExportPolicy(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (FlowExportPolicyV1_AutoWatchFlowExportPolicyClient, error)
}

type flowExportPolicyV1Client struct {
	cc *grpc.ClientConn
}

func NewFlowExportPolicyV1Client(cc *grpc.ClientConn) FlowExportPolicyV1Client {
	return &flowExportPolicyV1Client{cc}
}

func (c *flowExportPolicyV1Client) AutoAddFlowExportPolicy(ctx context.Context, in *FlowExportPolicy, opts ...grpc.CallOption) (*FlowExportPolicy, error) {
	out := new(FlowExportPolicy)
	err := grpc.Invoke(ctx, "/telemetry.FlowExportPolicyV1/AutoAddFlowExportPolicy", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *flowExportPolicyV1Client) AutoDeleteFlowExportPolicy(ctx context.Context, in *FlowExportPolicy, opts ...grpc.CallOption) (*FlowExportPolicy, error) {
	out := new(FlowExportPolicy)
	err := grpc.Invoke(ctx, "/telemetry.FlowExportPolicyV1/AutoDeleteFlowExportPolicy", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *flowExportPolicyV1Client) AutoGetFlowExportPolicy(ctx context.Context, in *FlowExportPolicy, opts ...grpc.CallOption) (*FlowExportPolicy, error) {
	out := new(FlowExportPolicy)
	err := grpc.Invoke(ctx, "/telemetry.FlowExportPolicyV1/AutoGetFlowExportPolicy", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *flowExportPolicyV1Client) AutoListFlowExportPolicy(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (*FlowExportPolicyList, error) {
	out := new(FlowExportPolicyList)
	err := grpc.Invoke(ctx, "/telemetry.FlowExportPolicyV1/AutoListFlowExportPolicy", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *flowExportPolicyV1Client) AutoUpdateFlowExportPolicy(ctx context.Context, in *FlowExportPolicy, opts ...grpc.CallOption) (*FlowExportPolicy, error) {
	out := new(FlowExportPolicy)
	err := grpc.Invoke(ctx, "/telemetry.FlowExportPolicyV1/AutoUpdateFlowExportPolicy", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *flowExportPolicyV1Client) AutoWatchFlowExportPolicy(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (FlowExportPolicyV1_AutoWatchFlowExportPolicyClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_FlowExportPolicyV1_serviceDesc.Streams[0], c.cc, "/telemetry.FlowExportPolicyV1/AutoWatchFlowExportPolicy", opts...)
	if err != nil {
		return nil, err
	}
	x := &flowExportPolicyV1AutoWatchFlowExportPolicyClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type FlowExportPolicyV1_AutoWatchFlowExportPolicyClient interface {
	Recv() (*AutoMsgFlowExportPolicyWatchHelper, error)
	grpc.ClientStream
}

type flowExportPolicyV1AutoWatchFlowExportPolicyClient struct {
	grpc.ClientStream
}

func (x *flowExportPolicyV1AutoWatchFlowExportPolicyClient) Recv() (*AutoMsgFlowExportPolicyWatchHelper, error) {
	m := new(AutoMsgFlowExportPolicyWatchHelper)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for FlowExportPolicyV1 service

type FlowExportPolicyV1Server interface {
	AutoAddFlowExportPolicy(context.Context, *FlowExportPolicy) (*FlowExportPolicy, error)
	AutoDeleteFlowExportPolicy(context.Context, *FlowExportPolicy) (*FlowExportPolicy, error)
	AutoGetFlowExportPolicy(context.Context, *FlowExportPolicy) (*FlowExportPolicy, error)
	AutoListFlowExportPolicy(context.Context, *api.ListWatchOptions) (*FlowExportPolicyList, error)
	AutoUpdateFlowExportPolicy(context.Context, *FlowExportPolicy) (*FlowExportPolicy, error)
	AutoWatchFlowExportPolicy(*api.ListWatchOptions, FlowExportPolicyV1_AutoWatchFlowExportPolicyServer) error
}

func RegisterFlowExportPolicyV1Server(s *grpc.Server, srv FlowExportPolicyV1Server) {
	s.RegisterService(&_FlowExportPolicyV1_serviceDesc, srv)
}

func _FlowExportPolicyV1_AutoAddFlowExportPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FlowExportPolicy)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FlowExportPolicyV1Server).AutoAddFlowExportPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/telemetry.FlowExportPolicyV1/AutoAddFlowExportPolicy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FlowExportPolicyV1Server).AutoAddFlowExportPolicy(ctx, req.(*FlowExportPolicy))
	}
	return interceptor(ctx, in, info, handler)
}

func _FlowExportPolicyV1_AutoDeleteFlowExportPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FlowExportPolicy)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FlowExportPolicyV1Server).AutoDeleteFlowExportPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/telemetry.FlowExportPolicyV1/AutoDeleteFlowExportPolicy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FlowExportPolicyV1Server).AutoDeleteFlowExportPolicy(ctx, req.(*FlowExportPolicy))
	}
	return interceptor(ctx, in, info, handler)
}

func _FlowExportPolicyV1_AutoGetFlowExportPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FlowExportPolicy)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FlowExportPolicyV1Server).AutoGetFlowExportPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/telemetry.FlowExportPolicyV1/AutoGetFlowExportPolicy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FlowExportPolicyV1Server).AutoGetFlowExportPolicy(ctx, req.(*FlowExportPolicy))
	}
	return interceptor(ctx, in, info, handler)
}

func _FlowExportPolicyV1_AutoListFlowExportPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(api.ListWatchOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FlowExportPolicyV1Server).AutoListFlowExportPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/telemetry.FlowExportPolicyV1/AutoListFlowExportPolicy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FlowExportPolicyV1Server).AutoListFlowExportPolicy(ctx, req.(*api.ListWatchOptions))
	}
	return interceptor(ctx, in, info, handler)
}

func _FlowExportPolicyV1_AutoUpdateFlowExportPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FlowExportPolicy)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FlowExportPolicyV1Server).AutoUpdateFlowExportPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/telemetry.FlowExportPolicyV1/AutoUpdateFlowExportPolicy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FlowExportPolicyV1Server).AutoUpdateFlowExportPolicy(ctx, req.(*FlowExportPolicy))
	}
	return interceptor(ctx, in, info, handler)
}

func _FlowExportPolicyV1_AutoWatchFlowExportPolicy_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(api.ListWatchOptions)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(FlowExportPolicyV1Server).AutoWatchFlowExportPolicy(m, &flowExportPolicyV1AutoWatchFlowExportPolicyServer{stream})
}

type FlowExportPolicyV1_AutoWatchFlowExportPolicyServer interface {
	Send(*AutoMsgFlowExportPolicyWatchHelper) error
	grpc.ServerStream
}

type flowExportPolicyV1AutoWatchFlowExportPolicyServer struct {
	grpc.ServerStream
}

func (x *flowExportPolicyV1AutoWatchFlowExportPolicyServer) Send(m *AutoMsgFlowExportPolicyWatchHelper) error {
	return x.ServerStream.SendMsg(m)
}

var _FlowExportPolicyV1_serviceDesc = grpc.ServiceDesc{
	ServiceName: "telemetry.FlowExportPolicyV1",
	HandlerType: (*FlowExportPolicyV1Server)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AutoAddFlowExportPolicy",
			Handler:    _FlowExportPolicyV1_AutoAddFlowExportPolicy_Handler,
		},
		{
			MethodName: "AutoDeleteFlowExportPolicy",
			Handler:    _FlowExportPolicyV1_AutoDeleteFlowExportPolicy_Handler,
		},
		{
			MethodName: "AutoGetFlowExportPolicy",
			Handler:    _FlowExportPolicyV1_AutoGetFlowExportPolicy_Handler,
		},
		{
			MethodName: "AutoListFlowExportPolicy",
			Handler:    _FlowExportPolicyV1_AutoListFlowExportPolicy_Handler,
		},
		{
			MethodName: "AutoUpdateFlowExportPolicy",
			Handler:    _FlowExportPolicyV1_AutoUpdateFlowExportPolicy_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "AutoWatchFlowExportPolicy",
			Handler:       _FlowExportPolicyV1_AutoWatchFlowExportPolicy_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "telemetry.proto",
}

// Client API for FwlogPolicyV1 service

type FwlogPolicyV1Client interface {
	AutoAddFwlogPolicy(ctx context.Context, in *FwlogPolicy, opts ...grpc.CallOption) (*FwlogPolicy, error)
	AutoDeleteFwlogPolicy(ctx context.Context, in *FwlogPolicy, opts ...grpc.CallOption) (*FwlogPolicy, error)
	AutoGetFwlogPolicy(ctx context.Context, in *FwlogPolicy, opts ...grpc.CallOption) (*FwlogPolicy, error)
	AutoListFwlogPolicy(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (*FwlogPolicyList, error)
	AutoUpdateFwlogPolicy(ctx context.Context, in *FwlogPolicy, opts ...grpc.CallOption) (*FwlogPolicy, error)
	AutoWatchFwlogPolicy(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (FwlogPolicyV1_AutoWatchFwlogPolicyClient, error)
}

type fwlogPolicyV1Client struct {
	cc *grpc.ClientConn
}

func NewFwlogPolicyV1Client(cc *grpc.ClientConn) FwlogPolicyV1Client {
	return &fwlogPolicyV1Client{cc}
}

func (c *fwlogPolicyV1Client) AutoAddFwlogPolicy(ctx context.Context, in *FwlogPolicy, opts ...grpc.CallOption) (*FwlogPolicy, error) {
	out := new(FwlogPolicy)
	err := grpc.Invoke(ctx, "/telemetry.FwlogPolicyV1/AutoAddFwlogPolicy", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fwlogPolicyV1Client) AutoDeleteFwlogPolicy(ctx context.Context, in *FwlogPolicy, opts ...grpc.CallOption) (*FwlogPolicy, error) {
	out := new(FwlogPolicy)
	err := grpc.Invoke(ctx, "/telemetry.FwlogPolicyV1/AutoDeleteFwlogPolicy", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fwlogPolicyV1Client) AutoGetFwlogPolicy(ctx context.Context, in *FwlogPolicy, opts ...grpc.CallOption) (*FwlogPolicy, error) {
	out := new(FwlogPolicy)
	err := grpc.Invoke(ctx, "/telemetry.FwlogPolicyV1/AutoGetFwlogPolicy", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fwlogPolicyV1Client) AutoListFwlogPolicy(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (*FwlogPolicyList, error) {
	out := new(FwlogPolicyList)
	err := grpc.Invoke(ctx, "/telemetry.FwlogPolicyV1/AutoListFwlogPolicy", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fwlogPolicyV1Client) AutoUpdateFwlogPolicy(ctx context.Context, in *FwlogPolicy, opts ...grpc.CallOption) (*FwlogPolicy, error) {
	out := new(FwlogPolicy)
	err := grpc.Invoke(ctx, "/telemetry.FwlogPolicyV1/AutoUpdateFwlogPolicy", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fwlogPolicyV1Client) AutoWatchFwlogPolicy(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (FwlogPolicyV1_AutoWatchFwlogPolicyClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_FwlogPolicyV1_serviceDesc.Streams[0], c.cc, "/telemetry.FwlogPolicyV1/AutoWatchFwlogPolicy", opts...)
	if err != nil {
		return nil, err
	}
	x := &fwlogPolicyV1AutoWatchFwlogPolicyClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type FwlogPolicyV1_AutoWatchFwlogPolicyClient interface {
	Recv() (*AutoMsgFwlogPolicyWatchHelper, error)
	grpc.ClientStream
}

type fwlogPolicyV1AutoWatchFwlogPolicyClient struct {
	grpc.ClientStream
}

func (x *fwlogPolicyV1AutoWatchFwlogPolicyClient) Recv() (*AutoMsgFwlogPolicyWatchHelper, error) {
	m := new(AutoMsgFwlogPolicyWatchHelper)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for FwlogPolicyV1 service

type FwlogPolicyV1Server interface {
	AutoAddFwlogPolicy(context.Context, *FwlogPolicy) (*FwlogPolicy, error)
	AutoDeleteFwlogPolicy(context.Context, *FwlogPolicy) (*FwlogPolicy, error)
	AutoGetFwlogPolicy(context.Context, *FwlogPolicy) (*FwlogPolicy, error)
	AutoListFwlogPolicy(context.Context, *api.ListWatchOptions) (*FwlogPolicyList, error)
	AutoUpdateFwlogPolicy(context.Context, *FwlogPolicy) (*FwlogPolicy, error)
	AutoWatchFwlogPolicy(*api.ListWatchOptions, FwlogPolicyV1_AutoWatchFwlogPolicyServer) error
}

func RegisterFwlogPolicyV1Server(s *grpc.Server, srv FwlogPolicyV1Server) {
	s.RegisterService(&_FwlogPolicyV1_serviceDesc, srv)
}

func _FwlogPolicyV1_AutoAddFwlogPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FwlogPolicy)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FwlogPolicyV1Server).AutoAddFwlogPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/telemetry.FwlogPolicyV1/AutoAddFwlogPolicy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FwlogPolicyV1Server).AutoAddFwlogPolicy(ctx, req.(*FwlogPolicy))
	}
	return interceptor(ctx, in, info, handler)
}

func _FwlogPolicyV1_AutoDeleteFwlogPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FwlogPolicy)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FwlogPolicyV1Server).AutoDeleteFwlogPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/telemetry.FwlogPolicyV1/AutoDeleteFwlogPolicy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FwlogPolicyV1Server).AutoDeleteFwlogPolicy(ctx, req.(*FwlogPolicy))
	}
	return interceptor(ctx, in, info, handler)
}

func _FwlogPolicyV1_AutoGetFwlogPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FwlogPolicy)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FwlogPolicyV1Server).AutoGetFwlogPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/telemetry.FwlogPolicyV1/AutoGetFwlogPolicy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FwlogPolicyV1Server).AutoGetFwlogPolicy(ctx, req.(*FwlogPolicy))
	}
	return interceptor(ctx, in, info, handler)
}

func _FwlogPolicyV1_AutoListFwlogPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(api.ListWatchOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FwlogPolicyV1Server).AutoListFwlogPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/telemetry.FwlogPolicyV1/AutoListFwlogPolicy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FwlogPolicyV1Server).AutoListFwlogPolicy(ctx, req.(*api.ListWatchOptions))
	}
	return interceptor(ctx, in, info, handler)
}

func _FwlogPolicyV1_AutoUpdateFwlogPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FwlogPolicy)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FwlogPolicyV1Server).AutoUpdateFwlogPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/telemetry.FwlogPolicyV1/AutoUpdateFwlogPolicy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FwlogPolicyV1Server).AutoUpdateFwlogPolicy(ctx, req.(*FwlogPolicy))
	}
	return interceptor(ctx, in, info, handler)
}

func _FwlogPolicyV1_AutoWatchFwlogPolicy_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(api.ListWatchOptions)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(FwlogPolicyV1Server).AutoWatchFwlogPolicy(m, &fwlogPolicyV1AutoWatchFwlogPolicyServer{stream})
}

type FwlogPolicyV1_AutoWatchFwlogPolicyServer interface {
	Send(*AutoMsgFwlogPolicyWatchHelper) error
	grpc.ServerStream
}

type fwlogPolicyV1AutoWatchFwlogPolicyServer struct {
	grpc.ServerStream
}

func (x *fwlogPolicyV1AutoWatchFwlogPolicyServer) Send(m *AutoMsgFwlogPolicyWatchHelper) error {
	return x.ServerStream.SendMsg(m)
}

var _FwlogPolicyV1_serviceDesc = grpc.ServiceDesc{
	ServiceName: "telemetry.FwlogPolicyV1",
	HandlerType: (*FwlogPolicyV1Server)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AutoAddFwlogPolicy",
			Handler:    _FwlogPolicyV1_AutoAddFwlogPolicy_Handler,
		},
		{
			MethodName: "AutoDeleteFwlogPolicy",
			Handler:    _FwlogPolicyV1_AutoDeleteFwlogPolicy_Handler,
		},
		{
			MethodName: "AutoGetFwlogPolicy",
			Handler:    _FwlogPolicyV1_AutoGetFwlogPolicy_Handler,
		},
		{
			MethodName: "AutoListFwlogPolicy",
			Handler:    _FwlogPolicyV1_AutoListFwlogPolicy_Handler,
		},
		{
			MethodName: "AutoUpdateFwlogPolicy",
			Handler:    _FwlogPolicyV1_AutoUpdateFwlogPolicy_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "AutoWatchFwlogPolicy",
			Handler:       _FwlogPolicyV1_AutoWatchFwlogPolicy_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "telemetry.proto",
}

// Client API for StatsPolicyV1 service

type StatsPolicyV1Client interface {
	AutoAddStatsPolicy(ctx context.Context, in *StatsPolicy, opts ...grpc.CallOption) (*StatsPolicy, error)
	AutoDeleteStatsPolicy(ctx context.Context, in *StatsPolicy, opts ...grpc.CallOption) (*StatsPolicy, error)
	AutoGetStatsPolicy(ctx context.Context, in *StatsPolicy, opts ...grpc.CallOption) (*StatsPolicy, error)
	AutoListStatsPolicy(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (*StatsPolicyList, error)
	AutoUpdateStatsPolicy(ctx context.Context, in *StatsPolicy, opts ...grpc.CallOption) (*StatsPolicy, error)
	AutoWatchStatsPolicy(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (StatsPolicyV1_AutoWatchStatsPolicyClient, error)
}

type statsPolicyV1Client struct {
	cc *grpc.ClientConn
}

func NewStatsPolicyV1Client(cc *grpc.ClientConn) StatsPolicyV1Client {
	return &statsPolicyV1Client{cc}
}

func (c *statsPolicyV1Client) AutoAddStatsPolicy(ctx context.Context, in *StatsPolicy, opts ...grpc.CallOption) (*StatsPolicy, error) {
	out := new(StatsPolicy)
	err := grpc.Invoke(ctx, "/telemetry.StatsPolicyV1/AutoAddStatsPolicy", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *statsPolicyV1Client) AutoDeleteStatsPolicy(ctx context.Context, in *StatsPolicy, opts ...grpc.CallOption) (*StatsPolicy, error) {
	out := new(StatsPolicy)
	err := grpc.Invoke(ctx, "/telemetry.StatsPolicyV1/AutoDeleteStatsPolicy", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *statsPolicyV1Client) AutoGetStatsPolicy(ctx context.Context, in *StatsPolicy, opts ...grpc.CallOption) (*StatsPolicy, error) {
	out := new(StatsPolicy)
	err := grpc.Invoke(ctx, "/telemetry.StatsPolicyV1/AutoGetStatsPolicy", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *statsPolicyV1Client) AutoListStatsPolicy(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (*StatsPolicyList, error) {
	out := new(StatsPolicyList)
	err := grpc.Invoke(ctx, "/telemetry.StatsPolicyV1/AutoListStatsPolicy", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *statsPolicyV1Client) AutoUpdateStatsPolicy(ctx context.Context, in *StatsPolicy, opts ...grpc.CallOption) (*StatsPolicy, error) {
	out := new(StatsPolicy)
	err := grpc.Invoke(ctx, "/telemetry.StatsPolicyV1/AutoUpdateStatsPolicy", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *statsPolicyV1Client) AutoWatchStatsPolicy(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (StatsPolicyV1_AutoWatchStatsPolicyClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_StatsPolicyV1_serviceDesc.Streams[0], c.cc, "/telemetry.StatsPolicyV1/AutoWatchStatsPolicy", opts...)
	if err != nil {
		return nil, err
	}
	x := &statsPolicyV1AutoWatchStatsPolicyClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type StatsPolicyV1_AutoWatchStatsPolicyClient interface {
	Recv() (*AutoMsgStatsPolicyWatchHelper, error)
	grpc.ClientStream
}

type statsPolicyV1AutoWatchStatsPolicyClient struct {
	grpc.ClientStream
}

func (x *statsPolicyV1AutoWatchStatsPolicyClient) Recv() (*AutoMsgStatsPolicyWatchHelper, error) {
	m := new(AutoMsgStatsPolicyWatchHelper)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for StatsPolicyV1 service

type StatsPolicyV1Server interface {
	AutoAddStatsPolicy(context.Context, *StatsPolicy) (*StatsPolicy, error)
	AutoDeleteStatsPolicy(context.Context, *StatsPolicy) (*StatsPolicy, error)
	AutoGetStatsPolicy(context.Context, *StatsPolicy) (*StatsPolicy, error)
	AutoListStatsPolicy(context.Context, *api.ListWatchOptions) (*StatsPolicyList, error)
	AutoUpdateStatsPolicy(context.Context, *StatsPolicy) (*StatsPolicy, error)
	AutoWatchStatsPolicy(*api.ListWatchOptions, StatsPolicyV1_AutoWatchStatsPolicyServer) error
}

func RegisterStatsPolicyV1Server(s *grpc.Server, srv StatsPolicyV1Server) {
	s.RegisterService(&_StatsPolicyV1_serviceDesc, srv)
}

func _StatsPolicyV1_AutoAddStatsPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StatsPolicy)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StatsPolicyV1Server).AutoAddStatsPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/telemetry.StatsPolicyV1/AutoAddStatsPolicy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StatsPolicyV1Server).AutoAddStatsPolicy(ctx, req.(*StatsPolicy))
	}
	return interceptor(ctx, in, info, handler)
}

func _StatsPolicyV1_AutoDeleteStatsPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StatsPolicy)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StatsPolicyV1Server).AutoDeleteStatsPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/telemetry.StatsPolicyV1/AutoDeleteStatsPolicy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StatsPolicyV1Server).AutoDeleteStatsPolicy(ctx, req.(*StatsPolicy))
	}
	return interceptor(ctx, in, info, handler)
}

func _StatsPolicyV1_AutoGetStatsPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StatsPolicy)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StatsPolicyV1Server).AutoGetStatsPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/telemetry.StatsPolicyV1/AutoGetStatsPolicy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StatsPolicyV1Server).AutoGetStatsPolicy(ctx, req.(*StatsPolicy))
	}
	return interceptor(ctx, in, info, handler)
}

func _StatsPolicyV1_AutoListStatsPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(api.ListWatchOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StatsPolicyV1Server).AutoListStatsPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/telemetry.StatsPolicyV1/AutoListStatsPolicy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StatsPolicyV1Server).AutoListStatsPolicy(ctx, req.(*api.ListWatchOptions))
	}
	return interceptor(ctx, in, info, handler)
}

func _StatsPolicyV1_AutoUpdateStatsPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StatsPolicy)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StatsPolicyV1Server).AutoUpdateStatsPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/telemetry.StatsPolicyV1/AutoUpdateStatsPolicy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StatsPolicyV1Server).AutoUpdateStatsPolicy(ctx, req.(*StatsPolicy))
	}
	return interceptor(ctx, in, info, handler)
}

func _StatsPolicyV1_AutoWatchStatsPolicy_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(api.ListWatchOptions)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(StatsPolicyV1Server).AutoWatchStatsPolicy(m, &statsPolicyV1AutoWatchStatsPolicyServer{stream})
}

type StatsPolicyV1_AutoWatchStatsPolicyServer interface {
	Send(*AutoMsgStatsPolicyWatchHelper) error
	grpc.ServerStream
}

type statsPolicyV1AutoWatchStatsPolicyServer struct {
	grpc.ServerStream
}

func (x *statsPolicyV1AutoWatchStatsPolicyServer) Send(m *AutoMsgStatsPolicyWatchHelper) error {
	return x.ServerStream.SendMsg(m)
}

var _StatsPolicyV1_serviceDesc = grpc.ServiceDesc{
	ServiceName: "telemetry.StatsPolicyV1",
	HandlerType: (*StatsPolicyV1Server)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AutoAddStatsPolicy",
			Handler:    _StatsPolicyV1_AutoAddStatsPolicy_Handler,
		},
		{
			MethodName: "AutoDeleteStatsPolicy",
			Handler:    _StatsPolicyV1_AutoDeleteStatsPolicy_Handler,
		},
		{
			MethodName: "AutoGetStatsPolicy",
			Handler:    _StatsPolicyV1_AutoGetStatsPolicy_Handler,
		},
		{
			MethodName: "AutoListStatsPolicy",
			Handler:    _StatsPolicyV1_AutoListStatsPolicy_Handler,
		},
		{
			MethodName: "AutoUpdateStatsPolicy",
			Handler:    _StatsPolicyV1_AutoUpdateStatsPolicy_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "AutoWatchStatsPolicy",
			Handler:       _StatsPolicyV1_AutoWatchStatsPolicy_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "telemetry.proto",
}

func (m *AutoMsgFlowExportPolicyWatchHelper) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AutoMsgFlowExportPolicyWatchHelper) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if m.Object != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.Object.Size()))
		n1, err := m.Object.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	return i, nil
}

func (m *AutoMsgFwlogPolicyWatchHelper) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AutoMsgFwlogPolicyWatchHelper) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if m.Object != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.Object.Size()))
		n2, err := m.Object.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}

func (m *AutoMsgStatsPolicyWatchHelper) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AutoMsgStatsPolicyWatchHelper) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if m.Object != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.Object.Size()))
		n3, err := m.Object.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}

func (m *FlowExportPolicy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlowExportPolicy) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintTelemetry(dAtA, i, uint64(m.TypeMeta.Size()))
	n4, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n4
	dAtA[i] = 0x12
	i++
	i = encodeVarintTelemetry(dAtA, i, uint64(m.ObjectMeta.Size()))
	n5, err := m.ObjectMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n5
	dAtA[i] = 0x1a
	i++
	i = encodeVarintTelemetry(dAtA, i, uint64(m.Spec.Size()))
	n6, err := m.Spec.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n6
	dAtA[i] = 0x22
	i++
	i = encodeVarintTelemetry(dAtA, i, uint64(m.Status.Size()))
	n7, err := m.Status.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n7
	return i, nil
}

func (m *FlowExportPolicyList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlowExportPolicyList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x12
	i++
	i = encodeVarintTelemetry(dAtA, i, uint64(m.TypeMeta.Size()))
	n8, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n8
	dAtA[i] = 0x1a
	i++
	i = encodeVarintTelemetry(dAtA, i, uint64(m.ListMeta.Size()))
	n9, err := m.ListMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n9
	if len(m.Items) > 0 {
		for _, msg := range m.Items {
			dAtA[i] = 0x22
			i++
			i = encodeVarintTelemetry(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *FlowExportSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlowExportSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Targets) > 0 {
		for _, msg := range m.Targets {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTelemetry(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *FlowExportStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlowExportStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *FlowExportTarget) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlowExportTarget) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Interval) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(len(m.Interval)))
		i += copy(dAtA[i:], m.Interval)
	}
	if len(m.Format) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(len(m.Format)))
		i += copy(dAtA[i:], m.Format)
	}
	if len(m.Exports) > 0 {
		for _, msg := range m.Exports {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintTelemetry(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *FwlogExport) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FwlogExport) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Targets) > 0 {
		for _, msg := range m.Targets {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTelemetry(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Format) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(len(m.Format)))
		i += copy(dAtA[i:], m.Format)
	}
	if len(m.Filter) > 0 {
		for _, s := range m.Filter {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.SyslogConfig != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.SyslogConfig.Size()))
		n10, err := m.SyslogConfig.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	return i, nil
}

func (m *FwlogPolicy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FwlogPolicy) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintTelemetry(dAtA, i, uint64(m.TypeMeta.Size()))
	n11, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n11
	dAtA[i] = 0x12
	i++
	i = encodeVarintTelemetry(dAtA, i, uint64(m.ObjectMeta.Size()))
	n12, err := m.ObjectMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n12
	dAtA[i] = 0x1a
	i++
	i = encodeVarintTelemetry(dAtA, i, uint64(m.Spec.Size()))
	n13, err := m.Spec.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n13
	dAtA[i] = 0x22
	i++
	i = encodeVarintTelemetry(dAtA, i, uint64(m.Status.Size()))
	n14, err := m.Status.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n14
	return i, nil
}

func (m *FwlogPolicyList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FwlogPolicyList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x12
	i++
	i = encodeVarintTelemetry(dAtA, i, uint64(m.TypeMeta.Size()))
	n15, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n15
	dAtA[i] = 0x1a
	i++
	i = encodeVarintTelemetry(dAtA, i, uint64(m.ListMeta.Size()))
	n16, err := m.ListMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n16
	if len(m.Items) > 0 {
		for _, msg := range m.Items {
			dAtA[i] = 0x22
			i++
			i = encodeVarintTelemetry(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *FwlogSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FwlogSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RetentionTime) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(len(m.RetentionTime)))
		i += copy(dAtA[i:], m.RetentionTime)
	}
	if len(m.Filter) > 0 {
		for _, s := range m.Filter {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Exports) > 0 {
		for _, msg := range m.Exports {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintTelemetry(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *FwlogStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FwlogStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *StatsPolicy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StatsPolicy) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintTelemetry(dAtA, i, uint64(m.TypeMeta.Size()))
	n17, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n17
	dAtA[i] = 0x12
	i++
	i = encodeVarintTelemetry(dAtA, i, uint64(m.ObjectMeta.Size()))
	n18, err := m.ObjectMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n18
	dAtA[i] = 0x1a
	i++
	i = encodeVarintTelemetry(dAtA, i, uint64(m.Spec.Size()))
	n19, err := m.Spec.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n19
	dAtA[i] = 0x22
	i++
	i = encodeVarintTelemetry(dAtA, i, uint64(m.Status.Size()))
	n20, err := m.Status.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n20
	return i, nil
}

func (m *StatsPolicyList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StatsPolicyList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x12
	i++
	i = encodeVarintTelemetry(dAtA, i, uint64(m.TypeMeta.Size()))
	n21, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n21
	dAtA[i] = 0x1a
	i++
	i = encodeVarintTelemetry(dAtA, i, uint64(m.ListMeta.Size()))
	n22, err := m.ListMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n22
	if len(m.Items) > 0 {
		for _, msg := range m.Items {
			dAtA[i] = 0x22
			i++
			i = encodeVarintTelemetry(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *StatsSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StatsSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.CompactionInterval) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(len(m.CompactionInterval)))
		i += copy(dAtA[i:], m.CompactionInterval)
	}
	if len(m.RetentionTime) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(len(m.RetentionTime)))
		i += copy(dAtA[i:], m.RetentionTime)
	}
	if len(m.DownSampleRetentionTime) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(len(m.DownSampleRetentionTime)))
		i += copy(dAtA[i:], m.DownSampleRetentionTime)
	}
	return i, nil
}

func (m *StatsStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StatsStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func encodeVarintTelemetry(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *AutoMsgFlowExportPolicyWatchHelper) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if m.Object != nil {
		l = m.Object.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	return n
}

func (m *AutoMsgFwlogPolicyWatchHelper) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if m.Object != nil {
		l = m.Object.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	return n
}

func (m *AutoMsgStatsPolicyWatchHelper) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if m.Object != nil {
		l = m.Object.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	return n
}

func (m *FlowExportPolicy) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovTelemetry(uint64(l))
	l = m.ObjectMeta.Size()
	n += 1 + l + sovTelemetry(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovTelemetry(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovTelemetry(uint64(l))
	return n
}

func (m *FlowExportPolicyList) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovTelemetry(uint64(l))
	l = m.ListMeta.Size()
	n += 1 + l + sovTelemetry(uint64(l))
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovTelemetry(uint64(l))
		}
	}
	return n
}

func (m *FlowExportSpec) Size() (n int) {
	var l int
	_ = l
	if len(m.Targets) > 0 {
		for _, e := range m.Targets {
			l = e.Size()
			n += 1 + l + sovTelemetry(uint64(l))
		}
	}
	return n
}

func (m *FlowExportStatus) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *FlowExportTarget) Size() (n int) {
	var l int
	_ = l
	l = len(m.Interval)
	if l > 0 {
		n += 1 + l + sovTelemetry(uint64(l))
	}
	l = len(m.Format)
	if l > 0 {
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if len(m.Exports) > 0 {
		for _, e := range m.Exports {
			l = e.Size()
			n += 1 + l + sovTelemetry(uint64(l))
		}
	}
	return n
}

func (m *FwlogExport) Size() (n int) {
	var l int
	_ = l
	if len(m.Targets) > 0 {
		for _, e := range m.Targets {
			l = e.Size()
			n += 1 + l + sovTelemetry(uint64(l))
		}
	}
	l = len(m.Format)
	if l > 0 {
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if len(m.Filter) > 0 {
		for _, s := range m.Filter {
			l = len(s)
			n += 1 + l + sovTelemetry(uint64(l))
		}
	}
	if m.SyslogConfig != nil {
		l = m.SyslogConfig.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	return n
}

func (m *FwlogPolicy) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovTelemetry(uint64(l))
	l = m.ObjectMeta.Size()
	n += 1 + l + sovTelemetry(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovTelemetry(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovTelemetry(uint64(l))
	return n
}

func (m *FwlogPolicyList) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovTelemetry(uint64(l))
	l = m.ListMeta.Size()
	n += 1 + l + sovTelemetry(uint64(l))
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovTelemetry(uint64(l))
		}
	}
	return n
}

func (m *FwlogSpec) Size() (n int) {
	var l int
	_ = l
	l = len(m.RetentionTime)
	if l > 0 {
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if len(m.Filter) > 0 {
		for _, s := range m.Filter {
			l = len(s)
			n += 1 + l + sovTelemetry(uint64(l))
		}
	}
	if len(m.Exports) > 0 {
		for _, e := range m.Exports {
			l = e.Size()
			n += 1 + l + sovTelemetry(uint64(l))
		}
	}
	return n
}

func (m *FwlogStatus) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *StatsPolicy) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovTelemetry(uint64(l))
	l = m.ObjectMeta.Size()
	n += 1 + l + sovTelemetry(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovTelemetry(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovTelemetry(uint64(l))
	return n
}

func (m *StatsPolicyList) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovTelemetry(uint64(l))
	l = m.ListMeta.Size()
	n += 1 + l + sovTelemetry(uint64(l))
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovTelemetry(uint64(l))
		}
	}
	return n
}

func (m *StatsSpec) Size() (n int) {
	var l int
	_ = l
	l = len(m.CompactionInterval)
	if l > 0 {
		n += 1 + l + sovTelemetry(uint64(l))
	}
	l = len(m.RetentionTime)
	if l > 0 {
		n += 1 + l + sovTelemetry(uint64(l))
	}
	l = len(m.DownSampleRetentionTime)
	if l > 0 {
		n += 1 + l + sovTelemetry(uint64(l))
	}
	return n
}

func (m *StatsStatus) Size() (n int) {
	var l int
	_ = l
	return n
}

func sovTelemetry(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozTelemetry(x uint64) (n int) {
	return sovTelemetry(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *AutoMsgFlowExportPolicyWatchHelper) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AutoMsgFlowExportPolicyWatchHelper: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AutoMsgFlowExportPolicyWatchHelper: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Object", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Object == nil {
				m.Object = &FlowExportPolicy{}
			}
			if err := m.Object.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AutoMsgFwlogPolicyWatchHelper) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AutoMsgFwlogPolicyWatchHelper: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AutoMsgFwlogPolicyWatchHelper: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Object", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Object == nil {
				m.Object = &FwlogPolicy{}
			}
			if err := m.Object.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AutoMsgStatsPolicyWatchHelper) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AutoMsgStatsPolicyWatchHelper: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AutoMsgStatsPolicyWatchHelper: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Object", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Object == nil {
				m.Object = &StatsPolicy{}
			}
			if err := m.Object.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlowExportPolicy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlowExportPolicy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlowExportPolicy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlowExportPolicyList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlowExportPolicyList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlowExportPolicyList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ListMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &FlowExportPolicy{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlowExportSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlowExportSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlowExportSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Targets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Targets = append(m.Targets, FlowExportTarget{})
			if err := m.Targets[len(m.Targets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlowExportStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlowExportStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlowExportStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlowExportTarget) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlowExportTarget: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlowExportTarget: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Interval", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Interval = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Format", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Format = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exports", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Exports = append(m.Exports, api1.ExportConfig{})
			if err := m.Exports[len(m.Exports)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FwlogExport) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FwlogExport: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FwlogExport: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Targets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Targets = append(m.Targets, api1.ExportConfig{})
			if err := m.Targets[len(m.Targets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Format", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Format = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Filter = append(m.Filter, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SyslogConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SyslogConfig == nil {
				m.SyslogConfig = &api1.SyslogExportConfig{}
			}
			if err := m.SyslogConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FwlogPolicy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FwlogPolicy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FwlogPolicy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FwlogPolicyList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FwlogPolicyList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FwlogPolicyList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ListMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &FwlogPolicy{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FwlogSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FwlogSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FwlogSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetentionTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RetentionTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Filter = append(m.Filter, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exports", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Exports = append(m.Exports, &FwlogExport{})
			if err := m.Exports[len(m.Exports)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FwlogStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FwlogStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FwlogStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StatsPolicy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StatsPolicy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StatsPolicy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StatsPolicyList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StatsPolicyList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StatsPolicyList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ListMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &StatsPolicy{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StatsSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StatsSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StatsSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompactionInterval", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CompactionInterval = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetentionTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RetentionTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DownSampleRetentionTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DownSampleRetentionTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StatsStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StatsStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StatsStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTelemetry(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthTelemetry
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowTelemetry
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipTelemetry(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthTelemetry = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTelemetry   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("telemetry.proto", fileDescriptorTelemetry) }

var fileDescriptorTelemetry = []byte{
	// 1606 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x58, 0xcf, 0x73, 0xd3, 0xc6,
	0x17, 0xb7, 0xec, 0xe0, 0xe0, 0xcd, 0x2f, 0xb3, 0x04, 0x62, 0x19, 0x88, 0xf3, 0x15, 0x03, 0x84,
	0x10, 0xdb, 0x60, 0xf8, 0x0e, 0x43, 0xbe, 0xdf, 0x99, 0x82, 0x13, 0x87, 0x1f, 0x0d, 0x24, 0x8d,
	0x5d, 0x28, 0xa7, 0x8e, 0x62, 0xaf, 0x1d, 0x75, 0x64, 0x49, 0x63, 0xad, 0x09, 0x99, 0x0e, 0x97,
	0x3a, 0xc9, 0xf4, 0xd0, 0x4b, 0xdb, 0x03, 0x9d, 0xde, 0xca, 0xa1, 0x87, 0x1c, 0x73, 0xea, 0xf4,
	0x2f, 0xe0, 0x06, 0x43, 0x6f, 0x1c, 0x3c, 0x1d, 0xa6, 0xa7, 0xfc, 0x03, 0xbd, 0x76, 0x76, 0x57,
	0xb6, 0x57, 0xb2, 0x24, 0xbb, 0x63, 0xfa, 0xe3, 0x66, 0x3d, 0xbd, 0xfd, 0xbc, 0xb7, 0x9f, 0x7d,
	0x9f, 0xa7, 0xb7, 0x06, 0x13, 0x18, 0xa9, 0xa8, 0x8a, 0x70, 0x6d, 0x3b, 0x65, 0xd4, 0x74, 0xac,
	0xc3, 0x48, 0xdb, 0x10, 0x3f, 0x5d, 0xd1, 0xf5, 0x8a, 0x8a, 0xd2, 0xb2, 0xa1, 0xa4, 0x65, 0x4d,
	0xd3, 0xb1, 0x8c, 0x15, 0x5d, 0x33, 0x99, 0x63, 0x3c, 0x57, 0x51, 0xf0, 0x66, 0x7d, 0x23, 0x55,
	0xd4, 0xab, 0x69, 0x03, 0x69, 0xa6, 0xac, 0x95, 0xf4, 0xb4, 0xb9, 0x95, 0x7e, 0x82, 0x34, 0xa5,
	0x88, 0xd2, 0x75, 0xac, 0xa8, 0x26, 0x59, 0x5a, 0x41, 0x1a, 0xbf, 0x3a, 0xad, 0x68, 0x45, 0xb5,
	0x5e, 0x42, 0x2d, 0x98, 0x24, 0x07, 0x53, 0xd1, 0x2b, 0x7a, 0x9a, 0x9a, 0x37, 0xea, 0x65, 0xfa,
	0x44, 0x1f, 0xe8, 0x2f, 0xcb, 0xfd, 0x9c, 0x47, 0x54, 0x92, 0x63, 0x15, 0x61, 0xd9, 0x72, 0xbb,
	0xe0, 0xe3, 0x86, 0x9e, 0x1a, 0x7a, 0x0d, 0x33, 0x47, 0xc9, 0x00, 0xd2, 0xad, 0x3a, 0xd6, 0xef,
	0x9b, 0x95, 0x65, 0x55, 0xdf, 0xca, 0xd1, 0x57, 0x6b, 0xba, 0xaa, 0x14, 0xb7, 0x1f, 0xc9, 0xb8,
	0xb8, 0x79, 0x07, 0xa9, 0x06, 0xaa, 0xc1, 0x51, 0x30, 0x54, 0xd8, 0x36, 0x50, 0x4c, 0x98, 0x11,
	0x66, 0x23, 0xf0, 0x12, 0x08, 0xaf, 0x6e, 0x7c, 0x86, 0x8a, 0x38, 0x16, 0x9c, 0x11, 0x66, 0x47,
	0x32, 0xa7, 0x52, 0x1d, 0x12, 0x9d, 0x28, 0x0b, 0x13, 0x6f, 0x77, 0xc5, 0x91, 0x2d, 0x82, 0xb5,
	0x49, 0xb1, 0xa4, 0x32, 0x38, 0xd3, 0x8a, 0xb8, 0xa5, 0xea, 0x95, 0x5e, 0xc1, 0xce, 0x3b, 0x82,
	0x9d, 0xe4, 0x83, 0x75, 0x00, 0xfc, 0xe2, 0xe4, 0xb1, 0x8c, 0xcd, 0x41, 0xe2, 0x70, 0x00, 0xdd,
	0x71, 0x7e, 0x0e, 0x82, 0xa8, 0x73, 0xd7, 0xf0, 0x32, 0x10, 0x0a, 0x14, 0x78, 0x24, 0x33, 0x96,
	0x92, 0x0d, 0x25, 0x45, 0x22, 0xdd, 0x47, 0x58, 0xce, 0x1e, 0x7f, 0xd9, 0x4c, 0x04, 0x5e, 0x37,
	0x13, 0xc2, 0x61, 0x33, 0x31, 0x3c, 0xaf, 0x68, 0xaa, 0xa2, 0xa1, 0x75, 0xa1, 0x00, 0x6f, 0x00,
	0x61, 0xd5, 0x0a, 0x3d, 0x41, 0x57, 0xb0, 0x6c, 0xe8, 0x9a, 0x38, 0xb7, 0x66, 0x9c, 0x9c, 0xf2,
	0xbc, 0x5e, 0x55, 0x30, 0xaa, 0x1a, 0x78, 0x7b, 0x5d, 0x58, 0x85, 0x39, 0x30, 0x94, 0x37, 0x50,
	0x31, 0x16, 0xa2, 0xab, 0x45, 0xd7, 0xd3, 0x20, 0x0e, 0xd9, 0x93, 0x04, 0x87, 0x60, 0x98, 0x06,
	0x2a, 0x72, 0x18, 0x74, 0x39, 0xbc, 0x0f, 0xc2, 0x64, 0xa3, 0x75, 0x33, 0x36, 0xe4, 0x73, 0xac,
	0xcc, 0x25, 0x1b, 0xb3, 0xa0, 0xa2, 0x26, 0x7d, 0xe6, 0xc0, 0x2c, 0x90, 0x85, 0xb3, 0x6f, 0x76,
	0xc5, 0x04, 0x18, 0x49, 0x7f, 0xbe, 0x9a, 0x2a, 0x20, 0x4d, 0xd6, 0xf0, 0x33, 0x18, 0x2d, 0x3b,
	0x78, 0x92, 0x7e, 0x10, 0xc0, 0xa4, 0x93, 0xbc, 0x15, 0xc5, 0xc4, 0x50, 0x22, 0x04, 0x06, 0xdd,
	0x08, 0x3c, 0xda, 0x22, 0x03, 0x5e, 0x04, 0x47, 0x89, 0x2f, 0xb1, 0x5a, 0x7b, 0x67, 0xae, 0x2d,
	0x23, 0xe7, 0x3a, 0x07, 0x8e, 0xdc, 0xc5, 0xa8, 0x4a, 0xb6, 0x16, 0xea, 0x55, 0xb1, 0xe3, 0x6f,
	0x77, 0x45, 0xa0, 0x2a, 0x26, 0xb6, 0x0e, 0x78, 0x03, 0x8c, 0xdb, 0x79, 0x84, 0x6b, 0x60, 0xb8,
	0x20, 0xd7, 0x2a, 0x08, 0x9b, 0x31, 0xc1, 0x07, 0x8f, 0xf9, 0x64, 0x45, 0x8b, 0xaa, 0x63, 0x98,
	0xad, 0xe1, 0xb8, 0x6a, 0xc1, 0x48, 0x90, 0xaf, 0x21, 0x46, 0xa0, 0xf4, 0xbb, 0xc0, 0x1b, 0x99,
	0x27, 0xcc, 0x80, 0xa3, 0x77, 0x35, 0x8c, 0x6a, 0x4f, 0x64, 0x95, 0x15, 0x6e, 0xf6, 0xe4, 0x61,
	0x33, 0x01, 0x15, 0xcb, 0xc6, 0x61, 0xb7, 0xfd, 0xe0, 0x47, 0x20, 0xbc, 0xac, 0xd7, 0xaa, 0x32,
	0x2b, 0xed, 0x48, 0xf6, 0xc6, 0xfe, 0x9e, 0xf8, 0x9f, 0x3c, 0xae, 0xe5, 0xb4, 0x7a, 0x75, 0xd6,
	0x19, 0x21, 0xc5, 0x5c, 0xcd, 0x8b, 0xe4, 0x70, 0xcb, 0xf4, 0x37, 0x7f, 0xb8, 0xec, 0x2d, 0x5c,
	0x06, 0xc3, 0x6c, 0x91, 0x19, 0x0b, 0x51, 0x06, 0x8e, 0x51, 0xe6, 0x99, 0x6d, 0x51, 0xd7, 0xca,
	0x4a, 0xa5, 0xb3, 0x6f, 0xd6, 0x70, 0x6c, 0xfb, 0xb6, 0x16, 0x4b, 0x93, 0x60, 0xd8, 0x8a, 0x07,
	0x23, 0xe0, 0xc8, 0x5d, 0xa3, 0xac, 0x3c, 0x8d, 0x06, 0xa4, 0x97, 0x41, 0x30, 0x42, 0xb5, 0xcd,
	0xdc, 0x48, 0x34, 0x3b, 0xdf, 0x7e, 0xd1, 0xbc, 0x59, 0x86, 0xf7, 0x1c, 0x44, 0x64, 0xf6, 0xf7,
	0xc4, 0x78, 0x9b, 0x88, 0x4e, 0x40, 0xe6, 0xe4, 0xcf, 0xc0, 0x87, 0x20, 0xbc, 0xac, 0xa8, 0x18,
	0xd5, 0x28, 0x01, 0x91, 0xec, 0xd5, 0xfd, 0x3d, 0x71, 0xd2, 0x86, 0xc5, 0x5e, 0x13, 0x94, 0x29,
	0xc6, 0x40, 0xb2, 0x4c, 0x2d, 0x36, 0x30, 0x6a, 0x81, 0x9f, 0x80, 0xd1, 0xfc, 0xb6, 0xa9, 0xea,
	0x15, 0xb6, 0x19, 0x4b, 0x80, 0x53, 0x74, 0x97, 0xec, 0x85, 0x6d, 0xaf, 0xa7, 0x08, 0xa6, 0x49,
	0xed, 0xc9, 0x22, 0x35, 0x71, 0x98, 0x36, 0x24, 0xe9, 0xc7, 0x16, 0x95, 0xff, 0x44, 0x63, 0xba,
	0x69, 0x6b, 0x4c, 0x93, 0xce, 0xce, 0xdd, 0x47, 0x4f, 0xba, 0xe3, 0xe8, 0x49, 0x5d, 0xdd, 0xbf,
	0xef, 0x76, 0x34, 0xfd, 0x66, 0x57, 0x8c, 0xdb, 0xdb, 0xd1, 0x48, 0xb9, 0x43, 0x8c, 0xf4, 0x5c,
	0x00, 0x13, 0x1c, 0x51, 0x7f, 0x45, 0x13, 0x3a, 0x67, 0x6f, 0x42, 0x5e, 0x5f, 0x32, 0x67, 0xff,
	0x69, 0x0a, 0x20, 0xd2, 0xe6, 0x0b, 0x66, 0xc1, 0xd8, 0x3a, 0xc2, 0x48, 0x23, 0xc3, 0x44, 0x41,
	0xa9, 0x5a, 0x9f, 0xaf, 0xec, 0xe9, 0xc3, 0x66, 0x22, 0x56, 0x6b, 0xbd, 0x48, 0x62, 0xa5, 0x8a,
	0x38, 0x12, 0xec, 0x4b, 0xe0, 0x52, 0xbb, 0x76, 0x83, 0xb4, 0x76, 0xe7, 0x7d, 0x6a, 0x37, 0xea,
	0x59, 0xb4, 0xb7, 0x9d, 0x3d, 0xa0, 0x6b, 0x43, 0xec, 0x75, 0xf6, 0x44, 0x8f, 0x26, 0x30, 0x66,
	0x95, 0xa8, 0xd5, 0xf7, 0x48, 0xc9, 0x72, 0x5f, 0xdc, 0x7f, 0x4b, 0xc9, 0xd2, 0x94, 0x06, 0x2c,
	0x59, 0x86, 0x31, 0x48, 0xc9, 0x72, 0xc4, 0xd0, 0x92, 0xe5, 0x9e, 0xff, 0xe6, 0x92, 0xe5, 0x87,
	0x22, 0x67, 0xc9, 0xee, 0x05, 0x41, 0xa4, 0xcd, 0x17, 0x5c, 0x07, 0x70, 0x51, 0xaf, 0x1a, 0x72,
	0x91, 0x14, 0xa0, 0xe3, 0xeb, 0x25, 0x1d, 0x36, 0x13, 0xd3, 0xc5, 0xf6, 0xdb, 0x64, 0xeb, 0x43,
	0x36, 0xc3, 0xf1, 0xe1, 0xb2, 0xba, 0x5b, 0x06, 0xc1, 0x3f, 0x2f, 0x03, 0x19, 0x4c, 0x2d, 0xe9,
	0x5b, 0x5a, 0x5e, 0xae, 0x1a, 0x2a, 0xb2, 0xa3, 0x85, 0x28, 0xda, 0x85, 0xc3, 0x66, 0xe2, 0x6c,
	0x49, 0xdf, 0xd2, 0x4c, 0xea, 0x92, 0xf4, 0x04, 0xf6, 0xc2, 0x21, 0xa5, 0xcd, 0x9d, 0xf9, 0xdc,
	0x75, 0x70, 0xac, 0xeb, 0x33, 0x03, 0xc7, 0x01, 0xc8, 0x3f, 0xce, 0xaf, 0xac, 0xde, 0xfe, 0x34,
	0x9b, 0x5f, 0x8a, 0x06, 0x20, 0x04, 0xe3, 0xd6, 0xf3, 0xfa, 0xf2, 0xe2, 0x7f, 0xaf, 0x65, 0xae,
	0x45, 0x85, 0xb9, 0x35, 0x4b, 0x22, 0x96, 0xf4, 0xc6, 0x40, 0x64, 0xf9, 0x11, 0xf1, 0xb8, 0xb5,
	0xb2, 0x12, 0x0d, 0xc0, 0x28, 0x18, 0xb5, 0x1e, 0x17, 0x17, 0x73, 0x6b, 0x85, 0xa8, 0xd0, 0xb1,
	0xac, 0xe7, 0xee, 0xe5, 0x16, 0x0b, 0xd1, 0x20, 0x89, 0xc2, 0x2c, 0x4b, 0xb9, 0x07, 0x8f, 0xa3,
	0xa1, 0xcc, 0xab, 0x61, 0x00, 0x9d, 0xa3, 0xcf, 0xc3, 0x2b, 0xf0, 0x2b, 0x01, 0x4c, 0x91, 0xb1,
	0xf9, 0x56, 0xa9, 0xd4, 0x35, 0xd4, 0xfa, 0x4d, 0x4d, 0x71, 0xbf, 0x97, 0xd2, 0xf5, 0x83, 0x1d,
	0x31, 0x5c, 0xac, 0x21, 0x19, 0xa3, 0x9f, 0x76, 0x44, 0xe1, 0x8b, 0x5f, 0x7e, 0xfb, 0x36, 0x78,
	0x16, 0x04, 0x16, 0x84, 0x39, 0xe9, 0x34, 0x57, 0xde, 0x69, 0xe7, 0x7c, 0x08, 0x9f, 0x0b, 0x20,
	0x4e, 0xd2, 0x59, 0x42, 0x2a, 0xc2, 0xe8, 0x3d, 0x66, 0xf4, 0x01, 0xc9, 0xa8, 0x44, 0x51, 0xdb,
	0x19, 0x5d, 0x02, 0x81, 0x85, 0xc0, 0xdc, 0x39, 0xbf, 0x84, 0xc8, 0xbb, 0x07, 0x72, 0x15, 0x3d,
	0x83, 0x5f, 0x5b, 0x44, 0xdd, 0x46, 0xf8, 0x3d, 0xa6, 0xf5, 0xff, 0x83, 0x1d, 0x31, 0x54, 0x41,
	0xd8, 0x9e, 0x13, 0xec, 0x33, 0xa7, 0x2f, 0x05, 0x10, 0x23, 0x39, 0x11, 0x21, 0x77, 0x25, 0x75,
	0xa2, 0xad, 0x71, 0x7a, 0x09, 0x5a, 0x35, 0xe8, 0x75, 0x34, 0x9e, 0xf0, 0x49, 0x87, 0x38, 0x4b,
	0xd7, 0x0e, 0x76, 0xc4, 0x21, 0xa2, 0xed, 0x76, 0x4e, 0x12, 0xcd, 0xc9, 0xff, 0xe0, 0xbe, 0xb3,
	0x0e, 0xee, 0x63, 0xa3, 0x24, 0xbf, 0xd7, 0x83, 0xbb, 0x49, 0x0e, 0xae, 0x4e, 0x51, 0xdb, 0x09,
	0xcd, 0xd3, 0x52, 0x8a, 0xf7, 0xc9, 0x52, 0x0d, 0x88, 0x24, 0x33, 0xca, 0x42, 0xbf, 0x2c, 0x25,
	0xb9, 0x94, 0x7a, 0xdf, 0x97, 0xa5, 0xb1, 0x83, 0x1d, 0xf1, 0x08, 0xbd, 0x24, 0x92, 0x1c, 0x2f,
	0x0b, 0xf1, 0x8d, 0x6f, 0x1a, 0x62, 0xf0, 0xc9, 0x95, 0xef, 0x1b, 0x62, 0xd7, 0x1d, 0xe8, 0x45,
	0x43, 0xec, 0xba, 0x3f, 0xee, 0x37, 0xc4, 0xcb, 0x2e, 0xb7, 0x4a, 0x52, 0x19, 0x30, 0x64, 0xd4,
	0x31, 0xb4, 0x4a, 0x17, 0x0e, 0x19, 0xba, 0x89, 0x21, 0x3d, 0x9e, 0xcc, 0xab, 0x30, 0x18, 0xe3,
	0xe6, 0x88, 0x87, 0x57, 0xe0, 0x53, 0x00, 0x5b, 0x5a, 0xe6, 0x46, 0x40, 0x8f, 0xb9, 0x23, 0xee,
	0x61, 0x97, 0x32, 0x2e, 0xe2, 0x9d, 0x66, 0xe2, 0x9d, 0xb2, 0x31, 0xce, 0xc5, 0x68, 0x08, 0xe0,
	0x04, 0xa7, 0xdb, 0x01, 0xa2, 0x2f, 0xb8, 0x08, 0xf5, 0x3c, 0x15, 0xea, 0x8c, 0x47, 0xf0, 0xce,
	0x49, 0x3f, 0x63, 0xfb, 0x27, 0x12, 0x1d, 0x20, 0x83, 0xeb, 0x4e, 0x4d, 0xd2, 0xf0, 0xb0, 0x77,
	0xf8, 0x6d, 0x70, 0xbc, 0xad, 0x46, 0x2e, 0xbe, 0x47, 0x89, 0xc5, 0xdd, 0xc3, 0x53, 0x0d, 0xa6,
	0xbb, 0x34, 0x78, 0x86, 0xe6, 0xe0, 0xc9, 0xff, 0x8e, 0xc5, 0xbf, 0x25, 0xbf, 0x01, 0x76, 0xff,
	0x3f, 0x17, 0xbd, 0x5d, 0x60, 0x7a, 0xeb, 0xcd, 0xc0, 0x26, 0x98, 0xec, 0x48, 0xad, 0x37, 0x05,
	0xb3, 0x2e, 0x2a, 0x73, 0xfd, 0x8f, 0xa8, 0x5b, 0x60, 0xf9, 0xb6, 0xc0, 0xf8, 0xa9, 0xfe, 0x45,
	0x43, 0xe4, 0x6f, 0x3f, 0xfb, 0x0d, 0xf1, 0x92, 0xfd, 0x3a, 0xd4, 0x5b, 0x51, 0xdc, 0x98, 0x63,
	0x53, 0x14, 0x3f, 0xa1, 0x7a, 0x8c, 0x45, 0x71, 0x0f, 0x7b, 0xdf, 0x8a, 0xe2, 0x63, 0xd8, 0x15,
	0x35, 0x48, 0xf4, 0x3e, 0x15, 0xc5, 0x2d, 0x71, 0x53, 0xd4, 0x20, 0x19, 0xf4, 0xa3, 0x28, 0xd7,
	0xf0, 0x9c, 0xa2, 0xf8, 0xf8, 0x7d, 0x28, 0xca, 0x31, 0x27, 0xf7, 0xa7, 0x28, 0x3e, 0x86, 0x5d,
	0x51, 0x83, 0xec, 0xbe, 0x5f, 0x45, 0xb9, 0x32, 0xc0, 0x2b, 0xaa, 0x0f, 0x0a, 0x5c, 0x14, 0xe5,
	0xfe, 0x6f, 0xa8, 0xaf, 0xa2, 0xcc, 0xce, 0x12, 0xa2, 0x28, 0x0e, 0x81, 0x29, 0x8a, 0x4f, 0xc4,
	0x57, 0x51, 0xd9, 0xd1, 0x97, 0xef, 0xa6, 0x85, 0xd7, 0xef, 0xa6, 0x85, 0x5f, 0xdf, 0x4d, 0x0b,
	0x6b, 0xc2, 0x46, 0x98, 0xfe, 0x0b, 0x7d, 0xf5, 0x8f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x63, 0xac,
	0xea, 0xa1, 0x87, 0x17, 0x00, 0x00,
}
