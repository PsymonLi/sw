// Code generated by protoc-gen-grpc-pensando DO NOT EDIT.

/*
Package aggwatchApiServer is a auto generated package.
Input file: svc_aggwatch.proto
*/
package aggwatchApiServer

import (
	"context"
	"fmt"

	"google.golang.org/grpc"

	"github.com/pensando/sw/api"
	aggwatch "github.com/pensando/sw/api/generated/aggwatch"
	fieldhooks "github.com/pensando/sw/api/hooks/apiserver/fields"
	"github.com/pensando/sw/api/listerwatcher"
	"github.com/pensando/sw/venice/apiserver"
	"github.com/pensando/sw/venice/apiserver/pkg"
	"github.com/pensando/sw/venice/utils/ctxutils"
	"github.com/pensando/sw/venice/utils/kvstore"
	"github.com/pensando/sw/venice/utils/log"
	"github.com/pensando/sw/venice/utils/rpckit"
	"github.com/pensando/sw/venice/utils/runtime"
)

// dummy vars to suppress unused errors
var _ api.ObjectMeta
var _ listerwatcher.WatcherClient
var _ fmt.Stringer
var _ fieldhooks.Dummy

type saggwatchSvc_aggwatchBackend struct {
	Services map[string]apiserver.Service
	Messages map[string]apiserver.Message
	logger   log.Logger
	scheme   *runtime.Scheme

	endpointsAggWatchV1 *eAggWatchV1Endpoints
}

type eAggWatchV1Endpoints struct {
	Svc                      saggwatchSvc_aggwatchBackend
	fnAutoWatchSvcAggWatchV1 func(in *api.AggWatchOptions, stream grpc.ServerStream, svcprefix string) error
}

func (s *saggwatchSvc_aggwatchBackend) regMsgsFunc(l log.Logger, scheme *runtime.Scheme) {
	l.Infof("registering message for saggwatchSvc_aggwatchBackend")
	s.Messages = map[string]apiserver.Message{

		// Add a message handler for ListWatch options
		"api.ListWatchOptions": apisrvpkg.NewMessage("api.ListWatchOptions"),
		// Add a message handler for Label options
		"api.Label": apisrvpkg.NewMessage("api.Label").WithGetRuntimeObject(func(i interface{}) runtime.Object {
			r := i.(api.Label)
			return &r
		}).WithObjectVersionWriter(func(i interface{}, version string) interface{} {
			r := i.(api.Label)
			r.APIVersion = version
			return r
		}),
	}

	apisrv.RegisterMessages("aggwatch", s.Messages)
	// add messages to package.
	if pkgMessages == nil {
		pkgMessages = make(map[string]apiserver.Message)
	}
	for k, v := range s.Messages {
		pkgMessages[k] = v
	}
}

func (s *saggwatchSvc_aggwatchBackend) regSvcsFunc(ctx context.Context, logger log.Logger, grpcserver *rpckit.RPCServer, scheme *runtime.Scheme) {

	{
		srv := apisrvpkg.NewService("aggwatch.AggWatchV1")
		s.endpointsAggWatchV1.fnAutoWatchSvcAggWatchV1 = srv.WatchFromKv

		s.Services = map[string]apiserver.Service{
			"aggwatch.AggWatchV1": srv,
		}
		apisrv.RegisterService("aggwatch.AggWatchV1", srv)
		endpoints := aggwatch.MakeAggWatchV1ServerEndpoints(s.endpointsAggWatchV1, logger)
		server := aggwatch.MakeGRPCServerAggWatchV1(ctx, endpoints, logger)
		aggwatch.RegisterAggWatchV1Server(grpcserver.GrpcServer, server)

	}
}

func (s *saggwatchSvc_aggwatchBackend) regWatchersFunc(ctx context.Context, logger log.Logger, grpcserver *rpckit.RPCServer, scheme *runtime.Scheme) {

	// Add Watchers
	{
		// Service watcher
		svc := s.Services["aggwatch.AggWatchV1"]
		if svc != nil {
			svc.WithKvWatchFunc(func(l log.Logger, options *api.AggWatchOptions, kvs kvstore.Interface, stream interface{}, txfnMap map[string]func(from, to string, i interface{}) (interface{}, error), version, svcprefix string) error {
				for _, o := range options.WatchOptions {
					if o.Group != "aggwatch" {
						return fmt.Errorf("invalid group [%s] in watch options", o.Group)
					}
				}
				if len(options.WatchOptions) == 0 {
					options.WatchOptions = append(options.WatchOptions, api.KindWatchOptions{Group: "aggwatch"})
				}
				wstream := stream.(grpc.ServerStream)
				nctx, cancel := context.WithCancel(wstream.Context())
				id := fmt.Sprintf("%s-%x", ctxutils.GetPeerID(nctx), &options)
				nctx = ctxutils.SetContextID(nctx, id)
				defer cancel()
				watcher, err := kvs.WatchAggregate(nctx, *options)
				if err != nil {
					l.ErrorLog("msg", "error starting Watch for service", "err", err, "service", "AggWatchV1")
					return err
				}
				return listerwatcher.SvcWatch(nctx, watcher, wstream, txfnMap, version, l)
			})
		}

	}

}

func (s *saggwatchSvc_aggwatchBackend) CompleteRegistration(ctx context.Context, logger log.Logger,
	grpcserver *rpckit.RPCServer, scheme *runtime.Scheme) error {
	// register all messages in the package if not done already
	s.logger = logger
	s.scheme = scheme
	registerMessages(logger, scheme)
	registerServices(ctx, logger, grpcserver, scheme)
	registerWatchers(ctx, logger, grpcserver, scheme)
	return nil
}

func (s *saggwatchSvc_aggwatchBackend) Reset() {
	cleanupRegistration()
}

func (e *eAggWatchV1Endpoints) AutoWatchSvcAggWatchV1(in *api.AggWatchOptions, stream aggwatch.AggWatchV1_AutoWatchSvcAggWatchV1Server) error {
	return e.fnAutoWatchSvcAggWatchV1(in, stream, "")
}

func init() {
	apisrv = apisrvpkg.MustGetAPIServer()

	svc := saggwatchSvc_aggwatchBackend{}
	addMsgRegFunc(svc.regMsgsFunc)
	addSvcRegFunc(svc.regSvcsFunc)
	addWatcherRegFunc(svc.regWatchersFunc)

	{
		e := eAggWatchV1Endpoints{Svc: svc}
		svc.endpointsAggWatchV1 = &e
	}
	apisrv.Register("aggwatch.svc_aggwatch.proto", &svc)
}
