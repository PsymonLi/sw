// Code generated by protoc-gen-grpc-pensando DO NOT EDIT.

/*
Package ctkit is a auto generated package.
Input file: svc_cluster.proto
*/
package ctkit

import (
	"context"
	"errors"
	"fmt"
	"strings"
	"sync"
	"time"

	"github.com/pensando/sw/api"
	"github.com/pensando/sw/api/generated/apiclient"
	"github.com/pensando/sw/api/generated/cluster"
	"github.com/pensando/sw/venice/utils/balancer"
	"github.com/pensando/sw/venice/utils/kvstore"
	"github.com/pensando/sw/venice/utils/log"
	"github.com/pensando/sw/venice/utils/rpckit"
)

// Cluster is a wrapper object that implements additional functionality
type Cluster struct {
	sync.Mutex
	cluster.Cluster
	HandlerCtx interface{} // additional state handlers can store
	ctrler     *ctrlerCtx  // reference back to the controller instance
}

func (obj *Cluster) Write() error {
	// if there is no API server to connect to, we are done
	if (obj.ctrler == nil) || (obj.ctrler.resolver == nil) || obj.ctrler.apisrvURL == "" {
		return nil
	}

	apicl, err := obj.ctrler.apiClient()
	if err != nil {
		obj.ctrler.logger.Errorf("Error creating API server clent. Err: %v", err)
		return err
	}

	obj.ctrler.stats.Counter("Cluster_Writes").Inc()

	// write to api server
	if obj.ObjectMeta.ResourceVersion != "" {
		// update it
		for i := 0; i < maxApisrvWriteRetry; i++ {
			_, err = apicl.ClusterV1().Cluster().Update(context.Background(), &obj.Cluster)
			if err == nil {
				break
			}
			time.Sleep(time.Millisecond * 100)
		}
	} else {
		//  create
		_, err = apicl.ClusterV1().Cluster().Create(context.Background(), &obj.Cluster)
	}

	return nil
}

// ClusterHandler is the event handler for Cluster object
type ClusterHandler interface {
	OnClusterCreate(obj *Cluster) error
	OnClusterUpdate(oldObj *Cluster, newObj *cluster.Cluster) error
	OnClusterDelete(obj *Cluster) error
}

// handleClusterEvent handles Cluster events from watcher
func (ct *ctrlerCtx) handleClusterEvent(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *cluster.Cluster:
		eobj := evt.Object.(*cluster.Cluster)
		kind := "Cluster"

		ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		handler, ok := ct.handlers[kind]
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		clusterHandler := handler.(ClusterHandler)
		// handle based on event type
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			fobj, err := ct.findObject(kind, eobj.GetKey())
			if err != nil {
				obj := &Cluster{
					Cluster:    *eobj,
					HandlerCtx: nil,
					ctrler:     ct,
				}
				ct.addObject(kind, obj.GetKey(), obj)
				ct.stats.Counter("Cluster_Created_Events").Inc()

				// call the event handler
				obj.Lock()
				err = clusterHandler.OnClusterCreate(obj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					ct.delObject(kind, eobj.GetKey())
					return err
				}
			} else {
				obj := fobj.(*Cluster)

				ct.stats.Counter("Cluster_Updated_Events").Inc()

				// call the event handler
				obj.Lock()
				err = clusterHandler.OnClusterUpdate(obj, eobj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					return err
				}
			}
		case kvstore.Deleted:
			fobj, err := ct.findObject(kind, eobj.GetKey())
			if err != nil {
				ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
				return err
			}

			obj := fobj.(*Cluster)

			ct.stats.Counter("Cluster_Deleted_Events").Inc()

			// Call the event reactor
			obj.Lock()
			err = clusterHandler.OnClusterDelete(obj)
			obj.Unlock()
			if err != nil {
				ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
			}

			ct.delObject(kind, eobj.GetKey())
		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on Cluster watch channel", tp)
	}

	return nil
}

// diffCluster does a diff of Cluster objects between local cache and API server
func (ct *ctrlerCtx) diffCluster(apicl apiclient.Services) {
	opts := api.ListWatchOptions{}

	// get a list of all objects from API server
	objlist, err := apicl.ClusterV1().Cluster().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Errorf("Error getting a list of objects. Err: %v", err)
		return
	}

	ct.logger.Infof("diffCluster(): ClusterList returned %d objects", len(objlist))

	// build an object map
	objmap := make(map[string]*cluster.Cluster)
	for _, obj := range objlist {
		objmap[obj.GetKey()] = obj
	}

	// if an object is in our local cache and not in API server, trigger delete for it
	for _, obj := range ct.Cluster().List() {
		_, ok := objmap[obj.GetKey()]
		if !ok {
			ct.logger.Infof("diffCluster(): Deleting existing object %#v since its not in apiserver", obj.GetKey())
			evt := kvstore.WatchEvent{
				Type:   kvstore.Deleted,
				Key:    obj.GetKey(),
				Object: &obj.Cluster,
			}
			ct.handleClusterEvent(&evt)
		}
	}

	// trigger create event for all others
	for _, obj := range objlist {
		ct.logger.Infof("diffCluster(): Adding object %#v", obj.GetKey())
		evt := kvstore.WatchEvent{
			Type:   kvstore.Created,
			Key:    obj.GetKey(),
			Object: obj,
		}
		ct.handleClusterEvent(&evt)
	}
}

func (ct *ctrlerCtx) runClusterWatcher() {
	kind := "Cluster"

	// if there is no API server to connect to, we are done
	if (ct.resolver == nil) || ct.apisrvURL == "" {
		return
	}

	// create context
	ctx, cancel := context.WithCancel(context.Background())
	ct.Lock()
	ct.watchCancel[kind] = cancel
	ct.Unlock()
	opts := api.ListWatchOptions{}

	// setup wait group
	ct.waitGrp.Add(1)
	defer ct.waitGrp.Done()
	logger := ct.logger.WithContext("submodule", "ClusterWatcher")

	ct.stats.Counter("Cluster_Watch").Inc()
	defer ct.stats.Counter("Cluster_Watch").Dec()

	// loop forever
	for {
		// create a grpc client
		apicl, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
		if err != nil {
			logger.Warnf("Failed to connect to gRPC server [%s]\n", ct.apisrvURL)
			ct.stats.Counter("Cluster_ApiClientErr").Inc()
		} else {
			logger.Infof("API client connected {%+v}", apicl)

			// Cluster object watcher
			wt, werr := apicl.ClusterV1().Cluster().Watch(ctx, &opts)
			if werr != nil {
				logger.Errorf("Failed to start %s watch (%s)\n", kind, werr)
				// wait for a second and retry connecting to api server
				apicl.Close()
				time.Sleep(time.Second)
				continue
			}
			ct.Lock()
			ct.watchers[kind] = wt
			ct.Unlock()

			// perform a diff with API server and local cache
			time.Sleep(time.Millisecond * 100)
			ct.diffCluster(apicl)

			// handle api server watch events
		innerLoop:
			for {
				// wait for events
				select {
				case evt, ok := <-wt.EventChan():
					if !ok {
						logger.Error("Error receiving from apisrv watcher")
						ct.stats.Counter("Cluster_WatchErrors").Inc()
						break innerLoop
					}

					// handle event
					ct.handleClusterEvent(evt)
				}
			}
			apicl.Close()
		}

		// if stop flag is set, we are done
		if ct.stoped {
			logger.Infof("Exiting API server watcher")
			return
		}

		// wait for a second and retry connecting to api server
		time.Sleep(time.Second)
	}
}

// WatchCluster starts watch on Cluster object
func (ct *ctrlerCtx) WatchCluster(handler ClusterHandler) error {
	kind := "Cluster"

	ct.Lock()
	defer ct.Unlock()

	// see if we already have a watcher
	_, ok := ct.watchers[kind]
	if ok {
		return fmt.Errorf("Cluster watcher already exists")
	}

	// save handler
	ct.handlers[kind] = handler

	// run Cluster watcher in a go routine
	go ct.runClusterWatcher()

	return nil
}

// ClusterAPI returns
type ClusterAPI interface {
	Create(obj *cluster.Cluster) error
	Update(obj *cluster.Cluster) error
	Delete(obj *cluster.Cluster) error
	Find(meta *api.ObjectMeta) (*Cluster, error)
	List() []*Cluster
	Watch(handler ClusterHandler) error
}

// dummy struct that implements ClusterAPI
type clusterAPI struct {
	ct *ctrlerCtx
}

// Create creates Cluster object
func (api *clusterAPI) Create(obj *cluster.Cluster) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.ClusterV1().Cluster().Create(context.Background(), obj)
		if err != nil && strings.Contains(err.Error(), "AlreadyExists") {
			_, err = apicl.ClusterV1().Cluster().Update(context.Background(), obj)
		}
		if err != nil {
			return err
		}
	}

	return api.ct.handleClusterEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Created})
}

// Update triggers update on Cluster object
func (api *clusterAPI) Update(obj *cluster.Cluster) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.ClusterV1().Cluster().Update(context.Background(), obj)
		if err != nil {
			return err
		}
	}

	return api.ct.handleClusterEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Updated})
}

// Delete deletes Cluster object
func (api *clusterAPI) Delete(obj *cluster.Cluster) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		apicl.ClusterV1().Cluster().Delete(context.Background(), &obj.ObjectMeta)
	}

	return api.ct.handleClusterEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Deleted})
}

// Find returns an object by meta
func (api *clusterAPI) Find(meta *api.ObjectMeta) (*Cluster, error) {
	// find the object
	obj, err := api.ct.FindObject("Cluster", meta)
	if err != nil {
		return nil, err
	}

	// asset type
	switch obj.(type) {
	case *Cluster:
		hobj := obj.(*Cluster)
		return hobj, nil
	default:
		return nil, errors.New("incorrect object type")
	}
}

// List returns a list of all Cluster objects
func (api *clusterAPI) List() []*Cluster {
	var objlist []*Cluster

	objs := api.ct.ListObjects("Cluster")
	for _, obj := range objs {
		switch tp := obj.(type) {
		case *Cluster:
			eobj := obj.(*Cluster)
			objlist = append(objlist, eobj)
		default:
			log.Fatalf("Got invalid object type %v while looking for Cluster", tp)
		}
	}

	return objlist
}

// Watch sets up a event handlers for Cluster object
func (api *clusterAPI) Watch(handler ClusterHandler) error {
	return api.ct.WatchCluster(handler)
}

// Cluster returns ClusterAPI
func (ct *ctrlerCtx) Cluster() ClusterAPI {
	return &clusterAPI{ct: ct}
}

// Node is a wrapper object that implements additional functionality
type Node struct {
	sync.Mutex
	cluster.Node
	HandlerCtx interface{} // additional state handlers can store
	ctrler     *ctrlerCtx  // reference back to the controller instance
}

func (obj *Node) Write() error {
	// if there is no API server to connect to, we are done
	if (obj.ctrler == nil) || (obj.ctrler.resolver == nil) || obj.ctrler.apisrvURL == "" {
		return nil
	}

	apicl, err := obj.ctrler.apiClient()
	if err != nil {
		obj.ctrler.logger.Errorf("Error creating API server clent. Err: %v", err)
		return err
	}

	obj.ctrler.stats.Counter("Node_Writes").Inc()

	// write to api server
	if obj.ObjectMeta.ResourceVersion != "" {
		// update it
		for i := 0; i < maxApisrvWriteRetry; i++ {
			_, err = apicl.ClusterV1().Node().Update(context.Background(), &obj.Node)
			if err == nil {
				break
			}
			time.Sleep(time.Millisecond * 100)
		}
	} else {
		//  create
		_, err = apicl.ClusterV1().Node().Create(context.Background(), &obj.Node)
	}

	return nil
}

// NodeHandler is the event handler for Node object
type NodeHandler interface {
	OnNodeCreate(obj *Node) error
	OnNodeUpdate(oldObj *Node, newObj *cluster.Node) error
	OnNodeDelete(obj *Node) error
}

// handleNodeEvent handles Node events from watcher
func (ct *ctrlerCtx) handleNodeEvent(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *cluster.Node:
		eobj := evt.Object.(*cluster.Node)
		kind := "Node"

		ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		handler, ok := ct.handlers[kind]
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		nodeHandler := handler.(NodeHandler)
		// handle based on event type
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			fobj, err := ct.findObject(kind, eobj.GetKey())
			if err != nil {
				obj := &Node{
					Node:       *eobj,
					HandlerCtx: nil,
					ctrler:     ct,
				}
				ct.addObject(kind, obj.GetKey(), obj)
				ct.stats.Counter("Node_Created_Events").Inc()

				// call the event handler
				obj.Lock()
				err = nodeHandler.OnNodeCreate(obj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					ct.delObject(kind, eobj.GetKey())
					return err
				}
			} else {
				obj := fobj.(*Node)

				ct.stats.Counter("Node_Updated_Events").Inc()

				// call the event handler
				obj.Lock()
				err = nodeHandler.OnNodeUpdate(obj, eobj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					return err
				}
			}
		case kvstore.Deleted:
			fobj, err := ct.findObject(kind, eobj.GetKey())
			if err != nil {
				ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
				return err
			}

			obj := fobj.(*Node)

			ct.stats.Counter("Node_Deleted_Events").Inc()

			// Call the event reactor
			obj.Lock()
			err = nodeHandler.OnNodeDelete(obj)
			obj.Unlock()
			if err != nil {
				ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
			}

			ct.delObject(kind, eobj.GetKey())
		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on Node watch channel", tp)
	}

	return nil
}

// diffNode does a diff of Node objects between local cache and API server
func (ct *ctrlerCtx) diffNode(apicl apiclient.Services) {
	opts := api.ListWatchOptions{}

	// get a list of all objects from API server
	objlist, err := apicl.ClusterV1().Node().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Errorf("Error getting a list of objects. Err: %v", err)
		return
	}

	ct.logger.Infof("diffNode(): NodeList returned %d objects", len(objlist))

	// build an object map
	objmap := make(map[string]*cluster.Node)
	for _, obj := range objlist {
		objmap[obj.GetKey()] = obj
	}

	// if an object is in our local cache and not in API server, trigger delete for it
	for _, obj := range ct.Node().List() {
		_, ok := objmap[obj.GetKey()]
		if !ok {
			ct.logger.Infof("diffNode(): Deleting existing object %#v since its not in apiserver", obj.GetKey())
			evt := kvstore.WatchEvent{
				Type:   kvstore.Deleted,
				Key:    obj.GetKey(),
				Object: &obj.Node,
			}
			ct.handleNodeEvent(&evt)
		}
	}

	// trigger create event for all others
	for _, obj := range objlist {
		ct.logger.Infof("diffNode(): Adding object %#v", obj.GetKey())
		evt := kvstore.WatchEvent{
			Type:   kvstore.Created,
			Key:    obj.GetKey(),
			Object: obj,
		}
		ct.handleNodeEvent(&evt)
	}
}

func (ct *ctrlerCtx) runNodeWatcher() {
	kind := "Node"

	// if there is no API server to connect to, we are done
	if (ct.resolver == nil) || ct.apisrvURL == "" {
		return
	}

	// create context
	ctx, cancel := context.WithCancel(context.Background())
	ct.Lock()
	ct.watchCancel[kind] = cancel
	ct.Unlock()
	opts := api.ListWatchOptions{}

	// setup wait group
	ct.waitGrp.Add(1)
	defer ct.waitGrp.Done()
	logger := ct.logger.WithContext("submodule", "NodeWatcher")

	ct.stats.Counter("Node_Watch").Inc()
	defer ct.stats.Counter("Node_Watch").Dec()

	// loop forever
	for {
		// create a grpc client
		apicl, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
		if err != nil {
			logger.Warnf("Failed to connect to gRPC server [%s]\n", ct.apisrvURL)
			ct.stats.Counter("Node_ApiClientErr").Inc()
		} else {
			logger.Infof("API client connected {%+v}", apicl)

			// Node object watcher
			wt, werr := apicl.ClusterV1().Node().Watch(ctx, &opts)
			if werr != nil {
				logger.Errorf("Failed to start %s watch (%s)\n", kind, werr)
				// wait for a second and retry connecting to api server
				apicl.Close()
				time.Sleep(time.Second)
				continue
			}
			ct.Lock()
			ct.watchers[kind] = wt
			ct.Unlock()

			// perform a diff with API server and local cache
			time.Sleep(time.Millisecond * 100)
			ct.diffNode(apicl)

			// handle api server watch events
		innerLoop:
			for {
				// wait for events
				select {
				case evt, ok := <-wt.EventChan():
					if !ok {
						logger.Error("Error receiving from apisrv watcher")
						ct.stats.Counter("Node_WatchErrors").Inc()
						break innerLoop
					}

					// handle event
					ct.handleNodeEvent(evt)
				}
			}
			apicl.Close()
		}

		// if stop flag is set, we are done
		if ct.stoped {
			logger.Infof("Exiting API server watcher")
			return
		}

		// wait for a second and retry connecting to api server
		time.Sleep(time.Second)
	}
}

// WatchNode starts watch on Node object
func (ct *ctrlerCtx) WatchNode(handler NodeHandler) error {
	kind := "Node"

	ct.Lock()
	defer ct.Unlock()

	// see if we already have a watcher
	_, ok := ct.watchers[kind]
	if ok {
		return fmt.Errorf("Node watcher already exists")
	}

	// save handler
	ct.handlers[kind] = handler

	// run Node watcher in a go routine
	go ct.runNodeWatcher()

	return nil
}

// NodeAPI returns
type NodeAPI interface {
	Create(obj *cluster.Node) error
	Update(obj *cluster.Node) error
	Delete(obj *cluster.Node) error
	Find(meta *api.ObjectMeta) (*Node, error)
	List() []*Node
	Watch(handler NodeHandler) error
}

// dummy struct that implements NodeAPI
type nodeAPI struct {
	ct *ctrlerCtx
}

// Create creates Node object
func (api *nodeAPI) Create(obj *cluster.Node) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.ClusterV1().Node().Create(context.Background(), obj)
		if err != nil && strings.Contains(err.Error(), "AlreadyExists") {
			_, err = apicl.ClusterV1().Node().Update(context.Background(), obj)
		}
		if err != nil {
			return err
		}
	}

	return api.ct.handleNodeEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Created})
}

// Update triggers update on Node object
func (api *nodeAPI) Update(obj *cluster.Node) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.ClusterV1().Node().Update(context.Background(), obj)
		if err != nil {
			return err
		}
	}

	return api.ct.handleNodeEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Updated})
}

// Delete deletes Node object
func (api *nodeAPI) Delete(obj *cluster.Node) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		apicl.ClusterV1().Node().Delete(context.Background(), &obj.ObjectMeta)
	}

	return api.ct.handleNodeEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Deleted})
}

// Find returns an object by meta
func (api *nodeAPI) Find(meta *api.ObjectMeta) (*Node, error) {
	// find the object
	obj, err := api.ct.FindObject("Node", meta)
	if err != nil {
		return nil, err
	}

	// asset type
	switch obj.(type) {
	case *Node:
		hobj := obj.(*Node)
		return hobj, nil
	default:
		return nil, errors.New("incorrect object type")
	}
}

// List returns a list of all Node objects
func (api *nodeAPI) List() []*Node {
	var objlist []*Node

	objs := api.ct.ListObjects("Node")
	for _, obj := range objs {
		switch tp := obj.(type) {
		case *Node:
			eobj := obj.(*Node)
			objlist = append(objlist, eobj)
		default:
			log.Fatalf("Got invalid object type %v while looking for Node", tp)
		}
	}

	return objlist
}

// Watch sets up a event handlers for Node object
func (api *nodeAPI) Watch(handler NodeHandler) error {
	return api.ct.WatchNode(handler)
}

// Node returns NodeAPI
func (ct *ctrlerCtx) Node() NodeAPI {
	return &nodeAPI{ct: ct}
}

// Host is a wrapper object that implements additional functionality
type Host struct {
	sync.Mutex
	cluster.Host
	HandlerCtx interface{} // additional state handlers can store
	ctrler     *ctrlerCtx  // reference back to the controller instance
}

func (obj *Host) Write() error {
	// if there is no API server to connect to, we are done
	if (obj.ctrler == nil) || (obj.ctrler.resolver == nil) || obj.ctrler.apisrvURL == "" {
		return nil
	}

	apicl, err := obj.ctrler.apiClient()
	if err != nil {
		obj.ctrler.logger.Errorf("Error creating API server clent. Err: %v", err)
		return err
	}

	obj.ctrler.stats.Counter("Host_Writes").Inc()

	// write to api server
	if obj.ObjectMeta.ResourceVersion != "" {
		// update it
		for i := 0; i < maxApisrvWriteRetry; i++ {
			_, err = apicl.ClusterV1().Host().Update(context.Background(), &obj.Host)
			if err == nil {
				break
			}
			time.Sleep(time.Millisecond * 100)
		}
	} else {
		//  create
		_, err = apicl.ClusterV1().Host().Create(context.Background(), &obj.Host)
	}

	return nil
}

// HostHandler is the event handler for Host object
type HostHandler interface {
	OnHostCreate(obj *Host) error
	OnHostUpdate(oldObj *Host, newObj *cluster.Host) error
	OnHostDelete(obj *Host) error
}

// handleHostEvent handles Host events from watcher
func (ct *ctrlerCtx) handleHostEvent(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *cluster.Host:
		eobj := evt.Object.(*cluster.Host)
		kind := "Host"

		ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		handler, ok := ct.handlers[kind]
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		hostHandler := handler.(HostHandler)
		// handle based on event type
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			fobj, err := ct.findObject(kind, eobj.GetKey())
			if err != nil {
				obj := &Host{
					Host:       *eobj,
					HandlerCtx: nil,
					ctrler:     ct,
				}
				ct.addObject(kind, obj.GetKey(), obj)
				ct.stats.Counter("Host_Created_Events").Inc()

				// call the event handler
				obj.Lock()
				err = hostHandler.OnHostCreate(obj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					ct.delObject(kind, eobj.GetKey())
					return err
				}
			} else {
				obj := fobj.(*Host)

				ct.stats.Counter("Host_Updated_Events").Inc()

				// call the event handler
				obj.Lock()
				err = hostHandler.OnHostUpdate(obj, eobj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					return err
				}
			}
		case kvstore.Deleted:
			fobj, err := ct.findObject(kind, eobj.GetKey())
			if err != nil {
				ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
				return err
			}

			obj := fobj.(*Host)

			ct.stats.Counter("Host_Deleted_Events").Inc()

			// Call the event reactor
			obj.Lock()
			err = hostHandler.OnHostDelete(obj)
			obj.Unlock()
			if err != nil {
				ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
			}

			ct.delObject(kind, eobj.GetKey())
		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on Host watch channel", tp)
	}

	return nil
}

// diffHost does a diff of Host objects between local cache and API server
func (ct *ctrlerCtx) diffHost(apicl apiclient.Services) {
	opts := api.ListWatchOptions{}

	// get a list of all objects from API server
	objlist, err := apicl.ClusterV1().Host().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Errorf("Error getting a list of objects. Err: %v", err)
		return
	}

	ct.logger.Infof("diffHost(): HostList returned %d objects", len(objlist))

	// build an object map
	objmap := make(map[string]*cluster.Host)
	for _, obj := range objlist {
		objmap[obj.GetKey()] = obj
	}

	// if an object is in our local cache and not in API server, trigger delete for it
	for _, obj := range ct.Host().List() {
		_, ok := objmap[obj.GetKey()]
		if !ok {
			ct.logger.Infof("diffHost(): Deleting existing object %#v since its not in apiserver", obj.GetKey())
			evt := kvstore.WatchEvent{
				Type:   kvstore.Deleted,
				Key:    obj.GetKey(),
				Object: &obj.Host,
			}
			ct.handleHostEvent(&evt)
		}
	}

	// trigger create event for all others
	for _, obj := range objlist {
		ct.logger.Infof("diffHost(): Adding object %#v", obj.GetKey())
		evt := kvstore.WatchEvent{
			Type:   kvstore.Created,
			Key:    obj.GetKey(),
			Object: obj,
		}
		ct.handleHostEvent(&evt)
	}
}

func (ct *ctrlerCtx) runHostWatcher() {
	kind := "Host"

	// if there is no API server to connect to, we are done
	if (ct.resolver == nil) || ct.apisrvURL == "" {
		return
	}

	// create context
	ctx, cancel := context.WithCancel(context.Background())
	ct.Lock()
	ct.watchCancel[kind] = cancel
	ct.Unlock()
	opts := api.ListWatchOptions{}

	// setup wait group
	ct.waitGrp.Add(1)
	defer ct.waitGrp.Done()
	logger := ct.logger.WithContext("submodule", "HostWatcher")

	ct.stats.Counter("Host_Watch").Inc()
	defer ct.stats.Counter("Host_Watch").Dec()

	// loop forever
	for {
		// create a grpc client
		apicl, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
		if err != nil {
			logger.Warnf("Failed to connect to gRPC server [%s]\n", ct.apisrvURL)
			ct.stats.Counter("Host_ApiClientErr").Inc()
		} else {
			logger.Infof("API client connected {%+v}", apicl)

			// Host object watcher
			wt, werr := apicl.ClusterV1().Host().Watch(ctx, &opts)
			if werr != nil {
				logger.Errorf("Failed to start %s watch (%s)\n", kind, werr)
				// wait for a second and retry connecting to api server
				apicl.Close()
				time.Sleep(time.Second)
				continue
			}
			ct.Lock()
			ct.watchers[kind] = wt
			ct.Unlock()

			// perform a diff with API server and local cache
			time.Sleep(time.Millisecond * 100)
			ct.diffHost(apicl)

			// handle api server watch events
		innerLoop:
			for {
				// wait for events
				select {
				case evt, ok := <-wt.EventChan():
					if !ok {
						logger.Error("Error receiving from apisrv watcher")
						ct.stats.Counter("Host_WatchErrors").Inc()
						break innerLoop
					}

					// handle event
					ct.handleHostEvent(evt)
				}
			}
			apicl.Close()
		}

		// if stop flag is set, we are done
		if ct.stoped {
			logger.Infof("Exiting API server watcher")
			return
		}

		// wait for a second and retry connecting to api server
		time.Sleep(time.Second)
	}
}

// WatchHost starts watch on Host object
func (ct *ctrlerCtx) WatchHost(handler HostHandler) error {
	kind := "Host"

	ct.Lock()
	defer ct.Unlock()

	// see if we already have a watcher
	_, ok := ct.watchers[kind]
	if ok {
		return fmt.Errorf("Host watcher already exists")
	}

	// save handler
	ct.handlers[kind] = handler

	// run Host watcher in a go routine
	go ct.runHostWatcher()

	return nil
}

// HostAPI returns
type HostAPI interface {
	Create(obj *cluster.Host) error
	Update(obj *cluster.Host) error
	Delete(obj *cluster.Host) error
	Find(meta *api.ObjectMeta) (*Host, error)
	List() []*Host
	Watch(handler HostHandler) error
}

// dummy struct that implements HostAPI
type hostAPI struct {
	ct *ctrlerCtx
}

// Create creates Host object
func (api *hostAPI) Create(obj *cluster.Host) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.ClusterV1().Host().Create(context.Background(), obj)
		if err != nil && strings.Contains(err.Error(), "AlreadyExists") {
			_, err = apicl.ClusterV1().Host().Update(context.Background(), obj)
		}
		if err != nil {
			return err
		}
	}

	return api.ct.handleHostEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Created})
}

// Update triggers update on Host object
func (api *hostAPI) Update(obj *cluster.Host) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.ClusterV1().Host().Update(context.Background(), obj)
		if err != nil {
			return err
		}
	}

	return api.ct.handleHostEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Updated})
}

// Delete deletes Host object
func (api *hostAPI) Delete(obj *cluster.Host) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		apicl.ClusterV1().Host().Delete(context.Background(), &obj.ObjectMeta)
	}

	return api.ct.handleHostEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Deleted})
}

// Find returns an object by meta
func (api *hostAPI) Find(meta *api.ObjectMeta) (*Host, error) {
	// find the object
	obj, err := api.ct.FindObject("Host", meta)
	if err != nil {
		return nil, err
	}

	// asset type
	switch obj.(type) {
	case *Host:
		hobj := obj.(*Host)
		return hobj, nil
	default:
		return nil, errors.New("incorrect object type")
	}
}

// List returns a list of all Host objects
func (api *hostAPI) List() []*Host {
	var objlist []*Host

	objs := api.ct.ListObjects("Host")
	for _, obj := range objs {
		switch tp := obj.(type) {
		case *Host:
			eobj := obj.(*Host)
			objlist = append(objlist, eobj)
		default:
			log.Fatalf("Got invalid object type %v while looking for Host", tp)
		}
	}

	return objlist
}

// Watch sets up a event handlers for Host object
func (api *hostAPI) Watch(handler HostHandler) error {
	return api.ct.WatchHost(handler)
}

// Host returns HostAPI
func (ct *ctrlerCtx) Host() HostAPI {
	return &hostAPI{ct: ct}
}

// SmartNIC is a wrapper object that implements additional functionality
type SmartNIC struct {
	sync.Mutex
	cluster.SmartNIC
	HandlerCtx interface{} // additional state handlers can store
	ctrler     *ctrlerCtx  // reference back to the controller instance
}

func (obj *SmartNIC) Write() error {
	// if there is no API server to connect to, we are done
	if (obj.ctrler == nil) || (obj.ctrler.resolver == nil) || obj.ctrler.apisrvURL == "" {
		return nil
	}

	apicl, err := obj.ctrler.apiClient()
	if err != nil {
		obj.ctrler.logger.Errorf("Error creating API server clent. Err: %v", err)
		return err
	}

	obj.ctrler.stats.Counter("SmartNIC_Writes").Inc()

	// write to api server
	if obj.ObjectMeta.ResourceVersion != "" {
		// update it
		for i := 0; i < maxApisrvWriteRetry; i++ {
			_, err = apicl.ClusterV1().SmartNIC().Update(context.Background(), &obj.SmartNIC)
			if err == nil {
				break
			}
			time.Sleep(time.Millisecond * 100)
		}
	} else {
		//  create
		_, err = apicl.ClusterV1().SmartNIC().Create(context.Background(), &obj.SmartNIC)
	}

	return nil
}

// SmartNICHandler is the event handler for SmartNIC object
type SmartNICHandler interface {
	OnSmartNICCreate(obj *SmartNIC) error
	OnSmartNICUpdate(oldObj *SmartNIC, newObj *cluster.SmartNIC) error
	OnSmartNICDelete(obj *SmartNIC) error
}

// handleSmartNICEvent handles SmartNIC events from watcher
func (ct *ctrlerCtx) handleSmartNICEvent(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *cluster.SmartNIC:
		eobj := evt.Object.(*cluster.SmartNIC)
		kind := "SmartNIC"

		ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		handler, ok := ct.handlers[kind]
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		smartnicHandler := handler.(SmartNICHandler)
		// handle based on event type
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			fobj, err := ct.findObject(kind, eobj.GetKey())
			if err != nil {
				obj := &SmartNIC{
					SmartNIC:   *eobj,
					HandlerCtx: nil,
					ctrler:     ct,
				}
				ct.addObject(kind, obj.GetKey(), obj)
				ct.stats.Counter("SmartNIC_Created_Events").Inc()

				// call the event handler
				obj.Lock()
				err = smartnicHandler.OnSmartNICCreate(obj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					ct.delObject(kind, eobj.GetKey())
					return err
				}
			} else {
				obj := fobj.(*SmartNIC)

				ct.stats.Counter("SmartNIC_Updated_Events").Inc()

				// call the event handler
				obj.Lock()
				err = smartnicHandler.OnSmartNICUpdate(obj, eobj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					return err
				}
			}
		case kvstore.Deleted:
			fobj, err := ct.findObject(kind, eobj.GetKey())
			if err != nil {
				ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
				return err
			}

			obj := fobj.(*SmartNIC)

			ct.stats.Counter("SmartNIC_Deleted_Events").Inc()

			// Call the event reactor
			obj.Lock()
			err = smartnicHandler.OnSmartNICDelete(obj)
			obj.Unlock()
			if err != nil {
				ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
			}

			ct.delObject(kind, eobj.GetKey())
		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on SmartNIC watch channel", tp)
	}

	return nil
}

// diffSmartNIC does a diff of SmartNIC objects between local cache and API server
func (ct *ctrlerCtx) diffSmartNIC(apicl apiclient.Services) {
	opts := api.ListWatchOptions{}

	// get a list of all objects from API server
	objlist, err := apicl.ClusterV1().SmartNIC().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Errorf("Error getting a list of objects. Err: %v", err)
		return
	}

	ct.logger.Infof("diffSmartNIC(): SmartNICList returned %d objects", len(objlist))

	// build an object map
	objmap := make(map[string]*cluster.SmartNIC)
	for _, obj := range objlist {
		objmap[obj.GetKey()] = obj
	}

	// if an object is in our local cache and not in API server, trigger delete for it
	for _, obj := range ct.SmartNIC().List() {
		_, ok := objmap[obj.GetKey()]
		if !ok {
			ct.logger.Infof("diffSmartNIC(): Deleting existing object %#v since its not in apiserver", obj.GetKey())
			evt := kvstore.WatchEvent{
				Type:   kvstore.Deleted,
				Key:    obj.GetKey(),
				Object: &obj.SmartNIC,
			}
			ct.handleSmartNICEvent(&evt)
		}
	}

	// trigger create event for all others
	for _, obj := range objlist {
		ct.logger.Infof("diffSmartNIC(): Adding object %#v", obj.GetKey())
		evt := kvstore.WatchEvent{
			Type:   kvstore.Created,
			Key:    obj.GetKey(),
			Object: obj,
		}
		ct.handleSmartNICEvent(&evt)
	}
}

func (ct *ctrlerCtx) runSmartNICWatcher() {
	kind := "SmartNIC"

	// if there is no API server to connect to, we are done
	if (ct.resolver == nil) || ct.apisrvURL == "" {
		return
	}

	// create context
	ctx, cancel := context.WithCancel(context.Background())
	ct.Lock()
	ct.watchCancel[kind] = cancel
	ct.Unlock()
	opts := api.ListWatchOptions{}

	// setup wait group
	ct.waitGrp.Add(1)
	defer ct.waitGrp.Done()
	logger := ct.logger.WithContext("submodule", "SmartNICWatcher")

	ct.stats.Counter("SmartNIC_Watch").Inc()
	defer ct.stats.Counter("SmartNIC_Watch").Dec()

	// loop forever
	for {
		// create a grpc client
		apicl, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
		if err != nil {
			logger.Warnf("Failed to connect to gRPC server [%s]\n", ct.apisrvURL)
			ct.stats.Counter("SmartNIC_ApiClientErr").Inc()
		} else {
			logger.Infof("API client connected {%+v}", apicl)

			// SmartNIC object watcher
			wt, werr := apicl.ClusterV1().SmartNIC().Watch(ctx, &opts)
			if werr != nil {
				logger.Errorf("Failed to start %s watch (%s)\n", kind, werr)
				// wait for a second and retry connecting to api server
				apicl.Close()
				time.Sleep(time.Second)
				continue
			}
			ct.Lock()
			ct.watchers[kind] = wt
			ct.Unlock()

			// perform a diff with API server and local cache
			time.Sleep(time.Millisecond * 100)
			ct.diffSmartNIC(apicl)

			// handle api server watch events
		innerLoop:
			for {
				// wait for events
				select {
				case evt, ok := <-wt.EventChan():
					if !ok {
						logger.Error("Error receiving from apisrv watcher")
						ct.stats.Counter("SmartNIC_WatchErrors").Inc()
						break innerLoop
					}

					// handle event
					ct.handleSmartNICEvent(evt)
				}
			}
			apicl.Close()
		}

		// if stop flag is set, we are done
		if ct.stoped {
			logger.Infof("Exiting API server watcher")
			return
		}

		// wait for a second and retry connecting to api server
		time.Sleep(time.Second)
	}
}

// WatchSmartNIC starts watch on SmartNIC object
func (ct *ctrlerCtx) WatchSmartNIC(handler SmartNICHandler) error {
	kind := "SmartNIC"

	ct.Lock()
	defer ct.Unlock()

	// see if we already have a watcher
	_, ok := ct.watchers[kind]
	if ok {
		return fmt.Errorf("SmartNIC watcher already exists")
	}

	// save handler
	ct.handlers[kind] = handler

	// run SmartNIC watcher in a go routine
	go ct.runSmartNICWatcher()

	return nil
}

// SmartNICAPI returns
type SmartNICAPI interface {
	Create(obj *cluster.SmartNIC) error
	Update(obj *cluster.SmartNIC) error
	Delete(obj *cluster.SmartNIC) error
	Find(meta *api.ObjectMeta) (*SmartNIC, error)
	List() []*SmartNIC
	Watch(handler SmartNICHandler) error
}

// dummy struct that implements SmartNICAPI
type smartnicAPI struct {
	ct *ctrlerCtx
}

// Create creates SmartNIC object
func (api *smartnicAPI) Create(obj *cluster.SmartNIC) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.ClusterV1().SmartNIC().Create(context.Background(), obj)
		if err != nil && strings.Contains(err.Error(), "AlreadyExists") {
			_, err = apicl.ClusterV1().SmartNIC().Update(context.Background(), obj)
		}
		if err != nil {
			return err
		}
	}

	return api.ct.handleSmartNICEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Created})
}

// Update triggers update on SmartNIC object
func (api *smartnicAPI) Update(obj *cluster.SmartNIC) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.ClusterV1().SmartNIC().Update(context.Background(), obj)
		if err != nil {
			return err
		}
	}

	return api.ct.handleSmartNICEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Updated})
}

// Delete deletes SmartNIC object
func (api *smartnicAPI) Delete(obj *cluster.SmartNIC) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		apicl.ClusterV1().SmartNIC().Delete(context.Background(), &obj.ObjectMeta)
	}

	return api.ct.handleSmartNICEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Deleted})
}

// Find returns an object by meta
func (api *smartnicAPI) Find(meta *api.ObjectMeta) (*SmartNIC, error) {
	// find the object
	obj, err := api.ct.FindObject("SmartNIC", meta)
	if err != nil {
		return nil, err
	}

	// asset type
	switch obj.(type) {
	case *SmartNIC:
		hobj := obj.(*SmartNIC)
		return hobj, nil
	default:
		return nil, errors.New("incorrect object type")
	}
}

// List returns a list of all SmartNIC objects
func (api *smartnicAPI) List() []*SmartNIC {
	var objlist []*SmartNIC

	objs := api.ct.ListObjects("SmartNIC")
	for _, obj := range objs {
		switch tp := obj.(type) {
		case *SmartNIC:
			eobj := obj.(*SmartNIC)
			objlist = append(objlist, eobj)
		default:
			log.Fatalf("Got invalid object type %v while looking for SmartNIC", tp)
		}
	}

	return objlist
}

// Watch sets up a event handlers for SmartNIC object
func (api *smartnicAPI) Watch(handler SmartNICHandler) error {
	return api.ct.WatchSmartNIC(handler)
}

// SmartNIC returns SmartNICAPI
func (ct *ctrlerCtx) SmartNIC() SmartNICAPI {
	return &smartnicAPI{ct: ct}
}

// Tenant is a wrapper object that implements additional functionality
type Tenant struct {
	sync.Mutex
	cluster.Tenant
	HandlerCtx interface{} // additional state handlers can store
	ctrler     *ctrlerCtx  // reference back to the controller instance
}

func (obj *Tenant) Write() error {
	// if there is no API server to connect to, we are done
	if (obj.ctrler == nil) || (obj.ctrler.resolver == nil) || obj.ctrler.apisrvURL == "" {
		return nil
	}

	apicl, err := obj.ctrler.apiClient()
	if err != nil {
		obj.ctrler.logger.Errorf("Error creating API server clent. Err: %v", err)
		return err
	}

	obj.ctrler.stats.Counter("Tenant_Writes").Inc()

	// write to api server
	if obj.ObjectMeta.ResourceVersion != "" {
		// update it
		for i := 0; i < maxApisrvWriteRetry; i++ {
			_, err = apicl.ClusterV1().Tenant().Update(context.Background(), &obj.Tenant)
			if err == nil {
				break
			}
			time.Sleep(time.Millisecond * 100)
		}
	} else {
		//  create
		_, err = apicl.ClusterV1().Tenant().Create(context.Background(), &obj.Tenant)
	}

	return nil
}

// TenantHandler is the event handler for Tenant object
type TenantHandler interface {
	OnTenantCreate(obj *Tenant) error
	OnTenantUpdate(oldObj *Tenant, newObj *cluster.Tenant) error
	OnTenantDelete(obj *Tenant) error
}

// handleTenantEvent handles Tenant events from watcher
func (ct *ctrlerCtx) handleTenantEvent(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *cluster.Tenant:
		eobj := evt.Object.(*cluster.Tenant)
		kind := "Tenant"

		ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		handler, ok := ct.handlers[kind]
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		tenantHandler := handler.(TenantHandler)
		// handle based on event type
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			fobj, err := ct.findObject(kind, eobj.GetKey())
			if err != nil {
				obj := &Tenant{
					Tenant:     *eobj,
					HandlerCtx: nil,
					ctrler:     ct,
				}
				ct.addObject(kind, obj.GetKey(), obj)
				ct.stats.Counter("Tenant_Created_Events").Inc()

				// call the event handler
				obj.Lock()
				err = tenantHandler.OnTenantCreate(obj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					ct.delObject(kind, eobj.GetKey())
					return err
				}
			} else {
				obj := fobj.(*Tenant)

				ct.stats.Counter("Tenant_Updated_Events").Inc()

				// call the event handler
				obj.Lock()
				err = tenantHandler.OnTenantUpdate(obj, eobj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					return err
				}
			}
		case kvstore.Deleted:
			fobj, err := ct.findObject(kind, eobj.GetKey())
			if err != nil {
				ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
				return err
			}

			obj := fobj.(*Tenant)

			ct.stats.Counter("Tenant_Deleted_Events").Inc()

			// Call the event reactor
			obj.Lock()
			err = tenantHandler.OnTenantDelete(obj)
			obj.Unlock()
			if err != nil {
				ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
			}

			ct.delObject(kind, eobj.GetKey())
		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on Tenant watch channel", tp)
	}

	return nil
}

// diffTenant does a diff of Tenant objects between local cache and API server
func (ct *ctrlerCtx) diffTenant(apicl apiclient.Services) {
	opts := api.ListWatchOptions{}

	// get a list of all objects from API server
	objlist, err := apicl.ClusterV1().Tenant().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Errorf("Error getting a list of objects. Err: %v", err)
		return
	}

	ct.logger.Infof("diffTenant(): TenantList returned %d objects", len(objlist))

	// build an object map
	objmap := make(map[string]*cluster.Tenant)
	for _, obj := range objlist {
		objmap[obj.GetKey()] = obj
	}

	// if an object is in our local cache and not in API server, trigger delete for it
	for _, obj := range ct.Tenant().List() {
		_, ok := objmap[obj.GetKey()]
		if !ok {
			ct.logger.Infof("diffTenant(): Deleting existing object %#v since its not in apiserver", obj.GetKey())
			evt := kvstore.WatchEvent{
				Type:   kvstore.Deleted,
				Key:    obj.GetKey(),
				Object: &obj.Tenant,
			}
			ct.handleTenantEvent(&evt)
		}
	}

	// trigger create event for all others
	for _, obj := range objlist {
		ct.logger.Infof("diffTenant(): Adding object %#v", obj.GetKey())
		evt := kvstore.WatchEvent{
			Type:   kvstore.Created,
			Key:    obj.GetKey(),
			Object: obj,
		}
		ct.handleTenantEvent(&evt)
	}
}

func (ct *ctrlerCtx) runTenantWatcher() {
	kind := "Tenant"

	// if there is no API server to connect to, we are done
	if (ct.resolver == nil) || ct.apisrvURL == "" {
		return
	}

	// create context
	ctx, cancel := context.WithCancel(context.Background())
	ct.Lock()
	ct.watchCancel[kind] = cancel
	ct.Unlock()
	opts := api.ListWatchOptions{}

	// setup wait group
	ct.waitGrp.Add(1)
	defer ct.waitGrp.Done()
	logger := ct.logger.WithContext("submodule", "TenantWatcher")

	ct.stats.Counter("Tenant_Watch").Inc()
	defer ct.stats.Counter("Tenant_Watch").Dec()

	// loop forever
	for {
		// create a grpc client
		apicl, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
		if err != nil {
			logger.Warnf("Failed to connect to gRPC server [%s]\n", ct.apisrvURL)
			ct.stats.Counter("Tenant_ApiClientErr").Inc()
		} else {
			logger.Infof("API client connected {%+v}", apicl)

			// Tenant object watcher
			wt, werr := apicl.ClusterV1().Tenant().Watch(ctx, &opts)
			if werr != nil {
				logger.Errorf("Failed to start %s watch (%s)\n", kind, werr)
				// wait for a second and retry connecting to api server
				apicl.Close()
				time.Sleep(time.Second)
				continue
			}
			ct.Lock()
			ct.watchers[kind] = wt
			ct.Unlock()

			// perform a diff with API server and local cache
			time.Sleep(time.Millisecond * 100)
			ct.diffTenant(apicl)

			// handle api server watch events
		innerLoop:
			for {
				// wait for events
				select {
				case evt, ok := <-wt.EventChan():
					if !ok {
						logger.Error("Error receiving from apisrv watcher")
						ct.stats.Counter("Tenant_WatchErrors").Inc()
						break innerLoop
					}

					// handle event
					ct.handleTenantEvent(evt)
				}
			}
			apicl.Close()
		}

		// if stop flag is set, we are done
		if ct.stoped {
			logger.Infof("Exiting API server watcher")
			return
		}

		// wait for a second and retry connecting to api server
		time.Sleep(time.Second)
	}
}

// WatchTenant starts watch on Tenant object
func (ct *ctrlerCtx) WatchTenant(handler TenantHandler) error {
	kind := "Tenant"

	ct.Lock()
	defer ct.Unlock()

	// see if we already have a watcher
	_, ok := ct.watchers[kind]
	if ok {
		return fmt.Errorf("Tenant watcher already exists")
	}

	// save handler
	ct.handlers[kind] = handler

	// run Tenant watcher in a go routine
	go ct.runTenantWatcher()

	return nil
}

// TenantAPI returns
type TenantAPI interface {
	Create(obj *cluster.Tenant) error
	Update(obj *cluster.Tenant) error
	Delete(obj *cluster.Tenant) error
	Find(meta *api.ObjectMeta) (*Tenant, error)
	List() []*Tenant
	Watch(handler TenantHandler) error
}

// dummy struct that implements TenantAPI
type tenantAPI struct {
	ct *ctrlerCtx
}

// Create creates Tenant object
func (api *tenantAPI) Create(obj *cluster.Tenant) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.ClusterV1().Tenant().Create(context.Background(), obj)
		if err != nil && strings.Contains(err.Error(), "AlreadyExists") {
			_, err = apicl.ClusterV1().Tenant().Update(context.Background(), obj)
		}
		if err != nil {
			return err
		}
	}

	return api.ct.handleTenantEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Created})
}

// Update triggers update on Tenant object
func (api *tenantAPI) Update(obj *cluster.Tenant) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.ClusterV1().Tenant().Update(context.Background(), obj)
		if err != nil {
			return err
		}
	}

	return api.ct.handleTenantEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Updated})
}

// Delete deletes Tenant object
func (api *tenantAPI) Delete(obj *cluster.Tenant) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		apicl.ClusterV1().Tenant().Delete(context.Background(), &obj.ObjectMeta)
	}

	return api.ct.handleTenantEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Deleted})
}

// Find returns an object by meta
func (api *tenantAPI) Find(meta *api.ObjectMeta) (*Tenant, error) {
	// find the object
	obj, err := api.ct.FindObject("Tenant", meta)
	if err != nil {
		return nil, err
	}

	// asset type
	switch obj.(type) {
	case *Tenant:
		hobj := obj.(*Tenant)
		return hobj, nil
	default:
		return nil, errors.New("incorrect object type")
	}
}

// List returns a list of all Tenant objects
func (api *tenantAPI) List() []*Tenant {
	var objlist []*Tenant

	objs := api.ct.ListObjects("Tenant")
	for _, obj := range objs {
		switch tp := obj.(type) {
		case *Tenant:
			eobj := obj.(*Tenant)
			objlist = append(objlist, eobj)
		default:
			log.Fatalf("Got invalid object type %v while looking for Tenant", tp)
		}
	}

	return objlist
}

// Watch sets up a event handlers for Tenant object
func (api *tenantAPI) Watch(handler TenantHandler) error {
	return api.ct.WatchTenant(handler)
}

// Tenant returns TenantAPI
func (ct *ctrlerCtx) Tenant() TenantAPI {
	return &tenantAPI{ct: ct}
}

// Version is a wrapper object that implements additional functionality
type Version struct {
	sync.Mutex
	cluster.Version
	HandlerCtx interface{} // additional state handlers can store
	ctrler     *ctrlerCtx  // reference back to the controller instance
}

func (obj *Version) Write() error {
	// if there is no API server to connect to, we are done
	if (obj.ctrler == nil) || (obj.ctrler.resolver == nil) || obj.ctrler.apisrvURL == "" {
		return nil
	}

	apicl, err := obj.ctrler.apiClient()
	if err != nil {
		obj.ctrler.logger.Errorf("Error creating API server clent. Err: %v", err)
		return err
	}

	obj.ctrler.stats.Counter("Version_Writes").Inc()

	// write to api server
	if obj.ObjectMeta.ResourceVersion != "" {
		// update it
		for i := 0; i < maxApisrvWriteRetry; i++ {
			_, err = apicl.ClusterV1().Version().Update(context.Background(), &obj.Version)
			if err == nil {
				break
			}
			time.Sleep(time.Millisecond * 100)
		}
	} else {
		//  create
		_, err = apicl.ClusterV1().Version().Create(context.Background(), &obj.Version)
	}

	return nil
}

// VersionHandler is the event handler for Version object
type VersionHandler interface {
	OnVersionCreate(obj *Version) error
	OnVersionUpdate(oldObj *Version, newObj *cluster.Version) error
	OnVersionDelete(obj *Version) error
}

// handleVersionEvent handles Version events from watcher
func (ct *ctrlerCtx) handleVersionEvent(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *cluster.Version:
		eobj := evt.Object.(*cluster.Version)
		kind := "Version"

		ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		handler, ok := ct.handlers[kind]
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		versionHandler := handler.(VersionHandler)
		// handle based on event type
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			fobj, err := ct.findObject(kind, eobj.GetKey())
			if err != nil {
				obj := &Version{
					Version:    *eobj,
					HandlerCtx: nil,
					ctrler:     ct,
				}
				ct.addObject(kind, obj.GetKey(), obj)
				ct.stats.Counter("Version_Created_Events").Inc()

				// call the event handler
				obj.Lock()
				err = versionHandler.OnVersionCreate(obj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					ct.delObject(kind, eobj.GetKey())
					return err
				}
			} else {
				obj := fobj.(*Version)

				ct.stats.Counter("Version_Updated_Events").Inc()

				// call the event handler
				obj.Lock()
				err = versionHandler.OnVersionUpdate(obj, eobj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					return err
				}
			}
		case kvstore.Deleted:
			fobj, err := ct.findObject(kind, eobj.GetKey())
			if err != nil {
				ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
				return err
			}

			obj := fobj.(*Version)

			ct.stats.Counter("Version_Deleted_Events").Inc()

			// Call the event reactor
			obj.Lock()
			err = versionHandler.OnVersionDelete(obj)
			obj.Unlock()
			if err != nil {
				ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
			}

			ct.delObject(kind, eobj.GetKey())
		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on Version watch channel", tp)
	}

	return nil
}

// diffVersion does a diff of Version objects between local cache and API server
func (ct *ctrlerCtx) diffVersion(apicl apiclient.Services) {
	opts := api.ListWatchOptions{}

	// get a list of all objects from API server
	objlist, err := apicl.ClusterV1().Version().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Errorf("Error getting a list of objects. Err: %v", err)
		return
	}

	ct.logger.Infof("diffVersion(): VersionList returned %d objects", len(objlist))

	// build an object map
	objmap := make(map[string]*cluster.Version)
	for _, obj := range objlist {
		objmap[obj.GetKey()] = obj
	}

	// if an object is in our local cache and not in API server, trigger delete for it
	for _, obj := range ct.Version().List() {
		_, ok := objmap[obj.GetKey()]
		if !ok {
			ct.logger.Infof("diffVersion(): Deleting existing object %#v since its not in apiserver", obj.GetKey())
			evt := kvstore.WatchEvent{
				Type:   kvstore.Deleted,
				Key:    obj.GetKey(),
				Object: &obj.Version,
			}
			ct.handleVersionEvent(&evt)
		}
	}

	// trigger create event for all others
	for _, obj := range objlist {
		ct.logger.Infof("diffVersion(): Adding object %#v", obj.GetKey())
		evt := kvstore.WatchEvent{
			Type:   kvstore.Created,
			Key:    obj.GetKey(),
			Object: obj,
		}
		ct.handleVersionEvent(&evt)
	}
}

func (ct *ctrlerCtx) runVersionWatcher() {
	kind := "Version"

	// if there is no API server to connect to, we are done
	if (ct.resolver == nil) || ct.apisrvURL == "" {
		return
	}

	// create context
	ctx, cancel := context.WithCancel(context.Background())
	ct.Lock()
	ct.watchCancel[kind] = cancel
	ct.Unlock()
	opts := api.ListWatchOptions{}

	// setup wait group
	ct.waitGrp.Add(1)
	defer ct.waitGrp.Done()
	logger := ct.logger.WithContext("submodule", "VersionWatcher")

	ct.stats.Counter("Version_Watch").Inc()
	defer ct.stats.Counter("Version_Watch").Dec()

	// loop forever
	for {
		// create a grpc client
		apicl, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
		if err != nil {
			logger.Warnf("Failed to connect to gRPC server [%s]\n", ct.apisrvURL)
			ct.stats.Counter("Version_ApiClientErr").Inc()
		} else {
			logger.Infof("API client connected {%+v}", apicl)

			// Version object watcher
			wt, werr := apicl.ClusterV1().Version().Watch(ctx, &opts)
			if werr != nil {
				logger.Errorf("Failed to start %s watch (%s)\n", kind, werr)
				// wait for a second and retry connecting to api server
				apicl.Close()
				time.Sleep(time.Second)
				continue
			}
			ct.Lock()
			ct.watchers[kind] = wt
			ct.Unlock()

			// perform a diff with API server and local cache
			time.Sleep(time.Millisecond * 100)
			ct.diffVersion(apicl)

			// handle api server watch events
		innerLoop:
			for {
				// wait for events
				select {
				case evt, ok := <-wt.EventChan():
					if !ok {
						logger.Error("Error receiving from apisrv watcher")
						ct.stats.Counter("Version_WatchErrors").Inc()
						break innerLoop
					}

					// handle event
					ct.handleVersionEvent(evt)
				}
			}
			apicl.Close()
		}

		// if stop flag is set, we are done
		if ct.stoped {
			logger.Infof("Exiting API server watcher")
			return
		}

		// wait for a second and retry connecting to api server
		time.Sleep(time.Second)
	}
}

// WatchVersion starts watch on Version object
func (ct *ctrlerCtx) WatchVersion(handler VersionHandler) error {
	kind := "Version"

	ct.Lock()
	defer ct.Unlock()

	// see if we already have a watcher
	_, ok := ct.watchers[kind]
	if ok {
		return fmt.Errorf("Version watcher already exists")
	}

	// save handler
	ct.handlers[kind] = handler

	// run Version watcher in a go routine
	go ct.runVersionWatcher()

	return nil
}

// VersionAPI returns
type VersionAPI interface {
	Create(obj *cluster.Version) error
	Update(obj *cluster.Version) error
	Delete(obj *cluster.Version) error
	Find(meta *api.ObjectMeta) (*Version, error)
	List() []*Version
	Watch(handler VersionHandler) error
}

// dummy struct that implements VersionAPI
type versionAPI struct {
	ct *ctrlerCtx
}

// Create creates Version object
func (api *versionAPI) Create(obj *cluster.Version) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.ClusterV1().Version().Create(context.Background(), obj)
		if err != nil && strings.Contains(err.Error(), "AlreadyExists") {
			_, err = apicl.ClusterV1().Version().Update(context.Background(), obj)
		}
		if err != nil {
			return err
		}
	}

	return api.ct.handleVersionEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Created})
}

// Update triggers update on Version object
func (api *versionAPI) Update(obj *cluster.Version) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.ClusterV1().Version().Update(context.Background(), obj)
		if err != nil {
			return err
		}
	}

	return api.ct.handleVersionEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Updated})
}

// Delete deletes Version object
func (api *versionAPI) Delete(obj *cluster.Version) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		apicl.ClusterV1().Version().Delete(context.Background(), &obj.ObjectMeta)
	}

	return api.ct.handleVersionEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Deleted})
}

// Find returns an object by meta
func (api *versionAPI) Find(meta *api.ObjectMeta) (*Version, error) {
	// find the object
	obj, err := api.ct.FindObject("Version", meta)
	if err != nil {
		return nil, err
	}

	// asset type
	switch obj.(type) {
	case *Version:
		hobj := obj.(*Version)
		return hobj, nil
	default:
		return nil, errors.New("incorrect object type")
	}
}

// List returns a list of all Version objects
func (api *versionAPI) List() []*Version {
	var objlist []*Version

	objs := api.ct.ListObjects("Version")
	for _, obj := range objs {
		switch tp := obj.(type) {
		case *Version:
			eobj := obj.(*Version)
			objlist = append(objlist, eobj)
		default:
			log.Fatalf("Got invalid object type %v while looking for Version", tp)
		}
	}

	return objlist
}

// Watch sets up a event handlers for Version object
func (api *versionAPI) Watch(handler VersionHandler) error {
	return api.ct.WatchVersion(handler)
}

// Version returns VersionAPI
func (ct *ctrlerCtx) Version() VersionAPI {
	return &versionAPI{ct: ct}
}
