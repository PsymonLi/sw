// Code generated by protoc-gen-grpc-pensando DO NOT EDIT.

/*
Package ctkit is a auto generated package.
Input file: example.proto
*/
package ctkit

import (
	"context"
	"errors"
	"fmt"
	"strings"
	"sync"
	"time"

	"github.com/pensando/sw/api"
	"github.com/pensando/sw/api/generated/apiclient"
	"github.com/pensando/sw/api/generated/bookstore"
	"github.com/pensando/sw/venice/utils/balancer"
	"github.com/pensando/sw/venice/utils/kvstore"
	"github.com/pensando/sw/venice/utils/log"
	"github.com/pensando/sw/venice/utils/rpckit"
	"github.com/pensando/sw/venice/utils/shardworkers"
)

// Order is a wrapper object that implements additional functionality
type Order struct {
	sync.Mutex
	bookstore.Order
	HandlerCtx interface{} // additional state handlers can store
	ctrler     *ctrlerCtx  // reference back to the controller instance
}

func (obj *Order) Write() error {
	// if there is no API server to connect to, we are done
	if (obj.ctrler == nil) || (obj.ctrler.resolver == nil) || obj.ctrler.apisrvURL == "" {
		return nil
	}

	apicl, err := obj.ctrler.apiClient()
	if err != nil {
		obj.ctrler.logger.Errorf("Error creating API server clent. Err: %v", err)
		return err
	}

	obj.ctrler.stats.Counter("Order_Writes").Inc()

	// write to api server
	if obj.ObjectMeta.ResourceVersion != "" {
		// update it
		for i := 0; i < maxApisrvWriteRetry; i++ {
			_, err = apicl.BookstoreV1().Order().UpdateStatus(context.Background(), &obj.Order)
			if err == nil {
				break
			}
			time.Sleep(time.Millisecond * 100)
		}
	} else {
		//  create
		_, err = apicl.BookstoreV1().Order().Create(context.Background(), &obj.Order)
	}

	return nil
}

// OrderHandler is the event handler for Order object
type OrderHandler interface {
	OnOrderCreate(obj *Order) error
	OnOrderUpdate(oldObj *Order, newObj *bookstore.Order) error
	OnOrderDelete(obj *Order) error
}

// handleOrderEvent handles Order events from watcher
func (ct *ctrlerCtx) handleOrderEvent(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *bookstore.Order:
		eobj := evt.Object.(*bookstore.Order)
		kind := "Order"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		handler, ok := ct.handlers[kind]
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		orderHandler := handler.(OrderHandler)
		// handle based on event type
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			fobj, err := ct.findObject(kind, eobj.GetKey())
			if err != nil {
				obj := &Order{
					Order:      *eobj,
					HandlerCtx: nil,
					ctrler:     ct,
				}
				ct.addObject(kind, obj.GetKey(), obj)
				ct.stats.Counter("Order_Created_Events").Inc()

				// call the event handler
				obj.Lock()
				err = orderHandler.OnOrderCreate(obj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					ct.delObject(kind, eobj.GetKey())
					return err
				}
			} else {
				obj := fobj.(*Order)

				ct.stats.Counter("Order_Updated_Events").Inc()

				// call the event handler
				obj.Lock()
				err = orderHandler.OnOrderUpdate(obj, eobj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					return err
				}
			}
		case kvstore.Deleted:
			fobj, err := ct.findObject(kind, eobj.GetKey())
			if err != nil {
				ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
				return err
			}

			obj := fobj.(*Order)

			ct.stats.Counter("Order_Deleted_Events").Inc()

			// Call the event reactor
			obj.Lock()
			err = orderHandler.OnOrderDelete(obj)
			obj.Unlock()
			if err != nil {
				ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
			}

			ct.delObject(kind, eobj.GetKey())
		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on Order watch channel", tp)
	}

	return nil
}

// handleOrderEventParallel handles Order events from watcher
func (ct *ctrlerCtx) handleOrderEventParallel(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *bookstore.Order:
		eobj := evt.Object.(*bookstore.Order)
		kind := "Order"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		handler, ok := ct.handlers[kind]
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		orderHandler := handler.(OrderHandler)
		// handle based on event type
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			workFunc := func(ctx context.Context, userCtx shardworkers.WorkObj) error {
				var err error
				eobj := userCtx.(*bookstore.Order)
				fobj, err := ct.findObject(kind, eobj.GetKey())
				if err != nil {
					obj := &Order{
						Order:      *eobj,
						HandlerCtx: nil,
						ctrler:     ct,
					}
					ct.addObject(kind, obj.GetKey(), obj)
					ct.stats.Counter("Order_Created_Events").Inc()
					obj.Lock()
					err = orderHandler.OnOrderCreate(obj)
					obj.Unlock()
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
						ct.delObject(kind, obj.Order.GetKey())
					}
				} else {
					obj := fobj.(*Order)
					ct.stats.Counter("Order_Updated_Events").Inc()
					obj.Lock()
					err = orderHandler.OnOrderUpdate(obj, eobj)
					obj.Unlock()
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					}
				}
				return err
			}
			ct.runJob("Order", eobj, workFunc)
		case kvstore.Deleted:
			workFunc := func(ctx context.Context, userCtx shardworkers.WorkObj) error {
				eobj := userCtx.(*bookstore.Order)
				fobj, err := ct.findObject(kind, eobj.GetKey())
				if err != nil {
					ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
					return err
				}
				obj := fobj.(*Order)
				ct.stats.Counter("Order_Deleted_Events").Inc()
				obj.Lock()
				err = orderHandler.OnOrderDelete(obj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
				}
				ct.delObject(kind, obj.Order.GetKey())
				return nil
			}
			ct.runJob("Order", eobj, workFunc)
		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on Order watch channel", tp)
	}

	return nil
}

// diffOrder does a diff of Order objects between local cache and API server
func (ct *ctrlerCtx) diffOrder(apicl apiclient.Services) {
	opts := api.ListWatchOptions{}

	// get a list of all objects from API server
	objlist, err := apicl.BookstoreV1().Order().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Errorf("Error getting a list of objects. Err: %v", err)
		return
	}

	ct.logger.Infof("diffOrder(): OrderList returned %d objects", len(objlist))

	// build an object map
	objmap := make(map[string]*bookstore.Order)
	for _, obj := range objlist {
		objmap[obj.GetKey()] = obj
	}

	// if an object is in our local cache and not in API server, trigger delete for it
	for _, obj := range ct.Order().List() {
		_, ok := objmap[obj.GetKey()]
		if !ok {
			ct.logger.Infof("diffOrder(): Deleting existing object %#v since its not in apiserver", obj.GetKey())
			evt := kvstore.WatchEvent{
				Type:   kvstore.Deleted,
				Key:    obj.GetKey(),
				Object: &obj.Order,
			}
			ct.handleOrderEvent(&evt)
		}
	}

	// trigger create event for all others
	for _, obj := range objlist {
		ct.logger.Infof("diffOrder(): Adding object %#v", obj.GetKey())
		evt := kvstore.WatchEvent{
			Type:   kvstore.Created,
			Key:    obj.GetKey(),
			Object: obj,
		}
		ct.handleOrderEvent(&evt)
	}
}

func (ct *ctrlerCtx) runOrderWatcher() {
	kind := "Order"

	// if there is no API server to connect to, we are done
	if (ct.resolver == nil) || ct.apisrvURL == "" {
		return
	}

	// create context
	ctx, cancel := context.WithCancel(context.Background())
	ct.Lock()
	ct.watchCancel[kind] = cancel
	ct.Unlock()
	opts := api.ListWatchOptions{}
	logger := ct.logger.WithContext("submodule", "OrderWatcher")

	// create a grpc client
	apiclt, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
	if err == nil {
		ct.diffOrder(apiclt)
	}

	// setup wait group
	ct.waitGrp.Add(1)

	// start a goroutine
	go func() {
		defer ct.waitGrp.Done()
		ct.stats.Counter("Order_Watch").Inc()
		defer ct.stats.Counter("Order_Watch").Dec()

		// loop forever
		for {
			// create a grpc client
			apicl, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
			if err != nil {
				logger.Warnf("Failed to connect to gRPC server [%s]\n", ct.apisrvURL)
				ct.stats.Counter("Order_ApiClientErr").Inc()
			} else {
				logger.Infof("API client connected {%+v}", apicl)

				// Order object watcher
				wt, werr := apicl.BookstoreV1().Order().Watch(ctx, &opts)
				if werr != nil {
					logger.Errorf("Failed to start %s watch (%s)\n", kind, werr)
					// wait for a second and retry connecting to api server
					apicl.Close()
					time.Sleep(time.Second)
					continue
				}
				ct.Lock()
				ct.watchers[kind] = wt
				ct.Unlock()

				// perform a diff with API server and local cache
				time.Sleep(time.Millisecond * 100)
				ct.diffOrder(apicl)

				// handle api server watch events
			innerLoop:
				for {
					// wait for events
					select {
					case evt, ok := <-wt.EventChan():
						if !ok {
							logger.Error("Error receiving from apisrv watcher")
							ct.stats.Counter("Order_WatchErrors").Inc()
							break innerLoop
						}

						// handle event in parallel
						ct.handleOrderEventParallel(evt)
					}
				}
				apicl.Close()
			}

			// if stop flag is set, we are done
			if ct.stoped {
				logger.Infof("Exiting API server watcher")
				return
			}

			// wait for a second and retry connecting to api server
			time.Sleep(time.Second)
		}
	}()
}

// WatchOrder starts watch on Order object
func (ct *ctrlerCtx) WatchOrder(handler OrderHandler) error {
	kind := "Order"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchers[kind]
	ct.Unlock()
	if ok {
		return fmt.Errorf("Order watcher already exists")
	}

	// save handler
	ct.Lock()
	ct.handlers[kind] = handler
	ct.Unlock()

	// run Order watcher in a go routine
	ct.runOrderWatcher()

	return nil
}

// OrderAPI returns
type OrderAPI interface {
	Create(obj *bookstore.Order) error
	Update(obj *bookstore.Order) error
	Delete(obj *bookstore.Order) error
	Find(meta *api.ObjectMeta) (*Order, error)
	List() []*Order
	Watch(handler OrderHandler) error
}

// dummy struct that implements OrderAPI
type orderAPI struct {
	ct *ctrlerCtx
}

// Create creates Order object
func (api *orderAPI) Create(obj *bookstore.Order) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.BookstoreV1().Order().Create(context.Background(), obj)
		if err != nil && strings.Contains(err.Error(), "AlreadyExists") {
			_, err = apicl.BookstoreV1().Order().Update(context.Background(), obj)
		}
		return err
	}

	return api.ct.handleOrderEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Created})
}

// Update triggers update on Order object
func (api *orderAPI) Update(obj *bookstore.Order) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.BookstoreV1().Order().Update(context.Background(), obj)
		return err
	}

	return api.ct.handleOrderEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Updated})
}

// Delete deletes Order object
func (api *orderAPI) Delete(obj *bookstore.Order) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.BookstoreV1().Order().Delete(context.Background(), &obj.ObjectMeta)
		return err
	}

	return api.ct.handleOrderEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Deleted})
}

// Find returns an object by meta
func (api *orderAPI) Find(meta *api.ObjectMeta) (*Order, error) {
	// find the object
	obj, err := api.ct.FindObject("Order", meta)
	if err != nil {
		return nil, err
	}

	// asset type
	switch obj.(type) {
	case *Order:
		hobj := obj.(*Order)
		return hobj, nil
	default:
		return nil, errors.New("incorrect object type")
	}
}

// List returns a list of all Order objects
func (api *orderAPI) List() []*Order {
	var objlist []*Order

	objs := api.ct.ListObjects("Order")
	for _, obj := range objs {
		switch tp := obj.(type) {
		case *Order:
			eobj := obj.(*Order)
			objlist = append(objlist, eobj)
		default:
			log.Fatalf("Got invalid object type %v while looking for Order", tp)
		}
	}

	return objlist
}

// Watch sets up a event handlers for Order object
func (api *orderAPI) Watch(handler OrderHandler) error {
	api.ct.startWorkerPool("Order")
	return api.ct.WatchOrder(handler)
}

// Order returns OrderAPI
func (ct *ctrlerCtx) Order() OrderAPI {
	return &orderAPI{ct: ct}
}

// Book is a wrapper object that implements additional functionality
type Book struct {
	sync.Mutex
	bookstore.Book
	HandlerCtx interface{} // additional state handlers can store
	ctrler     *ctrlerCtx  // reference back to the controller instance
}

func (obj *Book) Write() error {
	// if there is no API server to connect to, we are done
	if (obj.ctrler == nil) || (obj.ctrler.resolver == nil) || obj.ctrler.apisrvURL == "" {
		return nil
	}

	apicl, err := obj.ctrler.apiClient()
	if err != nil {
		obj.ctrler.logger.Errorf("Error creating API server clent. Err: %v", err)
		return err
	}

	obj.ctrler.stats.Counter("Book_Writes").Inc()

	// write to api server
	if obj.ObjectMeta.ResourceVersion != "" {
		// update it
		for i := 0; i < maxApisrvWriteRetry; i++ {
			_, err = apicl.BookstoreV1().Book().UpdateStatus(context.Background(), &obj.Book)
			if err == nil {
				break
			}
			time.Sleep(time.Millisecond * 100)
		}
	} else {
		//  create
		_, err = apicl.BookstoreV1().Book().Create(context.Background(), &obj.Book)
	}

	return nil
}

// BookHandler is the event handler for Book object
type BookHandler interface {
	OnBookCreate(obj *Book) error
	OnBookUpdate(oldObj *Book, newObj *bookstore.Book) error
	OnBookDelete(obj *Book) error
}

// handleBookEvent handles Book events from watcher
func (ct *ctrlerCtx) handleBookEvent(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *bookstore.Book:
		eobj := evt.Object.(*bookstore.Book)
		kind := "Book"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		handler, ok := ct.handlers[kind]
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		bookHandler := handler.(BookHandler)
		// handle based on event type
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			fobj, err := ct.findObject(kind, eobj.GetKey())
			if err != nil {
				obj := &Book{
					Book:       *eobj,
					HandlerCtx: nil,
					ctrler:     ct,
				}
				ct.addObject(kind, obj.GetKey(), obj)
				ct.stats.Counter("Book_Created_Events").Inc()

				// call the event handler
				obj.Lock()
				err = bookHandler.OnBookCreate(obj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					ct.delObject(kind, eobj.GetKey())
					return err
				}
			} else {
				obj := fobj.(*Book)

				ct.stats.Counter("Book_Updated_Events").Inc()

				// call the event handler
				obj.Lock()
				err = bookHandler.OnBookUpdate(obj, eobj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					return err
				}
			}
		case kvstore.Deleted:
			fobj, err := ct.findObject(kind, eobj.GetKey())
			if err != nil {
				ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
				return err
			}

			obj := fobj.(*Book)

			ct.stats.Counter("Book_Deleted_Events").Inc()

			// Call the event reactor
			obj.Lock()
			err = bookHandler.OnBookDelete(obj)
			obj.Unlock()
			if err != nil {
				ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
			}

			ct.delObject(kind, eobj.GetKey())
		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on Book watch channel", tp)
	}

	return nil
}

// handleBookEventParallel handles Book events from watcher
func (ct *ctrlerCtx) handleBookEventParallel(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *bookstore.Book:
		eobj := evt.Object.(*bookstore.Book)
		kind := "Book"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		handler, ok := ct.handlers[kind]
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		bookHandler := handler.(BookHandler)
		// handle based on event type
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			workFunc := func(ctx context.Context, userCtx shardworkers.WorkObj) error {
				var err error
				eobj := userCtx.(*bookstore.Book)
				fobj, err := ct.findObject(kind, eobj.GetKey())
				if err != nil {
					obj := &Book{
						Book:       *eobj,
						HandlerCtx: nil,
						ctrler:     ct,
					}
					ct.addObject(kind, obj.GetKey(), obj)
					ct.stats.Counter("Book_Created_Events").Inc()
					obj.Lock()
					err = bookHandler.OnBookCreate(obj)
					obj.Unlock()
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
						ct.delObject(kind, obj.Book.GetKey())
					}
				} else {
					obj := fobj.(*Book)
					ct.stats.Counter("Book_Updated_Events").Inc()
					obj.Lock()
					err = bookHandler.OnBookUpdate(obj, eobj)
					obj.Unlock()
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					}
				}
				return err
			}
			ct.runJob("Book", eobj, workFunc)
		case kvstore.Deleted:
			workFunc := func(ctx context.Context, userCtx shardworkers.WorkObj) error {
				eobj := userCtx.(*bookstore.Book)
				fobj, err := ct.findObject(kind, eobj.GetKey())
				if err != nil {
					ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
					return err
				}
				obj := fobj.(*Book)
				ct.stats.Counter("Book_Deleted_Events").Inc()
				obj.Lock()
				err = bookHandler.OnBookDelete(obj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
				}
				ct.delObject(kind, obj.Book.GetKey())
				return nil
			}
			ct.runJob("Book", eobj, workFunc)
		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on Book watch channel", tp)
	}

	return nil
}

// diffBook does a diff of Book objects between local cache and API server
func (ct *ctrlerCtx) diffBook(apicl apiclient.Services) {
	opts := api.ListWatchOptions{}

	// get a list of all objects from API server
	objlist, err := apicl.BookstoreV1().Book().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Errorf("Error getting a list of objects. Err: %v", err)
		return
	}

	ct.logger.Infof("diffBook(): BookList returned %d objects", len(objlist))

	// build an object map
	objmap := make(map[string]*bookstore.Book)
	for _, obj := range objlist {
		objmap[obj.GetKey()] = obj
	}

	// if an object is in our local cache and not in API server, trigger delete for it
	for _, obj := range ct.Book().List() {
		_, ok := objmap[obj.GetKey()]
		if !ok {
			ct.logger.Infof("diffBook(): Deleting existing object %#v since its not in apiserver", obj.GetKey())
			evt := kvstore.WatchEvent{
				Type:   kvstore.Deleted,
				Key:    obj.GetKey(),
				Object: &obj.Book,
			}
			ct.handleBookEvent(&evt)
		}
	}

	// trigger create event for all others
	for _, obj := range objlist {
		ct.logger.Infof("diffBook(): Adding object %#v", obj.GetKey())
		evt := kvstore.WatchEvent{
			Type:   kvstore.Created,
			Key:    obj.GetKey(),
			Object: obj,
		}
		ct.handleBookEvent(&evt)
	}
}

func (ct *ctrlerCtx) runBookWatcher() {
	kind := "Book"

	// if there is no API server to connect to, we are done
	if (ct.resolver == nil) || ct.apisrvURL == "" {
		return
	}

	// create context
	ctx, cancel := context.WithCancel(context.Background())
	ct.Lock()
	ct.watchCancel[kind] = cancel
	ct.Unlock()
	opts := api.ListWatchOptions{}
	logger := ct.logger.WithContext("submodule", "BookWatcher")

	// create a grpc client
	apiclt, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
	if err == nil {
		ct.diffBook(apiclt)
	}

	// setup wait group
	ct.waitGrp.Add(1)

	// start a goroutine
	go func() {
		defer ct.waitGrp.Done()
		ct.stats.Counter("Book_Watch").Inc()
		defer ct.stats.Counter("Book_Watch").Dec()

		// loop forever
		for {
			// create a grpc client
			apicl, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
			if err != nil {
				logger.Warnf("Failed to connect to gRPC server [%s]\n", ct.apisrvURL)
				ct.stats.Counter("Book_ApiClientErr").Inc()
			} else {
				logger.Infof("API client connected {%+v}", apicl)

				// Book object watcher
				wt, werr := apicl.BookstoreV1().Book().Watch(ctx, &opts)
				if werr != nil {
					logger.Errorf("Failed to start %s watch (%s)\n", kind, werr)
					// wait for a second and retry connecting to api server
					apicl.Close()
					time.Sleep(time.Second)
					continue
				}
				ct.Lock()
				ct.watchers[kind] = wt
				ct.Unlock()

				// perform a diff with API server and local cache
				time.Sleep(time.Millisecond * 100)
				ct.diffBook(apicl)

				// handle api server watch events
			innerLoop:
				for {
					// wait for events
					select {
					case evt, ok := <-wt.EventChan():
						if !ok {
							logger.Error("Error receiving from apisrv watcher")
							ct.stats.Counter("Book_WatchErrors").Inc()
							break innerLoop
						}

						// handle event in parallel
						ct.handleBookEventParallel(evt)
					}
				}
				apicl.Close()
			}

			// if stop flag is set, we are done
			if ct.stoped {
				logger.Infof("Exiting API server watcher")
				return
			}

			// wait for a second and retry connecting to api server
			time.Sleep(time.Second)
		}
	}()
}

// WatchBook starts watch on Book object
func (ct *ctrlerCtx) WatchBook(handler BookHandler) error {
	kind := "Book"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchers[kind]
	ct.Unlock()
	if ok {
		return fmt.Errorf("Book watcher already exists")
	}

	// save handler
	ct.Lock()
	ct.handlers[kind] = handler
	ct.Unlock()

	// run Book watcher in a go routine
	ct.runBookWatcher()

	return nil
}

// BookAPI returns
type BookAPI interface {
	Create(obj *bookstore.Book) error
	Update(obj *bookstore.Book) error
	Delete(obj *bookstore.Book) error
	Find(meta *api.ObjectMeta) (*Book, error)
	List() []*Book
	Watch(handler BookHandler) error
}

// dummy struct that implements BookAPI
type bookAPI struct {
	ct *ctrlerCtx
}

// Create creates Book object
func (api *bookAPI) Create(obj *bookstore.Book) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.BookstoreV1().Book().Create(context.Background(), obj)
		if err != nil && strings.Contains(err.Error(), "AlreadyExists") {
			_, err = apicl.BookstoreV1().Book().Update(context.Background(), obj)
		}
		return err
	}

	return api.ct.handleBookEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Created})
}

// Update triggers update on Book object
func (api *bookAPI) Update(obj *bookstore.Book) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.BookstoreV1().Book().Update(context.Background(), obj)
		return err
	}

	return api.ct.handleBookEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Updated})
}

// Delete deletes Book object
func (api *bookAPI) Delete(obj *bookstore.Book) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.BookstoreV1().Book().Delete(context.Background(), &obj.ObjectMeta)
		return err
	}

	return api.ct.handleBookEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Deleted})
}

// Find returns an object by meta
func (api *bookAPI) Find(meta *api.ObjectMeta) (*Book, error) {
	// find the object
	obj, err := api.ct.FindObject("Book", meta)
	if err != nil {
		return nil, err
	}

	// asset type
	switch obj.(type) {
	case *Book:
		hobj := obj.(*Book)
		return hobj, nil
	default:
		return nil, errors.New("incorrect object type")
	}
}

// List returns a list of all Book objects
func (api *bookAPI) List() []*Book {
	var objlist []*Book

	objs := api.ct.ListObjects("Book")
	for _, obj := range objs {
		switch tp := obj.(type) {
		case *Book:
			eobj := obj.(*Book)
			objlist = append(objlist, eobj)
		default:
			log.Fatalf("Got invalid object type %v while looking for Book", tp)
		}
	}

	return objlist
}

// Watch sets up a event handlers for Book object
func (api *bookAPI) Watch(handler BookHandler) error {
	api.ct.startWorkerPool("Book")
	return api.ct.WatchBook(handler)
}

// Book returns BookAPI
func (ct *ctrlerCtx) Book() BookAPI {
	return &bookAPI{ct: ct}
}

// Publisher is a wrapper object that implements additional functionality
type Publisher struct {
	sync.Mutex
	bookstore.Publisher
	HandlerCtx interface{} // additional state handlers can store
	ctrler     *ctrlerCtx  // reference back to the controller instance
}

func (obj *Publisher) Write() error {
	// if there is no API server to connect to, we are done
	if (obj.ctrler == nil) || (obj.ctrler.resolver == nil) || obj.ctrler.apisrvURL == "" {
		return nil
	}

	apicl, err := obj.ctrler.apiClient()
	if err != nil {
		obj.ctrler.logger.Errorf("Error creating API server clent. Err: %v", err)
		return err
	}

	obj.ctrler.stats.Counter("Publisher_Writes").Inc()

	// write to api server
	if obj.ObjectMeta.ResourceVersion != "" {
		// update it
		for i := 0; i < maxApisrvWriteRetry; i++ {
			_, err = apicl.BookstoreV1().Publisher().UpdateStatus(context.Background(), &obj.Publisher)
			if err == nil {
				break
			}
			time.Sleep(time.Millisecond * 100)
		}
	} else {
		//  create
		_, err = apicl.BookstoreV1().Publisher().Create(context.Background(), &obj.Publisher)
	}

	return nil
}

// PublisherHandler is the event handler for Publisher object
type PublisherHandler interface {
	OnPublisherCreate(obj *Publisher) error
	OnPublisherUpdate(oldObj *Publisher, newObj *bookstore.Publisher) error
	OnPublisherDelete(obj *Publisher) error
}

// handlePublisherEvent handles Publisher events from watcher
func (ct *ctrlerCtx) handlePublisherEvent(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *bookstore.Publisher:
		eobj := evt.Object.(*bookstore.Publisher)
		kind := "Publisher"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		handler, ok := ct.handlers[kind]
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		publisherHandler := handler.(PublisherHandler)
		// handle based on event type
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			fobj, err := ct.findObject(kind, eobj.GetKey())
			if err != nil {
				obj := &Publisher{
					Publisher:  *eobj,
					HandlerCtx: nil,
					ctrler:     ct,
				}
				ct.addObject(kind, obj.GetKey(), obj)
				ct.stats.Counter("Publisher_Created_Events").Inc()

				// call the event handler
				obj.Lock()
				err = publisherHandler.OnPublisherCreate(obj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					ct.delObject(kind, eobj.GetKey())
					return err
				}
			} else {
				obj := fobj.(*Publisher)

				ct.stats.Counter("Publisher_Updated_Events").Inc()

				// call the event handler
				obj.Lock()
				err = publisherHandler.OnPublisherUpdate(obj, eobj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					return err
				}
			}
		case kvstore.Deleted:
			fobj, err := ct.findObject(kind, eobj.GetKey())
			if err != nil {
				ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
				return err
			}

			obj := fobj.(*Publisher)

			ct.stats.Counter("Publisher_Deleted_Events").Inc()

			// Call the event reactor
			obj.Lock()
			err = publisherHandler.OnPublisherDelete(obj)
			obj.Unlock()
			if err != nil {
				ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
			}

			ct.delObject(kind, eobj.GetKey())
		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on Publisher watch channel", tp)
	}

	return nil
}

// handlePublisherEventParallel handles Publisher events from watcher
func (ct *ctrlerCtx) handlePublisherEventParallel(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *bookstore.Publisher:
		eobj := evt.Object.(*bookstore.Publisher)
		kind := "Publisher"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		handler, ok := ct.handlers[kind]
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		publisherHandler := handler.(PublisherHandler)
		// handle based on event type
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			workFunc := func(ctx context.Context, userCtx shardworkers.WorkObj) error {
				var err error
				eobj := userCtx.(*bookstore.Publisher)
				fobj, err := ct.findObject(kind, eobj.GetKey())
				if err != nil {
					obj := &Publisher{
						Publisher:  *eobj,
						HandlerCtx: nil,
						ctrler:     ct,
					}
					ct.addObject(kind, obj.GetKey(), obj)
					ct.stats.Counter("Publisher_Created_Events").Inc()
					obj.Lock()
					err = publisherHandler.OnPublisherCreate(obj)
					obj.Unlock()
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
						ct.delObject(kind, obj.Publisher.GetKey())
					}
				} else {
					obj := fobj.(*Publisher)
					ct.stats.Counter("Publisher_Updated_Events").Inc()
					obj.Lock()
					err = publisherHandler.OnPublisherUpdate(obj, eobj)
					obj.Unlock()
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					}
				}
				return err
			}
			ct.runJob("Publisher", eobj, workFunc)
		case kvstore.Deleted:
			workFunc := func(ctx context.Context, userCtx shardworkers.WorkObj) error {
				eobj := userCtx.(*bookstore.Publisher)
				fobj, err := ct.findObject(kind, eobj.GetKey())
				if err != nil {
					ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
					return err
				}
				obj := fobj.(*Publisher)
				ct.stats.Counter("Publisher_Deleted_Events").Inc()
				obj.Lock()
				err = publisherHandler.OnPublisherDelete(obj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
				}
				ct.delObject(kind, obj.Publisher.GetKey())
				return nil
			}
			ct.runJob("Publisher", eobj, workFunc)
		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on Publisher watch channel", tp)
	}

	return nil
}

// diffPublisher does a diff of Publisher objects between local cache and API server
func (ct *ctrlerCtx) diffPublisher(apicl apiclient.Services) {
	opts := api.ListWatchOptions{}

	// get a list of all objects from API server
	objlist, err := apicl.BookstoreV1().Publisher().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Errorf("Error getting a list of objects. Err: %v", err)
		return
	}

	ct.logger.Infof("diffPublisher(): PublisherList returned %d objects", len(objlist))

	// build an object map
	objmap := make(map[string]*bookstore.Publisher)
	for _, obj := range objlist {
		objmap[obj.GetKey()] = obj
	}

	// if an object is in our local cache and not in API server, trigger delete for it
	for _, obj := range ct.Publisher().List() {
		_, ok := objmap[obj.GetKey()]
		if !ok {
			ct.logger.Infof("diffPublisher(): Deleting existing object %#v since its not in apiserver", obj.GetKey())
			evt := kvstore.WatchEvent{
				Type:   kvstore.Deleted,
				Key:    obj.GetKey(),
				Object: &obj.Publisher,
			}
			ct.handlePublisherEvent(&evt)
		}
	}

	// trigger create event for all others
	for _, obj := range objlist {
		ct.logger.Infof("diffPublisher(): Adding object %#v", obj.GetKey())
		evt := kvstore.WatchEvent{
			Type:   kvstore.Created,
			Key:    obj.GetKey(),
			Object: obj,
		}
		ct.handlePublisherEvent(&evt)
	}
}

func (ct *ctrlerCtx) runPublisherWatcher() {
	kind := "Publisher"

	// if there is no API server to connect to, we are done
	if (ct.resolver == nil) || ct.apisrvURL == "" {
		return
	}

	// create context
	ctx, cancel := context.WithCancel(context.Background())
	ct.Lock()
	ct.watchCancel[kind] = cancel
	ct.Unlock()
	opts := api.ListWatchOptions{}
	logger := ct.logger.WithContext("submodule", "PublisherWatcher")

	// create a grpc client
	apiclt, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
	if err == nil {
		ct.diffPublisher(apiclt)
	}

	// setup wait group
	ct.waitGrp.Add(1)

	// start a goroutine
	go func() {
		defer ct.waitGrp.Done()
		ct.stats.Counter("Publisher_Watch").Inc()
		defer ct.stats.Counter("Publisher_Watch").Dec()

		// loop forever
		for {
			// create a grpc client
			apicl, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
			if err != nil {
				logger.Warnf("Failed to connect to gRPC server [%s]\n", ct.apisrvURL)
				ct.stats.Counter("Publisher_ApiClientErr").Inc()
			} else {
				logger.Infof("API client connected {%+v}", apicl)

				// Publisher object watcher
				wt, werr := apicl.BookstoreV1().Publisher().Watch(ctx, &opts)
				if werr != nil {
					logger.Errorf("Failed to start %s watch (%s)\n", kind, werr)
					// wait for a second and retry connecting to api server
					apicl.Close()
					time.Sleep(time.Second)
					continue
				}
				ct.Lock()
				ct.watchers[kind] = wt
				ct.Unlock()

				// perform a diff with API server and local cache
				time.Sleep(time.Millisecond * 100)
				ct.diffPublisher(apicl)

				// handle api server watch events
			innerLoop:
				for {
					// wait for events
					select {
					case evt, ok := <-wt.EventChan():
						if !ok {
							logger.Error("Error receiving from apisrv watcher")
							ct.stats.Counter("Publisher_WatchErrors").Inc()
							break innerLoop
						}

						// handle event in parallel
						ct.handlePublisherEventParallel(evt)
					}
				}
				apicl.Close()
			}

			// if stop flag is set, we are done
			if ct.stoped {
				logger.Infof("Exiting API server watcher")
				return
			}

			// wait for a second and retry connecting to api server
			time.Sleep(time.Second)
		}
	}()
}

// WatchPublisher starts watch on Publisher object
func (ct *ctrlerCtx) WatchPublisher(handler PublisherHandler) error {
	kind := "Publisher"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchers[kind]
	ct.Unlock()
	if ok {
		return fmt.Errorf("Publisher watcher already exists")
	}

	// save handler
	ct.Lock()
	ct.handlers[kind] = handler
	ct.Unlock()

	// run Publisher watcher in a go routine
	ct.runPublisherWatcher()

	return nil
}

// PublisherAPI returns
type PublisherAPI interface {
	Create(obj *bookstore.Publisher) error
	Update(obj *bookstore.Publisher) error
	Delete(obj *bookstore.Publisher) error
	Find(meta *api.ObjectMeta) (*Publisher, error)
	List() []*Publisher
	Watch(handler PublisherHandler) error
}

// dummy struct that implements PublisherAPI
type publisherAPI struct {
	ct *ctrlerCtx
}

// Create creates Publisher object
func (api *publisherAPI) Create(obj *bookstore.Publisher) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.BookstoreV1().Publisher().Create(context.Background(), obj)
		if err != nil && strings.Contains(err.Error(), "AlreadyExists") {
			_, err = apicl.BookstoreV1().Publisher().Update(context.Background(), obj)
		}
		return err
	}

	return api.ct.handlePublisherEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Created})
}

// Update triggers update on Publisher object
func (api *publisherAPI) Update(obj *bookstore.Publisher) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.BookstoreV1().Publisher().Update(context.Background(), obj)
		return err
	}

	return api.ct.handlePublisherEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Updated})
}

// Delete deletes Publisher object
func (api *publisherAPI) Delete(obj *bookstore.Publisher) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.BookstoreV1().Publisher().Delete(context.Background(), &obj.ObjectMeta)
		return err
	}

	return api.ct.handlePublisherEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Deleted})
}

// Find returns an object by meta
func (api *publisherAPI) Find(meta *api.ObjectMeta) (*Publisher, error) {
	// find the object
	obj, err := api.ct.FindObject("Publisher", meta)
	if err != nil {
		return nil, err
	}

	// asset type
	switch obj.(type) {
	case *Publisher:
		hobj := obj.(*Publisher)
		return hobj, nil
	default:
		return nil, errors.New("incorrect object type")
	}
}

// List returns a list of all Publisher objects
func (api *publisherAPI) List() []*Publisher {
	var objlist []*Publisher

	objs := api.ct.ListObjects("Publisher")
	for _, obj := range objs {
		switch tp := obj.(type) {
		case *Publisher:
			eobj := obj.(*Publisher)
			objlist = append(objlist, eobj)
		default:
			log.Fatalf("Got invalid object type %v while looking for Publisher", tp)
		}
	}

	return objlist
}

// Watch sets up a event handlers for Publisher object
func (api *publisherAPI) Watch(handler PublisherHandler) error {
	api.ct.startWorkerPool("Publisher")
	return api.ct.WatchPublisher(handler)
}

// Publisher returns PublisherAPI
func (ct *ctrlerCtx) Publisher() PublisherAPI {
	return &publisherAPI{ct: ct}
}

// Store is a wrapper object that implements additional functionality
type Store struct {
	sync.Mutex
	bookstore.Store
	HandlerCtx interface{} // additional state handlers can store
	ctrler     *ctrlerCtx  // reference back to the controller instance
}

func (obj *Store) Write() error {
	// if there is no API server to connect to, we are done
	if (obj.ctrler == nil) || (obj.ctrler.resolver == nil) || obj.ctrler.apisrvURL == "" {
		return nil
	}

	apicl, err := obj.ctrler.apiClient()
	if err != nil {
		obj.ctrler.logger.Errorf("Error creating API server clent. Err: %v", err)
		return err
	}

	obj.ctrler.stats.Counter("Store_Writes").Inc()

	// write to api server
	if obj.ObjectMeta.ResourceVersion != "" {
		// update it
		for i := 0; i < maxApisrvWriteRetry; i++ {
			_, err = apicl.BookstoreV1().Store().UpdateStatus(context.Background(), &obj.Store)
			if err == nil {
				break
			}
			time.Sleep(time.Millisecond * 100)
		}
	} else {
		//  create
		_, err = apicl.BookstoreV1().Store().Create(context.Background(), &obj.Store)
	}

	return nil
}

// StoreHandler is the event handler for Store object
type StoreHandler interface {
	OnStoreCreate(obj *Store) error
	OnStoreUpdate(oldObj *Store, newObj *bookstore.Store) error
	OnStoreDelete(obj *Store) error
}

// handleStoreEvent handles Store events from watcher
func (ct *ctrlerCtx) handleStoreEvent(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *bookstore.Store:
		eobj := evt.Object.(*bookstore.Store)
		kind := "Store"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		handler, ok := ct.handlers[kind]
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		storeHandler := handler.(StoreHandler)
		// handle based on event type
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			fobj, err := ct.findObject(kind, eobj.GetKey())
			if err != nil {
				obj := &Store{
					Store:      *eobj,
					HandlerCtx: nil,
					ctrler:     ct,
				}
				ct.addObject(kind, obj.GetKey(), obj)
				ct.stats.Counter("Store_Created_Events").Inc()

				// call the event handler
				obj.Lock()
				err = storeHandler.OnStoreCreate(obj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					ct.delObject(kind, eobj.GetKey())
					return err
				}
			} else {
				obj := fobj.(*Store)

				ct.stats.Counter("Store_Updated_Events").Inc()

				// call the event handler
				obj.Lock()
				err = storeHandler.OnStoreUpdate(obj, eobj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					return err
				}
			}
		case kvstore.Deleted:
			fobj, err := ct.findObject(kind, eobj.GetKey())
			if err != nil {
				ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
				return err
			}

			obj := fobj.(*Store)

			ct.stats.Counter("Store_Deleted_Events").Inc()

			// Call the event reactor
			obj.Lock()
			err = storeHandler.OnStoreDelete(obj)
			obj.Unlock()
			if err != nil {
				ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
			}

			ct.delObject(kind, eobj.GetKey())
		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on Store watch channel", tp)
	}

	return nil
}

// handleStoreEventParallel handles Store events from watcher
func (ct *ctrlerCtx) handleStoreEventParallel(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *bookstore.Store:
		eobj := evt.Object.(*bookstore.Store)
		kind := "Store"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		handler, ok := ct.handlers[kind]
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		storeHandler := handler.(StoreHandler)
		// handle based on event type
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			workFunc := func(ctx context.Context, userCtx shardworkers.WorkObj) error {
				var err error
				eobj := userCtx.(*bookstore.Store)
				fobj, err := ct.findObject(kind, eobj.GetKey())
				if err != nil {
					obj := &Store{
						Store:      *eobj,
						HandlerCtx: nil,
						ctrler:     ct,
					}
					ct.addObject(kind, obj.GetKey(), obj)
					ct.stats.Counter("Store_Created_Events").Inc()
					obj.Lock()
					err = storeHandler.OnStoreCreate(obj)
					obj.Unlock()
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
						ct.delObject(kind, obj.Store.GetKey())
					}
				} else {
					obj := fobj.(*Store)
					ct.stats.Counter("Store_Updated_Events").Inc()
					obj.Lock()
					err = storeHandler.OnStoreUpdate(obj, eobj)
					obj.Unlock()
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					}
				}
				return err
			}
			ct.runJob("Store", eobj, workFunc)
		case kvstore.Deleted:
			workFunc := func(ctx context.Context, userCtx shardworkers.WorkObj) error {
				eobj := userCtx.(*bookstore.Store)
				fobj, err := ct.findObject(kind, eobj.GetKey())
				if err != nil {
					ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
					return err
				}
				obj := fobj.(*Store)
				ct.stats.Counter("Store_Deleted_Events").Inc()
				obj.Lock()
				err = storeHandler.OnStoreDelete(obj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
				}
				ct.delObject(kind, obj.Store.GetKey())
				return nil
			}
			ct.runJob("Store", eobj, workFunc)
		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on Store watch channel", tp)
	}

	return nil
}

// diffStore does a diff of Store objects between local cache and API server
func (ct *ctrlerCtx) diffStore(apicl apiclient.Services) {
	opts := api.ListWatchOptions{}

	// get a list of all objects from API server
	objlist, err := apicl.BookstoreV1().Store().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Errorf("Error getting a list of objects. Err: %v", err)
		return
	}

	ct.logger.Infof("diffStore(): StoreList returned %d objects", len(objlist))

	// build an object map
	objmap := make(map[string]*bookstore.Store)
	for _, obj := range objlist {
		objmap[obj.GetKey()] = obj
	}

	// if an object is in our local cache and not in API server, trigger delete for it
	for _, obj := range ct.Store().List() {
		_, ok := objmap[obj.GetKey()]
		if !ok {
			ct.logger.Infof("diffStore(): Deleting existing object %#v since its not in apiserver", obj.GetKey())
			evt := kvstore.WatchEvent{
				Type:   kvstore.Deleted,
				Key:    obj.GetKey(),
				Object: &obj.Store,
			}
			ct.handleStoreEvent(&evt)
		}
	}

	// trigger create event for all others
	for _, obj := range objlist {
		ct.logger.Infof("diffStore(): Adding object %#v", obj.GetKey())
		evt := kvstore.WatchEvent{
			Type:   kvstore.Created,
			Key:    obj.GetKey(),
			Object: obj,
		}
		ct.handleStoreEvent(&evt)
	}
}

func (ct *ctrlerCtx) runStoreWatcher() {
	kind := "Store"

	// if there is no API server to connect to, we are done
	if (ct.resolver == nil) || ct.apisrvURL == "" {
		return
	}

	// create context
	ctx, cancel := context.WithCancel(context.Background())
	ct.Lock()
	ct.watchCancel[kind] = cancel
	ct.Unlock()
	opts := api.ListWatchOptions{}
	logger := ct.logger.WithContext("submodule", "StoreWatcher")

	// create a grpc client
	apiclt, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
	if err == nil {
		ct.diffStore(apiclt)
	}

	// setup wait group
	ct.waitGrp.Add(1)

	// start a goroutine
	go func() {
		defer ct.waitGrp.Done()
		ct.stats.Counter("Store_Watch").Inc()
		defer ct.stats.Counter("Store_Watch").Dec()

		// loop forever
		for {
			// create a grpc client
			apicl, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
			if err != nil {
				logger.Warnf("Failed to connect to gRPC server [%s]\n", ct.apisrvURL)
				ct.stats.Counter("Store_ApiClientErr").Inc()
			} else {
				logger.Infof("API client connected {%+v}", apicl)

				// Store object watcher
				wt, werr := apicl.BookstoreV1().Store().Watch(ctx, &opts)
				if werr != nil {
					logger.Errorf("Failed to start %s watch (%s)\n", kind, werr)
					// wait for a second and retry connecting to api server
					apicl.Close()
					time.Sleep(time.Second)
					continue
				}
				ct.Lock()
				ct.watchers[kind] = wt
				ct.Unlock()

				// perform a diff with API server and local cache
				time.Sleep(time.Millisecond * 100)
				ct.diffStore(apicl)

				// handle api server watch events
			innerLoop:
				for {
					// wait for events
					select {
					case evt, ok := <-wt.EventChan():
						if !ok {
							logger.Error("Error receiving from apisrv watcher")
							ct.stats.Counter("Store_WatchErrors").Inc()
							break innerLoop
						}

						// handle event in parallel
						ct.handleStoreEventParallel(evt)
					}
				}
				apicl.Close()
			}

			// if stop flag is set, we are done
			if ct.stoped {
				logger.Infof("Exiting API server watcher")
				return
			}

			// wait for a second and retry connecting to api server
			time.Sleep(time.Second)
		}
	}()
}

// WatchStore starts watch on Store object
func (ct *ctrlerCtx) WatchStore(handler StoreHandler) error {
	kind := "Store"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchers[kind]
	ct.Unlock()
	if ok {
		return fmt.Errorf("Store watcher already exists")
	}

	// save handler
	ct.Lock()
	ct.handlers[kind] = handler
	ct.Unlock()

	// run Store watcher in a go routine
	ct.runStoreWatcher()

	return nil
}

// StoreAPI returns
type StoreAPI interface {
	Create(obj *bookstore.Store) error
	Update(obj *bookstore.Store) error
	Delete(obj *bookstore.Store) error
	Find(meta *api.ObjectMeta) (*Store, error)
	List() []*Store
	Watch(handler StoreHandler) error
}

// dummy struct that implements StoreAPI
type storeAPI struct {
	ct *ctrlerCtx
}

// Create creates Store object
func (api *storeAPI) Create(obj *bookstore.Store) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.BookstoreV1().Store().Create(context.Background(), obj)
		if err != nil && strings.Contains(err.Error(), "AlreadyExists") {
			_, err = apicl.BookstoreV1().Store().Update(context.Background(), obj)
		}
		return err
	}

	return api.ct.handleStoreEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Created})
}

// Update triggers update on Store object
func (api *storeAPI) Update(obj *bookstore.Store) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.BookstoreV1().Store().Update(context.Background(), obj)
		return err
	}

	return api.ct.handleStoreEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Updated})
}

// Delete deletes Store object
func (api *storeAPI) Delete(obj *bookstore.Store) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.BookstoreV1().Store().Delete(context.Background(), &obj.ObjectMeta)
		return err
	}

	return api.ct.handleStoreEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Deleted})
}

// Find returns an object by meta
func (api *storeAPI) Find(meta *api.ObjectMeta) (*Store, error) {
	// find the object
	obj, err := api.ct.FindObject("Store", meta)
	if err != nil {
		return nil, err
	}

	// asset type
	switch obj.(type) {
	case *Store:
		hobj := obj.(*Store)
		return hobj, nil
	default:
		return nil, errors.New("incorrect object type")
	}
}

// List returns a list of all Store objects
func (api *storeAPI) List() []*Store {
	var objlist []*Store

	objs := api.ct.ListObjects("Store")
	for _, obj := range objs {
		switch tp := obj.(type) {
		case *Store:
			eobj := obj.(*Store)
			objlist = append(objlist, eobj)
		default:
			log.Fatalf("Got invalid object type %v while looking for Store", tp)
		}
	}

	return objlist
}

// Watch sets up a event handlers for Store object
func (api *storeAPI) Watch(handler StoreHandler) error {
	api.ct.startWorkerPool("Store")
	return api.ct.WatchStore(handler)
}

// Store returns StoreAPI
func (ct *ctrlerCtx) Store() StoreAPI {
	return &storeAPI{ct: ct}
}

// Coupon is a wrapper object that implements additional functionality
type Coupon struct {
	sync.Mutex
	bookstore.Coupon
	HandlerCtx interface{} // additional state handlers can store
	ctrler     *ctrlerCtx  // reference back to the controller instance
}

func (obj *Coupon) Write() error {
	// if there is no API server to connect to, we are done
	if (obj.ctrler == nil) || (obj.ctrler.resolver == nil) || obj.ctrler.apisrvURL == "" {
		return nil
	}

	apicl, err := obj.ctrler.apiClient()
	if err != nil {
		obj.ctrler.logger.Errorf("Error creating API server clent. Err: %v", err)
		return err
	}

	obj.ctrler.stats.Counter("Coupon_Writes").Inc()

	// write to api server
	if obj.ObjectMeta.ResourceVersion != "" {
		// update it
		for i := 0; i < maxApisrvWriteRetry; i++ {
			_, err = apicl.BookstoreV1().Coupon().UpdateStatus(context.Background(), &obj.Coupon)
			if err == nil {
				break
			}
			time.Sleep(time.Millisecond * 100)
		}
	} else {
		//  create
		_, err = apicl.BookstoreV1().Coupon().Create(context.Background(), &obj.Coupon)
	}

	return nil
}

// CouponHandler is the event handler for Coupon object
type CouponHandler interface {
	OnCouponCreate(obj *Coupon) error
	OnCouponUpdate(oldObj *Coupon, newObj *bookstore.Coupon) error
	OnCouponDelete(obj *Coupon) error
}

// handleCouponEvent handles Coupon events from watcher
func (ct *ctrlerCtx) handleCouponEvent(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *bookstore.Coupon:
		eobj := evt.Object.(*bookstore.Coupon)
		kind := "Coupon"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		handler, ok := ct.handlers[kind]
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		couponHandler := handler.(CouponHandler)
		// handle based on event type
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			fobj, err := ct.findObject(kind, eobj.GetKey())
			if err != nil {
				obj := &Coupon{
					Coupon:     *eobj,
					HandlerCtx: nil,
					ctrler:     ct,
				}
				ct.addObject(kind, obj.GetKey(), obj)
				ct.stats.Counter("Coupon_Created_Events").Inc()

				// call the event handler
				obj.Lock()
				err = couponHandler.OnCouponCreate(obj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					ct.delObject(kind, eobj.GetKey())
					return err
				}
			} else {
				obj := fobj.(*Coupon)

				ct.stats.Counter("Coupon_Updated_Events").Inc()

				// call the event handler
				obj.Lock()
				err = couponHandler.OnCouponUpdate(obj, eobj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					return err
				}
			}
		case kvstore.Deleted:
			fobj, err := ct.findObject(kind, eobj.GetKey())
			if err != nil {
				ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
				return err
			}

			obj := fobj.(*Coupon)

			ct.stats.Counter("Coupon_Deleted_Events").Inc()

			// Call the event reactor
			obj.Lock()
			err = couponHandler.OnCouponDelete(obj)
			obj.Unlock()
			if err != nil {
				ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
			}

			ct.delObject(kind, eobj.GetKey())
		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on Coupon watch channel", tp)
	}

	return nil
}

// handleCouponEventParallel handles Coupon events from watcher
func (ct *ctrlerCtx) handleCouponEventParallel(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *bookstore.Coupon:
		eobj := evt.Object.(*bookstore.Coupon)
		kind := "Coupon"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		handler, ok := ct.handlers[kind]
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		couponHandler := handler.(CouponHandler)
		// handle based on event type
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			workFunc := func(ctx context.Context, userCtx shardworkers.WorkObj) error {
				var err error
				eobj := userCtx.(*bookstore.Coupon)
				fobj, err := ct.findObject(kind, eobj.GetKey())
				if err != nil {
					obj := &Coupon{
						Coupon:     *eobj,
						HandlerCtx: nil,
						ctrler:     ct,
					}
					ct.addObject(kind, obj.GetKey(), obj)
					ct.stats.Counter("Coupon_Created_Events").Inc()
					obj.Lock()
					err = couponHandler.OnCouponCreate(obj)
					obj.Unlock()
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
						ct.delObject(kind, obj.Coupon.GetKey())
					}
				} else {
					obj := fobj.(*Coupon)
					ct.stats.Counter("Coupon_Updated_Events").Inc()
					obj.Lock()
					err = couponHandler.OnCouponUpdate(obj, eobj)
					obj.Unlock()
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					}
				}
				return err
			}
			ct.runJob("Coupon", eobj, workFunc)
		case kvstore.Deleted:
			workFunc := func(ctx context.Context, userCtx shardworkers.WorkObj) error {
				eobj := userCtx.(*bookstore.Coupon)
				fobj, err := ct.findObject(kind, eobj.GetKey())
				if err != nil {
					ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
					return err
				}
				obj := fobj.(*Coupon)
				ct.stats.Counter("Coupon_Deleted_Events").Inc()
				obj.Lock()
				err = couponHandler.OnCouponDelete(obj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
				}
				ct.delObject(kind, obj.Coupon.GetKey())
				return nil
			}
			ct.runJob("Coupon", eobj, workFunc)
		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on Coupon watch channel", tp)
	}

	return nil
}

// diffCoupon does a diff of Coupon objects between local cache and API server
func (ct *ctrlerCtx) diffCoupon(apicl apiclient.Services) {
	opts := api.ListWatchOptions{}

	// get a list of all objects from API server
	objlist, err := apicl.BookstoreV1().Coupon().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Errorf("Error getting a list of objects. Err: %v", err)
		return
	}

	ct.logger.Infof("diffCoupon(): CouponList returned %d objects", len(objlist))

	// build an object map
	objmap := make(map[string]*bookstore.Coupon)
	for _, obj := range objlist {
		objmap[obj.GetKey()] = obj
	}

	// if an object is in our local cache and not in API server, trigger delete for it
	for _, obj := range ct.Coupon().List() {
		_, ok := objmap[obj.GetKey()]
		if !ok {
			ct.logger.Infof("diffCoupon(): Deleting existing object %#v since its not in apiserver", obj.GetKey())
			evt := kvstore.WatchEvent{
				Type:   kvstore.Deleted,
				Key:    obj.GetKey(),
				Object: &obj.Coupon,
			}
			ct.handleCouponEvent(&evt)
		}
	}

	// trigger create event for all others
	for _, obj := range objlist {
		ct.logger.Infof("diffCoupon(): Adding object %#v", obj.GetKey())
		evt := kvstore.WatchEvent{
			Type:   kvstore.Created,
			Key:    obj.GetKey(),
			Object: obj,
		}
		ct.handleCouponEvent(&evt)
	}
}

func (ct *ctrlerCtx) runCouponWatcher() {
	kind := "Coupon"

	// if there is no API server to connect to, we are done
	if (ct.resolver == nil) || ct.apisrvURL == "" {
		return
	}

	// create context
	ctx, cancel := context.WithCancel(context.Background())
	ct.Lock()
	ct.watchCancel[kind] = cancel
	ct.Unlock()
	opts := api.ListWatchOptions{}
	logger := ct.logger.WithContext("submodule", "CouponWatcher")

	// create a grpc client
	apiclt, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
	if err == nil {
		ct.diffCoupon(apiclt)
	}

	// setup wait group
	ct.waitGrp.Add(1)

	// start a goroutine
	go func() {
		defer ct.waitGrp.Done()
		ct.stats.Counter("Coupon_Watch").Inc()
		defer ct.stats.Counter("Coupon_Watch").Dec()

		// loop forever
		for {
			// create a grpc client
			apicl, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
			if err != nil {
				logger.Warnf("Failed to connect to gRPC server [%s]\n", ct.apisrvURL)
				ct.stats.Counter("Coupon_ApiClientErr").Inc()
			} else {
				logger.Infof("API client connected {%+v}", apicl)

				// Coupon object watcher
				wt, werr := apicl.BookstoreV1().Coupon().Watch(ctx, &opts)
				if werr != nil {
					logger.Errorf("Failed to start %s watch (%s)\n", kind, werr)
					// wait for a second and retry connecting to api server
					apicl.Close()
					time.Sleep(time.Second)
					continue
				}
				ct.Lock()
				ct.watchers[kind] = wt
				ct.Unlock()

				// perform a diff with API server and local cache
				time.Sleep(time.Millisecond * 100)
				ct.diffCoupon(apicl)

				// handle api server watch events
			innerLoop:
				for {
					// wait for events
					select {
					case evt, ok := <-wt.EventChan():
						if !ok {
							logger.Error("Error receiving from apisrv watcher")
							ct.stats.Counter("Coupon_WatchErrors").Inc()
							break innerLoop
						}

						// handle event in parallel
						ct.handleCouponEventParallel(evt)
					}
				}
				apicl.Close()
			}

			// if stop flag is set, we are done
			if ct.stoped {
				logger.Infof("Exiting API server watcher")
				return
			}

			// wait for a second and retry connecting to api server
			time.Sleep(time.Second)
		}
	}()
}

// WatchCoupon starts watch on Coupon object
func (ct *ctrlerCtx) WatchCoupon(handler CouponHandler) error {
	kind := "Coupon"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchers[kind]
	ct.Unlock()
	if ok {
		return fmt.Errorf("Coupon watcher already exists")
	}

	// save handler
	ct.Lock()
	ct.handlers[kind] = handler
	ct.Unlock()

	// run Coupon watcher in a go routine
	ct.runCouponWatcher()

	return nil
}

// CouponAPI returns
type CouponAPI interface {
	Create(obj *bookstore.Coupon) error
	Update(obj *bookstore.Coupon) error
	Delete(obj *bookstore.Coupon) error
	Find(meta *api.ObjectMeta) (*Coupon, error)
	List() []*Coupon
	Watch(handler CouponHandler) error
}

// dummy struct that implements CouponAPI
type couponAPI struct {
	ct *ctrlerCtx
}

// Create creates Coupon object
func (api *couponAPI) Create(obj *bookstore.Coupon) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.BookstoreV1().Coupon().Create(context.Background(), obj)
		if err != nil && strings.Contains(err.Error(), "AlreadyExists") {
			_, err = apicl.BookstoreV1().Coupon().Update(context.Background(), obj)
		}
		return err
	}

	return api.ct.handleCouponEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Created})
}

// Update triggers update on Coupon object
func (api *couponAPI) Update(obj *bookstore.Coupon) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.BookstoreV1().Coupon().Update(context.Background(), obj)
		return err
	}

	return api.ct.handleCouponEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Updated})
}

// Delete deletes Coupon object
func (api *couponAPI) Delete(obj *bookstore.Coupon) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.BookstoreV1().Coupon().Delete(context.Background(), &obj.ObjectMeta)
		return err
	}

	return api.ct.handleCouponEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Deleted})
}

// Find returns an object by meta
func (api *couponAPI) Find(meta *api.ObjectMeta) (*Coupon, error) {
	// find the object
	obj, err := api.ct.FindObject("Coupon", meta)
	if err != nil {
		return nil, err
	}

	// asset type
	switch obj.(type) {
	case *Coupon:
		hobj := obj.(*Coupon)
		return hobj, nil
	default:
		return nil, errors.New("incorrect object type")
	}
}

// List returns a list of all Coupon objects
func (api *couponAPI) List() []*Coupon {
	var objlist []*Coupon

	objs := api.ct.ListObjects("Coupon")
	for _, obj := range objs {
		switch tp := obj.(type) {
		case *Coupon:
			eobj := obj.(*Coupon)
			objlist = append(objlist, eobj)
		default:
			log.Fatalf("Got invalid object type %v while looking for Coupon", tp)
		}
	}

	return objlist
}

// Watch sets up a event handlers for Coupon object
func (api *couponAPI) Watch(handler CouponHandler) error {
	api.ct.startWorkerPool("Coupon")
	return api.ct.WatchCoupon(handler)
}

// Coupon returns CouponAPI
func (ct *ctrlerCtx) Coupon() CouponAPI {
	return &couponAPI{ct: ct}
}

// Customer is a wrapper object that implements additional functionality
type Customer struct {
	sync.Mutex
	bookstore.Customer
	HandlerCtx interface{} // additional state handlers can store
	ctrler     *ctrlerCtx  // reference back to the controller instance
}

func (obj *Customer) Write() error {
	// if there is no API server to connect to, we are done
	if (obj.ctrler == nil) || (obj.ctrler.resolver == nil) || obj.ctrler.apisrvURL == "" {
		return nil
	}

	apicl, err := obj.ctrler.apiClient()
	if err != nil {
		obj.ctrler.logger.Errorf("Error creating API server clent. Err: %v", err)
		return err
	}

	obj.ctrler.stats.Counter("Customer_Writes").Inc()

	// write to api server
	if obj.ObjectMeta.ResourceVersion != "" {
		// update it
		for i := 0; i < maxApisrvWriteRetry; i++ {
			_, err = apicl.BookstoreV1().Customer().UpdateStatus(context.Background(), &obj.Customer)
			if err == nil {
				break
			}
			time.Sleep(time.Millisecond * 100)
		}
	} else {
		//  create
		_, err = apicl.BookstoreV1().Customer().Create(context.Background(), &obj.Customer)
	}

	return nil
}

// CustomerHandler is the event handler for Customer object
type CustomerHandler interface {
	OnCustomerCreate(obj *Customer) error
	OnCustomerUpdate(oldObj *Customer, newObj *bookstore.Customer) error
	OnCustomerDelete(obj *Customer) error
}

// handleCustomerEvent handles Customer events from watcher
func (ct *ctrlerCtx) handleCustomerEvent(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *bookstore.Customer:
		eobj := evt.Object.(*bookstore.Customer)
		kind := "Customer"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		handler, ok := ct.handlers[kind]
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		customerHandler := handler.(CustomerHandler)
		// handle based on event type
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			fobj, err := ct.findObject(kind, eobj.GetKey())
			if err != nil {
				obj := &Customer{
					Customer:   *eobj,
					HandlerCtx: nil,
					ctrler:     ct,
				}
				ct.addObject(kind, obj.GetKey(), obj)
				ct.stats.Counter("Customer_Created_Events").Inc()

				// call the event handler
				obj.Lock()
				err = customerHandler.OnCustomerCreate(obj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					ct.delObject(kind, eobj.GetKey())
					return err
				}
			} else {
				obj := fobj.(*Customer)

				ct.stats.Counter("Customer_Updated_Events").Inc()

				// call the event handler
				obj.Lock()
				err = customerHandler.OnCustomerUpdate(obj, eobj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					return err
				}
			}
		case kvstore.Deleted:
			fobj, err := ct.findObject(kind, eobj.GetKey())
			if err != nil {
				ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
				return err
			}

			obj := fobj.(*Customer)

			ct.stats.Counter("Customer_Deleted_Events").Inc()

			// Call the event reactor
			obj.Lock()
			err = customerHandler.OnCustomerDelete(obj)
			obj.Unlock()
			if err != nil {
				ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
			}

			ct.delObject(kind, eobj.GetKey())
		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on Customer watch channel", tp)
	}

	return nil
}

// handleCustomerEventParallel handles Customer events from watcher
func (ct *ctrlerCtx) handleCustomerEventParallel(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *bookstore.Customer:
		eobj := evt.Object.(*bookstore.Customer)
		kind := "Customer"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		handler, ok := ct.handlers[kind]
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		customerHandler := handler.(CustomerHandler)
		// handle based on event type
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			workFunc := func(ctx context.Context, userCtx shardworkers.WorkObj) error {
				var err error
				eobj := userCtx.(*bookstore.Customer)
				fobj, err := ct.findObject(kind, eobj.GetKey())
				if err != nil {
					obj := &Customer{
						Customer:   *eobj,
						HandlerCtx: nil,
						ctrler:     ct,
					}
					ct.addObject(kind, obj.GetKey(), obj)
					ct.stats.Counter("Customer_Created_Events").Inc()
					obj.Lock()
					err = customerHandler.OnCustomerCreate(obj)
					obj.Unlock()
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
						ct.delObject(kind, obj.Customer.GetKey())
					}
				} else {
					obj := fobj.(*Customer)
					ct.stats.Counter("Customer_Updated_Events").Inc()
					obj.Lock()
					err = customerHandler.OnCustomerUpdate(obj, eobj)
					obj.Unlock()
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					}
				}
				return err
			}
			ct.runJob("Customer", eobj, workFunc)
		case kvstore.Deleted:
			workFunc := func(ctx context.Context, userCtx shardworkers.WorkObj) error {
				eobj := userCtx.(*bookstore.Customer)
				fobj, err := ct.findObject(kind, eobj.GetKey())
				if err != nil {
					ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
					return err
				}
				obj := fobj.(*Customer)
				ct.stats.Counter("Customer_Deleted_Events").Inc()
				obj.Lock()
				err = customerHandler.OnCustomerDelete(obj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
				}
				ct.delObject(kind, obj.Customer.GetKey())
				return nil
			}
			ct.runJob("Customer", eobj, workFunc)
		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on Customer watch channel", tp)
	}

	return nil
}

// diffCustomer does a diff of Customer objects between local cache and API server
func (ct *ctrlerCtx) diffCustomer(apicl apiclient.Services) {
	opts := api.ListWatchOptions{}

	// get a list of all objects from API server
	objlist, err := apicl.BookstoreV1().Customer().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Errorf("Error getting a list of objects. Err: %v", err)
		return
	}

	ct.logger.Infof("diffCustomer(): CustomerList returned %d objects", len(objlist))

	// build an object map
	objmap := make(map[string]*bookstore.Customer)
	for _, obj := range objlist {
		objmap[obj.GetKey()] = obj
	}

	// if an object is in our local cache and not in API server, trigger delete for it
	for _, obj := range ct.Customer().List() {
		_, ok := objmap[obj.GetKey()]
		if !ok {
			ct.logger.Infof("diffCustomer(): Deleting existing object %#v since its not in apiserver", obj.GetKey())
			evt := kvstore.WatchEvent{
				Type:   kvstore.Deleted,
				Key:    obj.GetKey(),
				Object: &obj.Customer,
			}
			ct.handleCustomerEvent(&evt)
		}
	}

	// trigger create event for all others
	for _, obj := range objlist {
		ct.logger.Infof("diffCustomer(): Adding object %#v", obj.GetKey())
		evt := kvstore.WatchEvent{
			Type:   kvstore.Created,
			Key:    obj.GetKey(),
			Object: obj,
		}
		ct.handleCustomerEvent(&evt)
	}
}

func (ct *ctrlerCtx) runCustomerWatcher() {
	kind := "Customer"

	// if there is no API server to connect to, we are done
	if (ct.resolver == nil) || ct.apisrvURL == "" {
		return
	}

	// create context
	ctx, cancel := context.WithCancel(context.Background())
	ct.Lock()
	ct.watchCancel[kind] = cancel
	ct.Unlock()
	opts := api.ListWatchOptions{}
	logger := ct.logger.WithContext("submodule", "CustomerWatcher")

	// create a grpc client
	apiclt, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
	if err == nil {
		ct.diffCustomer(apiclt)
	}

	// setup wait group
	ct.waitGrp.Add(1)

	// start a goroutine
	go func() {
		defer ct.waitGrp.Done()
		ct.stats.Counter("Customer_Watch").Inc()
		defer ct.stats.Counter("Customer_Watch").Dec()

		// loop forever
		for {
			// create a grpc client
			apicl, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
			if err != nil {
				logger.Warnf("Failed to connect to gRPC server [%s]\n", ct.apisrvURL)
				ct.stats.Counter("Customer_ApiClientErr").Inc()
			} else {
				logger.Infof("API client connected {%+v}", apicl)

				// Customer object watcher
				wt, werr := apicl.BookstoreV1().Customer().Watch(ctx, &opts)
				if werr != nil {
					logger.Errorf("Failed to start %s watch (%s)\n", kind, werr)
					// wait for a second and retry connecting to api server
					apicl.Close()
					time.Sleep(time.Second)
					continue
				}
				ct.Lock()
				ct.watchers[kind] = wt
				ct.Unlock()

				// perform a diff with API server and local cache
				time.Sleep(time.Millisecond * 100)
				ct.diffCustomer(apicl)

				// handle api server watch events
			innerLoop:
				for {
					// wait for events
					select {
					case evt, ok := <-wt.EventChan():
						if !ok {
							logger.Error("Error receiving from apisrv watcher")
							ct.stats.Counter("Customer_WatchErrors").Inc()
							break innerLoop
						}

						// handle event in parallel
						ct.handleCustomerEventParallel(evt)
					}
				}
				apicl.Close()
			}

			// if stop flag is set, we are done
			if ct.stoped {
				logger.Infof("Exiting API server watcher")
				return
			}

			// wait for a second and retry connecting to api server
			time.Sleep(time.Second)
		}
	}()
}

// WatchCustomer starts watch on Customer object
func (ct *ctrlerCtx) WatchCustomer(handler CustomerHandler) error {
	kind := "Customer"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchers[kind]
	ct.Unlock()
	if ok {
		return fmt.Errorf("Customer watcher already exists")
	}

	// save handler
	ct.Lock()
	ct.handlers[kind] = handler
	ct.Unlock()

	// run Customer watcher in a go routine
	ct.runCustomerWatcher()

	return nil
}

// CustomerAPI returns
type CustomerAPI interface {
	Create(obj *bookstore.Customer) error
	Update(obj *bookstore.Customer) error
	Delete(obj *bookstore.Customer) error
	Find(meta *api.ObjectMeta) (*Customer, error)
	List() []*Customer
	Watch(handler CustomerHandler) error
}

// dummy struct that implements CustomerAPI
type customerAPI struct {
	ct *ctrlerCtx
}

// Create creates Customer object
func (api *customerAPI) Create(obj *bookstore.Customer) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.BookstoreV1().Customer().Create(context.Background(), obj)
		if err != nil && strings.Contains(err.Error(), "AlreadyExists") {
			_, err = apicl.BookstoreV1().Customer().Update(context.Background(), obj)
		}
		return err
	}

	return api.ct.handleCustomerEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Created})
}

// Update triggers update on Customer object
func (api *customerAPI) Update(obj *bookstore.Customer) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.BookstoreV1().Customer().Update(context.Background(), obj)
		return err
	}

	return api.ct.handleCustomerEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Updated})
}

// Delete deletes Customer object
func (api *customerAPI) Delete(obj *bookstore.Customer) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.BookstoreV1().Customer().Delete(context.Background(), &obj.ObjectMeta)
		return err
	}

	return api.ct.handleCustomerEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Deleted})
}

// Find returns an object by meta
func (api *customerAPI) Find(meta *api.ObjectMeta) (*Customer, error) {
	// find the object
	obj, err := api.ct.FindObject("Customer", meta)
	if err != nil {
		return nil, err
	}

	// asset type
	switch obj.(type) {
	case *Customer:
		hobj := obj.(*Customer)
		return hobj, nil
	default:
		return nil, errors.New("incorrect object type")
	}
}

// List returns a list of all Customer objects
func (api *customerAPI) List() []*Customer {
	var objlist []*Customer

	objs := api.ct.ListObjects("Customer")
	for _, obj := range objs {
		switch tp := obj.(type) {
		case *Customer:
			eobj := obj.(*Customer)
			objlist = append(objlist, eobj)
		default:
			log.Fatalf("Got invalid object type %v while looking for Customer", tp)
		}
	}

	return objlist
}

// Watch sets up a event handlers for Customer object
func (api *customerAPI) Watch(handler CustomerHandler) error {
	api.ct.startWorkerPool("Customer")
	return api.ct.WatchCustomer(handler)
}

// Customer returns CustomerAPI
func (ct *ctrlerCtx) Customer() CustomerAPI {
	return &customerAPI{ct: ct}
}
