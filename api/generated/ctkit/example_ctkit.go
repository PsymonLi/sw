// Code generated by protoc-gen-grpc-pensando DO NOT EDIT.

/*
Package ctkit is a auto generated package.
Input file: example.proto
*/
package ctkit

import (
	"context"
	"fmt"
	"sync"
	"time"

	"github.com/pensando/sw/api"
	"github.com/pensando/sw/api/generated/apiclient"
	"github.com/pensando/sw/api/generated/bookstore"
	"github.com/pensando/sw/venice/utils/kvstore"
	"github.com/pensando/sw/venice/utils/log"
	"github.com/pensando/sw/venice/utils/ref"
	"github.com/pensando/sw/venice/utils/rpckit"
)

// Order is a wrapper object that implements additional functionality
type Order struct {
	sync.Mutex
	bookstore.Order
	HandlerCtx interface{} // additional state handlers can store
	ctrler     *ctrlerCtx  // reference back to the controller instance
}

func (obj *Order) Write() error {
	// if there is no API server to connect to, we are done
	if (obj.ctrler == nil) || (obj.ctrler.resolver == nil) || obj.ctrler.apisrvURL == "" {
		return nil
	}

	apicl, err := obj.ctrler.apiClient()
	if err != nil {
		log.Errorf("Error creating API server clent. Err: %v", err)
		return err
	}

	// write to api server
	if obj.ObjectMeta.ResourceVersion != "" {
		nobj := *obj
		// FIXME: clear the resource version till we figure out CAS semantics
		nobj.ObjectMeta.ResourceVersion = ""

		// update it
		_, err = apicl.BookstoreV1().Order().Update(context.Background(), &nobj.Order)
	} else {
		//  create
		_, err = apicl.BookstoreV1().Order().Create(context.Background(), &obj.Order)
	}

	return nil
}

// OrderHandler is the event handler for Order object
type OrderHandler interface {
	OnOrderCreate(obj *Order) error
	OnOrderUpdate(obj *Order) error
	OnOrderDelete(obj *Order) error
}

// handleOrderEvent handles Order events from watcher
func (ct *ctrlerCtx) handleOrderEvent(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *bookstore.Order:
		eobj := evt.Object.(*bookstore.Order)
		kind := "Order"

		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		handler, ok := ct.handlers[kind]
		if !ok {
			log.Fatalf("Cant find the handler for %s", kind)
		}
		orderHandler := handler.(OrderHandler)
		// handle based on event type
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			fobj, err := ct.findObject(kind, eobj.GetKey())
			if err != nil {
				obj := &Order{
					Order:      *eobj,
					HandlerCtx: nil,
					ctrler:     ct,
				}
				ct.addObject(kind, obj.GetKey(), obj)
				// call the event handler
				obj.Lock()
				err = orderHandler.OnOrderCreate(obj)
				obj.Unlock()
				if err != nil {
					log.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					ct.delObject(kind, eobj.GetKey())
					return err
				}
			} else {
				obj := fobj.(*Order)
				obj.ObjectMeta = eobj.ObjectMeta

				// see if it changed
				if _, ok := ref.ObjDiff(obj.Spec, eobj.Spec); ok {
					obj.Spec = eobj.Spec
					// call the event handler
					obj.Lock()
					err = orderHandler.OnOrderUpdate(obj)
					obj.Unlock()
					if err != nil {
						log.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
						return err
					}
				}
			}
		case kvstore.Deleted:
			fobj, err := ct.findObject(kind, eobj.GetKey())
			if err != nil {
				log.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
				return err
			}

			obj := fobj.(*Order)

			// Call the event reactor
			obj.Lock()
			err = orderHandler.OnOrderDelete(obj)
			obj.Unlock()
			if err != nil {
				log.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
				return err
			}

			ct.delObject(kind, eobj.GetKey())
		}
	default:
		log.Fatalf("API watcher Found object of invalid type: %v on Order watch channel", tp)
	}

	return nil
}

// diffOrder does a diff of Order objects between local cache and API server
func (ct *ctrlerCtx) diffOrder(apicl apiclient.Services) {
	opts := api.ListWatchOptions{}

	// get a list of all objects from API server
	objlist, err := apicl.BookstoreV1().Order().List(context.Background(), &opts)
	if err != nil {
		log.Errorf("Error getting a list of objects. Err: %v", err)
		return
	}

	// build an object map
	objmap := make(map[string]*bookstore.Order)
	for _, obj := range objlist {
		objmap[obj.GetKey()] = obj
	}

	// if an object is in our local cache and not in API server, trigger delete for it
	for _, obj := range ct.Order().List() {
		_, ok := objmap[obj.GetKey()]
		if !ok {
			evt := kvstore.WatchEvent{
				Type:   kvstore.Deleted,
				Key:    obj.GetKey(),
				Object: &obj.Order,
			}
			ct.handleOrderEvent(&evt)
		}
	}

	// trigger create event for all others
	for _, obj := range objlist {
		evt := kvstore.WatchEvent{
			Type:   kvstore.Created,
			Key:    obj.GetKey(),
			Object: obj,
		}
		ct.handleOrderEvent(&evt)
	}
}

func (ct *ctrlerCtx) runOrderWatcher() {
	kind := "Order"

	// if there is no API server to connect to, we are done
	if (ct.resolver == nil) || ct.apisrvURL == "" {
		return
	}

	// create context
	ctx, cancel := context.WithCancel(context.Background())
	ct.Lock()
	ct.watchCancel[kind] = cancel
	ct.Unlock()
	opts := api.ListWatchOptions{}

	// setup wait group
	ct.waitGrp.Add(1)
	defer ct.waitGrp.Done()

	// loop forever
	for {
		// create a grpc client
		apicl, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, ct.logger, rpckit.WithBalancer(ct.balancer))
		if err != nil {
			log.Warnf("Failed to connect to gRPC server [%s]\n", ct.apisrvURL)
		} else {
			log.Infof("API client connected {%+v}", apicl)

			// Order object watcher
			wt, werr := apicl.BookstoreV1().Order().Watch(ctx, &opts)
			if werr != nil {
				log.Errorf("Failed to start %s watch (%s)\n", kind, werr)
				return
			}
			ct.Lock()
			ct.watchers[kind] = wt
			ct.Unlock()

			// perform a diff with API server and local cache
			time.Sleep(time.Millisecond * 100)
			ct.diffOrder(apicl)

			// handle api server watch events
		innerLoop:
			for {
				// wait for events
				select {
				case evt, ok := <-wt.EventChan():
					if !ok {
						log.Error("Error receiving from apisrv watcher")
						break innerLoop
					}

					// handle event
					ct.handleOrderEvent(evt)
				}
			}
			apicl.Close()
		}

		// if stop flag is set, we are done
		if ct.stoped {
			log.Infof("Exiting API server watcher")
			return
		}

		// wait for a second and retry connecting to api server
		time.Sleep(time.Second)
	}
}

// WatchOrder starts watch on Order object
func (ct *ctrlerCtx) WatchOrder(handler OrderHandler) error {
	kind := "Order"

	ct.Lock()
	defer ct.Unlock()

	// see if we already have a watcher
	_, ok := ct.watchers[kind]
	if ok {
		return fmt.Errorf("Order watcher already exists")
	}

	// save handler
	ct.handlers[kind] = handler

	// run Order watcher in a go routine
	go ct.runOrderWatcher()

	return nil
}

// OrderAPI returns
type OrderAPI interface {
	Create(obj *bookstore.Order) error
	Update(obj *bookstore.Order) error
	Delete(obj *bookstore.Order) error
	List() []*Order
	Watch(handler OrderHandler) error
}

// dummy struct that implements OrderAPI
type orderAPI struct {
	ct *ctrlerCtx
}

// Create creates Order object
func (api *orderAPI) Create(obj *bookstore.Order) error {
	return api.ct.handleOrderEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Created})
}

// Update triggers update on Order object
func (api *orderAPI) Update(obj *bookstore.Order) error {
	return api.ct.handleOrderEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Updated})
}

// Delete deletes Order object
func (api *orderAPI) Delete(obj *bookstore.Order) error {
	return api.ct.handleOrderEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Deleted})
}

// List returns a list of all Order objects
func (api *orderAPI) List() []*Order {
	var objlist []*Order

	objs := api.ct.ListObjects("Order")
	for _, obj := range objs {
		switch tp := obj.(type) {
		case *Order:
			eobj := obj.(*Order)
			objlist = append(objlist, eobj)
		default:
			log.Fatalf("Got invalid object type %v while looking for Order", tp)
		}
	}

	return objlist
}

// Watch sets up a event handlers for Order object
func (api *orderAPI) Watch(handler OrderHandler) error {
	return api.ct.WatchOrder(handler)
}

// Order returns OrderAPI
func (ct *ctrlerCtx) Order() OrderAPI {
	return &orderAPI{ct: ct}
}

// Book is a wrapper object that implements additional functionality
type Book struct {
	sync.Mutex
	bookstore.Book
	HandlerCtx interface{} // additional state handlers can store
	ctrler     *ctrlerCtx  // reference back to the controller instance
}

func (obj *Book) Write() error {
	// if there is no API server to connect to, we are done
	if (obj.ctrler == nil) || (obj.ctrler.resolver == nil) || obj.ctrler.apisrvURL == "" {
		return nil
	}

	apicl, err := obj.ctrler.apiClient()
	if err != nil {
		log.Errorf("Error creating API server clent. Err: %v", err)
		return err
	}

	// write to api server
	if obj.ObjectMeta.ResourceVersion != "" {
		nobj := *obj
		// FIXME: clear the resource version till we figure out CAS semantics
		nobj.ObjectMeta.ResourceVersion = ""

		// update it
		_, err = apicl.BookstoreV1().Book().Update(context.Background(), &nobj.Book)
	} else {
		//  create
		_, err = apicl.BookstoreV1().Book().Create(context.Background(), &obj.Book)
	}

	return nil
}

// BookHandler is the event handler for Book object
type BookHandler interface {
	OnBookCreate(obj *Book) error
	OnBookUpdate(obj *Book) error
	OnBookDelete(obj *Book) error
}

// handleBookEvent handles Book events from watcher
func (ct *ctrlerCtx) handleBookEvent(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *bookstore.Book:
		eobj := evt.Object.(*bookstore.Book)
		kind := "Book"

		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		handler, ok := ct.handlers[kind]
		if !ok {
			log.Fatalf("Cant find the handler for %s", kind)
		}
		bookHandler := handler.(BookHandler)
		// handle based on event type
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			fobj, err := ct.findObject(kind, eobj.GetKey())
			if err != nil {
				obj := &Book{
					Book:       *eobj,
					HandlerCtx: nil,
					ctrler:     ct,
				}
				ct.addObject(kind, obj.GetKey(), obj)
				// call the event handler
				obj.Lock()
				err = bookHandler.OnBookCreate(obj)
				obj.Unlock()
				if err != nil {
					log.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					ct.delObject(kind, eobj.GetKey())
					return err
				}
			} else {
				obj := fobj.(*Book)
				obj.ObjectMeta = eobj.ObjectMeta

				// see if it changed
				if _, ok := ref.ObjDiff(obj.Spec, eobj.Spec); ok {
					obj.Spec = eobj.Spec
					// call the event handler
					obj.Lock()
					err = bookHandler.OnBookUpdate(obj)
					obj.Unlock()
					if err != nil {
						log.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
						return err
					}
				}
			}
		case kvstore.Deleted:
			fobj, err := ct.findObject(kind, eobj.GetKey())
			if err != nil {
				log.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
				return err
			}

			obj := fobj.(*Book)

			// Call the event reactor
			obj.Lock()
			err = bookHandler.OnBookDelete(obj)
			obj.Unlock()
			if err != nil {
				log.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
				return err
			}

			ct.delObject(kind, eobj.GetKey())
		}
	default:
		log.Fatalf("API watcher Found object of invalid type: %v on Book watch channel", tp)
	}

	return nil
}

// diffBook does a diff of Book objects between local cache and API server
func (ct *ctrlerCtx) diffBook(apicl apiclient.Services) {
	opts := api.ListWatchOptions{}

	// get a list of all objects from API server
	objlist, err := apicl.BookstoreV1().Book().List(context.Background(), &opts)
	if err != nil {
		log.Errorf("Error getting a list of objects. Err: %v", err)
		return
	}

	// build an object map
	objmap := make(map[string]*bookstore.Book)
	for _, obj := range objlist {
		objmap[obj.GetKey()] = obj
	}

	// if an object is in our local cache and not in API server, trigger delete for it
	for _, obj := range ct.Book().List() {
		_, ok := objmap[obj.GetKey()]
		if !ok {
			evt := kvstore.WatchEvent{
				Type:   kvstore.Deleted,
				Key:    obj.GetKey(),
				Object: &obj.Book,
			}
			ct.handleBookEvent(&evt)
		}
	}

	// trigger create event for all others
	for _, obj := range objlist {
		evt := kvstore.WatchEvent{
			Type:   kvstore.Created,
			Key:    obj.GetKey(),
			Object: obj,
		}
		ct.handleBookEvent(&evt)
	}
}

func (ct *ctrlerCtx) runBookWatcher() {
	kind := "Book"

	// if there is no API server to connect to, we are done
	if (ct.resolver == nil) || ct.apisrvURL == "" {
		return
	}

	// create context
	ctx, cancel := context.WithCancel(context.Background())
	ct.Lock()
	ct.watchCancel[kind] = cancel
	ct.Unlock()
	opts := api.ListWatchOptions{}

	// setup wait group
	ct.waitGrp.Add(1)
	defer ct.waitGrp.Done()

	// loop forever
	for {
		// create a grpc client
		apicl, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, ct.logger, rpckit.WithBalancer(ct.balancer))
		if err != nil {
			log.Warnf("Failed to connect to gRPC server [%s]\n", ct.apisrvURL)
		} else {
			log.Infof("API client connected {%+v}", apicl)

			// Book object watcher
			wt, werr := apicl.BookstoreV1().Book().Watch(ctx, &opts)
			if werr != nil {
				log.Errorf("Failed to start %s watch (%s)\n", kind, werr)
				return
			}
			ct.Lock()
			ct.watchers[kind] = wt
			ct.Unlock()

			// perform a diff with API server and local cache
			time.Sleep(time.Millisecond * 100)
			ct.diffBook(apicl)

			// handle api server watch events
		innerLoop:
			for {
				// wait for events
				select {
				case evt, ok := <-wt.EventChan():
					if !ok {
						log.Error("Error receiving from apisrv watcher")
						break innerLoop
					}

					// handle event
					ct.handleBookEvent(evt)
				}
			}
			apicl.Close()
		}

		// if stop flag is set, we are done
		if ct.stoped {
			log.Infof("Exiting API server watcher")
			return
		}

		// wait for a second and retry connecting to api server
		time.Sleep(time.Second)
	}
}

// WatchBook starts watch on Book object
func (ct *ctrlerCtx) WatchBook(handler BookHandler) error {
	kind := "Book"

	ct.Lock()
	defer ct.Unlock()

	// see if we already have a watcher
	_, ok := ct.watchers[kind]
	if ok {
		return fmt.Errorf("Book watcher already exists")
	}

	// save handler
	ct.handlers[kind] = handler

	// run Book watcher in a go routine
	go ct.runBookWatcher()

	return nil
}

// BookAPI returns
type BookAPI interface {
	Create(obj *bookstore.Book) error
	Update(obj *bookstore.Book) error
	Delete(obj *bookstore.Book) error
	List() []*Book
	Watch(handler BookHandler) error
}

// dummy struct that implements BookAPI
type bookAPI struct {
	ct *ctrlerCtx
}

// Create creates Book object
func (api *bookAPI) Create(obj *bookstore.Book) error {
	return api.ct.handleBookEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Created})
}

// Update triggers update on Book object
func (api *bookAPI) Update(obj *bookstore.Book) error {
	return api.ct.handleBookEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Updated})
}

// Delete deletes Book object
func (api *bookAPI) Delete(obj *bookstore.Book) error {
	return api.ct.handleBookEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Deleted})
}

// List returns a list of all Book objects
func (api *bookAPI) List() []*Book {
	var objlist []*Book

	objs := api.ct.ListObjects("Book")
	for _, obj := range objs {
		switch tp := obj.(type) {
		case *Book:
			eobj := obj.(*Book)
			objlist = append(objlist, eobj)
		default:
			log.Fatalf("Got invalid object type %v while looking for Book", tp)
		}
	}

	return objlist
}

// Watch sets up a event handlers for Book object
func (api *bookAPI) Watch(handler BookHandler) error {
	return api.ct.WatchBook(handler)
}

// Book returns BookAPI
func (ct *ctrlerCtx) Book() BookAPI {
	return &bookAPI{ct: ct}
}

// Publisher is a wrapper object that implements additional functionality
type Publisher struct {
	sync.Mutex
	bookstore.Publisher
	HandlerCtx interface{} // additional state handlers can store
	ctrler     *ctrlerCtx  // reference back to the controller instance
}

func (obj *Publisher) Write() error {
	// if there is no API server to connect to, we are done
	if (obj.ctrler == nil) || (obj.ctrler.resolver == nil) || obj.ctrler.apisrvURL == "" {
		return nil
	}

	apicl, err := obj.ctrler.apiClient()
	if err != nil {
		log.Errorf("Error creating API server clent. Err: %v", err)
		return err
	}

	// write to api server
	if obj.ObjectMeta.ResourceVersion != "" {
		nobj := *obj
		// FIXME: clear the resource version till we figure out CAS semantics
		nobj.ObjectMeta.ResourceVersion = ""

		// update it
		_, err = apicl.BookstoreV1().Publisher().Update(context.Background(), &nobj.Publisher)
	} else {
		//  create
		_, err = apicl.BookstoreV1().Publisher().Create(context.Background(), &obj.Publisher)
	}

	return nil
}

// PublisherHandler is the event handler for Publisher object
type PublisherHandler interface {
	OnPublisherCreate(obj *Publisher) error
	OnPublisherUpdate(obj *Publisher) error
	OnPublisherDelete(obj *Publisher) error
}

// handlePublisherEvent handles Publisher events from watcher
func (ct *ctrlerCtx) handlePublisherEvent(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *bookstore.Publisher:
		eobj := evt.Object.(*bookstore.Publisher)
		kind := "Publisher"

		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		handler, ok := ct.handlers[kind]
		if !ok {
			log.Fatalf("Cant find the handler for %s", kind)
		}
		publisherHandler := handler.(PublisherHandler)
		// handle based on event type
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			fobj, err := ct.findObject(kind, eobj.GetKey())
			if err != nil {
				obj := &Publisher{
					Publisher:  *eobj,
					HandlerCtx: nil,
					ctrler:     ct,
				}
				ct.addObject(kind, obj.GetKey(), obj)
				// call the event handler
				obj.Lock()
				err = publisherHandler.OnPublisherCreate(obj)
				obj.Unlock()
				if err != nil {
					log.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					ct.delObject(kind, eobj.GetKey())
					return err
				}
			} else {
				obj := fobj.(*Publisher)
				obj.ObjectMeta = eobj.ObjectMeta

				// see if it changed
				if _, ok := ref.ObjDiff(obj.Spec, eobj.Spec); ok {
					obj.Spec = eobj.Spec
					// call the event handler
					obj.Lock()
					err = publisherHandler.OnPublisherUpdate(obj)
					obj.Unlock()
					if err != nil {
						log.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
						return err
					}
				}
			}
		case kvstore.Deleted:
			fobj, err := ct.findObject(kind, eobj.GetKey())
			if err != nil {
				log.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
				return err
			}

			obj := fobj.(*Publisher)

			// Call the event reactor
			obj.Lock()
			err = publisherHandler.OnPublisherDelete(obj)
			obj.Unlock()
			if err != nil {
				log.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
				return err
			}

			ct.delObject(kind, eobj.GetKey())
		}
	default:
		log.Fatalf("API watcher Found object of invalid type: %v on Publisher watch channel", tp)
	}

	return nil
}

// diffPublisher does a diff of Publisher objects between local cache and API server
func (ct *ctrlerCtx) diffPublisher(apicl apiclient.Services) {
	opts := api.ListWatchOptions{}

	// get a list of all objects from API server
	objlist, err := apicl.BookstoreV1().Publisher().List(context.Background(), &opts)
	if err != nil {
		log.Errorf("Error getting a list of objects. Err: %v", err)
		return
	}

	// build an object map
	objmap := make(map[string]*bookstore.Publisher)
	for _, obj := range objlist {
		objmap[obj.GetKey()] = obj
	}

	// if an object is in our local cache and not in API server, trigger delete for it
	for _, obj := range ct.Publisher().List() {
		_, ok := objmap[obj.GetKey()]
		if !ok {
			evt := kvstore.WatchEvent{
				Type:   kvstore.Deleted,
				Key:    obj.GetKey(),
				Object: &obj.Publisher,
			}
			ct.handlePublisherEvent(&evt)
		}
	}

	// trigger create event for all others
	for _, obj := range objlist {
		evt := kvstore.WatchEvent{
			Type:   kvstore.Created,
			Key:    obj.GetKey(),
			Object: obj,
		}
		ct.handlePublisherEvent(&evt)
	}
}

func (ct *ctrlerCtx) runPublisherWatcher() {
	kind := "Publisher"

	// if there is no API server to connect to, we are done
	if (ct.resolver == nil) || ct.apisrvURL == "" {
		return
	}

	// create context
	ctx, cancel := context.WithCancel(context.Background())
	ct.Lock()
	ct.watchCancel[kind] = cancel
	ct.Unlock()
	opts := api.ListWatchOptions{}

	// setup wait group
	ct.waitGrp.Add(1)
	defer ct.waitGrp.Done()

	// loop forever
	for {
		// create a grpc client
		apicl, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, ct.logger, rpckit.WithBalancer(ct.balancer))
		if err != nil {
			log.Warnf("Failed to connect to gRPC server [%s]\n", ct.apisrvURL)
		} else {
			log.Infof("API client connected {%+v}", apicl)

			// Publisher object watcher
			wt, werr := apicl.BookstoreV1().Publisher().Watch(ctx, &opts)
			if werr != nil {
				log.Errorf("Failed to start %s watch (%s)\n", kind, werr)
				return
			}
			ct.Lock()
			ct.watchers[kind] = wt
			ct.Unlock()

			// perform a diff with API server and local cache
			time.Sleep(time.Millisecond * 100)
			ct.diffPublisher(apicl)

			// handle api server watch events
		innerLoop:
			for {
				// wait for events
				select {
				case evt, ok := <-wt.EventChan():
					if !ok {
						log.Error("Error receiving from apisrv watcher")
						break innerLoop
					}

					// handle event
					ct.handlePublisherEvent(evt)
				}
			}
			apicl.Close()
		}

		// if stop flag is set, we are done
		if ct.stoped {
			log.Infof("Exiting API server watcher")
			return
		}

		// wait for a second and retry connecting to api server
		time.Sleep(time.Second)
	}
}

// WatchPublisher starts watch on Publisher object
func (ct *ctrlerCtx) WatchPublisher(handler PublisherHandler) error {
	kind := "Publisher"

	ct.Lock()
	defer ct.Unlock()

	// see if we already have a watcher
	_, ok := ct.watchers[kind]
	if ok {
		return fmt.Errorf("Publisher watcher already exists")
	}

	// save handler
	ct.handlers[kind] = handler

	// run Publisher watcher in a go routine
	go ct.runPublisherWatcher()

	return nil
}

// PublisherAPI returns
type PublisherAPI interface {
	Create(obj *bookstore.Publisher) error
	Update(obj *bookstore.Publisher) error
	Delete(obj *bookstore.Publisher) error
	List() []*Publisher
	Watch(handler PublisherHandler) error
}

// dummy struct that implements PublisherAPI
type publisherAPI struct {
	ct *ctrlerCtx
}

// Create creates Publisher object
func (api *publisherAPI) Create(obj *bookstore.Publisher) error {
	return api.ct.handlePublisherEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Created})
}

// Update triggers update on Publisher object
func (api *publisherAPI) Update(obj *bookstore.Publisher) error {
	return api.ct.handlePublisherEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Updated})
}

// Delete deletes Publisher object
func (api *publisherAPI) Delete(obj *bookstore.Publisher) error {
	return api.ct.handlePublisherEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Deleted})
}

// List returns a list of all Publisher objects
func (api *publisherAPI) List() []*Publisher {
	var objlist []*Publisher

	objs := api.ct.ListObjects("Publisher")
	for _, obj := range objs {
		switch tp := obj.(type) {
		case *Publisher:
			eobj := obj.(*Publisher)
			objlist = append(objlist, eobj)
		default:
			log.Fatalf("Got invalid object type %v while looking for Publisher", tp)
		}
	}

	return objlist
}

// Watch sets up a event handlers for Publisher object
func (api *publisherAPI) Watch(handler PublisherHandler) error {
	return api.ct.WatchPublisher(handler)
}

// Publisher returns PublisherAPI
func (ct *ctrlerCtx) Publisher() PublisherAPI {
	return &publisherAPI{ct: ct}
}

// Store is a wrapper object that implements additional functionality
type Store struct {
	sync.Mutex
	bookstore.Store
	HandlerCtx interface{} // additional state handlers can store
	ctrler     *ctrlerCtx  // reference back to the controller instance
}

func (obj *Store) Write() error {
	// if there is no API server to connect to, we are done
	if (obj.ctrler == nil) || (obj.ctrler.resolver == nil) || obj.ctrler.apisrvURL == "" {
		return nil
	}

	apicl, err := obj.ctrler.apiClient()
	if err != nil {
		log.Errorf("Error creating API server clent. Err: %v", err)
		return err
	}

	// write to api server
	if obj.ObjectMeta.ResourceVersion != "" {
		nobj := *obj
		// FIXME: clear the resource version till we figure out CAS semantics
		nobj.ObjectMeta.ResourceVersion = ""

		// update it
		_, err = apicl.BookstoreV1().Store().Update(context.Background(), &nobj.Store)
	} else {
		//  create
		_, err = apicl.BookstoreV1().Store().Create(context.Background(), &obj.Store)
	}

	return nil
}

// StoreHandler is the event handler for Store object
type StoreHandler interface {
	OnStoreCreate(obj *Store) error
	OnStoreUpdate(obj *Store) error
	OnStoreDelete(obj *Store) error
}

// handleStoreEvent handles Store events from watcher
func (ct *ctrlerCtx) handleStoreEvent(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *bookstore.Store:
		eobj := evt.Object.(*bookstore.Store)
		kind := "Store"

		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		handler, ok := ct.handlers[kind]
		if !ok {
			log.Fatalf("Cant find the handler for %s", kind)
		}
		storeHandler := handler.(StoreHandler)
		// handle based on event type
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			fobj, err := ct.findObject(kind, eobj.GetKey())
			if err != nil {
				obj := &Store{
					Store:      *eobj,
					HandlerCtx: nil,
					ctrler:     ct,
				}
				ct.addObject(kind, obj.GetKey(), obj)
				// call the event handler
				obj.Lock()
				err = storeHandler.OnStoreCreate(obj)
				obj.Unlock()
				if err != nil {
					log.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					ct.delObject(kind, eobj.GetKey())
					return err
				}
			} else {
				obj := fobj.(*Store)
				obj.ObjectMeta = eobj.ObjectMeta

				// see if it changed
				if _, ok := ref.ObjDiff(obj.Spec, eobj.Spec); ok {
					obj.Spec = eobj.Spec
					// call the event handler
					obj.Lock()
					err = storeHandler.OnStoreUpdate(obj)
					obj.Unlock()
					if err != nil {
						log.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
						return err
					}
				}
			}
		case kvstore.Deleted:
			fobj, err := ct.findObject(kind, eobj.GetKey())
			if err != nil {
				log.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
				return err
			}

			obj := fobj.(*Store)

			// Call the event reactor
			obj.Lock()
			err = storeHandler.OnStoreDelete(obj)
			obj.Unlock()
			if err != nil {
				log.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
				return err
			}

			ct.delObject(kind, eobj.GetKey())
		}
	default:
		log.Fatalf("API watcher Found object of invalid type: %v on Store watch channel", tp)
	}

	return nil
}

// diffStore does a diff of Store objects between local cache and API server
func (ct *ctrlerCtx) diffStore(apicl apiclient.Services) {
	opts := api.ListWatchOptions{}

	// get a list of all objects from API server
	objlist, err := apicl.BookstoreV1().Store().List(context.Background(), &opts)
	if err != nil {
		log.Errorf("Error getting a list of objects. Err: %v", err)
		return
	}

	// build an object map
	objmap := make(map[string]*bookstore.Store)
	for _, obj := range objlist {
		objmap[obj.GetKey()] = obj
	}

	// if an object is in our local cache and not in API server, trigger delete for it
	for _, obj := range ct.Store().List() {
		_, ok := objmap[obj.GetKey()]
		if !ok {
			evt := kvstore.WatchEvent{
				Type:   kvstore.Deleted,
				Key:    obj.GetKey(),
				Object: &obj.Store,
			}
			ct.handleStoreEvent(&evt)
		}
	}

	// trigger create event for all others
	for _, obj := range objlist {
		evt := kvstore.WatchEvent{
			Type:   kvstore.Created,
			Key:    obj.GetKey(),
			Object: obj,
		}
		ct.handleStoreEvent(&evt)
	}
}

func (ct *ctrlerCtx) runStoreWatcher() {
	kind := "Store"

	// if there is no API server to connect to, we are done
	if (ct.resolver == nil) || ct.apisrvURL == "" {
		return
	}

	// create context
	ctx, cancel := context.WithCancel(context.Background())
	ct.Lock()
	ct.watchCancel[kind] = cancel
	ct.Unlock()
	opts := api.ListWatchOptions{}

	// setup wait group
	ct.waitGrp.Add(1)
	defer ct.waitGrp.Done()

	// loop forever
	for {
		// create a grpc client
		apicl, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, ct.logger, rpckit.WithBalancer(ct.balancer))
		if err != nil {
			log.Warnf("Failed to connect to gRPC server [%s]\n", ct.apisrvURL)
		} else {
			log.Infof("API client connected {%+v}", apicl)

			// Store object watcher
			wt, werr := apicl.BookstoreV1().Store().Watch(ctx, &opts)
			if werr != nil {
				log.Errorf("Failed to start %s watch (%s)\n", kind, werr)
				return
			}
			ct.Lock()
			ct.watchers[kind] = wt
			ct.Unlock()

			// perform a diff with API server and local cache
			time.Sleep(time.Millisecond * 100)
			ct.diffStore(apicl)

			// handle api server watch events
		innerLoop:
			for {
				// wait for events
				select {
				case evt, ok := <-wt.EventChan():
					if !ok {
						log.Error("Error receiving from apisrv watcher")
						break innerLoop
					}

					// handle event
					ct.handleStoreEvent(evt)
				}
			}
			apicl.Close()
		}

		// if stop flag is set, we are done
		if ct.stoped {
			log.Infof("Exiting API server watcher")
			return
		}

		// wait for a second and retry connecting to api server
		time.Sleep(time.Second)
	}
}

// WatchStore starts watch on Store object
func (ct *ctrlerCtx) WatchStore(handler StoreHandler) error {
	kind := "Store"

	ct.Lock()
	defer ct.Unlock()

	// see if we already have a watcher
	_, ok := ct.watchers[kind]
	if ok {
		return fmt.Errorf("Store watcher already exists")
	}

	// save handler
	ct.handlers[kind] = handler

	// run Store watcher in a go routine
	go ct.runStoreWatcher()

	return nil
}

// StoreAPI returns
type StoreAPI interface {
	Create(obj *bookstore.Store) error
	Update(obj *bookstore.Store) error
	Delete(obj *bookstore.Store) error
	List() []*Store
	Watch(handler StoreHandler) error
}

// dummy struct that implements StoreAPI
type storeAPI struct {
	ct *ctrlerCtx
}

// Create creates Store object
func (api *storeAPI) Create(obj *bookstore.Store) error {
	return api.ct.handleStoreEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Created})
}

// Update triggers update on Store object
func (api *storeAPI) Update(obj *bookstore.Store) error {
	return api.ct.handleStoreEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Updated})
}

// Delete deletes Store object
func (api *storeAPI) Delete(obj *bookstore.Store) error {
	return api.ct.handleStoreEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Deleted})
}

// List returns a list of all Store objects
func (api *storeAPI) List() []*Store {
	var objlist []*Store

	objs := api.ct.ListObjects("Store")
	for _, obj := range objs {
		switch tp := obj.(type) {
		case *Store:
			eobj := obj.(*Store)
			objlist = append(objlist, eobj)
		default:
			log.Fatalf("Got invalid object type %v while looking for Store", tp)
		}
	}

	return objlist
}

// Watch sets up a event handlers for Store object
func (api *storeAPI) Watch(handler StoreHandler) error {
	return api.ct.WatchStore(handler)
}

// Store returns StoreAPI
func (ct *ctrlerCtx) Store() StoreAPI {
	return &storeAPI{ct: ct}
}

// Coupon is a wrapper object that implements additional functionality
type Coupon struct {
	sync.Mutex
	bookstore.Coupon
	HandlerCtx interface{} // additional state handlers can store
	ctrler     *ctrlerCtx  // reference back to the controller instance
}

func (obj *Coupon) Write() error {
	// if there is no API server to connect to, we are done
	if (obj.ctrler == nil) || (obj.ctrler.resolver == nil) || obj.ctrler.apisrvURL == "" {
		return nil
	}

	apicl, err := obj.ctrler.apiClient()
	if err != nil {
		log.Errorf("Error creating API server clent. Err: %v", err)
		return err
	}

	// write to api server
	if obj.ObjectMeta.ResourceVersion != "" {
		nobj := *obj
		// FIXME: clear the resource version till we figure out CAS semantics
		nobj.ObjectMeta.ResourceVersion = ""

		// update it
		_, err = apicl.BookstoreV1().Coupon().Update(context.Background(), &nobj.Coupon)
	} else {
		//  create
		_, err = apicl.BookstoreV1().Coupon().Create(context.Background(), &obj.Coupon)
	}

	return nil
}

// CouponHandler is the event handler for Coupon object
type CouponHandler interface {
	OnCouponCreate(obj *Coupon) error
	OnCouponUpdate(obj *Coupon) error
	OnCouponDelete(obj *Coupon) error
}

// handleCouponEvent handles Coupon events from watcher
func (ct *ctrlerCtx) handleCouponEvent(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *bookstore.Coupon:
		eobj := evt.Object.(*bookstore.Coupon)
		kind := "Coupon"

		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		handler, ok := ct.handlers[kind]
		if !ok {
			log.Fatalf("Cant find the handler for %s", kind)
		}
		couponHandler := handler.(CouponHandler)
		// handle based on event type
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			fobj, err := ct.findObject(kind, eobj.GetKey())
			if err != nil {
				obj := &Coupon{
					Coupon:     *eobj,
					HandlerCtx: nil,
					ctrler:     ct,
				}
				ct.addObject(kind, obj.GetKey(), obj)
				// call the event handler
				obj.Lock()
				err = couponHandler.OnCouponCreate(obj)
				obj.Unlock()
				if err != nil {
					log.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					ct.delObject(kind, eobj.GetKey())
					return err
				}
			} else {
				obj := fobj.(*Coupon)
				obj.ObjectMeta = eobj.ObjectMeta

				// see if it changed
				if _, ok := ref.ObjDiff(obj.Spec, eobj.Spec); ok {
					obj.Spec = eobj.Spec
					// call the event handler
					obj.Lock()
					err = couponHandler.OnCouponUpdate(obj)
					obj.Unlock()
					if err != nil {
						log.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
						return err
					}
				}
			}
		case kvstore.Deleted:
			fobj, err := ct.findObject(kind, eobj.GetKey())
			if err != nil {
				log.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
				return err
			}

			obj := fobj.(*Coupon)

			// Call the event reactor
			obj.Lock()
			err = couponHandler.OnCouponDelete(obj)
			obj.Unlock()
			if err != nil {
				log.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
				return err
			}

			ct.delObject(kind, eobj.GetKey())
		}
	default:
		log.Fatalf("API watcher Found object of invalid type: %v on Coupon watch channel", tp)
	}

	return nil
}

// diffCoupon does a diff of Coupon objects between local cache and API server
func (ct *ctrlerCtx) diffCoupon(apicl apiclient.Services) {
	opts := api.ListWatchOptions{}

	// get a list of all objects from API server
	objlist, err := apicl.BookstoreV1().Coupon().List(context.Background(), &opts)
	if err != nil {
		log.Errorf("Error getting a list of objects. Err: %v", err)
		return
	}

	// build an object map
	objmap := make(map[string]*bookstore.Coupon)
	for _, obj := range objlist {
		objmap[obj.GetKey()] = obj
	}

	// if an object is in our local cache and not in API server, trigger delete for it
	for _, obj := range ct.Coupon().List() {
		_, ok := objmap[obj.GetKey()]
		if !ok {
			evt := kvstore.WatchEvent{
				Type:   kvstore.Deleted,
				Key:    obj.GetKey(),
				Object: &obj.Coupon,
			}
			ct.handleCouponEvent(&evt)
		}
	}

	// trigger create event for all others
	for _, obj := range objlist {
		evt := kvstore.WatchEvent{
			Type:   kvstore.Created,
			Key:    obj.GetKey(),
			Object: obj,
		}
		ct.handleCouponEvent(&evt)
	}
}

func (ct *ctrlerCtx) runCouponWatcher() {
	kind := "Coupon"

	// if there is no API server to connect to, we are done
	if (ct.resolver == nil) || ct.apisrvURL == "" {
		return
	}

	// create context
	ctx, cancel := context.WithCancel(context.Background())
	ct.Lock()
	ct.watchCancel[kind] = cancel
	ct.Unlock()
	opts := api.ListWatchOptions{}

	// setup wait group
	ct.waitGrp.Add(1)
	defer ct.waitGrp.Done()

	// loop forever
	for {
		// create a grpc client
		apicl, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, ct.logger, rpckit.WithBalancer(ct.balancer))
		if err != nil {
			log.Warnf("Failed to connect to gRPC server [%s]\n", ct.apisrvURL)
		} else {
			log.Infof("API client connected {%+v}", apicl)

			// Coupon object watcher
			wt, werr := apicl.BookstoreV1().Coupon().Watch(ctx, &opts)
			if werr != nil {
				log.Errorf("Failed to start %s watch (%s)\n", kind, werr)
				return
			}
			ct.Lock()
			ct.watchers[kind] = wt
			ct.Unlock()

			// perform a diff with API server and local cache
			time.Sleep(time.Millisecond * 100)
			ct.diffCoupon(apicl)

			// handle api server watch events
		innerLoop:
			for {
				// wait for events
				select {
				case evt, ok := <-wt.EventChan():
					if !ok {
						log.Error("Error receiving from apisrv watcher")
						break innerLoop
					}

					// handle event
					ct.handleCouponEvent(evt)
				}
			}
			apicl.Close()
		}

		// if stop flag is set, we are done
		if ct.stoped {
			log.Infof("Exiting API server watcher")
			return
		}

		// wait for a second and retry connecting to api server
		time.Sleep(time.Second)
	}
}

// WatchCoupon starts watch on Coupon object
func (ct *ctrlerCtx) WatchCoupon(handler CouponHandler) error {
	kind := "Coupon"

	ct.Lock()
	defer ct.Unlock()

	// see if we already have a watcher
	_, ok := ct.watchers[kind]
	if ok {
		return fmt.Errorf("Coupon watcher already exists")
	}

	// save handler
	ct.handlers[kind] = handler

	// run Coupon watcher in a go routine
	go ct.runCouponWatcher()

	return nil
}

// CouponAPI returns
type CouponAPI interface {
	Create(obj *bookstore.Coupon) error
	Update(obj *bookstore.Coupon) error
	Delete(obj *bookstore.Coupon) error
	List() []*Coupon
	Watch(handler CouponHandler) error
}

// dummy struct that implements CouponAPI
type couponAPI struct {
	ct *ctrlerCtx
}

// Create creates Coupon object
func (api *couponAPI) Create(obj *bookstore.Coupon) error {
	return api.ct.handleCouponEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Created})
}

// Update triggers update on Coupon object
func (api *couponAPI) Update(obj *bookstore.Coupon) error {
	return api.ct.handleCouponEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Updated})
}

// Delete deletes Coupon object
func (api *couponAPI) Delete(obj *bookstore.Coupon) error {
	return api.ct.handleCouponEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Deleted})
}

// List returns a list of all Coupon objects
func (api *couponAPI) List() []*Coupon {
	var objlist []*Coupon

	objs := api.ct.ListObjects("Coupon")
	for _, obj := range objs {
		switch tp := obj.(type) {
		case *Coupon:
			eobj := obj.(*Coupon)
			objlist = append(objlist, eobj)
		default:
			log.Fatalf("Got invalid object type %v while looking for Coupon", tp)
		}
	}

	return objlist
}

// Watch sets up a event handlers for Coupon object
func (api *couponAPI) Watch(handler CouponHandler) error {
	return api.ct.WatchCoupon(handler)
}

// Coupon returns CouponAPI
func (ct *ctrlerCtx) Coupon() CouponAPI {
	return &couponAPI{ct: ct}
}

// Customer is a wrapper object that implements additional functionality
type Customer struct {
	sync.Mutex
	bookstore.Customer
	HandlerCtx interface{} // additional state handlers can store
	ctrler     *ctrlerCtx  // reference back to the controller instance
}

func (obj *Customer) Write() error {
	// if there is no API server to connect to, we are done
	if (obj.ctrler == nil) || (obj.ctrler.resolver == nil) || obj.ctrler.apisrvURL == "" {
		return nil
	}

	apicl, err := obj.ctrler.apiClient()
	if err != nil {
		log.Errorf("Error creating API server clent. Err: %v", err)
		return err
	}

	// write to api server
	if obj.ObjectMeta.ResourceVersion != "" {
		nobj := *obj
		// FIXME: clear the resource version till we figure out CAS semantics
		nobj.ObjectMeta.ResourceVersion = ""

		// update it
		_, err = apicl.BookstoreV1().Customer().Update(context.Background(), &nobj.Customer)
	} else {
		//  create
		_, err = apicl.BookstoreV1().Customer().Create(context.Background(), &obj.Customer)
	}

	return nil
}

// CustomerHandler is the event handler for Customer object
type CustomerHandler interface {
	OnCustomerCreate(obj *Customer) error
	OnCustomerUpdate(obj *Customer) error
	OnCustomerDelete(obj *Customer) error
}

// handleCustomerEvent handles Customer events from watcher
func (ct *ctrlerCtx) handleCustomerEvent(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *bookstore.Customer:
		eobj := evt.Object.(*bookstore.Customer)
		kind := "Customer"

		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		handler, ok := ct.handlers[kind]
		if !ok {
			log.Fatalf("Cant find the handler for %s", kind)
		}
		customerHandler := handler.(CustomerHandler)
		// handle based on event type
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			fobj, err := ct.findObject(kind, eobj.GetKey())
			if err != nil {
				obj := &Customer{
					Customer:   *eobj,
					HandlerCtx: nil,
					ctrler:     ct,
				}
				ct.addObject(kind, obj.GetKey(), obj)
				// call the event handler
				obj.Lock()
				err = customerHandler.OnCustomerCreate(obj)
				obj.Unlock()
				if err != nil {
					log.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					ct.delObject(kind, eobj.GetKey())
					return err
				}
			} else {
				obj := fobj.(*Customer)
				obj.ObjectMeta = eobj.ObjectMeta

				// see if it changed
				if _, ok := ref.ObjDiff(obj.Spec, eobj.Spec); ok {
					obj.Spec = eobj.Spec
					// call the event handler
					obj.Lock()
					err = customerHandler.OnCustomerUpdate(obj)
					obj.Unlock()
					if err != nil {
						log.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
						return err
					}
				}
			}
		case kvstore.Deleted:
			fobj, err := ct.findObject(kind, eobj.GetKey())
			if err != nil {
				log.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
				return err
			}

			obj := fobj.(*Customer)

			// Call the event reactor
			obj.Lock()
			err = customerHandler.OnCustomerDelete(obj)
			obj.Unlock()
			if err != nil {
				log.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
				return err
			}

			ct.delObject(kind, eobj.GetKey())
		}
	default:
		log.Fatalf("API watcher Found object of invalid type: %v on Customer watch channel", tp)
	}

	return nil
}

// diffCustomer does a diff of Customer objects between local cache and API server
func (ct *ctrlerCtx) diffCustomer(apicl apiclient.Services) {
	opts := api.ListWatchOptions{}

	// get a list of all objects from API server
	objlist, err := apicl.BookstoreV1().Customer().List(context.Background(), &opts)
	if err != nil {
		log.Errorf("Error getting a list of objects. Err: %v", err)
		return
	}

	// build an object map
	objmap := make(map[string]*bookstore.Customer)
	for _, obj := range objlist {
		objmap[obj.GetKey()] = obj
	}

	// if an object is in our local cache and not in API server, trigger delete for it
	for _, obj := range ct.Customer().List() {
		_, ok := objmap[obj.GetKey()]
		if !ok {
			evt := kvstore.WatchEvent{
				Type:   kvstore.Deleted,
				Key:    obj.GetKey(),
				Object: &obj.Customer,
			}
			ct.handleCustomerEvent(&evt)
		}
	}

	// trigger create event for all others
	for _, obj := range objlist {
		evt := kvstore.WatchEvent{
			Type:   kvstore.Created,
			Key:    obj.GetKey(),
			Object: obj,
		}
		ct.handleCustomerEvent(&evt)
	}
}

func (ct *ctrlerCtx) runCustomerWatcher() {
	kind := "Customer"

	// if there is no API server to connect to, we are done
	if (ct.resolver == nil) || ct.apisrvURL == "" {
		return
	}

	// create context
	ctx, cancel := context.WithCancel(context.Background())
	ct.Lock()
	ct.watchCancel[kind] = cancel
	ct.Unlock()
	opts := api.ListWatchOptions{}

	// setup wait group
	ct.waitGrp.Add(1)
	defer ct.waitGrp.Done()

	// loop forever
	for {
		// create a grpc client
		apicl, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, ct.logger, rpckit.WithBalancer(ct.balancer))
		if err != nil {
			log.Warnf("Failed to connect to gRPC server [%s]\n", ct.apisrvURL)
		} else {
			log.Infof("API client connected {%+v}", apicl)

			// Customer object watcher
			wt, werr := apicl.BookstoreV1().Customer().Watch(ctx, &opts)
			if werr != nil {
				log.Errorf("Failed to start %s watch (%s)\n", kind, werr)
				return
			}
			ct.Lock()
			ct.watchers[kind] = wt
			ct.Unlock()

			// perform a diff with API server and local cache
			time.Sleep(time.Millisecond * 100)
			ct.diffCustomer(apicl)

			// handle api server watch events
		innerLoop:
			for {
				// wait for events
				select {
				case evt, ok := <-wt.EventChan():
					if !ok {
						log.Error("Error receiving from apisrv watcher")
						break innerLoop
					}

					// handle event
					ct.handleCustomerEvent(evt)
				}
			}
			apicl.Close()
		}

		// if stop flag is set, we are done
		if ct.stoped {
			log.Infof("Exiting API server watcher")
			return
		}

		// wait for a second and retry connecting to api server
		time.Sleep(time.Second)
	}
}

// WatchCustomer starts watch on Customer object
func (ct *ctrlerCtx) WatchCustomer(handler CustomerHandler) error {
	kind := "Customer"

	ct.Lock()
	defer ct.Unlock()

	// see if we already have a watcher
	_, ok := ct.watchers[kind]
	if ok {
		return fmt.Errorf("Customer watcher already exists")
	}

	// save handler
	ct.handlers[kind] = handler

	// run Customer watcher in a go routine
	go ct.runCustomerWatcher()

	return nil
}

// CustomerAPI returns
type CustomerAPI interface {
	Create(obj *bookstore.Customer) error
	Update(obj *bookstore.Customer) error
	Delete(obj *bookstore.Customer) error
	List() []*Customer
	Watch(handler CustomerHandler) error
}

// dummy struct that implements CustomerAPI
type customerAPI struct {
	ct *ctrlerCtx
}

// Create creates Customer object
func (api *customerAPI) Create(obj *bookstore.Customer) error {
	return api.ct.handleCustomerEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Created})
}

// Update triggers update on Customer object
func (api *customerAPI) Update(obj *bookstore.Customer) error {
	return api.ct.handleCustomerEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Updated})
}

// Delete deletes Customer object
func (api *customerAPI) Delete(obj *bookstore.Customer) error {
	return api.ct.handleCustomerEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Deleted})
}

// List returns a list of all Customer objects
func (api *customerAPI) List() []*Customer {
	var objlist []*Customer

	objs := api.ct.ListObjects("Customer")
	for _, obj := range objs {
		switch tp := obj.(type) {
		case *Customer:
			eobj := obj.(*Customer)
			objlist = append(objlist, eobj)
		default:
			log.Fatalf("Got invalid object type %v while looking for Customer", tp)
		}
	}

	return objlist
}

// Watch sets up a event handlers for Customer object
func (api *customerAPI) Watch(handler CustomerHandler) error {
	return api.ct.WatchCustomer(handler)
}

// Customer returns CustomerAPI
func (ct *ctrlerCtx) Customer() CustomerAPI {
	return &customerAPI{ct: ct}
}
