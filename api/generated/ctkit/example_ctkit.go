// Code generated by protoc-gen-grpc-pensando DO NOT EDIT.

/*
Package ctkit is a auto generated package.
Input file: example.proto
*/
package ctkit

import (
	"context"
	"errors"
	"fmt"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/pensando/sw/api"
	"github.com/pensando/sw/api/generated/apiclient"
	"github.com/pensando/sw/api/generated/bookstore"
	apiintf "github.com/pensando/sw/api/interfaces"
	"github.com/pensando/sw/venice/globals"
	"github.com/pensando/sw/venice/utils/balancer"
	"github.com/pensando/sw/venice/utils/kvstore"
	"github.com/pensando/sw/venice/utils/log"
	"github.com/pensando/sw/venice/utils/rpckit"
	"github.com/pensando/sw/venice/utils/runtime"
	"github.com/pensando/sw/venice/utils/shardworkers"
)

// Order is a wrapper object that implements additional functionality
type Order struct {
	sync.Mutex
	bookstore.Order
	HandlerCtx interface{} // additional state handlers can store
	ctrler     *ctrlerCtx  // reference back to the controller instance
}

func (obj *Order) Write() error {
	// if there is no API server to connect to, we are done
	if (obj.ctrler == nil) || (obj.ctrler.resolver == nil) || obj.ctrler.apisrvURL == "" {
		return nil
	}

	apicl, err := obj.ctrler.apiClient()
	if err != nil {
		obj.ctrler.logger.Errorf("Error creating API server clent. Err: %v", err)
		return err
	}

	obj.ctrler.stats.Counter("Order_Writes").Inc()

	// write to api server
	if obj.ObjectMeta.ResourceVersion != "" {
		// update it
		for i := 0; i < maxApisrvWriteRetry; i++ {
			_, err = apicl.BookstoreV1().Order().UpdateStatus(context.Background(), &obj.Order)
			if err == nil {
				break
			}
			time.Sleep(time.Millisecond * 100)
		}
	} else {
		//  create
		_, err = apicl.BookstoreV1().Order().Create(context.Background(), &obj.Order)
	}

	return nil
}

// OrderHandler is the event handler for Order object
type OrderHandler interface {
	OnOrderCreate(obj *Order) error
	OnOrderUpdate(oldObj *Order, newObj *bookstore.Order) error
	OnOrderDelete(obj *Order) error
	GetOrderWatchOptions() *api.ListWatchOptions
}

// OnOrderCreate is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnOrderCreate(obj *Order) error {
	log.Info("OnOrderCreate is not implemented")
	return nil
}

// OnOrderUpdate is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnOrderUpdate(oldObj *Order, newObj *bookstore.Order) error {
	log.Info("OnOrderUpdate is not implemented")
	return nil
}

// OnOrderDelete is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnOrderDelete(obj *Order) error {
	log.Info("OnOrderDelete is not implemented")
	return nil
}

// GetOrderWatchOptions is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) GetOrderWatchOptions() *api.ListWatchOptions {
	log.Info("GetOrderWatchOptions is not implemented")
	opts := &api.ListWatchOptions{}
	return opts
}

// handleOrderEvent handles Order events from watcher
func (ct *ctrlerCtx) handleOrderEvent(evt *kvstore.WatchEvent) error {

	if ct.objResolver == nil {
		return ct.handleOrderEventNoResolver(evt)
	}

	switch tp := evt.Object.(type) {
	case *bookstore.Order:
		eobj := evt.Object.(*bookstore.Order)
		kind := "Order"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ctx := &orderCtx{event: evt.Type,
			obj: &Order{Order: *eobj, ctrler: ct}}

		var err error
		switch evt.Type {
		case kvstore.Created:
			err = ct.processAdd(ctx)
		case kvstore.Updated:
			err = ct.processUpdate(ctx)
		case kvstore.Deleted:
			err = ct.processDelete(ctx)
		}
		return err
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on Order watch channel", tp)
	}

	return nil
}

// handleOrderEventNoResolver handles Order events from watcher
func (ct *ctrlerCtx) handleOrderEventNoResolver(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *bookstore.Order:
		eobj := evt.Object.(*bookstore.Order)
		kind := "Order"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		orderHandler := handler.(OrderHandler)
		// handle based on event type
		ctrlCtx := &orderCtx{event: evt.Type, obj: &Order{Order: *eobj, ctrler: ct}}
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			fobj, err := ct.getObject(kind, ctrlCtx.GetKey())
			if err != nil {
				ct.addObject(ctrlCtx)
				ct.stats.Counter("Order_Created_Events").Inc()

				// call the event handler
				ctrlCtx.Lock()
				err = orderHandler.OnOrderCreate(ctrlCtx.obj)
				ctrlCtx.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctrlCtx.obj, err)
					ct.delObject(kind, ctrlCtx.GetKey())
					return err
				}
			} else {
				fResVer, fErr := strconv.ParseInt(fobj.GetResourceVersion(), 10, 64)
				eResVer, eErr := strconv.ParseInt(eobj.GetResourceVersion(), 10, 64)
				if ct.resolver != nil && fErr == nil && eErr == nil && fResVer >= eResVer {
					// Event already processed.
					ct.logger.Infof("Skipping update due to old resource version")
					return nil
				}
				ctrlCtx := fobj.(*orderCtx)
				ct.stats.Counter("Order_Updated_Events").Inc()
				ctrlCtx.Lock()
				p := bookstore.Order{Spec: eobj.Spec,
					ObjectMeta: eobj.ObjectMeta,
					TypeMeta:   eobj.TypeMeta,
					Status:     eobj.Status}

				err = orderHandler.OnOrderUpdate(ctrlCtx.obj, &p)
				ctrlCtx.obj.Order = *eobj
				ctrlCtx.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctrlCtx.obj, err)
					return err
				}

			}
		case kvstore.Deleted:
			ctrlCtx := &orderCtx{event: evt.Type, obj: &Order{Order: *eobj, ctrler: ct}}
			fobj, err := ct.findObject(kind, ctrlCtx.GetKey())
			if err != nil {
				ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
				return err
			}

			obj := fobj.(*Order)
			ct.stats.Counter("Order_Deleted_Events").Inc()
			obj.Lock()
			err = orderHandler.OnOrderDelete(obj)
			obj.Unlock()
			if err != nil {
				ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
			}
			ct.delObject(kind, ctrlCtx.GetKey())
			return nil

		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on Order watch channel", tp)
	}

	return nil
}

type orderCtx struct {
	ctkitBaseCtx
	event kvstore.WatchEventType
	obj   *Order //
	//   newObj     *bookstore.Order //update
	newObj *orderCtx //update
}

func (ctx *orderCtx) References() map[string]apiintf.ReferenceObj {
	resp := make(map[string]apiintf.ReferenceObj)
	ctx.obj.References(ctx.obj.GetObjectMeta().Name, ctx.obj.GetObjectMeta().Namespace, resp)
	return resp
}

func (ctx *orderCtx) GetKey() string {
	return ctx.obj.MakeKey("bookstore")
}

func (ctx *orderCtx) GetKind() string {
	return ctx.obj.GetKind()
}

func (ctx *orderCtx) GetResourceVersion() string {
	return ctx.obj.GetResourceVersion()
}

func (ctx *orderCtx) SetEvent(event kvstore.WatchEventType) {
	ctx.event = event
}

func (ctx *orderCtx) SetNewObj(newObj apiintf.CtkitObject) {
	if newObj == nil {
		ctx.newObj = nil
	} else {
		ctx.newObj = newObj.(*orderCtx)
		ctx.newObj.obj.HandlerCtx = ctx.obj.HandlerCtx
	}
}

func (ctx *orderCtx) GetNewObj() apiintf.CtkitObject {
	return ctx.newObj
}

func (ctx *orderCtx) Copy(obj apiintf.CtkitObject) {
	ctx.obj.Order = obj.(*orderCtx).obj.Order
}

func (ctx *orderCtx) Lock() {
	ctx.obj.Lock()
}

func (ctx *orderCtx) Unlock() {
	ctx.obj.Unlock()
}

func (ctx *orderCtx) GetObjectMeta() *api.ObjectMeta {
	return ctx.obj.GetObjectMeta()
}

func (ctx *orderCtx) RuntimeObject() runtime.Object {
	var v interface{}
	v = ctx.obj
	return v.(runtime.Object)
}

func (ctx *orderCtx) WorkFunc(context context.Context) error {
	var err error
	evt := ctx.event
	ct := ctx.obj.ctrler
	kind := "Order"
	ct.Lock()
	handler, ok := ct.handlers[kind]
	ct.Unlock()
	if !ok {
		ct.logger.Fatalf("Cant find the handler for %s", kind)
	}
	orderHandler := handler.(OrderHandler)
	switch evt {
	case kvstore.Created:
		ctx.obj.Lock()
		err = orderHandler.OnOrderCreate(ctx.obj)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctx.obj, err)
			ctx.SetEvent(kvstore.Deleted)
		}
	case kvstore.Updated:
		ct.stats.Counter("Order_Updated_Events").Inc()
		ctx.obj.Lock()
		p := bookstore.Order{Spec: ctx.newObj.obj.Spec,
			ObjectMeta: ctx.newObj.obj.ObjectMeta,
			TypeMeta:   ctx.newObj.obj.TypeMeta,
			Status:     ctx.newObj.obj.Status}
		err = orderHandler.OnOrderUpdate(ctx.obj, &p)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctx.obj, err)
			ctx.SetEvent(kvstore.Deleted)
		}
	case kvstore.Deleted:
		ctx.obj.Lock()
		err = orderHandler.OnOrderDelete(ctx.obj)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error deleting %s %+v. Err: %v", kind, ctx.obj, err)
		}
	}
	ct.resolveObject(ctx.event, ctx)
	return nil
}

// handleOrderEventParallel handles Order events from watcher
func (ct *ctrlerCtx) handleOrderEventParallel(evt *kvstore.WatchEvent) error {

	if ct.objResolver == nil {
		return ct.handleOrderEventParallelWithNoResolver(evt)
	}

	switch tp := evt.Object.(type) {
	case *bookstore.Order:
		eobj := evt.Object.(*bookstore.Order)
		kind := "Order"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ctx := &orderCtx{event: evt.Type, obj: &Order{Order: *eobj, ctrler: ct}}

		var err error
		switch evt.Type {
		case kvstore.Created:
			err = ct.processAdd(ctx)
		case kvstore.Updated:
			err = ct.processUpdate(ctx)
		case kvstore.Deleted:
			err = ct.processDelete(ctx)
		}
		return err
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on Order watch channel", tp)
	}

	return nil
}

// handleOrderEventParallel handles Order events from watcher
func (ct *ctrlerCtx) handleOrderEventParallelWithNoResolver(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *bookstore.Order:
		eobj := evt.Object.(*bookstore.Order)
		kind := "Order"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		orderHandler := handler.(OrderHandler)
		// handle based on event type
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			workFunc := func(ctx context.Context, ctrlCtx shardworkers.WorkObj) error {
				var err error
				workCtx := ctrlCtx.(*orderCtx)
				eobj := workCtx.obj
				fobj, err := ct.getObject(kind, workCtx.GetKey())
				if err != nil {
					ct.addObject(workCtx)
					ct.stats.Counter("Order_Created_Events").Inc()
					eobj.Lock()
					err = orderHandler.OnOrderCreate(eobj)
					eobj.Unlock()
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, eobj, err)
						ct.delObject(kind, workCtx.GetKey())
					}
				} else {
					workCtx := fobj.(*orderCtx)
					obj := workCtx.obj
					ct.stats.Counter("Order_Updated_Events").Inc()
					obj.Lock()
					p := bookstore.Order{Spec: eobj.Spec,
						ObjectMeta: eobj.ObjectMeta,
						TypeMeta:   eobj.TypeMeta,
						Status:     eobj.Status}

					err = orderHandler.OnOrderUpdate(obj, &p)
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					} else {
						workCtx.obj.Order = p
					}
					obj.Unlock()
				}
				return err
			}
			ctrlCtx := &orderCtx{event: evt.Type, obj: &Order{Order: *eobj, ctrler: ct}}
			ct.runFunction("Order", ctrlCtx, workFunc)
		case kvstore.Deleted:
			workFunc := func(ctx context.Context, ctrlCtx shardworkers.WorkObj) error {
				var err error
				workCtx := ctrlCtx.(*orderCtx)
				eobj := workCtx.obj
				fobj, err := ct.findObject(kind, workCtx.GetKey())
				if err != nil {
					ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
					return err
				}
				obj := fobj.(*Order)
				ct.stats.Counter("Order_Deleted_Events").Inc()
				obj.Lock()
				err = orderHandler.OnOrderDelete(obj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
				}
				ct.delObject(kind, workCtx.GetKey())
				return nil
			}
			ctrlCtx := &orderCtx{event: evt.Type, obj: &Order{Order: *eobj, ctrler: ct}}
			ct.runFunction("Order", ctrlCtx, workFunc)
		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on Order watch channel", tp)
	}

	return nil
}

// diffOrder does a diff of Order objects between local cache and API server
func (ct *ctrlerCtx) diffOrder(apicl apiclient.Services) {
	opts := api.ListWatchOptions{}

	// get a list of all objects from API server
	objlist, err := apicl.BookstoreV1().Order().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Errorf("Error getting a list of objects. Err: %v", err)
		return
	}

	ct.logger.Infof("diffOrder(): OrderList returned %d objects", len(objlist))

	// build an object map
	objmap := make(map[string]*bookstore.Order)
	for _, obj := range objlist {
		objmap[obj.GetKey()] = obj
	}

	list, err := ct.Order().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Infof("Failed to get a list of objects. Err: %s", err)
		return
	}

	// if an object is in our local cache and not in API server, trigger delete for it
	for _, obj := range list {
		_, ok := objmap[obj.GetKey()]
		if !ok {
			ct.logger.Infof("diffOrder(): Deleting existing object %#v since its not in apiserver", obj.GetKey())
			evt := kvstore.WatchEvent{
				Type:   kvstore.Deleted,
				Key:    obj.GetKey(),
				Object: &obj.Order,
			}
			ct.handleOrderEvent(&evt)
		}
	}

	// trigger create event for all others
	for _, obj := range objlist {
		ct.logger.Infof("diffOrder(): Adding object %#v", obj.GetKey())
		evt := kvstore.WatchEvent{
			Type:   kvstore.Created,
			Key:    obj.GetKey(),
			Object: obj,
		}
		ct.handleOrderEvent(&evt)
	}
}

func (ct *ctrlerCtx) runOrderWatcher() {
	kind := "Order"

	ct.Lock()
	handler, ok := ct.handlers[kind]
	ct.Unlock()
	if !ok {
		ct.logger.Fatalf("Cant find the handler for %s", kind)
	}
	orderHandler := handler.(OrderHandler)

	opts := orderHandler.GetOrderWatchOptions()

	// if there is no API server to connect to, we are done
	if (ct.resolver == nil) || ct.apisrvURL == "" {
		return
	}

	// create context
	ctx, cancel := context.WithCancel(context.Background())
	ct.Lock()
	ct.watchCancel[kind] = cancel
	ct.Unlock()
	logger := ct.logger.WithContext("submodule", "OrderWatcher")

	// create a grpc client
	apiclt, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
	if err == nil {
		ct.diffOrder(apiclt)
	}

	// setup wait group
	ct.waitGrp.Add(1)

	// start a goroutine
	go func() {
		defer ct.waitGrp.Done()
		ct.stats.Counter("Order_Watch").Inc()
		defer ct.stats.Counter("Order_Watch").Dec()

		// loop forever
		for {
			// create a grpc client
			apicl, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
			if err != nil {
				logger.Warnf("Failed to connect to gRPC server [%s]\n", ct.apisrvURL)
				ct.stats.Counter("Order_ApiClientErr").Inc()
			} else {
				logger.Infof("API client connected {%+v}", apicl)

				// Order object watcher
				wt, werr := apicl.BookstoreV1().Order().Watch(ctx, opts)
				if werr != nil {
					select {
					case <-ctx.Done():
						logger.Infof("watch %s cancelled", kind)
						return
					default:
					}
					logger.Errorf("Failed to start %s watch (%s)\n", kind, werr)
					// wait for a second and retry connecting to api server
					apicl.Close()
					time.Sleep(time.Second)
					continue
				}
				ct.Lock()
				ct.watchers[kind] = wt
				ct.Unlock()

				// perform a diff with API server and local cache
				time.Sleep(time.Millisecond * 100)
				ct.diffOrder(apicl)

				// handle api server watch events
			innerLoop:
				for {
					// wait for events
					select {
					case evt, ok := <-wt.EventChan():
						if !ok {
							logger.Error("Error receiving from apisrv watcher")
							ct.stats.Counter("Order_WatchErrors").Inc()
							break innerLoop
						}

						// handle event in parallel
						ct.handleOrderEventParallel(evt)
					}
				}
				apicl.Close()
			}

			// if stop flag is set, we are done
			if ct.stoped {
				logger.Infof("Exiting API server watcher")
				return
			}

			// wait for a second and retry connecting to api server
			time.Sleep(time.Second)
		}
	}()
}

// WatchOrder starts watch on Order object
func (ct *ctrlerCtx) WatchOrder(handler OrderHandler) error {
	kind := "Order"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchers[kind]
	ct.Unlock()
	if ok {
		return fmt.Errorf("Order watcher already exists")
	}

	// save handler
	ct.Lock()
	ct.handlers[kind] = handler
	ct.Unlock()

	// run Order watcher in a go routine
	ct.runOrderWatcher()

	return nil
}

// StopWatchOrder stops watch on Order object
func (ct *ctrlerCtx) StopWatchOrder(handler OrderHandler) error {
	kind := "Order"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchers[kind]
	ct.Unlock()
	if !ok {
		return fmt.Errorf("Order watcher does not exist")
	}

	ct.Lock()
	cancel, _ := ct.watchCancel[kind]
	cancel()
	delete(ct.watchers, kind)
	delete(ct.watchCancel, kind)
	ct.Unlock()

	time.Sleep(100 * time.Millisecond)

	return nil
}

// OrderAPI returns
type OrderAPI interface {
	Create(obj *bookstore.Order) error
	SyncCreate(obj *bookstore.Order) error
	Update(obj *bookstore.Order) error
	SyncUpdate(obj *bookstore.Order) error
	Delete(obj *bookstore.Order) error
	Find(meta *api.ObjectMeta) (*Order, error)
	List(ctx context.Context, opts *api.ListWatchOptions) ([]*Order, error)
	Watch(handler OrderHandler) error
	StopWatch(handler OrderHandler) error
	Applydiscount(obj *bookstore.ApplyDiscountReq) (*bookstore.Order, error)
	RegisterLocalApplydiscountHandler(fn func(*bookstore.ApplyDiscountReq) (*bookstore.Order, error))
	SyncApplydiscount(obj *bookstore.ApplyDiscountReq) (*bookstore.Order, error)
	RegisterLocalSyncApplydiscountHandler(fn func(*bookstore.ApplyDiscountReq) (*bookstore.Order, error))
	Cleardiscount(obj *bookstore.ApplyDiscountReq) (*bookstore.Order, error)
	RegisterLocalCleardiscountHandler(fn func(*bookstore.ApplyDiscountReq) (*bookstore.Order, error))
	SyncCleardiscount(obj *bookstore.ApplyDiscountReq) (*bookstore.Order, error)
	RegisterLocalSyncCleardiscountHandler(fn func(*bookstore.ApplyDiscountReq) (*bookstore.Order, error))
}

// dummy struct that implements OrderAPI
type orderAPI struct {
	ct *ctrlerCtx

	localApplydiscountHandler     func(obj *bookstore.ApplyDiscountReq) (*bookstore.Order, error)
	localSyncApplydiscountHandler func(obj *bookstore.ApplyDiscountReq) (*bookstore.Order, error)
	localCleardiscountHandler     func(obj *bookstore.ApplyDiscountReq) (*bookstore.Order, error)
	localSyncCleardiscountHandler func(obj *bookstore.ApplyDiscountReq) (*bookstore.Order, error)
}

// Create creates Order object
func (api *orderAPI) Create(obj *bookstore.Order) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.BookstoreV1().Order().Create(context.Background(), obj)
		if err != nil && strings.Contains(err.Error(), "AlreadyExists") {
			_, err = apicl.BookstoreV1().Order().Update(context.Background(), obj)

		}
		return err
	}

	api.ct.handleOrderEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Created})
	return nil
}

// SyncCreate creates Order object and updates the cache
func (api *orderAPI) SyncCreate(obj *bookstore.Order) error {
	newObj := obj
	evtType := kvstore.Created
	var writeErr error
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		newObj, writeErr = apicl.BookstoreV1().Order().Create(context.Background(), obj)
		if writeErr != nil && strings.Contains(writeErr.Error(), "AlreadyExists") {
			newObj, writeErr = apicl.BookstoreV1().Order().Update(context.Background(), obj)
			evtType = kvstore.Updated
		}
	}

	if writeErr == nil {
		api.ct.handleOrderEvent(&kvstore.WatchEvent{Object: newObj, Type: evtType})
	}
	return writeErr
}

// Update triggers update on Order object
func (api *orderAPI) Update(obj *bookstore.Order) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.BookstoreV1().Order().Update(context.Background(), obj)
		return err
	}

	api.ct.handleOrderEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Updated})
	return nil
}

// SyncUpdate triggers update on Order object and updates the cache
func (api *orderAPI) SyncUpdate(obj *bookstore.Order) error {
	newObj := obj
	var writeErr error
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		newObj, writeErr = apicl.BookstoreV1().Order().Update(context.Background(), obj)
	}

	if writeErr == nil {
		api.ct.handleOrderEvent(&kvstore.WatchEvent{Object: newObj, Type: kvstore.Updated})
	}

	return writeErr
}

// Delete deletes Order object
func (api *orderAPI) Delete(obj *bookstore.Order) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.BookstoreV1().Order().Delete(context.Background(), &obj.ObjectMeta)
		return err
	}

	api.ct.handleOrderEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Deleted})
	return nil
}

// MakeKey generates a KV store key for the object
func (api *orderAPI) getFullKey(tenant, name string) string {
	if tenant != "" {
		return fmt.Sprint(globals.ConfigRootPrefix, "/", "bookstore", "/", "orders", "/", tenant, "/", name)
	}
	return fmt.Sprint(globals.ConfigRootPrefix, "/", "bookstore", "/", "orders", "/", name)
}

// Find returns an object by meta
func (api *orderAPI) Find(meta *api.ObjectMeta) (*Order, error) {
	// find the object
	obj, err := api.ct.FindObject("Order", meta)
	if err != nil {
		return nil, err
	}

	// asset type
	switch obj.(type) {
	case *Order:
		hobj := obj.(*Order)
		return hobj, nil
	default:
		return nil, errors.New("incorrect object type")
	}
}

// List returns a list of all Order objects
func (api *orderAPI) List(ctx context.Context, opts *api.ListWatchOptions) ([]*Order, error) {
	var objlist []*Order
	objs, err := api.ct.List("Order", ctx, opts)

	if err != nil {
		return nil, err
	}

	for _, obj := range objs {
		switch tp := obj.(type) {
		case *Order:
			eobj := obj.(*Order)
			objlist = append(objlist, eobj)
		default:
			log.Fatalf("Got invalid object type %v while looking for Order", tp)
		}
	}

	return objlist, nil
}

// Watch sets up a event handlers for Order object
func (api *orderAPI) Watch(handler OrderHandler) error {
	api.ct.startWorkerPool("Order")
	return api.ct.WatchOrder(handler)
}

// StopWatch stop watch for Tenant Order object
func (api *orderAPI) StopWatch(handler OrderHandler) error {
	api.ct.Lock()
	api.ct.workPools["Order"].Stop()
	api.ct.Unlock()
	return api.ct.StopWatchOrder(handler)
}

// Applydiscount is an API action
func (api *orderAPI) Applydiscount(obj *bookstore.ApplyDiscountReq) (*bookstore.Order, error) {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return nil, err
		}

		return apicl.BookstoreV1().Order().Applydiscount(context.Background(), obj)
	}
	if api.localApplydiscountHandler != nil {
		return api.localApplydiscountHandler(obj)
	}
	return nil, fmt.Errorf("Action not implemented for local operation")
}

// SyncApplydiscount is an API action. Cache will be updated
func (api *orderAPI) SyncApplydiscount(obj *bookstore.ApplyDiscountReq) (*bookstore.Order, error) {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return nil, err
		}

		ret, err := apicl.BookstoreV1().Order().Applydiscount(context.Background(), obj)
		if err != nil {
			return ret, err
		}
		// Perform Get to update the cache
		newObj, err := apicl.BookstoreV1().Order().Get(context.Background(), obj.GetObjectMeta())
		if err == nil {
			api.ct.handleOrderEvent(&kvstore.WatchEvent{Object: newObj, Type: kvstore.Updated})
		}
		return ret, err
	}
	if api.localSyncApplydiscountHandler != nil {
		return api.localSyncApplydiscountHandler(obj)
	}
	return nil, fmt.Errorf("Action not implemented for local operation")
}

func (api *orderAPI) RegisterLocalApplydiscountHandler(fn func(*bookstore.ApplyDiscountReq) (*bookstore.Order, error)) {
	api.localApplydiscountHandler = fn
}

func (api *orderAPI) RegisterLocalSyncApplydiscountHandler(fn func(*bookstore.ApplyDiscountReq) (*bookstore.Order, error)) {
	api.localSyncApplydiscountHandler = fn
}

// Cleardiscount is an API action
func (api *orderAPI) Cleardiscount(obj *bookstore.ApplyDiscountReq) (*bookstore.Order, error) {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return nil, err
		}

		return apicl.BookstoreV1().Order().Cleardiscount(context.Background(), obj)
	}
	if api.localCleardiscountHandler != nil {
		return api.localCleardiscountHandler(obj)
	}
	return nil, fmt.Errorf("Action not implemented for local operation")
}

// SyncCleardiscount is an API action. Cache will be updated
func (api *orderAPI) SyncCleardiscount(obj *bookstore.ApplyDiscountReq) (*bookstore.Order, error) {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return nil, err
		}

		ret, err := apicl.BookstoreV1().Order().Cleardiscount(context.Background(), obj)
		if err != nil {
			return ret, err
		}
		// Perform Get to update the cache
		newObj, err := apicl.BookstoreV1().Order().Get(context.Background(), obj.GetObjectMeta())
		if err == nil {
			api.ct.handleOrderEvent(&kvstore.WatchEvent{Object: newObj, Type: kvstore.Updated})
		}
		return ret, err
	}
	if api.localSyncCleardiscountHandler != nil {
		return api.localSyncCleardiscountHandler(obj)
	}
	return nil, fmt.Errorf("Action not implemented for local operation")
}

func (api *orderAPI) RegisterLocalCleardiscountHandler(fn func(*bookstore.ApplyDiscountReq) (*bookstore.Order, error)) {
	api.localCleardiscountHandler = fn
}

func (api *orderAPI) RegisterLocalSyncCleardiscountHandler(fn func(*bookstore.ApplyDiscountReq) (*bookstore.Order, error)) {
	api.localSyncCleardiscountHandler = fn
}

// Order returns OrderAPI
func (ct *ctrlerCtx) Order() OrderAPI {
	kind := "Order"
	if _, ok := ct.apiInfMap[kind]; !ok {
		s := &orderAPI{ct: ct}
		ct.apiInfMap[kind] = s
	}
	return ct.apiInfMap[kind].(*orderAPI)
}

// Book is a wrapper object that implements additional functionality
type Book struct {
	sync.Mutex
	bookstore.Book
	HandlerCtx interface{} // additional state handlers can store
	ctrler     *ctrlerCtx  // reference back to the controller instance
}

func (obj *Book) Write() error {
	// if there is no API server to connect to, we are done
	if (obj.ctrler == nil) || (obj.ctrler.resolver == nil) || obj.ctrler.apisrvURL == "" {
		return nil
	}

	apicl, err := obj.ctrler.apiClient()
	if err != nil {
		obj.ctrler.logger.Errorf("Error creating API server clent. Err: %v", err)
		return err
	}

	obj.ctrler.stats.Counter("Book_Writes").Inc()

	// write to api server
	if obj.ObjectMeta.ResourceVersion != "" {
		// update it
		for i := 0; i < maxApisrvWriteRetry; i++ {
			_, err = apicl.BookstoreV1().Book().UpdateStatus(context.Background(), &obj.Book)
			if err == nil {
				break
			}
			time.Sleep(time.Millisecond * 100)
		}
	} else {
		//  create
		_, err = apicl.BookstoreV1().Book().Create(context.Background(), &obj.Book)
	}

	return nil
}

// BookHandler is the event handler for Book object
type BookHandler interface {
	OnBookCreate(obj *Book) error
	OnBookUpdate(oldObj *Book, newObj *bookstore.Book) error
	OnBookDelete(obj *Book) error
	GetBookWatchOptions() *api.ListWatchOptions
}

// OnBookCreate is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnBookCreate(obj *Book) error {
	log.Info("OnBookCreate is not implemented")
	return nil
}

// OnBookUpdate is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnBookUpdate(oldObj *Book, newObj *bookstore.Book) error {
	log.Info("OnBookUpdate is not implemented")
	return nil
}

// OnBookDelete is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnBookDelete(obj *Book) error {
	log.Info("OnBookDelete is not implemented")
	return nil
}

// GetBookWatchOptions is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) GetBookWatchOptions() *api.ListWatchOptions {
	log.Info("GetBookWatchOptions is not implemented")
	opts := &api.ListWatchOptions{}
	return opts
}

// handleBookEvent handles Book events from watcher
func (ct *ctrlerCtx) handleBookEvent(evt *kvstore.WatchEvent) error {

	if ct.objResolver == nil {
		return ct.handleBookEventNoResolver(evt)
	}

	switch tp := evt.Object.(type) {
	case *bookstore.Book:
		eobj := evt.Object.(*bookstore.Book)
		kind := "Book"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ctx := &bookCtx{event: evt.Type,
			obj: &Book{Book: *eobj, ctrler: ct}}

		var err error
		switch evt.Type {
		case kvstore.Created:
			err = ct.processAdd(ctx)
		case kvstore.Updated:
			err = ct.processUpdate(ctx)
		case kvstore.Deleted:
			err = ct.processDelete(ctx)
		}
		return err
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on Book watch channel", tp)
	}

	return nil
}

// handleBookEventNoResolver handles Book events from watcher
func (ct *ctrlerCtx) handleBookEventNoResolver(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *bookstore.Book:
		eobj := evt.Object.(*bookstore.Book)
		kind := "Book"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		bookHandler := handler.(BookHandler)
		// handle based on event type
		ctrlCtx := &bookCtx{event: evt.Type, obj: &Book{Book: *eobj, ctrler: ct}}
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			fobj, err := ct.getObject(kind, ctrlCtx.GetKey())
			if err != nil {
				ct.addObject(ctrlCtx)
				ct.stats.Counter("Book_Created_Events").Inc()

				// call the event handler
				ctrlCtx.Lock()
				err = bookHandler.OnBookCreate(ctrlCtx.obj)
				ctrlCtx.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctrlCtx.obj, err)
					ct.delObject(kind, ctrlCtx.GetKey())
					return err
				}
			} else {
				fResVer, fErr := strconv.ParseInt(fobj.GetResourceVersion(), 10, 64)
				eResVer, eErr := strconv.ParseInt(eobj.GetResourceVersion(), 10, 64)
				if ct.resolver != nil && fErr == nil && eErr == nil && fResVer >= eResVer {
					// Event already processed.
					ct.logger.Infof("Skipping update due to old resource version")
					return nil
				}
				ctrlCtx := fobj.(*bookCtx)
				ct.stats.Counter("Book_Updated_Events").Inc()
				ctrlCtx.Lock()
				p := bookstore.Book{Spec: eobj.Spec,
					ObjectMeta: eobj.ObjectMeta,
					TypeMeta:   eobj.TypeMeta,
					Status:     eobj.Status}

				err = bookHandler.OnBookUpdate(ctrlCtx.obj, &p)
				ctrlCtx.obj.Book = *eobj
				ctrlCtx.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctrlCtx.obj, err)
					return err
				}

			}
		case kvstore.Deleted:
			ctrlCtx := &bookCtx{event: evt.Type, obj: &Book{Book: *eobj, ctrler: ct}}
			fobj, err := ct.findObject(kind, ctrlCtx.GetKey())
			if err != nil {
				ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
				return err
			}

			obj := fobj.(*Book)
			ct.stats.Counter("Book_Deleted_Events").Inc()
			obj.Lock()
			err = bookHandler.OnBookDelete(obj)
			obj.Unlock()
			if err != nil {
				ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
			}
			ct.delObject(kind, ctrlCtx.GetKey())
			return nil

		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on Book watch channel", tp)
	}

	return nil
}

type bookCtx struct {
	ctkitBaseCtx
	event kvstore.WatchEventType
	obj   *Book //
	//   newObj     *bookstore.Book //update
	newObj *bookCtx //update
}

func (ctx *bookCtx) References() map[string]apiintf.ReferenceObj {
	resp := make(map[string]apiintf.ReferenceObj)
	ctx.obj.References(ctx.obj.GetObjectMeta().Name, ctx.obj.GetObjectMeta().Namespace, resp)
	return resp
}

func (ctx *bookCtx) GetKey() string {
	return ctx.obj.MakeKey("bookstore")
}

func (ctx *bookCtx) GetKind() string {
	return ctx.obj.GetKind()
}

func (ctx *bookCtx) GetResourceVersion() string {
	return ctx.obj.GetResourceVersion()
}

func (ctx *bookCtx) SetEvent(event kvstore.WatchEventType) {
	ctx.event = event
}

func (ctx *bookCtx) SetNewObj(newObj apiintf.CtkitObject) {
	if newObj == nil {
		ctx.newObj = nil
	} else {
		ctx.newObj = newObj.(*bookCtx)
		ctx.newObj.obj.HandlerCtx = ctx.obj.HandlerCtx
	}
}

func (ctx *bookCtx) GetNewObj() apiintf.CtkitObject {
	return ctx.newObj
}

func (ctx *bookCtx) Copy(obj apiintf.CtkitObject) {
	ctx.obj.Book = obj.(*bookCtx).obj.Book
}

func (ctx *bookCtx) Lock() {
	ctx.obj.Lock()
}

func (ctx *bookCtx) Unlock() {
	ctx.obj.Unlock()
}

func (ctx *bookCtx) GetObjectMeta() *api.ObjectMeta {
	return ctx.obj.GetObjectMeta()
}

func (ctx *bookCtx) RuntimeObject() runtime.Object {
	var v interface{}
	v = ctx.obj
	return v.(runtime.Object)
}

func (ctx *bookCtx) WorkFunc(context context.Context) error {
	var err error
	evt := ctx.event
	ct := ctx.obj.ctrler
	kind := "Book"
	ct.Lock()
	handler, ok := ct.handlers[kind]
	ct.Unlock()
	if !ok {
		ct.logger.Fatalf("Cant find the handler for %s", kind)
	}
	bookHandler := handler.(BookHandler)
	switch evt {
	case kvstore.Created:
		ctx.obj.Lock()
		err = bookHandler.OnBookCreate(ctx.obj)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctx.obj, err)
			ctx.SetEvent(kvstore.Deleted)
		}
	case kvstore.Updated:
		ct.stats.Counter("Book_Updated_Events").Inc()
		ctx.obj.Lock()
		p := bookstore.Book{Spec: ctx.newObj.obj.Spec,
			ObjectMeta: ctx.newObj.obj.ObjectMeta,
			TypeMeta:   ctx.newObj.obj.TypeMeta,
			Status:     ctx.newObj.obj.Status}
		err = bookHandler.OnBookUpdate(ctx.obj, &p)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctx.obj, err)
			ctx.SetEvent(kvstore.Deleted)
		}
	case kvstore.Deleted:
		ctx.obj.Lock()
		err = bookHandler.OnBookDelete(ctx.obj)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error deleting %s %+v. Err: %v", kind, ctx.obj, err)
		}
	}
	ct.resolveObject(ctx.event, ctx)
	return nil
}

// handleBookEventParallel handles Book events from watcher
func (ct *ctrlerCtx) handleBookEventParallel(evt *kvstore.WatchEvent) error {

	if ct.objResolver == nil {
		return ct.handleBookEventParallelWithNoResolver(evt)
	}

	switch tp := evt.Object.(type) {
	case *bookstore.Book:
		eobj := evt.Object.(*bookstore.Book)
		kind := "Book"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ctx := &bookCtx{event: evt.Type, obj: &Book{Book: *eobj, ctrler: ct}}

		var err error
		switch evt.Type {
		case kvstore.Created:
			err = ct.processAdd(ctx)
		case kvstore.Updated:
			err = ct.processUpdate(ctx)
		case kvstore.Deleted:
			err = ct.processDelete(ctx)
		}
		return err
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on Book watch channel", tp)
	}

	return nil
}

// handleBookEventParallel handles Book events from watcher
func (ct *ctrlerCtx) handleBookEventParallelWithNoResolver(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *bookstore.Book:
		eobj := evt.Object.(*bookstore.Book)
		kind := "Book"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		bookHandler := handler.(BookHandler)
		// handle based on event type
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			workFunc := func(ctx context.Context, ctrlCtx shardworkers.WorkObj) error {
				var err error
				workCtx := ctrlCtx.(*bookCtx)
				eobj := workCtx.obj
				fobj, err := ct.getObject(kind, workCtx.GetKey())
				if err != nil {
					ct.addObject(workCtx)
					ct.stats.Counter("Book_Created_Events").Inc()
					eobj.Lock()
					err = bookHandler.OnBookCreate(eobj)
					eobj.Unlock()
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, eobj, err)
						ct.delObject(kind, workCtx.GetKey())
					}
				} else {
					workCtx := fobj.(*bookCtx)
					obj := workCtx.obj
					ct.stats.Counter("Book_Updated_Events").Inc()
					obj.Lock()
					p := bookstore.Book{Spec: eobj.Spec,
						ObjectMeta: eobj.ObjectMeta,
						TypeMeta:   eobj.TypeMeta,
						Status:     eobj.Status}

					err = bookHandler.OnBookUpdate(obj, &p)
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					} else {
						workCtx.obj.Book = p
					}
					obj.Unlock()
				}
				return err
			}
			ctrlCtx := &bookCtx{event: evt.Type, obj: &Book{Book: *eobj, ctrler: ct}}
			ct.runFunction("Book", ctrlCtx, workFunc)
		case kvstore.Deleted:
			workFunc := func(ctx context.Context, ctrlCtx shardworkers.WorkObj) error {
				var err error
				workCtx := ctrlCtx.(*bookCtx)
				eobj := workCtx.obj
				fobj, err := ct.findObject(kind, workCtx.GetKey())
				if err != nil {
					ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
					return err
				}
				obj := fobj.(*Book)
				ct.stats.Counter("Book_Deleted_Events").Inc()
				obj.Lock()
				err = bookHandler.OnBookDelete(obj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
				}
				ct.delObject(kind, workCtx.GetKey())
				return nil
			}
			ctrlCtx := &bookCtx{event: evt.Type, obj: &Book{Book: *eobj, ctrler: ct}}
			ct.runFunction("Book", ctrlCtx, workFunc)
		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on Book watch channel", tp)
	}

	return nil
}

// diffBook does a diff of Book objects between local cache and API server
func (ct *ctrlerCtx) diffBook(apicl apiclient.Services) {
	opts := api.ListWatchOptions{}

	// get a list of all objects from API server
	objlist, err := apicl.BookstoreV1().Book().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Errorf("Error getting a list of objects. Err: %v", err)
		return
	}

	ct.logger.Infof("diffBook(): BookList returned %d objects", len(objlist))

	// build an object map
	objmap := make(map[string]*bookstore.Book)
	for _, obj := range objlist {
		objmap[obj.GetKey()] = obj
	}

	list, err := ct.Book().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Infof("Failed to get a list of objects. Err: %s", err)
		return
	}

	// if an object is in our local cache and not in API server, trigger delete for it
	for _, obj := range list {
		_, ok := objmap[obj.GetKey()]
		if !ok {
			ct.logger.Infof("diffBook(): Deleting existing object %#v since its not in apiserver", obj.GetKey())
			evt := kvstore.WatchEvent{
				Type:   kvstore.Deleted,
				Key:    obj.GetKey(),
				Object: &obj.Book,
			}
			ct.handleBookEvent(&evt)
		}
	}

	// trigger create event for all others
	for _, obj := range objlist {
		ct.logger.Infof("diffBook(): Adding object %#v", obj.GetKey())
		evt := kvstore.WatchEvent{
			Type:   kvstore.Created,
			Key:    obj.GetKey(),
			Object: obj,
		}
		ct.handleBookEvent(&evt)
	}
}

func (ct *ctrlerCtx) runBookWatcher() {
	kind := "Book"

	ct.Lock()
	handler, ok := ct.handlers[kind]
	ct.Unlock()
	if !ok {
		ct.logger.Fatalf("Cant find the handler for %s", kind)
	}
	bookHandler := handler.(BookHandler)

	opts := bookHandler.GetBookWatchOptions()

	// if there is no API server to connect to, we are done
	if (ct.resolver == nil) || ct.apisrvURL == "" {
		return
	}

	// create context
	ctx, cancel := context.WithCancel(context.Background())
	ct.Lock()
	ct.watchCancel[kind] = cancel
	ct.Unlock()
	logger := ct.logger.WithContext("submodule", "BookWatcher")

	// create a grpc client
	apiclt, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
	if err == nil {
		ct.diffBook(apiclt)
	}

	// setup wait group
	ct.waitGrp.Add(1)

	// start a goroutine
	go func() {
		defer ct.waitGrp.Done()
		ct.stats.Counter("Book_Watch").Inc()
		defer ct.stats.Counter("Book_Watch").Dec()

		// loop forever
		for {
			// create a grpc client
			apicl, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
			if err != nil {
				logger.Warnf("Failed to connect to gRPC server [%s]\n", ct.apisrvURL)
				ct.stats.Counter("Book_ApiClientErr").Inc()
			} else {
				logger.Infof("API client connected {%+v}", apicl)

				// Book object watcher
				wt, werr := apicl.BookstoreV1().Book().Watch(ctx, opts)
				if werr != nil {
					select {
					case <-ctx.Done():
						logger.Infof("watch %s cancelled", kind)
						return
					default:
					}
					logger.Errorf("Failed to start %s watch (%s)\n", kind, werr)
					// wait for a second and retry connecting to api server
					apicl.Close()
					time.Sleep(time.Second)
					continue
				}
				ct.Lock()
				ct.watchers[kind] = wt
				ct.Unlock()

				// perform a diff with API server and local cache
				time.Sleep(time.Millisecond * 100)
				ct.diffBook(apicl)

				// handle api server watch events
			innerLoop:
				for {
					// wait for events
					select {
					case evt, ok := <-wt.EventChan():
						if !ok {
							logger.Error("Error receiving from apisrv watcher")
							ct.stats.Counter("Book_WatchErrors").Inc()
							break innerLoop
						}

						// handle event in parallel
						ct.handleBookEventParallel(evt)
					}
				}
				apicl.Close()
			}

			// if stop flag is set, we are done
			if ct.stoped {
				logger.Infof("Exiting API server watcher")
				return
			}

			// wait for a second and retry connecting to api server
			time.Sleep(time.Second)
		}
	}()
}

// WatchBook starts watch on Book object
func (ct *ctrlerCtx) WatchBook(handler BookHandler) error {
	kind := "Book"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchers[kind]
	ct.Unlock()
	if ok {
		return fmt.Errorf("Book watcher already exists")
	}

	// save handler
	ct.Lock()
	ct.handlers[kind] = handler
	ct.Unlock()

	// run Book watcher in a go routine
	ct.runBookWatcher()

	return nil
}

// StopWatchBook stops watch on Book object
func (ct *ctrlerCtx) StopWatchBook(handler BookHandler) error {
	kind := "Book"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchers[kind]
	ct.Unlock()
	if !ok {
		return fmt.Errorf("Book watcher does not exist")
	}

	ct.Lock()
	cancel, _ := ct.watchCancel[kind]
	cancel()
	delete(ct.watchers, kind)
	delete(ct.watchCancel, kind)
	ct.Unlock()

	time.Sleep(100 * time.Millisecond)

	return nil
}

// BookAPI returns
type BookAPI interface {
	Create(obj *bookstore.Book) error
	SyncCreate(obj *bookstore.Book) error
	Update(obj *bookstore.Book) error
	SyncUpdate(obj *bookstore.Book) error
	Delete(obj *bookstore.Book) error
	Find(meta *api.ObjectMeta) (*Book, error)
	List(ctx context.Context, opts *api.ListWatchOptions) ([]*Book, error)
	Watch(handler BookHandler) error
	StopWatch(handler BookHandler) error
	Restock(obj *bookstore.RestockRequest) (*bookstore.RestockResponse, error)
	RegisterLocalRestockHandler(fn func(*bookstore.RestockRequest) (*bookstore.RestockResponse, error))
	SyncRestock(obj *bookstore.RestockRequest) (*bookstore.RestockResponse, error)
	RegisterLocalSyncRestockHandler(fn func(*bookstore.RestockRequest) (*bookstore.RestockResponse, error))
}

// dummy struct that implements BookAPI
type bookAPI struct {
	ct *ctrlerCtx

	localRestockHandler     func(obj *bookstore.RestockRequest) (*bookstore.RestockResponse, error)
	localSyncRestockHandler func(obj *bookstore.RestockRequest) (*bookstore.RestockResponse, error)
}

// Create creates Book object
func (api *bookAPI) Create(obj *bookstore.Book) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.BookstoreV1().Book().Create(context.Background(), obj)
		if err != nil && strings.Contains(err.Error(), "AlreadyExists") {
			_, err = apicl.BookstoreV1().Book().Update(context.Background(), obj)

		}
		return err
	}

	api.ct.handleBookEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Created})
	return nil
}

// SyncCreate creates Book object and updates the cache
func (api *bookAPI) SyncCreate(obj *bookstore.Book) error {
	newObj := obj
	evtType := kvstore.Created
	var writeErr error
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		newObj, writeErr = apicl.BookstoreV1().Book().Create(context.Background(), obj)
		if writeErr != nil && strings.Contains(writeErr.Error(), "AlreadyExists") {
			newObj, writeErr = apicl.BookstoreV1().Book().Update(context.Background(), obj)
			evtType = kvstore.Updated
		}
	}

	if writeErr == nil {
		api.ct.handleBookEvent(&kvstore.WatchEvent{Object: newObj, Type: evtType})
	}
	return writeErr
}

// Update triggers update on Book object
func (api *bookAPI) Update(obj *bookstore.Book) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.BookstoreV1().Book().Update(context.Background(), obj)
		return err
	}

	api.ct.handleBookEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Updated})
	return nil
}

// SyncUpdate triggers update on Book object and updates the cache
func (api *bookAPI) SyncUpdate(obj *bookstore.Book) error {
	newObj := obj
	var writeErr error
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		newObj, writeErr = apicl.BookstoreV1().Book().Update(context.Background(), obj)
	}

	if writeErr == nil {
		api.ct.handleBookEvent(&kvstore.WatchEvent{Object: newObj, Type: kvstore.Updated})
	}

	return writeErr
}

// Delete deletes Book object
func (api *bookAPI) Delete(obj *bookstore.Book) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.BookstoreV1().Book().Delete(context.Background(), &obj.ObjectMeta)
		return err
	}

	api.ct.handleBookEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Deleted})
	return nil
}

// MakeKey generates a KV store key for the object
func (api *bookAPI) getFullKey(tenant, name string) string {
	if tenant != "" {
		return fmt.Sprint(globals.ConfigRootPrefix, "/", "bookstore", "/", "books", "/", tenant, "/", name)
	}
	return fmt.Sprint(globals.ConfigRootPrefix, "/", "bookstore", "/", "books", "/", name)
}

// Find returns an object by meta
func (api *bookAPI) Find(meta *api.ObjectMeta) (*Book, error) {
	// find the object
	obj, err := api.ct.FindObject("Book", meta)
	if err != nil {
		return nil, err
	}

	// asset type
	switch obj.(type) {
	case *Book:
		hobj := obj.(*Book)
		return hobj, nil
	default:
		return nil, errors.New("incorrect object type")
	}
}

// List returns a list of all Book objects
func (api *bookAPI) List(ctx context.Context, opts *api.ListWatchOptions) ([]*Book, error) {
	var objlist []*Book
	objs, err := api.ct.List("Book", ctx, opts)

	if err != nil {
		return nil, err
	}

	for _, obj := range objs {
		switch tp := obj.(type) {
		case *Book:
			eobj := obj.(*Book)
			objlist = append(objlist, eobj)
		default:
			log.Fatalf("Got invalid object type %v while looking for Book", tp)
		}
	}

	return objlist, nil
}

// Watch sets up a event handlers for Book object
func (api *bookAPI) Watch(handler BookHandler) error {
	api.ct.startWorkerPool("Book")
	return api.ct.WatchBook(handler)
}

// StopWatch stop watch for Tenant Book object
func (api *bookAPI) StopWatch(handler BookHandler) error {
	api.ct.Lock()
	api.ct.workPools["Book"].Stop()
	api.ct.Unlock()
	return api.ct.StopWatchBook(handler)
}

// Restock is an API action
func (api *bookAPI) Restock(obj *bookstore.RestockRequest) (*bookstore.RestockResponse, error) {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return nil, err
		}

		return apicl.BookstoreV1().Book().Restock(context.Background(), obj)
	}
	if api.localRestockHandler != nil {
		return api.localRestockHandler(obj)
	}
	return nil, fmt.Errorf("Action not implemented for local operation")
}

// SyncRestock is an API action. Cache will be updated
func (api *bookAPI) SyncRestock(obj *bookstore.RestockRequest) (*bookstore.RestockResponse, error) {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return nil, err
		}

		ret, err := apicl.BookstoreV1().Book().Restock(context.Background(), obj)
		if err != nil {
			return ret, err
		}
		// Perform Get to update the cache
		newObj, err := apicl.BookstoreV1().Book().Get(context.Background(), obj.GetObjectMeta())
		if err == nil {
			api.ct.handleBookEvent(&kvstore.WatchEvent{Object: newObj, Type: kvstore.Updated})
		}
		return ret, err
	}
	if api.localSyncRestockHandler != nil {
		return api.localSyncRestockHandler(obj)
	}
	return nil, fmt.Errorf("Action not implemented for local operation")
}

func (api *bookAPI) RegisterLocalRestockHandler(fn func(*bookstore.RestockRequest) (*bookstore.RestockResponse, error)) {
	api.localRestockHandler = fn
}

func (api *bookAPI) RegisterLocalSyncRestockHandler(fn func(*bookstore.RestockRequest) (*bookstore.RestockResponse, error)) {
	api.localSyncRestockHandler = fn
}

// Book returns BookAPI
func (ct *ctrlerCtx) Book() BookAPI {
	kind := "Book"
	if _, ok := ct.apiInfMap[kind]; !ok {
		s := &bookAPI{ct: ct}
		ct.apiInfMap[kind] = s
	}
	return ct.apiInfMap[kind].(*bookAPI)
}

// Publisher is a wrapper object that implements additional functionality
type Publisher struct {
	sync.Mutex
	bookstore.Publisher
	HandlerCtx interface{} // additional state handlers can store
	ctrler     *ctrlerCtx  // reference back to the controller instance
}

func (obj *Publisher) Write() error {
	// if there is no API server to connect to, we are done
	if (obj.ctrler == nil) || (obj.ctrler.resolver == nil) || obj.ctrler.apisrvURL == "" {
		return nil
	}

	apicl, err := obj.ctrler.apiClient()
	if err != nil {
		obj.ctrler.logger.Errorf("Error creating API server clent. Err: %v", err)
		return err
	}

	obj.ctrler.stats.Counter("Publisher_Writes").Inc()

	// write to api server
	if obj.ObjectMeta.ResourceVersion != "" {
		// update it
		for i := 0; i < maxApisrvWriteRetry; i++ {
			_, err = apicl.BookstoreV1().Publisher().UpdateStatus(context.Background(), &obj.Publisher)
			if err == nil {
				break
			}
			time.Sleep(time.Millisecond * 100)
		}
	} else {
		//  create
		_, err = apicl.BookstoreV1().Publisher().Create(context.Background(), &obj.Publisher)
	}

	return nil
}

// PublisherHandler is the event handler for Publisher object
type PublisherHandler interface {
	OnPublisherCreate(obj *Publisher) error
	OnPublisherUpdate(oldObj *Publisher, newObj *bookstore.Publisher) error
	OnPublisherDelete(obj *Publisher) error
	GetPublisherWatchOptions() *api.ListWatchOptions
}

// OnPublisherCreate is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnPublisherCreate(obj *Publisher) error {
	log.Info("OnPublisherCreate is not implemented")
	return nil
}

// OnPublisherUpdate is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnPublisherUpdate(oldObj *Publisher, newObj *bookstore.Publisher) error {
	log.Info("OnPublisherUpdate is not implemented")
	return nil
}

// OnPublisherDelete is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnPublisherDelete(obj *Publisher) error {
	log.Info("OnPublisherDelete is not implemented")
	return nil
}

// GetPublisherWatchOptions is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) GetPublisherWatchOptions() *api.ListWatchOptions {
	log.Info("GetPublisherWatchOptions is not implemented")
	opts := &api.ListWatchOptions{}
	return opts
}

// handlePublisherEvent handles Publisher events from watcher
func (ct *ctrlerCtx) handlePublisherEvent(evt *kvstore.WatchEvent) error {

	if ct.objResolver == nil {
		return ct.handlePublisherEventNoResolver(evt)
	}

	switch tp := evt.Object.(type) {
	case *bookstore.Publisher:
		eobj := evt.Object.(*bookstore.Publisher)
		kind := "Publisher"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ctx := &publisherCtx{event: evt.Type,
			obj: &Publisher{Publisher: *eobj, ctrler: ct}}

		var err error
		switch evt.Type {
		case kvstore.Created:
			err = ct.processAdd(ctx)
		case kvstore.Updated:
			err = ct.processUpdate(ctx)
		case kvstore.Deleted:
			err = ct.processDelete(ctx)
		}
		return err
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on Publisher watch channel", tp)
	}

	return nil
}

// handlePublisherEventNoResolver handles Publisher events from watcher
func (ct *ctrlerCtx) handlePublisherEventNoResolver(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *bookstore.Publisher:
		eobj := evt.Object.(*bookstore.Publisher)
		kind := "Publisher"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		publisherHandler := handler.(PublisherHandler)
		// handle based on event type
		ctrlCtx := &publisherCtx{event: evt.Type, obj: &Publisher{Publisher: *eobj, ctrler: ct}}
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			fobj, err := ct.getObject(kind, ctrlCtx.GetKey())
			if err != nil {
				ct.addObject(ctrlCtx)
				ct.stats.Counter("Publisher_Created_Events").Inc()

				// call the event handler
				ctrlCtx.Lock()
				err = publisherHandler.OnPublisherCreate(ctrlCtx.obj)
				ctrlCtx.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctrlCtx.obj, err)
					ct.delObject(kind, ctrlCtx.GetKey())
					return err
				}
			} else {
				fResVer, fErr := strconv.ParseInt(fobj.GetResourceVersion(), 10, 64)
				eResVer, eErr := strconv.ParseInt(eobj.GetResourceVersion(), 10, 64)
				if ct.resolver != nil && fErr == nil && eErr == nil && fResVer >= eResVer {
					// Event already processed.
					ct.logger.Infof("Skipping update due to old resource version")
					return nil
				}
				ctrlCtx := fobj.(*publisherCtx)
				ct.stats.Counter("Publisher_Updated_Events").Inc()
				ctrlCtx.Lock()
				p := bookstore.Publisher{Spec: eobj.Spec,
					ObjectMeta: eobj.ObjectMeta,
					TypeMeta:   eobj.TypeMeta,
					Status:     eobj.Status}

				err = publisherHandler.OnPublisherUpdate(ctrlCtx.obj, &p)
				ctrlCtx.obj.Publisher = *eobj
				ctrlCtx.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctrlCtx.obj, err)
					return err
				}

			}
		case kvstore.Deleted:
			ctrlCtx := &publisherCtx{event: evt.Type, obj: &Publisher{Publisher: *eobj, ctrler: ct}}
			fobj, err := ct.findObject(kind, ctrlCtx.GetKey())
			if err != nil {
				ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
				return err
			}

			obj := fobj.(*Publisher)
			ct.stats.Counter("Publisher_Deleted_Events").Inc()
			obj.Lock()
			err = publisherHandler.OnPublisherDelete(obj)
			obj.Unlock()
			if err != nil {
				ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
			}
			ct.delObject(kind, ctrlCtx.GetKey())
			return nil

		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on Publisher watch channel", tp)
	}

	return nil
}

type publisherCtx struct {
	ctkitBaseCtx
	event kvstore.WatchEventType
	obj   *Publisher //
	//   newObj     *bookstore.Publisher //update
	newObj *publisherCtx //update
}

func (ctx *publisherCtx) References() map[string]apiintf.ReferenceObj {
	resp := make(map[string]apiintf.ReferenceObj)
	ctx.obj.References(ctx.obj.GetObjectMeta().Name, ctx.obj.GetObjectMeta().Namespace, resp)
	return resp
}

func (ctx *publisherCtx) GetKey() string {
	return ctx.obj.MakeKey("bookstore")
}

func (ctx *publisherCtx) GetKind() string {
	return ctx.obj.GetKind()
}

func (ctx *publisherCtx) GetResourceVersion() string {
	return ctx.obj.GetResourceVersion()
}

func (ctx *publisherCtx) SetEvent(event kvstore.WatchEventType) {
	ctx.event = event
}

func (ctx *publisherCtx) SetNewObj(newObj apiintf.CtkitObject) {
	if newObj == nil {
		ctx.newObj = nil
	} else {
		ctx.newObj = newObj.(*publisherCtx)
		ctx.newObj.obj.HandlerCtx = ctx.obj.HandlerCtx
	}
}

func (ctx *publisherCtx) GetNewObj() apiintf.CtkitObject {
	return ctx.newObj
}

func (ctx *publisherCtx) Copy(obj apiintf.CtkitObject) {
	ctx.obj.Publisher = obj.(*publisherCtx).obj.Publisher
}

func (ctx *publisherCtx) Lock() {
	ctx.obj.Lock()
}

func (ctx *publisherCtx) Unlock() {
	ctx.obj.Unlock()
}

func (ctx *publisherCtx) GetObjectMeta() *api.ObjectMeta {
	return ctx.obj.GetObjectMeta()
}

func (ctx *publisherCtx) RuntimeObject() runtime.Object {
	var v interface{}
	v = ctx.obj
	return v.(runtime.Object)
}

func (ctx *publisherCtx) WorkFunc(context context.Context) error {
	var err error
	evt := ctx.event
	ct := ctx.obj.ctrler
	kind := "Publisher"
	ct.Lock()
	handler, ok := ct.handlers[kind]
	ct.Unlock()
	if !ok {
		ct.logger.Fatalf("Cant find the handler for %s", kind)
	}
	publisherHandler := handler.(PublisherHandler)
	switch evt {
	case kvstore.Created:
		ctx.obj.Lock()
		err = publisherHandler.OnPublisherCreate(ctx.obj)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctx.obj, err)
			ctx.SetEvent(kvstore.Deleted)
		}
	case kvstore.Updated:
		ct.stats.Counter("Publisher_Updated_Events").Inc()
		ctx.obj.Lock()
		p := bookstore.Publisher{Spec: ctx.newObj.obj.Spec,
			ObjectMeta: ctx.newObj.obj.ObjectMeta,
			TypeMeta:   ctx.newObj.obj.TypeMeta,
			Status:     ctx.newObj.obj.Status}
		err = publisherHandler.OnPublisherUpdate(ctx.obj, &p)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctx.obj, err)
			ctx.SetEvent(kvstore.Deleted)
		}
	case kvstore.Deleted:
		ctx.obj.Lock()
		err = publisherHandler.OnPublisherDelete(ctx.obj)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error deleting %s %+v. Err: %v", kind, ctx.obj, err)
		}
	}
	ct.resolveObject(ctx.event, ctx)
	return nil
}

// handlePublisherEventParallel handles Publisher events from watcher
func (ct *ctrlerCtx) handlePublisherEventParallel(evt *kvstore.WatchEvent) error {

	if ct.objResolver == nil {
		return ct.handlePublisherEventParallelWithNoResolver(evt)
	}

	switch tp := evt.Object.(type) {
	case *bookstore.Publisher:
		eobj := evt.Object.(*bookstore.Publisher)
		kind := "Publisher"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ctx := &publisherCtx{event: evt.Type, obj: &Publisher{Publisher: *eobj, ctrler: ct}}

		var err error
		switch evt.Type {
		case kvstore.Created:
			err = ct.processAdd(ctx)
		case kvstore.Updated:
			err = ct.processUpdate(ctx)
		case kvstore.Deleted:
			err = ct.processDelete(ctx)
		}
		return err
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on Publisher watch channel", tp)
	}

	return nil
}

// handlePublisherEventParallel handles Publisher events from watcher
func (ct *ctrlerCtx) handlePublisherEventParallelWithNoResolver(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *bookstore.Publisher:
		eobj := evt.Object.(*bookstore.Publisher)
		kind := "Publisher"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		publisherHandler := handler.(PublisherHandler)
		// handle based on event type
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			workFunc := func(ctx context.Context, ctrlCtx shardworkers.WorkObj) error {
				var err error
				workCtx := ctrlCtx.(*publisherCtx)
				eobj := workCtx.obj
				fobj, err := ct.getObject(kind, workCtx.GetKey())
				if err != nil {
					ct.addObject(workCtx)
					ct.stats.Counter("Publisher_Created_Events").Inc()
					eobj.Lock()
					err = publisherHandler.OnPublisherCreate(eobj)
					eobj.Unlock()
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, eobj, err)
						ct.delObject(kind, workCtx.GetKey())
					}
				} else {
					workCtx := fobj.(*publisherCtx)
					obj := workCtx.obj
					ct.stats.Counter("Publisher_Updated_Events").Inc()
					obj.Lock()
					p := bookstore.Publisher{Spec: eobj.Spec,
						ObjectMeta: eobj.ObjectMeta,
						TypeMeta:   eobj.TypeMeta,
						Status:     eobj.Status}

					err = publisherHandler.OnPublisherUpdate(obj, &p)
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					} else {
						workCtx.obj.Publisher = p
					}
					obj.Unlock()
				}
				return err
			}
			ctrlCtx := &publisherCtx{event: evt.Type, obj: &Publisher{Publisher: *eobj, ctrler: ct}}
			ct.runFunction("Publisher", ctrlCtx, workFunc)
		case kvstore.Deleted:
			workFunc := func(ctx context.Context, ctrlCtx shardworkers.WorkObj) error {
				var err error
				workCtx := ctrlCtx.(*publisherCtx)
				eobj := workCtx.obj
				fobj, err := ct.findObject(kind, workCtx.GetKey())
				if err != nil {
					ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
					return err
				}
				obj := fobj.(*Publisher)
				ct.stats.Counter("Publisher_Deleted_Events").Inc()
				obj.Lock()
				err = publisherHandler.OnPublisherDelete(obj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
				}
				ct.delObject(kind, workCtx.GetKey())
				return nil
			}
			ctrlCtx := &publisherCtx{event: evt.Type, obj: &Publisher{Publisher: *eobj, ctrler: ct}}
			ct.runFunction("Publisher", ctrlCtx, workFunc)
		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on Publisher watch channel", tp)
	}

	return nil
}

// diffPublisher does a diff of Publisher objects between local cache and API server
func (ct *ctrlerCtx) diffPublisher(apicl apiclient.Services) {
	opts := api.ListWatchOptions{}

	// get a list of all objects from API server
	objlist, err := apicl.BookstoreV1().Publisher().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Errorf("Error getting a list of objects. Err: %v", err)
		return
	}

	ct.logger.Infof("diffPublisher(): PublisherList returned %d objects", len(objlist))

	// build an object map
	objmap := make(map[string]*bookstore.Publisher)
	for _, obj := range objlist {
		objmap[obj.GetKey()] = obj
	}

	list, err := ct.Publisher().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Infof("Failed to get a list of objects. Err: %s", err)
		return
	}

	// if an object is in our local cache and not in API server, trigger delete for it
	for _, obj := range list {
		_, ok := objmap[obj.GetKey()]
		if !ok {
			ct.logger.Infof("diffPublisher(): Deleting existing object %#v since its not in apiserver", obj.GetKey())
			evt := kvstore.WatchEvent{
				Type:   kvstore.Deleted,
				Key:    obj.GetKey(),
				Object: &obj.Publisher,
			}
			ct.handlePublisherEvent(&evt)
		}
	}

	// trigger create event for all others
	for _, obj := range objlist {
		ct.logger.Infof("diffPublisher(): Adding object %#v", obj.GetKey())
		evt := kvstore.WatchEvent{
			Type:   kvstore.Created,
			Key:    obj.GetKey(),
			Object: obj,
		}
		ct.handlePublisherEvent(&evt)
	}
}

func (ct *ctrlerCtx) runPublisherWatcher() {
	kind := "Publisher"

	ct.Lock()
	handler, ok := ct.handlers[kind]
	ct.Unlock()
	if !ok {
		ct.logger.Fatalf("Cant find the handler for %s", kind)
	}
	publisherHandler := handler.(PublisherHandler)

	opts := publisherHandler.GetPublisherWatchOptions()

	// if there is no API server to connect to, we are done
	if (ct.resolver == nil) || ct.apisrvURL == "" {
		return
	}

	// create context
	ctx, cancel := context.WithCancel(context.Background())
	ct.Lock()
	ct.watchCancel[kind] = cancel
	ct.Unlock()
	logger := ct.logger.WithContext("submodule", "PublisherWatcher")

	// create a grpc client
	apiclt, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
	if err == nil {
		ct.diffPublisher(apiclt)
	}

	// setup wait group
	ct.waitGrp.Add(1)

	// start a goroutine
	go func() {
		defer ct.waitGrp.Done()
		ct.stats.Counter("Publisher_Watch").Inc()
		defer ct.stats.Counter("Publisher_Watch").Dec()

		// loop forever
		for {
			// create a grpc client
			apicl, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
			if err != nil {
				logger.Warnf("Failed to connect to gRPC server [%s]\n", ct.apisrvURL)
				ct.stats.Counter("Publisher_ApiClientErr").Inc()
			} else {
				logger.Infof("API client connected {%+v}", apicl)

				// Publisher object watcher
				wt, werr := apicl.BookstoreV1().Publisher().Watch(ctx, opts)
				if werr != nil {
					select {
					case <-ctx.Done():
						logger.Infof("watch %s cancelled", kind)
						return
					default:
					}
					logger.Errorf("Failed to start %s watch (%s)\n", kind, werr)
					// wait for a second and retry connecting to api server
					apicl.Close()
					time.Sleep(time.Second)
					continue
				}
				ct.Lock()
				ct.watchers[kind] = wt
				ct.Unlock()

				// perform a diff with API server and local cache
				time.Sleep(time.Millisecond * 100)
				ct.diffPublisher(apicl)

				// handle api server watch events
			innerLoop:
				for {
					// wait for events
					select {
					case evt, ok := <-wt.EventChan():
						if !ok {
							logger.Error("Error receiving from apisrv watcher")
							ct.stats.Counter("Publisher_WatchErrors").Inc()
							break innerLoop
						}

						// handle event in parallel
						ct.handlePublisherEventParallel(evt)
					}
				}
				apicl.Close()
			}

			// if stop flag is set, we are done
			if ct.stoped {
				logger.Infof("Exiting API server watcher")
				return
			}

			// wait for a second and retry connecting to api server
			time.Sleep(time.Second)
		}
	}()
}

// WatchPublisher starts watch on Publisher object
func (ct *ctrlerCtx) WatchPublisher(handler PublisherHandler) error {
	kind := "Publisher"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchers[kind]
	ct.Unlock()
	if ok {
		return fmt.Errorf("Publisher watcher already exists")
	}

	// save handler
	ct.Lock()
	ct.handlers[kind] = handler
	ct.Unlock()

	// run Publisher watcher in a go routine
	ct.runPublisherWatcher()

	return nil
}

// StopWatchPublisher stops watch on Publisher object
func (ct *ctrlerCtx) StopWatchPublisher(handler PublisherHandler) error {
	kind := "Publisher"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchers[kind]
	ct.Unlock()
	if !ok {
		return fmt.Errorf("Publisher watcher does not exist")
	}

	ct.Lock()
	cancel, _ := ct.watchCancel[kind]
	cancel()
	delete(ct.watchers, kind)
	delete(ct.watchCancel, kind)
	ct.Unlock()

	time.Sleep(100 * time.Millisecond)

	return nil
}

// PublisherAPI returns
type PublisherAPI interface {
	Create(obj *bookstore.Publisher) error
	SyncCreate(obj *bookstore.Publisher) error
	Update(obj *bookstore.Publisher) error
	SyncUpdate(obj *bookstore.Publisher) error
	Delete(obj *bookstore.Publisher) error
	Find(meta *api.ObjectMeta) (*Publisher, error)
	List(ctx context.Context, opts *api.ListWatchOptions) ([]*Publisher, error)
	Watch(handler PublisherHandler) error
	StopWatch(handler PublisherHandler) error
}

// dummy struct that implements PublisherAPI
type publisherAPI struct {
	ct *ctrlerCtx
}

// Create creates Publisher object
func (api *publisherAPI) Create(obj *bookstore.Publisher) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.BookstoreV1().Publisher().Create(context.Background(), obj)
		if err != nil && strings.Contains(err.Error(), "AlreadyExists") {
			_, err = apicl.BookstoreV1().Publisher().Update(context.Background(), obj)

		}
		return err
	}

	api.ct.handlePublisherEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Created})
	return nil
}

// SyncCreate creates Publisher object and updates the cache
func (api *publisherAPI) SyncCreate(obj *bookstore.Publisher) error {
	newObj := obj
	evtType := kvstore.Created
	var writeErr error
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		newObj, writeErr = apicl.BookstoreV1().Publisher().Create(context.Background(), obj)
		if writeErr != nil && strings.Contains(writeErr.Error(), "AlreadyExists") {
			newObj, writeErr = apicl.BookstoreV1().Publisher().Update(context.Background(), obj)
			evtType = kvstore.Updated
		}
	}

	if writeErr == nil {
		api.ct.handlePublisherEvent(&kvstore.WatchEvent{Object: newObj, Type: evtType})
	}
	return writeErr
}

// Update triggers update on Publisher object
func (api *publisherAPI) Update(obj *bookstore.Publisher) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.BookstoreV1().Publisher().Update(context.Background(), obj)
		return err
	}

	api.ct.handlePublisherEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Updated})
	return nil
}

// SyncUpdate triggers update on Publisher object and updates the cache
func (api *publisherAPI) SyncUpdate(obj *bookstore.Publisher) error {
	newObj := obj
	var writeErr error
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		newObj, writeErr = apicl.BookstoreV1().Publisher().Update(context.Background(), obj)
	}

	if writeErr == nil {
		api.ct.handlePublisherEvent(&kvstore.WatchEvent{Object: newObj, Type: kvstore.Updated})
	}

	return writeErr
}

// Delete deletes Publisher object
func (api *publisherAPI) Delete(obj *bookstore.Publisher) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.BookstoreV1().Publisher().Delete(context.Background(), &obj.ObjectMeta)
		return err
	}

	api.ct.handlePublisherEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Deleted})
	return nil
}

// MakeKey generates a KV store key for the object
func (api *publisherAPI) getFullKey(tenant, name string) string {
	if tenant != "" {
		return fmt.Sprint(globals.ConfigRootPrefix, "/", "bookstore", "/", "publishers", "/", tenant, "/", name)
	}
	return fmt.Sprint(globals.ConfigRootPrefix, "/", "bookstore", "/", "publishers", "/", name)
}

// Find returns an object by meta
func (api *publisherAPI) Find(meta *api.ObjectMeta) (*Publisher, error) {
	// find the object
	obj, err := api.ct.FindObject("Publisher", meta)
	if err != nil {
		return nil, err
	}

	// asset type
	switch obj.(type) {
	case *Publisher:
		hobj := obj.(*Publisher)
		return hobj, nil
	default:
		return nil, errors.New("incorrect object type")
	}
}

// List returns a list of all Publisher objects
func (api *publisherAPI) List(ctx context.Context, opts *api.ListWatchOptions) ([]*Publisher, error) {
	var objlist []*Publisher
	objs, err := api.ct.List("Publisher", ctx, opts)

	if err != nil {
		return nil, err
	}

	for _, obj := range objs {
		switch tp := obj.(type) {
		case *Publisher:
			eobj := obj.(*Publisher)
			objlist = append(objlist, eobj)
		default:
			log.Fatalf("Got invalid object type %v while looking for Publisher", tp)
		}
	}

	return objlist, nil
}

// Watch sets up a event handlers for Publisher object
func (api *publisherAPI) Watch(handler PublisherHandler) error {
	api.ct.startWorkerPool("Publisher")
	return api.ct.WatchPublisher(handler)
}

// StopWatch stop watch for Tenant Publisher object
func (api *publisherAPI) StopWatch(handler PublisherHandler) error {
	api.ct.Lock()
	api.ct.workPools["Publisher"].Stop()
	api.ct.Unlock()
	return api.ct.StopWatchPublisher(handler)
}

// Publisher returns PublisherAPI
func (ct *ctrlerCtx) Publisher() PublisherAPI {
	kind := "Publisher"
	if _, ok := ct.apiInfMap[kind]; !ok {
		s := &publisherAPI{ct: ct}
		ct.apiInfMap[kind] = s
	}
	return ct.apiInfMap[kind].(*publisherAPI)
}

// Store is a wrapper object that implements additional functionality
type Store struct {
	sync.Mutex
	bookstore.Store
	HandlerCtx interface{} // additional state handlers can store
	ctrler     *ctrlerCtx  // reference back to the controller instance
}

func (obj *Store) Write() error {
	// if there is no API server to connect to, we are done
	if (obj.ctrler == nil) || (obj.ctrler.resolver == nil) || obj.ctrler.apisrvURL == "" {
		return nil
	}

	apicl, err := obj.ctrler.apiClient()
	if err != nil {
		obj.ctrler.logger.Errorf("Error creating API server clent. Err: %v", err)
		return err
	}

	obj.ctrler.stats.Counter("Store_Writes").Inc()

	// write to api server
	if obj.ObjectMeta.ResourceVersion != "" {
		// update it
		for i := 0; i < maxApisrvWriteRetry; i++ {
			_, err = apicl.BookstoreV1().Store().UpdateStatus(context.Background(), &obj.Store)
			if err == nil {
				break
			}
			time.Sleep(time.Millisecond * 100)
		}
	} else {
		//  create
		_, err = apicl.BookstoreV1().Store().Create(context.Background(), &obj.Store)
	}

	return nil
}

// StoreHandler is the event handler for Store object
type StoreHandler interface {
	OnStoreCreate(obj *Store) error
	OnStoreUpdate(oldObj *Store, newObj *bookstore.Store) error
	OnStoreDelete(obj *Store) error
	GetStoreWatchOptions() *api.ListWatchOptions
}

// OnStoreCreate is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnStoreCreate(obj *Store) error {
	log.Info("OnStoreCreate is not implemented")
	return nil
}

// OnStoreUpdate is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnStoreUpdate(oldObj *Store, newObj *bookstore.Store) error {
	log.Info("OnStoreUpdate is not implemented")
	return nil
}

// OnStoreDelete is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnStoreDelete(obj *Store) error {
	log.Info("OnStoreDelete is not implemented")
	return nil
}

// GetStoreWatchOptions is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) GetStoreWatchOptions() *api.ListWatchOptions {
	log.Info("GetStoreWatchOptions is not implemented")
	opts := &api.ListWatchOptions{}
	return opts
}

// handleStoreEvent handles Store events from watcher
func (ct *ctrlerCtx) handleStoreEvent(evt *kvstore.WatchEvent) error {

	if ct.objResolver == nil {
		return ct.handleStoreEventNoResolver(evt)
	}

	switch tp := evt.Object.(type) {
	case *bookstore.Store:
		eobj := evt.Object.(*bookstore.Store)
		kind := "Store"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ctx := &storeCtx{event: evt.Type,
			obj: &Store{Store: *eobj, ctrler: ct}}

		var err error
		switch evt.Type {
		case kvstore.Created:
			err = ct.processAdd(ctx)
		case kvstore.Updated:
			err = ct.processUpdate(ctx)
		case kvstore.Deleted:
			err = ct.processDelete(ctx)
		}
		return err
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on Store watch channel", tp)
	}

	return nil
}

// handleStoreEventNoResolver handles Store events from watcher
func (ct *ctrlerCtx) handleStoreEventNoResolver(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *bookstore.Store:
		eobj := evt.Object.(*bookstore.Store)
		kind := "Store"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		storeHandler := handler.(StoreHandler)
		// handle based on event type
		ctrlCtx := &storeCtx{event: evt.Type, obj: &Store{Store: *eobj, ctrler: ct}}
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			fobj, err := ct.getObject(kind, ctrlCtx.GetKey())
			if err != nil {
				ct.addObject(ctrlCtx)
				ct.stats.Counter("Store_Created_Events").Inc()

				// call the event handler
				ctrlCtx.Lock()
				err = storeHandler.OnStoreCreate(ctrlCtx.obj)
				ctrlCtx.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctrlCtx.obj, err)
					ct.delObject(kind, ctrlCtx.GetKey())
					return err
				}
			} else {
				fResVer, fErr := strconv.ParseInt(fobj.GetResourceVersion(), 10, 64)
				eResVer, eErr := strconv.ParseInt(eobj.GetResourceVersion(), 10, 64)
				if ct.resolver != nil && fErr == nil && eErr == nil && fResVer >= eResVer {
					// Event already processed.
					ct.logger.Infof("Skipping update due to old resource version")
					return nil
				}
				ctrlCtx := fobj.(*storeCtx)
				ct.stats.Counter("Store_Updated_Events").Inc()
				ctrlCtx.Lock()
				p := bookstore.Store{Spec: eobj.Spec,
					ObjectMeta: eobj.ObjectMeta,
					TypeMeta:   eobj.TypeMeta,
					Status:     eobj.Status}

				err = storeHandler.OnStoreUpdate(ctrlCtx.obj, &p)
				ctrlCtx.obj.Store = *eobj
				ctrlCtx.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctrlCtx.obj, err)
					return err
				}

			}
		case kvstore.Deleted:
			ctrlCtx := &storeCtx{event: evt.Type, obj: &Store{Store: *eobj, ctrler: ct}}
			fobj, err := ct.findObject(kind, ctrlCtx.GetKey())
			if err != nil {
				ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
				return err
			}

			obj := fobj.(*Store)
			ct.stats.Counter("Store_Deleted_Events").Inc()
			obj.Lock()
			err = storeHandler.OnStoreDelete(obj)
			obj.Unlock()
			if err != nil {
				ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
			}
			ct.delObject(kind, ctrlCtx.GetKey())
			return nil

		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on Store watch channel", tp)
	}

	return nil
}

type storeCtx struct {
	ctkitBaseCtx
	event kvstore.WatchEventType
	obj   *Store //
	//   newObj     *bookstore.Store //update
	newObj *storeCtx //update
}

func (ctx *storeCtx) References() map[string]apiintf.ReferenceObj {
	resp := make(map[string]apiintf.ReferenceObj)
	ctx.obj.References(ctx.obj.GetObjectMeta().Name, ctx.obj.GetObjectMeta().Namespace, resp)
	return resp
}

func (ctx *storeCtx) GetKey() string {
	return ctx.obj.MakeKey("bookstore")
}

func (ctx *storeCtx) GetKind() string {
	return ctx.obj.GetKind()
}

func (ctx *storeCtx) GetResourceVersion() string {
	return ctx.obj.GetResourceVersion()
}

func (ctx *storeCtx) SetEvent(event kvstore.WatchEventType) {
	ctx.event = event
}

func (ctx *storeCtx) SetNewObj(newObj apiintf.CtkitObject) {
	if newObj == nil {
		ctx.newObj = nil
	} else {
		ctx.newObj = newObj.(*storeCtx)
		ctx.newObj.obj.HandlerCtx = ctx.obj.HandlerCtx
	}
}

func (ctx *storeCtx) GetNewObj() apiintf.CtkitObject {
	return ctx.newObj
}

func (ctx *storeCtx) Copy(obj apiintf.CtkitObject) {
	ctx.obj.Store = obj.(*storeCtx).obj.Store
}

func (ctx *storeCtx) Lock() {
	ctx.obj.Lock()
}

func (ctx *storeCtx) Unlock() {
	ctx.obj.Unlock()
}

func (ctx *storeCtx) GetObjectMeta() *api.ObjectMeta {
	return ctx.obj.GetObjectMeta()
}

func (ctx *storeCtx) RuntimeObject() runtime.Object {
	var v interface{}
	v = ctx.obj
	return v.(runtime.Object)
}

func (ctx *storeCtx) WorkFunc(context context.Context) error {
	var err error
	evt := ctx.event
	ct := ctx.obj.ctrler
	kind := "Store"
	ct.Lock()
	handler, ok := ct.handlers[kind]
	ct.Unlock()
	if !ok {
		ct.logger.Fatalf("Cant find the handler for %s", kind)
	}
	storeHandler := handler.(StoreHandler)
	switch evt {
	case kvstore.Created:
		ctx.obj.Lock()
		err = storeHandler.OnStoreCreate(ctx.obj)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctx.obj, err)
			ctx.SetEvent(kvstore.Deleted)
		}
	case kvstore.Updated:
		ct.stats.Counter("Store_Updated_Events").Inc()
		ctx.obj.Lock()
		p := bookstore.Store{Spec: ctx.newObj.obj.Spec,
			ObjectMeta: ctx.newObj.obj.ObjectMeta,
			TypeMeta:   ctx.newObj.obj.TypeMeta,
			Status:     ctx.newObj.obj.Status}
		err = storeHandler.OnStoreUpdate(ctx.obj, &p)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctx.obj, err)
			ctx.SetEvent(kvstore.Deleted)
		}
	case kvstore.Deleted:
		ctx.obj.Lock()
		err = storeHandler.OnStoreDelete(ctx.obj)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error deleting %s %+v. Err: %v", kind, ctx.obj, err)
		}
	}
	ct.resolveObject(ctx.event, ctx)
	return nil
}

// handleStoreEventParallel handles Store events from watcher
func (ct *ctrlerCtx) handleStoreEventParallel(evt *kvstore.WatchEvent) error {

	if ct.objResolver == nil {
		return ct.handleStoreEventParallelWithNoResolver(evt)
	}

	switch tp := evt.Object.(type) {
	case *bookstore.Store:
		eobj := evt.Object.(*bookstore.Store)
		kind := "Store"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ctx := &storeCtx{event: evt.Type, obj: &Store{Store: *eobj, ctrler: ct}}

		var err error
		switch evt.Type {
		case kvstore.Created:
			err = ct.processAdd(ctx)
		case kvstore.Updated:
			err = ct.processUpdate(ctx)
		case kvstore.Deleted:
			err = ct.processDelete(ctx)
		}
		return err
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on Store watch channel", tp)
	}

	return nil
}

// handleStoreEventParallel handles Store events from watcher
func (ct *ctrlerCtx) handleStoreEventParallelWithNoResolver(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *bookstore.Store:
		eobj := evt.Object.(*bookstore.Store)
		kind := "Store"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		storeHandler := handler.(StoreHandler)
		// handle based on event type
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			workFunc := func(ctx context.Context, ctrlCtx shardworkers.WorkObj) error {
				var err error
				workCtx := ctrlCtx.(*storeCtx)
				eobj := workCtx.obj
				fobj, err := ct.getObject(kind, workCtx.GetKey())
				if err != nil {
					ct.addObject(workCtx)
					ct.stats.Counter("Store_Created_Events").Inc()
					eobj.Lock()
					err = storeHandler.OnStoreCreate(eobj)
					eobj.Unlock()
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, eobj, err)
						ct.delObject(kind, workCtx.GetKey())
					}
				} else {
					workCtx := fobj.(*storeCtx)
					obj := workCtx.obj
					ct.stats.Counter("Store_Updated_Events").Inc()
					obj.Lock()
					p := bookstore.Store{Spec: eobj.Spec,
						ObjectMeta: eobj.ObjectMeta,
						TypeMeta:   eobj.TypeMeta,
						Status:     eobj.Status}

					err = storeHandler.OnStoreUpdate(obj, &p)
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					} else {
						workCtx.obj.Store = p
					}
					obj.Unlock()
				}
				return err
			}
			ctrlCtx := &storeCtx{event: evt.Type, obj: &Store{Store: *eobj, ctrler: ct}}
			ct.runFunction("Store", ctrlCtx, workFunc)
		case kvstore.Deleted:
			workFunc := func(ctx context.Context, ctrlCtx shardworkers.WorkObj) error {
				var err error
				workCtx := ctrlCtx.(*storeCtx)
				eobj := workCtx.obj
				fobj, err := ct.findObject(kind, workCtx.GetKey())
				if err != nil {
					ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
					return err
				}
				obj := fobj.(*Store)
				ct.stats.Counter("Store_Deleted_Events").Inc()
				obj.Lock()
				err = storeHandler.OnStoreDelete(obj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
				}
				ct.delObject(kind, workCtx.GetKey())
				return nil
			}
			ctrlCtx := &storeCtx{event: evt.Type, obj: &Store{Store: *eobj, ctrler: ct}}
			ct.runFunction("Store", ctrlCtx, workFunc)
		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on Store watch channel", tp)
	}

	return nil
}

// diffStore does a diff of Store objects between local cache and API server
func (ct *ctrlerCtx) diffStore(apicl apiclient.Services) {
	opts := api.ListWatchOptions{}

	// get a list of all objects from API server
	objlist, err := apicl.BookstoreV1().Store().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Errorf("Error getting a list of objects. Err: %v", err)
		return
	}

	ct.logger.Infof("diffStore(): StoreList returned %d objects", len(objlist))

	// build an object map
	objmap := make(map[string]*bookstore.Store)
	for _, obj := range objlist {
		objmap[obj.GetKey()] = obj
	}

	list, err := ct.Store().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Infof("Failed to get a list of objects. Err: %s", err)
		return
	}

	// if an object is in our local cache and not in API server, trigger delete for it
	for _, obj := range list {
		_, ok := objmap[obj.GetKey()]
		if !ok {
			ct.logger.Infof("diffStore(): Deleting existing object %#v since its not in apiserver", obj.GetKey())
			evt := kvstore.WatchEvent{
				Type:   kvstore.Deleted,
				Key:    obj.GetKey(),
				Object: &obj.Store,
			}
			ct.handleStoreEvent(&evt)
		}
	}

	// trigger create event for all others
	for _, obj := range objlist {
		ct.logger.Infof("diffStore(): Adding object %#v", obj.GetKey())
		evt := kvstore.WatchEvent{
			Type:   kvstore.Created,
			Key:    obj.GetKey(),
			Object: obj,
		}
		ct.handleStoreEvent(&evt)
	}
}

func (ct *ctrlerCtx) runStoreWatcher() {
	kind := "Store"

	ct.Lock()
	handler, ok := ct.handlers[kind]
	ct.Unlock()
	if !ok {
		ct.logger.Fatalf("Cant find the handler for %s", kind)
	}
	storeHandler := handler.(StoreHandler)

	opts := storeHandler.GetStoreWatchOptions()

	// if there is no API server to connect to, we are done
	if (ct.resolver == nil) || ct.apisrvURL == "" {
		return
	}

	// create context
	ctx, cancel := context.WithCancel(context.Background())
	ct.Lock()
	ct.watchCancel[kind] = cancel
	ct.Unlock()
	logger := ct.logger.WithContext("submodule", "StoreWatcher")

	// create a grpc client
	apiclt, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
	if err == nil {
		ct.diffStore(apiclt)
	}

	// setup wait group
	ct.waitGrp.Add(1)

	// start a goroutine
	go func() {
		defer ct.waitGrp.Done()
		ct.stats.Counter("Store_Watch").Inc()
		defer ct.stats.Counter("Store_Watch").Dec()

		// loop forever
		for {
			// create a grpc client
			apicl, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
			if err != nil {
				logger.Warnf("Failed to connect to gRPC server [%s]\n", ct.apisrvURL)
				ct.stats.Counter("Store_ApiClientErr").Inc()
			} else {
				logger.Infof("API client connected {%+v}", apicl)

				// Store object watcher
				wt, werr := apicl.BookstoreV1().Store().Watch(ctx, opts)
				if werr != nil {
					select {
					case <-ctx.Done():
						logger.Infof("watch %s cancelled", kind)
						return
					default:
					}
					logger.Errorf("Failed to start %s watch (%s)\n", kind, werr)
					// wait for a second and retry connecting to api server
					apicl.Close()
					time.Sleep(time.Second)
					continue
				}
				ct.Lock()
				ct.watchers[kind] = wt
				ct.Unlock()

				// perform a diff with API server and local cache
				time.Sleep(time.Millisecond * 100)
				ct.diffStore(apicl)

				// handle api server watch events
			innerLoop:
				for {
					// wait for events
					select {
					case evt, ok := <-wt.EventChan():
						if !ok {
							logger.Error("Error receiving from apisrv watcher")
							ct.stats.Counter("Store_WatchErrors").Inc()
							break innerLoop
						}

						// handle event in parallel
						ct.handleStoreEventParallel(evt)
					}
				}
				apicl.Close()
			}

			// if stop flag is set, we are done
			if ct.stoped {
				logger.Infof("Exiting API server watcher")
				return
			}

			// wait for a second and retry connecting to api server
			time.Sleep(time.Second)
		}
	}()
}

// WatchStore starts watch on Store object
func (ct *ctrlerCtx) WatchStore(handler StoreHandler) error {
	kind := "Store"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchers[kind]
	ct.Unlock()
	if ok {
		return fmt.Errorf("Store watcher already exists")
	}

	// save handler
	ct.Lock()
	ct.handlers[kind] = handler
	ct.Unlock()

	// run Store watcher in a go routine
	ct.runStoreWatcher()

	return nil
}

// StopWatchStore stops watch on Store object
func (ct *ctrlerCtx) StopWatchStore(handler StoreHandler) error {
	kind := "Store"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchers[kind]
	ct.Unlock()
	if !ok {
		return fmt.Errorf("Store watcher does not exist")
	}

	ct.Lock()
	cancel, _ := ct.watchCancel[kind]
	cancel()
	delete(ct.watchers, kind)
	delete(ct.watchCancel, kind)
	ct.Unlock()

	time.Sleep(100 * time.Millisecond)

	return nil
}

// StoreAPI returns
type StoreAPI interface {
	Create(obj *bookstore.Store) error
	SyncCreate(obj *bookstore.Store) error
	Update(obj *bookstore.Store) error
	SyncUpdate(obj *bookstore.Store) error
	Delete(obj *bookstore.Store) error
	Find(meta *api.ObjectMeta) (*Store, error)
	List(ctx context.Context, opts *api.ListWatchOptions) ([]*Store, error)
	Watch(handler StoreHandler) error
	StopWatch(handler StoreHandler) error
	AddOutage(obj *bookstore.OutageRequest) (*bookstore.Store, error)
	RegisterLocalAddOutageHandler(fn func(*bookstore.OutageRequest) (*bookstore.Store, error))
	SyncAddOutage(obj *bookstore.OutageRequest) (*bookstore.Store, error)
	RegisterLocalSyncAddOutageHandler(fn func(*bookstore.OutageRequest) (*bookstore.Store, error))
}

// dummy struct that implements StoreAPI
type storeAPI struct {
	ct *ctrlerCtx

	localAddOutageHandler     func(obj *bookstore.OutageRequest) (*bookstore.Store, error)
	localSyncAddOutageHandler func(obj *bookstore.OutageRequest) (*bookstore.Store, error)
}

// Create creates Store object
func (api *storeAPI) Create(obj *bookstore.Store) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.BookstoreV1().Store().Create(context.Background(), obj)
		if err != nil && strings.Contains(err.Error(), "AlreadyExists") {
			_, err = apicl.BookstoreV1().Store().Update(context.Background(), obj)

		}
		return err
	}

	api.ct.handleStoreEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Created})
	return nil
}

// SyncCreate creates Store object and updates the cache
func (api *storeAPI) SyncCreate(obj *bookstore.Store) error {
	newObj := obj
	evtType := kvstore.Created
	var writeErr error
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		newObj, writeErr = apicl.BookstoreV1().Store().Create(context.Background(), obj)
		if writeErr != nil && strings.Contains(writeErr.Error(), "AlreadyExists") {
			newObj, writeErr = apicl.BookstoreV1().Store().Update(context.Background(), obj)
			evtType = kvstore.Updated
		}
	}

	if writeErr == nil {
		api.ct.handleStoreEvent(&kvstore.WatchEvent{Object: newObj, Type: evtType})
	}
	return writeErr
}

// Update triggers update on Store object
func (api *storeAPI) Update(obj *bookstore.Store) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.BookstoreV1().Store().Update(context.Background(), obj)
		return err
	}

	api.ct.handleStoreEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Updated})
	return nil
}

// SyncUpdate triggers update on Store object and updates the cache
func (api *storeAPI) SyncUpdate(obj *bookstore.Store) error {
	newObj := obj
	var writeErr error
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		newObj, writeErr = apicl.BookstoreV1().Store().Update(context.Background(), obj)
	}

	if writeErr == nil {
		api.ct.handleStoreEvent(&kvstore.WatchEvent{Object: newObj, Type: kvstore.Updated})
	}

	return writeErr
}

// Delete deletes Store object
func (api *storeAPI) Delete(obj *bookstore.Store) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.BookstoreV1().Store().Delete(context.Background(), &obj.ObjectMeta)
		return err
	}

	api.ct.handleStoreEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Deleted})
	return nil
}

// MakeKey generates a KV store key for the object
func (api *storeAPI) getFullKey(tenant, name string) string {
	if tenant != "" {
		return fmt.Sprint(globals.ConfigRootPrefix, "/", "bookstore", "/", "store", "/", tenant, "/", name)
	}
	return fmt.Sprint(globals.ConfigRootPrefix, "/", "bookstore", "/", "store", "/", name)
}

// Find returns an object by meta
func (api *storeAPI) Find(meta *api.ObjectMeta) (*Store, error) {
	// find the object
	obj, err := api.ct.FindObject("Store", meta)
	if err != nil {
		return nil, err
	}

	// asset type
	switch obj.(type) {
	case *Store:
		hobj := obj.(*Store)
		return hobj, nil
	default:
		return nil, errors.New("incorrect object type")
	}
}

// List returns a list of all Store objects
func (api *storeAPI) List(ctx context.Context, opts *api.ListWatchOptions) ([]*Store, error) {
	var objlist []*Store
	objs, err := api.ct.List("Store", ctx, opts)

	if err != nil {
		return nil, err
	}

	for _, obj := range objs {
		switch tp := obj.(type) {
		case *Store:
			eobj := obj.(*Store)
			objlist = append(objlist, eobj)
		default:
			log.Fatalf("Got invalid object type %v while looking for Store", tp)
		}
	}

	return objlist, nil
}

// Watch sets up a event handlers for Store object
func (api *storeAPI) Watch(handler StoreHandler) error {
	api.ct.startWorkerPool("Store")
	return api.ct.WatchStore(handler)
}

// StopWatch stop watch for Tenant Store object
func (api *storeAPI) StopWatch(handler StoreHandler) error {
	api.ct.Lock()
	api.ct.workPools["Store"].Stop()
	api.ct.Unlock()
	return api.ct.StopWatchStore(handler)
}

// AddOutage is an API action
func (api *storeAPI) AddOutage(obj *bookstore.OutageRequest) (*bookstore.Store, error) {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return nil, err
		}

		return apicl.BookstoreV1().Store().AddOutage(context.Background(), obj)
	}
	if api.localAddOutageHandler != nil {
		return api.localAddOutageHandler(obj)
	}
	return nil, fmt.Errorf("Action not implemented for local operation")
}

// SyncAddOutage is an API action. Cache will be updated
func (api *storeAPI) SyncAddOutage(obj *bookstore.OutageRequest) (*bookstore.Store, error) {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return nil, err
		}

		ret, err := apicl.BookstoreV1().Store().AddOutage(context.Background(), obj)
		if err != nil {
			return ret, err
		}
		// Perform Get to update the cache
		newObj, err := apicl.BookstoreV1().Store().Get(context.Background(), obj.GetObjectMeta())
		if err == nil {
			api.ct.handleStoreEvent(&kvstore.WatchEvent{Object: newObj, Type: kvstore.Updated})
		}
		return ret, err
	}
	if api.localSyncAddOutageHandler != nil {
		return api.localSyncAddOutageHandler(obj)
	}
	return nil, fmt.Errorf("Action not implemented for local operation")
}

func (api *storeAPI) RegisterLocalAddOutageHandler(fn func(*bookstore.OutageRequest) (*bookstore.Store, error)) {
	api.localAddOutageHandler = fn
}

func (api *storeAPI) RegisterLocalSyncAddOutageHandler(fn func(*bookstore.OutageRequest) (*bookstore.Store, error)) {
	api.localSyncAddOutageHandler = fn
}

// Store returns StoreAPI
func (ct *ctrlerCtx) Store() StoreAPI {
	kind := "Store"
	if _, ok := ct.apiInfMap[kind]; !ok {
		s := &storeAPI{ct: ct}
		ct.apiInfMap[kind] = s
	}
	return ct.apiInfMap[kind].(*storeAPI)
}

// Coupon is a wrapper object that implements additional functionality
type Coupon struct {
	sync.Mutex
	bookstore.Coupon
	HandlerCtx interface{} // additional state handlers can store
	ctrler     *ctrlerCtx  // reference back to the controller instance
}

func (obj *Coupon) Write() error {
	// if there is no API server to connect to, we are done
	if (obj.ctrler == nil) || (obj.ctrler.resolver == nil) || obj.ctrler.apisrvURL == "" {
		return nil
	}

	apicl, err := obj.ctrler.apiClient()
	if err != nil {
		obj.ctrler.logger.Errorf("Error creating API server clent. Err: %v", err)
		return err
	}

	obj.ctrler.stats.Counter("Coupon_Writes").Inc()

	// write to api server
	if obj.ObjectMeta.ResourceVersion != "" {
		// update it
		for i := 0; i < maxApisrvWriteRetry; i++ {
			_, err = apicl.BookstoreV1().Coupon().UpdateStatus(context.Background(), &obj.Coupon)
			if err == nil {
				break
			}
			time.Sleep(time.Millisecond * 100)
		}
	} else {
		//  create
		_, err = apicl.BookstoreV1().Coupon().Create(context.Background(), &obj.Coupon)
	}

	return nil
}

// CouponHandler is the event handler for Coupon object
type CouponHandler interface {
	OnCouponCreate(obj *Coupon) error
	OnCouponUpdate(oldObj *Coupon, newObj *bookstore.Coupon) error
	OnCouponDelete(obj *Coupon) error
	GetCouponWatchOptions() *api.ListWatchOptions
}

// OnCouponCreate is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnCouponCreate(obj *Coupon) error {
	log.Info("OnCouponCreate is not implemented")
	return nil
}

// OnCouponUpdate is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnCouponUpdate(oldObj *Coupon, newObj *bookstore.Coupon) error {
	log.Info("OnCouponUpdate is not implemented")
	return nil
}

// OnCouponDelete is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnCouponDelete(obj *Coupon) error {
	log.Info("OnCouponDelete is not implemented")
	return nil
}

// GetCouponWatchOptions is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) GetCouponWatchOptions() *api.ListWatchOptions {
	log.Info("GetCouponWatchOptions is not implemented")
	opts := &api.ListWatchOptions{}
	return opts
}

// handleCouponEvent handles Coupon events from watcher
func (ct *ctrlerCtx) handleCouponEvent(evt *kvstore.WatchEvent) error {

	if ct.objResolver == nil {
		return ct.handleCouponEventNoResolver(evt)
	}

	switch tp := evt.Object.(type) {
	case *bookstore.Coupon:
		eobj := evt.Object.(*bookstore.Coupon)
		kind := "Coupon"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ctx := &couponCtx{event: evt.Type,
			obj: &Coupon{Coupon: *eobj, ctrler: ct}}

		var err error
		switch evt.Type {
		case kvstore.Created:
			err = ct.processAdd(ctx)
		case kvstore.Updated:
			err = ct.processUpdate(ctx)
		case kvstore.Deleted:
			err = ct.processDelete(ctx)
		}
		return err
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on Coupon watch channel", tp)
	}

	return nil
}

// handleCouponEventNoResolver handles Coupon events from watcher
func (ct *ctrlerCtx) handleCouponEventNoResolver(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *bookstore.Coupon:
		eobj := evt.Object.(*bookstore.Coupon)
		kind := "Coupon"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		couponHandler := handler.(CouponHandler)
		// handle based on event type
		ctrlCtx := &couponCtx{event: evt.Type, obj: &Coupon{Coupon: *eobj, ctrler: ct}}
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			fobj, err := ct.getObject(kind, ctrlCtx.GetKey())
			if err != nil {
				ct.addObject(ctrlCtx)
				ct.stats.Counter("Coupon_Created_Events").Inc()

				// call the event handler
				ctrlCtx.Lock()
				err = couponHandler.OnCouponCreate(ctrlCtx.obj)
				ctrlCtx.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctrlCtx.obj, err)
					ct.delObject(kind, ctrlCtx.GetKey())
					return err
				}
			} else {
				fResVer, fErr := strconv.ParseInt(fobj.GetResourceVersion(), 10, 64)
				eResVer, eErr := strconv.ParseInt(eobj.GetResourceVersion(), 10, 64)
				if ct.resolver != nil && fErr == nil && eErr == nil && fResVer >= eResVer {
					// Event already processed.
					ct.logger.Infof("Skipping update due to old resource version")
					return nil
				}
				ctrlCtx := fobj.(*couponCtx)
				ct.stats.Counter("Coupon_Updated_Events").Inc()
				ctrlCtx.Lock()
				p := bookstore.Coupon{Spec: eobj.Spec,
					ObjectMeta: eobj.ObjectMeta,
					TypeMeta:   eobj.TypeMeta,
					Status:     eobj.Status}

				err = couponHandler.OnCouponUpdate(ctrlCtx.obj, &p)
				ctrlCtx.obj.Coupon = *eobj
				ctrlCtx.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctrlCtx.obj, err)
					return err
				}

			}
		case kvstore.Deleted:
			ctrlCtx := &couponCtx{event: evt.Type, obj: &Coupon{Coupon: *eobj, ctrler: ct}}
			fobj, err := ct.findObject(kind, ctrlCtx.GetKey())
			if err != nil {
				ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
				return err
			}

			obj := fobj.(*Coupon)
			ct.stats.Counter("Coupon_Deleted_Events").Inc()
			obj.Lock()
			err = couponHandler.OnCouponDelete(obj)
			obj.Unlock()
			if err != nil {
				ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
			}
			ct.delObject(kind, ctrlCtx.GetKey())
			return nil

		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on Coupon watch channel", tp)
	}

	return nil
}

type couponCtx struct {
	ctkitBaseCtx
	event kvstore.WatchEventType
	obj   *Coupon //
	//   newObj     *bookstore.Coupon //update
	newObj *couponCtx //update
}

func (ctx *couponCtx) References() map[string]apiintf.ReferenceObj {
	resp := make(map[string]apiintf.ReferenceObj)
	ctx.obj.References(ctx.obj.GetObjectMeta().Name, ctx.obj.GetObjectMeta().Namespace, resp)
	return resp
}

func (ctx *couponCtx) GetKey() string {
	return ctx.obj.MakeKey("bookstore")
}

func (ctx *couponCtx) GetKind() string {
	return ctx.obj.GetKind()
}

func (ctx *couponCtx) GetResourceVersion() string {
	return ctx.obj.GetResourceVersion()
}

func (ctx *couponCtx) SetEvent(event kvstore.WatchEventType) {
	ctx.event = event
}

func (ctx *couponCtx) SetNewObj(newObj apiintf.CtkitObject) {
	if newObj == nil {
		ctx.newObj = nil
	} else {
		ctx.newObj = newObj.(*couponCtx)
		ctx.newObj.obj.HandlerCtx = ctx.obj.HandlerCtx
	}
}

func (ctx *couponCtx) GetNewObj() apiintf.CtkitObject {
	return ctx.newObj
}

func (ctx *couponCtx) Copy(obj apiintf.CtkitObject) {
	ctx.obj.Coupon = obj.(*couponCtx).obj.Coupon
}

func (ctx *couponCtx) Lock() {
	ctx.obj.Lock()
}

func (ctx *couponCtx) Unlock() {
	ctx.obj.Unlock()
}

func (ctx *couponCtx) GetObjectMeta() *api.ObjectMeta {
	return ctx.obj.GetObjectMeta()
}

func (ctx *couponCtx) RuntimeObject() runtime.Object {
	var v interface{}
	v = ctx.obj
	return v.(runtime.Object)
}

func (ctx *couponCtx) WorkFunc(context context.Context) error {
	var err error
	evt := ctx.event
	ct := ctx.obj.ctrler
	kind := "Coupon"
	ct.Lock()
	handler, ok := ct.handlers[kind]
	ct.Unlock()
	if !ok {
		ct.logger.Fatalf("Cant find the handler for %s", kind)
	}
	couponHandler := handler.(CouponHandler)
	switch evt {
	case kvstore.Created:
		ctx.obj.Lock()
		err = couponHandler.OnCouponCreate(ctx.obj)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctx.obj, err)
			ctx.SetEvent(kvstore.Deleted)
		}
	case kvstore.Updated:
		ct.stats.Counter("Coupon_Updated_Events").Inc()
		ctx.obj.Lock()
		p := bookstore.Coupon{Spec: ctx.newObj.obj.Spec,
			ObjectMeta: ctx.newObj.obj.ObjectMeta,
			TypeMeta:   ctx.newObj.obj.TypeMeta,
			Status:     ctx.newObj.obj.Status}
		err = couponHandler.OnCouponUpdate(ctx.obj, &p)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctx.obj, err)
			ctx.SetEvent(kvstore.Deleted)
		}
	case kvstore.Deleted:
		ctx.obj.Lock()
		err = couponHandler.OnCouponDelete(ctx.obj)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error deleting %s %+v. Err: %v", kind, ctx.obj, err)
		}
	}
	ct.resolveObject(ctx.event, ctx)
	return nil
}

// handleCouponEventParallel handles Coupon events from watcher
func (ct *ctrlerCtx) handleCouponEventParallel(evt *kvstore.WatchEvent) error {

	if ct.objResolver == nil {
		return ct.handleCouponEventParallelWithNoResolver(evt)
	}

	switch tp := evt.Object.(type) {
	case *bookstore.Coupon:
		eobj := evt.Object.(*bookstore.Coupon)
		kind := "Coupon"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ctx := &couponCtx{event: evt.Type, obj: &Coupon{Coupon: *eobj, ctrler: ct}}

		var err error
		switch evt.Type {
		case kvstore.Created:
			err = ct.processAdd(ctx)
		case kvstore.Updated:
			err = ct.processUpdate(ctx)
		case kvstore.Deleted:
			err = ct.processDelete(ctx)
		}
		return err
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on Coupon watch channel", tp)
	}

	return nil
}

// handleCouponEventParallel handles Coupon events from watcher
func (ct *ctrlerCtx) handleCouponEventParallelWithNoResolver(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *bookstore.Coupon:
		eobj := evt.Object.(*bookstore.Coupon)
		kind := "Coupon"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		couponHandler := handler.(CouponHandler)
		// handle based on event type
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			workFunc := func(ctx context.Context, ctrlCtx shardworkers.WorkObj) error {
				var err error
				workCtx := ctrlCtx.(*couponCtx)
				eobj := workCtx.obj
				fobj, err := ct.getObject(kind, workCtx.GetKey())
				if err != nil {
					ct.addObject(workCtx)
					ct.stats.Counter("Coupon_Created_Events").Inc()
					eobj.Lock()
					err = couponHandler.OnCouponCreate(eobj)
					eobj.Unlock()
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, eobj, err)
						ct.delObject(kind, workCtx.GetKey())
					}
				} else {
					workCtx := fobj.(*couponCtx)
					obj := workCtx.obj
					ct.stats.Counter("Coupon_Updated_Events").Inc()
					obj.Lock()
					p := bookstore.Coupon{Spec: eobj.Spec,
						ObjectMeta: eobj.ObjectMeta,
						TypeMeta:   eobj.TypeMeta,
						Status:     eobj.Status}

					err = couponHandler.OnCouponUpdate(obj, &p)
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					} else {
						workCtx.obj.Coupon = p
					}
					obj.Unlock()
				}
				return err
			}
			ctrlCtx := &couponCtx{event: evt.Type, obj: &Coupon{Coupon: *eobj, ctrler: ct}}
			ct.runFunction("Coupon", ctrlCtx, workFunc)
		case kvstore.Deleted:
			workFunc := func(ctx context.Context, ctrlCtx shardworkers.WorkObj) error {
				var err error
				workCtx := ctrlCtx.(*couponCtx)
				eobj := workCtx.obj
				fobj, err := ct.findObject(kind, workCtx.GetKey())
				if err != nil {
					ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
					return err
				}
				obj := fobj.(*Coupon)
				ct.stats.Counter("Coupon_Deleted_Events").Inc()
				obj.Lock()
				err = couponHandler.OnCouponDelete(obj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
				}
				ct.delObject(kind, workCtx.GetKey())
				return nil
			}
			ctrlCtx := &couponCtx{event: evt.Type, obj: &Coupon{Coupon: *eobj, ctrler: ct}}
			ct.runFunction("Coupon", ctrlCtx, workFunc)
		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on Coupon watch channel", tp)
	}

	return nil
}

// diffCoupon does a diff of Coupon objects between local cache and API server
func (ct *ctrlerCtx) diffCoupon(apicl apiclient.Services) {
	opts := api.ListWatchOptions{}

	// get a list of all objects from API server
	objlist, err := apicl.BookstoreV1().Coupon().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Errorf("Error getting a list of objects. Err: %v", err)
		return
	}

	ct.logger.Infof("diffCoupon(): CouponList returned %d objects", len(objlist))

	// build an object map
	objmap := make(map[string]*bookstore.Coupon)
	for _, obj := range objlist {
		objmap[obj.GetKey()] = obj
	}

	list, err := ct.Coupon().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Infof("Failed to get a list of objects. Err: %s", err)
		return
	}

	// if an object is in our local cache and not in API server, trigger delete for it
	for _, obj := range list {
		_, ok := objmap[obj.GetKey()]
		if !ok {
			ct.logger.Infof("diffCoupon(): Deleting existing object %#v since its not in apiserver", obj.GetKey())
			evt := kvstore.WatchEvent{
				Type:   kvstore.Deleted,
				Key:    obj.GetKey(),
				Object: &obj.Coupon,
			}
			ct.handleCouponEvent(&evt)
		}
	}

	// trigger create event for all others
	for _, obj := range objlist {
		ct.logger.Infof("diffCoupon(): Adding object %#v", obj.GetKey())
		evt := kvstore.WatchEvent{
			Type:   kvstore.Created,
			Key:    obj.GetKey(),
			Object: obj,
		}
		ct.handleCouponEvent(&evt)
	}
}

func (ct *ctrlerCtx) runCouponWatcher() {
	kind := "Coupon"

	ct.Lock()
	handler, ok := ct.handlers[kind]
	ct.Unlock()
	if !ok {
		ct.logger.Fatalf("Cant find the handler for %s", kind)
	}
	couponHandler := handler.(CouponHandler)

	opts := couponHandler.GetCouponWatchOptions()

	// if there is no API server to connect to, we are done
	if (ct.resolver == nil) || ct.apisrvURL == "" {
		return
	}

	// create context
	ctx, cancel := context.WithCancel(context.Background())
	ct.Lock()
	ct.watchCancel[kind] = cancel
	ct.Unlock()
	logger := ct.logger.WithContext("submodule", "CouponWatcher")

	// create a grpc client
	apiclt, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
	if err == nil {
		ct.diffCoupon(apiclt)
	}

	// setup wait group
	ct.waitGrp.Add(1)

	// start a goroutine
	go func() {
		defer ct.waitGrp.Done()
		ct.stats.Counter("Coupon_Watch").Inc()
		defer ct.stats.Counter("Coupon_Watch").Dec()

		// loop forever
		for {
			// create a grpc client
			apicl, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
			if err != nil {
				logger.Warnf("Failed to connect to gRPC server [%s]\n", ct.apisrvURL)
				ct.stats.Counter("Coupon_ApiClientErr").Inc()
			} else {
				logger.Infof("API client connected {%+v}", apicl)

				// Coupon object watcher
				wt, werr := apicl.BookstoreV1().Coupon().Watch(ctx, opts)
				if werr != nil {
					select {
					case <-ctx.Done():
						logger.Infof("watch %s cancelled", kind)
						return
					default:
					}
					logger.Errorf("Failed to start %s watch (%s)\n", kind, werr)
					// wait for a second and retry connecting to api server
					apicl.Close()
					time.Sleep(time.Second)
					continue
				}
				ct.Lock()
				ct.watchers[kind] = wt
				ct.Unlock()

				// perform a diff with API server and local cache
				time.Sleep(time.Millisecond * 100)
				ct.diffCoupon(apicl)

				// handle api server watch events
			innerLoop:
				for {
					// wait for events
					select {
					case evt, ok := <-wt.EventChan():
						if !ok {
							logger.Error("Error receiving from apisrv watcher")
							ct.stats.Counter("Coupon_WatchErrors").Inc()
							break innerLoop
						}

						// handle event in parallel
						ct.handleCouponEventParallel(evt)
					}
				}
				apicl.Close()
			}

			// if stop flag is set, we are done
			if ct.stoped {
				logger.Infof("Exiting API server watcher")
				return
			}

			// wait for a second and retry connecting to api server
			time.Sleep(time.Second)
		}
	}()
}

// WatchCoupon starts watch on Coupon object
func (ct *ctrlerCtx) WatchCoupon(handler CouponHandler) error {
	kind := "Coupon"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchers[kind]
	ct.Unlock()
	if ok {
		return fmt.Errorf("Coupon watcher already exists")
	}

	// save handler
	ct.Lock()
	ct.handlers[kind] = handler
	ct.Unlock()

	// run Coupon watcher in a go routine
	ct.runCouponWatcher()

	return nil
}

// StopWatchCoupon stops watch on Coupon object
func (ct *ctrlerCtx) StopWatchCoupon(handler CouponHandler) error {
	kind := "Coupon"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchers[kind]
	ct.Unlock()
	if !ok {
		return fmt.Errorf("Coupon watcher does not exist")
	}

	ct.Lock()
	cancel, _ := ct.watchCancel[kind]
	cancel()
	delete(ct.watchers, kind)
	delete(ct.watchCancel, kind)
	ct.Unlock()

	time.Sleep(100 * time.Millisecond)

	return nil
}

// CouponAPI returns
type CouponAPI interface {
	Create(obj *bookstore.Coupon) error
	SyncCreate(obj *bookstore.Coupon) error
	Update(obj *bookstore.Coupon) error
	SyncUpdate(obj *bookstore.Coupon) error
	Delete(obj *bookstore.Coupon) error
	Find(meta *api.ObjectMeta) (*Coupon, error)
	List(ctx context.Context, opts *api.ListWatchOptions) ([]*Coupon, error)
	Watch(handler CouponHandler) error
	StopWatch(handler CouponHandler) error
}

// dummy struct that implements CouponAPI
type couponAPI struct {
	ct *ctrlerCtx
}

// Create creates Coupon object
func (api *couponAPI) Create(obj *bookstore.Coupon) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.BookstoreV1().Coupon().Create(context.Background(), obj)
		if err != nil && strings.Contains(err.Error(), "AlreadyExists") {
			_, err = apicl.BookstoreV1().Coupon().Update(context.Background(), obj)

		}
		return err
	}

	api.ct.handleCouponEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Created})
	return nil
}

// SyncCreate creates Coupon object and updates the cache
func (api *couponAPI) SyncCreate(obj *bookstore.Coupon) error {
	newObj := obj
	evtType := kvstore.Created
	var writeErr error
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		newObj, writeErr = apicl.BookstoreV1().Coupon().Create(context.Background(), obj)
		if writeErr != nil && strings.Contains(writeErr.Error(), "AlreadyExists") {
			newObj, writeErr = apicl.BookstoreV1().Coupon().Update(context.Background(), obj)
			evtType = kvstore.Updated
		}
	}

	if writeErr == nil {
		api.ct.handleCouponEvent(&kvstore.WatchEvent{Object: newObj, Type: evtType})
	}
	return writeErr
}

// Update triggers update on Coupon object
func (api *couponAPI) Update(obj *bookstore.Coupon) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.BookstoreV1().Coupon().Update(context.Background(), obj)
		return err
	}

	api.ct.handleCouponEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Updated})
	return nil
}

// SyncUpdate triggers update on Coupon object and updates the cache
func (api *couponAPI) SyncUpdate(obj *bookstore.Coupon) error {
	newObj := obj
	var writeErr error
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		newObj, writeErr = apicl.BookstoreV1().Coupon().Update(context.Background(), obj)
	}

	if writeErr == nil {
		api.ct.handleCouponEvent(&kvstore.WatchEvent{Object: newObj, Type: kvstore.Updated})
	}

	return writeErr
}

// Delete deletes Coupon object
func (api *couponAPI) Delete(obj *bookstore.Coupon) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.BookstoreV1().Coupon().Delete(context.Background(), &obj.ObjectMeta)
		return err
	}

	api.ct.handleCouponEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Deleted})
	return nil
}

// MakeKey generates a KV store key for the object
func (api *couponAPI) getFullKey(tenant, name string) string {
	if tenant != "" {
		return fmt.Sprint(globals.ConfigRootPrefix, "/", "bookstore", "/", "Coupon", "/", tenant, "/", name)
	}
	return fmt.Sprint(globals.ConfigRootPrefix, "/", "bookstore", "/", "Coupon", "/", name)
}

// Find returns an object by meta
func (api *couponAPI) Find(meta *api.ObjectMeta) (*Coupon, error) {
	// find the object
	obj, err := api.ct.FindObject("Coupon", meta)
	if err != nil {
		return nil, err
	}

	// asset type
	switch obj.(type) {
	case *Coupon:
		hobj := obj.(*Coupon)
		return hobj, nil
	default:
		return nil, errors.New("incorrect object type")
	}
}

// List returns a list of all Coupon objects
func (api *couponAPI) List(ctx context.Context, opts *api.ListWatchOptions) ([]*Coupon, error) {
	var objlist []*Coupon
	objs, err := api.ct.List("Coupon", ctx, opts)

	if err != nil {
		return nil, err
	}

	for _, obj := range objs {
		switch tp := obj.(type) {
		case *Coupon:
			eobj := obj.(*Coupon)
			objlist = append(objlist, eobj)
		default:
			log.Fatalf("Got invalid object type %v while looking for Coupon", tp)
		}
	}

	return objlist, nil
}

// Watch sets up a event handlers for Coupon object
func (api *couponAPI) Watch(handler CouponHandler) error {
	api.ct.startWorkerPool("Coupon")
	return api.ct.WatchCoupon(handler)
}

// StopWatch stop watch for Tenant Coupon object
func (api *couponAPI) StopWatch(handler CouponHandler) error {
	api.ct.Lock()
	api.ct.workPools["Coupon"].Stop()
	api.ct.Unlock()
	return api.ct.StopWatchCoupon(handler)
}

// Coupon returns CouponAPI
func (ct *ctrlerCtx) Coupon() CouponAPI {
	kind := "Coupon"
	if _, ok := ct.apiInfMap[kind]; !ok {
		s := &couponAPI{ct: ct}
		ct.apiInfMap[kind] = s
	}
	return ct.apiInfMap[kind].(*couponAPI)
}

// Customer is a wrapper object that implements additional functionality
type Customer struct {
	sync.Mutex
	bookstore.Customer
	HandlerCtx interface{} // additional state handlers can store
	ctrler     *ctrlerCtx  // reference back to the controller instance
}

func (obj *Customer) Write() error {
	// if there is no API server to connect to, we are done
	if (obj.ctrler == nil) || (obj.ctrler.resolver == nil) || obj.ctrler.apisrvURL == "" {
		return nil
	}

	apicl, err := obj.ctrler.apiClient()
	if err != nil {
		obj.ctrler.logger.Errorf("Error creating API server clent. Err: %v", err)
		return err
	}

	obj.ctrler.stats.Counter("Customer_Writes").Inc()

	// write to api server
	if obj.ObjectMeta.ResourceVersion != "" {
		// update it
		for i := 0; i < maxApisrvWriteRetry; i++ {
			_, err = apicl.BookstoreV1().Customer().UpdateStatus(context.Background(), &obj.Customer)
			if err == nil {
				break
			}
			time.Sleep(time.Millisecond * 100)
		}
	} else {
		//  create
		_, err = apicl.BookstoreV1().Customer().Create(context.Background(), &obj.Customer)
	}

	return nil
}

// CustomerHandler is the event handler for Customer object
type CustomerHandler interface {
	OnCustomerCreate(obj *Customer) error
	OnCustomerUpdate(oldObj *Customer, newObj *bookstore.Customer) error
	OnCustomerDelete(obj *Customer) error
	GetCustomerWatchOptions() *api.ListWatchOptions
}

// OnCustomerCreate is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnCustomerCreate(obj *Customer) error {
	log.Info("OnCustomerCreate is not implemented")
	return nil
}

// OnCustomerUpdate is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnCustomerUpdate(oldObj *Customer, newObj *bookstore.Customer) error {
	log.Info("OnCustomerUpdate is not implemented")
	return nil
}

// OnCustomerDelete is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnCustomerDelete(obj *Customer) error {
	log.Info("OnCustomerDelete is not implemented")
	return nil
}

// GetCustomerWatchOptions is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) GetCustomerWatchOptions() *api.ListWatchOptions {
	log.Info("GetCustomerWatchOptions is not implemented")
	opts := &api.ListWatchOptions{}
	return opts
}

// handleCustomerEvent handles Customer events from watcher
func (ct *ctrlerCtx) handleCustomerEvent(evt *kvstore.WatchEvent) error {

	if ct.objResolver == nil {
		return ct.handleCustomerEventNoResolver(evt)
	}

	switch tp := evt.Object.(type) {
	case *bookstore.Customer:
		eobj := evt.Object.(*bookstore.Customer)
		kind := "Customer"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ctx := &customerCtx{event: evt.Type,
			obj: &Customer{Customer: *eobj, ctrler: ct}}

		var err error
		switch evt.Type {
		case kvstore.Created:
			err = ct.processAdd(ctx)
		case kvstore.Updated:
			err = ct.processUpdate(ctx)
		case kvstore.Deleted:
			err = ct.processDelete(ctx)
		}
		return err
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on Customer watch channel", tp)
	}

	return nil
}

// handleCustomerEventNoResolver handles Customer events from watcher
func (ct *ctrlerCtx) handleCustomerEventNoResolver(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *bookstore.Customer:
		eobj := evt.Object.(*bookstore.Customer)
		kind := "Customer"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		customerHandler := handler.(CustomerHandler)
		// handle based on event type
		ctrlCtx := &customerCtx{event: evt.Type, obj: &Customer{Customer: *eobj, ctrler: ct}}
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			fobj, err := ct.getObject(kind, ctrlCtx.GetKey())
			if err != nil {
				ct.addObject(ctrlCtx)
				ct.stats.Counter("Customer_Created_Events").Inc()

				// call the event handler
				ctrlCtx.Lock()
				err = customerHandler.OnCustomerCreate(ctrlCtx.obj)
				ctrlCtx.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctrlCtx.obj, err)
					ct.delObject(kind, ctrlCtx.GetKey())
					return err
				}
			} else {
				fResVer, fErr := strconv.ParseInt(fobj.GetResourceVersion(), 10, 64)
				eResVer, eErr := strconv.ParseInt(eobj.GetResourceVersion(), 10, 64)
				if ct.resolver != nil && fErr == nil && eErr == nil && fResVer >= eResVer {
					// Event already processed.
					ct.logger.Infof("Skipping update due to old resource version")
					return nil
				}
				ctrlCtx := fobj.(*customerCtx)
				ct.stats.Counter("Customer_Updated_Events").Inc()
				ctrlCtx.Lock()
				p := bookstore.Customer{Spec: eobj.Spec,
					ObjectMeta: eobj.ObjectMeta,
					TypeMeta:   eobj.TypeMeta,
					Status:     eobj.Status}

				err = customerHandler.OnCustomerUpdate(ctrlCtx.obj, &p)
				ctrlCtx.obj.Customer = *eobj
				ctrlCtx.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctrlCtx.obj, err)
					return err
				}

			}
		case kvstore.Deleted:
			ctrlCtx := &customerCtx{event: evt.Type, obj: &Customer{Customer: *eobj, ctrler: ct}}
			fobj, err := ct.findObject(kind, ctrlCtx.GetKey())
			if err != nil {
				ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
				return err
			}

			obj := fobj.(*Customer)
			ct.stats.Counter("Customer_Deleted_Events").Inc()
			obj.Lock()
			err = customerHandler.OnCustomerDelete(obj)
			obj.Unlock()
			if err != nil {
				ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
			}
			ct.delObject(kind, ctrlCtx.GetKey())
			return nil

		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on Customer watch channel", tp)
	}

	return nil
}

type customerCtx struct {
	ctkitBaseCtx
	event kvstore.WatchEventType
	obj   *Customer //
	//   newObj     *bookstore.Customer //update
	newObj *customerCtx //update
}

func (ctx *customerCtx) References() map[string]apiintf.ReferenceObj {
	resp := make(map[string]apiintf.ReferenceObj)
	ctx.obj.References(ctx.obj.GetObjectMeta().Name, ctx.obj.GetObjectMeta().Namespace, resp)
	return resp
}

func (ctx *customerCtx) GetKey() string {
	return ctx.obj.MakeKey("bookstore")
}

func (ctx *customerCtx) GetKind() string {
	return ctx.obj.GetKind()
}

func (ctx *customerCtx) GetResourceVersion() string {
	return ctx.obj.GetResourceVersion()
}

func (ctx *customerCtx) SetEvent(event kvstore.WatchEventType) {
	ctx.event = event
}

func (ctx *customerCtx) SetNewObj(newObj apiintf.CtkitObject) {
	if newObj == nil {
		ctx.newObj = nil
	} else {
		ctx.newObj = newObj.(*customerCtx)
		ctx.newObj.obj.HandlerCtx = ctx.obj.HandlerCtx
	}
}

func (ctx *customerCtx) GetNewObj() apiintf.CtkitObject {
	return ctx.newObj
}

func (ctx *customerCtx) Copy(obj apiintf.CtkitObject) {
	ctx.obj.Customer = obj.(*customerCtx).obj.Customer
}

func (ctx *customerCtx) Lock() {
	ctx.obj.Lock()
}

func (ctx *customerCtx) Unlock() {
	ctx.obj.Unlock()
}

func (ctx *customerCtx) GetObjectMeta() *api.ObjectMeta {
	return ctx.obj.GetObjectMeta()
}

func (ctx *customerCtx) RuntimeObject() runtime.Object {
	var v interface{}
	v = ctx.obj
	return v.(runtime.Object)
}

func (ctx *customerCtx) WorkFunc(context context.Context) error {
	var err error
	evt := ctx.event
	ct := ctx.obj.ctrler
	kind := "Customer"
	ct.Lock()
	handler, ok := ct.handlers[kind]
	ct.Unlock()
	if !ok {
		ct.logger.Fatalf("Cant find the handler for %s", kind)
	}
	customerHandler := handler.(CustomerHandler)
	switch evt {
	case kvstore.Created:
		ctx.obj.Lock()
		err = customerHandler.OnCustomerCreate(ctx.obj)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctx.obj, err)
			ctx.SetEvent(kvstore.Deleted)
		}
	case kvstore.Updated:
		ct.stats.Counter("Customer_Updated_Events").Inc()
		ctx.obj.Lock()
		p := bookstore.Customer{Spec: ctx.newObj.obj.Spec,
			ObjectMeta: ctx.newObj.obj.ObjectMeta,
			TypeMeta:   ctx.newObj.obj.TypeMeta,
			Status:     ctx.newObj.obj.Status}
		err = customerHandler.OnCustomerUpdate(ctx.obj, &p)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctx.obj, err)
			ctx.SetEvent(kvstore.Deleted)
		}
	case kvstore.Deleted:
		ctx.obj.Lock()
		err = customerHandler.OnCustomerDelete(ctx.obj)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error deleting %s %+v. Err: %v", kind, ctx.obj, err)
		}
	}
	ct.resolveObject(ctx.event, ctx)
	return nil
}

// handleCustomerEventParallel handles Customer events from watcher
func (ct *ctrlerCtx) handleCustomerEventParallel(evt *kvstore.WatchEvent) error {

	if ct.objResolver == nil {
		return ct.handleCustomerEventParallelWithNoResolver(evt)
	}

	switch tp := evt.Object.(type) {
	case *bookstore.Customer:
		eobj := evt.Object.(*bookstore.Customer)
		kind := "Customer"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ctx := &customerCtx{event: evt.Type, obj: &Customer{Customer: *eobj, ctrler: ct}}

		var err error
		switch evt.Type {
		case kvstore.Created:
			err = ct.processAdd(ctx)
		case kvstore.Updated:
			err = ct.processUpdate(ctx)
		case kvstore.Deleted:
			err = ct.processDelete(ctx)
		}
		return err
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on Customer watch channel", tp)
	}

	return nil
}

// handleCustomerEventParallel handles Customer events from watcher
func (ct *ctrlerCtx) handleCustomerEventParallelWithNoResolver(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *bookstore.Customer:
		eobj := evt.Object.(*bookstore.Customer)
		kind := "Customer"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		customerHandler := handler.(CustomerHandler)
		// handle based on event type
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			workFunc := func(ctx context.Context, ctrlCtx shardworkers.WorkObj) error {
				var err error
				workCtx := ctrlCtx.(*customerCtx)
				eobj := workCtx.obj
				fobj, err := ct.getObject(kind, workCtx.GetKey())
				if err != nil {
					ct.addObject(workCtx)
					ct.stats.Counter("Customer_Created_Events").Inc()
					eobj.Lock()
					err = customerHandler.OnCustomerCreate(eobj)
					eobj.Unlock()
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, eobj, err)
						ct.delObject(kind, workCtx.GetKey())
					}
				} else {
					workCtx := fobj.(*customerCtx)
					obj := workCtx.obj
					ct.stats.Counter("Customer_Updated_Events").Inc()
					obj.Lock()
					p := bookstore.Customer{Spec: eobj.Spec,
						ObjectMeta: eobj.ObjectMeta,
						TypeMeta:   eobj.TypeMeta,
						Status:     eobj.Status}

					err = customerHandler.OnCustomerUpdate(obj, &p)
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					} else {
						workCtx.obj.Customer = p
					}
					obj.Unlock()
				}
				return err
			}
			ctrlCtx := &customerCtx{event: evt.Type, obj: &Customer{Customer: *eobj, ctrler: ct}}
			ct.runFunction("Customer", ctrlCtx, workFunc)
		case kvstore.Deleted:
			workFunc := func(ctx context.Context, ctrlCtx shardworkers.WorkObj) error {
				var err error
				workCtx := ctrlCtx.(*customerCtx)
				eobj := workCtx.obj
				fobj, err := ct.findObject(kind, workCtx.GetKey())
				if err != nil {
					ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
					return err
				}
				obj := fobj.(*Customer)
				ct.stats.Counter("Customer_Deleted_Events").Inc()
				obj.Lock()
				err = customerHandler.OnCustomerDelete(obj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
				}
				ct.delObject(kind, workCtx.GetKey())
				return nil
			}
			ctrlCtx := &customerCtx{event: evt.Type, obj: &Customer{Customer: *eobj, ctrler: ct}}
			ct.runFunction("Customer", ctrlCtx, workFunc)
		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on Customer watch channel", tp)
	}

	return nil
}

// diffCustomer does a diff of Customer objects between local cache and API server
func (ct *ctrlerCtx) diffCustomer(apicl apiclient.Services) {
	opts := api.ListWatchOptions{}

	// get a list of all objects from API server
	objlist, err := apicl.BookstoreV1().Customer().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Errorf("Error getting a list of objects. Err: %v", err)
		return
	}

	ct.logger.Infof("diffCustomer(): CustomerList returned %d objects", len(objlist))

	// build an object map
	objmap := make(map[string]*bookstore.Customer)
	for _, obj := range objlist {
		objmap[obj.GetKey()] = obj
	}

	list, err := ct.Customer().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Infof("Failed to get a list of objects. Err: %s", err)
		return
	}

	// if an object is in our local cache and not in API server, trigger delete for it
	for _, obj := range list {
		_, ok := objmap[obj.GetKey()]
		if !ok {
			ct.logger.Infof("diffCustomer(): Deleting existing object %#v since its not in apiserver", obj.GetKey())
			evt := kvstore.WatchEvent{
				Type:   kvstore.Deleted,
				Key:    obj.GetKey(),
				Object: &obj.Customer,
			}
			ct.handleCustomerEvent(&evt)
		}
	}

	// trigger create event for all others
	for _, obj := range objlist {
		ct.logger.Infof("diffCustomer(): Adding object %#v", obj.GetKey())
		evt := kvstore.WatchEvent{
			Type:   kvstore.Created,
			Key:    obj.GetKey(),
			Object: obj,
		}
		ct.handleCustomerEvent(&evt)
	}
}

func (ct *ctrlerCtx) runCustomerWatcher() {
	kind := "Customer"

	ct.Lock()
	handler, ok := ct.handlers[kind]
	ct.Unlock()
	if !ok {
		ct.logger.Fatalf("Cant find the handler for %s", kind)
	}
	customerHandler := handler.(CustomerHandler)

	opts := customerHandler.GetCustomerWatchOptions()

	// if there is no API server to connect to, we are done
	if (ct.resolver == nil) || ct.apisrvURL == "" {
		return
	}

	// create context
	ctx, cancel := context.WithCancel(context.Background())
	ct.Lock()
	ct.watchCancel[kind] = cancel
	ct.Unlock()
	logger := ct.logger.WithContext("submodule", "CustomerWatcher")

	// create a grpc client
	apiclt, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
	if err == nil {
		ct.diffCustomer(apiclt)
	}

	// setup wait group
	ct.waitGrp.Add(1)

	// start a goroutine
	go func() {
		defer ct.waitGrp.Done()
		ct.stats.Counter("Customer_Watch").Inc()
		defer ct.stats.Counter("Customer_Watch").Dec()

		// loop forever
		for {
			// create a grpc client
			apicl, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
			if err != nil {
				logger.Warnf("Failed to connect to gRPC server [%s]\n", ct.apisrvURL)
				ct.stats.Counter("Customer_ApiClientErr").Inc()
			} else {
				logger.Infof("API client connected {%+v}", apicl)

				// Customer object watcher
				wt, werr := apicl.BookstoreV1().Customer().Watch(ctx, opts)
				if werr != nil {
					select {
					case <-ctx.Done():
						logger.Infof("watch %s cancelled", kind)
						return
					default:
					}
					logger.Errorf("Failed to start %s watch (%s)\n", kind, werr)
					// wait for a second and retry connecting to api server
					apicl.Close()
					time.Sleep(time.Second)
					continue
				}
				ct.Lock()
				ct.watchers[kind] = wt
				ct.Unlock()

				// perform a diff with API server and local cache
				time.Sleep(time.Millisecond * 100)
				ct.diffCustomer(apicl)

				// handle api server watch events
			innerLoop:
				for {
					// wait for events
					select {
					case evt, ok := <-wt.EventChan():
						if !ok {
							logger.Error("Error receiving from apisrv watcher")
							ct.stats.Counter("Customer_WatchErrors").Inc()
							break innerLoop
						}

						// handle event in parallel
						ct.handleCustomerEventParallel(evt)
					}
				}
				apicl.Close()
			}

			// if stop flag is set, we are done
			if ct.stoped {
				logger.Infof("Exiting API server watcher")
				return
			}

			// wait for a second and retry connecting to api server
			time.Sleep(time.Second)
		}
	}()
}

// WatchCustomer starts watch on Customer object
func (ct *ctrlerCtx) WatchCustomer(handler CustomerHandler) error {
	kind := "Customer"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchers[kind]
	ct.Unlock()
	if ok {
		return fmt.Errorf("Customer watcher already exists")
	}

	// save handler
	ct.Lock()
	ct.handlers[kind] = handler
	ct.Unlock()

	// run Customer watcher in a go routine
	ct.runCustomerWatcher()

	return nil
}

// StopWatchCustomer stops watch on Customer object
func (ct *ctrlerCtx) StopWatchCustomer(handler CustomerHandler) error {
	kind := "Customer"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchers[kind]
	ct.Unlock()
	if !ok {
		return fmt.Errorf("Customer watcher does not exist")
	}

	ct.Lock()
	cancel, _ := ct.watchCancel[kind]
	cancel()
	delete(ct.watchers, kind)
	delete(ct.watchCancel, kind)
	ct.Unlock()

	time.Sleep(100 * time.Millisecond)

	return nil
}

// CustomerAPI returns
type CustomerAPI interface {
	Create(obj *bookstore.Customer) error
	SyncCreate(obj *bookstore.Customer) error
	Update(obj *bookstore.Customer) error
	SyncUpdate(obj *bookstore.Customer) error
	Delete(obj *bookstore.Customer) error
	Find(meta *api.ObjectMeta) (*Customer, error)
	List(ctx context.Context, opts *api.ListWatchOptions) ([]*Customer, error)
	Watch(handler CustomerHandler) error
	StopWatch(handler CustomerHandler) error
}

// dummy struct that implements CustomerAPI
type customerAPI struct {
	ct *ctrlerCtx
}

// Create creates Customer object
func (api *customerAPI) Create(obj *bookstore.Customer) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.BookstoreV1().Customer().Create(context.Background(), obj)
		if err != nil && strings.Contains(err.Error(), "AlreadyExists") {
			_, err = apicl.BookstoreV1().Customer().Update(context.Background(), obj)

		}
		return err
	}

	api.ct.handleCustomerEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Created})
	return nil
}

// SyncCreate creates Customer object and updates the cache
func (api *customerAPI) SyncCreate(obj *bookstore.Customer) error {
	newObj := obj
	evtType := kvstore.Created
	var writeErr error
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		newObj, writeErr = apicl.BookstoreV1().Customer().Create(context.Background(), obj)
		if writeErr != nil && strings.Contains(writeErr.Error(), "AlreadyExists") {
			newObj, writeErr = apicl.BookstoreV1().Customer().Update(context.Background(), obj)
			evtType = kvstore.Updated
		}
	}

	if writeErr == nil {
		api.ct.handleCustomerEvent(&kvstore.WatchEvent{Object: newObj, Type: evtType})
	}
	return writeErr
}

// Update triggers update on Customer object
func (api *customerAPI) Update(obj *bookstore.Customer) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.BookstoreV1().Customer().Update(context.Background(), obj)
		return err
	}

	api.ct.handleCustomerEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Updated})
	return nil
}

// SyncUpdate triggers update on Customer object and updates the cache
func (api *customerAPI) SyncUpdate(obj *bookstore.Customer) error {
	newObj := obj
	var writeErr error
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		newObj, writeErr = apicl.BookstoreV1().Customer().Update(context.Background(), obj)
	}

	if writeErr == nil {
		api.ct.handleCustomerEvent(&kvstore.WatchEvent{Object: newObj, Type: kvstore.Updated})
	}

	return writeErr
}

// Delete deletes Customer object
func (api *customerAPI) Delete(obj *bookstore.Customer) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.BookstoreV1().Customer().Delete(context.Background(), &obj.ObjectMeta)
		return err
	}

	api.ct.handleCustomerEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Deleted})
	return nil
}

// MakeKey generates a KV store key for the object
func (api *customerAPI) getFullKey(tenant, name string) string {
	if tenant != "" {
		return fmt.Sprint(globals.ConfigRootPrefix, "/", "bookstore", "/", "customers", "/", tenant, "/", name)
	}
	return fmt.Sprint(globals.ConfigRootPrefix, "/", "bookstore", "/", "customers", "/", name)
}

// Find returns an object by meta
func (api *customerAPI) Find(meta *api.ObjectMeta) (*Customer, error) {
	// find the object
	obj, err := api.ct.FindObject("Customer", meta)
	if err != nil {
		return nil, err
	}

	// asset type
	switch obj.(type) {
	case *Customer:
		hobj := obj.(*Customer)
		return hobj, nil
	default:
		return nil, errors.New("incorrect object type")
	}
}

// List returns a list of all Customer objects
func (api *customerAPI) List(ctx context.Context, opts *api.ListWatchOptions) ([]*Customer, error) {
	var objlist []*Customer
	objs, err := api.ct.List("Customer", ctx, opts)

	if err != nil {
		return nil, err
	}

	for _, obj := range objs {
		switch tp := obj.(type) {
		case *Customer:
			eobj := obj.(*Customer)
			objlist = append(objlist, eobj)
		default:
			log.Fatalf("Got invalid object type %v while looking for Customer", tp)
		}
	}

	return objlist, nil
}

// Watch sets up a event handlers for Customer object
func (api *customerAPI) Watch(handler CustomerHandler) error {
	api.ct.startWorkerPool("Customer")
	return api.ct.WatchCustomer(handler)
}

// StopWatch stop watch for Tenant Customer object
func (api *customerAPI) StopWatch(handler CustomerHandler) error {
	api.ct.Lock()
	api.ct.workPools["Customer"].Stop()
	api.ct.Unlock()
	return api.ct.StopWatchCustomer(handler)
}

// Customer returns CustomerAPI
func (ct *ctrlerCtx) Customer() CustomerAPI {
	kind := "Customer"
	if _, ok := ct.apiInfMap[kind]; !ok {
		s := &customerAPI{ct: ct}
		ct.apiInfMap[kind] = s
	}
	return ct.apiInfMap[kind].(*customerAPI)
}
