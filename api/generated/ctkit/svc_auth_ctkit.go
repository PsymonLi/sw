// Code generated by protoc-gen-grpc-pensando DO NOT EDIT.

/*
Package ctkit is a auto generated package.
Input file: svc_auth.proto
*/
package ctkit

import (
	"context"
	"errors"
	"fmt"
	"strings"
	"sync"
	"time"

	"github.com/pensando/sw/api"
	"github.com/pensando/sw/api/generated/apiclient"
	"github.com/pensando/sw/api/generated/auth"
	apiintf "github.com/pensando/sw/api/interfaces"
	"github.com/pensando/sw/venice/globals"
	"github.com/pensando/sw/venice/utils/balancer"
	"github.com/pensando/sw/venice/utils/kvstore"
	"github.com/pensando/sw/venice/utils/log"
	"github.com/pensando/sw/venice/utils/rpckit"
	"github.com/pensando/sw/venice/utils/runtime"
	"github.com/pensando/sw/venice/utils/shardworkers"
)

// User is a wrapper object that implements additional functionality
type User struct {
	sync.Mutex
	auth.User
	HandlerCtx interface{} // additional state handlers can store
	ctrler     *ctrlerCtx  // reference back to the controller instance
}

func (obj *User) Write() error {
	// if there is no API server to connect to, we are done
	if (obj.ctrler == nil) || (obj.ctrler.resolver == nil) || obj.ctrler.apisrvURL == "" {
		return nil
	}

	apicl, err := obj.ctrler.apiClient()
	if err != nil {
		obj.ctrler.logger.Errorf("Error creating API server clent. Err: %v", err)
		return err
	}

	obj.ctrler.stats.Counter("User_Writes").Inc()

	// write to api server
	if obj.ObjectMeta.ResourceVersion != "" {
		// update it
		for i := 0; i < maxApisrvWriteRetry; i++ {
			_, err = apicl.AuthV1().User().UpdateStatus(context.Background(), &obj.User)
			if err == nil {
				break
			}
			time.Sleep(time.Millisecond * 100)
		}
	} else {
		//  create
		_, err = apicl.AuthV1().User().Create(context.Background(), &obj.User)
	}

	return nil
}

// UserHandler is the event handler for User object
type UserHandler interface {
	OnUserCreate(obj *User) error
	OnUserUpdate(oldObj *User, newObj *auth.User) error
	OnUserDelete(obj *User) error
	GetUserWatchOptions() *api.ListWatchOptions
}

// handleUserEvent handles User events from watcher
func (ct *ctrlerCtx) handleUserEvent(evt *kvstore.WatchEvent) error {

	if ct.objResolver == nil {
		return ct.handleUserEventNoResolver(evt)
	}

	switch tp := evt.Object.(type) {
	case *auth.User:
		eobj := evt.Object.(*auth.User)
		kind := "User"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ctx := &userCtx{event: evt.Type,
			obj: &User{User: *eobj, ctrler: ct}}

		var err error
		switch evt.Type {
		case kvstore.Created:
			err = ct.processAdd(ctx)
		case kvstore.Updated:
			err = ct.processUpdate(ctx)
		case kvstore.Deleted:
			err = ct.processDelete(ctx)
		}
		return err
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on User watch channel", tp)
	}

	return nil
}

// handleUserEventNoResolver handles User events from watcher
func (ct *ctrlerCtx) handleUserEventNoResolver(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *auth.User:
		eobj := evt.Object.(*auth.User)
		kind := "User"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		userHandler := handler.(UserHandler)
		// handle based on event type
		ctrlCtx := &userCtx{event: evt.Type, obj: &User{User: *eobj, ctrler: ct}}
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			fobj, err := ct.getObject(kind, ctrlCtx.GetKey())
			if err != nil {
				ct.addObject(ctrlCtx)
				ct.stats.Counter("User_Created_Events").Inc()

				// call the event handler
				ctrlCtx.Lock()
				err = userHandler.OnUserCreate(ctrlCtx.obj)
				ctrlCtx.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctrlCtx.obj, err)
					ct.delObject(kind, ctrlCtx.GetKey())
					return err
				}
			} else {
				ctrlCtx := fobj.(*userCtx)
				ct.stats.Counter("User_Updated_Events").Inc()
				ctrlCtx.Lock()
				p := auth.User{Spec: eobj.Spec,
					ObjectMeta: eobj.ObjectMeta,
					TypeMeta:   eobj.TypeMeta,
					Status:     eobj.Status}

				err = userHandler.OnUserUpdate(ctrlCtx.obj, &p)
				ctrlCtx.obj.User = *eobj
				ctrlCtx.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctrlCtx.obj, err)
					return err
				}

			}
		case kvstore.Deleted:
			ctrlCtx := &userCtx{event: evt.Type, obj: &User{User: *eobj, ctrler: ct}}
			fobj, err := ct.findObject(kind, ctrlCtx.GetKey())
			if err != nil {
				ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
				return err
			}

			obj := fobj.(*User)
			ct.stats.Counter("User_Deleted_Events").Inc()
			obj.Lock()
			err = userHandler.OnUserDelete(obj)
			obj.Unlock()
			if err != nil {
				ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
			}
			ct.delObject(kind, ctrlCtx.GetKey())
			return nil

		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on User watch channel", tp)
	}

	return nil
}

type userCtx struct {
	ctkitBaseCtx
	event kvstore.WatchEventType
	obj   *User //
	//   newObj     *auth.User //update
	newObj *userCtx //update
}

func (ctx *userCtx) References() map[string]apiintf.ReferenceObj {
	resp := make(map[string]apiintf.ReferenceObj)
	ctx.obj.References(ctx.obj.GetObjectMeta().Name, ctx.obj.GetObjectMeta().Namespace, resp)
	return resp
}

func (ctx *userCtx) GetKey() string {
	return ctx.obj.MakeKey("auth")
}

func (ctx *userCtx) GetKind() string {
	return ctx.obj.GetKind()
}

func (ctx *userCtx) SetEvent(event kvstore.WatchEventType) {
	ctx.event = event
}

func (ctx *userCtx) SetNewObj(newObj apiintf.CtkitObject) {
	if newObj == nil {
		ctx.newObj = nil
	} else {
		ctx.newObj = newObj.(*userCtx)
		ctx.newObj.obj.HandlerCtx = ctx.obj.HandlerCtx
	}
}

func (ctx *userCtx) GetNewObj() apiintf.CtkitObject {
	return ctx.newObj
}

func (ctx *userCtx) Copy(obj apiintf.CtkitObject) {
	ctx.obj.User = obj.(*userCtx).obj.User
}

func (ctx *userCtx) Lock() {
	ctx.obj.Lock()
}

func (ctx *userCtx) Unlock() {
	ctx.obj.Unlock()
}

func (ctx *userCtx) GetObjectMeta() *api.ObjectMeta {
	return ctx.obj.GetObjectMeta()
}

func (ctx *userCtx) RuntimeObject() runtime.Object {
	var v interface{}
	v = ctx.obj
	return v.(runtime.Object)
}

func (ctx *userCtx) WorkFunc(context context.Context) error {
	var err error
	evt := ctx.event
	ct := ctx.obj.ctrler
	kind := "User"
	ct.Lock()
	handler, ok := ct.handlers[kind]
	ct.Unlock()
	if !ok {
		ct.logger.Fatalf("Cant find the handler for %s", kind)
	}
	userHandler := handler.(UserHandler)
	switch evt {
	case kvstore.Created:
		ctx.obj.Lock()
		err = userHandler.OnUserCreate(ctx.obj)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctx.obj, err)
			ctx.SetEvent(kvstore.Deleted)
		}
	case kvstore.Updated:
		ct.stats.Counter("User_Updated_Events").Inc()
		ctx.obj.Lock()
		p := auth.User{Spec: ctx.newObj.obj.Spec,
			ObjectMeta: ctx.newObj.obj.ObjectMeta,
			TypeMeta:   ctx.newObj.obj.TypeMeta,
			Status:     ctx.newObj.obj.Status}
		err = userHandler.OnUserUpdate(ctx.obj, &p)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctx.obj, err)
			ctx.SetEvent(kvstore.Deleted)
		}
	case kvstore.Deleted:
		ctx.obj.Lock()
		err = userHandler.OnUserDelete(ctx.obj)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error deleting %s %+v. Err: %v", kind, ctx.obj, err)
		}
	}
	ct.resolveObject(ctx.event, ctx)
	return nil
}

// handleUserEventParallel handles User events from watcher
func (ct *ctrlerCtx) handleUserEventParallel(evt *kvstore.WatchEvent) error {

	if ct.objResolver == nil {
		return ct.handleUserEventParallelWithNoResolver(evt)
	}

	switch tp := evt.Object.(type) {
	case *auth.User:
		eobj := evt.Object.(*auth.User)
		kind := "User"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ctx := &userCtx{event: evt.Type, obj: &User{User: *eobj, ctrler: ct}}

		var err error
		switch evt.Type {
		case kvstore.Created:
			err = ct.processAdd(ctx)
		case kvstore.Updated:
			err = ct.processUpdate(ctx)
		case kvstore.Deleted:
			err = ct.processDelete(ctx)
		}
		return err
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on User watch channel", tp)
	}

	return nil
}

// handleUserEventParallel handles User events from watcher
func (ct *ctrlerCtx) handleUserEventParallelWithNoResolver(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *auth.User:
		eobj := evt.Object.(*auth.User)
		kind := "User"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		userHandler := handler.(UserHandler)
		// handle based on event type
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			workFunc := func(ctx context.Context, ctrlCtx shardworkers.WorkObj) error {
				var err error
				workCtx := ctrlCtx.(*userCtx)
				eobj := workCtx.obj
				fobj, err := ct.getObject(kind, workCtx.GetKey())
				if err != nil {
					ct.addObject(workCtx)
					ct.stats.Counter("User_Created_Events").Inc()
					eobj.Lock()
					err = userHandler.OnUserCreate(eobj)
					eobj.Unlock()
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, eobj, err)
						ct.delObject(kind, workCtx.GetKey())
					}
				} else {
					workCtx := fobj.(*userCtx)
					obj := workCtx.obj
					ct.stats.Counter("User_Updated_Events").Inc()
					obj.Lock()
					p := auth.User{Spec: eobj.Spec,
						ObjectMeta: eobj.ObjectMeta,
						TypeMeta:   eobj.TypeMeta,
						Status:     eobj.Status}

					err = userHandler.OnUserUpdate(obj, &p)
					workCtx.obj.User = p
					obj.Unlock()
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					}
				}
				return err
			}
			ctrlCtx := &userCtx{event: evt.Type, obj: &User{User: *eobj, ctrler: ct}}
			ct.runFunction("User", ctrlCtx, workFunc)
		case kvstore.Deleted:
			workFunc := func(ctx context.Context, ctrlCtx shardworkers.WorkObj) error {
				var err error
				workCtx := ctrlCtx.(*userCtx)
				eobj := workCtx.obj
				fobj, err := ct.findObject(kind, workCtx.GetKey())
				if err != nil {
					ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
					return err
				}
				obj := fobj.(*User)
				ct.stats.Counter("User_Deleted_Events").Inc()
				obj.Lock()
				err = userHandler.OnUserDelete(obj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
				}
				ct.delObject(kind, workCtx.GetKey())
				return nil
			}
			ctrlCtx := &userCtx{event: evt.Type, obj: &User{User: *eobj, ctrler: ct}}
			ct.runFunction("User", ctrlCtx, workFunc)
		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on User watch channel", tp)
	}

	return nil
}

// diffUser does a diff of User objects between local cache and API server
func (ct *ctrlerCtx) diffUser(apicl apiclient.Services) {
	opts := api.ListWatchOptions{}

	// get a list of all objects from API server
	objlist, err := apicl.AuthV1().User().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Errorf("Error getting a list of objects. Err: %v", err)
		return
	}

	ct.logger.Infof("diffUser(): UserList returned %d objects", len(objlist))

	// build an object map
	objmap := make(map[string]*auth.User)
	for _, obj := range objlist {
		objmap[obj.GetKey()] = obj
	}

	list, err := ct.User().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Infof("Failed to get a list of objects. Err: %s", err)
		return
	}

	// if an object is in our local cache and not in API server, trigger delete for it
	for _, obj := range list {
		_, ok := objmap[obj.GetKey()]
		if !ok {
			ct.logger.Infof("diffUser(): Deleting existing object %#v since its not in apiserver", obj.GetKey())
			evt := kvstore.WatchEvent{
				Type:   kvstore.Deleted,
				Key:    obj.GetKey(),
				Object: &obj.User,
			}
			ct.handleUserEvent(&evt)
		}
	}

	// trigger create event for all others
	for _, obj := range objlist {
		ct.logger.Infof("diffUser(): Adding object %#v", obj.GetKey())
		evt := kvstore.WatchEvent{
			Type:   kvstore.Created,
			Key:    obj.GetKey(),
			Object: obj,
		}
		ct.handleUserEvent(&evt)
	}
}

func (ct *ctrlerCtx) runUserWatcher() {
	kind := "User"

	ct.Lock()
	handler, ok := ct.handlers[kind]
	ct.Unlock()
	if !ok {
		ct.logger.Fatalf("Cant find the handler for %s", kind)
	}
	userHandler := handler.(UserHandler)

	opts := userHandler.GetUserWatchOptions()

	// if there is no API server to connect to, we are done
	if (ct.resolver == nil) || ct.apisrvURL == "" {
		return
	}

	// create context
	ctx, cancel := context.WithCancel(context.Background())
	ct.Lock()
	ct.watchCancel[kind] = cancel
	ct.Unlock()
	logger := ct.logger.WithContext("submodule", "UserWatcher")

	// create a grpc client
	apiclt, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
	if err == nil {
		ct.diffUser(apiclt)
	}

	// setup wait group
	ct.waitGrp.Add(1)

	// start a goroutine
	go func() {
		defer ct.waitGrp.Done()
		ct.stats.Counter("User_Watch").Inc()
		defer ct.stats.Counter("User_Watch").Dec()

		// loop forever
		for {
			// create a grpc client
			apicl, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
			if err != nil {
				logger.Warnf("Failed to connect to gRPC server [%s]\n", ct.apisrvURL)
				ct.stats.Counter("User_ApiClientErr").Inc()
			} else {
				logger.Infof("API client connected {%+v}", apicl)

				// User object watcher
				wt, werr := apicl.AuthV1().User().Watch(ctx, opts)
				if werr != nil {
					select {
					case <-ctx.Done():
						logger.Infof("watch %s cancelled", kind)
						return
					default:
					}
					logger.Errorf("Failed to start %s watch (%s)\n", kind, werr)
					// wait for a second and retry connecting to api server
					apicl.Close()
					time.Sleep(time.Second)
					continue
				}
				ct.Lock()
				ct.watchers[kind] = wt
				ct.Unlock()

				// perform a diff with API server and local cache
				time.Sleep(time.Millisecond * 100)
				ct.diffUser(apicl)

				// handle api server watch events
			innerLoop:
				for {
					// wait for events
					select {
					case evt, ok := <-wt.EventChan():
						if !ok {
							logger.Error("Error receiving from apisrv watcher")
							ct.stats.Counter("User_WatchErrors").Inc()
							break innerLoop
						}

						// handle event in parallel
						ct.handleUserEventParallel(evt)
					}
				}
				apicl.Close()
			}

			// if stop flag is set, we are done
			if ct.stoped {
				logger.Infof("Exiting API server watcher")
				return
			}

			// wait for a second and retry connecting to api server
			time.Sleep(time.Second)
		}
	}()
}

// WatchUser starts watch on User object
func (ct *ctrlerCtx) WatchUser(handler UserHandler) error {
	kind := "User"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchers[kind]
	ct.Unlock()
	if ok {
		return fmt.Errorf("User watcher already exists")
	}

	// save handler
	ct.Lock()
	ct.handlers[kind] = handler
	ct.Unlock()

	// run User watcher in a go routine
	ct.runUserWatcher()

	return nil
}

// StopWatchUser stops watch on User object
func (ct *ctrlerCtx) StopWatchUser(handler UserHandler) error {
	kind := "User"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchers[kind]
	ct.Unlock()
	if !ok {
		return fmt.Errorf("User watcher does not exist")
	}

	ct.Lock()
	cancel, _ := ct.watchCancel[kind]
	cancel()
	delete(ct.watchers, kind)
	delete(ct.watchCancel, kind)
	ct.Unlock()

	time.Sleep(100 * time.Millisecond)

	return nil
}

// UserAPI returns
type UserAPI interface {
	Create(obj *auth.User) error
	CreateEvent(obj *auth.User) error
	Update(obj *auth.User) error
	Delete(obj *auth.User) error
	Find(meta *api.ObjectMeta) (*User, error)
	List(ctx context.Context, opts *api.ListWatchOptions) ([]*User, error)
	Watch(handler UserHandler) error
	StopWatch(handler UserHandler) error
}

// dummy struct that implements UserAPI
type userAPI struct {
	ct *ctrlerCtx
}

// Create creates User object
func (api *userAPI) Create(obj *auth.User) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.AuthV1().User().Create(context.Background(), obj)
		if err != nil && strings.Contains(err.Error(), "AlreadyExists") {
			_, err = apicl.AuthV1().User().Update(context.Background(), obj)
		}
		return err
	}

	api.ct.handleUserEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Created})
	return nil
}

// CreateEvent creates User object and synchronously triggers local event
func (api *userAPI) CreateEvent(obj *auth.User) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.AuthV1().User().Create(context.Background(), obj)
		if err != nil && strings.Contains(err.Error(), "AlreadyExists") {
			_, err = apicl.AuthV1().User().Update(context.Background(), obj)
		}
		if err != nil {
			api.ct.logger.Errorf("Error creating object in api server. Err: %v", err)
			return err
		}
		return err
	}

	api.ct.handleUserEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Created})
	return nil
}

// Update triggers update on User object
func (api *userAPI) Update(obj *auth.User) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.AuthV1().User().Update(context.Background(), obj)
		return err
	}

	api.ct.handleUserEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Updated})
	return nil
}

// Delete deletes User object
func (api *userAPI) Delete(obj *auth.User) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.AuthV1().User().Delete(context.Background(), &obj.ObjectMeta)
		return err
	}

	api.ct.handleUserEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Deleted})
	return nil
}

// MakeKey generates a KV store key for the object
func (api *userAPI) getFullKey(tenant, name string) string {
	if tenant != "" {
		return fmt.Sprint(globals.ConfigRootPrefix, "/", "auth", "/", "users", "/", tenant, "/", name)
	}
	return fmt.Sprint(globals.ConfigRootPrefix, "/", "auth", "/", "users", "/", name)
}

// Find returns an object by meta
func (api *userAPI) Find(meta *api.ObjectMeta) (*User, error) {
	// find the object
	obj, err := api.ct.FindObject("User", meta)
	if err != nil {
		return nil, err
	}

	// asset type
	switch obj.(type) {
	case *User:
		hobj := obj.(*User)
		return hobj, nil
	default:
		return nil, errors.New("incorrect object type")
	}
}

// List returns a list of all User objects
func (api *userAPI) List(ctx context.Context, opts *api.ListWatchOptions) ([]*User, error) {
	var objlist []*User
	objs, err := api.ct.List("User", ctx, opts)

	if err != nil {
		return nil, err
	}

	for _, obj := range objs {
		switch tp := obj.(type) {
		case *User:
			eobj := obj.(*User)
			objlist = append(objlist, eobj)
		default:
			log.Fatalf("Got invalid object type %v while looking for User", tp)
		}
	}

	return objlist, nil
}

// Watch sets up a event handlers for User object
func (api *userAPI) Watch(handler UserHandler) error {
	api.ct.startWorkerPool("User")
	return api.ct.WatchUser(handler)
}

// StopWatch stop watch for Tenant User object
func (api *userAPI) StopWatch(handler UserHandler) error {
	api.ct.Lock()
	api.ct.workPools["User"].Stop()
	api.ct.Unlock()
	return api.ct.StopWatchUser(handler)
}

// User returns UserAPI
func (ct *ctrlerCtx) User() UserAPI {
	return &userAPI{ct: ct}
}

// AuthenticationPolicy is a wrapper object that implements additional functionality
type AuthenticationPolicy struct {
	sync.Mutex
	auth.AuthenticationPolicy
	HandlerCtx interface{} // additional state handlers can store
	ctrler     *ctrlerCtx  // reference back to the controller instance
}

func (obj *AuthenticationPolicy) Write() error {
	// if there is no API server to connect to, we are done
	if (obj.ctrler == nil) || (obj.ctrler.resolver == nil) || obj.ctrler.apisrvURL == "" {
		return nil
	}

	apicl, err := obj.ctrler.apiClient()
	if err != nil {
		obj.ctrler.logger.Errorf("Error creating API server clent. Err: %v", err)
		return err
	}

	obj.ctrler.stats.Counter("AuthenticationPolicy_Writes").Inc()

	// write to api server
	if obj.ObjectMeta.ResourceVersion != "" {
		// update it
		for i := 0; i < maxApisrvWriteRetry; i++ {
			_, err = apicl.AuthV1().AuthenticationPolicy().UpdateStatus(context.Background(), &obj.AuthenticationPolicy)
			if err == nil {
				break
			}
			time.Sleep(time.Millisecond * 100)
		}
	} else {
		//  create
		_, err = apicl.AuthV1().AuthenticationPolicy().Create(context.Background(), &obj.AuthenticationPolicy)
	}

	return nil
}

// AuthenticationPolicyHandler is the event handler for AuthenticationPolicy object
type AuthenticationPolicyHandler interface {
	OnAuthenticationPolicyCreate(obj *AuthenticationPolicy) error
	OnAuthenticationPolicyUpdate(oldObj *AuthenticationPolicy, newObj *auth.AuthenticationPolicy) error
	OnAuthenticationPolicyDelete(obj *AuthenticationPolicy) error
	GetAuthenticationPolicyWatchOptions() *api.ListWatchOptions
}

// handleAuthenticationPolicyEvent handles AuthenticationPolicy events from watcher
func (ct *ctrlerCtx) handleAuthenticationPolicyEvent(evt *kvstore.WatchEvent) error {

	if ct.objResolver == nil {
		return ct.handleAuthenticationPolicyEventNoResolver(evt)
	}

	switch tp := evt.Object.(type) {
	case *auth.AuthenticationPolicy:
		eobj := evt.Object.(*auth.AuthenticationPolicy)
		kind := "AuthenticationPolicy"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ctx := &authenticationpolicyCtx{event: evt.Type,
			obj: &AuthenticationPolicy{AuthenticationPolicy: *eobj, ctrler: ct}}

		var err error
		switch evt.Type {
		case kvstore.Created:
			err = ct.processAdd(ctx)
		case kvstore.Updated:
			err = ct.processUpdate(ctx)
		case kvstore.Deleted:
			err = ct.processDelete(ctx)
		}
		return err
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on AuthenticationPolicy watch channel", tp)
	}

	return nil
}

// handleAuthenticationPolicyEventNoResolver handles AuthenticationPolicy events from watcher
func (ct *ctrlerCtx) handleAuthenticationPolicyEventNoResolver(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *auth.AuthenticationPolicy:
		eobj := evt.Object.(*auth.AuthenticationPolicy)
		kind := "AuthenticationPolicy"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		authenticationpolicyHandler := handler.(AuthenticationPolicyHandler)
		// handle based on event type
		ctrlCtx := &authenticationpolicyCtx{event: evt.Type, obj: &AuthenticationPolicy{AuthenticationPolicy: *eobj, ctrler: ct}}
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			fobj, err := ct.getObject(kind, ctrlCtx.GetKey())
			if err != nil {
				ct.addObject(ctrlCtx)
				ct.stats.Counter("AuthenticationPolicy_Created_Events").Inc()

				// call the event handler
				ctrlCtx.Lock()
				err = authenticationpolicyHandler.OnAuthenticationPolicyCreate(ctrlCtx.obj)
				ctrlCtx.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctrlCtx.obj, err)
					ct.delObject(kind, ctrlCtx.GetKey())
					return err
				}
			} else {
				ctrlCtx := fobj.(*authenticationpolicyCtx)
				ct.stats.Counter("AuthenticationPolicy_Updated_Events").Inc()
				ctrlCtx.Lock()
				p := auth.AuthenticationPolicy{Spec: eobj.Spec,
					ObjectMeta: eobj.ObjectMeta,
					TypeMeta:   eobj.TypeMeta,
					Status:     eobj.Status}

				err = authenticationpolicyHandler.OnAuthenticationPolicyUpdate(ctrlCtx.obj, &p)
				ctrlCtx.obj.AuthenticationPolicy = *eobj
				ctrlCtx.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctrlCtx.obj, err)
					return err
				}

			}
		case kvstore.Deleted:
			ctrlCtx := &authenticationpolicyCtx{event: evt.Type, obj: &AuthenticationPolicy{AuthenticationPolicy: *eobj, ctrler: ct}}
			fobj, err := ct.findObject(kind, ctrlCtx.GetKey())
			if err != nil {
				ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
				return err
			}

			obj := fobj.(*AuthenticationPolicy)
			ct.stats.Counter("AuthenticationPolicy_Deleted_Events").Inc()
			obj.Lock()
			err = authenticationpolicyHandler.OnAuthenticationPolicyDelete(obj)
			obj.Unlock()
			if err != nil {
				ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
			}
			ct.delObject(kind, ctrlCtx.GetKey())
			return nil

		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on AuthenticationPolicy watch channel", tp)
	}

	return nil
}

type authenticationpolicyCtx struct {
	ctkitBaseCtx
	event kvstore.WatchEventType
	obj   *AuthenticationPolicy //
	//   newObj     *auth.AuthenticationPolicy //update
	newObj *authenticationpolicyCtx //update
}

func (ctx *authenticationpolicyCtx) References() map[string]apiintf.ReferenceObj {
	resp := make(map[string]apiintf.ReferenceObj)
	ctx.obj.References(ctx.obj.GetObjectMeta().Name, ctx.obj.GetObjectMeta().Namespace, resp)
	return resp
}

func (ctx *authenticationpolicyCtx) GetKey() string {
	return ctx.obj.MakeKey("auth")
}

func (ctx *authenticationpolicyCtx) GetKind() string {
	return ctx.obj.GetKind()
}

func (ctx *authenticationpolicyCtx) SetEvent(event kvstore.WatchEventType) {
	ctx.event = event
}

func (ctx *authenticationpolicyCtx) SetNewObj(newObj apiintf.CtkitObject) {
	if newObj == nil {
		ctx.newObj = nil
	} else {
		ctx.newObj = newObj.(*authenticationpolicyCtx)
		ctx.newObj.obj.HandlerCtx = ctx.obj.HandlerCtx
	}
}

func (ctx *authenticationpolicyCtx) GetNewObj() apiintf.CtkitObject {
	return ctx.newObj
}

func (ctx *authenticationpolicyCtx) Copy(obj apiintf.CtkitObject) {
	ctx.obj.AuthenticationPolicy = obj.(*authenticationpolicyCtx).obj.AuthenticationPolicy
}

func (ctx *authenticationpolicyCtx) Lock() {
	ctx.obj.Lock()
}

func (ctx *authenticationpolicyCtx) Unlock() {
	ctx.obj.Unlock()
}

func (ctx *authenticationpolicyCtx) GetObjectMeta() *api.ObjectMeta {
	return ctx.obj.GetObjectMeta()
}

func (ctx *authenticationpolicyCtx) RuntimeObject() runtime.Object {
	var v interface{}
	v = ctx.obj
	return v.(runtime.Object)
}

func (ctx *authenticationpolicyCtx) WorkFunc(context context.Context) error {
	var err error
	evt := ctx.event
	ct := ctx.obj.ctrler
	kind := "AuthenticationPolicy"
	ct.Lock()
	handler, ok := ct.handlers[kind]
	ct.Unlock()
	if !ok {
		ct.logger.Fatalf("Cant find the handler for %s", kind)
	}
	authenticationpolicyHandler := handler.(AuthenticationPolicyHandler)
	switch evt {
	case kvstore.Created:
		ctx.obj.Lock()
		err = authenticationpolicyHandler.OnAuthenticationPolicyCreate(ctx.obj)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctx.obj, err)
			ctx.SetEvent(kvstore.Deleted)
		}
	case kvstore.Updated:
		ct.stats.Counter("AuthenticationPolicy_Updated_Events").Inc()
		ctx.obj.Lock()
		p := auth.AuthenticationPolicy{Spec: ctx.newObj.obj.Spec,
			ObjectMeta: ctx.newObj.obj.ObjectMeta,
			TypeMeta:   ctx.newObj.obj.TypeMeta,
			Status:     ctx.newObj.obj.Status}
		err = authenticationpolicyHandler.OnAuthenticationPolicyUpdate(ctx.obj, &p)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctx.obj, err)
			ctx.SetEvent(kvstore.Deleted)
		}
	case kvstore.Deleted:
		ctx.obj.Lock()
		err = authenticationpolicyHandler.OnAuthenticationPolicyDelete(ctx.obj)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error deleting %s %+v. Err: %v", kind, ctx.obj, err)
		}
	}
	ct.resolveObject(ctx.event, ctx)
	return nil
}

// handleAuthenticationPolicyEventParallel handles AuthenticationPolicy events from watcher
func (ct *ctrlerCtx) handleAuthenticationPolicyEventParallel(evt *kvstore.WatchEvent) error {

	if ct.objResolver == nil {
		return ct.handleAuthenticationPolicyEventParallelWithNoResolver(evt)
	}

	switch tp := evt.Object.(type) {
	case *auth.AuthenticationPolicy:
		eobj := evt.Object.(*auth.AuthenticationPolicy)
		kind := "AuthenticationPolicy"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ctx := &authenticationpolicyCtx{event: evt.Type, obj: &AuthenticationPolicy{AuthenticationPolicy: *eobj, ctrler: ct}}

		var err error
		switch evt.Type {
		case kvstore.Created:
			err = ct.processAdd(ctx)
		case kvstore.Updated:
			err = ct.processUpdate(ctx)
		case kvstore.Deleted:
			err = ct.processDelete(ctx)
		}
		return err
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on AuthenticationPolicy watch channel", tp)
	}

	return nil
}

// handleAuthenticationPolicyEventParallel handles AuthenticationPolicy events from watcher
func (ct *ctrlerCtx) handleAuthenticationPolicyEventParallelWithNoResolver(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *auth.AuthenticationPolicy:
		eobj := evt.Object.(*auth.AuthenticationPolicy)
		kind := "AuthenticationPolicy"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		authenticationpolicyHandler := handler.(AuthenticationPolicyHandler)
		// handle based on event type
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			workFunc := func(ctx context.Context, ctrlCtx shardworkers.WorkObj) error {
				var err error
				workCtx := ctrlCtx.(*authenticationpolicyCtx)
				eobj := workCtx.obj
				fobj, err := ct.getObject(kind, workCtx.GetKey())
				if err != nil {
					ct.addObject(workCtx)
					ct.stats.Counter("AuthenticationPolicy_Created_Events").Inc()
					eobj.Lock()
					err = authenticationpolicyHandler.OnAuthenticationPolicyCreate(eobj)
					eobj.Unlock()
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, eobj, err)
						ct.delObject(kind, workCtx.GetKey())
					}
				} else {
					workCtx := fobj.(*authenticationpolicyCtx)
					obj := workCtx.obj
					ct.stats.Counter("AuthenticationPolicy_Updated_Events").Inc()
					obj.Lock()
					p := auth.AuthenticationPolicy{Spec: eobj.Spec,
						ObjectMeta: eobj.ObjectMeta,
						TypeMeta:   eobj.TypeMeta,
						Status:     eobj.Status}

					err = authenticationpolicyHandler.OnAuthenticationPolicyUpdate(obj, &p)
					workCtx.obj.AuthenticationPolicy = p
					obj.Unlock()
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					}
				}
				return err
			}
			ctrlCtx := &authenticationpolicyCtx{event: evt.Type, obj: &AuthenticationPolicy{AuthenticationPolicy: *eobj, ctrler: ct}}
			ct.runFunction("AuthenticationPolicy", ctrlCtx, workFunc)
		case kvstore.Deleted:
			workFunc := func(ctx context.Context, ctrlCtx shardworkers.WorkObj) error {
				var err error
				workCtx := ctrlCtx.(*authenticationpolicyCtx)
				eobj := workCtx.obj
				fobj, err := ct.findObject(kind, workCtx.GetKey())
				if err != nil {
					ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
					return err
				}
				obj := fobj.(*AuthenticationPolicy)
				ct.stats.Counter("AuthenticationPolicy_Deleted_Events").Inc()
				obj.Lock()
				err = authenticationpolicyHandler.OnAuthenticationPolicyDelete(obj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
				}
				ct.delObject(kind, workCtx.GetKey())
				return nil
			}
			ctrlCtx := &authenticationpolicyCtx{event: evt.Type, obj: &AuthenticationPolicy{AuthenticationPolicy: *eobj, ctrler: ct}}
			ct.runFunction("AuthenticationPolicy", ctrlCtx, workFunc)
		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on AuthenticationPolicy watch channel", tp)
	}

	return nil
}

// diffAuthenticationPolicy does a diff of AuthenticationPolicy objects between local cache and API server
func (ct *ctrlerCtx) diffAuthenticationPolicy(apicl apiclient.Services) {
	opts := api.ListWatchOptions{}

	// get a list of all objects from API server
	objlist, err := apicl.AuthV1().AuthenticationPolicy().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Errorf("Error getting a list of objects. Err: %v", err)
		return
	}

	ct.logger.Infof("diffAuthenticationPolicy(): AuthenticationPolicyList returned %d objects", len(objlist))

	// build an object map
	objmap := make(map[string]*auth.AuthenticationPolicy)
	for _, obj := range objlist {
		objmap[obj.GetKey()] = obj
	}

	list, err := ct.AuthenticationPolicy().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Infof("Failed to get a list of objects. Err: %s", err)
		return
	}

	// if an object is in our local cache and not in API server, trigger delete for it
	for _, obj := range list {
		_, ok := objmap[obj.GetKey()]
		if !ok {
			ct.logger.Infof("diffAuthenticationPolicy(): Deleting existing object %#v since its not in apiserver", obj.GetKey())
			evt := kvstore.WatchEvent{
				Type:   kvstore.Deleted,
				Key:    obj.GetKey(),
				Object: &obj.AuthenticationPolicy,
			}
			ct.handleAuthenticationPolicyEvent(&evt)
		}
	}

	// trigger create event for all others
	for _, obj := range objlist {
		ct.logger.Infof("diffAuthenticationPolicy(): Adding object %#v", obj.GetKey())
		evt := kvstore.WatchEvent{
			Type:   kvstore.Created,
			Key:    obj.GetKey(),
			Object: obj,
		}
		ct.handleAuthenticationPolicyEvent(&evt)
	}
}

func (ct *ctrlerCtx) runAuthenticationPolicyWatcher() {
	kind := "AuthenticationPolicy"

	ct.Lock()
	handler, ok := ct.handlers[kind]
	ct.Unlock()
	if !ok {
		ct.logger.Fatalf("Cant find the handler for %s", kind)
	}
	authenticationpolicyHandler := handler.(AuthenticationPolicyHandler)

	opts := authenticationpolicyHandler.GetAuthenticationPolicyWatchOptions()

	// if there is no API server to connect to, we are done
	if (ct.resolver == nil) || ct.apisrvURL == "" {
		return
	}

	// create context
	ctx, cancel := context.WithCancel(context.Background())
	ct.Lock()
	ct.watchCancel[kind] = cancel
	ct.Unlock()
	logger := ct.logger.WithContext("submodule", "AuthenticationPolicyWatcher")

	// create a grpc client
	apiclt, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
	if err == nil {
		ct.diffAuthenticationPolicy(apiclt)
	}

	// setup wait group
	ct.waitGrp.Add(1)

	// start a goroutine
	go func() {
		defer ct.waitGrp.Done()
		ct.stats.Counter("AuthenticationPolicy_Watch").Inc()
		defer ct.stats.Counter("AuthenticationPolicy_Watch").Dec()

		// loop forever
		for {
			// create a grpc client
			apicl, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
			if err != nil {
				logger.Warnf("Failed to connect to gRPC server [%s]\n", ct.apisrvURL)
				ct.stats.Counter("AuthenticationPolicy_ApiClientErr").Inc()
			} else {
				logger.Infof("API client connected {%+v}", apicl)

				// AuthenticationPolicy object watcher
				wt, werr := apicl.AuthV1().AuthenticationPolicy().Watch(ctx, opts)
				if werr != nil {
					select {
					case <-ctx.Done():
						logger.Infof("watch %s cancelled", kind)
						return
					default:
					}
					logger.Errorf("Failed to start %s watch (%s)\n", kind, werr)
					// wait for a second and retry connecting to api server
					apicl.Close()
					time.Sleep(time.Second)
					continue
				}
				ct.Lock()
				ct.watchers[kind] = wt
				ct.Unlock()

				// perform a diff with API server and local cache
				time.Sleep(time.Millisecond * 100)
				ct.diffAuthenticationPolicy(apicl)

				// handle api server watch events
			innerLoop:
				for {
					// wait for events
					select {
					case evt, ok := <-wt.EventChan():
						if !ok {
							logger.Error("Error receiving from apisrv watcher")
							ct.stats.Counter("AuthenticationPolicy_WatchErrors").Inc()
							break innerLoop
						}

						// handle event in parallel
						ct.handleAuthenticationPolicyEventParallel(evt)
					}
				}
				apicl.Close()
			}

			// if stop flag is set, we are done
			if ct.stoped {
				logger.Infof("Exiting API server watcher")
				return
			}

			// wait for a second and retry connecting to api server
			time.Sleep(time.Second)
		}
	}()
}

// WatchAuthenticationPolicy starts watch on AuthenticationPolicy object
func (ct *ctrlerCtx) WatchAuthenticationPolicy(handler AuthenticationPolicyHandler) error {
	kind := "AuthenticationPolicy"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchers[kind]
	ct.Unlock()
	if ok {
		return fmt.Errorf("AuthenticationPolicy watcher already exists")
	}

	// save handler
	ct.Lock()
	ct.handlers[kind] = handler
	ct.Unlock()

	// run AuthenticationPolicy watcher in a go routine
	ct.runAuthenticationPolicyWatcher()

	return nil
}

// StopWatchAuthenticationPolicy stops watch on AuthenticationPolicy object
func (ct *ctrlerCtx) StopWatchAuthenticationPolicy(handler AuthenticationPolicyHandler) error {
	kind := "AuthenticationPolicy"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchers[kind]
	ct.Unlock()
	if !ok {
		return fmt.Errorf("AuthenticationPolicy watcher does not exist")
	}

	ct.Lock()
	cancel, _ := ct.watchCancel[kind]
	cancel()
	delete(ct.watchers, kind)
	delete(ct.watchCancel, kind)
	ct.Unlock()

	time.Sleep(100 * time.Millisecond)

	return nil
}

// AuthenticationPolicyAPI returns
type AuthenticationPolicyAPI interface {
	Create(obj *auth.AuthenticationPolicy) error
	CreateEvent(obj *auth.AuthenticationPolicy) error
	Update(obj *auth.AuthenticationPolicy) error
	Delete(obj *auth.AuthenticationPolicy) error
	Find(meta *api.ObjectMeta) (*AuthenticationPolicy, error)
	List(ctx context.Context, opts *api.ListWatchOptions) ([]*AuthenticationPolicy, error)
	Watch(handler AuthenticationPolicyHandler) error
	StopWatch(handler AuthenticationPolicyHandler) error
}

// dummy struct that implements AuthenticationPolicyAPI
type authenticationpolicyAPI struct {
	ct *ctrlerCtx
}

// Create creates AuthenticationPolicy object
func (api *authenticationpolicyAPI) Create(obj *auth.AuthenticationPolicy) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.AuthV1().AuthenticationPolicy().Create(context.Background(), obj)
		if err != nil && strings.Contains(err.Error(), "AlreadyExists") {
			_, err = apicl.AuthV1().AuthenticationPolicy().Update(context.Background(), obj)
		}
		return err
	}

	api.ct.handleAuthenticationPolicyEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Created})
	return nil
}

// CreateEvent creates AuthenticationPolicy object and synchronously triggers local event
func (api *authenticationpolicyAPI) CreateEvent(obj *auth.AuthenticationPolicy) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.AuthV1().AuthenticationPolicy().Create(context.Background(), obj)
		if err != nil && strings.Contains(err.Error(), "AlreadyExists") {
			_, err = apicl.AuthV1().AuthenticationPolicy().Update(context.Background(), obj)
		}
		if err != nil {
			api.ct.logger.Errorf("Error creating object in api server. Err: %v", err)
			return err
		}
		return err
	}

	api.ct.handleAuthenticationPolicyEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Created})
	return nil
}

// Update triggers update on AuthenticationPolicy object
func (api *authenticationpolicyAPI) Update(obj *auth.AuthenticationPolicy) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.AuthV1().AuthenticationPolicy().Update(context.Background(), obj)
		return err
	}

	api.ct.handleAuthenticationPolicyEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Updated})
	return nil
}

// Delete deletes AuthenticationPolicy object
func (api *authenticationpolicyAPI) Delete(obj *auth.AuthenticationPolicy) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.AuthV1().AuthenticationPolicy().Delete(context.Background(), &obj.ObjectMeta)
		return err
	}

	api.ct.handleAuthenticationPolicyEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Deleted})
	return nil
}

// MakeKey generates a KV store key for the object
func (api *authenticationpolicyAPI) getFullKey(tenant, name string) string {
	if tenant != "" {
		return fmt.Sprint(globals.ConfigRootPrefix, "/", "auth", "/", "authn-policy", "/", tenant, "/", name)
	}
	return fmt.Sprint(globals.ConfigRootPrefix, "/", "auth", "/", "authn-policy", "/", name)
}

// Find returns an object by meta
func (api *authenticationpolicyAPI) Find(meta *api.ObjectMeta) (*AuthenticationPolicy, error) {
	// find the object
	obj, err := api.ct.FindObject("AuthenticationPolicy", meta)
	if err != nil {
		return nil, err
	}

	// asset type
	switch obj.(type) {
	case *AuthenticationPolicy:
		hobj := obj.(*AuthenticationPolicy)
		return hobj, nil
	default:
		return nil, errors.New("incorrect object type")
	}
}

// List returns a list of all AuthenticationPolicy objects
func (api *authenticationpolicyAPI) List(ctx context.Context, opts *api.ListWatchOptions) ([]*AuthenticationPolicy, error) {
	var objlist []*AuthenticationPolicy
	objs, err := api.ct.List("AuthenticationPolicy", ctx, opts)

	if err != nil {
		return nil, err
	}

	for _, obj := range objs {
		switch tp := obj.(type) {
		case *AuthenticationPolicy:
			eobj := obj.(*AuthenticationPolicy)
			objlist = append(objlist, eobj)
		default:
			log.Fatalf("Got invalid object type %v while looking for AuthenticationPolicy", tp)
		}
	}

	return objlist, nil
}

// Watch sets up a event handlers for AuthenticationPolicy object
func (api *authenticationpolicyAPI) Watch(handler AuthenticationPolicyHandler) error {
	api.ct.startWorkerPool("AuthenticationPolicy")
	return api.ct.WatchAuthenticationPolicy(handler)
}

// StopWatch stop watch for Tenant AuthenticationPolicy object
func (api *authenticationpolicyAPI) StopWatch(handler AuthenticationPolicyHandler) error {
	api.ct.Lock()
	api.ct.workPools["AuthenticationPolicy"].Stop()
	api.ct.Unlock()
	return api.ct.StopWatchAuthenticationPolicy(handler)
}

// AuthenticationPolicy returns AuthenticationPolicyAPI
func (ct *ctrlerCtx) AuthenticationPolicy() AuthenticationPolicyAPI {
	return &authenticationpolicyAPI{ct: ct}
}

// Role is a wrapper object that implements additional functionality
type Role struct {
	sync.Mutex
	auth.Role
	HandlerCtx interface{} // additional state handlers can store
	ctrler     *ctrlerCtx  // reference back to the controller instance
}

func (obj *Role) Write() error {
	// if there is no API server to connect to, we are done
	if (obj.ctrler == nil) || (obj.ctrler.resolver == nil) || obj.ctrler.apisrvURL == "" {
		return nil
	}

	apicl, err := obj.ctrler.apiClient()
	if err != nil {
		obj.ctrler.logger.Errorf("Error creating API server clent. Err: %v", err)
		return err
	}

	obj.ctrler.stats.Counter("Role_Writes").Inc()

	// write to api server
	if obj.ObjectMeta.ResourceVersion != "" {
		// update it
		for i := 0; i < maxApisrvWriteRetry; i++ {
			_, err = apicl.AuthV1().Role().UpdateStatus(context.Background(), &obj.Role)
			if err == nil {
				break
			}
			time.Sleep(time.Millisecond * 100)
		}
	} else {
		//  create
		_, err = apicl.AuthV1().Role().Create(context.Background(), &obj.Role)
	}

	return nil
}

// RoleHandler is the event handler for Role object
type RoleHandler interface {
	OnRoleCreate(obj *Role) error
	OnRoleUpdate(oldObj *Role, newObj *auth.Role) error
	OnRoleDelete(obj *Role) error
	GetRoleWatchOptions() *api.ListWatchOptions
}

// handleRoleEvent handles Role events from watcher
func (ct *ctrlerCtx) handleRoleEvent(evt *kvstore.WatchEvent) error {

	if ct.objResolver == nil {
		return ct.handleRoleEventNoResolver(evt)
	}

	switch tp := evt.Object.(type) {
	case *auth.Role:
		eobj := evt.Object.(*auth.Role)
		kind := "Role"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ctx := &roleCtx{event: evt.Type,
			obj: &Role{Role: *eobj, ctrler: ct}}

		var err error
		switch evt.Type {
		case kvstore.Created:
			err = ct.processAdd(ctx)
		case kvstore.Updated:
			err = ct.processUpdate(ctx)
		case kvstore.Deleted:
			err = ct.processDelete(ctx)
		}
		return err
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on Role watch channel", tp)
	}

	return nil
}

// handleRoleEventNoResolver handles Role events from watcher
func (ct *ctrlerCtx) handleRoleEventNoResolver(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *auth.Role:
		eobj := evt.Object.(*auth.Role)
		kind := "Role"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		roleHandler := handler.(RoleHandler)
		// handle based on event type
		ctrlCtx := &roleCtx{event: evt.Type, obj: &Role{Role: *eobj, ctrler: ct}}
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			fobj, err := ct.getObject(kind, ctrlCtx.GetKey())
			if err != nil {
				ct.addObject(ctrlCtx)
				ct.stats.Counter("Role_Created_Events").Inc()

				// call the event handler
				ctrlCtx.Lock()
				err = roleHandler.OnRoleCreate(ctrlCtx.obj)
				ctrlCtx.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctrlCtx.obj, err)
					ct.delObject(kind, ctrlCtx.GetKey())
					return err
				}
			} else {
				ctrlCtx := fobj.(*roleCtx)
				ct.stats.Counter("Role_Updated_Events").Inc()
				ctrlCtx.Lock()
				p := auth.Role{Spec: eobj.Spec,
					ObjectMeta: eobj.ObjectMeta,
					TypeMeta:   eobj.TypeMeta,
					Status:     eobj.Status}

				err = roleHandler.OnRoleUpdate(ctrlCtx.obj, &p)
				ctrlCtx.obj.Role = *eobj
				ctrlCtx.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctrlCtx.obj, err)
					return err
				}

			}
		case kvstore.Deleted:
			ctrlCtx := &roleCtx{event: evt.Type, obj: &Role{Role: *eobj, ctrler: ct}}
			fobj, err := ct.findObject(kind, ctrlCtx.GetKey())
			if err != nil {
				ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
				return err
			}

			obj := fobj.(*Role)
			ct.stats.Counter("Role_Deleted_Events").Inc()
			obj.Lock()
			err = roleHandler.OnRoleDelete(obj)
			obj.Unlock()
			if err != nil {
				ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
			}
			ct.delObject(kind, ctrlCtx.GetKey())
			return nil

		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on Role watch channel", tp)
	}

	return nil
}

type roleCtx struct {
	ctkitBaseCtx
	event kvstore.WatchEventType
	obj   *Role //
	//   newObj     *auth.Role //update
	newObj *roleCtx //update
}

func (ctx *roleCtx) References() map[string]apiintf.ReferenceObj {
	resp := make(map[string]apiintf.ReferenceObj)
	ctx.obj.References(ctx.obj.GetObjectMeta().Name, ctx.obj.GetObjectMeta().Namespace, resp)
	return resp
}

func (ctx *roleCtx) GetKey() string {
	return ctx.obj.MakeKey("auth")
}

func (ctx *roleCtx) GetKind() string {
	return ctx.obj.GetKind()
}

func (ctx *roleCtx) SetEvent(event kvstore.WatchEventType) {
	ctx.event = event
}

func (ctx *roleCtx) SetNewObj(newObj apiintf.CtkitObject) {
	if newObj == nil {
		ctx.newObj = nil
	} else {
		ctx.newObj = newObj.(*roleCtx)
		ctx.newObj.obj.HandlerCtx = ctx.obj.HandlerCtx
	}
}

func (ctx *roleCtx) GetNewObj() apiintf.CtkitObject {
	return ctx.newObj
}

func (ctx *roleCtx) Copy(obj apiintf.CtkitObject) {
	ctx.obj.Role = obj.(*roleCtx).obj.Role
}

func (ctx *roleCtx) Lock() {
	ctx.obj.Lock()
}

func (ctx *roleCtx) Unlock() {
	ctx.obj.Unlock()
}

func (ctx *roleCtx) GetObjectMeta() *api.ObjectMeta {
	return ctx.obj.GetObjectMeta()
}

func (ctx *roleCtx) RuntimeObject() runtime.Object {
	var v interface{}
	v = ctx.obj
	return v.(runtime.Object)
}

func (ctx *roleCtx) WorkFunc(context context.Context) error {
	var err error
	evt := ctx.event
	ct := ctx.obj.ctrler
	kind := "Role"
	ct.Lock()
	handler, ok := ct.handlers[kind]
	ct.Unlock()
	if !ok {
		ct.logger.Fatalf("Cant find the handler for %s", kind)
	}
	roleHandler := handler.(RoleHandler)
	switch evt {
	case kvstore.Created:
		ctx.obj.Lock()
		err = roleHandler.OnRoleCreate(ctx.obj)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctx.obj, err)
			ctx.SetEvent(kvstore.Deleted)
		}
	case kvstore.Updated:
		ct.stats.Counter("Role_Updated_Events").Inc()
		ctx.obj.Lock()
		p := auth.Role{Spec: ctx.newObj.obj.Spec,
			ObjectMeta: ctx.newObj.obj.ObjectMeta,
			TypeMeta:   ctx.newObj.obj.TypeMeta,
			Status:     ctx.newObj.obj.Status}
		err = roleHandler.OnRoleUpdate(ctx.obj, &p)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctx.obj, err)
			ctx.SetEvent(kvstore.Deleted)
		}
	case kvstore.Deleted:
		ctx.obj.Lock()
		err = roleHandler.OnRoleDelete(ctx.obj)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error deleting %s %+v. Err: %v", kind, ctx.obj, err)
		}
	}
	ct.resolveObject(ctx.event, ctx)
	return nil
}

// handleRoleEventParallel handles Role events from watcher
func (ct *ctrlerCtx) handleRoleEventParallel(evt *kvstore.WatchEvent) error {

	if ct.objResolver == nil {
		return ct.handleRoleEventParallelWithNoResolver(evt)
	}

	switch tp := evt.Object.(type) {
	case *auth.Role:
		eobj := evt.Object.(*auth.Role)
		kind := "Role"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ctx := &roleCtx{event: evt.Type, obj: &Role{Role: *eobj, ctrler: ct}}

		var err error
		switch evt.Type {
		case kvstore.Created:
			err = ct.processAdd(ctx)
		case kvstore.Updated:
			err = ct.processUpdate(ctx)
		case kvstore.Deleted:
			err = ct.processDelete(ctx)
		}
		return err
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on Role watch channel", tp)
	}

	return nil
}

// handleRoleEventParallel handles Role events from watcher
func (ct *ctrlerCtx) handleRoleEventParallelWithNoResolver(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *auth.Role:
		eobj := evt.Object.(*auth.Role)
		kind := "Role"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		roleHandler := handler.(RoleHandler)
		// handle based on event type
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			workFunc := func(ctx context.Context, ctrlCtx shardworkers.WorkObj) error {
				var err error
				workCtx := ctrlCtx.(*roleCtx)
				eobj := workCtx.obj
				fobj, err := ct.getObject(kind, workCtx.GetKey())
				if err != nil {
					ct.addObject(workCtx)
					ct.stats.Counter("Role_Created_Events").Inc()
					eobj.Lock()
					err = roleHandler.OnRoleCreate(eobj)
					eobj.Unlock()
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, eobj, err)
						ct.delObject(kind, workCtx.GetKey())
					}
				} else {
					workCtx := fobj.(*roleCtx)
					obj := workCtx.obj
					ct.stats.Counter("Role_Updated_Events").Inc()
					obj.Lock()
					p := auth.Role{Spec: eobj.Spec,
						ObjectMeta: eobj.ObjectMeta,
						TypeMeta:   eobj.TypeMeta,
						Status:     eobj.Status}

					err = roleHandler.OnRoleUpdate(obj, &p)
					workCtx.obj.Role = p
					obj.Unlock()
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					}
				}
				return err
			}
			ctrlCtx := &roleCtx{event: evt.Type, obj: &Role{Role: *eobj, ctrler: ct}}
			ct.runFunction("Role", ctrlCtx, workFunc)
		case kvstore.Deleted:
			workFunc := func(ctx context.Context, ctrlCtx shardworkers.WorkObj) error {
				var err error
				workCtx := ctrlCtx.(*roleCtx)
				eobj := workCtx.obj
				fobj, err := ct.findObject(kind, workCtx.GetKey())
				if err != nil {
					ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
					return err
				}
				obj := fobj.(*Role)
				ct.stats.Counter("Role_Deleted_Events").Inc()
				obj.Lock()
				err = roleHandler.OnRoleDelete(obj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
				}
				ct.delObject(kind, workCtx.GetKey())
				return nil
			}
			ctrlCtx := &roleCtx{event: evt.Type, obj: &Role{Role: *eobj, ctrler: ct}}
			ct.runFunction("Role", ctrlCtx, workFunc)
		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on Role watch channel", tp)
	}

	return nil
}

// diffRole does a diff of Role objects between local cache and API server
func (ct *ctrlerCtx) diffRole(apicl apiclient.Services) {
	opts := api.ListWatchOptions{}

	// get a list of all objects from API server
	objlist, err := apicl.AuthV1().Role().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Errorf("Error getting a list of objects. Err: %v", err)
		return
	}

	ct.logger.Infof("diffRole(): RoleList returned %d objects", len(objlist))

	// build an object map
	objmap := make(map[string]*auth.Role)
	for _, obj := range objlist {
		objmap[obj.GetKey()] = obj
	}

	list, err := ct.Role().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Infof("Failed to get a list of objects. Err: %s", err)
		return
	}

	// if an object is in our local cache and not in API server, trigger delete for it
	for _, obj := range list {
		_, ok := objmap[obj.GetKey()]
		if !ok {
			ct.logger.Infof("diffRole(): Deleting existing object %#v since its not in apiserver", obj.GetKey())
			evt := kvstore.WatchEvent{
				Type:   kvstore.Deleted,
				Key:    obj.GetKey(),
				Object: &obj.Role,
			}
			ct.handleRoleEvent(&evt)
		}
	}

	// trigger create event for all others
	for _, obj := range objlist {
		ct.logger.Infof("diffRole(): Adding object %#v", obj.GetKey())
		evt := kvstore.WatchEvent{
			Type:   kvstore.Created,
			Key:    obj.GetKey(),
			Object: obj,
		}
		ct.handleRoleEvent(&evt)
	}
}

func (ct *ctrlerCtx) runRoleWatcher() {
	kind := "Role"

	ct.Lock()
	handler, ok := ct.handlers[kind]
	ct.Unlock()
	if !ok {
		ct.logger.Fatalf("Cant find the handler for %s", kind)
	}
	roleHandler := handler.(RoleHandler)

	opts := roleHandler.GetRoleWatchOptions()

	// if there is no API server to connect to, we are done
	if (ct.resolver == nil) || ct.apisrvURL == "" {
		return
	}

	// create context
	ctx, cancel := context.WithCancel(context.Background())
	ct.Lock()
	ct.watchCancel[kind] = cancel
	ct.Unlock()
	logger := ct.logger.WithContext("submodule", "RoleWatcher")

	// create a grpc client
	apiclt, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
	if err == nil {
		ct.diffRole(apiclt)
	}

	// setup wait group
	ct.waitGrp.Add(1)

	// start a goroutine
	go func() {
		defer ct.waitGrp.Done()
		ct.stats.Counter("Role_Watch").Inc()
		defer ct.stats.Counter("Role_Watch").Dec()

		// loop forever
		for {
			// create a grpc client
			apicl, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
			if err != nil {
				logger.Warnf("Failed to connect to gRPC server [%s]\n", ct.apisrvURL)
				ct.stats.Counter("Role_ApiClientErr").Inc()
			} else {
				logger.Infof("API client connected {%+v}", apicl)

				// Role object watcher
				wt, werr := apicl.AuthV1().Role().Watch(ctx, opts)
				if werr != nil {
					select {
					case <-ctx.Done():
						logger.Infof("watch %s cancelled", kind)
						return
					default:
					}
					logger.Errorf("Failed to start %s watch (%s)\n", kind, werr)
					// wait for a second and retry connecting to api server
					apicl.Close()
					time.Sleep(time.Second)
					continue
				}
				ct.Lock()
				ct.watchers[kind] = wt
				ct.Unlock()

				// perform a diff with API server and local cache
				time.Sleep(time.Millisecond * 100)
				ct.diffRole(apicl)

				// handle api server watch events
			innerLoop:
				for {
					// wait for events
					select {
					case evt, ok := <-wt.EventChan():
						if !ok {
							logger.Error("Error receiving from apisrv watcher")
							ct.stats.Counter("Role_WatchErrors").Inc()
							break innerLoop
						}

						// handle event in parallel
						ct.handleRoleEventParallel(evt)
					}
				}
				apicl.Close()
			}

			// if stop flag is set, we are done
			if ct.stoped {
				logger.Infof("Exiting API server watcher")
				return
			}

			// wait for a second and retry connecting to api server
			time.Sleep(time.Second)
		}
	}()
}

// WatchRole starts watch on Role object
func (ct *ctrlerCtx) WatchRole(handler RoleHandler) error {
	kind := "Role"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchers[kind]
	ct.Unlock()
	if ok {
		return fmt.Errorf("Role watcher already exists")
	}

	// save handler
	ct.Lock()
	ct.handlers[kind] = handler
	ct.Unlock()

	// run Role watcher in a go routine
	ct.runRoleWatcher()

	return nil
}

// StopWatchRole stops watch on Role object
func (ct *ctrlerCtx) StopWatchRole(handler RoleHandler) error {
	kind := "Role"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchers[kind]
	ct.Unlock()
	if !ok {
		return fmt.Errorf("Role watcher does not exist")
	}

	ct.Lock()
	cancel, _ := ct.watchCancel[kind]
	cancel()
	delete(ct.watchers, kind)
	delete(ct.watchCancel, kind)
	ct.Unlock()

	time.Sleep(100 * time.Millisecond)

	return nil
}

// RoleAPI returns
type RoleAPI interface {
	Create(obj *auth.Role) error
	CreateEvent(obj *auth.Role) error
	Update(obj *auth.Role) error
	Delete(obj *auth.Role) error
	Find(meta *api.ObjectMeta) (*Role, error)
	List(ctx context.Context, opts *api.ListWatchOptions) ([]*Role, error)
	Watch(handler RoleHandler) error
	StopWatch(handler RoleHandler) error
}

// dummy struct that implements RoleAPI
type roleAPI struct {
	ct *ctrlerCtx
}

// Create creates Role object
func (api *roleAPI) Create(obj *auth.Role) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.AuthV1().Role().Create(context.Background(), obj)
		if err != nil && strings.Contains(err.Error(), "AlreadyExists") {
			_, err = apicl.AuthV1().Role().Update(context.Background(), obj)
		}
		return err
	}

	api.ct.handleRoleEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Created})
	return nil
}

// CreateEvent creates Role object and synchronously triggers local event
func (api *roleAPI) CreateEvent(obj *auth.Role) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.AuthV1().Role().Create(context.Background(), obj)
		if err != nil && strings.Contains(err.Error(), "AlreadyExists") {
			_, err = apicl.AuthV1().Role().Update(context.Background(), obj)
		}
		if err != nil {
			api.ct.logger.Errorf("Error creating object in api server. Err: %v", err)
			return err
		}
		return err
	}

	api.ct.handleRoleEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Created})
	return nil
}

// Update triggers update on Role object
func (api *roleAPI) Update(obj *auth.Role) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.AuthV1().Role().Update(context.Background(), obj)
		return err
	}

	api.ct.handleRoleEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Updated})
	return nil
}

// Delete deletes Role object
func (api *roleAPI) Delete(obj *auth.Role) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.AuthV1().Role().Delete(context.Background(), &obj.ObjectMeta)
		return err
	}

	api.ct.handleRoleEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Deleted})
	return nil
}

// MakeKey generates a KV store key for the object
func (api *roleAPI) getFullKey(tenant, name string) string {
	if tenant != "" {
		return fmt.Sprint(globals.ConfigRootPrefix, "/", "auth", "/", "roles", "/", tenant, "/", name)
	}
	return fmt.Sprint(globals.ConfigRootPrefix, "/", "auth", "/", "roles", "/", name)
}

// Find returns an object by meta
func (api *roleAPI) Find(meta *api.ObjectMeta) (*Role, error) {
	// find the object
	obj, err := api.ct.FindObject("Role", meta)
	if err != nil {
		return nil, err
	}

	// asset type
	switch obj.(type) {
	case *Role:
		hobj := obj.(*Role)
		return hobj, nil
	default:
		return nil, errors.New("incorrect object type")
	}
}

// List returns a list of all Role objects
func (api *roleAPI) List(ctx context.Context, opts *api.ListWatchOptions) ([]*Role, error) {
	var objlist []*Role
	objs, err := api.ct.List("Role", ctx, opts)

	if err != nil {
		return nil, err
	}

	for _, obj := range objs {
		switch tp := obj.(type) {
		case *Role:
			eobj := obj.(*Role)
			objlist = append(objlist, eobj)
		default:
			log.Fatalf("Got invalid object type %v while looking for Role", tp)
		}
	}

	return objlist, nil
}

// Watch sets up a event handlers for Role object
func (api *roleAPI) Watch(handler RoleHandler) error {
	api.ct.startWorkerPool("Role")
	return api.ct.WatchRole(handler)
}

// StopWatch stop watch for Tenant Role object
func (api *roleAPI) StopWatch(handler RoleHandler) error {
	api.ct.Lock()
	api.ct.workPools["Role"].Stop()
	api.ct.Unlock()
	return api.ct.StopWatchRole(handler)
}

// Role returns RoleAPI
func (ct *ctrlerCtx) Role() RoleAPI {
	return &roleAPI{ct: ct}
}

// RoleBinding is a wrapper object that implements additional functionality
type RoleBinding struct {
	sync.Mutex
	auth.RoleBinding
	HandlerCtx interface{} // additional state handlers can store
	ctrler     *ctrlerCtx  // reference back to the controller instance
}

func (obj *RoleBinding) Write() error {
	// if there is no API server to connect to, we are done
	if (obj.ctrler == nil) || (obj.ctrler.resolver == nil) || obj.ctrler.apisrvURL == "" {
		return nil
	}

	apicl, err := obj.ctrler.apiClient()
	if err != nil {
		obj.ctrler.logger.Errorf("Error creating API server clent. Err: %v", err)
		return err
	}

	obj.ctrler.stats.Counter("RoleBinding_Writes").Inc()

	// write to api server
	if obj.ObjectMeta.ResourceVersion != "" {
		// update it
		for i := 0; i < maxApisrvWriteRetry; i++ {
			_, err = apicl.AuthV1().RoleBinding().UpdateStatus(context.Background(), &obj.RoleBinding)
			if err == nil {
				break
			}
			time.Sleep(time.Millisecond * 100)
		}
	} else {
		//  create
		_, err = apicl.AuthV1().RoleBinding().Create(context.Background(), &obj.RoleBinding)
	}

	return nil
}

// RoleBindingHandler is the event handler for RoleBinding object
type RoleBindingHandler interface {
	OnRoleBindingCreate(obj *RoleBinding) error
	OnRoleBindingUpdate(oldObj *RoleBinding, newObj *auth.RoleBinding) error
	OnRoleBindingDelete(obj *RoleBinding) error
	GetRoleBindingWatchOptions() *api.ListWatchOptions
}

// handleRoleBindingEvent handles RoleBinding events from watcher
func (ct *ctrlerCtx) handleRoleBindingEvent(evt *kvstore.WatchEvent) error {

	if ct.objResolver == nil {
		return ct.handleRoleBindingEventNoResolver(evt)
	}

	switch tp := evt.Object.(type) {
	case *auth.RoleBinding:
		eobj := evt.Object.(*auth.RoleBinding)
		kind := "RoleBinding"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ctx := &rolebindingCtx{event: evt.Type,
			obj: &RoleBinding{RoleBinding: *eobj, ctrler: ct}}

		var err error
		switch evt.Type {
		case kvstore.Created:
			err = ct.processAdd(ctx)
		case kvstore.Updated:
			err = ct.processUpdate(ctx)
		case kvstore.Deleted:
			err = ct.processDelete(ctx)
		}
		return err
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on RoleBinding watch channel", tp)
	}

	return nil
}

// handleRoleBindingEventNoResolver handles RoleBinding events from watcher
func (ct *ctrlerCtx) handleRoleBindingEventNoResolver(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *auth.RoleBinding:
		eobj := evt.Object.(*auth.RoleBinding)
		kind := "RoleBinding"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		rolebindingHandler := handler.(RoleBindingHandler)
		// handle based on event type
		ctrlCtx := &rolebindingCtx{event: evt.Type, obj: &RoleBinding{RoleBinding: *eobj, ctrler: ct}}
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			fobj, err := ct.getObject(kind, ctrlCtx.GetKey())
			if err != nil {
				ct.addObject(ctrlCtx)
				ct.stats.Counter("RoleBinding_Created_Events").Inc()

				// call the event handler
				ctrlCtx.Lock()
				err = rolebindingHandler.OnRoleBindingCreate(ctrlCtx.obj)
				ctrlCtx.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctrlCtx.obj, err)
					ct.delObject(kind, ctrlCtx.GetKey())
					return err
				}
			} else {
				ctrlCtx := fobj.(*rolebindingCtx)
				ct.stats.Counter("RoleBinding_Updated_Events").Inc()
				ctrlCtx.Lock()
				p := auth.RoleBinding{Spec: eobj.Spec,
					ObjectMeta: eobj.ObjectMeta,
					TypeMeta:   eobj.TypeMeta,
					Status:     eobj.Status}

				err = rolebindingHandler.OnRoleBindingUpdate(ctrlCtx.obj, &p)
				ctrlCtx.obj.RoleBinding = *eobj
				ctrlCtx.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctrlCtx.obj, err)
					return err
				}

			}
		case kvstore.Deleted:
			ctrlCtx := &rolebindingCtx{event: evt.Type, obj: &RoleBinding{RoleBinding: *eobj, ctrler: ct}}
			fobj, err := ct.findObject(kind, ctrlCtx.GetKey())
			if err != nil {
				ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
				return err
			}

			obj := fobj.(*RoleBinding)
			ct.stats.Counter("RoleBinding_Deleted_Events").Inc()
			obj.Lock()
			err = rolebindingHandler.OnRoleBindingDelete(obj)
			obj.Unlock()
			if err != nil {
				ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
			}
			ct.delObject(kind, ctrlCtx.GetKey())
			return nil

		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on RoleBinding watch channel", tp)
	}

	return nil
}

type rolebindingCtx struct {
	ctkitBaseCtx
	event kvstore.WatchEventType
	obj   *RoleBinding //
	//   newObj     *auth.RoleBinding //update
	newObj *rolebindingCtx //update
}

func (ctx *rolebindingCtx) References() map[string]apiintf.ReferenceObj {
	resp := make(map[string]apiintf.ReferenceObj)
	ctx.obj.References(ctx.obj.GetObjectMeta().Name, ctx.obj.GetObjectMeta().Namespace, resp)
	return resp
}

func (ctx *rolebindingCtx) GetKey() string {
	return ctx.obj.MakeKey("auth")
}

func (ctx *rolebindingCtx) GetKind() string {
	return ctx.obj.GetKind()
}

func (ctx *rolebindingCtx) SetEvent(event kvstore.WatchEventType) {
	ctx.event = event
}

func (ctx *rolebindingCtx) SetNewObj(newObj apiintf.CtkitObject) {
	if newObj == nil {
		ctx.newObj = nil
	} else {
		ctx.newObj = newObj.(*rolebindingCtx)
		ctx.newObj.obj.HandlerCtx = ctx.obj.HandlerCtx
	}
}

func (ctx *rolebindingCtx) GetNewObj() apiintf.CtkitObject {
	return ctx.newObj
}

func (ctx *rolebindingCtx) Copy(obj apiintf.CtkitObject) {
	ctx.obj.RoleBinding = obj.(*rolebindingCtx).obj.RoleBinding
}

func (ctx *rolebindingCtx) Lock() {
	ctx.obj.Lock()
}

func (ctx *rolebindingCtx) Unlock() {
	ctx.obj.Unlock()
}

func (ctx *rolebindingCtx) GetObjectMeta() *api.ObjectMeta {
	return ctx.obj.GetObjectMeta()
}

func (ctx *rolebindingCtx) RuntimeObject() runtime.Object {
	var v interface{}
	v = ctx.obj
	return v.(runtime.Object)
}

func (ctx *rolebindingCtx) WorkFunc(context context.Context) error {
	var err error
	evt := ctx.event
	ct := ctx.obj.ctrler
	kind := "RoleBinding"
	ct.Lock()
	handler, ok := ct.handlers[kind]
	ct.Unlock()
	if !ok {
		ct.logger.Fatalf("Cant find the handler for %s", kind)
	}
	rolebindingHandler := handler.(RoleBindingHandler)
	switch evt {
	case kvstore.Created:
		ctx.obj.Lock()
		err = rolebindingHandler.OnRoleBindingCreate(ctx.obj)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctx.obj, err)
			ctx.SetEvent(kvstore.Deleted)
		}
	case kvstore.Updated:
		ct.stats.Counter("RoleBinding_Updated_Events").Inc()
		ctx.obj.Lock()
		p := auth.RoleBinding{Spec: ctx.newObj.obj.Spec,
			ObjectMeta: ctx.newObj.obj.ObjectMeta,
			TypeMeta:   ctx.newObj.obj.TypeMeta,
			Status:     ctx.newObj.obj.Status}
		err = rolebindingHandler.OnRoleBindingUpdate(ctx.obj, &p)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctx.obj, err)
			ctx.SetEvent(kvstore.Deleted)
		}
	case kvstore.Deleted:
		ctx.obj.Lock()
		err = rolebindingHandler.OnRoleBindingDelete(ctx.obj)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error deleting %s %+v. Err: %v", kind, ctx.obj, err)
		}
	}
	ct.resolveObject(ctx.event, ctx)
	return nil
}

// handleRoleBindingEventParallel handles RoleBinding events from watcher
func (ct *ctrlerCtx) handleRoleBindingEventParallel(evt *kvstore.WatchEvent) error {

	if ct.objResolver == nil {
		return ct.handleRoleBindingEventParallelWithNoResolver(evt)
	}

	switch tp := evt.Object.(type) {
	case *auth.RoleBinding:
		eobj := evt.Object.(*auth.RoleBinding)
		kind := "RoleBinding"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ctx := &rolebindingCtx{event: evt.Type, obj: &RoleBinding{RoleBinding: *eobj, ctrler: ct}}

		var err error
		switch evt.Type {
		case kvstore.Created:
			err = ct.processAdd(ctx)
		case kvstore.Updated:
			err = ct.processUpdate(ctx)
		case kvstore.Deleted:
			err = ct.processDelete(ctx)
		}
		return err
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on RoleBinding watch channel", tp)
	}

	return nil
}

// handleRoleBindingEventParallel handles RoleBinding events from watcher
func (ct *ctrlerCtx) handleRoleBindingEventParallelWithNoResolver(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *auth.RoleBinding:
		eobj := evt.Object.(*auth.RoleBinding)
		kind := "RoleBinding"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		rolebindingHandler := handler.(RoleBindingHandler)
		// handle based on event type
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			workFunc := func(ctx context.Context, ctrlCtx shardworkers.WorkObj) error {
				var err error
				workCtx := ctrlCtx.(*rolebindingCtx)
				eobj := workCtx.obj
				fobj, err := ct.getObject(kind, workCtx.GetKey())
				if err != nil {
					ct.addObject(workCtx)
					ct.stats.Counter("RoleBinding_Created_Events").Inc()
					eobj.Lock()
					err = rolebindingHandler.OnRoleBindingCreate(eobj)
					eobj.Unlock()
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, eobj, err)
						ct.delObject(kind, workCtx.GetKey())
					}
				} else {
					workCtx := fobj.(*rolebindingCtx)
					obj := workCtx.obj
					ct.stats.Counter("RoleBinding_Updated_Events").Inc()
					obj.Lock()
					p := auth.RoleBinding{Spec: eobj.Spec,
						ObjectMeta: eobj.ObjectMeta,
						TypeMeta:   eobj.TypeMeta,
						Status:     eobj.Status}

					err = rolebindingHandler.OnRoleBindingUpdate(obj, &p)
					workCtx.obj.RoleBinding = p
					obj.Unlock()
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					}
				}
				return err
			}
			ctrlCtx := &rolebindingCtx{event: evt.Type, obj: &RoleBinding{RoleBinding: *eobj, ctrler: ct}}
			ct.runFunction("RoleBinding", ctrlCtx, workFunc)
		case kvstore.Deleted:
			workFunc := func(ctx context.Context, ctrlCtx shardworkers.WorkObj) error {
				var err error
				workCtx := ctrlCtx.(*rolebindingCtx)
				eobj := workCtx.obj
				fobj, err := ct.findObject(kind, workCtx.GetKey())
				if err != nil {
					ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
					return err
				}
				obj := fobj.(*RoleBinding)
				ct.stats.Counter("RoleBinding_Deleted_Events").Inc()
				obj.Lock()
				err = rolebindingHandler.OnRoleBindingDelete(obj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
				}
				ct.delObject(kind, workCtx.GetKey())
				return nil
			}
			ctrlCtx := &rolebindingCtx{event: evt.Type, obj: &RoleBinding{RoleBinding: *eobj, ctrler: ct}}
			ct.runFunction("RoleBinding", ctrlCtx, workFunc)
		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on RoleBinding watch channel", tp)
	}

	return nil
}

// diffRoleBinding does a diff of RoleBinding objects between local cache and API server
func (ct *ctrlerCtx) diffRoleBinding(apicl apiclient.Services) {
	opts := api.ListWatchOptions{}

	// get a list of all objects from API server
	objlist, err := apicl.AuthV1().RoleBinding().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Errorf("Error getting a list of objects. Err: %v", err)
		return
	}

	ct.logger.Infof("diffRoleBinding(): RoleBindingList returned %d objects", len(objlist))

	// build an object map
	objmap := make(map[string]*auth.RoleBinding)
	for _, obj := range objlist {
		objmap[obj.GetKey()] = obj
	}

	list, err := ct.RoleBinding().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Infof("Failed to get a list of objects. Err: %s", err)
		return
	}

	// if an object is in our local cache and not in API server, trigger delete for it
	for _, obj := range list {
		_, ok := objmap[obj.GetKey()]
		if !ok {
			ct.logger.Infof("diffRoleBinding(): Deleting existing object %#v since its not in apiserver", obj.GetKey())
			evt := kvstore.WatchEvent{
				Type:   kvstore.Deleted,
				Key:    obj.GetKey(),
				Object: &obj.RoleBinding,
			}
			ct.handleRoleBindingEvent(&evt)
		}
	}

	// trigger create event for all others
	for _, obj := range objlist {
		ct.logger.Infof("diffRoleBinding(): Adding object %#v", obj.GetKey())
		evt := kvstore.WatchEvent{
			Type:   kvstore.Created,
			Key:    obj.GetKey(),
			Object: obj,
		}
		ct.handleRoleBindingEvent(&evt)
	}
}

func (ct *ctrlerCtx) runRoleBindingWatcher() {
	kind := "RoleBinding"

	ct.Lock()
	handler, ok := ct.handlers[kind]
	ct.Unlock()
	if !ok {
		ct.logger.Fatalf("Cant find the handler for %s", kind)
	}
	rolebindingHandler := handler.(RoleBindingHandler)

	opts := rolebindingHandler.GetRoleBindingWatchOptions()

	// if there is no API server to connect to, we are done
	if (ct.resolver == nil) || ct.apisrvURL == "" {
		return
	}

	// create context
	ctx, cancel := context.WithCancel(context.Background())
	ct.Lock()
	ct.watchCancel[kind] = cancel
	ct.Unlock()
	logger := ct.logger.WithContext("submodule", "RoleBindingWatcher")

	// create a grpc client
	apiclt, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
	if err == nil {
		ct.diffRoleBinding(apiclt)
	}

	// setup wait group
	ct.waitGrp.Add(1)

	// start a goroutine
	go func() {
		defer ct.waitGrp.Done()
		ct.stats.Counter("RoleBinding_Watch").Inc()
		defer ct.stats.Counter("RoleBinding_Watch").Dec()

		// loop forever
		for {
			// create a grpc client
			apicl, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
			if err != nil {
				logger.Warnf("Failed to connect to gRPC server [%s]\n", ct.apisrvURL)
				ct.stats.Counter("RoleBinding_ApiClientErr").Inc()
			} else {
				logger.Infof("API client connected {%+v}", apicl)

				// RoleBinding object watcher
				wt, werr := apicl.AuthV1().RoleBinding().Watch(ctx, opts)
				if werr != nil {
					select {
					case <-ctx.Done():
						logger.Infof("watch %s cancelled", kind)
						return
					default:
					}
					logger.Errorf("Failed to start %s watch (%s)\n", kind, werr)
					// wait for a second and retry connecting to api server
					apicl.Close()
					time.Sleep(time.Second)
					continue
				}
				ct.Lock()
				ct.watchers[kind] = wt
				ct.Unlock()

				// perform a diff with API server and local cache
				time.Sleep(time.Millisecond * 100)
				ct.diffRoleBinding(apicl)

				// handle api server watch events
			innerLoop:
				for {
					// wait for events
					select {
					case evt, ok := <-wt.EventChan():
						if !ok {
							logger.Error("Error receiving from apisrv watcher")
							ct.stats.Counter("RoleBinding_WatchErrors").Inc()
							break innerLoop
						}

						// handle event in parallel
						ct.handleRoleBindingEventParallel(evt)
					}
				}
				apicl.Close()
			}

			// if stop flag is set, we are done
			if ct.stoped {
				logger.Infof("Exiting API server watcher")
				return
			}

			// wait for a second and retry connecting to api server
			time.Sleep(time.Second)
		}
	}()
}

// WatchRoleBinding starts watch on RoleBinding object
func (ct *ctrlerCtx) WatchRoleBinding(handler RoleBindingHandler) error {
	kind := "RoleBinding"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchers[kind]
	ct.Unlock()
	if ok {
		return fmt.Errorf("RoleBinding watcher already exists")
	}

	// save handler
	ct.Lock()
	ct.handlers[kind] = handler
	ct.Unlock()

	// run RoleBinding watcher in a go routine
	ct.runRoleBindingWatcher()

	return nil
}

// StopWatchRoleBinding stops watch on RoleBinding object
func (ct *ctrlerCtx) StopWatchRoleBinding(handler RoleBindingHandler) error {
	kind := "RoleBinding"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchers[kind]
	ct.Unlock()
	if !ok {
		return fmt.Errorf("RoleBinding watcher does not exist")
	}

	ct.Lock()
	cancel, _ := ct.watchCancel[kind]
	cancel()
	delete(ct.watchers, kind)
	delete(ct.watchCancel, kind)
	ct.Unlock()

	time.Sleep(100 * time.Millisecond)

	return nil
}

// RoleBindingAPI returns
type RoleBindingAPI interface {
	Create(obj *auth.RoleBinding) error
	CreateEvent(obj *auth.RoleBinding) error
	Update(obj *auth.RoleBinding) error
	Delete(obj *auth.RoleBinding) error
	Find(meta *api.ObjectMeta) (*RoleBinding, error)
	List(ctx context.Context, opts *api.ListWatchOptions) ([]*RoleBinding, error)
	Watch(handler RoleBindingHandler) error
	StopWatch(handler RoleBindingHandler) error
}

// dummy struct that implements RoleBindingAPI
type rolebindingAPI struct {
	ct *ctrlerCtx
}

// Create creates RoleBinding object
func (api *rolebindingAPI) Create(obj *auth.RoleBinding) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.AuthV1().RoleBinding().Create(context.Background(), obj)
		if err != nil && strings.Contains(err.Error(), "AlreadyExists") {
			_, err = apicl.AuthV1().RoleBinding().Update(context.Background(), obj)
		}
		return err
	}

	api.ct.handleRoleBindingEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Created})
	return nil
}

// CreateEvent creates RoleBinding object and synchronously triggers local event
func (api *rolebindingAPI) CreateEvent(obj *auth.RoleBinding) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.AuthV1().RoleBinding().Create(context.Background(), obj)
		if err != nil && strings.Contains(err.Error(), "AlreadyExists") {
			_, err = apicl.AuthV1().RoleBinding().Update(context.Background(), obj)
		}
		if err != nil {
			api.ct.logger.Errorf("Error creating object in api server. Err: %v", err)
			return err
		}
		return err
	}

	api.ct.handleRoleBindingEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Created})
	return nil
}

// Update triggers update on RoleBinding object
func (api *rolebindingAPI) Update(obj *auth.RoleBinding) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.AuthV1().RoleBinding().Update(context.Background(), obj)
		return err
	}

	api.ct.handleRoleBindingEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Updated})
	return nil
}

// Delete deletes RoleBinding object
func (api *rolebindingAPI) Delete(obj *auth.RoleBinding) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.AuthV1().RoleBinding().Delete(context.Background(), &obj.ObjectMeta)
		return err
	}

	api.ct.handleRoleBindingEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Deleted})
	return nil
}

// MakeKey generates a KV store key for the object
func (api *rolebindingAPI) getFullKey(tenant, name string) string {
	if tenant != "" {
		return fmt.Sprint(globals.ConfigRootPrefix, "/", "auth", "/", "role-bindings", "/", tenant, "/", name)
	}
	return fmt.Sprint(globals.ConfigRootPrefix, "/", "auth", "/", "role-bindings", "/", name)
}

// Find returns an object by meta
func (api *rolebindingAPI) Find(meta *api.ObjectMeta) (*RoleBinding, error) {
	// find the object
	obj, err := api.ct.FindObject("RoleBinding", meta)
	if err != nil {
		return nil, err
	}

	// asset type
	switch obj.(type) {
	case *RoleBinding:
		hobj := obj.(*RoleBinding)
		return hobj, nil
	default:
		return nil, errors.New("incorrect object type")
	}
}

// List returns a list of all RoleBinding objects
func (api *rolebindingAPI) List(ctx context.Context, opts *api.ListWatchOptions) ([]*RoleBinding, error) {
	var objlist []*RoleBinding
	objs, err := api.ct.List("RoleBinding", ctx, opts)

	if err != nil {
		return nil, err
	}

	for _, obj := range objs {
		switch tp := obj.(type) {
		case *RoleBinding:
			eobj := obj.(*RoleBinding)
			objlist = append(objlist, eobj)
		default:
			log.Fatalf("Got invalid object type %v while looking for RoleBinding", tp)
		}
	}

	return objlist, nil
}

// Watch sets up a event handlers for RoleBinding object
func (api *rolebindingAPI) Watch(handler RoleBindingHandler) error {
	api.ct.startWorkerPool("RoleBinding")
	return api.ct.WatchRoleBinding(handler)
}

// StopWatch stop watch for Tenant RoleBinding object
func (api *rolebindingAPI) StopWatch(handler RoleBindingHandler) error {
	api.ct.Lock()
	api.ct.workPools["RoleBinding"].Stop()
	api.ct.Unlock()
	return api.ct.StopWatchRoleBinding(handler)
}

// RoleBinding returns RoleBindingAPI
func (ct *ctrlerCtx) RoleBinding() RoleBindingAPI {
	return &rolebindingAPI{ct: ct}
}

// UserPreference is a wrapper object that implements additional functionality
type UserPreference struct {
	sync.Mutex
	auth.UserPreference
	HandlerCtx interface{} // additional state handlers can store
	ctrler     *ctrlerCtx  // reference back to the controller instance
}

func (obj *UserPreference) Write() error {
	// if there is no API server to connect to, we are done
	if (obj.ctrler == nil) || (obj.ctrler.resolver == nil) || obj.ctrler.apisrvURL == "" {
		return nil
	}

	apicl, err := obj.ctrler.apiClient()
	if err != nil {
		obj.ctrler.logger.Errorf("Error creating API server clent. Err: %v", err)
		return err
	}

	obj.ctrler.stats.Counter("UserPreference_Writes").Inc()

	// write to api server
	if obj.ObjectMeta.ResourceVersion != "" {
		// update it
		for i := 0; i < maxApisrvWriteRetry; i++ {
			_, err = apicl.AuthV1().UserPreference().UpdateStatus(context.Background(), &obj.UserPreference)
			if err == nil {
				break
			}
			time.Sleep(time.Millisecond * 100)
		}
	} else {
		//  create
		_, err = apicl.AuthV1().UserPreference().Create(context.Background(), &obj.UserPreference)
	}

	return nil
}

// UserPreferenceHandler is the event handler for UserPreference object
type UserPreferenceHandler interface {
	OnUserPreferenceCreate(obj *UserPreference) error
	OnUserPreferenceUpdate(oldObj *UserPreference, newObj *auth.UserPreference) error
	OnUserPreferenceDelete(obj *UserPreference) error
	GetUserPreferenceWatchOptions() *api.ListWatchOptions
}

// handleUserPreferenceEvent handles UserPreference events from watcher
func (ct *ctrlerCtx) handleUserPreferenceEvent(evt *kvstore.WatchEvent) error {

	if ct.objResolver == nil {
		return ct.handleUserPreferenceEventNoResolver(evt)
	}

	switch tp := evt.Object.(type) {
	case *auth.UserPreference:
		eobj := evt.Object.(*auth.UserPreference)
		kind := "UserPreference"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ctx := &userpreferenceCtx{event: evt.Type,
			obj: &UserPreference{UserPreference: *eobj, ctrler: ct}}

		var err error
		switch evt.Type {
		case kvstore.Created:
			err = ct.processAdd(ctx)
		case kvstore.Updated:
			err = ct.processUpdate(ctx)
		case kvstore.Deleted:
			err = ct.processDelete(ctx)
		}
		return err
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on UserPreference watch channel", tp)
	}

	return nil
}

// handleUserPreferenceEventNoResolver handles UserPreference events from watcher
func (ct *ctrlerCtx) handleUserPreferenceEventNoResolver(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *auth.UserPreference:
		eobj := evt.Object.(*auth.UserPreference)
		kind := "UserPreference"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		userpreferenceHandler := handler.(UserPreferenceHandler)
		// handle based on event type
		ctrlCtx := &userpreferenceCtx{event: evt.Type, obj: &UserPreference{UserPreference: *eobj, ctrler: ct}}
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			fobj, err := ct.getObject(kind, ctrlCtx.GetKey())
			if err != nil {
				ct.addObject(ctrlCtx)
				ct.stats.Counter("UserPreference_Created_Events").Inc()

				// call the event handler
				ctrlCtx.Lock()
				err = userpreferenceHandler.OnUserPreferenceCreate(ctrlCtx.obj)
				ctrlCtx.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctrlCtx.obj, err)
					ct.delObject(kind, ctrlCtx.GetKey())
					return err
				}
			} else {
				ctrlCtx := fobj.(*userpreferenceCtx)
				ct.stats.Counter("UserPreference_Updated_Events").Inc()
				ctrlCtx.Lock()
				p := auth.UserPreference{Spec: eobj.Spec,
					ObjectMeta: eobj.ObjectMeta,
					TypeMeta:   eobj.TypeMeta,
					Status:     eobj.Status}

				err = userpreferenceHandler.OnUserPreferenceUpdate(ctrlCtx.obj, &p)
				ctrlCtx.obj.UserPreference = *eobj
				ctrlCtx.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctrlCtx.obj, err)
					return err
				}

			}
		case kvstore.Deleted:
			ctrlCtx := &userpreferenceCtx{event: evt.Type, obj: &UserPreference{UserPreference: *eobj, ctrler: ct}}
			fobj, err := ct.findObject(kind, ctrlCtx.GetKey())
			if err != nil {
				ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
				return err
			}

			obj := fobj.(*UserPreference)
			ct.stats.Counter("UserPreference_Deleted_Events").Inc()
			obj.Lock()
			err = userpreferenceHandler.OnUserPreferenceDelete(obj)
			obj.Unlock()
			if err != nil {
				ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
			}
			ct.delObject(kind, ctrlCtx.GetKey())
			return nil

		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on UserPreference watch channel", tp)
	}

	return nil
}

type userpreferenceCtx struct {
	ctkitBaseCtx
	event kvstore.WatchEventType
	obj   *UserPreference //
	//   newObj     *auth.UserPreference //update
	newObj *userpreferenceCtx //update
}

func (ctx *userpreferenceCtx) References() map[string]apiintf.ReferenceObj {
	resp := make(map[string]apiintf.ReferenceObj)
	ctx.obj.References(ctx.obj.GetObjectMeta().Name, ctx.obj.GetObjectMeta().Namespace, resp)
	return resp
}

func (ctx *userpreferenceCtx) GetKey() string {
	return ctx.obj.MakeKey("auth")
}

func (ctx *userpreferenceCtx) GetKind() string {
	return ctx.obj.GetKind()
}

func (ctx *userpreferenceCtx) SetEvent(event kvstore.WatchEventType) {
	ctx.event = event
}

func (ctx *userpreferenceCtx) SetNewObj(newObj apiintf.CtkitObject) {
	if newObj == nil {
		ctx.newObj = nil
	} else {
		ctx.newObj = newObj.(*userpreferenceCtx)
		ctx.newObj.obj.HandlerCtx = ctx.obj.HandlerCtx
	}
}

func (ctx *userpreferenceCtx) GetNewObj() apiintf.CtkitObject {
	return ctx.newObj
}

func (ctx *userpreferenceCtx) Copy(obj apiintf.CtkitObject) {
	ctx.obj.UserPreference = obj.(*userpreferenceCtx).obj.UserPreference
}

func (ctx *userpreferenceCtx) Lock() {
	ctx.obj.Lock()
}

func (ctx *userpreferenceCtx) Unlock() {
	ctx.obj.Unlock()
}

func (ctx *userpreferenceCtx) GetObjectMeta() *api.ObjectMeta {
	return ctx.obj.GetObjectMeta()
}

func (ctx *userpreferenceCtx) RuntimeObject() runtime.Object {
	var v interface{}
	v = ctx.obj
	return v.(runtime.Object)
}

func (ctx *userpreferenceCtx) WorkFunc(context context.Context) error {
	var err error
	evt := ctx.event
	ct := ctx.obj.ctrler
	kind := "UserPreference"
	ct.Lock()
	handler, ok := ct.handlers[kind]
	ct.Unlock()
	if !ok {
		ct.logger.Fatalf("Cant find the handler for %s", kind)
	}
	userpreferenceHandler := handler.(UserPreferenceHandler)
	switch evt {
	case kvstore.Created:
		ctx.obj.Lock()
		err = userpreferenceHandler.OnUserPreferenceCreate(ctx.obj)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctx.obj, err)
			ctx.SetEvent(kvstore.Deleted)
		}
	case kvstore.Updated:
		ct.stats.Counter("UserPreference_Updated_Events").Inc()
		ctx.obj.Lock()
		p := auth.UserPreference{Spec: ctx.newObj.obj.Spec,
			ObjectMeta: ctx.newObj.obj.ObjectMeta,
			TypeMeta:   ctx.newObj.obj.TypeMeta,
			Status:     ctx.newObj.obj.Status}
		err = userpreferenceHandler.OnUserPreferenceUpdate(ctx.obj, &p)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctx.obj, err)
			ctx.SetEvent(kvstore.Deleted)
		}
	case kvstore.Deleted:
		ctx.obj.Lock()
		err = userpreferenceHandler.OnUserPreferenceDelete(ctx.obj)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error deleting %s %+v. Err: %v", kind, ctx.obj, err)
		}
	}
	ct.resolveObject(ctx.event, ctx)
	return nil
}

// handleUserPreferenceEventParallel handles UserPreference events from watcher
func (ct *ctrlerCtx) handleUserPreferenceEventParallel(evt *kvstore.WatchEvent) error {

	if ct.objResolver == nil {
		return ct.handleUserPreferenceEventParallelWithNoResolver(evt)
	}

	switch tp := evt.Object.(type) {
	case *auth.UserPreference:
		eobj := evt.Object.(*auth.UserPreference)
		kind := "UserPreference"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ctx := &userpreferenceCtx{event: evt.Type, obj: &UserPreference{UserPreference: *eobj, ctrler: ct}}

		var err error
		switch evt.Type {
		case kvstore.Created:
			err = ct.processAdd(ctx)
		case kvstore.Updated:
			err = ct.processUpdate(ctx)
		case kvstore.Deleted:
			err = ct.processDelete(ctx)
		}
		return err
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on UserPreference watch channel", tp)
	}

	return nil
}

// handleUserPreferenceEventParallel handles UserPreference events from watcher
func (ct *ctrlerCtx) handleUserPreferenceEventParallelWithNoResolver(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *auth.UserPreference:
		eobj := evt.Object.(*auth.UserPreference)
		kind := "UserPreference"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		userpreferenceHandler := handler.(UserPreferenceHandler)
		// handle based on event type
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			workFunc := func(ctx context.Context, ctrlCtx shardworkers.WorkObj) error {
				var err error
				workCtx := ctrlCtx.(*userpreferenceCtx)
				eobj := workCtx.obj
				fobj, err := ct.getObject(kind, workCtx.GetKey())
				if err != nil {
					ct.addObject(workCtx)
					ct.stats.Counter("UserPreference_Created_Events").Inc()
					eobj.Lock()
					err = userpreferenceHandler.OnUserPreferenceCreate(eobj)
					eobj.Unlock()
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, eobj, err)
						ct.delObject(kind, workCtx.GetKey())
					}
				} else {
					workCtx := fobj.(*userpreferenceCtx)
					obj := workCtx.obj
					ct.stats.Counter("UserPreference_Updated_Events").Inc()
					obj.Lock()
					p := auth.UserPreference{Spec: eobj.Spec,
						ObjectMeta: eobj.ObjectMeta,
						TypeMeta:   eobj.TypeMeta,
						Status:     eobj.Status}

					err = userpreferenceHandler.OnUserPreferenceUpdate(obj, &p)
					workCtx.obj.UserPreference = p
					obj.Unlock()
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					}
				}
				return err
			}
			ctrlCtx := &userpreferenceCtx{event: evt.Type, obj: &UserPreference{UserPreference: *eobj, ctrler: ct}}
			ct.runFunction("UserPreference", ctrlCtx, workFunc)
		case kvstore.Deleted:
			workFunc := func(ctx context.Context, ctrlCtx shardworkers.WorkObj) error {
				var err error
				workCtx := ctrlCtx.(*userpreferenceCtx)
				eobj := workCtx.obj
				fobj, err := ct.findObject(kind, workCtx.GetKey())
				if err != nil {
					ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
					return err
				}
				obj := fobj.(*UserPreference)
				ct.stats.Counter("UserPreference_Deleted_Events").Inc()
				obj.Lock()
				err = userpreferenceHandler.OnUserPreferenceDelete(obj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
				}
				ct.delObject(kind, workCtx.GetKey())
				return nil
			}
			ctrlCtx := &userpreferenceCtx{event: evt.Type, obj: &UserPreference{UserPreference: *eobj, ctrler: ct}}
			ct.runFunction("UserPreference", ctrlCtx, workFunc)
		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on UserPreference watch channel", tp)
	}

	return nil
}

// diffUserPreference does a diff of UserPreference objects between local cache and API server
func (ct *ctrlerCtx) diffUserPreference(apicl apiclient.Services) {
	opts := api.ListWatchOptions{}

	// get a list of all objects from API server
	objlist, err := apicl.AuthV1().UserPreference().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Errorf("Error getting a list of objects. Err: %v", err)
		return
	}

	ct.logger.Infof("diffUserPreference(): UserPreferenceList returned %d objects", len(objlist))

	// build an object map
	objmap := make(map[string]*auth.UserPreference)
	for _, obj := range objlist {
		objmap[obj.GetKey()] = obj
	}

	list, err := ct.UserPreference().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Infof("Failed to get a list of objects. Err: %s", err)
		return
	}

	// if an object is in our local cache and not in API server, trigger delete for it
	for _, obj := range list {
		_, ok := objmap[obj.GetKey()]
		if !ok {
			ct.logger.Infof("diffUserPreference(): Deleting existing object %#v since its not in apiserver", obj.GetKey())
			evt := kvstore.WatchEvent{
				Type:   kvstore.Deleted,
				Key:    obj.GetKey(),
				Object: &obj.UserPreference,
			}
			ct.handleUserPreferenceEvent(&evt)
		}
	}

	// trigger create event for all others
	for _, obj := range objlist {
		ct.logger.Infof("diffUserPreference(): Adding object %#v", obj.GetKey())
		evt := kvstore.WatchEvent{
			Type:   kvstore.Created,
			Key:    obj.GetKey(),
			Object: obj,
		}
		ct.handleUserPreferenceEvent(&evt)
	}
}

func (ct *ctrlerCtx) runUserPreferenceWatcher() {
	kind := "UserPreference"

	ct.Lock()
	handler, ok := ct.handlers[kind]
	ct.Unlock()
	if !ok {
		ct.logger.Fatalf("Cant find the handler for %s", kind)
	}
	userpreferenceHandler := handler.(UserPreferenceHandler)

	opts := userpreferenceHandler.GetUserPreferenceWatchOptions()

	// if there is no API server to connect to, we are done
	if (ct.resolver == nil) || ct.apisrvURL == "" {
		return
	}

	// create context
	ctx, cancel := context.WithCancel(context.Background())
	ct.Lock()
	ct.watchCancel[kind] = cancel
	ct.Unlock()
	logger := ct.logger.WithContext("submodule", "UserPreferenceWatcher")

	// create a grpc client
	apiclt, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
	if err == nil {
		ct.diffUserPreference(apiclt)
	}

	// setup wait group
	ct.waitGrp.Add(1)

	// start a goroutine
	go func() {
		defer ct.waitGrp.Done()
		ct.stats.Counter("UserPreference_Watch").Inc()
		defer ct.stats.Counter("UserPreference_Watch").Dec()

		// loop forever
		for {
			// create a grpc client
			apicl, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
			if err != nil {
				logger.Warnf("Failed to connect to gRPC server [%s]\n", ct.apisrvURL)
				ct.stats.Counter("UserPreference_ApiClientErr").Inc()
			} else {
				logger.Infof("API client connected {%+v}", apicl)

				// UserPreference object watcher
				wt, werr := apicl.AuthV1().UserPreference().Watch(ctx, opts)
				if werr != nil {
					select {
					case <-ctx.Done():
						logger.Infof("watch %s cancelled", kind)
						return
					default:
					}
					logger.Errorf("Failed to start %s watch (%s)\n", kind, werr)
					// wait for a second and retry connecting to api server
					apicl.Close()
					time.Sleep(time.Second)
					continue
				}
				ct.Lock()
				ct.watchers[kind] = wt
				ct.Unlock()

				// perform a diff with API server and local cache
				time.Sleep(time.Millisecond * 100)
				ct.diffUserPreference(apicl)

				// handle api server watch events
			innerLoop:
				for {
					// wait for events
					select {
					case evt, ok := <-wt.EventChan():
						if !ok {
							logger.Error("Error receiving from apisrv watcher")
							ct.stats.Counter("UserPreference_WatchErrors").Inc()
							break innerLoop
						}

						// handle event in parallel
						ct.handleUserPreferenceEventParallel(evt)
					}
				}
				apicl.Close()
			}

			// if stop flag is set, we are done
			if ct.stoped {
				logger.Infof("Exiting API server watcher")
				return
			}

			// wait for a second and retry connecting to api server
			time.Sleep(time.Second)
		}
	}()
}

// WatchUserPreference starts watch on UserPreference object
func (ct *ctrlerCtx) WatchUserPreference(handler UserPreferenceHandler) error {
	kind := "UserPreference"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchers[kind]
	ct.Unlock()
	if ok {
		return fmt.Errorf("UserPreference watcher already exists")
	}

	// save handler
	ct.Lock()
	ct.handlers[kind] = handler
	ct.Unlock()

	// run UserPreference watcher in a go routine
	ct.runUserPreferenceWatcher()

	return nil
}

// StopWatchUserPreference stops watch on UserPreference object
func (ct *ctrlerCtx) StopWatchUserPreference(handler UserPreferenceHandler) error {
	kind := "UserPreference"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchers[kind]
	ct.Unlock()
	if !ok {
		return fmt.Errorf("UserPreference watcher does not exist")
	}

	ct.Lock()
	cancel, _ := ct.watchCancel[kind]
	cancel()
	delete(ct.watchers, kind)
	delete(ct.watchCancel, kind)
	ct.Unlock()

	time.Sleep(100 * time.Millisecond)

	return nil
}

// UserPreferenceAPI returns
type UserPreferenceAPI interface {
	Create(obj *auth.UserPreference) error
	CreateEvent(obj *auth.UserPreference) error
	Update(obj *auth.UserPreference) error
	Delete(obj *auth.UserPreference) error
	Find(meta *api.ObjectMeta) (*UserPreference, error)
	List(ctx context.Context, opts *api.ListWatchOptions) ([]*UserPreference, error)
	Watch(handler UserPreferenceHandler) error
	StopWatch(handler UserPreferenceHandler) error
}

// dummy struct that implements UserPreferenceAPI
type userpreferenceAPI struct {
	ct *ctrlerCtx
}

// Create creates UserPreference object
func (api *userpreferenceAPI) Create(obj *auth.UserPreference) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.AuthV1().UserPreference().Create(context.Background(), obj)
		if err != nil && strings.Contains(err.Error(), "AlreadyExists") {
			_, err = apicl.AuthV1().UserPreference().Update(context.Background(), obj)
		}
		return err
	}

	api.ct.handleUserPreferenceEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Created})
	return nil
}

// CreateEvent creates UserPreference object and synchronously triggers local event
func (api *userpreferenceAPI) CreateEvent(obj *auth.UserPreference) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.AuthV1().UserPreference().Create(context.Background(), obj)
		if err != nil && strings.Contains(err.Error(), "AlreadyExists") {
			_, err = apicl.AuthV1().UserPreference().Update(context.Background(), obj)
		}
		if err != nil {
			api.ct.logger.Errorf("Error creating object in api server. Err: %v", err)
			return err
		}
		return err
	}

	api.ct.handleUserPreferenceEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Created})
	return nil
}

// Update triggers update on UserPreference object
func (api *userpreferenceAPI) Update(obj *auth.UserPreference) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.AuthV1().UserPreference().Update(context.Background(), obj)
		return err
	}

	api.ct.handleUserPreferenceEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Updated})
	return nil
}

// Delete deletes UserPreference object
func (api *userpreferenceAPI) Delete(obj *auth.UserPreference) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.AuthV1().UserPreference().Delete(context.Background(), &obj.ObjectMeta)
		return err
	}

	api.ct.handleUserPreferenceEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Deleted})
	return nil
}

// MakeKey generates a KV store key for the object
func (api *userpreferenceAPI) getFullKey(tenant, name string) string {
	if tenant != "" {
		return fmt.Sprint(globals.ConfigRootPrefix, "/", "auth", "/", "user-preferences", "/", tenant, "/", name)
	}
	return fmt.Sprint(globals.ConfigRootPrefix, "/", "auth", "/", "user-preferences", "/", name)
}

// Find returns an object by meta
func (api *userpreferenceAPI) Find(meta *api.ObjectMeta) (*UserPreference, error) {
	// find the object
	obj, err := api.ct.FindObject("UserPreference", meta)
	if err != nil {
		return nil, err
	}

	// asset type
	switch obj.(type) {
	case *UserPreference:
		hobj := obj.(*UserPreference)
		return hobj, nil
	default:
		return nil, errors.New("incorrect object type")
	}
}

// List returns a list of all UserPreference objects
func (api *userpreferenceAPI) List(ctx context.Context, opts *api.ListWatchOptions) ([]*UserPreference, error) {
	var objlist []*UserPreference
	objs, err := api.ct.List("UserPreference", ctx, opts)

	if err != nil {
		return nil, err
	}

	for _, obj := range objs {
		switch tp := obj.(type) {
		case *UserPreference:
			eobj := obj.(*UserPreference)
			objlist = append(objlist, eobj)
		default:
			log.Fatalf("Got invalid object type %v while looking for UserPreference", tp)
		}
	}

	return objlist, nil
}

// Watch sets up a event handlers for UserPreference object
func (api *userpreferenceAPI) Watch(handler UserPreferenceHandler) error {
	api.ct.startWorkerPool("UserPreference")
	return api.ct.WatchUserPreference(handler)
}

// StopWatch stop watch for Tenant UserPreference object
func (api *userpreferenceAPI) StopWatch(handler UserPreferenceHandler) error {
	api.ct.Lock()
	api.ct.workPools["UserPreference"].Stop()
	api.ct.Unlock()
	return api.ct.StopWatchUserPreference(handler)
}

// UserPreference returns UserPreferenceAPI
func (ct *ctrlerCtx) UserPreference() UserPreferenceAPI {
	return &userpreferenceAPI{ct: ct}
}
