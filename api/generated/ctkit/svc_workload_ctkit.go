// Code generated by protoc-gen-grpc-pensando DO NOT EDIT.

/*
Package ctkit is a auto generated package.
Input file: svc_workload.proto
*/
package ctkit

import (
	"context"
	"errors"
	"fmt"
	"strings"
	"sync"
	"time"

	"github.com/pensando/sw/api"
	"github.com/pensando/sw/api/generated/apiclient"
	"github.com/pensando/sw/api/generated/workload"
	apiintf "github.com/pensando/sw/api/interfaces"
	"github.com/pensando/sw/venice/globals"
	"github.com/pensando/sw/venice/utils/balancer"
	"github.com/pensando/sw/venice/utils/kvstore"
	"github.com/pensando/sw/venice/utils/log"
	"github.com/pensando/sw/venice/utils/rpckit"
	"github.com/pensando/sw/venice/utils/runtime"
	"github.com/pensando/sw/venice/utils/shardworkers"
)

// Endpoint is a wrapper object that implements additional functionality
type Endpoint struct {
	sync.Mutex
	workload.Endpoint
	HandlerCtx interface{} // additional state handlers can store
	ctrler     *ctrlerCtx  // reference back to the controller instance
}

func (obj *Endpoint) Write() error {
	// if there is no API server to connect to, we are done
	if (obj.ctrler == nil) || (obj.ctrler.resolver == nil) || obj.ctrler.apisrvURL == "" {
		return nil
	}

	apicl, err := obj.ctrler.apiClient()
	if err != nil {
		obj.ctrler.logger.Errorf("Error creating API server clent. Err: %v", err)
		return err
	}

	obj.ctrler.stats.Counter("Endpoint_Writes").Inc()

	// write to api server
	if obj.ObjectMeta.ResourceVersion != "" {
		// update it
		for i := 0; i < maxApisrvWriteRetry; i++ {
			_, err = apicl.WorkloadV1().Endpoint().UpdateStatus(context.Background(), &obj.Endpoint)
			if err == nil {
				break
			}
			time.Sleep(time.Millisecond * 100)
		}
	} else {
		//  create
		_, err = apicl.WorkloadV1().Endpoint().Create(context.Background(), &obj.Endpoint)
	}

	return nil
}

// EndpointHandler is the event handler for Endpoint object
type EndpointHandler interface {
	OnEndpointCreate(obj *Endpoint) error
	OnEndpointUpdate(oldObj *Endpoint, newObj *workload.Endpoint) error
	OnEndpointDelete(obj *Endpoint) error
	GetEndpointWatchOptions() *api.ListWatchOptions
}

// OnEndpointCreate is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnEndpointCreate(obj *Endpoint) error {
	log.Info("OnEndpointCreate is not implemented")
	return nil
}

// OnEndpointUpdate is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnEndpointUpdate(oldObj *Endpoint, newObj *workload.Endpoint) error {
	log.Info("OnEndpointUpdate is not implemented")
	return nil
}

// OnEndpointDelete is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnEndpointDelete(obj *Endpoint) error {
	log.Info("OnEndpointDelete is not implemented")
	return nil
}

// GetEndpointWatchOptions is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) GetEndpointWatchOptions() *api.ListWatchOptions {
	log.Info("GetEndpointWatchOptions is not implemented")
	opts := &api.ListWatchOptions{}
	return opts
}

// handleEndpointEvent handles Endpoint events from watcher
func (ct *ctrlerCtx) handleEndpointEvent(evt *kvstore.WatchEvent) error {

	if ct.objResolver == nil {
		return ct.handleEndpointEventNoResolver(evt)
	}

	switch tp := evt.Object.(type) {
	case *workload.Endpoint:
		eobj := evt.Object.(*workload.Endpoint)
		kind := "Endpoint"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ctx := &endpointCtx{event: evt.Type,
			obj: &Endpoint{Endpoint: *eobj, ctrler: ct}}

		var err error
		switch evt.Type {
		case kvstore.Created:
			err = ct.processAdd(ctx)
		case kvstore.Updated:
			err = ct.processUpdate(ctx)
		case kvstore.Deleted:
			err = ct.processDelete(ctx)
		}
		return err
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on Endpoint watch channel", tp)
	}

	return nil
}

// handleEndpointEventNoResolver handles Endpoint events from watcher
func (ct *ctrlerCtx) handleEndpointEventNoResolver(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *workload.Endpoint:
		eobj := evt.Object.(*workload.Endpoint)
		kind := "Endpoint"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		endpointHandler := handler.(EndpointHandler)
		// handle based on event type
		ctrlCtx := &endpointCtx{event: evt.Type, obj: &Endpoint{Endpoint: *eobj, ctrler: ct}}
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			fobj, err := ct.getObject(kind, ctrlCtx.GetKey())
			if err != nil {
				ct.addObject(ctrlCtx)
				ct.stats.Counter("Endpoint_Created_Events").Inc()

				// call the event handler
				ctrlCtx.Lock()
				err = endpointHandler.OnEndpointCreate(ctrlCtx.obj)
				ctrlCtx.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctrlCtx.obj, err)
					ct.delObject(kind, ctrlCtx.GetKey())
					return err
				}
			} else {
				ctrlCtx := fobj.(*endpointCtx)
				ct.stats.Counter("Endpoint_Updated_Events").Inc()
				ctrlCtx.Lock()
				p := workload.Endpoint{Spec: eobj.Spec,
					ObjectMeta: eobj.ObjectMeta,
					TypeMeta:   eobj.TypeMeta,
					Status:     eobj.Status}

				err = endpointHandler.OnEndpointUpdate(ctrlCtx.obj, &p)
				ctrlCtx.obj.Endpoint = *eobj
				ctrlCtx.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctrlCtx.obj, err)
					return err
				}

			}
		case kvstore.Deleted:
			ctrlCtx := &endpointCtx{event: evt.Type, obj: &Endpoint{Endpoint: *eobj, ctrler: ct}}
			fobj, err := ct.findObject(kind, ctrlCtx.GetKey())
			if err != nil {
				ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
				return err
			}

			obj := fobj.(*Endpoint)
			ct.stats.Counter("Endpoint_Deleted_Events").Inc()
			obj.Lock()
			err = endpointHandler.OnEndpointDelete(obj)
			obj.Unlock()
			if err != nil {
				ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
			}
			ct.delObject(kind, ctrlCtx.GetKey())
			return nil

		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on Endpoint watch channel", tp)
	}

	return nil
}

type endpointCtx struct {
	ctkitBaseCtx
	event kvstore.WatchEventType
	obj   *Endpoint //
	//   newObj     *workload.Endpoint //update
	newObj *endpointCtx //update
}

func (ctx *endpointCtx) References() map[string]apiintf.ReferenceObj {
	resp := make(map[string]apiintf.ReferenceObj)
	ctx.obj.References(ctx.obj.GetObjectMeta().Name, ctx.obj.GetObjectMeta().Namespace, resp)
	return resp
}

func (ctx *endpointCtx) GetKey() string {
	return ctx.obj.MakeKey("workload")
}

func (ctx *endpointCtx) GetKind() string {
	return ctx.obj.GetKind()
}

func (ctx *endpointCtx) SetEvent(event kvstore.WatchEventType) {
	ctx.event = event
}

func (ctx *endpointCtx) SetNewObj(newObj apiintf.CtkitObject) {
	if newObj == nil {
		ctx.newObj = nil
	} else {
		ctx.newObj = newObj.(*endpointCtx)
		ctx.newObj.obj.HandlerCtx = ctx.obj.HandlerCtx
	}
}

func (ctx *endpointCtx) GetNewObj() apiintf.CtkitObject {
	return ctx.newObj
}

func (ctx *endpointCtx) Copy(obj apiintf.CtkitObject) {
	ctx.obj.Endpoint = obj.(*endpointCtx).obj.Endpoint
}

func (ctx *endpointCtx) Lock() {
	ctx.obj.Lock()
}

func (ctx *endpointCtx) Unlock() {
	ctx.obj.Unlock()
}

func (ctx *endpointCtx) GetObjectMeta() *api.ObjectMeta {
	return ctx.obj.GetObjectMeta()
}

func (ctx *endpointCtx) RuntimeObject() runtime.Object {
	var v interface{}
	v = ctx.obj
	return v.(runtime.Object)
}

func (ctx *endpointCtx) WorkFunc(context context.Context) error {
	var err error
	evt := ctx.event
	ct := ctx.obj.ctrler
	kind := "Endpoint"
	ct.Lock()
	handler, ok := ct.handlers[kind]
	ct.Unlock()
	if !ok {
		ct.logger.Fatalf("Cant find the handler for %s", kind)
	}
	endpointHandler := handler.(EndpointHandler)
	switch evt {
	case kvstore.Created:
		ctx.obj.Lock()
		err = endpointHandler.OnEndpointCreate(ctx.obj)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctx.obj, err)
			ctx.SetEvent(kvstore.Deleted)
		}
	case kvstore.Updated:
		ct.stats.Counter("Endpoint_Updated_Events").Inc()
		ctx.obj.Lock()
		p := workload.Endpoint{Spec: ctx.newObj.obj.Spec,
			ObjectMeta: ctx.newObj.obj.ObjectMeta,
			TypeMeta:   ctx.newObj.obj.TypeMeta,
			Status:     ctx.newObj.obj.Status}
		err = endpointHandler.OnEndpointUpdate(ctx.obj, &p)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctx.obj, err)
			ctx.SetEvent(kvstore.Deleted)
		}
	case kvstore.Deleted:
		ctx.obj.Lock()
		err = endpointHandler.OnEndpointDelete(ctx.obj)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error deleting %s %+v. Err: %v", kind, ctx.obj, err)
		}
	}
	ct.resolveObject(ctx.event, ctx)
	return nil
}

// handleEndpointEventParallel handles Endpoint events from watcher
func (ct *ctrlerCtx) handleEndpointEventParallel(evt *kvstore.WatchEvent) error {

	if ct.objResolver == nil {
		return ct.handleEndpointEventParallelWithNoResolver(evt)
	}

	switch tp := evt.Object.(type) {
	case *workload.Endpoint:
		eobj := evt.Object.(*workload.Endpoint)
		kind := "Endpoint"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ctx := &endpointCtx{event: evt.Type, obj: &Endpoint{Endpoint: *eobj, ctrler: ct}}

		var err error
		switch evt.Type {
		case kvstore.Created:
			err = ct.processAdd(ctx)
		case kvstore.Updated:
			err = ct.processUpdate(ctx)
		case kvstore.Deleted:
			err = ct.processDelete(ctx)
		}
		return err
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on Endpoint watch channel", tp)
	}

	return nil
}

// handleEndpointEventParallel handles Endpoint events from watcher
func (ct *ctrlerCtx) handleEndpointEventParallelWithNoResolver(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *workload.Endpoint:
		eobj := evt.Object.(*workload.Endpoint)
		kind := "Endpoint"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		endpointHandler := handler.(EndpointHandler)
		// handle based on event type
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			workFunc := func(ctx context.Context, ctrlCtx shardworkers.WorkObj) error {
				var err error
				workCtx := ctrlCtx.(*endpointCtx)
				eobj := workCtx.obj
				fobj, err := ct.getObject(kind, workCtx.GetKey())
				if err != nil {
					ct.addObject(workCtx)
					ct.stats.Counter("Endpoint_Created_Events").Inc()
					eobj.Lock()
					err = endpointHandler.OnEndpointCreate(eobj)
					eobj.Unlock()
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, eobj, err)
						ct.delObject(kind, workCtx.GetKey())
					}
				} else {
					workCtx := fobj.(*endpointCtx)
					obj := workCtx.obj
					ct.stats.Counter("Endpoint_Updated_Events").Inc()
					obj.Lock()
					p := workload.Endpoint{Spec: eobj.Spec,
						ObjectMeta: eobj.ObjectMeta,
						TypeMeta:   eobj.TypeMeta,
						Status:     eobj.Status}

					err = endpointHandler.OnEndpointUpdate(obj, &p)
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					} else {
						workCtx.obj.Endpoint = p
					}
					obj.Unlock()
				}
				return err
			}
			ctrlCtx := &endpointCtx{event: evt.Type, obj: &Endpoint{Endpoint: *eobj, ctrler: ct}}
			ct.runFunction("Endpoint", ctrlCtx, workFunc)
		case kvstore.Deleted:
			workFunc := func(ctx context.Context, ctrlCtx shardworkers.WorkObj) error {
				var err error
				workCtx := ctrlCtx.(*endpointCtx)
				eobj := workCtx.obj
				fobj, err := ct.findObject(kind, workCtx.GetKey())
				if err != nil {
					ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
					return err
				}
				obj := fobj.(*Endpoint)
				ct.stats.Counter("Endpoint_Deleted_Events").Inc()
				obj.Lock()
				err = endpointHandler.OnEndpointDelete(obj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
				}
				ct.delObject(kind, workCtx.GetKey())
				return nil
			}
			ctrlCtx := &endpointCtx{event: evt.Type, obj: &Endpoint{Endpoint: *eobj, ctrler: ct}}
			ct.runFunction("Endpoint", ctrlCtx, workFunc)
		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on Endpoint watch channel", tp)
	}

	return nil
}

// diffEndpoint does a diff of Endpoint objects between local cache and API server
func (ct *ctrlerCtx) diffEndpoint(apicl apiclient.Services) {
	opts := api.ListWatchOptions{}

	// get a list of all objects from API server
	objlist, err := apicl.WorkloadV1().Endpoint().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Errorf("Error getting a list of objects. Err: %v", err)
		return
	}

	ct.logger.Infof("diffEndpoint(): EndpointList returned %d objects", len(objlist))

	// build an object map
	objmap := make(map[string]*workload.Endpoint)
	for _, obj := range objlist {
		objmap[obj.GetKey()] = obj
	}

	list, err := ct.Endpoint().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Infof("Failed to get a list of objects. Err: %s", err)
		return
	}

	// if an object is in our local cache and not in API server, trigger delete for it
	for _, obj := range list {
		_, ok := objmap[obj.GetKey()]
		if !ok {
			ct.logger.Infof("diffEndpoint(): Deleting existing object %#v since its not in apiserver", obj.GetKey())
			evt := kvstore.WatchEvent{
				Type:   kvstore.Deleted,
				Key:    obj.GetKey(),
				Object: &obj.Endpoint,
			}
			ct.handleEndpointEvent(&evt)
		}
	}

	// trigger create event for all others
	for _, obj := range objlist {
		ct.logger.Infof("diffEndpoint(): Adding object %#v", obj.GetKey())
		evt := kvstore.WatchEvent{
			Type:   kvstore.Created,
			Key:    obj.GetKey(),
			Object: obj,
		}
		ct.handleEndpointEvent(&evt)
	}
}

func (ct *ctrlerCtx) runEndpointWatcher() {
	kind := "Endpoint"

	ct.Lock()
	handler, ok := ct.handlers[kind]
	ct.Unlock()
	if !ok {
		ct.logger.Fatalf("Cant find the handler for %s", kind)
	}
	endpointHandler := handler.(EndpointHandler)

	opts := endpointHandler.GetEndpointWatchOptions()

	// if there is no API server to connect to, we are done
	if (ct.resolver == nil) || ct.apisrvURL == "" {
		return
	}

	// create context
	ctx, cancel := context.WithCancel(context.Background())
	ct.Lock()
	ct.watchCancel[kind] = cancel
	ct.Unlock()
	logger := ct.logger.WithContext("submodule", "EndpointWatcher")

	// create a grpc client
	apiclt, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
	if err == nil {
		ct.diffEndpoint(apiclt)
	}

	// setup wait group
	ct.waitGrp.Add(1)

	// start a goroutine
	go func() {
		defer ct.waitGrp.Done()
		ct.stats.Counter("Endpoint_Watch").Inc()
		defer ct.stats.Counter("Endpoint_Watch").Dec()

		// loop forever
		for {
			// create a grpc client
			apicl, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
			if err != nil {
				logger.Warnf("Failed to connect to gRPC server [%s]\n", ct.apisrvURL)
				ct.stats.Counter("Endpoint_ApiClientErr").Inc()
			} else {
				logger.Infof("API client connected {%+v}", apicl)

				// Endpoint object watcher
				wt, werr := apicl.WorkloadV1().Endpoint().Watch(ctx, opts)
				if werr != nil {
					select {
					case <-ctx.Done():
						logger.Infof("watch %s cancelled", kind)
						return
					default:
					}
					logger.Errorf("Failed to start %s watch (%s)\n", kind, werr)
					// wait for a second and retry connecting to api server
					apicl.Close()
					time.Sleep(time.Second)
					continue
				}
				ct.Lock()
				ct.watchers[kind] = wt
				ct.Unlock()

				// perform a diff with API server and local cache
				time.Sleep(time.Millisecond * 100)
				ct.diffEndpoint(apicl)

				// handle api server watch events
			innerLoop:
				for {
					// wait for events
					select {
					case evt, ok := <-wt.EventChan():
						if !ok {
							logger.Error("Error receiving from apisrv watcher")
							ct.stats.Counter("Endpoint_WatchErrors").Inc()
							break innerLoop
						}

						// handle event in parallel
						ct.handleEndpointEventParallel(evt)
					}
				}
				apicl.Close()
			}

			// if stop flag is set, we are done
			if ct.stoped {
				logger.Infof("Exiting API server watcher")
				return
			}

			// wait for a second and retry connecting to api server
			time.Sleep(time.Second)
		}
	}()
}

// WatchEndpoint starts watch on Endpoint object
func (ct *ctrlerCtx) WatchEndpoint(handler EndpointHandler) error {
	kind := "Endpoint"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchers[kind]
	ct.Unlock()
	if ok {
		return fmt.Errorf("Endpoint watcher already exists")
	}

	// save handler
	ct.Lock()
	ct.handlers[kind] = handler
	ct.Unlock()

	// run Endpoint watcher in a go routine
	ct.runEndpointWatcher()

	return nil
}

// StopWatchEndpoint stops watch on Endpoint object
func (ct *ctrlerCtx) StopWatchEndpoint(handler EndpointHandler) error {
	kind := "Endpoint"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchers[kind]
	ct.Unlock()
	if !ok {
		return fmt.Errorf("Endpoint watcher does not exist")
	}

	ct.Lock()
	cancel, _ := ct.watchCancel[kind]
	cancel()
	delete(ct.watchers, kind)
	delete(ct.watchCancel, kind)
	ct.Unlock()

	time.Sleep(100 * time.Millisecond)

	return nil
}

// EndpointAPI returns
type EndpointAPI interface {
	Create(obj *workload.Endpoint) error
	CreateEvent(obj *workload.Endpoint) error
	Update(obj *workload.Endpoint) error
	Delete(obj *workload.Endpoint) error
	Find(meta *api.ObjectMeta) (*Endpoint, error)
	List(ctx context.Context, opts *api.ListWatchOptions) ([]*Endpoint, error)
	Watch(handler EndpointHandler) error
	StopWatch(handler EndpointHandler) error
}

// dummy struct that implements EndpointAPI
type endpointAPI struct {
	ct *ctrlerCtx
}

// Create creates Endpoint object
func (api *endpointAPI) Create(obj *workload.Endpoint) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.WorkloadV1().Endpoint().Create(context.Background(), obj)
		if err != nil && strings.Contains(err.Error(), "AlreadyExists") {
			_, err = apicl.WorkloadV1().Endpoint().Update(context.Background(), obj)
		}
		return err
	}

	api.ct.handleEndpointEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Created})
	return nil
}

// CreateEvent creates Endpoint object and synchronously triggers local event
func (api *endpointAPI) CreateEvent(obj *workload.Endpoint) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.WorkloadV1().Endpoint().Create(context.Background(), obj)
		if err != nil && strings.Contains(err.Error(), "AlreadyExists") {
			_, err = apicl.WorkloadV1().Endpoint().Update(context.Background(), obj)
		}
		if err != nil {
			api.ct.logger.Errorf("Error creating object in api server. Err: %v", err)
			return err
		}
		return err
	}

	api.ct.handleEndpointEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Created})
	return nil
}

// Update triggers update on Endpoint object
func (api *endpointAPI) Update(obj *workload.Endpoint) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.WorkloadV1().Endpoint().Update(context.Background(), obj)
		return err
	}

	api.ct.handleEndpointEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Updated})
	return nil
}

// Delete deletes Endpoint object
func (api *endpointAPI) Delete(obj *workload.Endpoint) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.WorkloadV1().Endpoint().Delete(context.Background(), &obj.ObjectMeta)
		return err
	}

	api.ct.handleEndpointEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Deleted})
	return nil
}

// MakeKey generates a KV store key for the object
func (api *endpointAPI) getFullKey(tenant, name string) string {
	if tenant != "" {
		return fmt.Sprint(globals.ConfigRootPrefix, "/", "workload", "/", "endpoints", "/", tenant, "/", name)
	}
	return fmt.Sprint(globals.ConfigRootPrefix, "/", "workload", "/", "endpoints", "/", name)
}

// Find returns an object by meta
func (api *endpointAPI) Find(meta *api.ObjectMeta) (*Endpoint, error) {
	// find the object
	obj, err := api.ct.FindObject("Endpoint", meta)
	if err != nil {
		return nil, err
	}

	// asset type
	switch obj.(type) {
	case *Endpoint:
		hobj := obj.(*Endpoint)
		return hobj, nil
	default:
		return nil, errors.New("incorrect object type")
	}
}

// List returns a list of all Endpoint objects
func (api *endpointAPI) List(ctx context.Context, opts *api.ListWatchOptions) ([]*Endpoint, error) {
	var objlist []*Endpoint
	objs, err := api.ct.List("Endpoint", ctx, opts)

	if err != nil {
		return nil, err
	}

	for _, obj := range objs {
		switch tp := obj.(type) {
		case *Endpoint:
			eobj := obj.(*Endpoint)
			objlist = append(objlist, eobj)
		default:
			log.Fatalf("Got invalid object type %v while looking for Endpoint", tp)
		}
	}

	return objlist, nil
}

// Watch sets up a event handlers for Endpoint object
func (api *endpointAPI) Watch(handler EndpointHandler) error {
	api.ct.startWorkerPool("Endpoint")
	return api.ct.WatchEndpoint(handler)
}

// StopWatch stop watch for Tenant Endpoint object
func (api *endpointAPI) StopWatch(handler EndpointHandler) error {
	api.ct.Lock()
	api.ct.workPools["Endpoint"].Stop()
	api.ct.Unlock()
	return api.ct.StopWatchEndpoint(handler)
}

// Endpoint returns EndpointAPI
func (ct *ctrlerCtx) Endpoint() EndpointAPI {
	return &endpointAPI{ct: ct}
}

// Workload is a wrapper object that implements additional functionality
type Workload struct {
	sync.Mutex
	workload.Workload
	HandlerCtx interface{} // additional state handlers can store
	ctrler     *ctrlerCtx  // reference back to the controller instance
}

func (obj *Workload) Write() error {
	// if there is no API server to connect to, we are done
	if (obj.ctrler == nil) || (obj.ctrler.resolver == nil) || obj.ctrler.apisrvURL == "" {
		return nil
	}

	apicl, err := obj.ctrler.apiClient()
	if err != nil {
		obj.ctrler.logger.Errorf("Error creating API server clent. Err: %v", err)
		return err
	}

	obj.ctrler.stats.Counter("Workload_Writes").Inc()

	// write to api server
	if obj.ObjectMeta.ResourceVersion != "" {
		// update it
		for i := 0; i < maxApisrvWriteRetry; i++ {
			_, err = apicl.WorkloadV1().Workload().UpdateStatus(context.Background(), &obj.Workload)
			if err == nil {
				break
			}
			time.Sleep(time.Millisecond * 100)
		}
	} else {
		//  create
		_, err = apicl.WorkloadV1().Workload().Create(context.Background(), &obj.Workload)
	}

	return nil
}

// WorkloadHandler is the event handler for Workload object
type WorkloadHandler interface {
	OnWorkloadCreate(obj *Workload) error
	OnWorkloadUpdate(oldObj *Workload, newObj *workload.Workload) error
	OnWorkloadDelete(obj *Workload) error
	GetWorkloadWatchOptions() *api.ListWatchOptions
}

// OnWorkloadCreate is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnWorkloadCreate(obj *Workload) error {
	log.Info("OnWorkloadCreate is not implemented")
	return nil
}

// OnWorkloadUpdate is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnWorkloadUpdate(oldObj *Workload, newObj *workload.Workload) error {
	log.Info("OnWorkloadUpdate is not implemented")
	return nil
}

// OnWorkloadDelete is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnWorkloadDelete(obj *Workload) error {
	log.Info("OnWorkloadDelete is not implemented")
	return nil
}

// GetWorkloadWatchOptions is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) GetWorkloadWatchOptions() *api.ListWatchOptions {
	log.Info("GetWorkloadWatchOptions is not implemented")
	opts := &api.ListWatchOptions{}
	return opts
}

// handleWorkloadEvent handles Workload events from watcher
func (ct *ctrlerCtx) handleWorkloadEvent(evt *kvstore.WatchEvent) error {

	if ct.objResolver == nil {
		return ct.handleWorkloadEventNoResolver(evt)
	}

	switch tp := evt.Object.(type) {
	case *workload.Workload:
		eobj := evt.Object.(*workload.Workload)
		kind := "Workload"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ctx := &workloadCtx{event: evt.Type,
			obj: &Workload{Workload: *eobj, ctrler: ct}}

		var err error
		switch evt.Type {
		case kvstore.Created:
			err = ct.processAdd(ctx)
		case kvstore.Updated:
			err = ct.processUpdate(ctx)
		case kvstore.Deleted:
			err = ct.processDelete(ctx)
		}
		return err
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on Workload watch channel", tp)
	}

	return nil
}

// handleWorkloadEventNoResolver handles Workload events from watcher
func (ct *ctrlerCtx) handleWorkloadEventNoResolver(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *workload.Workload:
		eobj := evt.Object.(*workload.Workload)
		kind := "Workload"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		workloadHandler := handler.(WorkloadHandler)
		// handle based on event type
		ctrlCtx := &workloadCtx{event: evt.Type, obj: &Workload{Workload: *eobj, ctrler: ct}}
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			fobj, err := ct.getObject(kind, ctrlCtx.GetKey())
			if err != nil {
				ct.addObject(ctrlCtx)
				ct.stats.Counter("Workload_Created_Events").Inc()

				// call the event handler
				ctrlCtx.Lock()
				err = workloadHandler.OnWorkloadCreate(ctrlCtx.obj)
				ctrlCtx.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctrlCtx.obj, err)
					ct.delObject(kind, ctrlCtx.GetKey())
					return err
				}
			} else {
				ctrlCtx := fobj.(*workloadCtx)
				ct.stats.Counter("Workload_Updated_Events").Inc()
				ctrlCtx.Lock()
				p := workload.Workload{Spec: eobj.Spec,
					ObjectMeta: eobj.ObjectMeta,
					TypeMeta:   eobj.TypeMeta,
					Status:     eobj.Status}

				err = workloadHandler.OnWorkloadUpdate(ctrlCtx.obj, &p)
				ctrlCtx.obj.Workload = *eobj
				ctrlCtx.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctrlCtx.obj, err)
					return err
				}

			}
		case kvstore.Deleted:
			ctrlCtx := &workloadCtx{event: evt.Type, obj: &Workload{Workload: *eobj, ctrler: ct}}
			fobj, err := ct.findObject(kind, ctrlCtx.GetKey())
			if err != nil {
				ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
				return err
			}

			obj := fobj.(*Workload)
			ct.stats.Counter("Workload_Deleted_Events").Inc()
			obj.Lock()
			err = workloadHandler.OnWorkloadDelete(obj)
			obj.Unlock()
			if err != nil {
				ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
			}
			ct.delObject(kind, ctrlCtx.GetKey())
			return nil

		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on Workload watch channel", tp)
	}

	return nil
}

type workloadCtx struct {
	ctkitBaseCtx
	event kvstore.WatchEventType
	obj   *Workload //
	//   newObj     *workload.Workload //update
	newObj *workloadCtx //update
}

func (ctx *workloadCtx) References() map[string]apiintf.ReferenceObj {
	resp := make(map[string]apiintf.ReferenceObj)
	ctx.obj.References(ctx.obj.GetObjectMeta().Name, ctx.obj.GetObjectMeta().Namespace, resp)
	return resp
}

func (ctx *workloadCtx) GetKey() string {
	return ctx.obj.MakeKey("workload")
}

func (ctx *workloadCtx) GetKind() string {
	return ctx.obj.GetKind()
}

func (ctx *workloadCtx) SetEvent(event kvstore.WatchEventType) {
	ctx.event = event
}

func (ctx *workloadCtx) SetNewObj(newObj apiintf.CtkitObject) {
	if newObj == nil {
		ctx.newObj = nil
	} else {
		ctx.newObj = newObj.(*workloadCtx)
		ctx.newObj.obj.HandlerCtx = ctx.obj.HandlerCtx
	}
}

func (ctx *workloadCtx) GetNewObj() apiintf.CtkitObject {
	return ctx.newObj
}

func (ctx *workloadCtx) Copy(obj apiintf.CtkitObject) {
	ctx.obj.Workload = obj.(*workloadCtx).obj.Workload
}

func (ctx *workloadCtx) Lock() {
	ctx.obj.Lock()
}

func (ctx *workloadCtx) Unlock() {
	ctx.obj.Unlock()
}

func (ctx *workloadCtx) GetObjectMeta() *api.ObjectMeta {
	return ctx.obj.GetObjectMeta()
}

func (ctx *workloadCtx) RuntimeObject() runtime.Object {
	var v interface{}
	v = ctx.obj
	return v.(runtime.Object)
}

func (ctx *workloadCtx) WorkFunc(context context.Context) error {
	var err error
	evt := ctx.event
	ct := ctx.obj.ctrler
	kind := "Workload"
	ct.Lock()
	handler, ok := ct.handlers[kind]
	ct.Unlock()
	if !ok {
		ct.logger.Fatalf("Cant find the handler for %s", kind)
	}
	workloadHandler := handler.(WorkloadHandler)
	switch evt {
	case kvstore.Created:
		ctx.obj.Lock()
		err = workloadHandler.OnWorkloadCreate(ctx.obj)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctx.obj, err)
			ctx.SetEvent(kvstore.Deleted)
		}
	case kvstore.Updated:
		ct.stats.Counter("Workload_Updated_Events").Inc()
		ctx.obj.Lock()
		p := workload.Workload{Spec: ctx.newObj.obj.Spec,
			ObjectMeta: ctx.newObj.obj.ObjectMeta,
			TypeMeta:   ctx.newObj.obj.TypeMeta,
			Status:     ctx.newObj.obj.Status}
		err = workloadHandler.OnWorkloadUpdate(ctx.obj, &p)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctx.obj, err)
			ctx.SetEvent(kvstore.Deleted)
		}
	case kvstore.Deleted:
		ctx.obj.Lock()
		err = workloadHandler.OnWorkloadDelete(ctx.obj)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error deleting %s %+v. Err: %v", kind, ctx.obj, err)
		}
	}
	ct.resolveObject(ctx.event, ctx)
	return nil
}

// handleWorkloadEventParallel handles Workload events from watcher
func (ct *ctrlerCtx) handleWorkloadEventParallel(evt *kvstore.WatchEvent) error {

	if ct.objResolver == nil {
		return ct.handleWorkloadEventParallelWithNoResolver(evt)
	}

	switch tp := evt.Object.(type) {
	case *workload.Workload:
		eobj := evt.Object.(*workload.Workload)
		kind := "Workload"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ctx := &workloadCtx{event: evt.Type, obj: &Workload{Workload: *eobj, ctrler: ct}}

		var err error
		switch evt.Type {
		case kvstore.Created:
			err = ct.processAdd(ctx)
		case kvstore.Updated:
			err = ct.processUpdate(ctx)
		case kvstore.Deleted:
			err = ct.processDelete(ctx)
		}
		return err
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on Workload watch channel", tp)
	}

	return nil
}

// handleWorkloadEventParallel handles Workload events from watcher
func (ct *ctrlerCtx) handleWorkloadEventParallelWithNoResolver(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *workload.Workload:
		eobj := evt.Object.(*workload.Workload)
		kind := "Workload"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		workloadHandler := handler.(WorkloadHandler)
		// handle based on event type
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			workFunc := func(ctx context.Context, ctrlCtx shardworkers.WorkObj) error {
				var err error
				workCtx := ctrlCtx.(*workloadCtx)
				eobj := workCtx.obj
				fobj, err := ct.getObject(kind, workCtx.GetKey())
				if err != nil {
					ct.addObject(workCtx)
					ct.stats.Counter("Workload_Created_Events").Inc()
					eobj.Lock()
					err = workloadHandler.OnWorkloadCreate(eobj)
					eobj.Unlock()
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, eobj, err)
						ct.delObject(kind, workCtx.GetKey())
					}
				} else {
					workCtx := fobj.(*workloadCtx)
					obj := workCtx.obj
					ct.stats.Counter("Workload_Updated_Events").Inc()
					obj.Lock()
					p := workload.Workload{Spec: eobj.Spec,
						ObjectMeta: eobj.ObjectMeta,
						TypeMeta:   eobj.TypeMeta,
						Status:     eobj.Status}

					err = workloadHandler.OnWorkloadUpdate(obj, &p)
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					} else {
						workCtx.obj.Workload = p
					}
					obj.Unlock()
				}
				return err
			}
			ctrlCtx := &workloadCtx{event: evt.Type, obj: &Workload{Workload: *eobj, ctrler: ct}}
			ct.runFunction("Workload", ctrlCtx, workFunc)
		case kvstore.Deleted:
			workFunc := func(ctx context.Context, ctrlCtx shardworkers.WorkObj) error {
				var err error
				workCtx := ctrlCtx.(*workloadCtx)
				eobj := workCtx.obj
				fobj, err := ct.findObject(kind, workCtx.GetKey())
				if err != nil {
					ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
					return err
				}
				obj := fobj.(*Workload)
				ct.stats.Counter("Workload_Deleted_Events").Inc()
				obj.Lock()
				err = workloadHandler.OnWorkloadDelete(obj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
				}
				ct.delObject(kind, workCtx.GetKey())
				return nil
			}
			ctrlCtx := &workloadCtx{event: evt.Type, obj: &Workload{Workload: *eobj, ctrler: ct}}
			ct.runFunction("Workload", ctrlCtx, workFunc)
		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on Workload watch channel", tp)
	}

	return nil
}

// diffWorkload does a diff of Workload objects between local cache and API server
func (ct *ctrlerCtx) diffWorkload(apicl apiclient.Services) {
	opts := api.ListWatchOptions{}

	// get a list of all objects from API server
	objlist, err := apicl.WorkloadV1().Workload().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Errorf("Error getting a list of objects. Err: %v", err)
		return
	}

	ct.logger.Infof("diffWorkload(): WorkloadList returned %d objects", len(objlist))

	// build an object map
	objmap := make(map[string]*workload.Workload)
	for _, obj := range objlist {
		objmap[obj.GetKey()] = obj
	}

	list, err := ct.Workload().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Infof("Failed to get a list of objects. Err: %s", err)
		return
	}

	// if an object is in our local cache and not in API server, trigger delete for it
	for _, obj := range list {
		_, ok := objmap[obj.GetKey()]
		if !ok {
			ct.logger.Infof("diffWorkload(): Deleting existing object %#v since its not in apiserver", obj.GetKey())
			evt := kvstore.WatchEvent{
				Type:   kvstore.Deleted,
				Key:    obj.GetKey(),
				Object: &obj.Workload,
			}
			ct.handleWorkloadEvent(&evt)
		}
	}

	// trigger create event for all others
	for _, obj := range objlist {
		ct.logger.Infof("diffWorkload(): Adding object %#v", obj.GetKey())
		evt := kvstore.WatchEvent{
			Type:   kvstore.Created,
			Key:    obj.GetKey(),
			Object: obj,
		}
		ct.handleWorkloadEvent(&evt)
	}
}

func (ct *ctrlerCtx) runWorkloadWatcher() {
	kind := "Workload"

	ct.Lock()
	handler, ok := ct.handlers[kind]
	ct.Unlock()
	if !ok {
		ct.logger.Fatalf("Cant find the handler for %s", kind)
	}
	workloadHandler := handler.(WorkloadHandler)

	opts := workloadHandler.GetWorkloadWatchOptions()

	// if there is no API server to connect to, we are done
	if (ct.resolver == nil) || ct.apisrvURL == "" {
		return
	}

	// create context
	ctx, cancel := context.WithCancel(context.Background())
	ct.Lock()
	ct.watchCancel[kind] = cancel
	ct.Unlock()
	logger := ct.logger.WithContext("submodule", "WorkloadWatcher")

	// create a grpc client
	apiclt, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
	if err == nil {
		ct.diffWorkload(apiclt)
	}

	// setup wait group
	ct.waitGrp.Add(1)

	// start a goroutine
	go func() {
		defer ct.waitGrp.Done()
		ct.stats.Counter("Workload_Watch").Inc()
		defer ct.stats.Counter("Workload_Watch").Dec()

		// loop forever
		for {
			// create a grpc client
			apicl, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
			if err != nil {
				logger.Warnf("Failed to connect to gRPC server [%s]\n", ct.apisrvURL)
				ct.stats.Counter("Workload_ApiClientErr").Inc()
			} else {
				logger.Infof("API client connected {%+v}", apicl)

				// Workload object watcher
				wt, werr := apicl.WorkloadV1().Workload().Watch(ctx, opts)
				if werr != nil {
					select {
					case <-ctx.Done():
						logger.Infof("watch %s cancelled", kind)
						return
					default:
					}
					logger.Errorf("Failed to start %s watch (%s)\n", kind, werr)
					// wait for a second and retry connecting to api server
					apicl.Close()
					time.Sleep(time.Second)
					continue
				}
				ct.Lock()
				ct.watchers[kind] = wt
				ct.Unlock()

				// perform a diff with API server and local cache
				time.Sleep(time.Millisecond * 100)
				ct.diffWorkload(apicl)

				// handle api server watch events
			innerLoop:
				for {
					// wait for events
					select {
					case evt, ok := <-wt.EventChan():
						if !ok {
							logger.Error("Error receiving from apisrv watcher")
							ct.stats.Counter("Workload_WatchErrors").Inc()
							break innerLoop
						}

						// handle event in parallel
						ct.handleWorkloadEventParallel(evt)
					}
				}
				apicl.Close()
			}

			// if stop flag is set, we are done
			if ct.stoped {
				logger.Infof("Exiting API server watcher")
				return
			}

			// wait for a second and retry connecting to api server
			time.Sleep(time.Second)
		}
	}()
}

// WatchWorkload starts watch on Workload object
func (ct *ctrlerCtx) WatchWorkload(handler WorkloadHandler) error {
	kind := "Workload"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchers[kind]
	ct.Unlock()
	if ok {
		return fmt.Errorf("Workload watcher already exists")
	}

	// save handler
	ct.Lock()
	ct.handlers[kind] = handler
	ct.Unlock()

	// run Workload watcher in a go routine
	ct.runWorkloadWatcher()

	return nil
}

// StopWatchWorkload stops watch on Workload object
func (ct *ctrlerCtx) StopWatchWorkload(handler WorkloadHandler) error {
	kind := "Workload"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchers[kind]
	ct.Unlock()
	if !ok {
		return fmt.Errorf("Workload watcher does not exist")
	}

	ct.Lock()
	cancel, _ := ct.watchCancel[kind]
	cancel()
	delete(ct.watchers, kind)
	delete(ct.watchCancel, kind)
	ct.Unlock()

	time.Sleep(100 * time.Millisecond)

	return nil
}

// WorkloadAPI returns
type WorkloadAPI interface {
	Create(obj *workload.Workload) error
	CreateEvent(obj *workload.Workload) error
	Update(obj *workload.Workload) error
	Delete(obj *workload.Workload) error
	Find(meta *api.ObjectMeta) (*Workload, error)
	List(ctx context.Context, opts *api.ListWatchOptions) ([]*Workload, error)
	Watch(handler WorkloadHandler) error
	StopWatch(handler WorkloadHandler) error
	StartMigration(obj *workload.Workload) (*workload.Workload, error)
	FinishMigration(obj *workload.Workload) (*workload.Workload, error)
	AbortMigration(obj *workload.Workload) (*workload.Workload, error)
}

// dummy struct that implements WorkloadAPI
type workloadAPI struct {
	ct *ctrlerCtx
}

// Create creates Workload object
func (api *workloadAPI) Create(obj *workload.Workload) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.WorkloadV1().Workload().Create(context.Background(), obj)
		if err != nil && strings.Contains(err.Error(), "AlreadyExists") {
			_, err = apicl.WorkloadV1().Workload().Update(context.Background(), obj)
		}
		return err
	}

	api.ct.handleWorkloadEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Created})
	return nil
}

// CreateEvent creates Workload object and synchronously triggers local event
func (api *workloadAPI) CreateEvent(obj *workload.Workload) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.WorkloadV1().Workload().Create(context.Background(), obj)
		if err != nil && strings.Contains(err.Error(), "AlreadyExists") {
			_, err = apicl.WorkloadV1().Workload().Update(context.Background(), obj)
		}
		if err != nil {
			api.ct.logger.Errorf("Error creating object in api server. Err: %v", err)
			return err
		}
		return err
	}

	api.ct.handleWorkloadEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Created})
	return nil
}

// Update triggers update on Workload object
func (api *workloadAPI) Update(obj *workload.Workload) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.WorkloadV1().Workload().Update(context.Background(), obj)
		return err
	}

	api.ct.handleWorkloadEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Updated})
	return nil
}

// Delete deletes Workload object
func (api *workloadAPI) Delete(obj *workload.Workload) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.WorkloadV1().Workload().Delete(context.Background(), &obj.ObjectMeta)
		return err
	}

	api.ct.handleWorkloadEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Deleted})
	return nil
}

// MakeKey generates a KV store key for the object
func (api *workloadAPI) getFullKey(tenant, name string) string {
	if tenant != "" {
		return fmt.Sprint(globals.ConfigRootPrefix, "/", "workload", "/", "workloads", "/", tenant, "/", name)
	}
	return fmt.Sprint(globals.ConfigRootPrefix, "/", "workload", "/", "workloads", "/", name)
}

// Find returns an object by meta
func (api *workloadAPI) Find(meta *api.ObjectMeta) (*Workload, error) {
	// find the object
	obj, err := api.ct.FindObject("Workload", meta)
	if err != nil {
		return nil, err
	}

	// asset type
	switch obj.(type) {
	case *Workload:
		hobj := obj.(*Workload)
		return hobj, nil
	default:
		return nil, errors.New("incorrect object type")
	}
}

// List returns a list of all Workload objects
func (api *workloadAPI) List(ctx context.Context, opts *api.ListWatchOptions) ([]*Workload, error) {
	var objlist []*Workload
	objs, err := api.ct.List("Workload", ctx, opts)

	if err != nil {
		return nil, err
	}

	for _, obj := range objs {
		switch tp := obj.(type) {
		case *Workload:
			eobj := obj.(*Workload)
			objlist = append(objlist, eobj)
		default:
			log.Fatalf("Got invalid object type %v while looking for Workload", tp)
		}
	}

	return objlist, nil
}

// Watch sets up a event handlers for Workload object
func (api *workloadAPI) Watch(handler WorkloadHandler) error {
	api.ct.startWorkerPool("Workload")
	return api.ct.WatchWorkload(handler)
}

// StopWatch stop watch for Tenant Workload object
func (api *workloadAPI) StopWatch(handler WorkloadHandler) error {
	api.ct.Lock()
	api.ct.workPools["Workload"].Stop()
	api.ct.Unlock()
	return api.ct.StopWatchWorkload(handler)
}

// StartMigration is an API action
func (api *workloadAPI) StartMigration(obj *workload.Workload) (*workload.Workload, error) {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return nil, err
		}

		return apicl.WorkloadV1().Workload().StartMigration(context.Background(), obj)
	}
	return nil, fmt.Errorf("Action not implemented for local operation")
}

// FinishMigration is an API action
func (api *workloadAPI) FinishMigration(obj *workload.Workload) (*workload.Workload, error) {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return nil, err
		}

		return apicl.WorkloadV1().Workload().FinishMigration(context.Background(), obj)
	}
	return nil, fmt.Errorf("Action not implemented for local operation")
}

// AbortMigration is an API action
func (api *workloadAPI) AbortMigration(obj *workload.Workload) (*workload.Workload, error) {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return nil, err
		}

		return apicl.WorkloadV1().Workload().AbortMigration(context.Background(), obj)
	}
	return nil, fmt.Errorf("Action not implemented for local operation")
}

// Workload returns WorkloadAPI
func (ct *ctrlerCtx) Workload() WorkloadAPI {
	return &workloadAPI{ct: ct}
}
