// Code generated by protoc-gen-grpc-pensando DO NOT EDIT.

/*
Package ctkit is a auto generated package.
Input file: svc_network.proto
*/
package ctkit

import (
	"context"
	"errors"
	"fmt"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/pensando/sw/api"
	"github.com/pensando/sw/api/generated/apiclient"
	"github.com/pensando/sw/api/generated/network"
	apiintf "github.com/pensando/sw/api/interfaces"
	"github.com/pensando/sw/venice/globals"
	"github.com/pensando/sw/venice/utils/balancer"
	"github.com/pensando/sw/venice/utils/kvstore"
	"github.com/pensando/sw/venice/utils/log"
	"github.com/pensando/sw/venice/utils/rpckit"
	"github.com/pensando/sw/venice/utils/runtime"
	"github.com/pensando/sw/venice/utils/shardworkers"
)

// Network is a wrapper object that implements additional functionality
type Network struct {
	sync.Mutex
	network.Network
	HandlerCtx interface{} // additional state handlers can store
	ctrler     *ctrlerCtx  // reference back to the controller instance
}

func (obj *Network) Write() error {
	// if there is no API server to connect to, we are done
	if (obj.ctrler == nil) || (obj.ctrler.resolver == nil) || obj.ctrler.apisrvURL == "" {
		return nil
	}

	apicl, err := obj.ctrler.apiClient()
	if err != nil {
		obj.ctrler.logger.Errorf("Error creating API server clent. Err: %v", err)
		return err
	}

	obj.ctrler.stats.Counter("Network_Writes").Inc()

	// write to api server
	if obj.ObjectMeta.ResourceVersion != "" {
		// update it
		for i := 0; i < maxApisrvWriteRetry; i++ {
			_, err = apicl.NetworkV1().Network().UpdateStatus(context.Background(), &obj.Network)
			if err == nil {
				break
			}
			time.Sleep(time.Millisecond * 100)
		}
	} else {
		//  create
		_, err = apicl.NetworkV1().Network().Create(context.Background(), &obj.Network)
	}

	return nil
}

// NetworkHandler is the event handler for Network object
type NetworkHandler interface {
	OnNetworkCreate(obj *Network) error
	OnNetworkUpdate(oldObj *Network, newObj *network.Network) error
	OnNetworkDelete(obj *Network) error
	GetNetworkWatchOptions() *api.ListWatchOptions
	OnNetworkReconnect()
}

// OnNetworkCreate is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnNetworkCreate(obj *Network) error {
	log.Info("OnNetworkCreate is not implemented")
	return nil
}

// OnNetworkUpdate is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnNetworkUpdate(oldObj *Network, newObj *network.Network) error {
	log.Info("OnNetworkUpdate is not implemented")
	return nil
}

// OnNetworkDelete is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnNetworkDelete(obj *Network) error {
	log.Info("OnNetworkDelete is not implemented")
	return nil
}

// GetNetworkWatchOptions is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) GetNetworkWatchOptions() *api.ListWatchOptions {
	log.Info("GetNetworkWatchOptions is not implemented")
	opts := &api.ListWatchOptions{}
	return opts
}

// OnNetworkReconnect is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnNetworkReconnect() {
	log.Info("OnNetworkReconnect is not implemented")
	return
}

// handleNetworkEvent handles Network events from watcher
func (ct *ctrlerCtx) handleNetworkEvent(evt *kvstore.WatchEvent) error {

	if ct.objResolver == nil {
		return ct.handleNetworkEventNoResolver(evt)
	}

	switch tp := evt.Object.(type) {
	case *network.Network:
		eobj := evt.Object.(*network.Network)
		kind := "Network"

		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ctx := &networkCtx{event: evt.Type,
			obj: &Network{Network: *eobj, ctrler: ct}}

		var err error
		switch evt.Type {
		case kvstore.Created:
			err = ct.processAdd(ctx)
		case kvstore.Updated:
			err = ct.processUpdate(ctx)
		case kvstore.Deleted:
			err = ct.processDelete(ctx)
		}
		return err
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on Network watch channel", tp)
	}

	return nil
}

// handleNetworkEventNoResolver handles Network events from watcher
func (ct *ctrlerCtx) handleNetworkEventNoResolver(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *network.Network:
		eobj := evt.Object.(*network.Network)
		kind := "Network"

		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		networkHandler := handler.(NetworkHandler)
		// handle based on event type
		ctrlCtx := &networkCtx{event: evt.Type, obj: &Network{Network: *eobj, ctrler: ct}}
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			fobj, err := ct.getObject(kind, ctrlCtx.GetKey())
			if err != nil {
				ct.addObject(ctrlCtx)
				ct.stats.Counter("Network_Created_Events").Inc()

				// call the event handler
				ctrlCtx.Lock()
				err = networkHandler.OnNetworkCreate(ctrlCtx.obj)
				ctrlCtx.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctrlCtx.obj, err)
					ct.delObject(kind, ctrlCtx.GetKey())
					return err
				}
			} else {
				fResVer, fErr := strconv.ParseInt(fobj.GetResourceVersion(), 10, 64)
				eResVer, eErr := strconv.ParseInt(eobj.GetResourceVersion(), 10, 64)
				if ct.resolver != nil && fErr == nil && eErr == nil && fResVer >= eResVer {
					// Event already processed.
					ct.logger.Infof("Skipping update due to old resource version")
					return nil
				}
				ctrlCtx := fobj.(*networkCtx)
				ct.stats.Counter("Network_Updated_Events").Inc()
				ctrlCtx.Lock()
				p := network.Network{Spec: eobj.Spec,
					ObjectMeta: eobj.ObjectMeta,
					TypeMeta:   eobj.TypeMeta,
					Status:     eobj.Status}

				err = networkHandler.OnNetworkUpdate(ctrlCtx.obj, &p)
				ctrlCtx.obj.Network = *eobj
				ctrlCtx.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctrlCtx.obj, err)
					return err
				}

			}
		case kvstore.Deleted:
			ctrlCtx := &networkCtx{event: evt.Type, obj: &Network{Network: *eobj, ctrler: ct}}
			fobj, err := ct.findObject(kind, ctrlCtx.GetKey())
			if err != nil {
				ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
				return err
			}

			obj := fobj.(*Network)
			ct.stats.Counter("Network_Deleted_Events").Inc()
			obj.Lock()
			err = networkHandler.OnNetworkDelete(obj)
			obj.Unlock()
			if err != nil {
				ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
			}
			ct.delObject(kind, ctrlCtx.GetKey())
			return nil

		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on Network watch channel", tp)
	}

	return nil
}

type networkCtx struct {
	ctkitBaseCtx
	event kvstore.WatchEventType
	obj   *Network //
	//   newObj     *network.Network //update
	newObj *networkCtx //update
}

func (ctx *networkCtx) References() map[string]apiintf.ReferenceObj {
	resp := make(map[string]apiintf.ReferenceObj)
	ctx.obj.References(ctx.obj.GetObjectMeta().Name, ctx.obj.GetObjectMeta().Namespace, resp)
	return resp
}

func (ctx *networkCtx) GetKey() string {
	return ctx.obj.MakeKey("network")
}

func (ctx *networkCtx) GetKind() string {
	return ctx.obj.GetKind()
}

func (ctx *networkCtx) GetResourceVersion() string {
	return ctx.obj.GetResourceVersion()
}

func (ctx *networkCtx) SetEvent(event kvstore.WatchEventType) {
	ctx.event = event
}

func (ctx *networkCtx) SetNewObj(newObj apiintf.CtkitObject) {
	if newObj == nil {
		ctx.newObj = nil
	} else {
		ctx.newObj = newObj.(*networkCtx)
		ctx.newObj.obj.HandlerCtx = ctx.obj.HandlerCtx
	}
}

func (ctx *networkCtx) GetNewObj() apiintf.CtkitObject {
	return ctx.newObj
}

func (ctx *networkCtx) Copy(obj apiintf.CtkitObject) {
	ctx.obj.Network = obj.(*networkCtx).obj.Network
}

func (ctx *networkCtx) Lock() {
	ctx.obj.Lock()
}

func (ctx *networkCtx) Unlock() {
	ctx.obj.Unlock()
}

func (ctx *networkCtx) GetObjectMeta() *api.ObjectMeta {
	return ctx.obj.GetObjectMeta()
}

func (ctx *networkCtx) RuntimeObject() runtime.Object {
	var v interface{}
	v = ctx.obj
	return v.(runtime.Object)
}

func (ctx *networkCtx) WorkFunc(context context.Context) error {
	var err error
	evt := ctx.event
	ct := ctx.obj.ctrler
	kind := "Network"
	ct.Lock()
	handler, ok := ct.handlers[kind]
	ct.Unlock()
	if !ok {
		ct.logger.Fatalf("Cant find the handler for %s", kind)
	}
	networkHandler := handler.(NetworkHandler)
	switch evt {
	case kvstore.Created:
		ctx.obj.Lock()
		err = networkHandler.OnNetworkCreate(ctx.obj)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctx.obj, err)
			ctx.SetEvent(kvstore.Deleted)
		}
	case kvstore.Updated:
		ct.stats.Counter("Network_Updated_Events").Inc()
		ctx.obj.Lock()
		p := network.Network{Spec: ctx.newObj.obj.Spec,
			ObjectMeta: ctx.newObj.obj.ObjectMeta,
			TypeMeta:   ctx.newObj.obj.TypeMeta,
			Status:     ctx.newObj.obj.Status}
		err = networkHandler.OnNetworkUpdate(ctx.obj, &p)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctx.obj, err)
			ctx.SetEvent(kvstore.Deleted)
		}
	case kvstore.Deleted:
		ctx.obj.Lock()
		err = networkHandler.OnNetworkDelete(ctx.obj)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error deleting %s %+v. Err: %v", kind, ctx.obj, err)
		}
	}
	ct.resolveObject(ctx.event, ctx)
	return nil
}

// handleNetworkEventParallel handles Network events from watcher
func (ct *ctrlerCtx) handleNetworkEventParallel(evt *kvstore.WatchEvent) error {

	if ct.objResolver == nil {
		return ct.handleNetworkEventParallelWithNoResolver(evt)
	}

	switch tp := evt.Object.(type) {
	case *network.Network:
		eobj := evt.Object.(*network.Network)
		kind := "Network"

		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ctx := &networkCtx{event: evt.Type, obj: &Network{Network: *eobj, ctrler: ct}}

		var err error
		switch evt.Type {
		case kvstore.Created:
			err = ct.processAdd(ctx)
		case kvstore.Updated:
			err = ct.processUpdate(ctx)
		case kvstore.Deleted:
			err = ct.processDelete(ctx)
		}
		return err
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on Network watch channel", tp)
	}

	return nil
}

// handleNetworkEventParallel handles Network events from watcher
func (ct *ctrlerCtx) handleNetworkEventParallelWithNoResolver(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *network.Network:
		eobj := evt.Object.(*network.Network)
		kind := "Network"

		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		networkHandler := handler.(NetworkHandler)
		// handle based on event type
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			workFunc := func(ctx context.Context, ctrlCtx shardworkers.WorkObj) error {
				var err error
				workCtx := ctrlCtx.(*networkCtx)
				eobj := workCtx.obj
				fobj, err := ct.getObject(kind, workCtx.GetKey())
				if err != nil {
					ct.addObject(workCtx)
					ct.stats.Counter("Network_Created_Events").Inc()
					eobj.Lock()
					err = networkHandler.OnNetworkCreate(eobj)
					eobj.Unlock()
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, eobj, err)
						ct.delObject(kind, workCtx.GetKey())
					}
				} else {
					workCtx := fobj.(*networkCtx)
					obj := workCtx.obj
					ct.stats.Counter("Network_Updated_Events").Inc()
					obj.Lock()
					p := network.Network{Spec: eobj.Spec,
						ObjectMeta: eobj.ObjectMeta,
						TypeMeta:   eobj.TypeMeta,
						Status:     eobj.Status}

					err = networkHandler.OnNetworkUpdate(obj, &p)
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					} else {
						workCtx.obj.Network = p
					}
					obj.Unlock()
				}
				return err
			}
			ctrlCtx := &networkCtx{event: evt.Type, obj: &Network{Network: *eobj, ctrler: ct}}
			ct.runFunction("Network", ctrlCtx, workFunc)
		case kvstore.Deleted:
			workFunc := func(ctx context.Context, ctrlCtx shardworkers.WorkObj) error {
				var err error
				workCtx := ctrlCtx.(*networkCtx)
				eobj := workCtx.obj
				fobj, err := ct.findObject(kind, workCtx.GetKey())
				if err != nil {
					ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
					return err
				}
				obj := fobj.(*Network)
				ct.stats.Counter("Network_Deleted_Events").Inc()
				obj.Lock()
				err = networkHandler.OnNetworkDelete(obj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
				}
				ct.delObject(kind, workCtx.GetKey())
				return nil
			}
			ctrlCtx := &networkCtx{event: evt.Type, obj: &Network{Network: *eobj, ctrler: ct}}
			ct.runFunction("Network", ctrlCtx, workFunc)
		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on Network watch channel", tp)
	}

	return nil
}

// diffNetwork does a diff of Network objects between local cache and API server
func (ct *ctrlerCtx) diffNetwork(apicl apiclient.Services) {
	opts := api.ListWatchOptions{}

	// get a list of all objects from API server
	objlist, err := apicl.NetworkV1().Network().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Errorf("Error getting a list of objects. Err: %v", err)
		return
	}

	ct.logger.Infof("diffNetwork(): NetworkList returned %d objects", len(objlist))

	// build an object map
	objmap := make(map[string]*network.Network)
	for _, obj := range objlist {
		objmap[obj.GetKey()] = obj
	}

	list, err := ct.Network().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Infof("Failed to get a list of objects. Err: %s", err)
		return
	}

	// if an object is in our local cache and not in API server, trigger delete for it
	for _, obj := range list {
		_, ok := objmap[obj.GetKey()]
		if !ok {
			ct.logger.Infof("diffNetwork(): Deleting existing object %#v since its not in apiserver", obj.GetKey())
			evt := kvstore.WatchEvent{
				Type:   kvstore.Deleted,
				Key:    obj.GetKey(),
				Object: &obj.Network,
			}
			ct.handleNetworkEvent(&evt)
		}
	}

	// trigger create event for all others
	for _, obj := range objlist {
		ct.logger.Infof("diffNetwork(): Adding object %#v", obj.GetKey())
		evt := kvstore.WatchEvent{
			Type:   kvstore.Created,
			Key:    obj.GetKey(),
			Object: obj,
		}
		ct.handleNetworkEvent(&evt)
	}
}

func (ct *ctrlerCtx) runNetworkWatcher() {
	kind := "Network"

	ct.Lock()
	handler, ok := ct.handlers[kind]
	ct.Unlock()
	if !ok {
		ct.logger.Fatalf("Cant find the handler for %s", kind)
	}
	networkHandler := handler.(NetworkHandler)

	opts := networkHandler.GetNetworkWatchOptions()

	// if there is no API server to connect to, we are done
	if (ct.resolver == nil) || ct.apisrvURL == "" {
		return
	}

	// create context
	ctx, cancel := context.WithCancel(context.Background())
	ct.Lock()
	ct.watchCancel[kind] = cancel
	ct.Unlock()
	logger := ct.logger.WithContext("submodule", "NetworkWatcher")
	for {
		if ctx.Err() != nil {
			return
		}

		apiclt, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
		// create a grpc client
		if err == nil {
			// Upon successful connection perform the diff, and start watch goroutine
			ct.diffNetwork(apiclt)
			break
		}

		logger.Warnf("Failed to connect to gRPC server [%s]\n", ct.apisrvURL)
		time.Sleep(time.Second)
	}

	// setup wait group
	ct.waitGrp.Add(1)

	// start a goroutine
	go func() {
		defer ct.waitGrp.Done()
		ct.stats.Counter("Network_Watch").Inc()
		defer ct.stats.Counter("Network_Watch").Dec()

		// loop forever
		for {
			// create a grpc client
			apicl, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
			if err != nil {
				logger.Warnf("Failed to connect to gRPC server [%s]\n", ct.apisrvURL)
				ct.stats.Counter("Network_ApiClientErr").Inc()
			} else {
				logger.Infof("API client connected {%+v}", apicl)

				// Network object watcher
				wt, werr := apicl.NetworkV1().Network().Watch(ctx, opts)
				if werr != nil {
					select {
					case <-ctx.Done():
						logger.Infof("watch %s cancelled", kind)
						return
					default:
					}
					logger.Errorf("Failed to start %s watch (%s)\n", kind, werr)
					// wait for a second and retry connecting to api server
					apicl.Close()
					time.Sleep(time.Second)
					continue
				}
				ct.Lock()
				ct.watchers[kind] = wt
				ct.Unlock()

				// perform a diff with API server and local cache
				time.Sleep(time.Millisecond * 100)
				ct.diffNetwork(apicl)
				networkHandler.OnNetworkReconnect()

				// handle api server watch events
			innerLoop:
				for {
					// wait for events
					select {
					case evt, ok := <-wt.EventChan():
						if !ok {
							logger.Error("Error receiving from apisrv watcher")
							ct.stats.Counter("Network_WatchErrors").Inc()
							break innerLoop
						}

						// handle event in parallel
						ct.handleNetworkEventParallel(evt)
					}
				}
				apicl.Close()
			}

			// if stop flag is set, we are done
			if ct.stoped {
				logger.Infof("Exiting API server watcher")
				return
			}

			// wait for a second and retry connecting to api server
			time.Sleep(time.Second)
		}
	}()
}

// WatchNetwork starts watch on Network object
func (ct *ctrlerCtx) WatchNetwork(handler NetworkHandler) error {
	kind := "Network"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchers[kind]
	ct.Unlock()
	if ok {
		return fmt.Errorf("Network watcher already exists")
	}

	// save handler
	ct.Lock()
	ct.handlers[kind] = handler
	ct.Unlock()

	// run Network watcher in a go routine
	ct.runNetworkWatcher()

	return nil
}

// StopWatchNetwork stops watch on Network object
func (ct *ctrlerCtx) StopWatchNetwork(handler NetworkHandler) error {
	kind := "Network"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchers[kind]
	ct.Unlock()
	if !ok {
		return fmt.Errorf("Network watcher does not exist")
	}

	ct.Lock()
	cancel, _ := ct.watchCancel[kind]
	cancel()
	delete(ct.watchers, kind)
	delete(ct.watchCancel, kind)
	ct.Unlock()

	time.Sleep(100 * time.Millisecond)

	return nil
}

// NetworkAPI returns
type NetworkAPI interface {
	Create(obj *network.Network) error
	SyncCreate(obj *network.Network) error
	Update(obj *network.Network) error
	SyncUpdate(obj *network.Network) error
	Delete(obj *network.Network) error
	Find(meta *api.ObjectMeta) (*Network, error)
	List(ctx context.Context, opts *api.ListWatchOptions) ([]*Network, error)
	Watch(handler NetworkHandler) error
	StopWatch(handler NetworkHandler) error
}

// dummy struct that implements NetworkAPI
type networkAPI struct {
	ct *ctrlerCtx
}

// Create creates Network object
func (api *networkAPI) Create(obj *network.Network) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.NetworkV1().Network().Create(context.Background(), obj)
		if err != nil && strings.Contains(err.Error(), "AlreadyExists") {
			_, err = apicl.NetworkV1().Network().Update(context.Background(), obj)

		}
		return err
	}

	api.ct.handleNetworkEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Created})
	return nil
}

// SyncCreate creates Network object and updates the cache
func (api *networkAPI) SyncCreate(obj *network.Network) error {
	newObj := obj
	evtType := kvstore.Created
	var writeErr error
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		newObj, writeErr = apicl.NetworkV1().Network().Create(context.Background(), obj)
		if writeErr != nil && strings.Contains(writeErr.Error(), "AlreadyExists") {
			newObj, writeErr = apicl.NetworkV1().Network().Update(context.Background(), obj)
			evtType = kvstore.Updated
		}
	}

	if writeErr == nil {
		api.ct.handleNetworkEvent(&kvstore.WatchEvent{Object: newObj, Type: evtType})
	}
	return writeErr
}

// Update triggers update on Network object
func (api *networkAPI) Update(obj *network.Network) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.NetworkV1().Network().Update(context.Background(), obj)
		return err
	}

	api.ct.handleNetworkEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Updated})
	return nil
}

// SyncUpdate triggers update on Network object and updates the cache
func (api *networkAPI) SyncUpdate(obj *network.Network) error {
	newObj := obj
	var writeErr error
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		newObj, writeErr = apicl.NetworkV1().Network().Update(context.Background(), obj)
	}

	if writeErr == nil {
		api.ct.handleNetworkEvent(&kvstore.WatchEvent{Object: newObj, Type: kvstore.Updated})
	}

	return writeErr
}

// Delete deletes Network object
func (api *networkAPI) Delete(obj *network.Network) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.NetworkV1().Network().Delete(context.Background(), &obj.ObjectMeta)
		return err
	}

	api.ct.handleNetworkEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Deleted})
	return nil
}

// MakeKey generates a KV store key for the object
func (api *networkAPI) getFullKey(tenant, name string) string {
	if tenant != "" {
		return fmt.Sprint(globals.ConfigRootPrefix, "/", "network", "/", "networks", "/", tenant, "/", name)
	}
	return fmt.Sprint(globals.ConfigRootPrefix, "/", "network", "/", "networks", "/", name)
}

// Find returns an object by meta
func (api *networkAPI) Find(meta *api.ObjectMeta) (*Network, error) {
	// find the object
	obj, err := api.ct.FindObject("Network", meta)
	if err != nil {
		return nil, err
	}

	// asset type
	switch obj.(type) {
	case *Network:
		hobj := obj.(*Network)
		return hobj, nil
	default:
		return nil, errors.New("incorrect object type")
	}
}

// List returns a list of all Network objects
func (api *networkAPI) List(ctx context.Context, opts *api.ListWatchOptions) ([]*Network, error) {
	var objlist []*Network
	objs, err := api.ct.List("Network", ctx, opts)

	if err != nil {
		return nil, err
	}

	for _, obj := range objs {
		switch tp := obj.(type) {
		case *Network:
			eobj := obj.(*Network)
			objlist = append(objlist, eobj)
		default:
			log.Fatalf("Got invalid object type %v while looking for Network", tp)
		}
	}

	return objlist, nil
}

// Watch sets up a event handlers for Network object
func (api *networkAPI) Watch(handler NetworkHandler) error {
	api.ct.startWorkerPool("Network")
	return api.ct.WatchNetwork(handler)
}

// StopWatch stop watch for Tenant Network object
func (api *networkAPI) StopWatch(handler NetworkHandler) error {
	api.ct.Lock()
	api.ct.workPools["Network"].Stop()
	api.ct.Unlock()
	return api.ct.StopWatchNetwork(handler)
}

// Network returns NetworkAPI
func (ct *ctrlerCtx) Network() NetworkAPI {
	kind := "Network"
	if _, ok := ct.apiInfMap[kind]; !ok {
		s := &networkAPI{ct: ct}
		ct.apiInfMap[kind] = s
	}
	return ct.apiInfMap[kind].(*networkAPI)
}

// Service is a wrapper object that implements additional functionality
type Service struct {
	sync.Mutex
	network.Service
	HandlerCtx interface{} // additional state handlers can store
	ctrler     *ctrlerCtx  // reference back to the controller instance
}

func (obj *Service) Write() error {
	// if there is no API server to connect to, we are done
	if (obj.ctrler == nil) || (obj.ctrler.resolver == nil) || obj.ctrler.apisrvURL == "" {
		return nil
	}

	apicl, err := obj.ctrler.apiClient()
	if err != nil {
		obj.ctrler.logger.Errorf("Error creating API server clent. Err: %v", err)
		return err
	}

	obj.ctrler.stats.Counter("Service_Writes").Inc()

	// write to api server
	if obj.ObjectMeta.ResourceVersion != "" {
		// update it
		for i := 0; i < maxApisrvWriteRetry; i++ {
			_, err = apicl.NetworkV1().Service().UpdateStatus(context.Background(), &obj.Service)
			if err == nil {
				break
			}
			time.Sleep(time.Millisecond * 100)
		}
	} else {
		//  create
		_, err = apicl.NetworkV1().Service().Create(context.Background(), &obj.Service)
	}

	return nil
}

// ServiceHandler is the event handler for Service object
type ServiceHandler interface {
	OnServiceCreate(obj *Service) error
	OnServiceUpdate(oldObj *Service, newObj *network.Service) error
	OnServiceDelete(obj *Service) error
	GetServiceWatchOptions() *api.ListWatchOptions
	OnServiceReconnect()
}

// OnServiceCreate is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnServiceCreate(obj *Service) error {
	log.Info("OnServiceCreate is not implemented")
	return nil
}

// OnServiceUpdate is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnServiceUpdate(oldObj *Service, newObj *network.Service) error {
	log.Info("OnServiceUpdate is not implemented")
	return nil
}

// OnServiceDelete is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnServiceDelete(obj *Service) error {
	log.Info("OnServiceDelete is not implemented")
	return nil
}

// GetServiceWatchOptions is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) GetServiceWatchOptions() *api.ListWatchOptions {
	log.Info("GetServiceWatchOptions is not implemented")
	opts := &api.ListWatchOptions{}
	return opts
}

// OnServiceReconnect is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnServiceReconnect() {
	log.Info("OnServiceReconnect is not implemented")
	return
}

// handleServiceEvent handles Service events from watcher
func (ct *ctrlerCtx) handleServiceEvent(evt *kvstore.WatchEvent) error {

	if ct.objResolver == nil {
		return ct.handleServiceEventNoResolver(evt)
	}

	switch tp := evt.Object.(type) {
	case *network.Service:
		eobj := evt.Object.(*network.Service)
		kind := "Service"

		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ctx := &serviceCtx{event: evt.Type,
			obj: &Service{Service: *eobj, ctrler: ct}}

		var err error
		switch evt.Type {
		case kvstore.Created:
			err = ct.processAdd(ctx)
		case kvstore.Updated:
			err = ct.processUpdate(ctx)
		case kvstore.Deleted:
			err = ct.processDelete(ctx)
		}
		return err
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on Service watch channel", tp)
	}

	return nil
}

// handleServiceEventNoResolver handles Service events from watcher
func (ct *ctrlerCtx) handleServiceEventNoResolver(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *network.Service:
		eobj := evt.Object.(*network.Service)
		kind := "Service"

		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		serviceHandler := handler.(ServiceHandler)
		// handle based on event type
		ctrlCtx := &serviceCtx{event: evt.Type, obj: &Service{Service: *eobj, ctrler: ct}}
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			fobj, err := ct.getObject(kind, ctrlCtx.GetKey())
			if err != nil {
				ct.addObject(ctrlCtx)
				ct.stats.Counter("Service_Created_Events").Inc()

				// call the event handler
				ctrlCtx.Lock()
				err = serviceHandler.OnServiceCreate(ctrlCtx.obj)
				ctrlCtx.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctrlCtx.obj, err)
					ct.delObject(kind, ctrlCtx.GetKey())
					return err
				}
			} else {
				fResVer, fErr := strconv.ParseInt(fobj.GetResourceVersion(), 10, 64)
				eResVer, eErr := strconv.ParseInt(eobj.GetResourceVersion(), 10, 64)
				if ct.resolver != nil && fErr == nil && eErr == nil && fResVer >= eResVer {
					// Event already processed.
					ct.logger.Infof("Skipping update due to old resource version")
					return nil
				}
				ctrlCtx := fobj.(*serviceCtx)
				ct.stats.Counter("Service_Updated_Events").Inc()
				ctrlCtx.Lock()
				p := network.Service{Spec: eobj.Spec,
					ObjectMeta: eobj.ObjectMeta,
					TypeMeta:   eobj.TypeMeta,
					Status:     eobj.Status}

				err = serviceHandler.OnServiceUpdate(ctrlCtx.obj, &p)
				ctrlCtx.obj.Service = *eobj
				ctrlCtx.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctrlCtx.obj, err)
					return err
				}

			}
		case kvstore.Deleted:
			ctrlCtx := &serviceCtx{event: evt.Type, obj: &Service{Service: *eobj, ctrler: ct}}
			fobj, err := ct.findObject(kind, ctrlCtx.GetKey())
			if err != nil {
				ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
				return err
			}

			obj := fobj.(*Service)
			ct.stats.Counter("Service_Deleted_Events").Inc()
			obj.Lock()
			err = serviceHandler.OnServiceDelete(obj)
			obj.Unlock()
			if err != nil {
				ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
			}
			ct.delObject(kind, ctrlCtx.GetKey())
			return nil

		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on Service watch channel", tp)
	}

	return nil
}

type serviceCtx struct {
	ctkitBaseCtx
	event kvstore.WatchEventType
	obj   *Service //
	//   newObj     *network.Service //update
	newObj *serviceCtx //update
}

func (ctx *serviceCtx) References() map[string]apiintf.ReferenceObj {
	resp := make(map[string]apiintf.ReferenceObj)
	ctx.obj.References(ctx.obj.GetObjectMeta().Name, ctx.obj.GetObjectMeta().Namespace, resp)
	return resp
}

func (ctx *serviceCtx) GetKey() string {
	return ctx.obj.MakeKey("network")
}

func (ctx *serviceCtx) GetKind() string {
	return ctx.obj.GetKind()
}

func (ctx *serviceCtx) GetResourceVersion() string {
	return ctx.obj.GetResourceVersion()
}

func (ctx *serviceCtx) SetEvent(event kvstore.WatchEventType) {
	ctx.event = event
}

func (ctx *serviceCtx) SetNewObj(newObj apiintf.CtkitObject) {
	if newObj == nil {
		ctx.newObj = nil
	} else {
		ctx.newObj = newObj.(*serviceCtx)
		ctx.newObj.obj.HandlerCtx = ctx.obj.HandlerCtx
	}
}

func (ctx *serviceCtx) GetNewObj() apiintf.CtkitObject {
	return ctx.newObj
}

func (ctx *serviceCtx) Copy(obj apiintf.CtkitObject) {
	ctx.obj.Service = obj.(*serviceCtx).obj.Service
}

func (ctx *serviceCtx) Lock() {
	ctx.obj.Lock()
}

func (ctx *serviceCtx) Unlock() {
	ctx.obj.Unlock()
}

func (ctx *serviceCtx) GetObjectMeta() *api.ObjectMeta {
	return ctx.obj.GetObjectMeta()
}

func (ctx *serviceCtx) RuntimeObject() runtime.Object {
	var v interface{}
	v = ctx.obj
	return v.(runtime.Object)
}

func (ctx *serviceCtx) WorkFunc(context context.Context) error {
	var err error
	evt := ctx.event
	ct := ctx.obj.ctrler
	kind := "Service"
	ct.Lock()
	handler, ok := ct.handlers[kind]
	ct.Unlock()
	if !ok {
		ct.logger.Fatalf("Cant find the handler for %s", kind)
	}
	serviceHandler := handler.(ServiceHandler)
	switch evt {
	case kvstore.Created:
		ctx.obj.Lock()
		err = serviceHandler.OnServiceCreate(ctx.obj)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctx.obj, err)
			ctx.SetEvent(kvstore.Deleted)
		}
	case kvstore.Updated:
		ct.stats.Counter("Service_Updated_Events").Inc()
		ctx.obj.Lock()
		p := network.Service{Spec: ctx.newObj.obj.Spec,
			ObjectMeta: ctx.newObj.obj.ObjectMeta,
			TypeMeta:   ctx.newObj.obj.TypeMeta,
			Status:     ctx.newObj.obj.Status}
		err = serviceHandler.OnServiceUpdate(ctx.obj, &p)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctx.obj, err)
			ctx.SetEvent(kvstore.Deleted)
		}
	case kvstore.Deleted:
		ctx.obj.Lock()
		err = serviceHandler.OnServiceDelete(ctx.obj)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error deleting %s %+v. Err: %v", kind, ctx.obj, err)
		}
	}
	ct.resolveObject(ctx.event, ctx)
	return nil
}

// handleServiceEventParallel handles Service events from watcher
func (ct *ctrlerCtx) handleServiceEventParallel(evt *kvstore.WatchEvent) error {

	if ct.objResolver == nil {
		return ct.handleServiceEventParallelWithNoResolver(evt)
	}

	switch tp := evt.Object.(type) {
	case *network.Service:
		eobj := evt.Object.(*network.Service)
		kind := "Service"

		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ctx := &serviceCtx{event: evt.Type, obj: &Service{Service: *eobj, ctrler: ct}}

		var err error
		switch evt.Type {
		case kvstore.Created:
			err = ct.processAdd(ctx)
		case kvstore.Updated:
			err = ct.processUpdate(ctx)
		case kvstore.Deleted:
			err = ct.processDelete(ctx)
		}
		return err
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on Service watch channel", tp)
	}

	return nil
}

// handleServiceEventParallel handles Service events from watcher
func (ct *ctrlerCtx) handleServiceEventParallelWithNoResolver(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *network.Service:
		eobj := evt.Object.(*network.Service)
		kind := "Service"

		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		serviceHandler := handler.(ServiceHandler)
		// handle based on event type
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			workFunc := func(ctx context.Context, ctrlCtx shardworkers.WorkObj) error {
				var err error
				workCtx := ctrlCtx.(*serviceCtx)
				eobj := workCtx.obj
				fobj, err := ct.getObject(kind, workCtx.GetKey())
				if err != nil {
					ct.addObject(workCtx)
					ct.stats.Counter("Service_Created_Events").Inc()
					eobj.Lock()
					err = serviceHandler.OnServiceCreate(eobj)
					eobj.Unlock()
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, eobj, err)
						ct.delObject(kind, workCtx.GetKey())
					}
				} else {
					workCtx := fobj.(*serviceCtx)
					obj := workCtx.obj
					ct.stats.Counter("Service_Updated_Events").Inc()
					obj.Lock()
					p := network.Service{Spec: eobj.Spec,
						ObjectMeta: eobj.ObjectMeta,
						TypeMeta:   eobj.TypeMeta,
						Status:     eobj.Status}

					err = serviceHandler.OnServiceUpdate(obj, &p)
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					} else {
						workCtx.obj.Service = p
					}
					obj.Unlock()
				}
				return err
			}
			ctrlCtx := &serviceCtx{event: evt.Type, obj: &Service{Service: *eobj, ctrler: ct}}
			ct.runFunction("Service", ctrlCtx, workFunc)
		case kvstore.Deleted:
			workFunc := func(ctx context.Context, ctrlCtx shardworkers.WorkObj) error {
				var err error
				workCtx := ctrlCtx.(*serviceCtx)
				eobj := workCtx.obj
				fobj, err := ct.findObject(kind, workCtx.GetKey())
				if err != nil {
					ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
					return err
				}
				obj := fobj.(*Service)
				ct.stats.Counter("Service_Deleted_Events").Inc()
				obj.Lock()
				err = serviceHandler.OnServiceDelete(obj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
				}
				ct.delObject(kind, workCtx.GetKey())
				return nil
			}
			ctrlCtx := &serviceCtx{event: evt.Type, obj: &Service{Service: *eobj, ctrler: ct}}
			ct.runFunction("Service", ctrlCtx, workFunc)
		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on Service watch channel", tp)
	}

	return nil
}

// diffService does a diff of Service objects between local cache and API server
func (ct *ctrlerCtx) diffService(apicl apiclient.Services) {
	opts := api.ListWatchOptions{}

	// get a list of all objects from API server
	objlist, err := apicl.NetworkV1().Service().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Errorf("Error getting a list of objects. Err: %v", err)
		return
	}

	ct.logger.Infof("diffService(): ServiceList returned %d objects", len(objlist))

	// build an object map
	objmap := make(map[string]*network.Service)
	for _, obj := range objlist {
		objmap[obj.GetKey()] = obj
	}

	list, err := ct.Service().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Infof("Failed to get a list of objects. Err: %s", err)
		return
	}

	// if an object is in our local cache and not in API server, trigger delete for it
	for _, obj := range list {
		_, ok := objmap[obj.GetKey()]
		if !ok {
			ct.logger.Infof("diffService(): Deleting existing object %#v since its not in apiserver", obj.GetKey())
			evt := kvstore.WatchEvent{
				Type:   kvstore.Deleted,
				Key:    obj.GetKey(),
				Object: &obj.Service,
			}
			ct.handleServiceEvent(&evt)
		}
	}

	// trigger create event for all others
	for _, obj := range objlist {
		ct.logger.Infof("diffService(): Adding object %#v", obj.GetKey())
		evt := kvstore.WatchEvent{
			Type:   kvstore.Created,
			Key:    obj.GetKey(),
			Object: obj,
		}
		ct.handleServiceEvent(&evt)
	}
}

func (ct *ctrlerCtx) runServiceWatcher() {
	kind := "Service"

	ct.Lock()
	handler, ok := ct.handlers[kind]
	ct.Unlock()
	if !ok {
		ct.logger.Fatalf("Cant find the handler for %s", kind)
	}
	serviceHandler := handler.(ServiceHandler)

	opts := serviceHandler.GetServiceWatchOptions()

	// if there is no API server to connect to, we are done
	if (ct.resolver == nil) || ct.apisrvURL == "" {
		return
	}

	// create context
	ctx, cancel := context.WithCancel(context.Background())
	ct.Lock()
	ct.watchCancel[kind] = cancel
	ct.Unlock()
	logger := ct.logger.WithContext("submodule", "ServiceWatcher")
	for {
		if ctx.Err() != nil {
			return
		}

		apiclt, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
		// create a grpc client
		if err == nil {
			// Upon successful connection perform the diff, and start watch goroutine
			ct.diffService(apiclt)
			break
		}

		logger.Warnf("Failed to connect to gRPC server [%s]\n", ct.apisrvURL)
		time.Sleep(time.Second)
	}

	// setup wait group
	ct.waitGrp.Add(1)

	// start a goroutine
	go func() {
		defer ct.waitGrp.Done()
		ct.stats.Counter("Service_Watch").Inc()
		defer ct.stats.Counter("Service_Watch").Dec()

		// loop forever
		for {
			// create a grpc client
			apicl, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
			if err != nil {
				logger.Warnf("Failed to connect to gRPC server [%s]\n", ct.apisrvURL)
				ct.stats.Counter("Service_ApiClientErr").Inc()
			} else {
				logger.Infof("API client connected {%+v}", apicl)

				// Service object watcher
				wt, werr := apicl.NetworkV1().Service().Watch(ctx, opts)
				if werr != nil {
					select {
					case <-ctx.Done():
						logger.Infof("watch %s cancelled", kind)
						return
					default:
					}
					logger.Errorf("Failed to start %s watch (%s)\n", kind, werr)
					// wait for a second and retry connecting to api server
					apicl.Close()
					time.Sleep(time.Second)
					continue
				}
				ct.Lock()
				ct.watchers[kind] = wt
				ct.Unlock()

				// perform a diff with API server and local cache
				time.Sleep(time.Millisecond * 100)
				ct.diffService(apicl)
				serviceHandler.OnServiceReconnect()

				// handle api server watch events
			innerLoop:
				for {
					// wait for events
					select {
					case evt, ok := <-wt.EventChan():
						if !ok {
							logger.Error("Error receiving from apisrv watcher")
							ct.stats.Counter("Service_WatchErrors").Inc()
							break innerLoop
						}

						// handle event in parallel
						ct.handleServiceEventParallel(evt)
					}
				}
				apicl.Close()
			}

			// if stop flag is set, we are done
			if ct.stoped {
				logger.Infof("Exiting API server watcher")
				return
			}

			// wait for a second and retry connecting to api server
			time.Sleep(time.Second)
		}
	}()
}

// WatchService starts watch on Service object
func (ct *ctrlerCtx) WatchService(handler ServiceHandler) error {
	kind := "Service"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchers[kind]
	ct.Unlock()
	if ok {
		return fmt.Errorf("Service watcher already exists")
	}

	// save handler
	ct.Lock()
	ct.handlers[kind] = handler
	ct.Unlock()

	// run Service watcher in a go routine
	ct.runServiceWatcher()

	return nil
}

// StopWatchService stops watch on Service object
func (ct *ctrlerCtx) StopWatchService(handler ServiceHandler) error {
	kind := "Service"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchers[kind]
	ct.Unlock()
	if !ok {
		return fmt.Errorf("Service watcher does not exist")
	}

	ct.Lock()
	cancel, _ := ct.watchCancel[kind]
	cancel()
	delete(ct.watchers, kind)
	delete(ct.watchCancel, kind)
	ct.Unlock()

	time.Sleep(100 * time.Millisecond)

	return nil
}

// ServiceAPI returns
type ServiceAPI interface {
	Create(obj *network.Service) error
	SyncCreate(obj *network.Service) error
	Update(obj *network.Service) error
	SyncUpdate(obj *network.Service) error
	Delete(obj *network.Service) error
	Find(meta *api.ObjectMeta) (*Service, error)
	List(ctx context.Context, opts *api.ListWatchOptions) ([]*Service, error)
	Watch(handler ServiceHandler) error
	StopWatch(handler ServiceHandler) error
}

// dummy struct that implements ServiceAPI
type serviceAPI struct {
	ct *ctrlerCtx
}

// Create creates Service object
func (api *serviceAPI) Create(obj *network.Service) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.NetworkV1().Service().Create(context.Background(), obj)
		if err != nil && strings.Contains(err.Error(), "AlreadyExists") {
			_, err = apicl.NetworkV1().Service().Update(context.Background(), obj)

		}
		return err
	}

	api.ct.handleServiceEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Created})
	return nil
}

// SyncCreate creates Service object and updates the cache
func (api *serviceAPI) SyncCreate(obj *network.Service) error {
	newObj := obj
	evtType := kvstore.Created
	var writeErr error
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		newObj, writeErr = apicl.NetworkV1().Service().Create(context.Background(), obj)
		if writeErr != nil && strings.Contains(writeErr.Error(), "AlreadyExists") {
			newObj, writeErr = apicl.NetworkV1().Service().Update(context.Background(), obj)
			evtType = kvstore.Updated
		}
	}

	if writeErr == nil {
		api.ct.handleServiceEvent(&kvstore.WatchEvent{Object: newObj, Type: evtType})
	}
	return writeErr
}

// Update triggers update on Service object
func (api *serviceAPI) Update(obj *network.Service) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.NetworkV1().Service().Update(context.Background(), obj)
		return err
	}

	api.ct.handleServiceEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Updated})
	return nil
}

// SyncUpdate triggers update on Service object and updates the cache
func (api *serviceAPI) SyncUpdate(obj *network.Service) error {
	newObj := obj
	var writeErr error
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		newObj, writeErr = apicl.NetworkV1().Service().Update(context.Background(), obj)
	}

	if writeErr == nil {
		api.ct.handleServiceEvent(&kvstore.WatchEvent{Object: newObj, Type: kvstore.Updated})
	}

	return writeErr
}

// Delete deletes Service object
func (api *serviceAPI) Delete(obj *network.Service) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.NetworkV1().Service().Delete(context.Background(), &obj.ObjectMeta)
		return err
	}

	api.ct.handleServiceEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Deleted})
	return nil
}

// MakeKey generates a KV store key for the object
func (api *serviceAPI) getFullKey(tenant, name string) string {
	if tenant != "" {
		return fmt.Sprint(globals.ConfigRootPrefix, "/", "network", "/", "services", "/", tenant, "/", name)
	}
	return fmt.Sprint(globals.ConfigRootPrefix, "/", "network", "/", "services", "/", name)
}

// Find returns an object by meta
func (api *serviceAPI) Find(meta *api.ObjectMeta) (*Service, error) {
	// find the object
	obj, err := api.ct.FindObject("Service", meta)
	if err != nil {
		return nil, err
	}

	// asset type
	switch obj.(type) {
	case *Service:
		hobj := obj.(*Service)
		return hobj, nil
	default:
		return nil, errors.New("incorrect object type")
	}
}

// List returns a list of all Service objects
func (api *serviceAPI) List(ctx context.Context, opts *api.ListWatchOptions) ([]*Service, error) {
	var objlist []*Service
	objs, err := api.ct.List("Service", ctx, opts)

	if err != nil {
		return nil, err
	}

	for _, obj := range objs {
		switch tp := obj.(type) {
		case *Service:
			eobj := obj.(*Service)
			objlist = append(objlist, eobj)
		default:
			log.Fatalf("Got invalid object type %v while looking for Service", tp)
		}
	}

	return objlist, nil
}

// Watch sets up a event handlers for Service object
func (api *serviceAPI) Watch(handler ServiceHandler) error {
	api.ct.startWorkerPool("Service")
	return api.ct.WatchService(handler)
}

// StopWatch stop watch for Tenant Service object
func (api *serviceAPI) StopWatch(handler ServiceHandler) error {
	api.ct.Lock()
	api.ct.workPools["Service"].Stop()
	api.ct.Unlock()
	return api.ct.StopWatchService(handler)
}

// Service returns ServiceAPI
func (ct *ctrlerCtx) Service() ServiceAPI {
	kind := "Service"
	if _, ok := ct.apiInfMap[kind]; !ok {
		s := &serviceAPI{ct: ct}
		ct.apiInfMap[kind] = s
	}
	return ct.apiInfMap[kind].(*serviceAPI)
}

// LbPolicy is a wrapper object that implements additional functionality
type LbPolicy struct {
	sync.Mutex
	network.LbPolicy
	HandlerCtx interface{} // additional state handlers can store
	ctrler     *ctrlerCtx  // reference back to the controller instance
}

func (obj *LbPolicy) Write() error {
	// if there is no API server to connect to, we are done
	if (obj.ctrler == nil) || (obj.ctrler.resolver == nil) || obj.ctrler.apisrvURL == "" {
		return nil
	}

	apicl, err := obj.ctrler.apiClient()
	if err != nil {
		obj.ctrler.logger.Errorf("Error creating API server clent. Err: %v", err)
		return err
	}

	obj.ctrler.stats.Counter("LbPolicy_Writes").Inc()

	// write to api server
	if obj.ObjectMeta.ResourceVersion != "" {
		// update it
		for i := 0; i < maxApisrvWriteRetry; i++ {
			_, err = apicl.NetworkV1().LbPolicy().UpdateStatus(context.Background(), &obj.LbPolicy)
			if err == nil {
				break
			}
			time.Sleep(time.Millisecond * 100)
		}
	} else {
		//  create
		_, err = apicl.NetworkV1().LbPolicy().Create(context.Background(), &obj.LbPolicy)
	}

	return nil
}

// LbPolicyHandler is the event handler for LbPolicy object
type LbPolicyHandler interface {
	OnLbPolicyCreate(obj *LbPolicy) error
	OnLbPolicyUpdate(oldObj *LbPolicy, newObj *network.LbPolicy) error
	OnLbPolicyDelete(obj *LbPolicy) error
	GetLbPolicyWatchOptions() *api.ListWatchOptions
	OnLbPolicyReconnect()
}

// OnLbPolicyCreate is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnLbPolicyCreate(obj *LbPolicy) error {
	log.Info("OnLbPolicyCreate is not implemented")
	return nil
}

// OnLbPolicyUpdate is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnLbPolicyUpdate(oldObj *LbPolicy, newObj *network.LbPolicy) error {
	log.Info("OnLbPolicyUpdate is not implemented")
	return nil
}

// OnLbPolicyDelete is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnLbPolicyDelete(obj *LbPolicy) error {
	log.Info("OnLbPolicyDelete is not implemented")
	return nil
}

// GetLbPolicyWatchOptions is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) GetLbPolicyWatchOptions() *api.ListWatchOptions {
	log.Info("GetLbPolicyWatchOptions is not implemented")
	opts := &api.ListWatchOptions{}
	return opts
}

// OnLbPolicyReconnect is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnLbPolicyReconnect() {
	log.Info("OnLbPolicyReconnect is not implemented")
	return
}

// handleLbPolicyEvent handles LbPolicy events from watcher
func (ct *ctrlerCtx) handleLbPolicyEvent(evt *kvstore.WatchEvent) error {

	if ct.objResolver == nil {
		return ct.handleLbPolicyEventNoResolver(evt)
	}

	switch tp := evt.Object.(type) {
	case *network.LbPolicy:
		eobj := evt.Object.(*network.LbPolicy)
		kind := "LbPolicy"

		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ctx := &lbpolicyCtx{event: evt.Type,
			obj: &LbPolicy{LbPolicy: *eobj, ctrler: ct}}

		var err error
		switch evt.Type {
		case kvstore.Created:
			err = ct.processAdd(ctx)
		case kvstore.Updated:
			err = ct.processUpdate(ctx)
		case kvstore.Deleted:
			err = ct.processDelete(ctx)
		}
		return err
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on LbPolicy watch channel", tp)
	}

	return nil
}

// handleLbPolicyEventNoResolver handles LbPolicy events from watcher
func (ct *ctrlerCtx) handleLbPolicyEventNoResolver(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *network.LbPolicy:
		eobj := evt.Object.(*network.LbPolicy)
		kind := "LbPolicy"

		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		lbpolicyHandler := handler.(LbPolicyHandler)
		// handle based on event type
		ctrlCtx := &lbpolicyCtx{event: evt.Type, obj: &LbPolicy{LbPolicy: *eobj, ctrler: ct}}
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			fobj, err := ct.getObject(kind, ctrlCtx.GetKey())
			if err != nil {
				ct.addObject(ctrlCtx)
				ct.stats.Counter("LbPolicy_Created_Events").Inc()

				// call the event handler
				ctrlCtx.Lock()
				err = lbpolicyHandler.OnLbPolicyCreate(ctrlCtx.obj)
				ctrlCtx.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctrlCtx.obj, err)
					ct.delObject(kind, ctrlCtx.GetKey())
					return err
				}
			} else {
				fResVer, fErr := strconv.ParseInt(fobj.GetResourceVersion(), 10, 64)
				eResVer, eErr := strconv.ParseInt(eobj.GetResourceVersion(), 10, 64)
				if ct.resolver != nil && fErr == nil && eErr == nil && fResVer >= eResVer {
					// Event already processed.
					ct.logger.Infof("Skipping update due to old resource version")
					return nil
				}
				ctrlCtx := fobj.(*lbpolicyCtx)
				ct.stats.Counter("LbPolicy_Updated_Events").Inc()
				ctrlCtx.Lock()
				p := network.LbPolicy{Spec: eobj.Spec,
					ObjectMeta: eobj.ObjectMeta,
					TypeMeta:   eobj.TypeMeta,
					Status:     eobj.Status}

				err = lbpolicyHandler.OnLbPolicyUpdate(ctrlCtx.obj, &p)
				ctrlCtx.obj.LbPolicy = *eobj
				ctrlCtx.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctrlCtx.obj, err)
					return err
				}

			}
		case kvstore.Deleted:
			ctrlCtx := &lbpolicyCtx{event: evt.Type, obj: &LbPolicy{LbPolicy: *eobj, ctrler: ct}}
			fobj, err := ct.findObject(kind, ctrlCtx.GetKey())
			if err != nil {
				ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
				return err
			}

			obj := fobj.(*LbPolicy)
			ct.stats.Counter("LbPolicy_Deleted_Events").Inc()
			obj.Lock()
			err = lbpolicyHandler.OnLbPolicyDelete(obj)
			obj.Unlock()
			if err != nil {
				ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
			}
			ct.delObject(kind, ctrlCtx.GetKey())
			return nil

		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on LbPolicy watch channel", tp)
	}

	return nil
}

type lbpolicyCtx struct {
	ctkitBaseCtx
	event kvstore.WatchEventType
	obj   *LbPolicy //
	//   newObj     *network.LbPolicy //update
	newObj *lbpolicyCtx //update
}

func (ctx *lbpolicyCtx) References() map[string]apiintf.ReferenceObj {
	resp := make(map[string]apiintf.ReferenceObj)
	ctx.obj.References(ctx.obj.GetObjectMeta().Name, ctx.obj.GetObjectMeta().Namespace, resp)
	return resp
}

func (ctx *lbpolicyCtx) GetKey() string {
	return ctx.obj.MakeKey("network")
}

func (ctx *lbpolicyCtx) GetKind() string {
	return ctx.obj.GetKind()
}

func (ctx *lbpolicyCtx) GetResourceVersion() string {
	return ctx.obj.GetResourceVersion()
}

func (ctx *lbpolicyCtx) SetEvent(event kvstore.WatchEventType) {
	ctx.event = event
}

func (ctx *lbpolicyCtx) SetNewObj(newObj apiintf.CtkitObject) {
	if newObj == nil {
		ctx.newObj = nil
	} else {
		ctx.newObj = newObj.(*lbpolicyCtx)
		ctx.newObj.obj.HandlerCtx = ctx.obj.HandlerCtx
	}
}

func (ctx *lbpolicyCtx) GetNewObj() apiintf.CtkitObject {
	return ctx.newObj
}

func (ctx *lbpolicyCtx) Copy(obj apiintf.CtkitObject) {
	ctx.obj.LbPolicy = obj.(*lbpolicyCtx).obj.LbPolicy
}

func (ctx *lbpolicyCtx) Lock() {
	ctx.obj.Lock()
}

func (ctx *lbpolicyCtx) Unlock() {
	ctx.obj.Unlock()
}

func (ctx *lbpolicyCtx) GetObjectMeta() *api.ObjectMeta {
	return ctx.obj.GetObjectMeta()
}

func (ctx *lbpolicyCtx) RuntimeObject() runtime.Object {
	var v interface{}
	v = ctx.obj
	return v.(runtime.Object)
}

func (ctx *lbpolicyCtx) WorkFunc(context context.Context) error {
	var err error
	evt := ctx.event
	ct := ctx.obj.ctrler
	kind := "LbPolicy"
	ct.Lock()
	handler, ok := ct.handlers[kind]
	ct.Unlock()
	if !ok {
		ct.logger.Fatalf("Cant find the handler for %s", kind)
	}
	lbpolicyHandler := handler.(LbPolicyHandler)
	switch evt {
	case kvstore.Created:
		ctx.obj.Lock()
		err = lbpolicyHandler.OnLbPolicyCreate(ctx.obj)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctx.obj, err)
			ctx.SetEvent(kvstore.Deleted)
		}
	case kvstore.Updated:
		ct.stats.Counter("LbPolicy_Updated_Events").Inc()
		ctx.obj.Lock()
		p := network.LbPolicy{Spec: ctx.newObj.obj.Spec,
			ObjectMeta: ctx.newObj.obj.ObjectMeta,
			TypeMeta:   ctx.newObj.obj.TypeMeta,
			Status:     ctx.newObj.obj.Status}
		err = lbpolicyHandler.OnLbPolicyUpdate(ctx.obj, &p)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctx.obj, err)
			ctx.SetEvent(kvstore.Deleted)
		}
	case kvstore.Deleted:
		ctx.obj.Lock()
		err = lbpolicyHandler.OnLbPolicyDelete(ctx.obj)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error deleting %s %+v. Err: %v", kind, ctx.obj, err)
		}
	}
	ct.resolveObject(ctx.event, ctx)
	return nil
}

// handleLbPolicyEventParallel handles LbPolicy events from watcher
func (ct *ctrlerCtx) handleLbPolicyEventParallel(evt *kvstore.WatchEvent) error {

	if ct.objResolver == nil {
		return ct.handleLbPolicyEventParallelWithNoResolver(evt)
	}

	switch tp := evt.Object.(type) {
	case *network.LbPolicy:
		eobj := evt.Object.(*network.LbPolicy)
		kind := "LbPolicy"

		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ctx := &lbpolicyCtx{event: evt.Type, obj: &LbPolicy{LbPolicy: *eobj, ctrler: ct}}

		var err error
		switch evt.Type {
		case kvstore.Created:
			err = ct.processAdd(ctx)
		case kvstore.Updated:
			err = ct.processUpdate(ctx)
		case kvstore.Deleted:
			err = ct.processDelete(ctx)
		}
		return err
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on LbPolicy watch channel", tp)
	}

	return nil
}

// handleLbPolicyEventParallel handles LbPolicy events from watcher
func (ct *ctrlerCtx) handleLbPolicyEventParallelWithNoResolver(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *network.LbPolicy:
		eobj := evt.Object.(*network.LbPolicy)
		kind := "LbPolicy"

		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		lbpolicyHandler := handler.(LbPolicyHandler)
		// handle based on event type
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			workFunc := func(ctx context.Context, ctrlCtx shardworkers.WorkObj) error {
				var err error
				workCtx := ctrlCtx.(*lbpolicyCtx)
				eobj := workCtx.obj
				fobj, err := ct.getObject(kind, workCtx.GetKey())
				if err != nil {
					ct.addObject(workCtx)
					ct.stats.Counter("LbPolicy_Created_Events").Inc()
					eobj.Lock()
					err = lbpolicyHandler.OnLbPolicyCreate(eobj)
					eobj.Unlock()
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, eobj, err)
						ct.delObject(kind, workCtx.GetKey())
					}
				} else {
					workCtx := fobj.(*lbpolicyCtx)
					obj := workCtx.obj
					ct.stats.Counter("LbPolicy_Updated_Events").Inc()
					obj.Lock()
					p := network.LbPolicy{Spec: eobj.Spec,
						ObjectMeta: eobj.ObjectMeta,
						TypeMeta:   eobj.TypeMeta,
						Status:     eobj.Status}

					err = lbpolicyHandler.OnLbPolicyUpdate(obj, &p)
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					} else {
						workCtx.obj.LbPolicy = p
					}
					obj.Unlock()
				}
				return err
			}
			ctrlCtx := &lbpolicyCtx{event: evt.Type, obj: &LbPolicy{LbPolicy: *eobj, ctrler: ct}}
			ct.runFunction("LbPolicy", ctrlCtx, workFunc)
		case kvstore.Deleted:
			workFunc := func(ctx context.Context, ctrlCtx shardworkers.WorkObj) error {
				var err error
				workCtx := ctrlCtx.(*lbpolicyCtx)
				eobj := workCtx.obj
				fobj, err := ct.findObject(kind, workCtx.GetKey())
				if err != nil {
					ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
					return err
				}
				obj := fobj.(*LbPolicy)
				ct.stats.Counter("LbPolicy_Deleted_Events").Inc()
				obj.Lock()
				err = lbpolicyHandler.OnLbPolicyDelete(obj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
				}
				ct.delObject(kind, workCtx.GetKey())
				return nil
			}
			ctrlCtx := &lbpolicyCtx{event: evt.Type, obj: &LbPolicy{LbPolicy: *eobj, ctrler: ct}}
			ct.runFunction("LbPolicy", ctrlCtx, workFunc)
		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on LbPolicy watch channel", tp)
	}

	return nil
}

// diffLbPolicy does a diff of LbPolicy objects between local cache and API server
func (ct *ctrlerCtx) diffLbPolicy(apicl apiclient.Services) {
	opts := api.ListWatchOptions{}

	// get a list of all objects from API server
	objlist, err := apicl.NetworkV1().LbPolicy().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Errorf("Error getting a list of objects. Err: %v", err)
		return
	}

	ct.logger.Infof("diffLbPolicy(): LbPolicyList returned %d objects", len(objlist))

	// build an object map
	objmap := make(map[string]*network.LbPolicy)
	for _, obj := range objlist {
		objmap[obj.GetKey()] = obj
	}

	list, err := ct.LbPolicy().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Infof("Failed to get a list of objects. Err: %s", err)
		return
	}

	// if an object is in our local cache and not in API server, trigger delete for it
	for _, obj := range list {
		_, ok := objmap[obj.GetKey()]
		if !ok {
			ct.logger.Infof("diffLbPolicy(): Deleting existing object %#v since its not in apiserver", obj.GetKey())
			evt := kvstore.WatchEvent{
				Type:   kvstore.Deleted,
				Key:    obj.GetKey(),
				Object: &obj.LbPolicy,
			}
			ct.handleLbPolicyEvent(&evt)
		}
	}

	// trigger create event for all others
	for _, obj := range objlist {
		ct.logger.Infof("diffLbPolicy(): Adding object %#v", obj.GetKey())
		evt := kvstore.WatchEvent{
			Type:   kvstore.Created,
			Key:    obj.GetKey(),
			Object: obj,
		}
		ct.handleLbPolicyEvent(&evt)
	}
}

func (ct *ctrlerCtx) runLbPolicyWatcher() {
	kind := "LbPolicy"

	ct.Lock()
	handler, ok := ct.handlers[kind]
	ct.Unlock()
	if !ok {
		ct.logger.Fatalf("Cant find the handler for %s", kind)
	}
	lbpolicyHandler := handler.(LbPolicyHandler)

	opts := lbpolicyHandler.GetLbPolicyWatchOptions()

	// if there is no API server to connect to, we are done
	if (ct.resolver == nil) || ct.apisrvURL == "" {
		return
	}

	// create context
	ctx, cancel := context.WithCancel(context.Background())
	ct.Lock()
	ct.watchCancel[kind] = cancel
	ct.Unlock()
	logger := ct.logger.WithContext("submodule", "LbPolicyWatcher")
	for {
		if ctx.Err() != nil {
			return
		}

		apiclt, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
		// create a grpc client
		if err == nil {
			// Upon successful connection perform the diff, and start watch goroutine
			ct.diffLbPolicy(apiclt)
			break
		}

		logger.Warnf("Failed to connect to gRPC server [%s]\n", ct.apisrvURL)
		time.Sleep(time.Second)
	}

	// setup wait group
	ct.waitGrp.Add(1)

	// start a goroutine
	go func() {
		defer ct.waitGrp.Done()
		ct.stats.Counter("LbPolicy_Watch").Inc()
		defer ct.stats.Counter("LbPolicy_Watch").Dec()

		// loop forever
		for {
			// create a grpc client
			apicl, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
			if err != nil {
				logger.Warnf("Failed to connect to gRPC server [%s]\n", ct.apisrvURL)
				ct.stats.Counter("LbPolicy_ApiClientErr").Inc()
			} else {
				logger.Infof("API client connected {%+v}", apicl)

				// LbPolicy object watcher
				wt, werr := apicl.NetworkV1().LbPolicy().Watch(ctx, opts)
				if werr != nil {
					select {
					case <-ctx.Done():
						logger.Infof("watch %s cancelled", kind)
						return
					default:
					}
					logger.Errorf("Failed to start %s watch (%s)\n", kind, werr)
					// wait for a second and retry connecting to api server
					apicl.Close()
					time.Sleep(time.Second)
					continue
				}
				ct.Lock()
				ct.watchers[kind] = wt
				ct.Unlock()

				// perform a diff with API server and local cache
				time.Sleep(time.Millisecond * 100)
				ct.diffLbPolicy(apicl)
				lbpolicyHandler.OnLbPolicyReconnect()

				// handle api server watch events
			innerLoop:
				for {
					// wait for events
					select {
					case evt, ok := <-wt.EventChan():
						if !ok {
							logger.Error("Error receiving from apisrv watcher")
							ct.stats.Counter("LbPolicy_WatchErrors").Inc()
							break innerLoop
						}

						// handle event in parallel
						ct.handleLbPolicyEventParallel(evt)
					}
				}
				apicl.Close()
			}

			// if stop flag is set, we are done
			if ct.stoped {
				logger.Infof("Exiting API server watcher")
				return
			}

			// wait for a second and retry connecting to api server
			time.Sleep(time.Second)
		}
	}()
}

// WatchLbPolicy starts watch on LbPolicy object
func (ct *ctrlerCtx) WatchLbPolicy(handler LbPolicyHandler) error {
	kind := "LbPolicy"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchers[kind]
	ct.Unlock()
	if ok {
		return fmt.Errorf("LbPolicy watcher already exists")
	}

	// save handler
	ct.Lock()
	ct.handlers[kind] = handler
	ct.Unlock()

	// run LbPolicy watcher in a go routine
	ct.runLbPolicyWatcher()

	return nil
}

// StopWatchLbPolicy stops watch on LbPolicy object
func (ct *ctrlerCtx) StopWatchLbPolicy(handler LbPolicyHandler) error {
	kind := "LbPolicy"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchers[kind]
	ct.Unlock()
	if !ok {
		return fmt.Errorf("LbPolicy watcher does not exist")
	}

	ct.Lock()
	cancel, _ := ct.watchCancel[kind]
	cancel()
	delete(ct.watchers, kind)
	delete(ct.watchCancel, kind)
	ct.Unlock()

	time.Sleep(100 * time.Millisecond)

	return nil
}

// LbPolicyAPI returns
type LbPolicyAPI interface {
	Create(obj *network.LbPolicy) error
	SyncCreate(obj *network.LbPolicy) error
	Update(obj *network.LbPolicy) error
	SyncUpdate(obj *network.LbPolicy) error
	Delete(obj *network.LbPolicy) error
	Find(meta *api.ObjectMeta) (*LbPolicy, error)
	List(ctx context.Context, opts *api.ListWatchOptions) ([]*LbPolicy, error)
	Watch(handler LbPolicyHandler) error
	StopWatch(handler LbPolicyHandler) error
}

// dummy struct that implements LbPolicyAPI
type lbpolicyAPI struct {
	ct *ctrlerCtx
}

// Create creates LbPolicy object
func (api *lbpolicyAPI) Create(obj *network.LbPolicy) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.NetworkV1().LbPolicy().Create(context.Background(), obj)
		if err != nil && strings.Contains(err.Error(), "AlreadyExists") {
			_, err = apicl.NetworkV1().LbPolicy().Update(context.Background(), obj)

		}
		return err
	}

	api.ct.handleLbPolicyEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Created})
	return nil
}

// SyncCreate creates LbPolicy object and updates the cache
func (api *lbpolicyAPI) SyncCreate(obj *network.LbPolicy) error {
	newObj := obj
	evtType := kvstore.Created
	var writeErr error
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		newObj, writeErr = apicl.NetworkV1().LbPolicy().Create(context.Background(), obj)
		if writeErr != nil && strings.Contains(writeErr.Error(), "AlreadyExists") {
			newObj, writeErr = apicl.NetworkV1().LbPolicy().Update(context.Background(), obj)
			evtType = kvstore.Updated
		}
	}

	if writeErr == nil {
		api.ct.handleLbPolicyEvent(&kvstore.WatchEvent{Object: newObj, Type: evtType})
	}
	return writeErr
}

// Update triggers update on LbPolicy object
func (api *lbpolicyAPI) Update(obj *network.LbPolicy) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.NetworkV1().LbPolicy().Update(context.Background(), obj)
		return err
	}

	api.ct.handleLbPolicyEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Updated})
	return nil
}

// SyncUpdate triggers update on LbPolicy object and updates the cache
func (api *lbpolicyAPI) SyncUpdate(obj *network.LbPolicy) error {
	newObj := obj
	var writeErr error
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		newObj, writeErr = apicl.NetworkV1().LbPolicy().Update(context.Background(), obj)
	}

	if writeErr == nil {
		api.ct.handleLbPolicyEvent(&kvstore.WatchEvent{Object: newObj, Type: kvstore.Updated})
	}

	return writeErr
}

// Delete deletes LbPolicy object
func (api *lbpolicyAPI) Delete(obj *network.LbPolicy) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.NetworkV1().LbPolicy().Delete(context.Background(), &obj.ObjectMeta)
		return err
	}

	api.ct.handleLbPolicyEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Deleted})
	return nil
}

// MakeKey generates a KV store key for the object
func (api *lbpolicyAPI) getFullKey(tenant, name string) string {
	if tenant != "" {
		return fmt.Sprint(globals.ConfigRootPrefix, "/", "network", "/", "lb-policy", "/", tenant, "/", name)
	}
	return fmt.Sprint(globals.ConfigRootPrefix, "/", "network", "/", "lb-policy", "/", name)
}

// Find returns an object by meta
func (api *lbpolicyAPI) Find(meta *api.ObjectMeta) (*LbPolicy, error) {
	// find the object
	obj, err := api.ct.FindObject("LbPolicy", meta)
	if err != nil {
		return nil, err
	}

	// asset type
	switch obj.(type) {
	case *LbPolicy:
		hobj := obj.(*LbPolicy)
		return hobj, nil
	default:
		return nil, errors.New("incorrect object type")
	}
}

// List returns a list of all LbPolicy objects
func (api *lbpolicyAPI) List(ctx context.Context, opts *api.ListWatchOptions) ([]*LbPolicy, error) {
	var objlist []*LbPolicy
	objs, err := api.ct.List("LbPolicy", ctx, opts)

	if err != nil {
		return nil, err
	}

	for _, obj := range objs {
		switch tp := obj.(type) {
		case *LbPolicy:
			eobj := obj.(*LbPolicy)
			objlist = append(objlist, eobj)
		default:
			log.Fatalf("Got invalid object type %v while looking for LbPolicy", tp)
		}
	}

	return objlist, nil
}

// Watch sets up a event handlers for LbPolicy object
func (api *lbpolicyAPI) Watch(handler LbPolicyHandler) error {
	api.ct.startWorkerPool("LbPolicy")
	return api.ct.WatchLbPolicy(handler)
}

// StopWatch stop watch for Tenant LbPolicy object
func (api *lbpolicyAPI) StopWatch(handler LbPolicyHandler) error {
	api.ct.Lock()
	api.ct.workPools["LbPolicy"].Stop()
	api.ct.Unlock()
	return api.ct.StopWatchLbPolicy(handler)
}

// LbPolicy returns LbPolicyAPI
func (ct *ctrlerCtx) LbPolicy() LbPolicyAPI {
	kind := "LbPolicy"
	if _, ok := ct.apiInfMap[kind]; !ok {
		s := &lbpolicyAPI{ct: ct}
		ct.apiInfMap[kind] = s
	}
	return ct.apiInfMap[kind].(*lbpolicyAPI)
}

// VirtualRouter is a wrapper object that implements additional functionality
type VirtualRouter struct {
	sync.Mutex
	network.VirtualRouter
	HandlerCtx interface{} // additional state handlers can store
	ctrler     *ctrlerCtx  // reference back to the controller instance
}

func (obj *VirtualRouter) Write() error {
	// if there is no API server to connect to, we are done
	if (obj.ctrler == nil) || (obj.ctrler.resolver == nil) || obj.ctrler.apisrvURL == "" {
		return nil
	}

	apicl, err := obj.ctrler.apiClient()
	if err != nil {
		obj.ctrler.logger.Errorf("Error creating API server clent. Err: %v", err)
		return err
	}

	obj.ctrler.stats.Counter("VirtualRouter_Writes").Inc()

	// write to api server
	if obj.ObjectMeta.ResourceVersion != "" {
		// update it
		for i := 0; i < maxApisrvWriteRetry; i++ {
			_, err = apicl.NetworkV1().VirtualRouter().UpdateStatus(context.Background(), &obj.VirtualRouter)
			if err == nil {
				break
			}
			time.Sleep(time.Millisecond * 100)
		}
	} else {
		//  create
		_, err = apicl.NetworkV1().VirtualRouter().Create(context.Background(), &obj.VirtualRouter)
	}

	return nil
}

// VirtualRouterHandler is the event handler for VirtualRouter object
type VirtualRouterHandler interface {
	OnVirtualRouterCreate(obj *VirtualRouter) error
	OnVirtualRouterUpdate(oldObj *VirtualRouter, newObj *network.VirtualRouter) error
	OnVirtualRouterDelete(obj *VirtualRouter) error
	GetVirtualRouterWatchOptions() *api.ListWatchOptions
	OnVirtualRouterReconnect()
}

// OnVirtualRouterCreate is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnVirtualRouterCreate(obj *VirtualRouter) error {
	log.Info("OnVirtualRouterCreate is not implemented")
	return nil
}

// OnVirtualRouterUpdate is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnVirtualRouterUpdate(oldObj *VirtualRouter, newObj *network.VirtualRouter) error {
	log.Info("OnVirtualRouterUpdate is not implemented")
	return nil
}

// OnVirtualRouterDelete is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnVirtualRouterDelete(obj *VirtualRouter) error {
	log.Info("OnVirtualRouterDelete is not implemented")
	return nil
}

// GetVirtualRouterWatchOptions is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) GetVirtualRouterWatchOptions() *api.ListWatchOptions {
	log.Info("GetVirtualRouterWatchOptions is not implemented")
	opts := &api.ListWatchOptions{}
	return opts
}

// OnVirtualRouterReconnect is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnVirtualRouterReconnect() {
	log.Info("OnVirtualRouterReconnect is not implemented")
	return
}

// handleVirtualRouterEvent handles VirtualRouter events from watcher
func (ct *ctrlerCtx) handleVirtualRouterEvent(evt *kvstore.WatchEvent) error {

	if ct.objResolver == nil {
		return ct.handleVirtualRouterEventNoResolver(evt)
	}

	switch tp := evt.Object.(type) {
	case *network.VirtualRouter:
		eobj := evt.Object.(*network.VirtualRouter)
		kind := "VirtualRouter"

		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ctx := &virtualrouterCtx{event: evt.Type,
			obj: &VirtualRouter{VirtualRouter: *eobj, ctrler: ct}}

		var err error
		switch evt.Type {
		case kvstore.Created:
			err = ct.processAdd(ctx)
		case kvstore.Updated:
			err = ct.processUpdate(ctx)
		case kvstore.Deleted:
			err = ct.processDelete(ctx)
		}
		return err
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on VirtualRouter watch channel", tp)
	}

	return nil
}

// handleVirtualRouterEventNoResolver handles VirtualRouter events from watcher
func (ct *ctrlerCtx) handleVirtualRouterEventNoResolver(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *network.VirtualRouter:
		eobj := evt.Object.(*network.VirtualRouter)
		kind := "VirtualRouter"

		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		virtualrouterHandler := handler.(VirtualRouterHandler)
		// handle based on event type
		ctrlCtx := &virtualrouterCtx{event: evt.Type, obj: &VirtualRouter{VirtualRouter: *eobj, ctrler: ct}}
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			fobj, err := ct.getObject(kind, ctrlCtx.GetKey())
			if err != nil {
				ct.addObject(ctrlCtx)
				ct.stats.Counter("VirtualRouter_Created_Events").Inc()

				// call the event handler
				ctrlCtx.Lock()
				err = virtualrouterHandler.OnVirtualRouterCreate(ctrlCtx.obj)
				ctrlCtx.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctrlCtx.obj, err)
					ct.delObject(kind, ctrlCtx.GetKey())
					return err
				}
			} else {
				fResVer, fErr := strconv.ParseInt(fobj.GetResourceVersion(), 10, 64)
				eResVer, eErr := strconv.ParseInt(eobj.GetResourceVersion(), 10, 64)
				if ct.resolver != nil && fErr == nil && eErr == nil && fResVer >= eResVer {
					// Event already processed.
					ct.logger.Infof("Skipping update due to old resource version")
					return nil
				}
				ctrlCtx := fobj.(*virtualrouterCtx)
				ct.stats.Counter("VirtualRouter_Updated_Events").Inc()
				ctrlCtx.Lock()
				p := network.VirtualRouter{Spec: eobj.Spec,
					ObjectMeta: eobj.ObjectMeta,
					TypeMeta:   eobj.TypeMeta,
					Status:     eobj.Status}

				err = virtualrouterHandler.OnVirtualRouterUpdate(ctrlCtx.obj, &p)
				ctrlCtx.obj.VirtualRouter = *eobj
				ctrlCtx.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctrlCtx.obj, err)
					return err
				}

			}
		case kvstore.Deleted:
			ctrlCtx := &virtualrouterCtx{event: evt.Type, obj: &VirtualRouter{VirtualRouter: *eobj, ctrler: ct}}
			fobj, err := ct.findObject(kind, ctrlCtx.GetKey())
			if err != nil {
				ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
				return err
			}

			obj := fobj.(*VirtualRouter)
			ct.stats.Counter("VirtualRouter_Deleted_Events").Inc()
			obj.Lock()
			err = virtualrouterHandler.OnVirtualRouterDelete(obj)
			obj.Unlock()
			if err != nil {
				ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
			}
			ct.delObject(kind, ctrlCtx.GetKey())
			return nil

		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on VirtualRouter watch channel", tp)
	}

	return nil
}

type virtualrouterCtx struct {
	ctkitBaseCtx
	event kvstore.WatchEventType
	obj   *VirtualRouter //
	//   newObj     *network.VirtualRouter //update
	newObj *virtualrouterCtx //update
}

func (ctx *virtualrouterCtx) References() map[string]apiintf.ReferenceObj {
	resp := make(map[string]apiintf.ReferenceObj)
	ctx.obj.References(ctx.obj.GetObjectMeta().Name, ctx.obj.GetObjectMeta().Namespace, resp)
	return resp
}

func (ctx *virtualrouterCtx) GetKey() string {
	return ctx.obj.MakeKey("network")
}

func (ctx *virtualrouterCtx) GetKind() string {
	return ctx.obj.GetKind()
}

func (ctx *virtualrouterCtx) GetResourceVersion() string {
	return ctx.obj.GetResourceVersion()
}

func (ctx *virtualrouterCtx) SetEvent(event kvstore.WatchEventType) {
	ctx.event = event
}

func (ctx *virtualrouterCtx) SetNewObj(newObj apiintf.CtkitObject) {
	if newObj == nil {
		ctx.newObj = nil
	} else {
		ctx.newObj = newObj.(*virtualrouterCtx)
		ctx.newObj.obj.HandlerCtx = ctx.obj.HandlerCtx
	}
}

func (ctx *virtualrouterCtx) GetNewObj() apiintf.CtkitObject {
	return ctx.newObj
}

func (ctx *virtualrouterCtx) Copy(obj apiintf.CtkitObject) {
	ctx.obj.VirtualRouter = obj.(*virtualrouterCtx).obj.VirtualRouter
}

func (ctx *virtualrouterCtx) Lock() {
	ctx.obj.Lock()
}

func (ctx *virtualrouterCtx) Unlock() {
	ctx.obj.Unlock()
}

func (ctx *virtualrouterCtx) GetObjectMeta() *api.ObjectMeta {
	return ctx.obj.GetObjectMeta()
}

func (ctx *virtualrouterCtx) RuntimeObject() runtime.Object {
	var v interface{}
	v = ctx.obj
	return v.(runtime.Object)
}

func (ctx *virtualrouterCtx) WorkFunc(context context.Context) error {
	var err error
	evt := ctx.event
	ct := ctx.obj.ctrler
	kind := "VirtualRouter"
	ct.Lock()
	handler, ok := ct.handlers[kind]
	ct.Unlock()
	if !ok {
		ct.logger.Fatalf("Cant find the handler for %s", kind)
	}
	virtualrouterHandler := handler.(VirtualRouterHandler)
	switch evt {
	case kvstore.Created:
		ctx.obj.Lock()
		err = virtualrouterHandler.OnVirtualRouterCreate(ctx.obj)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctx.obj, err)
			ctx.SetEvent(kvstore.Deleted)
		}
	case kvstore.Updated:
		ct.stats.Counter("VirtualRouter_Updated_Events").Inc()
		ctx.obj.Lock()
		p := network.VirtualRouter{Spec: ctx.newObj.obj.Spec,
			ObjectMeta: ctx.newObj.obj.ObjectMeta,
			TypeMeta:   ctx.newObj.obj.TypeMeta,
			Status:     ctx.newObj.obj.Status}
		err = virtualrouterHandler.OnVirtualRouterUpdate(ctx.obj, &p)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctx.obj, err)
			ctx.SetEvent(kvstore.Deleted)
		}
	case kvstore.Deleted:
		ctx.obj.Lock()
		err = virtualrouterHandler.OnVirtualRouterDelete(ctx.obj)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error deleting %s %+v. Err: %v", kind, ctx.obj, err)
		}
	}
	ct.resolveObject(ctx.event, ctx)
	return nil
}

// handleVirtualRouterEventParallel handles VirtualRouter events from watcher
func (ct *ctrlerCtx) handleVirtualRouterEventParallel(evt *kvstore.WatchEvent) error {

	if ct.objResolver == nil {
		return ct.handleVirtualRouterEventParallelWithNoResolver(evt)
	}

	switch tp := evt.Object.(type) {
	case *network.VirtualRouter:
		eobj := evt.Object.(*network.VirtualRouter)
		kind := "VirtualRouter"

		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ctx := &virtualrouterCtx{event: evt.Type, obj: &VirtualRouter{VirtualRouter: *eobj, ctrler: ct}}

		var err error
		switch evt.Type {
		case kvstore.Created:
			err = ct.processAdd(ctx)
		case kvstore.Updated:
			err = ct.processUpdate(ctx)
		case kvstore.Deleted:
			err = ct.processDelete(ctx)
		}
		return err
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on VirtualRouter watch channel", tp)
	}

	return nil
}

// handleVirtualRouterEventParallel handles VirtualRouter events from watcher
func (ct *ctrlerCtx) handleVirtualRouterEventParallelWithNoResolver(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *network.VirtualRouter:
		eobj := evt.Object.(*network.VirtualRouter)
		kind := "VirtualRouter"

		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		virtualrouterHandler := handler.(VirtualRouterHandler)
		// handle based on event type
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			workFunc := func(ctx context.Context, ctrlCtx shardworkers.WorkObj) error {
				var err error
				workCtx := ctrlCtx.(*virtualrouterCtx)
				eobj := workCtx.obj
				fobj, err := ct.getObject(kind, workCtx.GetKey())
				if err != nil {
					ct.addObject(workCtx)
					ct.stats.Counter("VirtualRouter_Created_Events").Inc()
					eobj.Lock()
					err = virtualrouterHandler.OnVirtualRouterCreate(eobj)
					eobj.Unlock()
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, eobj, err)
						ct.delObject(kind, workCtx.GetKey())
					}
				} else {
					workCtx := fobj.(*virtualrouterCtx)
					obj := workCtx.obj
					ct.stats.Counter("VirtualRouter_Updated_Events").Inc()
					obj.Lock()
					p := network.VirtualRouter{Spec: eobj.Spec,
						ObjectMeta: eobj.ObjectMeta,
						TypeMeta:   eobj.TypeMeta,
						Status:     eobj.Status}

					err = virtualrouterHandler.OnVirtualRouterUpdate(obj, &p)
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					} else {
						workCtx.obj.VirtualRouter = p
					}
					obj.Unlock()
				}
				return err
			}
			ctrlCtx := &virtualrouterCtx{event: evt.Type, obj: &VirtualRouter{VirtualRouter: *eobj, ctrler: ct}}
			ct.runFunction("VirtualRouter", ctrlCtx, workFunc)
		case kvstore.Deleted:
			workFunc := func(ctx context.Context, ctrlCtx shardworkers.WorkObj) error {
				var err error
				workCtx := ctrlCtx.(*virtualrouterCtx)
				eobj := workCtx.obj
				fobj, err := ct.findObject(kind, workCtx.GetKey())
				if err != nil {
					ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
					return err
				}
				obj := fobj.(*VirtualRouter)
				ct.stats.Counter("VirtualRouter_Deleted_Events").Inc()
				obj.Lock()
				err = virtualrouterHandler.OnVirtualRouterDelete(obj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
				}
				ct.delObject(kind, workCtx.GetKey())
				return nil
			}
			ctrlCtx := &virtualrouterCtx{event: evt.Type, obj: &VirtualRouter{VirtualRouter: *eobj, ctrler: ct}}
			ct.runFunction("VirtualRouter", ctrlCtx, workFunc)
		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on VirtualRouter watch channel", tp)
	}

	return nil
}

// diffVirtualRouter does a diff of VirtualRouter objects between local cache and API server
func (ct *ctrlerCtx) diffVirtualRouter(apicl apiclient.Services) {
	opts := api.ListWatchOptions{}

	// get a list of all objects from API server
	objlist, err := apicl.NetworkV1().VirtualRouter().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Errorf("Error getting a list of objects. Err: %v", err)
		return
	}

	ct.logger.Infof("diffVirtualRouter(): VirtualRouterList returned %d objects", len(objlist))

	// build an object map
	objmap := make(map[string]*network.VirtualRouter)
	for _, obj := range objlist {
		objmap[obj.GetKey()] = obj
	}

	list, err := ct.VirtualRouter().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Infof("Failed to get a list of objects. Err: %s", err)
		return
	}

	// if an object is in our local cache and not in API server, trigger delete for it
	for _, obj := range list {
		_, ok := objmap[obj.GetKey()]
		if !ok {
			ct.logger.Infof("diffVirtualRouter(): Deleting existing object %#v since its not in apiserver", obj.GetKey())
			evt := kvstore.WatchEvent{
				Type:   kvstore.Deleted,
				Key:    obj.GetKey(),
				Object: &obj.VirtualRouter,
			}
			ct.handleVirtualRouterEvent(&evt)
		}
	}

	// trigger create event for all others
	for _, obj := range objlist {
		ct.logger.Infof("diffVirtualRouter(): Adding object %#v", obj.GetKey())
		evt := kvstore.WatchEvent{
			Type:   kvstore.Created,
			Key:    obj.GetKey(),
			Object: obj,
		}
		ct.handleVirtualRouterEvent(&evt)
	}
}

func (ct *ctrlerCtx) runVirtualRouterWatcher() {
	kind := "VirtualRouter"

	ct.Lock()
	handler, ok := ct.handlers[kind]
	ct.Unlock()
	if !ok {
		ct.logger.Fatalf("Cant find the handler for %s", kind)
	}
	virtualrouterHandler := handler.(VirtualRouterHandler)

	opts := virtualrouterHandler.GetVirtualRouterWatchOptions()

	// if there is no API server to connect to, we are done
	if (ct.resolver == nil) || ct.apisrvURL == "" {
		return
	}

	// create context
	ctx, cancel := context.WithCancel(context.Background())
	ct.Lock()
	ct.watchCancel[kind] = cancel
	ct.Unlock()
	logger := ct.logger.WithContext("submodule", "VirtualRouterWatcher")
	for {
		if ctx.Err() != nil {
			return
		}

		apiclt, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
		// create a grpc client
		if err == nil {
			// Upon successful connection perform the diff, and start watch goroutine
			ct.diffVirtualRouter(apiclt)
			break
		}

		logger.Warnf("Failed to connect to gRPC server [%s]\n", ct.apisrvURL)
		time.Sleep(time.Second)
	}

	// setup wait group
	ct.waitGrp.Add(1)

	// start a goroutine
	go func() {
		defer ct.waitGrp.Done()
		ct.stats.Counter("VirtualRouter_Watch").Inc()
		defer ct.stats.Counter("VirtualRouter_Watch").Dec()

		// loop forever
		for {
			// create a grpc client
			apicl, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
			if err != nil {
				logger.Warnf("Failed to connect to gRPC server [%s]\n", ct.apisrvURL)
				ct.stats.Counter("VirtualRouter_ApiClientErr").Inc()
			} else {
				logger.Infof("API client connected {%+v}", apicl)

				// VirtualRouter object watcher
				wt, werr := apicl.NetworkV1().VirtualRouter().Watch(ctx, opts)
				if werr != nil {
					select {
					case <-ctx.Done():
						logger.Infof("watch %s cancelled", kind)
						return
					default:
					}
					logger.Errorf("Failed to start %s watch (%s)\n", kind, werr)
					// wait for a second and retry connecting to api server
					apicl.Close()
					time.Sleep(time.Second)
					continue
				}
				ct.Lock()
				ct.watchers[kind] = wt
				ct.Unlock()

				// perform a diff with API server and local cache
				time.Sleep(time.Millisecond * 100)
				ct.diffVirtualRouter(apicl)
				virtualrouterHandler.OnVirtualRouterReconnect()

				// handle api server watch events
			innerLoop:
				for {
					// wait for events
					select {
					case evt, ok := <-wt.EventChan():
						if !ok {
							logger.Error("Error receiving from apisrv watcher")
							ct.stats.Counter("VirtualRouter_WatchErrors").Inc()
							break innerLoop
						}

						// handle event in parallel
						ct.handleVirtualRouterEventParallel(evt)
					}
				}
				apicl.Close()
			}

			// if stop flag is set, we are done
			if ct.stoped {
				logger.Infof("Exiting API server watcher")
				return
			}

			// wait for a second and retry connecting to api server
			time.Sleep(time.Second)
		}
	}()
}

// WatchVirtualRouter starts watch on VirtualRouter object
func (ct *ctrlerCtx) WatchVirtualRouter(handler VirtualRouterHandler) error {
	kind := "VirtualRouter"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchers[kind]
	ct.Unlock()
	if ok {
		return fmt.Errorf("VirtualRouter watcher already exists")
	}

	// save handler
	ct.Lock()
	ct.handlers[kind] = handler
	ct.Unlock()

	// run VirtualRouter watcher in a go routine
	ct.runVirtualRouterWatcher()

	return nil
}

// StopWatchVirtualRouter stops watch on VirtualRouter object
func (ct *ctrlerCtx) StopWatchVirtualRouter(handler VirtualRouterHandler) error {
	kind := "VirtualRouter"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchers[kind]
	ct.Unlock()
	if !ok {
		return fmt.Errorf("VirtualRouter watcher does not exist")
	}

	ct.Lock()
	cancel, _ := ct.watchCancel[kind]
	cancel()
	delete(ct.watchers, kind)
	delete(ct.watchCancel, kind)
	ct.Unlock()

	time.Sleep(100 * time.Millisecond)

	return nil
}

// VirtualRouterAPI returns
type VirtualRouterAPI interface {
	Create(obj *network.VirtualRouter) error
	SyncCreate(obj *network.VirtualRouter) error
	Update(obj *network.VirtualRouter) error
	SyncUpdate(obj *network.VirtualRouter) error
	Delete(obj *network.VirtualRouter) error
	Find(meta *api.ObjectMeta) (*VirtualRouter, error)
	List(ctx context.Context, opts *api.ListWatchOptions) ([]*VirtualRouter, error)
	Watch(handler VirtualRouterHandler) error
	StopWatch(handler VirtualRouterHandler) error
}

// dummy struct that implements VirtualRouterAPI
type virtualrouterAPI struct {
	ct *ctrlerCtx
}

// Create creates VirtualRouter object
func (api *virtualrouterAPI) Create(obj *network.VirtualRouter) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.NetworkV1().VirtualRouter().Create(context.Background(), obj)
		if err != nil && strings.Contains(err.Error(), "AlreadyExists") {
			_, err = apicl.NetworkV1().VirtualRouter().Update(context.Background(), obj)

		}
		return err
	}

	api.ct.handleVirtualRouterEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Created})
	return nil
}

// SyncCreate creates VirtualRouter object and updates the cache
func (api *virtualrouterAPI) SyncCreate(obj *network.VirtualRouter) error {
	newObj := obj
	evtType := kvstore.Created
	var writeErr error
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		newObj, writeErr = apicl.NetworkV1().VirtualRouter().Create(context.Background(), obj)
		if writeErr != nil && strings.Contains(writeErr.Error(), "AlreadyExists") {
			newObj, writeErr = apicl.NetworkV1().VirtualRouter().Update(context.Background(), obj)
			evtType = kvstore.Updated
		}
	}

	if writeErr == nil {
		api.ct.handleVirtualRouterEvent(&kvstore.WatchEvent{Object: newObj, Type: evtType})
	}
	return writeErr
}

// Update triggers update on VirtualRouter object
func (api *virtualrouterAPI) Update(obj *network.VirtualRouter) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.NetworkV1().VirtualRouter().Update(context.Background(), obj)
		return err
	}

	api.ct.handleVirtualRouterEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Updated})
	return nil
}

// SyncUpdate triggers update on VirtualRouter object and updates the cache
func (api *virtualrouterAPI) SyncUpdate(obj *network.VirtualRouter) error {
	newObj := obj
	var writeErr error
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		newObj, writeErr = apicl.NetworkV1().VirtualRouter().Update(context.Background(), obj)
	}

	if writeErr == nil {
		api.ct.handleVirtualRouterEvent(&kvstore.WatchEvent{Object: newObj, Type: kvstore.Updated})
	}

	return writeErr
}

// Delete deletes VirtualRouter object
func (api *virtualrouterAPI) Delete(obj *network.VirtualRouter) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.NetworkV1().VirtualRouter().Delete(context.Background(), &obj.ObjectMeta)
		return err
	}

	api.ct.handleVirtualRouterEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Deleted})
	return nil
}

// MakeKey generates a KV store key for the object
func (api *virtualrouterAPI) getFullKey(tenant, name string) string {
	if tenant != "" {
		return fmt.Sprint(globals.ConfigRootPrefix, "/", "network", "/", "virtualrouters", "/", tenant, "/", name)
	}
	return fmt.Sprint(globals.ConfigRootPrefix, "/", "network", "/", "virtualrouters", "/", name)
}

// Find returns an object by meta
func (api *virtualrouterAPI) Find(meta *api.ObjectMeta) (*VirtualRouter, error) {
	// find the object
	obj, err := api.ct.FindObject("VirtualRouter", meta)
	if err != nil {
		return nil, err
	}

	// asset type
	switch obj.(type) {
	case *VirtualRouter:
		hobj := obj.(*VirtualRouter)
		return hobj, nil
	default:
		return nil, errors.New("incorrect object type")
	}
}

// List returns a list of all VirtualRouter objects
func (api *virtualrouterAPI) List(ctx context.Context, opts *api.ListWatchOptions) ([]*VirtualRouter, error) {
	var objlist []*VirtualRouter
	objs, err := api.ct.List("VirtualRouter", ctx, opts)

	if err != nil {
		return nil, err
	}

	for _, obj := range objs {
		switch tp := obj.(type) {
		case *VirtualRouter:
			eobj := obj.(*VirtualRouter)
			objlist = append(objlist, eobj)
		default:
			log.Fatalf("Got invalid object type %v while looking for VirtualRouter", tp)
		}
	}

	return objlist, nil
}

// Watch sets up a event handlers for VirtualRouter object
func (api *virtualrouterAPI) Watch(handler VirtualRouterHandler) error {
	api.ct.startWorkerPool("VirtualRouter")
	return api.ct.WatchVirtualRouter(handler)
}

// StopWatch stop watch for Tenant VirtualRouter object
func (api *virtualrouterAPI) StopWatch(handler VirtualRouterHandler) error {
	api.ct.Lock()
	api.ct.workPools["VirtualRouter"].Stop()
	api.ct.Unlock()
	return api.ct.StopWatchVirtualRouter(handler)
}

// VirtualRouter returns VirtualRouterAPI
func (ct *ctrlerCtx) VirtualRouter() VirtualRouterAPI {
	kind := "VirtualRouter"
	if _, ok := ct.apiInfMap[kind]; !ok {
		s := &virtualrouterAPI{ct: ct}
		ct.apiInfMap[kind] = s
	}
	return ct.apiInfMap[kind].(*virtualrouterAPI)
}

// NetworkInterface is a wrapper object that implements additional functionality
type NetworkInterface struct {
	sync.Mutex
	network.NetworkInterface
	HandlerCtx interface{} // additional state handlers can store
	ctrler     *ctrlerCtx  // reference back to the controller instance
}

func (obj *NetworkInterface) Write() error {
	// if there is no API server to connect to, we are done
	if (obj.ctrler == nil) || (obj.ctrler.resolver == nil) || obj.ctrler.apisrvURL == "" {
		return nil
	}

	apicl, err := obj.ctrler.apiClient()
	if err != nil {
		obj.ctrler.logger.Errorf("Error creating API server clent. Err: %v", err)
		return err
	}

	obj.ctrler.stats.Counter("NetworkInterface_Writes").Inc()

	// write to api server
	if obj.ObjectMeta.ResourceVersion != "" {
		// update it
		for i := 0; i < maxApisrvWriteRetry; i++ {
			_, err = apicl.NetworkV1().NetworkInterface().UpdateStatus(context.Background(), &obj.NetworkInterface)
			if err == nil {
				break
			}
			time.Sleep(time.Millisecond * 100)
		}
	} else {
		//  create
		_, err = apicl.NetworkV1().NetworkInterface().Create(context.Background(), &obj.NetworkInterface)
	}

	return nil
}

// NetworkInterfaceHandler is the event handler for NetworkInterface object
type NetworkInterfaceHandler interface {
	OnNetworkInterfaceCreate(obj *NetworkInterface) error
	OnNetworkInterfaceUpdate(oldObj *NetworkInterface, newObj *network.NetworkInterface) error
	OnNetworkInterfaceDelete(obj *NetworkInterface) error
	GetNetworkInterfaceWatchOptions() *api.ListWatchOptions
	OnNetworkInterfaceReconnect()
}

// OnNetworkInterfaceCreate is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnNetworkInterfaceCreate(obj *NetworkInterface) error {
	log.Info("OnNetworkInterfaceCreate is not implemented")
	return nil
}

// OnNetworkInterfaceUpdate is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnNetworkInterfaceUpdate(oldObj *NetworkInterface, newObj *network.NetworkInterface) error {
	log.Info("OnNetworkInterfaceUpdate is not implemented")
	return nil
}

// OnNetworkInterfaceDelete is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnNetworkInterfaceDelete(obj *NetworkInterface) error {
	log.Info("OnNetworkInterfaceDelete is not implemented")
	return nil
}

// GetNetworkInterfaceWatchOptions is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) GetNetworkInterfaceWatchOptions() *api.ListWatchOptions {
	log.Info("GetNetworkInterfaceWatchOptions is not implemented")
	opts := &api.ListWatchOptions{}
	return opts
}

// OnNetworkInterfaceReconnect is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnNetworkInterfaceReconnect() {
	log.Info("OnNetworkInterfaceReconnect is not implemented")
	return
}

// handleNetworkInterfaceEvent handles NetworkInterface events from watcher
func (ct *ctrlerCtx) handleNetworkInterfaceEvent(evt *kvstore.WatchEvent) error {

	if ct.objResolver == nil {
		return ct.handleNetworkInterfaceEventNoResolver(evt)
	}

	switch tp := evt.Object.(type) {
	case *network.NetworkInterface:
		eobj := evt.Object.(*network.NetworkInterface)
		kind := "NetworkInterface"

		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ctx := &networkinterfaceCtx{event: evt.Type,
			obj: &NetworkInterface{NetworkInterface: *eobj, ctrler: ct}}

		var err error
		switch evt.Type {
		case kvstore.Created:
			err = ct.processAdd(ctx)
		case kvstore.Updated:
			err = ct.processUpdate(ctx)
		case kvstore.Deleted:
			err = ct.processDelete(ctx)
		}
		return err
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on NetworkInterface watch channel", tp)
	}

	return nil
}

// handleNetworkInterfaceEventNoResolver handles NetworkInterface events from watcher
func (ct *ctrlerCtx) handleNetworkInterfaceEventNoResolver(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *network.NetworkInterface:
		eobj := evt.Object.(*network.NetworkInterface)
		kind := "NetworkInterface"

		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		networkinterfaceHandler := handler.(NetworkInterfaceHandler)
		// handle based on event type
		ctrlCtx := &networkinterfaceCtx{event: evt.Type, obj: &NetworkInterface{NetworkInterface: *eobj, ctrler: ct}}
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			fobj, err := ct.getObject(kind, ctrlCtx.GetKey())
			if err != nil {
				ct.addObject(ctrlCtx)
				ct.stats.Counter("NetworkInterface_Created_Events").Inc()

				// call the event handler
				ctrlCtx.Lock()
				err = networkinterfaceHandler.OnNetworkInterfaceCreate(ctrlCtx.obj)
				ctrlCtx.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctrlCtx.obj, err)
					ct.delObject(kind, ctrlCtx.GetKey())
					return err
				}
			} else {
				fResVer, fErr := strconv.ParseInt(fobj.GetResourceVersion(), 10, 64)
				eResVer, eErr := strconv.ParseInt(eobj.GetResourceVersion(), 10, 64)
				if ct.resolver != nil && fErr == nil && eErr == nil && fResVer >= eResVer {
					// Event already processed.
					ct.logger.Infof("Skipping update due to old resource version")
					return nil
				}
				ctrlCtx := fobj.(*networkinterfaceCtx)
				ct.stats.Counter("NetworkInterface_Updated_Events").Inc()
				ctrlCtx.Lock()
				p := network.NetworkInterface{Spec: eobj.Spec,
					ObjectMeta: eobj.ObjectMeta,
					TypeMeta:   eobj.TypeMeta,
					Status:     eobj.Status}

				err = networkinterfaceHandler.OnNetworkInterfaceUpdate(ctrlCtx.obj, &p)
				ctrlCtx.obj.NetworkInterface = *eobj
				ctrlCtx.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctrlCtx.obj, err)
					return err
				}

			}
		case kvstore.Deleted:
			ctrlCtx := &networkinterfaceCtx{event: evt.Type, obj: &NetworkInterface{NetworkInterface: *eobj, ctrler: ct}}
			fobj, err := ct.findObject(kind, ctrlCtx.GetKey())
			if err != nil {
				ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
				return err
			}

			obj := fobj.(*NetworkInterface)
			ct.stats.Counter("NetworkInterface_Deleted_Events").Inc()
			obj.Lock()
			err = networkinterfaceHandler.OnNetworkInterfaceDelete(obj)
			obj.Unlock()
			if err != nil {
				ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
			}
			ct.delObject(kind, ctrlCtx.GetKey())
			return nil

		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on NetworkInterface watch channel", tp)
	}

	return nil
}

type networkinterfaceCtx struct {
	ctkitBaseCtx
	event kvstore.WatchEventType
	obj   *NetworkInterface //
	//   newObj     *network.NetworkInterface //update
	newObj *networkinterfaceCtx //update
}

func (ctx *networkinterfaceCtx) References() map[string]apiintf.ReferenceObj {
	resp := make(map[string]apiintf.ReferenceObj)
	ctx.obj.References(ctx.obj.GetObjectMeta().Name, ctx.obj.GetObjectMeta().Namespace, resp)
	return resp
}

func (ctx *networkinterfaceCtx) GetKey() string {
	return ctx.obj.MakeKey("network")
}

func (ctx *networkinterfaceCtx) GetKind() string {
	return ctx.obj.GetKind()
}

func (ctx *networkinterfaceCtx) GetResourceVersion() string {
	return ctx.obj.GetResourceVersion()
}

func (ctx *networkinterfaceCtx) SetEvent(event kvstore.WatchEventType) {
	ctx.event = event
}

func (ctx *networkinterfaceCtx) SetNewObj(newObj apiintf.CtkitObject) {
	if newObj == nil {
		ctx.newObj = nil
	} else {
		ctx.newObj = newObj.(*networkinterfaceCtx)
		ctx.newObj.obj.HandlerCtx = ctx.obj.HandlerCtx
	}
}

func (ctx *networkinterfaceCtx) GetNewObj() apiintf.CtkitObject {
	return ctx.newObj
}

func (ctx *networkinterfaceCtx) Copy(obj apiintf.CtkitObject) {
	ctx.obj.NetworkInterface = obj.(*networkinterfaceCtx).obj.NetworkInterface
}

func (ctx *networkinterfaceCtx) Lock() {
	ctx.obj.Lock()
}

func (ctx *networkinterfaceCtx) Unlock() {
	ctx.obj.Unlock()
}

func (ctx *networkinterfaceCtx) GetObjectMeta() *api.ObjectMeta {
	return ctx.obj.GetObjectMeta()
}

func (ctx *networkinterfaceCtx) RuntimeObject() runtime.Object {
	var v interface{}
	v = ctx.obj
	return v.(runtime.Object)
}

func (ctx *networkinterfaceCtx) WorkFunc(context context.Context) error {
	var err error
	evt := ctx.event
	ct := ctx.obj.ctrler
	kind := "NetworkInterface"
	ct.Lock()
	handler, ok := ct.handlers[kind]
	ct.Unlock()
	if !ok {
		ct.logger.Fatalf("Cant find the handler for %s", kind)
	}
	networkinterfaceHandler := handler.(NetworkInterfaceHandler)
	switch evt {
	case kvstore.Created:
		ctx.obj.Lock()
		err = networkinterfaceHandler.OnNetworkInterfaceCreate(ctx.obj)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctx.obj, err)
			ctx.SetEvent(kvstore.Deleted)
		}
	case kvstore.Updated:
		ct.stats.Counter("NetworkInterface_Updated_Events").Inc()
		ctx.obj.Lock()
		p := network.NetworkInterface{Spec: ctx.newObj.obj.Spec,
			ObjectMeta: ctx.newObj.obj.ObjectMeta,
			TypeMeta:   ctx.newObj.obj.TypeMeta,
			Status:     ctx.newObj.obj.Status}
		err = networkinterfaceHandler.OnNetworkInterfaceUpdate(ctx.obj, &p)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctx.obj, err)
			ctx.SetEvent(kvstore.Deleted)
		}
	case kvstore.Deleted:
		ctx.obj.Lock()
		err = networkinterfaceHandler.OnNetworkInterfaceDelete(ctx.obj)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error deleting %s %+v. Err: %v", kind, ctx.obj, err)
		}
	}
	ct.resolveObject(ctx.event, ctx)
	return nil
}

// handleNetworkInterfaceEventParallel handles NetworkInterface events from watcher
func (ct *ctrlerCtx) handleNetworkInterfaceEventParallel(evt *kvstore.WatchEvent) error {

	if ct.objResolver == nil {
		return ct.handleNetworkInterfaceEventParallelWithNoResolver(evt)
	}

	switch tp := evt.Object.(type) {
	case *network.NetworkInterface:
		eobj := evt.Object.(*network.NetworkInterface)
		kind := "NetworkInterface"

		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ctx := &networkinterfaceCtx{event: evt.Type, obj: &NetworkInterface{NetworkInterface: *eobj, ctrler: ct}}

		var err error
		switch evt.Type {
		case kvstore.Created:
			err = ct.processAdd(ctx)
		case kvstore.Updated:
			err = ct.processUpdate(ctx)
		case kvstore.Deleted:
			err = ct.processDelete(ctx)
		}
		return err
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on NetworkInterface watch channel", tp)
	}

	return nil
}

// handleNetworkInterfaceEventParallel handles NetworkInterface events from watcher
func (ct *ctrlerCtx) handleNetworkInterfaceEventParallelWithNoResolver(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *network.NetworkInterface:
		eobj := evt.Object.(*network.NetworkInterface)
		kind := "NetworkInterface"

		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		networkinterfaceHandler := handler.(NetworkInterfaceHandler)
		// handle based on event type
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			workFunc := func(ctx context.Context, ctrlCtx shardworkers.WorkObj) error {
				var err error
				workCtx := ctrlCtx.(*networkinterfaceCtx)
				eobj := workCtx.obj
				fobj, err := ct.getObject(kind, workCtx.GetKey())
				if err != nil {
					ct.addObject(workCtx)
					ct.stats.Counter("NetworkInterface_Created_Events").Inc()
					eobj.Lock()
					err = networkinterfaceHandler.OnNetworkInterfaceCreate(eobj)
					eobj.Unlock()
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, eobj, err)
						ct.delObject(kind, workCtx.GetKey())
					}
				} else {
					workCtx := fobj.(*networkinterfaceCtx)
					obj := workCtx.obj
					ct.stats.Counter("NetworkInterface_Updated_Events").Inc()
					obj.Lock()
					p := network.NetworkInterface{Spec: eobj.Spec,
						ObjectMeta: eobj.ObjectMeta,
						TypeMeta:   eobj.TypeMeta,
						Status:     eobj.Status}

					err = networkinterfaceHandler.OnNetworkInterfaceUpdate(obj, &p)
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					} else {
						workCtx.obj.NetworkInterface = p
					}
					obj.Unlock()
				}
				return err
			}
			ctrlCtx := &networkinterfaceCtx{event: evt.Type, obj: &NetworkInterface{NetworkInterface: *eobj, ctrler: ct}}
			ct.runFunction("NetworkInterface", ctrlCtx, workFunc)
		case kvstore.Deleted:
			workFunc := func(ctx context.Context, ctrlCtx shardworkers.WorkObj) error {
				var err error
				workCtx := ctrlCtx.(*networkinterfaceCtx)
				eobj := workCtx.obj
				fobj, err := ct.findObject(kind, workCtx.GetKey())
				if err != nil {
					ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
					return err
				}
				obj := fobj.(*NetworkInterface)
				ct.stats.Counter("NetworkInterface_Deleted_Events").Inc()
				obj.Lock()
				err = networkinterfaceHandler.OnNetworkInterfaceDelete(obj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
				}
				ct.delObject(kind, workCtx.GetKey())
				return nil
			}
			ctrlCtx := &networkinterfaceCtx{event: evt.Type, obj: &NetworkInterface{NetworkInterface: *eobj, ctrler: ct}}
			ct.runFunction("NetworkInterface", ctrlCtx, workFunc)
		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on NetworkInterface watch channel", tp)
	}

	return nil
}

// diffNetworkInterface does a diff of NetworkInterface objects between local cache and API server
func (ct *ctrlerCtx) diffNetworkInterface(apicl apiclient.Services) {
	opts := api.ListWatchOptions{}

	// get a list of all objects from API server
	objlist, err := apicl.NetworkV1().NetworkInterface().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Errorf("Error getting a list of objects. Err: %v", err)
		return
	}

	ct.logger.Infof("diffNetworkInterface(): NetworkInterfaceList returned %d objects", len(objlist))

	// build an object map
	objmap := make(map[string]*network.NetworkInterface)
	for _, obj := range objlist {
		objmap[obj.GetKey()] = obj
	}

	list, err := ct.NetworkInterface().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Infof("Failed to get a list of objects. Err: %s", err)
		return
	}

	// if an object is in our local cache and not in API server, trigger delete for it
	for _, obj := range list {
		_, ok := objmap[obj.GetKey()]
		if !ok {
			ct.logger.Infof("diffNetworkInterface(): Deleting existing object %#v since its not in apiserver", obj.GetKey())
			evt := kvstore.WatchEvent{
				Type:   kvstore.Deleted,
				Key:    obj.GetKey(),
				Object: &obj.NetworkInterface,
			}
			ct.handleNetworkInterfaceEvent(&evt)
		}
	}

	// trigger create event for all others
	for _, obj := range objlist {
		ct.logger.Infof("diffNetworkInterface(): Adding object %#v", obj.GetKey())
		evt := kvstore.WatchEvent{
			Type:   kvstore.Created,
			Key:    obj.GetKey(),
			Object: obj,
		}
		ct.handleNetworkInterfaceEvent(&evt)
	}
}

func (ct *ctrlerCtx) runNetworkInterfaceWatcher() {
	kind := "NetworkInterface"

	ct.Lock()
	handler, ok := ct.handlers[kind]
	ct.Unlock()
	if !ok {
		ct.logger.Fatalf("Cant find the handler for %s", kind)
	}
	networkinterfaceHandler := handler.(NetworkInterfaceHandler)

	opts := networkinterfaceHandler.GetNetworkInterfaceWatchOptions()

	// if there is no API server to connect to, we are done
	if (ct.resolver == nil) || ct.apisrvURL == "" {
		return
	}

	// create context
	ctx, cancel := context.WithCancel(context.Background())
	ct.Lock()
	ct.watchCancel[kind] = cancel
	ct.Unlock()
	logger := ct.logger.WithContext("submodule", "NetworkInterfaceWatcher")
	for {
		if ctx.Err() != nil {
			return
		}

		apiclt, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
		// create a grpc client
		if err == nil {
			// Upon successful connection perform the diff, and start watch goroutine
			ct.diffNetworkInterface(apiclt)
			break
		}

		logger.Warnf("Failed to connect to gRPC server [%s]\n", ct.apisrvURL)
		time.Sleep(time.Second)
	}

	// setup wait group
	ct.waitGrp.Add(1)

	// start a goroutine
	go func() {
		defer ct.waitGrp.Done()
		ct.stats.Counter("NetworkInterface_Watch").Inc()
		defer ct.stats.Counter("NetworkInterface_Watch").Dec()

		// loop forever
		for {
			// create a grpc client
			apicl, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
			if err != nil {
				logger.Warnf("Failed to connect to gRPC server [%s]\n", ct.apisrvURL)
				ct.stats.Counter("NetworkInterface_ApiClientErr").Inc()
			} else {
				logger.Infof("API client connected {%+v}", apicl)

				// NetworkInterface object watcher
				wt, werr := apicl.NetworkV1().NetworkInterface().Watch(ctx, opts)
				if werr != nil {
					select {
					case <-ctx.Done():
						logger.Infof("watch %s cancelled", kind)
						return
					default:
					}
					logger.Errorf("Failed to start %s watch (%s)\n", kind, werr)
					// wait for a second and retry connecting to api server
					apicl.Close()
					time.Sleep(time.Second)
					continue
				}
				ct.Lock()
				ct.watchers[kind] = wt
				ct.Unlock()

				// perform a diff with API server and local cache
				time.Sleep(time.Millisecond * 100)
				ct.diffNetworkInterface(apicl)
				networkinterfaceHandler.OnNetworkInterfaceReconnect()

				// handle api server watch events
			innerLoop:
				for {
					// wait for events
					select {
					case evt, ok := <-wt.EventChan():
						if !ok {
							logger.Error("Error receiving from apisrv watcher")
							ct.stats.Counter("NetworkInterface_WatchErrors").Inc()
							break innerLoop
						}

						// handle event in parallel
						ct.handleNetworkInterfaceEventParallel(evt)
					}
				}
				apicl.Close()
			}

			// if stop flag is set, we are done
			if ct.stoped {
				logger.Infof("Exiting API server watcher")
				return
			}

			// wait for a second and retry connecting to api server
			time.Sleep(time.Second)
		}
	}()
}

// WatchNetworkInterface starts watch on NetworkInterface object
func (ct *ctrlerCtx) WatchNetworkInterface(handler NetworkInterfaceHandler) error {
	kind := "NetworkInterface"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchers[kind]
	ct.Unlock()
	if ok {
		return fmt.Errorf("NetworkInterface watcher already exists")
	}

	// save handler
	ct.Lock()
	ct.handlers[kind] = handler
	ct.Unlock()

	// run NetworkInterface watcher in a go routine
	ct.runNetworkInterfaceWatcher()

	return nil
}

// StopWatchNetworkInterface stops watch on NetworkInterface object
func (ct *ctrlerCtx) StopWatchNetworkInterface(handler NetworkInterfaceHandler) error {
	kind := "NetworkInterface"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchers[kind]
	ct.Unlock()
	if !ok {
		return fmt.Errorf("NetworkInterface watcher does not exist")
	}

	ct.Lock()
	cancel, _ := ct.watchCancel[kind]
	cancel()
	delete(ct.watchers, kind)
	delete(ct.watchCancel, kind)
	ct.Unlock()

	time.Sleep(100 * time.Millisecond)

	return nil
}

// NetworkInterfaceAPI returns
type NetworkInterfaceAPI interface {
	Create(obj *network.NetworkInterface) error
	SyncCreate(obj *network.NetworkInterface) error
	Update(obj *network.NetworkInterface) error
	SyncUpdate(obj *network.NetworkInterface) error
	Delete(obj *network.NetworkInterface) error
	Find(meta *api.ObjectMeta) (*NetworkInterface, error)
	List(ctx context.Context, opts *api.ListWatchOptions) ([]*NetworkInterface, error)
	Watch(handler NetworkInterfaceHandler) error
	StopWatch(handler NetworkInterfaceHandler) error
}

// dummy struct that implements NetworkInterfaceAPI
type networkinterfaceAPI struct {
	ct *ctrlerCtx
}

// Create creates NetworkInterface object
func (api *networkinterfaceAPI) Create(obj *network.NetworkInterface) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.NetworkV1().NetworkInterface().Create(context.Background(), obj)
		if err != nil && strings.Contains(err.Error(), "AlreadyExists") {
			_, err = apicl.NetworkV1().NetworkInterface().UpdateStatus(context.Background(), obj)

		}
		return err
	}

	api.ct.handleNetworkInterfaceEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Created})
	return nil
}

// SyncCreate creates NetworkInterface object and updates the cache
func (api *networkinterfaceAPI) SyncCreate(obj *network.NetworkInterface) error {
	newObj := obj
	evtType := kvstore.Created
	var writeErr error
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		newObj, writeErr = apicl.NetworkV1().NetworkInterface().Create(context.Background(), obj)
		if writeErr != nil && strings.Contains(writeErr.Error(), "AlreadyExists") {
			newObj, writeErr = apicl.NetworkV1().NetworkInterface().UpdateStatus(context.Background(), obj)
			evtType = kvstore.Updated
		}
	}

	if writeErr == nil {
		api.ct.handleNetworkInterfaceEvent(&kvstore.WatchEvent{Object: newObj, Type: evtType})
	}
	return writeErr
}

// Update triggers update on NetworkInterface object
func (api *networkinterfaceAPI) Update(obj *network.NetworkInterface) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.NetworkV1().NetworkInterface().Update(context.Background(), obj)
		return err
	}

	api.ct.handleNetworkInterfaceEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Updated})
	return nil
}

// SyncUpdate triggers update on NetworkInterface object and updates the cache
func (api *networkinterfaceAPI) SyncUpdate(obj *network.NetworkInterface) error {
	newObj := obj
	var writeErr error
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		newObj, writeErr = apicl.NetworkV1().NetworkInterface().Update(context.Background(), obj)
	}

	if writeErr == nil {
		api.ct.handleNetworkInterfaceEvent(&kvstore.WatchEvent{Object: newObj, Type: kvstore.Updated})
	}

	return writeErr
}

// Delete deletes NetworkInterface object
func (api *networkinterfaceAPI) Delete(obj *network.NetworkInterface) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.NetworkV1().NetworkInterface().Delete(context.Background(), &obj.ObjectMeta)
		return err
	}

	api.ct.handleNetworkInterfaceEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Deleted})
	return nil
}

// MakeKey generates a KV store key for the object
func (api *networkinterfaceAPI) getFullKey(tenant, name string) string {
	if tenant != "" {
		return fmt.Sprint(globals.ConfigRootPrefix, "/", "network", "/", "networkinterfaces", "/", tenant, "/", name)
	}
	return fmt.Sprint(globals.ConfigRootPrefix, "/", "network", "/", "networkinterfaces", "/", name)
}

// Find returns an object by meta
func (api *networkinterfaceAPI) Find(meta *api.ObjectMeta) (*NetworkInterface, error) {
	// find the object
	obj, err := api.ct.FindObject("NetworkInterface", meta)
	if err != nil {
		return nil, err
	}

	// asset type
	switch obj.(type) {
	case *NetworkInterface:
		hobj := obj.(*NetworkInterface)
		return hobj, nil
	default:
		return nil, errors.New("incorrect object type")
	}
}

// List returns a list of all NetworkInterface objects
func (api *networkinterfaceAPI) List(ctx context.Context, opts *api.ListWatchOptions) ([]*NetworkInterface, error) {
	var objlist []*NetworkInterface
	objs, err := api.ct.List("NetworkInterface", ctx, opts)

	if err != nil {
		return nil, err
	}

	for _, obj := range objs {
		switch tp := obj.(type) {
		case *NetworkInterface:
			eobj := obj.(*NetworkInterface)
			objlist = append(objlist, eobj)
		default:
			log.Fatalf("Got invalid object type %v while looking for NetworkInterface", tp)
		}
	}

	return objlist, nil
}

// Watch sets up a event handlers for NetworkInterface object
func (api *networkinterfaceAPI) Watch(handler NetworkInterfaceHandler) error {
	api.ct.startWorkerPool("NetworkInterface")
	return api.ct.WatchNetworkInterface(handler)
}

// StopWatch stop watch for Tenant NetworkInterface object
func (api *networkinterfaceAPI) StopWatch(handler NetworkInterfaceHandler) error {
	api.ct.Lock()
	api.ct.workPools["NetworkInterface"].Stop()
	api.ct.Unlock()
	return api.ct.StopWatchNetworkInterface(handler)
}

// NetworkInterface returns NetworkInterfaceAPI
func (ct *ctrlerCtx) NetworkInterface() NetworkInterfaceAPI {
	kind := "NetworkInterface"
	if _, ok := ct.apiInfMap[kind]; !ok {
		s := &networkinterfaceAPI{ct: ct}
		ct.apiInfMap[kind] = s
	}
	return ct.apiInfMap[kind].(*networkinterfaceAPI)
}

// IPAMPolicy is a wrapper object that implements additional functionality
type IPAMPolicy struct {
	sync.Mutex
	network.IPAMPolicy
	HandlerCtx interface{} // additional state handlers can store
	ctrler     *ctrlerCtx  // reference back to the controller instance
}

func (obj *IPAMPolicy) Write() error {
	// if there is no API server to connect to, we are done
	if (obj.ctrler == nil) || (obj.ctrler.resolver == nil) || obj.ctrler.apisrvURL == "" {
		return nil
	}

	apicl, err := obj.ctrler.apiClient()
	if err != nil {
		obj.ctrler.logger.Errorf("Error creating API server clent. Err: %v", err)
		return err
	}

	obj.ctrler.stats.Counter("IPAMPolicy_Writes").Inc()

	// write to api server
	if obj.ObjectMeta.ResourceVersion != "" {
		// update it
		for i := 0; i < maxApisrvWriteRetry; i++ {
			_, err = apicl.NetworkV1().IPAMPolicy().UpdateStatus(context.Background(), &obj.IPAMPolicy)
			if err == nil {
				break
			}
			time.Sleep(time.Millisecond * 100)
		}
	} else {
		//  create
		_, err = apicl.NetworkV1().IPAMPolicy().Create(context.Background(), &obj.IPAMPolicy)
	}

	return nil
}

// IPAMPolicyHandler is the event handler for IPAMPolicy object
type IPAMPolicyHandler interface {
	OnIPAMPolicyCreate(obj *IPAMPolicy) error
	OnIPAMPolicyUpdate(oldObj *IPAMPolicy, newObj *network.IPAMPolicy) error
	OnIPAMPolicyDelete(obj *IPAMPolicy) error
	GetIPAMPolicyWatchOptions() *api.ListWatchOptions
	OnIPAMPolicyReconnect()
}

// OnIPAMPolicyCreate is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnIPAMPolicyCreate(obj *IPAMPolicy) error {
	log.Info("OnIPAMPolicyCreate is not implemented")
	return nil
}

// OnIPAMPolicyUpdate is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnIPAMPolicyUpdate(oldObj *IPAMPolicy, newObj *network.IPAMPolicy) error {
	log.Info("OnIPAMPolicyUpdate is not implemented")
	return nil
}

// OnIPAMPolicyDelete is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnIPAMPolicyDelete(obj *IPAMPolicy) error {
	log.Info("OnIPAMPolicyDelete is not implemented")
	return nil
}

// GetIPAMPolicyWatchOptions is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) GetIPAMPolicyWatchOptions() *api.ListWatchOptions {
	log.Info("GetIPAMPolicyWatchOptions is not implemented")
	opts := &api.ListWatchOptions{}
	return opts
}

// OnIPAMPolicyReconnect is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnIPAMPolicyReconnect() {
	log.Info("OnIPAMPolicyReconnect is not implemented")
	return
}

// handleIPAMPolicyEvent handles IPAMPolicy events from watcher
func (ct *ctrlerCtx) handleIPAMPolicyEvent(evt *kvstore.WatchEvent) error {

	if ct.objResolver == nil {
		return ct.handleIPAMPolicyEventNoResolver(evt)
	}

	switch tp := evt.Object.(type) {
	case *network.IPAMPolicy:
		eobj := evt.Object.(*network.IPAMPolicy)
		kind := "IPAMPolicy"

		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ctx := &ipampolicyCtx{event: evt.Type,
			obj: &IPAMPolicy{IPAMPolicy: *eobj, ctrler: ct}}

		var err error
		switch evt.Type {
		case kvstore.Created:
			err = ct.processAdd(ctx)
		case kvstore.Updated:
			err = ct.processUpdate(ctx)
		case kvstore.Deleted:
			err = ct.processDelete(ctx)
		}
		return err
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on IPAMPolicy watch channel", tp)
	}

	return nil
}

// handleIPAMPolicyEventNoResolver handles IPAMPolicy events from watcher
func (ct *ctrlerCtx) handleIPAMPolicyEventNoResolver(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *network.IPAMPolicy:
		eobj := evt.Object.(*network.IPAMPolicy)
		kind := "IPAMPolicy"

		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		ipampolicyHandler := handler.(IPAMPolicyHandler)
		// handle based on event type
		ctrlCtx := &ipampolicyCtx{event: evt.Type, obj: &IPAMPolicy{IPAMPolicy: *eobj, ctrler: ct}}
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			fobj, err := ct.getObject(kind, ctrlCtx.GetKey())
			if err != nil {
				ct.addObject(ctrlCtx)
				ct.stats.Counter("IPAMPolicy_Created_Events").Inc()

				// call the event handler
				ctrlCtx.Lock()
				err = ipampolicyHandler.OnIPAMPolicyCreate(ctrlCtx.obj)
				ctrlCtx.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctrlCtx.obj, err)
					ct.delObject(kind, ctrlCtx.GetKey())
					return err
				}
			} else {
				fResVer, fErr := strconv.ParseInt(fobj.GetResourceVersion(), 10, 64)
				eResVer, eErr := strconv.ParseInt(eobj.GetResourceVersion(), 10, 64)
				if ct.resolver != nil && fErr == nil && eErr == nil && fResVer >= eResVer {
					// Event already processed.
					ct.logger.Infof("Skipping update due to old resource version")
					return nil
				}
				ctrlCtx := fobj.(*ipampolicyCtx)
				ct.stats.Counter("IPAMPolicy_Updated_Events").Inc()
				ctrlCtx.Lock()
				p := network.IPAMPolicy{Spec: eobj.Spec,
					ObjectMeta: eobj.ObjectMeta,
					TypeMeta:   eobj.TypeMeta,
					Status:     eobj.Status}

				err = ipampolicyHandler.OnIPAMPolicyUpdate(ctrlCtx.obj, &p)
				ctrlCtx.obj.IPAMPolicy = *eobj
				ctrlCtx.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctrlCtx.obj, err)
					return err
				}

			}
		case kvstore.Deleted:
			ctrlCtx := &ipampolicyCtx{event: evt.Type, obj: &IPAMPolicy{IPAMPolicy: *eobj, ctrler: ct}}
			fobj, err := ct.findObject(kind, ctrlCtx.GetKey())
			if err != nil {
				ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
				return err
			}

			obj := fobj.(*IPAMPolicy)
			ct.stats.Counter("IPAMPolicy_Deleted_Events").Inc()
			obj.Lock()
			err = ipampolicyHandler.OnIPAMPolicyDelete(obj)
			obj.Unlock()
			if err != nil {
				ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
			}
			ct.delObject(kind, ctrlCtx.GetKey())
			return nil

		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on IPAMPolicy watch channel", tp)
	}

	return nil
}

type ipampolicyCtx struct {
	ctkitBaseCtx
	event kvstore.WatchEventType
	obj   *IPAMPolicy //
	//   newObj     *network.IPAMPolicy //update
	newObj *ipampolicyCtx //update
}

func (ctx *ipampolicyCtx) References() map[string]apiintf.ReferenceObj {
	resp := make(map[string]apiintf.ReferenceObj)
	ctx.obj.References(ctx.obj.GetObjectMeta().Name, ctx.obj.GetObjectMeta().Namespace, resp)
	return resp
}

func (ctx *ipampolicyCtx) GetKey() string {
	return ctx.obj.MakeKey("network")
}

func (ctx *ipampolicyCtx) GetKind() string {
	return ctx.obj.GetKind()
}

func (ctx *ipampolicyCtx) GetResourceVersion() string {
	return ctx.obj.GetResourceVersion()
}

func (ctx *ipampolicyCtx) SetEvent(event kvstore.WatchEventType) {
	ctx.event = event
}

func (ctx *ipampolicyCtx) SetNewObj(newObj apiintf.CtkitObject) {
	if newObj == nil {
		ctx.newObj = nil
	} else {
		ctx.newObj = newObj.(*ipampolicyCtx)
		ctx.newObj.obj.HandlerCtx = ctx.obj.HandlerCtx
	}
}

func (ctx *ipampolicyCtx) GetNewObj() apiintf.CtkitObject {
	return ctx.newObj
}

func (ctx *ipampolicyCtx) Copy(obj apiintf.CtkitObject) {
	ctx.obj.IPAMPolicy = obj.(*ipampolicyCtx).obj.IPAMPolicy
}

func (ctx *ipampolicyCtx) Lock() {
	ctx.obj.Lock()
}

func (ctx *ipampolicyCtx) Unlock() {
	ctx.obj.Unlock()
}

func (ctx *ipampolicyCtx) GetObjectMeta() *api.ObjectMeta {
	return ctx.obj.GetObjectMeta()
}

func (ctx *ipampolicyCtx) RuntimeObject() runtime.Object {
	var v interface{}
	v = ctx.obj
	return v.(runtime.Object)
}

func (ctx *ipampolicyCtx) WorkFunc(context context.Context) error {
	var err error
	evt := ctx.event
	ct := ctx.obj.ctrler
	kind := "IPAMPolicy"
	ct.Lock()
	handler, ok := ct.handlers[kind]
	ct.Unlock()
	if !ok {
		ct.logger.Fatalf("Cant find the handler for %s", kind)
	}
	ipampolicyHandler := handler.(IPAMPolicyHandler)
	switch evt {
	case kvstore.Created:
		ctx.obj.Lock()
		err = ipampolicyHandler.OnIPAMPolicyCreate(ctx.obj)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctx.obj, err)
			ctx.SetEvent(kvstore.Deleted)
		}
	case kvstore.Updated:
		ct.stats.Counter("IPAMPolicy_Updated_Events").Inc()
		ctx.obj.Lock()
		p := network.IPAMPolicy{Spec: ctx.newObj.obj.Spec,
			ObjectMeta: ctx.newObj.obj.ObjectMeta,
			TypeMeta:   ctx.newObj.obj.TypeMeta,
			Status:     ctx.newObj.obj.Status}
		err = ipampolicyHandler.OnIPAMPolicyUpdate(ctx.obj, &p)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctx.obj, err)
			ctx.SetEvent(kvstore.Deleted)
		}
	case kvstore.Deleted:
		ctx.obj.Lock()
		err = ipampolicyHandler.OnIPAMPolicyDelete(ctx.obj)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error deleting %s %+v. Err: %v", kind, ctx.obj, err)
		}
	}
	ct.resolveObject(ctx.event, ctx)
	return nil
}

// handleIPAMPolicyEventParallel handles IPAMPolicy events from watcher
func (ct *ctrlerCtx) handleIPAMPolicyEventParallel(evt *kvstore.WatchEvent) error {

	if ct.objResolver == nil {
		return ct.handleIPAMPolicyEventParallelWithNoResolver(evt)
	}

	switch tp := evt.Object.(type) {
	case *network.IPAMPolicy:
		eobj := evt.Object.(*network.IPAMPolicy)
		kind := "IPAMPolicy"

		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ctx := &ipampolicyCtx{event: evt.Type, obj: &IPAMPolicy{IPAMPolicy: *eobj, ctrler: ct}}

		var err error
		switch evt.Type {
		case kvstore.Created:
			err = ct.processAdd(ctx)
		case kvstore.Updated:
			err = ct.processUpdate(ctx)
		case kvstore.Deleted:
			err = ct.processDelete(ctx)
		}
		return err
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on IPAMPolicy watch channel", tp)
	}

	return nil
}

// handleIPAMPolicyEventParallel handles IPAMPolicy events from watcher
func (ct *ctrlerCtx) handleIPAMPolicyEventParallelWithNoResolver(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *network.IPAMPolicy:
		eobj := evt.Object.(*network.IPAMPolicy)
		kind := "IPAMPolicy"

		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		ipampolicyHandler := handler.(IPAMPolicyHandler)
		// handle based on event type
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			workFunc := func(ctx context.Context, ctrlCtx shardworkers.WorkObj) error {
				var err error
				workCtx := ctrlCtx.(*ipampolicyCtx)
				eobj := workCtx.obj
				fobj, err := ct.getObject(kind, workCtx.GetKey())
				if err != nil {
					ct.addObject(workCtx)
					ct.stats.Counter("IPAMPolicy_Created_Events").Inc()
					eobj.Lock()
					err = ipampolicyHandler.OnIPAMPolicyCreate(eobj)
					eobj.Unlock()
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, eobj, err)
						ct.delObject(kind, workCtx.GetKey())
					}
				} else {
					workCtx := fobj.(*ipampolicyCtx)
					obj := workCtx.obj
					ct.stats.Counter("IPAMPolicy_Updated_Events").Inc()
					obj.Lock()
					p := network.IPAMPolicy{Spec: eobj.Spec,
						ObjectMeta: eobj.ObjectMeta,
						TypeMeta:   eobj.TypeMeta,
						Status:     eobj.Status}

					err = ipampolicyHandler.OnIPAMPolicyUpdate(obj, &p)
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					} else {
						workCtx.obj.IPAMPolicy = p
					}
					obj.Unlock()
				}
				return err
			}
			ctrlCtx := &ipampolicyCtx{event: evt.Type, obj: &IPAMPolicy{IPAMPolicy: *eobj, ctrler: ct}}
			ct.runFunction("IPAMPolicy", ctrlCtx, workFunc)
		case kvstore.Deleted:
			workFunc := func(ctx context.Context, ctrlCtx shardworkers.WorkObj) error {
				var err error
				workCtx := ctrlCtx.(*ipampolicyCtx)
				eobj := workCtx.obj
				fobj, err := ct.findObject(kind, workCtx.GetKey())
				if err != nil {
					ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
					return err
				}
				obj := fobj.(*IPAMPolicy)
				ct.stats.Counter("IPAMPolicy_Deleted_Events").Inc()
				obj.Lock()
				err = ipampolicyHandler.OnIPAMPolicyDelete(obj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
				}
				ct.delObject(kind, workCtx.GetKey())
				return nil
			}
			ctrlCtx := &ipampolicyCtx{event: evt.Type, obj: &IPAMPolicy{IPAMPolicy: *eobj, ctrler: ct}}
			ct.runFunction("IPAMPolicy", ctrlCtx, workFunc)
		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on IPAMPolicy watch channel", tp)
	}

	return nil
}

// diffIPAMPolicy does a diff of IPAMPolicy objects between local cache and API server
func (ct *ctrlerCtx) diffIPAMPolicy(apicl apiclient.Services) {
	opts := api.ListWatchOptions{}

	// get a list of all objects from API server
	objlist, err := apicl.NetworkV1().IPAMPolicy().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Errorf("Error getting a list of objects. Err: %v", err)
		return
	}

	ct.logger.Infof("diffIPAMPolicy(): IPAMPolicyList returned %d objects", len(objlist))

	// build an object map
	objmap := make(map[string]*network.IPAMPolicy)
	for _, obj := range objlist {
		objmap[obj.GetKey()] = obj
	}

	list, err := ct.IPAMPolicy().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Infof("Failed to get a list of objects. Err: %s", err)
		return
	}

	// if an object is in our local cache and not in API server, trigger delete for it
	for _, obj := range list {
		_, ok := objmap[obj.GetKey()]
		if !ok {
			ct.logger.Infof("diffIPAMPolicy(): Deleting existing object %#v since its not in apiserver", obj.GetKey())
			evt := kvstore.WatchEvent{
				Type:   kvstore.Deleted,
				Key:    obj.GetKey(),
				Object: &obj.IPAMPolicy,
			}
			ct.handleIPAMPolicyEvent(&evt)
		}
	}

	// trigger create event for all others
	for _, obj := range objlist {
		ct.logger.Infof("diffIPAMPolicy(): Adding object %#v", obj.GetKey())
		evt := kvstore.WatchEvent{
			Type:   kvstore.Created,
			Key:    obj.GetKey(),
			Object: obj,
		}
		ct.handleIPAMPolicyEvent(&evt)
	}
}

func (ct *ctrlerCtx) runIPAMPolicyWatcher() {
	kind := "IPAMPolicy"

	ct.Lock()
	handler, ok := ct.handlers[kind]
	ct.Unlock()
	if !ok {
		ct.logger.Fatalf("Cant find the handler for %s", kind)
	}
	ipampolicyHandler := handler.(IPAMPolicyHandler)

	opts := ipampolicyHandler.GetIPAMPolicyWatchOptions()

	// if there is no API server to connect to, we are done
	if (ct.resolver == nil) || ct.apisrvURL == "" {
		return
	}

	// create context
	ctx, cancel := context.WithCancel(context.Background())
	ct.Lock()
	ct.watchCancel[kind] = cancel
	ct.Unlock()
	logger := ct.logger.WithContext("submodule", "IPAMPolicyWatcher")
	for {
		if ctx.Err() != nil {
			return
		}

		apiclt, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
		// create a grpc client
		if err == nil {
			// Upon successful connection perform the diff, and start watch goroutine
			ct.diffIPAMPolicy(apiclt)
			break
		}

		logger.Warnf("Failed to connect to gRPC server [%s]\n", ct.apisrvURL)
		time.Sleep(time.Second)
	}

	// setup wait group
	ct.waitGrp.Add(1)

	// start a goroutine
	go func() {
		defer ct.waitGrp.Done()
		ct.stats.Counter("IPAMPolicy_Watch").Inc()
		defer ct.stats.Counter("IPAMPolicy_Watch").Dec()

		// loop forever
		for {
			// create a grpc client
			apicl, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
			if err != nil {
				logger.Warnf("Failed to connect to gRPC server [%s]\n", ct.apisrvURL)
				ct.stats.Counter("IPAMPolicy_ApiClientErr").Inc()
			} else {
				logger.Infof("API client connected {%+v}", apicl)

				// IPAMPolicy object watcher
				wt, werr := apicl.NetworkV1().IPAMPolicy().Watch(ctx, opts)
				if werr != nil {
					select {
					case <-ctx.Done():
						logger.Infof("watch %s cancelled", kind)
						return
					default:
					}
					logger.Errorf("Failed to start %s watch (%s)\n", kind, werr)
					// wait for a second and retry connecting to api server
					apicl.Close()
					time.Sleep(time.Second)
					continue
				}
				ct.Lock()
				ct.watchers[kind] = wt
				ct.Unlock()

				// perform a diff with API server and local cache
				time.Sleep(time.Millisecond * 100)
				ct.diffIPAMPolicy(apicl)
				ipampolicyHandler.OnIPAMPolicyReconnect()

				// handle api server watch events
			innerLoop:
				for {
					// wait for events
					select {
					case evt, ok := <-wt.EventChan():
						if !ok {
							logger.Error("Error receiving from apisrv watcher")
							ct.stats.Counter("IPAMPolicy_WatchErrors").Inc()
							break innerLoop
						}

						// handle event in parallel
						ct.handleIPAMPolicyEventParallel(evt)
					}
				}
				apicl.Close()
			}

			// if stop flag is set, we are done
			if ct.stoped {
				logger.Infof("Exiting API server watcher")
				return
			}

			// wait for a second and retry connecting to api server
			time.Sleep(time.Second)
		}
	}()
}

// WatchIPAMPolicy starts watch on IPAMPolicy object
func (ct *ctrlerCtx) WatchIPAMPolicy(handler IPAMPolicyHandler) error {
	kind := "IPAMPolicy"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchers[kind]
	ct.Unlock()
	if ok {
		return fmt.Errorf("IPAMPolicy watcher already exists")
	}

	// save handler
	ct.Lock()
	ct.handlers[kind] = handler
	ct.Unlock()

	// run IPAMPolicy watcher in a go routine
	ct.runIPAMPolicyWatcher()

	return nil
}

// StopWatchIPAMPolicy stops watch on IPAMPolicy object
func (ct *ctrlerCtx) StopWatchIPAMPolicy(handler IPAMPolicyHandler) error {
	kind := "IPAMPolicy"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchers[kind]
	ct.Unlock()
	if !ok {
		return fmt.Errorf("IPAMPolicy watcher does not exist")
	}

	ct.Lock()
	cancel, _ := ct.watchCancel[kind]
	cancel()
	delete(ct.watchers, kind)
	delete(ct.watchCancel, kind)
	ct.Unlock()

	time.Sleep(100 * time.Millisecond)

	return nil
}

// IPAMPolicyAPI returns
type IPAMPolicyAPI interface {
	Create(obj *network.IPAMPolicy) error
	SyncCreate(obj *network.IPAMPolicy) error
	Update(obj *network.IPAMPolicy) error
	SyncUpdate(obj *network.IPAMPolicy) error
	Delete(obj *network.IPAMPolicy) error
	Find(meta *api.ObjectMeta) (*IPAMPolicy, error)
	List(ctx context.Context, opts *api.ListWatchOptions) ([]*IPAMPolicy, error)
	Watch(handler IPAMPolicyHandler) error
	StopWatch(handler IPAMPolicyHandler) error
}

// dummy struct that implements IPAMPolicyAPI
type ipampolicyAPI struct {
	ct *ctrlerCtx
}

// Create creates IPAMPolicy object
func (api *ipampolicyAPI) Create(obj *network.IPAMPolicy) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.NetworkV1().IPAMPolicy().Create(context.Background(), obj)
		if err != nil && strings.Contains(err.Error(), "AlreadyExists") {
			_, err = apicl.NetworkV1().IPAMPolicy().Update(context.Background(), obj)

		}
		return err
	}

	api.ct.handleIPAMPolicyEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Created})
	return nil
}

// SyncCreate creates IPAMPolicy object and updates the cache
func (api *ipampolicyAPI) SyncCreate(obj *network.IPAMPolicy) error {
	newObj := obj
	evtType := kvstore.Created
	var writeErr error
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		newObj, writeErr = apicl.NetworkV1().IPAMPolicy().Create(context.Background(), obj)
		if writeErr != nil && strings.Contains(writeErr.Error(), "AlreadyExists") {
			newObj, writeErr = apicl.NetworkV1().IPAMPolicy().Update(context.Background(), obj)
			evtType = kvstore.Updated
		}
	}

	if writeErr == nil {
		api.ct.handleIPAMPolicyEvent(&kvstore.WatchEvent{Object: newObj, Type: evtType})
	}
	return writeErr
}

// Update triggers update on IPAMPolicy object
func (api *ipampolicyAPI) Update(obj *network.IPAMPolicy) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.NetworkV1().IPAMPolicy().Update(context.Background(), obj)
		return err
	}

	api.ct.handleIPAMPolicyEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Updated})
	return nil
}

// SyncUpdate triggers update on IPAMPolicy object and updates the cache
func (api *ipampolicyAPI) SyncUpdate(obj *network.IPAMPolicy) error {
	newObj := obj
	var writeErr error
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		newObj, writeErr = apicl.NetworkV1().IPAMPolicy().Update(context.Background(), obj)
	}

	if writeErr == nil {
		api.ct.handleIPAMPolicyEvent(&kvstore.WatchEvent{Object: newObj, Type: kvstore.Updated})
	}

	return writeErr
}

// Delete deletes IPAMPolicy object
func (api *ipampolicyAPI) Delete(obj *network.IPAMPolicy) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.NetworkV1().IPAMPolicy().Delete(context.Background(), &obj.ObjectMeta)
		return err
	}

	api.ct.handleIPAMPolicyEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Deleted})
	return nil
}

// MakeKey generates a KV store key for the object
func (api *ipampolicyAPI) getFullKey(tenant, name string) string {
	if tenant != "" {
		return fmt.Sprint(globals.ConfigRootPrefix, "/", "network", "/", "ipam-policies", "/", tenant, "/", name)
	}
	return fmt.Sprint(globals.ConfigRootPrefix, "/", "network", "/", "ipam-policies", "/", name)
}

// Find returns an object by meta
func (api *ipampolicyAPI) Find(meta *api.ObjectMeta) (*IPAMPolicy, error) {
	// find the object
	obj, err := api.ct.FindObject("IPAMPolicy", meta)
	if err != nil {
		return nil, err
	}

	// asset type
	switch obj.(type) {
	case *IPAMPolicy:
		hobj := obj.(*IPAMPolicy)
		return hobj, nil
	default:
		return nil, errors.New("incorrect object type")
	}
}

// List returns a list of all IPAMPolicy objects
func (api *ipampolicyAPI) List(ctx context.Context, opts *api.ListWatchOptions) ([]*IPAMPolicy, error) {
	var objlist []*IPAMPolicy
	objs, err := api.ct.List("IPAMPolicy", ctx, opts)

	if err != nil {
		return nil, err
	}

	for _, obj := range objs {
		switch tp := obj.(type) {
		case *IPAMPolicy:
			eobj := obj.(*IPAMPolicy)
			objlist = append(objlist, eobj)
		default:
			log.Fatalf("Got invalid object type %v while looking for IPAMPolicy", tp)
		}
	}

	return objlist, nil
}

// Watch sets up a event handlers for IPAMPolicy object
func (api *ipampolicyAPI) Watch(handler IPAMPolicyHandler) error {
	api.ct.startWorkerPool("IPAMPolicy")
	return api.ct.WatchIPAMPolicy(handler)
}

// StopWatch stop watch for Tenant IPAMPolicy object
func (api *ipampolicyAPI) StopWatch(handler IPAMPolicyHandler) error {
	api.ct.Lock()
	api.ct.workPools["IPAMPolicy"].Stop()
	api.ct.Unlock()
	return api.ct.StopWatchIPAMPolicy(handler)
}

// IPAMPolicy returns IPAMPolicyAPI
func (ct *ctrlerCtx) IPAMPolicy() IPAMPolicyAPI {
	kind := "IPAMPolicy"
	if _, ok := ct.apiInfMap[kind]; !ok {
		s := &ipampolicyAPI{ct: ct}
		ct.apiInfMap[kind] = s
	}
	return ct.apiInfMap[kind].(*ipampolicyAPI)
}

// RoutingConfig is a wrapper object that implements additional functionality
type RoutingConfig struct {
	sync.Mutex
	network.RoutingConfig
	HandlerCtx interface{} // additional state handlers can store
	ctrler     *ctrlerCtx  // reference back to the controller instance
}

func (obj *RoutingConfig) Write() error {
	// if there is no API server to connect to, we are done
	if (obj.ctrler == nil) || (obj.ctrler.resolver == nil) || obj.ctrler.apisrvURL == "" {
		return nil
	}

	apicl, err := obj.ctrler.apiClient()
	if err != nil {
		obj.ctrler.logger.Errorf("Error creating API server clent. Err: %v", err)
		return err
	}

	obj.ctrler.stats.Counter("RoutingConfig_Writes").Inc()

	// write to api server
	if obj.ObjectMeta.ResourceVersion != "" {
		// update it
		for i := 0; i < maxApisrvWriteRetry; i++ {
			_, err = apicl.NetworkV1().RoutingConfig().UpdateStatus(context.Background(), &obj.RoutingConfig)
			if err == nil {
				break
			}
			time.Sleep(time.Millisecond * 100)
		}
	} else {
		//  create
		_, err = apicl.NetworkV1().RoutingConfig().Create(context.Background(), &obj.RoutingConfig)
	}

	return nil
}

// RoutingConfigHandler is the event handler for RoutingConfig object
type RoutingConfigHandler interface {
	OnRoutingConfigCreate(obj *RoutingConfig) error
	OnRoutingConfigUpdate(oldObj *RoutingConfig, newObj *network.RoutingConfig) error
	OnRoutingConfigDelete(obj *RoutingConfig) error
	GetRoutingConfigWatchOptions() *api.ListWatchOptions
	OnRoutingConfigReconnect()
}

// OnRoutingConfigCreate is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnRoutingConfigCreate(obj *RoutingConfig) error {
	log.Info("OnRoutingConfigCreate is not implemented")
	return nil
}

// OnRoutingConfigUpdate is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnRoutingConfigUpdate(oldObj *RoutingConfig, newObj *network.RoutingConfig) error {
	log.Info("OnRoutingConfigUpdate is not implemented")
	return nil
}

// OnRoutingConfigDelete is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnRoutingConfigDelete(obj *RoutingConfig) error {
	log.Info("OnRoutingConfigDelete is not implemented")
	return nil
}

// GetRoutingConfigWatchOptions is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) GetRoutingConfigWatchOptions() *api.ListWatchOptions {
	log.Info("GetRoutingConfigWatchOptions is not implemented")
	opts := &api.ListWatchOptions{}
	return opts
}

// OnRoutingConfigReconnect is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnRoutingConfigReconnect() {
	log.Info("OnRoutingConfigReconnect is not implemented")
	return
}

// handleRoutingConfigEvent handles RoutingConfig events from watcher
func (ct *ctrlerCtx) handleRoutingConfigEvent(evt *kvstore.WatchEvent) error {

	if ct.objResolver == nil {
		return ct.handleRoutingConfigEventNoResolver(evt)
	}

	switch tp := evt.Object.(type) {
	case *network.RoutingConfig:
		eobj := evt.Object.(*network.RoutingConfig)
		kind := "RoutingConfig"

		eobj.ApplyStorageTransformer(context.Background(), true /*encrypt*/)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		eobj.ApplyStorageTransformer(context.Background(), false /*decrypt*/)

		ctx := &routingconfigCtx{event: evt.Type,
			obj: &RoutingConfig{RoutingConfig: *eobj, ctrler: ct}}

		var err error
		switch evt.Type {
		case kvstore.Created:
			err = ct.processAdd(ctx)
		case kvstore.Updated:
			err = ct.processUpdate(ctx)
		case kvstore.Deleted:
			err = ct.processDelete(ctx)
		}
		return err
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on RoutingConfig watch channel", tp)
	}

	return nil
}

// handleRoutingConfigEventNoResolver handles RoutingConfig events from watcher
func (ct *ctrlerCtx) handleRoutingConfigEventNoResolver(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *network.RoutingConfig:
		eobj := evt.Object.(*network.RoutingConfig)
		kind := "RoutingConfig"

		eobj.ApplyStorageTransformer(context.Background(), true /*encrypt*/)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		eobj.ApplyStorageTransformer(context.Background(), false /*decrypt*/)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		routingconfigHandler := handler.(RoutingConfigHandler)
		// handle based on event type
		ctrlCtx := &routingconfigCtx{event: evt.Type, obj: &RoutingConfig{RoutingConfig: *eobj, ctrler: ct}}
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			fobj, err := ct.getObject(kind, ctrlCtx.GetKey())
			if err != nil {
				ct.addObject(ctrlCtx)
				ct.stats.Counter("RoutingConfig_Created_Events").Inc()

				// call the event handler
				ctrlCtx.Lock()
				err = routingconfigHandler.OnRoutingConfigCreate(ctrlCtx.obj)
				ctrlCtx.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctrlCtx.obj, err)
					ct.delObject(kind, ctrlCtx.GetKey())
					return err
				}
			} else {
				fResVer, fErr := strconv.ParseInt(fobj.GetResourceVersion(), 10, 64)
				eResVer, eErr := strconv.ParseInt(eobj.GetResourceVersion(), 10, 64)
				if ct.resolver != nil && fErr == nil && eErr == nil && fResVer >= eResVer {
					// Event already processed.
					ct.logger.Infof("Skipping update due to old resource version")
					return nil
				}
				ctrlCtx := fobj.(*routingconfigCtx)
				ct.stats.Counter("RoutingConfig_Updated_Events").Inc()
				ctrlCtx.Lock()
				p := network.RoutingConfig{Spec: eobj.Spec,
					ObjectMeta: eobj.ObjectMeta,
					TypeMeta:   eobj.TypeMeta,
					Status:     eobj.Status}

				err = routingconfigHandler.OnRoutingConfigUpdate(ctrlCtx.obj, &p)
				ctrlCtx.obj.RoutingConfig = *eobj
				ctrlCtx.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctrlCtx.obj, err)
					return err
				}

			}
		case kvstore.Deleted:
			ctrlCtx := &routingconfigCtx{event: evt.Type, obj: &RoutingConfig{RoutingConfig: *eobj, ctrler: ct}}
			fobj, err := ct.findObject(kind, ctrlCtx.GetKey())
			if err != nil {
				ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
				return err
			}

			obj := fobj.(*RoutingConfig)
			ct.stats.Counter("RoutingConfig_Deleted_Events").Inc()
			obj.Lock()
			err = routingconfigHandler.OnRoutingConfigDelete(obj)
			obj.Unlock()
			if err != nil {
				ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
			}
			ct.delObject(kind, ctrlCtx.GetKey())
			return nil

		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on RoutingConfig watch channel", tp)
	}

	return nil
}

type routingconfigCtx struct {
	ctkitBaseCtx
	event kvstore.WatchEventType
	obj   *RoutingConfig //
	//   newObj     *network.RoutingConfig //update
	newObj *routingconfigCtx //update
}

func (ctx *routingconfigCtx) References() map[string]apiintf.ReferenceObj {
	resp := make(map[string]apiintf.ReferenceObj)
	ctx.obj.References(ctx.obj.GetObjectMeta().Name, ctx.obj.GetObjectMeta().Namespace, resp)
	return resp
}

func (ctx *routingconfigCtx) GetKey() string {
	return ctx.obj.MakeKey("network")
}

func (ctx *routingconfigCtx) GetKind() string {
	return ctx.obj.GetKind()
}

func (ctx *routingconfigCtx) GetResourceVersion() string {
	return ctx.obj.GetResourceVersion()
}

func (ctx *routingconfigCtx) SetEvent(event kvstore.WatchEventType) {
	ctx.event = event
}

func (ctx *routingconfigCtx) SetNewObj(newObj apiintf.CtkitObject) {
	if newObj == nil {
		ctx.newObj = nil
	} else {
		ctx.newObj = newObj.(*routingconfigCtx)
		ctx.newObj.obj.HandlerCtx = ctx.obj.HandlerCtx
	}
}

func (ctx *routingconfigCtx) GetNewObj() apiintf.CtkitObject {
	return ctx.newObj
}

func (ctx *routingconfigCtx) Copy(obj apiintf.CtkitObject) {
	ctx.obj.RoutingConfig = obj.(*routingconfigCtx).obj.RoutingConfig
}

func (ctx *routingconfigCtx) Lock() {
	ctx.obj.Lock()
}

func (ctx *routingconfigCtx) Unlock() {
	ctx.obj.Unlock()
}

func (ctx *routingconfigCtx) GetObjectMeta() *api.ObjectMeta {
	return ctx.obj.GetObjectMeta()
}

func (ctx *routingconfigCtx) RuntimeObject() runtime.Object {
	var v interface{}
	v = ctx.obj
	return v.(runtime.Object)
}

func (ctx *routingconfigCtx) WorkFunc(context context.Context) error {
	var err error
	evt := ctx.event
	ct := ctx.obj.ctrler
	kind := "RoutingConfig"
	ct.Lock()
	handler, ok := ct.handlers[kind]
	ct.Unlock()
	if !ok {
		ct.logger.Fatalf("Cant find the handler for %s", kind)
	}
	routingconfigHandler := handler.(RoutingConfigHandler)
	switch evt {
	case kvstore.Created:
		ctx.obj.Lock()
		err = routingconfigHandler.OnRoutingConfigCreate(ctx.obj)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctx.obj, err)
			ctx.SetEvent(kvstore.Deleted)
		}
	case kvstore.Updated:
		ct.stats.Counter("RoutingConfig_Updated_Events").Inc()
		ctx.obj.Lock()
		p := network.RoutingConfig{Spec: ctx.newObj.obj.Spec,
			ObjectMeta: ctx.newObj.obj.ObjectMeta,
			TypeMeta:   ctx.newObj.obj.TypeMeta,
			Status:     ctx.newObj.obj.Status}
		err = routingconfigHandler.OnRoutingConfigUpdate(ctx.obj, &p)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctx.obj, err)
			ctx.SetEvent(kvstore.Deleted)
		}
	case kvstore.Deleted:
		ctx.obj.Lock()
		err = routingconfigHandler.OnRoutingConfigDelete(ctx.obj)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error deleting %s %+v. Err: %v", kind, ctx.obj, err)
		}
	}
	ct.resolveObject(ctx.event, ctx)
	return nil
}

// handleRoutingConfigEventParallel handles RoutingConfig events from watcher
func (ct *ctrlerCtx) handleRoutingConfigEventParallel(evt *kvstore.WatchEvent) error {

	if ct.objResolver == nil {
		return ct.handleRoutingConfigEventParallelWithNoResolver(evt)
	}

	switch tp := evt.Object.(type) {
	case *network.RoutingConfig:
		eobj := evt.Object.(*network.RoutingConfig)
		kind := "RoutingConfig"

		eobj.ApplyStorageTransformer(context.Background(), true /*encrypt*/)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		eobj.ApplyStorageTransformer(context.Background(), false /*decrypt*/)

		ctx := &routingconfigCtx{event: evt.Type, obj: &RoutingConfig{RoutingConfig: *eobj, ctrler: ct}}

		var err error
		switch evt.Type {
		case kvstore.Created:
			err = ct.processAdd(ctx)
		case kvstore.Updated:
			err = ct.processUpdate(ctx)
		case kvstore.Deleted:
			err = ct.processDelete(ctx)
		}
		return err
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on RoutingConfig watch channel", tp)
	}

	return nil
}

// handleRoutingConfigEventParallel handles RoutingConfig events from watcher
func (ct *ctrlerCtx) handleRoutingConfigEventParallelWithNoResolver(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *network.RoutingConfig:
		eobj := evt.Object.(*network.RoutingConfig)
		kind := "RoutingConfig"

		eobj.ApplyStorageTransformer(context.Background(), true /*encrypt*/)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		eobj.ApplyStorageTransformer(context.Background(), false /*decrypt*/)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		routingconfigHandler := handler.(RoutingConfigHandler)
		// handle based on event type
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			workFunc := func(ctx context.Context, ctrlCtx shardworkers.WorkObj) error {
				var err error
				workCtx := ctrlCtx.(*routingconfigCtx)
				eobj := workCtx.obj
				fobj, err := ct.getObject(kind, workCtx.GetKey())
				if err != nil {
					ct.addObject(workCtx)
					ct.stats.Counter("RoutingConfig_Created_Events").Inc()
					eobj.Lock()
					err = routingconfigHandler.OnRoutingConfigCreate(eobj)
					eobj.Unlock()
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, eobj, err)
						ct.delObject(kind, workCtx.GetKey())
					}
				} else {
					workCtx := fobj.(*routingconfigCtx)
					obj := workCtx.obj
					ct.stats.Counter("RoutingConfig_Updated_Events").Inc()
					obj.Lock()
					p := network.RoutingConfig{Spec: eobj.Spec,
						ObjectMeta: eobj.ObjectMeta,
						TypeMeta:   eobj.TypeMeta,
						Status:     eobj.Status}

					err = routingconfigHandler.OnRoutingConfigUpdate(obj, &p)
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					} else {
						workCtx.obj.RoutingConfig = p
					}
					obj.Unlock()
				}
				return err
			}
			ctrlCtx := &routingconfigCtx{event: evt.Type, obj: &RoutingConfig{RoutingConfig: *eobj, ctrler: ct}}
			ct.runFunction("RoutingConfig", ctrlCtx, workFunc)
		case kvstore.Deleted:
			workFunc := func(ctx context.Context, ctrlCtx shardworkers.WorkObj) error {
				var err error
				workCtx := ctrlCtx.(*routingconfigCtx)
				eobj := workCtx.obj
				fobj, err := ct.findObject(kind, workCtx.GetKey())
				if err != nil {
					ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
					return err
				}
				obj := fobj.(*RoutingConfig)
				ct.stats.Counter("RoutingConfig_Deleted_Events").Inc()
				obj.Lock()
				err = routingconfigHandler.OnRoutingConfigDelete(obj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
				}
				ct.delObject(kind, workCtx.GetKey())
				return nil
			}
			ctrlCtx := &routingconfigCtx{event: evt.Type, obj: &RoutingConfig{RoutingConfig: *eobj, ctrler: ct}}
			ct.runFunction("RoutingConfig", ctrlCtx, workFunc)
		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on RoutingConfig watch channel", tp)
	}

	return nil
}

// diffRoutingConfig does a diff of RoutingConfig objects between local cache and API server
func (ct *ctrlerCtx) diffRoutingConfig(apicl apiclient.Services) {
	opts := api.ListWatchOptions{}

	// get a list of all objects from API server
	objlist, err := apicl.NetworkV1().RoutingConfig().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Errorf("Error getting a list of objects. Err: %v", err)
		return
	}

	ct.logger.Infof("diffRoutingConfig(): RoutingConfigList returned %d objects", len(objlist))

	// build an object map
	objmap := make(map[string]*network.RoutingConfig)
	for _, obj := range objlist {
		objmap[obj.GetKey()] = obj
	}

	list, err := ct.RoutingConfig().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Infof("Failed to get a list of objects. Err: %s", err)
		return
	}

	// if an object is in our local cache and not in API server, trigger delete for it
	for _, obj := range list {
		_, ok := objmap[obj.GetKey()]
		if !ok {
			ct.logger.Infof("diffRoutingConfig(): Deleting existing object %#v since its not in apiserver", obj.GetKey())
			evt := kvstore.WatchEvent{
				Type:   kvstore.Deleted,
				Key:    obj.GetKey(),
				Object: &obj.RoutingConfig,
			}
			ct.handleRoutingConfigEvent(&evt)
		}
	}

	// trigger create event for all others
	for _, obj := range objlist {
		ct.logger.Infof("diffRoutingConfig(): Adding object %#v", obj.GetKey())
		evt := kvstore.WatchEvent{
			Type:   kvstore.Created,
			Key:    obj.GetKey(),
			Object: obj,
		}
		ct.handleRoutingConfigEvent(&evt)
	}
}

func (ct *ctrlerCtx) runRoutingConfigWatcher() {
	kind := "RoutingConfig"

	ct.Lock()
	handler, ok := ct.handlers[kind]
	ct.Unlock()
	if !ok {
		ct.logger.Fatalf("Cant find the handler for %s", kind)
	}
	routingconfigHandler := handler.(RoutingConfigHandler)

	opts := routingconfigHandler.GetRoutingConfigWatchOptions()

	// if there is no API server to connect to, we are done
	if (ct.resolver == nil) || ct.apisrvURL == "" {
		return
	}

	// create context
	ctx, cancel := context.WithCancel(context.Background())
	ct.Lock()
	ct.watchCancel[kind] = cancel
	ct.Unlock()
	logger := ct.logger.WithContext("submodule", "RoutingConfigWatcher")
	for {
		if ctx.Err() != nil {
			return
		}

		apiclt, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
		// create a grpc client
		if err == nil {
			// Upon successful connection perform the diff, and start watch goroutine
			ct.diffRoutingConfig(apiclt)
			break
		}

		logger.Warnf("Failed to connect to gRPC server [%s]\n", ct.apisrvURL)
		time.Sleep(time.Second)
	}

	// setup wait group
	ct.waitGrp.Add(1)

	// start a goroutine
	go func() {
		defer ct.waitGrp.Done()
		ct.stats.Counter("RoutingConfig_Watch").Inc()
		defer ct.stats.Counter("RoutingConfig_Watch").Dec()

		// loop forever
		for {
			// create a grpc client
			apicl, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
			if err != nil {
				logger.Warnf("Failed to connect to gRPC server [%s]\n", ct.apisrvURL)
				ct.stats.Counter("RoutingConfig_ApiClientErr").Inc()
			} else {
				logger.Infof("API client connected {%+v}", apicl)

				// RoutingConfig object watcher
				wt, werr := apicl.NetworkV1().RoutingConfig().Watch(ctx, opts)
				if werr != nil {
					select {
					case <-ctx.Done():
						logger.Infof("watch %s cancelled", kind)
						return
					default:
					}
					logger.Errorf("Failed to start %s watch (%s)\n", kind, werr)
					// wait for a second and retry connecting to api server
					apicl.Close()
					time.Sleep(time.Second)
					continue
				}
				ct.Lock()
				ct.watchers[kind] = wt
				ct.Unlock()

				// perform a diff with API server and local cache
				time.Sleep(time.Millisecond * 100)
				ct.diffRoutingConfig(apicl)
				routingconfigHandler.OnRoutingConfigReconnect()

				// handle api server watch events
			innerLoop:
				for {
					// wait for events
					select {
					case evt, ok := <-wt.EventChan():
						if !ok {
							logger.Error("Error receiving from apisrv watcher")
							ct.stats.Counter("RoutingConfig_WatchErrors").Inc()
							break innerLoop
						}

						// handle event in parallel
						ct.handleRoutingConfigEventParallel(evt)
					}
				}
				apicl.Close()
			}

			// if stop flag is set, we are done
			if ct.stoped {
				logger.Infof("Exiting API server watcher")
				return
			}

			// wait for a second and retry connecting to api server
			time.Sleep(time.Second)
		}
	}()
}

// WatchRoutingConfig starts watch on RoutingConfig object
func (ct *ctrlerCtx) WatchRoutingConfig(handler RoutingConfigHandler) error {
	kind := "RoutingConfig"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchers[kind]
	ct.Unlock()
	if ok {
		return fmt.Errorf("RoutingConfig watcher already exists")
	}

	// save handler
	ct.Lock()
	ct.handlers[kind] = handler
	ct.Unlock()

	// run RoutingConfig watcher in a go routine
	ct.runRoutingConfigWatcher()

	return nil
}

// StopWatchRoutingConfig stops watch on RoutingConfig object
func (ct *ctrlerCtx) StopWatchRoutingConfig(handler RoutingConfigHandler) error {
	kind := "RoutingConfig"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchers[kind]
	ct.Unlock()
	if !ok {
		return fmt.Errorf("RoutingConfig watcher does not exist")
	}

	ct.Lock()
	cancel, _ := ct.watchCancel[kind]
	cancel()
	delete(ct.watchers, kind)
	delete(ct.watchCancel, kind)
	ct.Unlock()

	time.Sleep(100 * time.Millisecond)

	return nil
}

// RoutingConfigAPI returns
type RoutingConfigAPI interface {
	Create(obj *network.RoutingConfig) error
	SyncCreate(obj *network.RoutingConfig) error
	Update(obj *network.RoutingConfig) error
	SyncUpdate(obj *network.RoutingConfig) error
	Delete(obj *network.RoutingConfig) error
	Find(meta *api.ObjectMeta) (*RoutingConfig, error)
	List(ctx context.Context, opts *api.ListWatchOptions) ([]*RoutingConfig, error)
	Watch(handler RoutingConfigHandler) error
	StopWatch(handler RoutingConfigHandler) error
}

// dummy struct that implements RoutingConfigAPI
type routingconfigAPI struct {
	ct *ctrlerCtx
}

// Create creates RoutingConfig object
func (api *routingconfigAPI) Create(obj *network.RoutingConfig) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.NetworkV1().RoutingConfig().Create(context.Background(), obj)
		if err != nil && strings.Contains(err.Error(), "AlreadyExists") {
			_, err = apicl.NetworkV1().RoutingConfig().Update(context.Background(), obj)

		}
		return err
	}

	api.ct.handleRoutingConfigEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Created})
	return nil
}

// SyncCreate creates RoutingConfig object and updates the cache
func (api *routingconfigAPI) SyncCreate(obj *network.RoutingConfig) error {
	newObj := obj
	evtType := kvstore.Created
	var writeErr error
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		newObj, writeErr = apicl.NetworkV1().RoutingConfig().Create(context.Background(), obj)
		if writeErr != nil && strings.Contains(writeErr.Error(), "AlreadyExists") {
			newObj, writeErr = apicl.NetworkV1().RoutingConfig().Update(context.Background(), obj)
			evtType = kvstore.Updated
		}
	}

	if writeErr == nil {
		api.ct.handleRoutingConfigEvent(&kvstore.WatchEvent{Object: newObj, Type: evtType})
	}
	return writeErr
}

// Update triggers update on RoutingConfig object
func (api *routingconfigAPI) Update(obj *network.RoutingConfig) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.NetworkV1().RoutingConfig().Update(context.Background(), obj)
		return err
	}

	api.ct.handleRoutingConfigEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Updated})
	return nil
}

// SyncUpdate triggers update on RoutingConfig object and updates the cache
func (api *routingconfigAPI) SyncUpdate(obj *network.RoutingConfig) error {
	newObj := obj
	var writeErr error
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		newObj, writeErr = apicl.NetworkV1().RoutingConfig().Update(context.Background(), obj)
	}

	if writeErr == nil {
		api.ct.handleRoutingConfigEvent(&kvstore.WatchEvent{Object: newObj, Type: kvstore.Updated})
	}

	return writeErr
}

// Delete deletes RoutingConfig object
func (api *routingconfigAPI) Delete(obj *network.RoutingConfig) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.NetworkV1().RoutingConfig().Delete(context.Background(), &obj.ObjectMeta)
		return err
	}

	api.ct.handleRoutingConfigEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Deleted})
	return nil
}

// MakeKey generates a KV store key for the object
func (api *routingconfigAPI) getFullKey(tenant, name string) string {
	if tenant != "" {
		return fmt.Sprint(globals.ConfigRootPrefix, "/", "network", "/", "routing-config", "/", tenant, "/", name)
	}
	return fmt.Sprint(globals.ConfigRootPrefix, "/", "network", "/", "routing-config", "/", name)
}

// Find returns an object by meta
func (api *routingconfigAPI) Find(meta *api.ObjectMeta) (*RoutingConfig, error) {
	// find the object
	obj, err := api.ct.FindObject("RoutingConfig", meta)
	if err != nil {
		return nil, err
	}

	// asset type
	switch obj.(type) {
	case *RoutingConfig:
		hobj := obj.(*RoutingConfig)
		return hobj, nil
	default:
		return nil, errors.New("incorrect object type")
	}
}

// List returns a list of all RoutingConfig objects
func (api *routingconfigAPI) List(ctx context.Context, opts *api.ListWatchOptions) ([]*RoutingConfig, error) {
	var objlist []*RoutingConfig
	objs, err := api.ct.List("RoutingConfig", ctx, opts)

	if err != nil {
		return nil, err
	}

	for _, obj := range objs {
		switch tp := obj.(type) {
		case *RoutingConfig:
			eobj := obj.(*RoutingConfig)
			objlist = append(objlist, eobj)
		default:
			log.Fatalf("Got invalid object type %v while looking for RoutingConfig", tp)
		}
	}

	return objlist, nil
}

// Watch sets up a event handlers for RoutingConfig object
func (api *routingconfigAPI) Watch(handler RoutingConfigHandler) error {
	api.ct.startWorkerPool("RoutingConfig")
	return api.ct.WatchRoutingConfig(handler)
}

// StopWatch stop watch for Tenant RoutingConfig object
func (api *routingconfigAPI) StopWatch(handler RoutingConfigHandler) error {
	api.ct.Lock()
	api.ct.workPools["RoutingConfig"].Stop()
	api.ct.Unlock()
	return api.ct.StopWatchRoutingConfig(handler)
}

// RoutingConfig returns RoutingConfigAPI
func (ct *ctrlerCtx) RoutingConfig() RoutingConfigAPI {
	kind := "RoutingConfig"
	if _, ok := ct.apiInfMap[kind]; !ok {
		s := &routingconfigAPI{ct: ct}
		ct.apiInfMap[kind] = s
	}
	return ct.apiInfMap[kind].(*routingconfigAPI)
}

// RouteTable is a wrapper object that implements additional functionality
type RouteTable struct {
	sync.Mutex
	network.RouteTable
	HandlerCtx interface{} // additional state handlers can store
	ctrler     *ctrlerCtx  // reference back to the controller instance
}

func (obj *RouteTable) Write() error {
	// if there is no API server to connect to, we are done
	if (obj.ctrler == nil) || (obj.ctrler.resolver == nil) || obj.ctrler.apisrvURL == "" {
		return nil
	}

	apicl, err := obj.ctrler.apiClient()
	if err != nil {
		obj.ctrler.logger.Errorf("Error creating API server clent. Err: %v", err)
		return err
	}

	obj.ctrler.stats.Counter("RouteTable_Writes").Inc()

	// write to api server
	if obj.ObjectMeta.ResourceVersion != "" {
		// update it
		for i := 0; i < maxApisrvWriteRetry; i++ {
			_, err = apicl.NetworkV1().RouteTable().UpdateStatus(context.Background(), &obj.RouteTable)
			if err == nil {
				break
			}
			time.Sleep(time.Millisecond * 100)
		}
	} else {
		//  create
		_, err = apicl.NetworkV1().RouteTable().Create(context.Background(), &obj.RouteTable)
	}

	return nil
}

// RouteTableHandler is the event handler for RouteTable object
type RouteTableHandler interface {
	OnRouteTableCreate(obj *RouteTable) error
	OnRouteTableUpdate(oldObj *RouteTable, newObj *network.RouteTable) error
	OnRouteTableDelete(obj *RouteTable) error
	GetRouteTableWatchOptions() *api.ListWatchOptions
	OnRouteTableReconnect()
}

// OnRouteTableCreate is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnRouteTableCreate(obj *RouteTable) error {
	log.Info("OnRouteTableCreate is not implemented")
	return nil
}

// OnRouteTableUpdate is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnRouteTableUpdate(oldObj *RouteTable, newObj *network.RouteTable) error {
	log.Info("OnRouteTableUpdate is not implemented")
	return nil
}

// OnRouteTableDelete is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnRouteTableDelete(obj *RouteTable) error {
	log.Info("OnRouteTableDelete is not implemented")
	return nil
}

// GetRouteTableWatchOptions is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) GetRouteTableWatchOptions() *api.ListWatchOptions {
	log.Info("GetRouteTableWatchOptions is not implemented")
	opts := &api.ListWatchOptions{}
	return opts
}

// OnRouteTableReconnect is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnRouteTableReconnect() {
	log.Info("OnRouteTableReconnect is not implemented")
	return
}

// handleRouteTableEvent handles RouteTable events from watcher
func (ct *ctrlerCtx) handleRouteTableEvent(evt *kvstore.WatchEvent) error {

	if ct.objResolver == nil {
		return ct.handleRouteTableEventNoResolver(evt)
	}

	switch tp := evt.Object.(type) {
	case *network.RouteTable:
		eobj := evt.Object.(*network.RouteTable)
		kind := "RouteTable"

		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ctx := &routetableCtx{event: evt.Type,
			obj: &RouteTable{RouteTable: *eobj, ctrler: ct}}

		var err error
		switch evt.Type {
		case kvstore.Created:
			err = ct.processAdd(ctx)
		case kvstore.Updated:
			err = ct.processUpdate(ctx)
		case kvstore.Deleted:
			err = ct.processDelete(ctx)
		}
		return err
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on RouteTable watch channel", tp)
	}

	return nil
}

// handleRouteTableEventNoResolver handles RouteTable events from watcher
func (ct *ctrlerCtx) handleRouteTableEventNoResolver(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *network.RouteTable:
		eobj := evt.Object.(*network.RouteTable)
		kind := "RouteTable"

		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		routetableHandler := handler.(RouteTableHandler)
		// handle based on event type
		ctrlCtx := &routetableCtx{event: evt.Type, obj: &RouteTable{RouteTable: *eobj, ctrler: ct}}
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			fobj, err := ct.getObject(kind, ctrlCtx.GetKey())
			if err != nil {
				ct.addObject(ctrlCtx)
				ct.stats.Counter("RouteTable_Created_Events").Inc()

				// call the event handler
				ctrlCtx.Lock()
				err = routetableHandler.OnRouteTableCreate(ctrlCtx.obj)
				ctrlCtx.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctrlCtx.obj, err)
					ct.delObject(kind, ctrlCtx.GetKey())
					return err
				}
			} else {
				fResVer, fErr := strconv.ParseInt(fobj.GetResourceVersion(), 10, 64)
				eResVer, eErr := strconv.ParseInt(eobj.GetResourceVersion(), 10, 64)
				if ct.resolver != nil && fErr == nil && eErr == nil && fResVer >= eResVer {
					// Event already processed.
					ct.logger.Infof("Skipping update due to old resource version")
					return nil
				}
				ctrlCtx := fobj.(*routetableCtx)
				ct.stats.Counter("RouteTable_Updated_Events").Inc()
				ctrlCtx.Lock()
				p := network.RouteTable{Spec: eobj.Spec,
					ObjectMeta: eobj.ObjectMeta,
					TypeMeta:   eobj.TypeMeta,
					Status:     eobj.Status}

				err = routetableHandler.OnRouteTableUpdate(ctrlCtx.obj, &p)
				ctrlCtx.obj.RouteTable = *eobj
				ctrlCtx.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctrlCtx.obj, err)
					return err
				}

			}
		case kvstore.Deleted:
			ctrlCtx := &routetableCtx{event: evt.Type, obj: &RouteTable{RouteTable: *eobj, ctrler: ct}}
			fobj, err := ct.findObject(kind, ctrlCtx.GetKey())
			if err != nil {
				ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
				return err
			}

			obj := fobj.(*RouteTable)
			ct.stats.Counter("RouteTable_Deleted_Events").Inc()
			obj.Lock()
			err = routetableHandler.OnRouteTableDelete(obj)
			obj.Unlock()
			if err != nil {
				ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
			}
			ct.delObject(kind, ctrlCtx.GetKey())
			return nil

		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on RouteTable watch channel", tp)
	}

	return nil
}

type routetableCtx struct {
	ctkitBaseCtx
	event kvstore.WatchEventType
	obj   *RouteTable //
	//   newObj     *network.RouteTable //update
	newObj *routetableCtx //update
}

func (ctx *routetableCtx) References() map[string]apiintf.ReferenceObj {
	resp := make(map[string]apiintf.ReferenceObj)
	ctx.obj.References(ctx.obj.GetObjectMeta().Name, ctx.obj.GetObjectMeta().Namespace, resp)
	return resp
}

func (ctx *routetableCtx) GetKey() string {
	return ctx.obj.MakeKey("network")
}

func (ctx *routetableCtx) GetKind() string {
	return ctx.obj.GetKind()
}

func (ctx *routetableCtx) GetResourceVersion() string {
	return ctx.obj.GetResourceVersion()
}

func (ctx *routetableCtx) SetEvent(event kvstore.WatchEventType) {
	ctx.event = event
}

func (ctx *routetableCtx) SetNewObj(newObj apiintf.CtkitObject) {
	if newObj == nil {
		ctx.newObj = nil
	} else {
		ctx.newObj = newObj.(*routetableCtx)
		ctx.newObj.obj.HandlerCtx = ctx.obj.HandlerCtx
	}
}

func (ctx *routetableCtx) GetNewObj() apiintf.CtkitObject {
	return ctx.newObj
}

func (ctx *routetableCtx) Copy(obj apiintf.CtkitObject) {
	ctx.obj.RouteTable = obj.(*routetableCtx).obj.RouteTable
}

func (ctx *routetableCtx) Lock() {
	ctx.obj.Lock()
}

func (ctx *routetableCtx) Unlock() {
	ctx.obj.Unlock()
}

func (ctx *routetableCtx) GetObjectMeta() *api.ObjectMeta {
	return ctx.obj.GetObjectMeta()
}

func (ctx *routetableCtx) RuntimeObject() runtime.Object {
	var v interface{}
	v = ctx.obj
	return v.(runtime.Object)
}

func (ctx *routetableCtx) WorkFunc(context context.Context) error {
	var err error
	evt := ctx.event
	ct := ctx.obj.ctrler
	kind := "RouteTable"
	ct.Lock()
	handler, ok := ct.handlers[kind]
	ct.Unlock()
	if !ok {
		ct.logger.Fatalf("Cant find the handler for %s", kind)
	}
	routetableHandler := handler.(RouteTableHandler)
	switch evt {
	case kvstore.Created:
		ctx.obj.Lock()
		err = routetableHandler.OnRouteTableCreate(ctx.obj)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctx.obj, err)
			ctx.SetEvent(kvstore.Deleted)
		}
	case kvstore.Updated:
		ct.stats.Counter("RouteTable_Updated_Events").Inc()
		ctx.obj.Lock()
		p := network.RouteTable{Spec: ctx.newObj.obj.Spec,
			ObjectMeta: ctx.newObj.obj.ObjectMeta,
			TypeMeta:   ctx.newObj.obj.TypeMeta,
			Status:     ctx.newObj.obj.Status}
		err = routetableHandler.OnRouteTableUpdate(ctx.obj, &p)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctx.obj, err)
			ctx.SetEvent(kvstore.Deleted)
		}
	case kvstore.Deleted:
		ctx.obj.Lock()
		err = routetableHandler.OnRouteTableDelete(ctx.obj)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error deleting %s %+v. Err: %v", kind, ctx.obj, err)
		}
	}
	ct.resolveObject(ctx.event, ctx)
	return nil
}

// handleRouteTableEventParallel handles RouteTable events from watcher
func (ct *ctrlerCtx) handleRouteTableEventParallel(evt *kvstore.WatchEvent) error {

	if ct.objResolver == nil {
		return ct.handleRouteTableEventParallelWithNoResolver(evt)
	}

	switch tp := evt.Object.(type) {
	case *network.RouteTable:
		eobj := evt.Object.(*network.RouteTable)
		kind := "RouteTable"

		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ctx := &routetableCtx{event: evt.Type, obj: &RouteTable{RouteTable: *eobj, ctrler: ct}}

		var err error
		switch evt.Type {
		case kvstore.Created:
			err = ct.processAdd(ctx)
		case kvstore.Updated:
			err = ct.processUpdate(ctx)
		case kvstore.Deleted:
			err = ct.processDelete(ctx)
		}
		return err
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on RouteTable watch channel", tp)
	}

	return nil
}

// handleRouteTableEventParallel handles RouteTable events from watcher
func (ct *ctrlerCtx) handleRouteTableEventParallelWithNoResolver(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *network.RouteTable:
		eobj := evt.Object.(*network.RouteTable)
		kind := "RouteTable"

		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		routetableHandler := handler.(RouteTableHandler)
		// handle based on event type
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			workFunc := func(ctx context.Context, ctrlCtx shardworkers.WorkObj) error {
				var err error
				workCtx := ctrlCtx.(*routetableCtx)
				eobj := workCtx.obj
				fobj, err := ct.getObject(kind, workCtx.GetKey())
				if err != nil {
					ct.addObject(workCtx)
					ct.stats.Counter("RouteTable_Created_Events").Inc()
					eobj.Lock()
					err = routetableHandler.OnRouteTableCreate(eobj)
					eobj.Unlock()
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, eobj, err)
						ct.delObject(kind, workCtx.GetKey())
					}
				} else {
					workCtx := fobj.(*routetableCtx)
					obj := workCtx.obj
					ct.stats.Counter("RouteTable_Updated_Events").Inc()
					obj.Lock()
					p := network.RouteTable{Spec: eobj.Spec,
						ObjectMeta: eobj.ObjectMeta,
						TypeMeta:   eobj.TypeMeta,
						Status:     eobj.Status}

					err = routetableHandler.OnRouteTableUpdate(obj, &p)
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					} else {
						workCtx.obj.RouteTable = p
					}
					obj.Unlock()
				}
				return err
			}
			ctrlCtx := &routetableCtx{event: evt.Type, obj: &RouteTable{RouteTable: *eobj, ctrler: ct}}
			ct.runFunction("RouteTable", ctrlCtx, workFunc)
		case kvstore.Deleted:
			workFunc := func(ctx context.Context, ctrlCtx shardworkers.WorkObj) error {
				var err error
				workCtx := ctrlCtx.(*routetableCtx)
				eobj := workCtx.obj
				fobj, err := ct.findObject(kind, workCtx.GetKey())
				if err != nil {
					ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
					return err
				}
				obj := fobj.(*RouteTable)
				ct.stats.Counter("RouteTable_Deleted_Events").Inc()
				obj.Lock()
				err = routetableHandler.OnRouteTableDelete(obj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
				}
				ct.delObject(kind, workCtx.GetKey())
				return nil
			}
			ctrlCtx := &routetableCtx{event: evt.Type, obj: &RouteTable{RouteTable: *eobj, ctrler: ct}}
			ct.runFunction("RouteTable", ctrlCtx, workFunc)
		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on RouteTable watch channel", tp)
	}

	return nil
}

// diffRouteTable does a diff of RouteTable objects between local cache and API server
func (ct *ctrlerCtx) diffRouteTable(apicl apiclient.Services) {
	opts := api.ListWatchOptions{}

	// get a list of all objects from API server
	objlist, err := apicl.NetworkV1().RouteTable().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Errorf("Error getting a list of objects. Err: %v", err)
		return
	}

	ct.logger.Infof("diffRouteTable(): RouteTableList returned %d objects", len(objlist))

	// build an object map
	objmap := make(map[string]*network.RouteTable)
	for _, obj := range objlist {
		objmap[obj.GetKey()] = obj
	}

	list, err := ct.RouteTable().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Infof("Failed to get a list of objects. Err: %s", err)
		return
	}

	// if an object is in our local cache and not in API server, trigger delete for it
	for _, obj := range list {
		_, ok := objmap[obj.GetKey()]
		if !ok {
			ct.logger.Infof("diffRouteTable(): Deleting existing object %#v since its not in apiserver", obj.GetKey())
			evt := kvstore.WatchEvent{
				Type:   kvstore.Deleted,
				Key:    obj.GetKey(),
				Object: &obj.RouteTable,
			}
			ct.handleRouteTableEvent(&evt)
		}
	}

	// trigger create event for all others
	for _, obj := range objlist {
		ct.logger.Infof("diffRouteTable(): Adding object %#v", obj.GetKey())
		evt := kvstore.WatchEvent{
			Type:   kvstore.Created,
			Key:    obj.GetKey(),
			Object: obj,
		}
		ct.handleRouteTableEvent(&evt)
	}
}

func (ct *ctrlerCtx) runRouteTableWatcher() {
	kind := "RouteTable"

	ct.Lock()
	handler, ok := ct.handlers[kind]
	ct.Unlock()
	if !ok {
		ct.logger.Fatalf("Cant find the handler for %s", kind)
	}
	routetableHandler := handler.(RouteTableHandler)

	opts := routetableHandler.GetRouteTableWatchOptions()

	// if there is no API server to connect to, we are done
	if (ct.resolver == nil) || ct.apisrvURL == "" {
		return
	}

	// create context
	ctx, cancel := context.WithCancel(context.Background())
	ct.Lock()
	ct.watchCancel[kind] = cancel
	ct.Unlock()
	logger := ct.logger.WithContext("submodule", "RouteTableWatcher")
	for {
		if ctx.Err() != nil {
			return
		}

		apiclt, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
		// create a grpc client
		if err == nil {
			// Upon successful connection perform the diff, and start watch goroutine
			ct.diffRouteTable(apiclt)
			break
		}

		logger.Warnf("Failed to connect to gRPC server [%s]\n", ct.apisrvURL)
		time.Sleep(time.Second)
	}

	// setup wait group
	ct.waitGrp.Add(1)

	// start a goroutine
	go func() {
		defer ct.waitGrp.Done()
		ct.stats.Counter("RouteTable_Watch").Inc()
		defer ct.stats.Counter("RouteTable_Watch").Dec()

		// loop forever
		for {
			// create a grpc client
			apicl, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
			if err != nil {
				logger.Warnf("Failed to connect to gRPC server [%s]\n", ct.apisrvURL)
				ct.stats.Counter("RouteTable_ApiClientErr").Inc()
			} else {
				logger.Infof("API client connected {%+v}", apicl)

				// RouteTable object watcher
				wt, werr := apicl.NetworkV1().RouteTable().Watch(ctx, opts)
				if werr != nil {
					select {
					case <-ctx.Done():
						logger.Infof("watch %s cancelled", kind)
						return
					default:
					}
					logger.Errorf("Failed to start %s watch (%s)\n", kind, werr)
					// wait for a second and retry connecting to api server
					apicl.Close()
					time.Sleep(time.Second)
					continue
				}
				ct.Lock()
				ct.watchers[kind] = wt
				ct.Unlock()

				// perform a diff with API server and local cache
				time.Sleep(time.Millisecond * 100)
				ct.diffRouteTable(apicl)
				routetableHandler.OnRouteTableReconnect()

				// handle api server watch events
			innerLoop:
				for {
					// wait for events
					select {
					case evt, ok := <-wt.EventChan():
						if !ok {
							logger.Error("Error receiving from apisrv watcher")
							ct.stats.Counter("RouteTable_WatchErrors").Inc()
							break innerLoop
						}

						// handle event in parallel
						ct.handleRouteTableEventParallel(evt)
					}
				}
				apicl.Close()
			}

			// if stop flag is set, we are done
			if ct.stoped {
				logger.Infof("Exiting API server watcher")
				return
			}

			// wait for a second and retry connecting to api server
			time.Sleep(time.Second)
		}
	}()
}

// WatchRouteTable starts watch on RouteTable object
func (ct *ctrlerCtx) WatchRouteTable(handler RouteTableHandler) error {
	kind := "RouteTable"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchers[kind]
	ct.Unlock()
	if ok {
		return fmt.Errorf("RouteTable watcher already exists")
	}

	// save handler
	ct.Lock()
	ct.handlers[kind] = handler
	ct.Unlock()

	// run RouteTable watcher in a go routine
	ct.runRouteTableWatcher()

	return nil
}

// StopWatchRouteTable stops watch on RouteTable object
func (ct *ctrlerCtx) StopWatchRouteTable(handler RouteTableHandler) error {
	kind := "RouteTable"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchers[kind]
	ct.Unlock()
	if !ok {
		return fmt.Errorf("RouteTable watcher does not exist")
	}

	ct.Lock()
	cancel, _ := ct.watchCancel[kind]
	cancel()
	delete(ct.watchers, kind)
	delete(ct.watchCancel, kind)
	ct.Unlock()

	time.Sleep(100 * time.Millisecond)

	return nil
}

// RouteTableAPI returns
type RouteTableAPI interface {
	Create(obj *network.RouteTable) error
	SyncCreate(obj *network.RouteTable) error
	Update(obj *network.RouteTable) error
	SyncUpdate(obj *network.RouteTable) error
	Delete(obj *network.RouteTable) error
	Find(meta *api.ObjectMeta) (*RouteTable, error)
	List(ctx context.Context, opts *api.ListWatchOptions) ([]*RouteTable, error)
	Watch(handler RouteTableHandler) error
	StopWatch(handler RouteTableHandler) error
}

// dummy struct that implements RouteTableAPI
type routetableAPI struct {
	ct *ctrlerCtx
}

// Create creates RouteTable object
func (api *routetableAPI) Create(obj *network.RouteTable) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.NetworkV1().RouteTable().Create(context.Background(), obj)
		if err != nil && strings.Contains(err.Error(), "AlreadyExists") {
			_, err = apicl.NetworkV1().RouteTable().Update(context.Background(), obj)

		}
		return err
	}

	api.ct.handleRouteTableEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Created})
	return nil
}

// SyncCreate creates RouteTable object and updates the cache
func (api *routetableAPI) SyncCreate(obj *network.RouteTable) error {
	newObj := obj
	evtType := kvstore.Created
	var writeErr error
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		newObj, writeErr = apicl.NetworkV1().RouteTable().Create(context.Background(), obj)
		if writeErr != nil && strings.Contains(writeErr.Error(), "AlreadyExists") {
			newObj, writeErr = apicl.NetworkV1().RouteTable().Update(context.Background(), obj)
			evtType = kvstore.Updated
		}
	}

	if writeErr == nil {
		api.ct.handleRouteTableEvent(&kvstore.WatchEvent{Object: newObj, Type: evtType})
	}
	return writeErr
}

// Update triggers update on RouteTable object
func (api *routetableAPI) Update(obj *network.RouteTable) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.NetworkV1().RouteTable().Update(context.Background(), obj)
		return err
	}

	api.ct.handleRouteTableEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Updated})
	return nil
}

// SyncUpdate triggers update on RouteTable object and updates the cache
func (api *routetableAPI) SyncUpdate(obj *network.RouteTable) error {
	newObj := obj
	var writeErr error
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		newObj, writeErr = apicl.NetworkV1().RouteTable().Update(context.Background(), obj)
	}

	if writeErr == nil {
		api.ct.handleRouteTableEvent(&kvstore.WatchEvent{Object: newObj, Type: kvstore.Updated})
	}

	return writeErr
}

// Delete deletes RouteTable object
func (api *routetableAPI) Delete(obj *network.RouteTable) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.NetworkV1().RouteTable().Delete(context.Background(), &obj.ObjectMeta)
		return err
	}

	api.ct.handleRouteTableEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Deleted})
	return nil
}

// MakeKey generates a KV store key for the object
func (api *routetableAPI) getFullKey(tenant, name string) string {
	if tenant != "" {
		return fmt.Sprint(globals.ConfigRootPrefix, "/", "network", "/", "route-tables", "/", tenant, "/", name)
	}
	return fmt.Sprint(globals.ConfigRootPrefix, "/", "network", "/", "route-tables", "/", name)
}

// Find returns an object by meta
func (api *routetableAPI) Find(meta *api.ObjectMeta) (*RouteTable, error) {
	// find the object
	obj, err := api.ct.FindObject("RouteTable", meta)
	if err != nil {
		return nil, err
	}

	// asset type
	switch obj.(type) {
	case *RouteTable:
		hobj := obj.(*RouteTable)
		return hobj, nil
	default:
		return nil, errors.New("incorrect object type")
	}
}

// List returns a list of all RouteTable objects
func (api *routetableAPI) List(ctx context.Context, opts *api.ListWatchOptions) ([]*RouteTable, error) {
	var objlist []*RouteTable
	objs, err := api.ct.List("RouteTable", ctx, opts)

	if err != nil {
		return nil, err
	}

	for _, obj := range objs {
		switch tp := obj.(type) {
		case *RouteTable:
			eobj := obj.(*RouteTable)
			objlist = append(objlist, eobj)
		default:
			log.Fatalf("Got invalid object type %v while looking for RouteTable", tp)
		}
	}

	return objlist, nil
}

// Watch sets up a event handlers for RouteTable object
func (api *routetableAPI) Watch(handler RouteTableHandler) error {
	api.ct.startWorkerPool("RouteTable")
	return api.ct.WatchRouteTable(handler)
}

// StopWatch stop watch for Tenant RouteTable object
func (api *routetableAPI) StopWatch(handler RouteTableHandler) error {
	api.ct.Lock()
	api.ct.workPools["RouteTable"].Stop()
	api.ct.Unlock()
	return api.ct.StopWatchRouteTable(handler)
}

// RouteTable returns RouteTableAPI
func (ct *ctrlerCtx) RouteTable() RouteTableAPI {
	kind := "RouteTable"
	if _, ok := ct.apiInfMap[kind]; !ok {
		s := &routetableAPI{ct: ct}
		ct.apiInfMap[kind] = s
	}
	return ct.apiInfMap[kind].(*routetableAPI)
}
