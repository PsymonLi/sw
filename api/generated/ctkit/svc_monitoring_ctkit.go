// Code generated by protoc-gen-grpc-pensando DO NOT EDIT.

/*
Package ctkit is a auto generated package.
Input file: svc_monitoring.proto
*/
package ctkit

import (
	"context"
	"errors"
	"fmt"
	"strings"
	"sync"
	"time"

	"github.com/pensando/sw/api"
	"github.com/pensando/sw/api/generated/apiclient"
	"github.com/pensando/sw/api/generated/monitoring"
	apiintf "github.com/pensando/sw/api/interfaces"
	"github.com/pensando/sw/venice/globals"
	"github.com/pensando/sw/venice/utils/balancer"
	"github.com/pensando/sw/venice/utils/kvstore"
	"github.com/pensando/sw/venice/utils/log"
	"github.com/pensando/sw/venice/utils/rpckit"
	"github.com/pensando/sw/venice/utils/runtime"
	"github.com/pensando/sw/venice/utils/shardworkers"
)

// EventPolicy is a wrapper object that implements additional functionality
type EventPolicy struct {
	sync.Mutex
	monitoring.EventPolicy
	HandlerCtx interface{} // additional state handlers can store
	ctrler     *ctrlerCtx  // reference back to the controller instance
}

func (obj *EventPolicy) Write() error {
	// if there is no API server to connect to, we are done
	if (obj.ctrler == nil) || (obj.ctrler.resolver == nil) || obj.ctrler.apisrvURL == "" {
		return nil
	}

	apicl, err := obj.ctrler.apiClient()
	if err != nil {
		obj.ctrler.logger.Errorf("Error creating API server clent. Err: %v", err)
		return err
	}

	obj.ctrler.stats.Counter("EventPolicy_Writes").Inc()

	// write to api server
	if obj.ObjectMeta.ResourceVersion != "" {
		// update it
		for i := 0; i < maxApisrvWriteRetry; i++ {
			_, err = apicl.MonitoringV1().EventPolicy().UpdateStatus(context.Background(), &obj.EventPolicy)
			if err == nil {
				break
			}
			time.Sleep(time.Millisecond * 100)
		}
	} else {
		//  create
		_, err = apicl.MonitoringV1().EventPolicy().Create(context.Background(), &obj.EventPolicy)
	}

	return nil
}

// EventPolicyHandler is the event handler for EventPolicy object
type EventPolicyHandler interface {
	OnEventPolicyCreate(obj *EventPolicy) error
	OnEventPolicyUpdate(oldObj *EventPolicy, newObj *monitoring.EventPolicy) error
	OnEventPolicyDelete(obj *EventPolicy) error
	GetEventPolicyWatchOptions() *api.ListWatchOptions
}

// OnEventPolicyCreate is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnEventPolicyCreate(obj *EventPolicy) error {
	log.Info("OnEventPolicyCreate is not implemented")
	return nil
}

// OnEventPolicyUpdate is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnEventPolicyUpdate(oldObj *EventPolicy, newObj *monitoring.EventPolicy) error {
	log.Info("OnEventPolicyUpdate is not implemented")
	return nil
}

// OnEventPolicyDelete is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnEventPolicyDelete(obj *EventPolicy) error {
	log.Info("OnEventPolicyDelete is not implemented")
	return nil
}

// GetEventPolicyWatchOptions is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) GetEventPolicyWatchOptions() *api.ListWatchOptions {
	log.Info("GetEventPolicyWatchOptions is not implemented")
	opts := &api.ListWatchOptions{}
	return opts
}

// handleEventPolicyEvent handles EventPolicy events from watcher
func (ct *ctrlerCtx) handleEventPolicyEvent(evt *kvstore.WatchEvent) error {

	if ct.objResolver == nil {
		return ct.handleEventPolicyEventNoResolver(evt)
	}

	switch tp := evt.Object.(type) {
	case *monitoring.EventPolicy:
		eobj := evt.Object.(*monitoring.EventPolicy)
		kind := "EventPolicy"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ctx := &eventpolicyCtx{event: evt.Type,
			obj: &EventPolicy{EventPolicy: *eobj, ctrler: ct}}

		var err error
		switch evt.Type {
		case kvstore.Created:
			err = ct.processAdd(ctx)
		case kvstore.Updated:
			err = ct.processUpdate(ctx)
		case kvstore.Deleted:
			err = ct.processDelete(ctx)
		}
		return err
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on EventPolicy watch channel", tp)
	}

	return nil
}

// handleEventPolicyEventNoResolver handles EventPolicy events from watcher
func (ct *ctrlerCtx) handleEventPolicyEventNoResolver(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *monitoring.EventPolicy:
		eobj := evt.Object.(*monitoring.EventPolicy)
		kind := "EventPolicy"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		eventpolicyHandler := handler.(EventPolicyHandler)
		// handle based on event type
		ctrlCtx := &eventpolicyCtx{event: evt.Type, obj: &EventPolicy{EventPolicy: *eobj, ctrler: ct}}
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			fobj, err := ct.getObject(kind, ctrlCtx.GetKey())
			if err != nil {
				ct.addObject(ctrlCtx)
				ct.stats.Counter("EventPolicy_Created_Events").Inc()

				// call the event handler
				ctrlCtx.Lock()
				err = eventpolicyHandler.OnEventPolicyCreate(ctrlCtx.obj)
				ctrlCtx.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctrlCtx.obj, err)
					ct.delObject(kind, ctrlCtx.GetKey())
					return err
				}
			} else {
				if ct.resolver != nil && fobj.GetResourceVersion() >= eobj.GetResourceVersion() {
					// Event already processed.
					ct.logger.Infof("Skipping update due to old resource version")
					return nil
				}
				ctrlCtx := fobj.(*eventpolicyCtx)
				ct.stats.Counter("EventPolicy_Updated_Events").Inc()
				ctrlCtx.Lock()
				p := monitoring.EventPolicy{Spec: eobj.Spec,
					ObjectMeta: eobj.ObjectMeta,
					TypeMeta:   eobj.TypeMeta,
					Status:     eobj.Status}

				err = eventpolicyHandler.OnEventPolicyUpdate(ctrlCtx.obj, &p)
				ctrlCtx.obj.EventPolicy = *eobj
				ctrlCtx.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctrlCtx.obj, err)
					return err
				}

			}
		case kvstore.Deleted:
			ctrlCtx := &eventpolicyCtx{event: evt.Type, obj: &EventPolicy{EventPolicy: *eobj, ctrler: ct}}
			fobj, err := ct.findObject(kind, ctrlCtx.GetKey())
			if err != nil {
				ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
				return err
			}

			obj := fobj.(*EventPolicy)
			ct.stats.Counter("EventPolicy_Deleted_Events").Inc()
			obj.Lock()
			err = eventpolicyHandler.OnEventPolicyDelete(obj)
			obj.Unlock()
			if err != nil {
				ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
			}
			ct.delObject(kind, ctrlCtx.GetKey())
			return nil

		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on EventPolicy watch channel", tp)
	}

	return nil
}

type eventpolicyCtx struct {
	ctkitBaseCtx
	event kvstore.WatchEventType
	obj   *EventPolicy //
	//   newObj     *monitoring.EventPolicy //update
	newObj *eventpolicyCtx //update
}

func (ctx *eventpolicyCtx) References() map[string]apiintf.ReferenceObj {
	resp := make(map[string]apiintf.ReferenceObj)
	ctx.obj.References(ctx.obj.GetObjectMeta().Name, ctx.obj.GetObjectMeta().Namespace, resp)
	return resp
}

func (ctx *eventpolicyCtx) GetKey() string {
	return ctx.obj.MakeKey("monitoring")
}

func (ctx *eventpolicyCtx) GetKind() string {
	return ctx.obj.GetKind()
}

func (ctx *eventpolicyCtx) GetResourceVersion() string {
	return ctx.obj.GetResourceVersion()
}

func (ctx *eventpolicyCtx) SetEvent(event kvstore.WatchEventType) {
	ctx.event = event
}

func (ctx *eventpolicyCtx) SetNewObj(newObj apiintf.CtkitObject) {
	if newObj == nil {
		ctx.newObj = nil
	} else {
		ctx.newObj = newObj.(*eventpolicyCtx)
		ctx.newObj.obj.HandlerCtx = ctx.obj.HandlerCtx
	}
}

func (ctx *eventpolicyCtx) GetNewObj() apiintf.CtkitObject {
	return ctx.newObj
}

func (ctx *eventpolicyCtx) Copy(obj apiintf.CtkitObject) {
	ctx.obj.EventPolicy = obj.(*eventpolicyCtx).obj.EventPolicy
}

func (ctx *eventpolicyCtx) Lock() {
	ctx.obj.Lock()
}

func (ctx *eventpolicyCtx) Unlock() {
	ctx.obj.Unlock()
}

func (ctx *eventpolicyCtx) GetObjectMeta() *api.ObjectMeta {
	return ctx.obj.GetObjectMeta()
}

func (ctx *eventpolicyCtx) RuntimeObject() runtime.Object {
	var v interface{}
	v = ctx.obj
	return v.(runtime.Object)
}

func (ctx *eventpolicyCtx) WorkFunc(context context.Context) error {
	var err error
	evt := ctx.event
	ct := ctx.obj.ctrler
	kind := "EventPolicy"
	ct.Lock()
	handler, ok := ct.handlers[kind]
	ct.Unlock()
	if !ok {
		ct.logger.Fatalf("Cant find the handler for %s", kind)
	}
	eventpolicyHandler := handler.(EventPolicyHandler)
	switch evt {
	case kvstore.Created:
		ctx.obj.Lock()
		err = eventpolicyHandler.OnEventPolicyCreate(ctx.obj)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctx.obj, err)
			ctx.SetEvent(kvstore.Deleted)
		}
	case kvstore.Updated:
		ct.stats.Counter("EventPolicy_Updated_Events").Inc()
		ctx.obj.Lock()
		p := monitoring.EventPolicy{Spec: ctx.newObj.obj.Spec,
			ObjectMeta: ctx.newObj.obj.ObjectMeta,
			TypeMeta:   ctx.newObj.obj.TypeMeta,
			Status:     ctx.newObj.obj.Status}
		err = eventpolicyHandler.OnEventPolicyUpdate(ctx.obj, &p)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctx.obj, err)
			ctx.SetEvent(kvstore.Deleted)
		}
	case kvstore.Deleted:
		ctx.obj.Lock()
		err = eventpolicyHandler.OnEventPolicyDelete(ctx.obj)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error deleting %s %+v. Err: %v", kind, ctx.obj, err)
		}
	}
	ct.resolveObject(ctx.event, ctx)
	return nil
}

// handleEventPolicyEventParallel handles EventPolicy events from watcher
func (ct *ctrlerCtx) handleEventPolicyEventParallel(evt *kvstore.WatchEvent) error {

	if ct.objResolver == nil {
		return ct.handleEventPolicyEventParallelWithNoResolver(evt)
	}

	switch tp := evt.Object.(type) {
	case *monitoring.EventPolicy:
		eobj := evt.Object.(*monitoring.EventPolicy)
		kind := "EventPolicy"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ctx := &eventpolicyCtx{event: evt.Type, obj: &EventPolicy{EventPolicy: *eobj, ctrler: ct}}

		var err error
		switch evt.Type {
		case kvstore.Created:
			err = ct.processAdd(ctx)
		case kvstore.Updated:
			err = ct.processUpdate(ctx)
		case kvstore.Deleted:
			err = ct.processDelete(ctx)
		}
		return err
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on EventPolicy watch channel", tp)
	}

	return nil
}

// handleEventPolicyEventParallel handles EventPolicy events from watcher
func (ct *ctrlerCtx) handleEventPolicyEventParallelWithNoResolver(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *monitoring.EventPolicy:
		eobj := evt.Object.(*monitoring.EventPolicy)
		kind := "EventPolicy"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		eventpolicyHandler := handler.(EventPolicyHandler)
		// handle based on event type
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			workFunc := func(ctx context.Context, ctrlCtx shardworkers.WorkObj) error {
				var err error
				workCtx := ctrlCtx.(*eventpolicyCtx)
				eobj := workCtx.obj
				fobj, err := ct.getObject(kind, workCtx.GetKey())
				if err != nil {
					ct.addObject(workCtx)
					ct.stats.Counter("EventPolicy_Created_Events").Inc()
					eobj.Lock()
					err = eventpolicyHandler.OnEventPolicyCreate(eobj)
					eobj.Unlock()
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, eobj, err)
						ct.delObject(kind, workCtx.GetKey())
					}
				} else {
					workCtx := fobj.(*eventpolicyCtx)
					obj := workCtx.obj
					ct.stats.Counter("EventPolicy_Updated_Events").Inc()
					obj.Lock()
					p := monitoring.EventPolicy{Spec: eobj.Spec,
						ObjectMeta: eobj.ObjectMeta,
						TypeMeta:   eobj.TypeMeta,
						Status:     eobj.Status}

					err = eventpolicyHandler.OnEventPolicyUpdate(obj, &p)
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					} else {
						workCtx.obj.EventPolicy = p
					}
					obj.Unlock()
				}
				return err
			}
			ctrlCtx := &eventpolicyCtx{event: evt.Type, obj: &EventPolicy{EventPolicy: *eobj, ctrler: ct}}
			ct.runFunction("EventPolicy", ctrlCtx, workFunc)
		case kvstore.Deleted:
			workFunc := func(ctx context.Context, ctrlCtx shardworkers.WorkObj) error {
				var err error
				workCtx := ctrlCtx.(*eventpolicyCtx)
				eobj := workCtx.obj
				fobj, err := ct.findObject(kind, workCtx.GetKey())
				if err != nil {
					ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
					return err
				}
				obj := fobj.(*EventPolicy)
				ct.stats.Counter("EventPolicy_Deleted_Events").Inc()
				obj.Lock()
				err = eventpolicyHandler.OnEventPolicyDelete(obj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
				}
				ct.delObject(kind, workCtx.GetKey())
				return nil
			}
			ctrlCtx := &eventpolicyCtx{event: evt.Type, obj: &EventPolicy{EventPolicy: *eobj, ctrler: ct}}
			ct.runFunction("EventPolicy", ctrlCtx, workFunc)
		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on EventPolicy watch channel", tp)
	}

	return nil
}

// diffEventPolicy does a diff of EventPolicy objects between local cache and API server
func (ct *ctrlerCtx) diffEventPolicy(apicl apiclient.Services) {
	opts := api.ListWatchOptions{}

	// get a list of all objects from API server
	objlist, err := apicl.MonitoringV1().EventPolicy().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Errorf("Error getting a list of objects. Err: %v", err)
		return
	}

	ct.logger.Infof("diffEventPolicy(): EventPolicyList returned %d objects", len(objlist))

	// build an object map
	objmap := make(map[string]*monitoring.EventPolicy)
	for _, obj := range objlist {
		objmap[obj.GetKey()] = obj
	}

	list, err := ct.EventPolicy().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Infof("Failed to get a list of objects. Err: %s", err)
		return
	}

	// if an object is in our local cache and not in API server, trigger delete for it
	for _, obj := range list {
		_, ok := objmap[obj.GetKey()]
		if !ok {
			ct.logger.Infof("diffEventPolicy(): Deleting existing object %#v since its not in apiserver", obj.GetKey())
			evt := kvstore.WatchEvent{
				Type:   kvstore.Deleted,
				Key:    obj.GetKey(),
				Object: &obj.EventPolicy,
			}
			ct.handleEventPolicyEvent(&evt)
		}
	}

	// trigger create event for all others
	for _, obj := range objlist {
		ct.logger.Infof("diffEventPolicy(): Adding object %#v", obj.GetKey())
		evt := kvstore.WatchEvent{
			Type:   kvstore.Created,
			Key:    obj.GetKey(),
			Object: obj,
		}
		ct.handleEventPolicyEvent(&evt)
	}
}

func (ct *ctrlerCtx) runEventPolicyWatcher() {
	kind := "EventPolicy"

	ct.Lock()
	handler, ok := ct.handlers[kind]
	ct.Unlock()
	if !ok {
		ct.logger.Fatalf("Cant find the handler for %s", kind)
	}
	eventpolicyHandler := handler.(EventPolicyHandler)

	opts := eventpolicyHandler.GetEventPolicyWatchOptions()

	// if there is no API server to connect to, we are done
	if (ct.resolver == nil) || ct.apisrvURL == "" {
		return
	}

	// create context
	ctx, cancel := context.WithCancel(context.Background())
	ct.Lock()
	ct.watchCancel[kind] = cancel
	ct.Unlock()
	logger := ct.logger.WithContext("submodule", "EventPolicyWatcher")

	// create a grpc client
	apiclt, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
	if err == nil {
		ct.diffEventPolicy(apiclt)
	}

	// setup wait group
	ct.waitGrp.Add(1)

	// start a goroutine
	go func() {
		defer ct.waitGrp.Done()
		ct.stats.Counter("EventPolicy_Watch").Inc()
		defer ct.stats.Counter("EventPolicy_Watch").Dec()

		// loop forever
		for {
			// create a grpc client
			apicl, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
			if err != nil {
				logger.Warnf("Failed to connect to gRPC server [%s]\n", ct.apisrvURL)
				ct.stats.Counter("EventPolicy_ApiClientErr").Inc()
			} else {
				logger.Infof("API client connected {%+v}", apicl)

				// EventPolicy object watcher
				wt, werr := apicl.MonitoringV1().EventPolicy().Watch(ctx, opts)
				if werr != nil {
					select {
					case <-ctx.Done():
						logger.Infof("watch %s cancelled", kind)
						return
					default:
					}
					logger.Errorf("Failed to start %s watch (%s)\n", kind, werr)
					// wait for a second and retry connecting to api server
					apicl.Close()
					time.Sleep(time.Second)
					continue
				}
				ct.Lock()
				ct.watchers[kind] = wt
				ct.Unlock()

				// perform a diff with API server and local cache
				time.Sleep(time.Millisecond * 100)
				ct.diffEventPolicy(apicl)

				// handle api server watch events
			innerLoop:
				for {
					// wait for events
					select {
					case evt, ok := <-wt.EventChan():
						if !ok {
							logger.Error("Error receiving from apisrv watcher")
							ct.stats.Counter("EventPolicy_WatchErrors").Inc()
							break innerLoop
						}

						// handle event in parallel
						ct.handleEventPolicyEventParallel(evt)
					}
				}
				apicl.Close()
			}

			// if stop flag is set, we are done
			if ct.stoped {
				logger.Infof("Exiting API server watcher")
				return
			}

			// wait for a second and retry connecting to api server
			time.Sleep(time.Second)
		}
	}()
}

// WatchEventPolicy starts watch on EventPolicy object
func (ct *ctrlerCtx) WatchEventPolicy(handler EventPolicyHandler) error {
	kind := "EventPolicy"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchers[kind]
	ct.Unlock()
	if ok {
		return fmt.Errorf("EventPolicy watcher already exists")
	}

	// save handler
	ct.Lock()
	ct.handlers[kind] = handler
	ct.Unlock()

	// run EventPolicy watcher in a go routine
	ct.runEventPolicyWatcher()

	return nil
}

// StopWatchEventPolicy stops watch on EventPolicy object
func (ct *ctrlerCtx) StopWatchEventPolicy(handler EventPolicyHandler) error {
	kind := "EventPolicy"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchers[kind]
	ct.Unlock()
	if !ok {
		return fmt.Errorf("EventPolicy watcher does not exist")
	}

	ct.Lock()
	cancel, _ := ct.watchCancel[kind]
	cancel()
	delete(ct.watchers, kind)
	delete(ct.watchCancel, kind)
	ct.Unlock()

	time.Sleep(100 * time.Millisecond)

	return nil
}

// EventPolicyAPI returns
type EventPolicyAPI interface {
	Create(obj *monitoring.EventPolicy) error
	SyncCreate(obj *monitoring.EventPolicy) error
	Update(obj *monitoring.EventPolicy) error
	SyncUpdate(obj *monitoring.EventPolicy) error
	Delete(obj *monitoring.EventPolicy) error
	Find(meta *api.ObjectMeta) (*EventPolicy, error)
	List(ctx context.Context, opts *api.ListWatchOptions) ([]*EventPolicy, error)
	Watch(handler EventPolicyHandler) error
	StopWatch(handler EventPolicyHandler) error
}

// dummy struct that implements EventPolicyAPI
type eventpolicyAPI struct {
	ct *ctrlerCtx
}

// Create creates EventPolicy object
func (api *eventpolicyAPI) Create(obj *monitoring.EventPolicy) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.MonitoringV1().EventPolicy().Create(context.Background(), obj)
		if err != nil && strings.Contains(err.Error(), "AlreadyExists") {
			_, err = apicl.MonitoringV1().EventPolicy().Update(context.Background(), obj)
		}
		return err
	}

	api.ct.handleEventPolicyEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Created})
	return nil
}

// SyncCreate creates EventPolicy object and updates the cache
func (api *eventpolicyAPI) SyncCreate(obj *monitoring.EventPolicy) error {
	newObj := obj
	evtType := kvstore.Created
	var writeErr error
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		newObj, writeErr = apicl.MonitoringV1().EventPolicy().Create(context.Background(), obj)
		if writeErr != nil && strings.Contains(err.Error(), "AlreadyExists") {
			newObj, writeErr = apicl.MonitoringV1().EventPolicy().Update(context.Background(), obj)
			evtType = kvstore.Updated
		}
	}

	if writeErr == nil {
		api.ct.handleEventPolicyEvent(&kvstore.WatchEvent{Object: newObj, Type: evtType})
	}

	if writeErr == nil {
		api.ct.handleEventPolicyEvent(&kvstore.WatchEvent{Object: newObj, Type: evtType})
	}

	return writeErr
}

// Update triggers update on EventPolicy object
func (api *eventpolicyAPI) Update(obj *monitoring.EventPolicy) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.MonitoringV1().EventPolicy().Update(context.Background(), obj)
		return err
	}

	api.ct.handleEventPolicyEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Updated})
	return nil
}

// SyncUpdate triggers update on EventPolicy object and updates the cache
func (api *eventpolicyAPI) SyncUpdate(obj *monitoring.EventPolicy) error {
	newObj := obj
	var writeErr error
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		newObj, writeErr = apicl.MonitoringV1().EventPolicy().Update(context.Background(), obj)
	}

	if writeErr == nil {
		api.ct.handleEventPolicyEvent(&kvstore.WatchEvent{Object: newObj, Type: kvstore.Updated})
	}

	return writeErr
}

// Delete deletes EventPolicy object
func (api *eventpolicyAPI) Delete(obj *monitoring.EventPolicy) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.MonitoringV1().EventPolicy().Delete(context.Background(), &obj.ObjectMeta)
		return err
	}

	api.ct.handleEventPolicyEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Deleted})
	return nil
}

// MakeKey generates a KV store key for the object
func (api *eventpolicyAPI) getFullKey(tenant, name string) string {
	if tenant != "" {
		return fmt.Sprint(globals.ConfigRootPrefix, "/", "monitoring", "/", "event-policy", "/", tenant, "/", name)
	}
	return fmt.Sprint(globals.ConfigRootPrefix, "/", "monitoring", "/", "event-policy", "/", name)
}

// Find returns an object by meta
func (api *eventpolicyAPI) Find(meta *api.ObjectMeta) (*EventPolicy, error) {
	// find the object
	obj, err := api.ct.FindObject("EventPolicy", meta)
	if err != nil {
		return nil, err
	}

	// asset type
	switch obj.(type) {
	case *EventPolicy:
		hobj := obj.(*EventPolicy)
		return hobj, nil
	default:
		return nil, errors.New("incorrect object type")
	}
}

// List returns a list of all EventPolicy objects
func (api *eventpolicyAPI) List(ctx context.Context, opts *api.ListWatchOptions) ([]*EventPolicy, error) {
	var objlist []*EventPolicy
	objs, err := api.ct.List("EventPolicy", ctx, opts)

	if err != nil {
		return nil, err
	}

	for _, obj := range objs {
		switch tp := obj.(type) {
		case *EventPolicy:
			eobj := obj.(*EventPolicy)
			objlist = append(objlist, eobj)
		default:
			log.Fatalf("Got invalid object type %v while looking for EventPolicy", tp)
		}
	}

	return objlist, nil
}

// Watch sets up a event handlers for EventPolicy object
func (api *eventpolicyAPI) Watch(handler EventPolicyHandler) error {
	api.ct.startWorkerPool("EventPolicy")
	return api.ct.WatchEventPolicy(handler)
}

// StopWatch stop watch for Tenant EventPolicy object
func (api *eventpolicyAPI) StopWatch(handler EventPolicyHandler) error {
	api.ct.Lock()
	api.ct.workPools["EventPolicy"].Stop()
	api.ct.Unlock()
	return api.ct.StopWatchEventPolicy(handler)
}

// EventPolicy returns EventPolicyAPI
func (ct *ctrlerCtx) EventPolicy() EventPolicyAPI {
	return &eventpolicyAPI{ct: ct}
}

// FwlogPolicy is a wrapper object that implements additional functionality
type FwlogPolicy struct {
	sync.Mutex
	monitoring.FwlogPolicy
	HandlerCtx interface{} // additional state handlers can store
	ctrler     *ctrlerCtx  // reference back to the controller instance
}

func (obj *FwlogPolicy) Write() error {
	// if there is no API server to connect to, we are done
	if (obj.ctrler == nil) || (obj.ctrler.resolver == nil) || obj.ctrler.apisrvURL == "" {
		return nil
	}

	apicl, err := obj.ctrler.apiClient()
	if err != nil {
		obj.ctrler.logger.Errorf("Error creating API server clent. Err: %v", err)
		return err
	}

	obj.ctrler.stats.Counter("FwlogPolicy_Writes").Inc()

	// write to api server
	if obj.ObjectMeta.ResourceVersion != "" {
		// update it
		for i := 0; i < maxApisrvWriteRetry; i++ {
			_, err = apicl.MonitoringV1().FwlogPolicy().UpdateStatus(context.Background(), &obj.FwlogPolicy)
			if err == nil {
				break
			}
			time.Sleep(time.Millisecond * 100)
		}
	} else {
		//  create
		_, err = apicl.MonitoringV1().FwlogPolicy().Create(context.Background(), &obj.FwlogPolicy)
	}

	return nil
}

// FwlogPolicyHandler is the event handler for FwlogPolicy object
type FwlogPolicyHandler interface {
	OnFwlogPolicyCreate(obj *FwlogPolicy) error
	OnFwlogPolicyUpdate(oldObj *FwlogPolicy, newObj *monitoring.FwlogPolicy) error
	OnFwlogPolicyDelete(obj *FwlogPolicy) error
	GetFwlogPolicyWatchOptions() *api.ListWatchOptions
}

// OnFwlogPolicyCreate is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnFwlogPolicyCreate(obj *FwlogPolicy) error {
	log.Info("OnFwlogPolicyCreate is not implemented")
	return nil
}

// OnFwlogPolicyUpdate is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnFwlogPolicyUpdate(oldObj *FwlogPolicy, newObj *monitoring.FwlogPolicy) error {
	log.Info("OnFwlogPolicyUpdate is not implemented")
	return nil
}

// OnFwlogPolicyDelete is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnFwlogPolicyDelete(obj *FwlogPolicy) error {
	log.Info("OnFwlogPolicyDelete is not implemented")
	return nil
}

// GetFwlogPolicyWatchOptions is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) GetFwlogPolicyWatchOptions() *api.ListWatchOptions {
	log.Info("GetFwlogPolicyWatchOptions is not implemented")
	opts := &api.ListWatchOptions{}
	return opts
}

// handleFwlogPolicyEvent handles FwlogPolicy events from watcher
func (ct *ctrlerCtx) handleFwlogPolicyEvent(evt *kvstore.WatchEvent) error {

	if ct.objResolver == nil {
		return ct.handleFwlogPolicyEventNoResolver(evt)
	}

	switch tp := evt.Object.(type) {
	case *monitoring.FwlogPolicy:
		eobj := evt.Object.(*monitoring.FwlogPolicy)
		kind := "FwlogPolicy"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ctx := &fwlogpolicyCtx{event: evt.Type,
			obj: &FwlogPolicy{FwlogPolicy: *eobj, ctrler: ct}}

		var err error
		switch evt.Type {
		case kvstore.Created:
			err = ct.processAdd(ctx)
		case kvstore.Updated:
			err = ct.processUpdate(ctx)
		case kvstore.Deleted:
			err = ct.processDelete(ctx)
		}
		return err
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on FwlogPolicy watch channel", tp)
	}

	return nil
}

// handleFwlogPolicyEventNoResolver handles FwlogPolicy events from watcher
func (ct *ctrlerCtx) handleFwlogPolicyEventNoResolver(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *monitoring.FwlogPolicy:
		eobj := evt.Object.(*monitoring.FwlogPolicy)
		kind := "FwlogPolicy"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		fwlogpolicyHandler := handler.(FwlogPolicyHandler)
		// handle based on event type
		ctrlCtx := &fwlogpolicyCtx{event: evt.Type, obj: &FwlogPolicy{FwlogPolicy: *eobj, ctrler: ct}}
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			fobj, err := ct.getObject(kind, ctrlCtx.GetKey())
			if err != nil {
				ct.addObject(ctrlCtx)
				ct.stats.Counter("FwlogPolicy_Created_Events").Inc()

				// call the event handler
				ctrlCtx.Lock()
				err = fwlogpolicyHandler.OnFwlogPolicyCreate(ctrlCtx.obj)
				ctrlCtx.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctrlCtx.obj, err)
					ct.delObject(kind, ctrlCtx.GetKey())
					return err
				}
			} else {
				if ct.resolver != nil && fobj.GetResourceVersion() >= eobj.GetResourceVersion() {
					// Event already processed.
					ct.logger.Infof("Skipping update due to old resource version")
					return nil
				}
				ctrlCtx := fobj.(*fwlogpolicyCtx)
				ct.stats.Counter("FwlogPolicy_Updated_Events").Inc()
				ctrlCtx.Lock()
				p := monitoring.FwlogPolicy{Spec: eobj.Spec,
					ObjectMeta: eobj.ObjectMeta,
					TypeMeta:   eobj.TypeMeta,
					Status:     eobj.Status}

				err = fwlogpolicyHandler.OnFwlogPolicyUpdate(ctrlCtx.obj, &p)
				ctrlCtx.obj.FwlogPolicy = *eobj
				ctrlCtx.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctrlCtx.obj, err)
					return err
				}

			}
		case kvstore.Deleted:
			ctrlCtx := &fwlogpolicyCtx{event: evt.Type, obj: &FwlogPolicy{FwlogPolicy: *eobj, ctrler: ct}}
			fobj, err := ct.findObject(kind, ctrlCtx.GetKey())
			if err != nil {
				ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
				return err
			}

			obj := fobj.(*FwlogPolicy)
			ct.stats.Counter("FwlogPolicy_Deleted_Events").Inc()
			obj.Lock()
			err = fwlogpolicyHandler.OnFwlogPolicyDelete(obj)
			obj.Unlock()
			if err != nil {
				ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
			}
			ct.delObject(kind, ctrlCtx.GetKey())
			return nil

		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on FwlogPolicy watch channel", tp)
	}

	return nil
}

type fwlogpolicyCtx struct {
	ctkitBaseCtx
	event kvstore.WatchEventType
	obj   *FwlogPolicy //
	//   newObj     *monitoring.FwlogPolicy //update
	newObj *fwlogpolicyCtx //update
}

func (ctx *fwlogpolicyCtx) References() map[string]apiintf.ReferenceObj {
	resp := make(map[string]apiintf.ReferenceObj)
	ctx.obj.References(ctx.obj.GetObjectMeta().Name, ctx.obj.GetObjectMeta().Namespace, resp)
	return resp
}

func (ctx *fwlogpolicyCtx) GetKey() string {
	return ctx.obj.MakeKey("monitoring")
}

func (ctx *fwlogpolicyCtx) GetKind() string {
	return ctx.obj.GetKind()
}

func (ctx *fwlogpolicyCtx) GetResourceVersion() string {
	return ctx.obj.GetResourceVersion()
}

func (ctx *fwlogpolicyCtx) SetEvent(event kvstore.WatchEventType) {
	ctx.event = event
}

func (ctx *fwlogpolicyCtx) SetNewObj(newObj apiintf.CtkitObject) {
	if newObj == nil {
		ctx.newObj = nil
	} else {
		ctx.newObj = newObj.(*fwlogpolicyCtx)
		ctx.newObj.obj.HandlerCtx = ctx.obj.HandlerCtx
	}
}

func (ctx *fwlogpolicyCtx) GetNewObj() apiintf.CtkitObject {
	return ctx.newObj
}

func (ctx *fwlogpolicyCtx) Copy(obj apiintf.CtkitObject) {
	ctx.obj.FwlogPolicy = obj.(*fwlogpolicyCtx).obj.FwlogPolicy
}

func (ctx *fwlogpolicyCtx) Lock() {
	ctx.obj.Lock()
}

func (ctx *fwlogpolicyCtx) Unlock() {
	ctx.obj.Unlock()
}

func (ctx *fwlogpolicyCtx) GetObjectMeta() *api.ObjectMeta {
	return ctx.obj.GetObjectMeta()
}

func (ctx *fwlogpolicyCtx) RuntimeObject() runtime.Object {
	var v interface{}
	v = ctx.obj
	return v.(runtime.Object)
}

func (ctx *fwlogpolicyCtx) WorkFunc(context context.Context) error {
	var err error
	evt := ctx.event
	ct := ctx.obj.ctrler
	kind := "FwlogPolicy"
	ct.Lock()
	handler, ok := ct.handlers[kind]
	ct.Unlock()
	if !ok {
		ct.logger.Fatalf("Cant find the handler for %s", kind)
	}
	fwlogpolicyHandler := handler.(FwlogPolicyHandler)
	switch evt {
	case kvstore.Created:
		ctx.obj.Lock()
		err = fwlogpolicyHandler.OnFwlogPolicyCreate(ctx.obj)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctx.obj, err)
			ctx.SetEvent(kvstore.Deleted)
		}
	case kvstore.Updated:
		ct.stats.Counter("FwlogPolicy_Updated_Events").Inc()
		ctx.obj.Lock()
		p := monitoring.FwlogPolicy{Spec: ctx.newObj.obj.Spec,
			ObjectMeta: ctx.newObj.obj.ObjectMeta,
			TypeMeta:   ctx.newObj.obj.TypeMeta,
			Status:     ctx.newObj.obj.Status}
		err = fwlogpolicyHandler.OnFwlogPolicyUpdate(ctx.obj, &p)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctx.obj, err)
			ctx.SetEvent(kvstore.Deleted)
		}
	case kvstore.Deleted:
		ctx.obj.Lock()
		err = fwlogpolicyHandler.OnFwlogPolicyDelete(ctx.obj)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error deleting %s %+v. Err: %v", kind, ctx.obj, err)
		}
	}
	ct.resolveObject(ctx.event, ctx)
	return nil
}

// handleFwlogPolicyEventParallel handles FwlogPolicy events from watcher
func (ct *ctrlerCtx) handleFwlogPolicyEventParallel(evt *kvstore.WatchEvent) error {

	if ct.objResolver == nil {
		return ct.handleFwlogPolicyEventParallelWithNoResolver(evt)
	}

	switch tp := evt.Object.(type) {
	case *monitoring.FwlogPolicy:
		eobj := evt.Object.(*monitoring.FwlogPolicy)
		kind := "FwlogPolicy"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ctx := &fwlogpolicyCtx{event: evt.Type, obj: &FwlogPolicy{FwlogPolicy: *eobj, ctrler: ct}}

		var err error
		switch evt.Type {
		case kvstore.Created:
			err = ct.processAdd(ctx)
		case kvstore.Updated:
			err = ct.processUpdate(ctx)
		case kvstore.Deleted:
			err = ct.processDelete(ctx)
		}
		return err
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on FwlogPolicy watch channel", tp)
	}

	return nil
}

// handleFwlogPolicyEventParallel handles FwlogPolicy events from watcher
func (ct *ctrlerCtx) handleFwlogPolicyEventParallelWithNoResolver(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *monitoring.FwlogPolicy:
		eobj := evt.Object.(*monitoring.FwlogPolicy)
		kind := "FwlogPolicy"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		fwlogpolicyHandler := handler.(FwlogPolicyHandler)
		// handle based on event type
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			workFunc := func(ctx context.Context, ctrlCtx shardworkers.WorkObj) error {
				var err error
				workCtx := ctrlCtx.(*fwlogpolicyCtx)
				eobj := workCtx.obj
				fobj, err := ct.getObject(kind, workCtx.GetKey())
				if err != nil {
					ct.addObject(workCtx)
					ct.stats.Counter("FwlogPolicy_Created_Events").Inc()
					eobj.Lock()
					err = fwlogpolicyHandler.OnFwlogPolicyCreate(eobj)
					eobj.Unlock()
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, eobj, err)
						ct.delObject(kind, workCtx.GetKey())
					}
				} else {
					workCtx := fobj.(*fwlogpolicyCtx)
					obj := workCtx.obj
					ct.stats.Counter("FwlogPolicy_Updated_Events").Inc()
					obj.Lock()
					p := monitoring.FwlogPolicy{Spec: eobj.Spec,
						ObjectMeta: eobj.ObjectMeta,
						TypeMeta:   eobj.TypeMeta,
						Status:     eobj.Status}

					err = fwlogpolicyHandler.OnFwlogPolicyUpdate(obj, &p)
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					} else {
						workCtx.obj.FwlogPolicy = p
					}
					obj.Unlock()
				}
				return err
			}
			ctrlCtx := &fwlogpolicyCtx{event: evt.Type, obj: &FwlogPolicy{FwlogPolicy: *eobj, ctrler: ct}}
			ct.runFunction("FwlogPolicy", ctrlCtx, workFunc)
		case kvstore.Deleted:
			workFunc := func(ctx context.Context, ctrlCtx shardworkers.WorkObj) error {
				var err error
				workCtx := ctrlCtx.(*fwlogpolicyCtx)
				eobj := workCtx.obj
				fobj, err := ct.findObject(kind, workCtx.GetKey())
				if err != nil {
					ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
					return err
				}
				obj := fobj.(*FwlogPolicy)
				ct.stats.Counter("FwlogPolicy_Deleted_Events").Inc()
				obj.Lock()
				err = fwlogpolicyHandler.OnFwlogPolicyDelete(obj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
				}
				ct.delObject(kind, workCtx.GetKey())
				return nil
			}
			ctrlCtx := &fwlogpolicyCtx{event: evt.Type, obj: &FwlogPolicy{FwlogPolicy: *eobj, ctrler: ct}}
			ct.runFunction("FwlogPolicy", ctrlCtx, workFunc)
		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on FwlogPolicy watch channel", tp)
	}

	return nil
}

// diffFwlogPolicy does a diff of FwlogPolicy objects between local cache and API server
func (ct *ctrlerCtx) diffFwlogPolicy(apicl apiclient.Services) {
	opts := api.ListWatchOptions{}

	// get a list of all objects from API server
	objlist, err := apicl.MonitoringV1().FwlogPolicy().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Errorf("Error getting a list of objects. Err: %v", err)
		return
	}

	ct.logger.Infof("diffFwlogPolicy(): FwlogPolicyList returned %d objects", len(objlist))

	// build an object map
	objmap := make(map[string]*monitoring.FwlogPolicy)
	for _, obj := range objlist {
		objmap[obj.GetKey()] = obj
	}

	list, err := ct.FwlogPolicy().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Infof("Failed to get a list of objects. Err: %s", err)
		return
	}

	// if an object is in our local cache and not in API server, trigger delete for it
	for _, obj := range list {
		_, ok := objmap[obj.GetKey()]
		if !ok {
			ct.logger.Infof("diffFwlogPolicy(): Deleting existing object %#v since its not in apiserver", obj.GetKey())
			evt := kvstore.WatchEvent{
				Type:   kvstore.Deleted,
				Key:    obj.GetKey(),
				Object: &obj.FwlogPolicy,
			}
			ct.handleFwlogPolicyEvent(&evt)
		}
	}

	// trigger create event for all others
	for _, obj := range objlist {
		ct.logger.Infof("diffFwlogPolicy(): Adding object %#v", obj.GetKey())
		evt := kvstore.WatchEvent{
			Type:   kvstore.Created,
			Key:    obj.GetKey(),
			Object: obj,
		}
		ct.handleFwlogPolicyEvent(&evt)
	}
}

func (ct *ctrlerCtx) runFwlogPolicyWatcher() {
	kind := "FwlogPolicy"

	ct.Lock()
	handler, ok := ct.handlers[kind]
	ct.Unlock()
	if !ok {
		ct.logger.Fatalf("Cant find the handler for %s", kind)
	}
	fwlogpolicyHandler := handler.(FwlogPolicyHandler)

	opts := fwlogpolicyHandler.GetFwlogPolicyWatchOptions()

	// if there is no API server to connect to, we are done
	if (ct.resolver == nil) || ct.apisrvURL == "" {
		return
	}

	// create context
	ctx, cancel := context.WithCancel(context.Background())
	ct.Lock()
	ct.watchCancel[kind] = cancel
	ct.Unlock()
	logger := ct.logger.WithContext("submodule", "FwlogPolicyWatcher")

	// create a grpc client
	apiclt, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
	if err == nil {
		ct.diffFwlogPolicy(apiclt)
	}

	// setup wait group
	ct.waitGrp.Add(1)

	// start a goroutine
	go func() {
		defer ct.waitGrp.Done()
		ct.stats.Counter("FwlogPolicy_Watch").Inc()
		defer ct.stats.Counter("FwlogPolicy_Watch").Dec()

		// loop forever
		for {
			// create a grpc client
			apicl, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
			if err != nil {
				logger.Warnf("Failed to connect to gRPC server [%s]\n", ct.apisrvURL)
				ct.stats.Counter("FwlogPolicy_ApiClientErr").Inc()
			} else {
				logger.Infof("API client connected {%+v}", apicl)

				// FwlogPolicy object watcher
				wt, werr := apicl.MonitoringV1().FwlogPolicy().Watch(ctx, opts)
				if werr != nil {
					select {
					case <-ctx.Done():
						logger.Infof("watch %s cancelled", kind)
						return
					default:
					}
					logger.Errorf("Failed to start %s watch (%s)\n", kind, werr)
					// wait for a second and retry connecting to api server
					apicl.Close()
					time.Sleep(time.Second)
					continue
				}
				ct.Lock()
				ct.watchers[kind] = wt
				ct.Unlock()

				// perform a diff with API server and local cache
				time.Sleep(time.Millisecond * 100)
				ct.diffFwlogPolicy(apicl)

				// handle api server watch events
			innerLoop:
				for {
					// wait for events
					select {
					case evt, ok := <-wt.EventChan():
						if !ok {
							logger.Error("Error receiving from apisrv watcher")
							ct.stats.Counter("FwlogPolicy_WatchErrors").Inc()
							break innerLoop
						}

						// handle event in parallel
						ct.handleFwlogPolicyEventParallel(evt)
					}
				}
				apicl.Close()
			}

			// if stop flag is set, we are done
			if ct.stoped {
				logger.Infof("Exiting API server watcher")
				return
			}

			// wait for a second and retry connecting to api server
			time.Sleep(time.Second)
		}
	}()
}

// WatchFwlogPolicy starts watch on FwlogPolicy object
func (ct *ctrlerCtx) WatchFwlogPolicy(handler FwlogPolicyHandler) error {
	kind := "FwlogPolicy"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchers[kind]
	ct.Unlock()
	if ok {
		return fmt.Errorf("FwlogPolicy watcher already exists")
	}

	// save handler
	ct.Lock()
	ct.handlers[kind] = handler
	ct.Unlock()

	// run FwlogPolicy watcher in a go routine
	ct.runFwlogPolicyWatcher()

	return nil
}

// StopWatchFwlogPolicy stops watch on FwlogPolicy object
func (ct *ctrlerCtx) StopWatchFwlogPolicy(handler FwlogPolicyHandler) error {
	kind := "FwlogPolicy"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchers[kind]
	ct.Unlock()
	if !ok {
		return fmt.Errorf("FwlogPolicy watcher does not exist")
	}

	ct.Lock()
	cancel, _ := ct.watchCancel[kind]
	cancel()
	delete(ct.watchers, kind)
	delete(ct.watchCancel, kind)
	ct.Unlock()

	time.Sleep(100 * time.Millisecond)

	return nil
}

// FwlogPolicyAPI returns
type FwlogPolicyAPI interface {
	Create(obj *monitoring.FwlogPolicy) error
	SyncCreate(obj *monitoring.FwlogPolicy) error
	Update(obj *monitoring.FwlogPolicy) error
	SyncUpdate(obj *monitoring.FwlogPolicy) error
	Delete(obj *monitoring.FwlogPolicy) error
	Find(meta *api.ObjectMeta) (*FwlogPolicy, error)
	List(ctx context.Context, opts *api.ListWatchOptions) ([]*FwlogPolicy, error)
	Watch(handler FwlogPolicyHandler) error
	StopWatch(handler FwlogPolicyHandler) error
}

// dummy struct that implements FwlogPolicyAPI
type fwlogpolicyAPI struct {
	ct *ctrlerCtx
}

// Create creates FwlogPolicy object
func (api *fwlogpolicyAPI) Create(obj *monitoring.FwlogPolicy) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.MonitoringV1().FwlogPolicy().Create(context.Background(), obj)
		if err != nil && strings.Contains(err.Error(), "AlreadyExists") {
			_, err = apicl.MonitoringV1().FwlogPolicy().Update(context.Background(), obj)
		}
		return err
	}

	api.ct.handleFwlogPolicyEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Created})
	return nil
}

// SyncCreate creates FwlogPolicy object and updates the cache
func (api *fwlogpolicyAPI) SyncCreate(obj *monitoring.FwlogPolicy) error {
	newObj := obj
	evtType := kvstore.Created
	var writeErr error
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		newObj, writeErr = apicl.MonitoringV1().FwlogPolicy().Create(context.Background(), obj)
		if writeErr != nil && strings.Contains(err.Error(), "AlreadyExists") {
			newObj, writeErr = apicl.MonitoringV1().FwlogPolicy().Update(context.Background(), obj)
			evtType = kvstore.Updated
		}
	}

	if writeErr == nil {
		api.ct.handleFwlogPolicyEvent(&kvstore.WatchEvent{Object: newObj, Type: evtType})
	}

	if writeErr == nil {
		api.ct.handleFwlogPolicyEvent(&kvstore.WatchEvent{Object: newObj, Type: evtType})
	}

	return writeErr
}

// Update triggers update on FwlogPolicy object
func (api *fwlogpolicyAPI) Update(obj *monitoring.FwlogPolicy) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.MonitoringV1().FwlogPolicy().Update(context.Background(), obj)
		return err
	}

	api.ct.handleFwlogPolicyEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Updated})
	return nil
}

// SyncUpdate triggers update on FwlogPolicy object and updates the cache
func (api *fwlogpolicyAPI) SyncUpdate(obj *monitoring.FwlogPolicy) error {
	newObj := obj
	var writeErr error
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		newObj, writeErr = apicl.MonitoringV1().FwlogPolicy().Update(context.Background(), obj)
	}

	if writeErr == nil {
		api.ct.handleFwlogPolicyEvent(&kvstore.WatchEvent{Object: newObj, Type: kvstore.Updated})
	}

	return writeErr
}

// Delete deletes FwlogPolicy object
func (api *fwlogpolicyAPI) Delete(obj *monitoring.FwlogPolicy) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.MonitoringV1().FwlogPolicy().Delete(context.Background(), &obj.ObjectMeta)
		return err
	}

	api.ct.handleFwlogPolicyEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Deleted})
	return nil
}

// MakeKey generates a KV store key for the object
func (api *fwlogpolicyAPI) getFullKey(tenant, name string) string {
	if tenant != "" {
		return fmt.Sprint(globals.ConfigRootPrefix, "/", "monitoring", "/", "fwlogPolicy", "/", tenant, "/", name)
	}
	return fmt.Sprint(globals.ConfigRootPrefix, "/", "monitoring", "/", "fwlogPolicy", "/", name)
}

// Find returns an object by meta
func (api *fwlogpolicyAPI) Find(meta *api.ObjectMeta) (*FwlogPolicy, error) {
	// find the object
	obj, err := api.ct.FindObject("FwlogPolicy", meta)
	if err != nil {
		return nil, err
	}

	// asset type
	switch obj.(type) {
	case *FwlogPolicy:
		hobj := obj.(*FwlogPolicy)
		return hobj, nil
	default:
		return nil, errors.New("incorrect object type")
	}
}

// List returns a list of all FwlogPolicy objects
func (api *fwlogpolicyAPI) List(ctx context.Context, opts *api.ListWatchOptions) ([]*FwlogPolicy, error) {
	var objlist []*FwlogPolicy
	objs, err := api.ct.List("FwlogPolicy", ctx, opts)

	if err != nil {
		return nil, err
	}

	for _, obj := range objs {
		switch tp := obj.(type) {
		case *FwlogPolicy:
			eobj := obj.(*FwlogPolicy)
			objlist = append(objlist, eobj)
		default:
			log.Fatalf("Got invalid object type %v while looking for FwlogPolicy", tp)
		}
	}

	return objlist, nil
}

// Watch sets up a event handlers for FwlogPolicy object
func (api *fwlogpolicyAPI) Watch(handler FwlogPolicyHandler) error {
	api.ct.startWorkerPool("FwlogPolicy")
	return api.ct.WatchFwlogPolicy(handler)
}

// StopWatch stop watch for Tenant FwlogPolicy object
func (api *fwlogpolicyAPI) StopWatch(handler FwlogPolicyHandler) error {
	api.ct.Lock()
	api.ct.workPools["FwlogPolicy"].Stop()
	api.ct.Unlock()
	return api.ct.StopWatchFwlogPolicy(handler)
}

// FwlogPolicy returns FwlogPolicyAPI
func (ct *ctrlerCtx) FwlogPolicy() FwlogPolicyAPI {
	return &fwlogpolicyAPI{ct: ct}
}

// FlowExportPolicy is a wrapper object that implements additional functionality
type FlowExportPolicy struct {
	sync.Mutex
	monitoring.FlowExportPolicy
	HandlerCtx interface{} // additional state handlers can store
	ctrler     *ctrlerCtx  // reference back to the controller instance
}

func (obj *FlowExportPolicy) Write() error {
	// if there is no API server to connect to, we are done
	if (obj.ctrler == nil) || (obj.ctrler.resolver == nil) || obj.ctrler.apisrvURL == "" {
		return nil
	}

	apicl, err := obj.ctrler.apiClient()
	if err != nil {
		obj.ctrler.logger.Errorf("Error creating API server clent. Err: %v", err)
		return err
	}

	obj.ctrler.stats.Counter("FlowExportPolicy_Writes").Inc()

	// write to api server
	if obj.ObjectMeta.ResourceVersion != "" {
		// update it
		for i := 0; i < maxApisrvWriteRetry; i++ {
			_, err = apicl.MonitoringV1().FlowExportPolicy().UpdateStatus(context.Background(), &obj.FlowExportPolicy)
			if err == nil {
				break
			}
			time.Sleep(time.Millisecond * 100)
		}
	} else {
		//  create
		_, err = apicl.MonitoringV1().FlowExportPolicy().Create(context.Background(), &obj.FlowExportPolicy)
	}

	return nil
}

// FlowExportPolicyHandler is the event handler for FlowExportPolicy object
type FlowExportPolicyHandler interface {
	OnFlowExportPolicyCreate(obj *FlowExportPolicy) error
	OnFlowExportPolicyUpdate(oldObj *FlowExportPolicy, newObj *monitoring.FlowExportPolicy) error
	OnFlowExportPolicyDelete(obj *FlowExportPolicy) error
	GetFlowExportPolicyWatchOptions() *api.ListWatchOptions
}

// OnFlowExportPolicyCreate is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnFlowExportPolicyCreate(obj *FlowExportPolicy) error {
	log.Info("OnFlowExportPolicyCreate is not implemented")
	return nil
}

// OnFlowExportPolicyUpdate is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnFlowExportPolicyUpdate(oldObj *FlowExportPolicy, newObj *monitoring.FlowExportPolicy) error {
	log.Info("OnFlowExportPolicyUpdate is not implemented")
	return nil
}

// OnFlowExportPolicyDelete is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnFlowExportPolicyDelete(obj *FlowExportPolicy) error {
	log.Info("OnFlowExportPolicyDelete is not implemented")
	return nil
}

// GetFlowExportPolicyWatchOptions is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) GetFlowExportPolicyWatchOptions() *api.ListWatchOptions {
	log.Info("GetFlowExportPolicyWatchOptions is not implemented")
	opts := &api.ListWatchOptions{}
	return opts
}

// handleFlowExportPolicyEvent handles FlowExportPolicy events from watcher
func (ct *ctrlerCtx) handleFlowExportPolicyEvent(evt *kvstore.WatchEvent) error {

	if ct.objResolver == nil {
		return ct.handleFlowExportPolicyEventNoResolver(evt)
	}

	switch tp := evt.Object.(type) {
	case *monitoring.FlowExportPolicy:
		eobj := evt.Object.(*monitoring.FlowExportPolicy)
		kind := "FlowExportPolicy"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ctx := &flowexportpolicyCtx{event: evt.Type,
			obj: &FlowExportPolicy{FlowExportPolicy: *eobj, ctrler: ct}}

		var err error
		switch evt.Type {
		case kvstore.Created:
			err = ct.processAdd(ctx)
		case kvstore.Updated:
			err = ct.processUpdate(ctx)
		case kvstore.Deleted:
			err = ct.processDelete(ctx)
		}
		return err
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on FlowExportPolicy watch channel", tp)
	}

	return nil
}

// handleFlowExportPolicyEventNoResolver handles FlowExportPolicy events from watcher
func (ct *ctrlerCtx) handleFlowExportPolicyEventNoResolver(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *monitoring.FlowExportPolicy:
		eobj := evt.Object.(*monitoring.FlowExportPolicy)
		kind := "FlowExportPolicy"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		flowexportpolicyHandler := handler.(FlowExportPolicyHandler)
		// handle based on event type
		ctrlCtx := &flowexportpolicyCtx{event: evt.Type, obj: &FlowExportPolicy{FlowExportPolicy: *eobj, ctrler: ct}}
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			fobj, err := ct.getObject(kind, ctrlCtx.GetKey())
			if err != nil {
				ct.addObject(ctrlCtx)
				ct.stats.Counter("FlowExportPolicy_Created_Events").Inc()

				// call the event handler
				ctrlCtx.Lock()
				err = flowexportpolicyHandler.OnFlowExportPolicyCreate(ctrlCtx.obj)
				ctrlCtx.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctrlCtx.obj, err)
					ct.delObject(kind, ctrlCtx.GetKey())
					return err
				}
			} else {
				if ct.resolver != nil && fobj.GetResourceVersion() >= eobj.GetResourceVersion() {
					// Event already processed.
					ct.logger.Infof("Skipping update due to old resource version")
					return nil
				}
				ctrlCtx := fobj.(*flowexportpolicyCtx)
				ct.stats.Counter("FlowExportPolicy_Updated_Events").Inc()
				ctrlCtx.Lock()
				p := monitoring.FlowExportPolicy{Spec: eobj.Spec,
					ObjectMeta: eobj.ObjectMeta,
					TypeMeta:   eobj.TypeMeta,
					Status:     eobj.Status}

				err = flowexportpolicyHandler.OnFlowExportPolicyUpdate(ctrlCtx.obj, &p)
				ctrlCtx.obj.FlowExportPolicy = *eobj
				ctrlCtx.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctrlCtx.obj, err)
					return err
				}

			}
		case kvstore.Deleted:
			ctrlCtx := &flowexportpolicyCtx{event: evt.Type, obj: &FlowExportPolicy{FlowExportPolicy: *eobj, ctrler: ct}}
			fobj, err := ct.findObject(kind, ctrlCtx.GetKey())
			if err != nil {
				ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
				return err
			}

			obj := fobj.(*FlowExportPolicy)
			ct.stats.Counter("FlowExportPolicy_Deleted_Events").Inc()
			obj.Lock()
			err = flowexportpolicyHandler.OnFlowExportPolicyDelete(obj)
			obj.Unlock()
			if err != nil {
				ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
			}
			ct.delObject(kind, ctrlCtx.GetKey())
			return nil

		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on FlowExportPolicy watch channel", tp)
	}

	return nil
}

type flowexportpolicyCtx struct {
	ctkitBaseCtx
	event kvstore.WatchEventType
	obj   *FlowExportPolicy //
	//   newObj     *monitoring.FlowExportPolicy //update
	newObj *flowexportpolicyCtx //update
}

func (ctx *flowexportpolicyCtx) References() map[string]apiintf.ReferenceObj {
	resp := make(map[string]apiintf.ReferenceObj)
	ctx.obj.References(ctx.obj.GetObjectMeta().Name, ctx.obj.GetObjectMeta().Namespace, resp)
	return resp
}

func (ctx *flowexportpolicyCtx) GetKey() string {
	return ctx.obj.MakeKey("monitoring")
}

func (ctx *flowexportpolicyCtx) GetKind() string {
	return ctx.obj.GetKind()
}

func (ctx *flowexportpolicyCtx) GetResourceVersion() string {
	return ctx.obj.GetResourceVersion()
}

func (ctx *flowexportpolicyCtx) SetEvent(event kvstore.WatchEventType) {
	ctx.event = event
}

func (ctx *flowexportpolicyCtx) SetNewObj(newObj apiintf.CtkitObject) {
	if newObj == nil {
		ctx.newObj = nil
	} else {
		ctx.newObj = newObj.(*flowexportpolicyCtx)
		ctx.newObj.obj.HandlerCtx = ctx.obj.HandlerCtx
	}
}

func (ctx *flowexportpolicyCtx) GetNewObj() apiintf.CtkitObject {
	return ctx.newObj
}

func (ctx *flowexportpolicyCtx) Copy(obj apiintf.CtkitObject) {
	ctx.obj.FlowExportPolicy = obj.(*flowexportpolicyCtx).obj.FlowExportPolicy
}

func (ctx *flowexportpolicyCtx) Lock() {
	ctx.obj.Lock()
}

func (ctx *flowexportpolicyCtx) Unlock() {
	ctx.obj.Unlock()
}

func (ctx *flowexportpolicyCtx) GetObjectMeta() *api.ObjectMeta {
	return ctx.obj.GetObjectMeta()
}

func (ctx *flowexportpolicyCtx) RuntimeObject() runtime.Object {
	var v interface{}
	v = ctx.obj
	return v.(runtime.Object)
}

func (ctx *flowexportpolicyCtx) WorkFunc(context context.Context) error {
	var err error
	evt := ctx.event
	ct := ctx.obj.ctrler
	kind := "FlowExportPolicy"
	ct.Lock()
	handler, ok := ct.handlers[kind]
	ct.Unlock()
	if !ok {
		ct.logger.Fatalf("Cant find the handler for %s", kind)
	}
	flowexportpolicyHandler := handler.(FlowExportPolicyHandler)
	switch evt {
	case kvstore.Created:
		ctx.obj.Lock()
		err = flowexportpolicyHandler.OnFlowExportPolicyCreate(ctx.obj)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctx.obj, err)
			ctx.SetEvent(kvstore.Deleted)
		}
	case kvstore.Updated:
		ct.stats.Counter("FlowExportPolicy_Updated_Events").Inc()
		ctx.obj.Lock()
		p := monitoring.FlowExportPolicy{Spec: ctx.newObj.obj.Spec,
			ObjectMeta: ctx.newObj.obj.ObjectMeta,
			TypeMeta:   ctx.newObj.obj.TypeMeta,
			Status:     ctx.newObj.obj.Status}
		err = flowexportpolicyHandler.OnFlowExportPolicyUpdate(ctx.obj, &p)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctx.obj, err)
			ctx.SetEvent(kvstore.Deleted)
		}
	case kvstore.Deleted:
		ctx.obj.Lock()
		err = flowexportpolicyHandler.OnFlowExportPolicyDelete(ctx.obj)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error deleting %s %+v. Err: %v", kind, ctx.obj, err)
		}
	}
	ct.resolveObject(ctx.event, ctx)
	return nil
}

// handleFlowExportPolicyEventParallel handles FlowExportPolicy events from watcher
func (ct *ctrlerCtx) handleFlowExportPolicyEventParallel(evt *kvstore.WatchEvent) error {

	if ct.objResolver == nil {
		return ct.handleFlowExportPolicyEventParallelWithNoResolver(evt)
	}

	switch tp := evt.Object.(type) {
	case *monitoring.FlowExportPolicy:
		eobj := evt.Object.(*monitoring.FlowExportPolicy)
		kind := "FlowExportPolicy"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ctx := &flowexportpolicyCtx{event: evt.Type, obj: &FlowExportPolicy{FlowExportPolicy: *eobj, ctrler: ct}}

		var err error
		switch evt.Type {
		case kvstore.Created:
			err = ct.processAdd(ctx)
		case kvstore.Updated:
			err = ct.processUpdate(ctx)
		case kvstore.Deleted:
			err = ct.processDelete(ctx)
		}
		return err
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on FlowExportPolicy watch channel", tp)
	}

	return nil
}

// handleFlowExportPolicyEventParallel handles FlowExportPolicy events from watcher
func (ct *ctrlerCtx) handleFlowExportPolicyEventParallelWithNoResolver(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *monitoring.FlowExportPolicy:
		eobj := evt.Object.(*monitoring.FlowExportPolicy)
		kind := "FlowExportPolicy"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		flowexportpolicyHandler := handler.(FlowExportPolicyHandler)
		// handle based on event type
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			workFunc := func(ctx context.Context, ctrlCtx shardworkers.WorkObj) error {
				var err error
				workCtx := ctrlCtx.(*flowexportpolicyCtx)
				eobj := workCtx.obj
				fobj, err := ct.getObject(kind, workCtx.GetKey())
				if err != nil {
					ct.addObject(workCtx)
					ct.stats.Counter("FlowExportPolicy_Created_Events").Inc()
					eobj.Lock()
					err = flowexportpolicyHandler.OnFlowExportPolicyCreate(eobj)
					eobj.Unlock()
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, eobj, err)
						ct.delObject(kind, workCtx.GetKey())
					}
				} else {
					workCtx := fobj.(*flowexportpolicyCtx)
					obj := workCtx.obj
					ct.stats.Counter("FlowExportPolicy_Updated_Events").Inc()
					obj.Lock()
					p := monitoring.FlowExportPolicy{Spec: eobj.Spec,
						ObjectMeta: eobj.ObjectMeta,
						TypeMeta:   eobj.TypeMeta,
						Status:     eobj.Status}

					err = flowexportpolicyHandler.OnFlowExportPolicyUpdate(obj, &p)
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					} else {
						workCtx.obj.FlowExportPolicy = p
					}
					obj.Unlock()
				}
				return err
			}
			ctrlCtx := &flowexportpolicyCtx{event: evt.Type, obj: &FlowExportPolicy{FlowExportPolicy: *eobj, ctrler: ct}}
			ct.runFunction("FlowExportPolicy", ctrlCtx, workFunc)
		case kvstore.Deleted:
			workFunc := func(ctx context.Context, ctrlCtx shardworkers.WorkObj) error {
				var err error
				workCtx := ctrlCtx.(*flowexportpolicyCtx)
				eobj := workCtx.obj
				fobj, err := ct.findObject(kind, workCtx.GetKey())
				if err != nil {
					ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
					return err
				}
				obj := fobj.(*FlowExportPolicy)
				ct.stats.Counter("FlowExportPolicy_Deleted_Events").Inc()
				obj.Lock()
				err = flowexportpolicyHandler.OnFlowExportPolicyDelete(obj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
				}
				ct.delObject(kind, workCtx.GetKey())
				return nil
			}
			ctrlCtx := &flowexportpolicyCtx{event: evt.Type, obj: &FlowExportPolicy{FlowExportPolicy: *eobj, ctrler: ct}}
			ct.runFunction("FlowExportPolicy", ctrlCtx, workFunc)
		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on FlowExportPolicy watch channel", tp)
	}

	return nil
}

// diffFlowExportPolicy does a diff of FlowExportPolicy objects between local cache and API server
func (ct *ctrlerCtx) diffFlowExportPolicy(apicl apiclient.Services) {
	opts := api.ListWatchOptions{}

	// get a list of all objects from API server
	objlist, err := apicl.MonitoringV1().FlowExportPolicy().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Errorf("Error getting a list of objects. Err: %v", err)
		return
	}

	ct.logger.Infof("diffFlowExportPolicy(): FlowExportPolicyList returned %d objects", len(objlist))

	// build an object map
	objmap := make(map[string]*monitoring.FlowExportPolicy)
	for _, obj := range objlist {
		objmap[obj.GetKey()] = obj
	}

	list, err := ct.FlowExportPolicy().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Infof("Failed to get a list of objects. Err: %s", err)
		return
	}

	// if an object is in our local cache and not in API server, trigger delete for it
	for _, obj := range list {
		_, ok := objmap[obj.GetKey()]
		if !ok {
			ct.logger.Infof("diffFlowExportPolicy(): Deleting existing object %#v since its not in apiserver", obj.GetKey())
			evt := kvstore.WatchEvent{
				Type:   kvstore.Deleted,
				Key:    obj.GetKey(),
				Object: &obj.FlowExportPolicy,
			}
			ct.handleFlowExportPolicyEvent(&evt)
		}
	}

	// trigger create event for all others
	for _, obj := range objlist {
		ct.logger.Infof("diffFlowExportPolicy(): Adding object %#v", obj.GetKey())
		evt := kvstore.WatchEvent{
			Type:   kvstore.Created,
			Key:    obj.GetKey(),
			Object: obj,
		}
		ct.handleFlowExportPolicyEvent(&evt)
	}
}

func (ct *ctrlerCtx) runFlowExportPolicyWatcher() {
	kind := "FlowExportPolicy"

	ct.Lock()
	handler, ok := ct.handlers[kind]
	ct.Unlock()
	if !ok {
		ct.logger.Fatalf("Cant find the handler for %s", kind)
	}
	flowexportpolicyHandler := handler.(FlowExportPolicyHandler)

	opts := flowexportpolicyHandler.GetFlowExportPolicyWatchOptions()

	// if there is no API server to connect to, we are done
	if (ct.resolver == nil) || ct.apisrvURL == "" {
		return
	}

	// create context
	ctx, cancel := context.WithCancel(context.Background())
	ct.Lock()
	ct.watchCancel[kind] = cancel
	ct.Unlock()
	logger := ct.logger.WithContext("submodule", "FlowExportPolicyWatcher")

	// create a grpc client
	apiclt, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
	if err == nil {
		ct.diffFlowExportPolicy(apiclt)
	}

	// setup wait group
	ct.waitGrp.Add(1)

	// start a goroutine
	go func() {
		defer ct.waitGrp.Done()
		ct.stats.Counter("FlowExportPolicy_Watch").Inc()
		defer ct.stats.Counter("FlowExportPolicy_Watch").Dec()

		// loop forever
		for {
			// create a grpc client
			apicl, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
			if err != nil {
				logger.Warnf("Failed to connect to gRPC server [%s]\n", ct.apisrvURL)
				ct.stats.Counter("FlowExportPolicy_ApiClientErr").Inc()
			} else {
				logger.Infof("API client connected {%+v}", apicl)

				// FlowExportPolicy object watcher
				wt, werr := apicl.MonitoringV1().FlowExportPolicy().Watch(ctx, opts)
				if werr != nil {
					select {
					case <-ctx.Done():
						logger.Infof("watch %s cancelled", kind)
						return
					default:
					}
					logger.Errorf("Failed to start %s watch (%s)\n", kind, werr)
					// wait for a second and retry connecting to api server
					apicl.Close()
					time.Sleep(time.Second)
					continue
				}
				ct.Lock()
				ct.watchers[kind] = wt
				ct.Unlock()

				// perform a diff with API server and local cache
				time.Sleep(time.Millisecond * 100)
				ct.diffFlowExportPolicy(apicl)

				// handle api server watch events
			innerLoop:
				for {
					// wait for events
					select {
					case evt, ok := <-wt.EventChan():
						if !ok {
							logger.Error("Error receiving from apisrv watcher")
							ct.stats.Counter("FlowExportPolicy_WatchErrors").Inc()
							break innerLoop
						}

						// handle event in parallel
						ct.handleFlowExportPolicyEventParallel(evt)
					}
				}
				apicl.Close()
			}

			// if stop flag is set, we are done
			if ct.stoped {
				logger.Infof("Exiting API server watcher")
				return
			}

			// wait for a second and retry connecting to api server
			time.Sleep(time.Second)
		}
	}()
}

// WatchFlowExportPolicy starts watch on FlowExportPolicy object
func (ct *ctrlerCtx) WatchFlowExportPolicy(handler FlowExportPolicyHandler) error {
	kind := "FlowExportPolicy"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchers[kind]
	ct.Unlock()
	if ok {
		return fmt.Errorf("FlowExportPolicy watcher already exists")
	}

	// save handler
	ct.Lock()
	ct.handlers[kind] = handler
	ct.Unlock()

	// run FlowExportPolicy watcher in a go routine
	ct.runFlowExportPolicyWatcher()

	return nil
}

// StopWatchFlowExportPolicy stops watch on FlowExportPolicy object
func (ct *ctrlerCtx) StopWatchFlowExportPolicy(handler FlowExportPolicyHandler) error {
	kind := "FlowExportPolicy"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchers[kind]
	ct.Unlock()
	if !ok {
		return fmt.Errorf("FlowExportPolicy watcher does not exist")
	}

	ct.Lock()
	cancel, _ := ct.watchCancel[kind]
	cancel()
	delete(ct.watchers, kind)
	delete(ct.watchCancel, kind)
	ct.Unlock()

	time.Sleep(100 * time.Millisecond)

	return nil
}

// FlowExportPolicyAPI returns
type FlowExportPolicyAPI interface {
	Create(obj *monitoring.FlowExportPolicy) error
	SyncCreate(obj *monitoring.FlowExportPolicy) error
	Update(obj *monitoring.FlowExportPolicy) error
	SyncUpdate(obj *monitoring.FlowExportPolicy) error
	Delete(obj *monitoring.FlowExportPolicy) error
	Find(meta *api.ObjectMeta) (*FlowExportPolicy, error)
	List(ctx context.Context, opts *api.ListWatchOptions) ([]*FlowExportPolicy, error)
	Watch(handler FlowExportPolicyHandler) error
	StopWatch(handler FlowExportPolicyHandler) error
}

// dummy struct that implements FlowExportPolicyAPI
type flowexportpolicyAPI struct {
	ct *ctrlerCtx
}

// Create creates FlowExportPolicy object
func (api *flowexportpolicyAPI) Create(obj *monitoring.FlowExportPolicy) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.MonitoringV1().FlowExportPolicy().Create(context.Background(), obj)
		if err != nil && strings.Contains(err.Error(), "AlreadyExists") {
			_, err = apicl.MonitoringV1().FlowExportPolicy().Update(context.Background(), obj)
		}
		return err
	}

	api.ct.handleFlowExportPolicyEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Created})
	return nil
}

// SyncCreate creates FlowExportPolicy object and updates the cache
func (api *flowexportpolicyAPI) SyncCreate(obj *monitoring.FlowExportPolicy) error {
	newObj := obj
	evtType := kvstore.Created
	var writeErr error
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		newObj, writeErr = apicl.MonitoringV1().FlowExportPolicy().Create(context.Background(), obj)
		if writeErr != nil && strings.Contains(err.Error(), "AlreadyExists") {
			newObj, writeErr = apicl.MonitoringV1().FlowExportPolicy().Update(context.Background(), obj)
			evtType = kvstore.Updated
		}
	}

	if writeErr == nil {
		api.ct.handleFlowExportPolicyEvent(&kvstore.WatchEvent{Object: newObj, Type: evtType})
	}

	if writeErr == nil {
		api.ct.handleFlowExportPolicyEvent(&kvstore.WatchEvent{Object: newObj, Type: evtType})
	}

	return writeErr
}

// Update triggers update on FlowExportPolicy object
func (api *flowexportpolicyAPI) Update(obj *monitoring.FlowExportPolicy) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.MonitoringV1().FlowExportPolicy().Update(context.Background(), obj)
		return err
	}

	api.ct.handleFlowExportPolicyEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Updated})
	return nil
}

// SyncUpdate triggers update on FlowExportPolicy object and updates the cache
func (api *flowexportpolicyAPI) SyncUpdate(obj *monitoring.FlowExportPolicy) error {
	newObj := obj
	var writeErr error
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		newObj, writeErr = apicl.MonitoringV1().FlowExportPolicy().Update(context.Background(), obj)
	}

	if writeErr == nil {
		api.ct.handleFlowExportPolicyEvent(&kvstore.WatchEvent{Object: newObj, Type: kvstore.Updated})
	}

	return writeErr
}

// Delete deletes FlowExportPolicy object
func (api *flowexportpolicyAPI) Delete(obj *monitoring.FlowExportPolicy) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.MonitoringV1().FlowExportPolicy().Delete(context.Background(), &obj.ObjectMeta)
		return err
	}

	api.ct.handleFlowExportPolicyEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Deleted})
	return nil
}

// MakeKey generates a KV store key for the object
func (api *flowexportpolicyAPI) getFullKey(tenant, name string) string {
	if tenant != "" {
		return fmt.Sprint(globals.ConfigRootPrefix, "/", "monitoring", "/", "flowExportPolicy", "/", tenant, "/", name)
	}
	return fmt.Sprint(globals.ConfigRootPrefix, "/", "monitoring", "/", "flowExportPolicy", "/", name)
}

// Find returns an object by meta
func (api *flowexportpolicyAPI) Find(meta *api.ObjectMeta) (*FlowExportPolicy, error) {
	// find the object
	obj, err := api.ct.FindObject("FlowExportPolicy", meta)
	if err != nil {
		return nil, err
	}

	// asset type
	switch obj.(type) {
	case *FlowExportPolicy:
		hobj := obj.(*FlowExportPolicy)
		return hobj, nil
	default:
		return nil, errors.New("incorrect object type")
	}
}

// List returns a list of all FlowExportPolicy objects
func (api *flowexportpolicyAPI) List(ctx context.Context, opts *api.ListWatchOptions) ([]*FlowExportPolicy, error) {
	var objlist []*FlowExportPolicy
	objs, err := api.ct.List("FlowExportPolicy", ctx, opts)

	if err != nil {
		return nil, err
	}

	for _, obj := range objs {
		switch tp := obj.(type) {
		case *FlowExportPolicy:
			eobj := obj.(*FlowExportPolicy)
			objlist = append(objlist, eobj)
		default:
			log.Fatalf("Got invalid object type %v while looking for FlowExportPolicy", tp)
		}
	}

	return objlist, nil
}

// Watch sets up a event handlers for FlowExportPolicy object
func (api *flowexportpolicyAPI) Watch(handler FlowExportPolicyHandler) error {
	api.ct.startWorkerPool("FlowExportPolicy")
	return api.ct.WatchFlowExportPolicy(handler)
}

// StopWatch stop watch for Tenant FlowExportPolicy object
func (api *flowexportpolicyAPI) StopWatch(handler FlowExportPolicyHandler) error {
	api.ct.Lock()
	api.ct.workPools["FlowExportPolicy"].Stop()
	api.ct.Unlock()
	return api.ct.StopWatchFlowExportPolicy(handler)
}

// FlowExportPolicy returns FlowExportPolicyAPI
func (ct *ctrlerCtx) FlowExportPolicy() FlowExportPolicyAPI {
	return &flowexportpolicyAPI{ct: ct}
}

// Alert is a wrapper object that implements additional functionality
type Alert struct {
	sync.Mutex
	monitoring.Alert
	HandlerCtx interface{} // additional state handlers can store
	ctrler     *ctrlerCtx  // reference back to the controller instance
}

func (obj *Alert) Write() error {
	// if there is no API server to connect to, we are done
	if (obj.ctrler == nil) || (obj.ctrler.resolver == nil) || obj.ctrler.apisrvURL == "" {
		return nil
	}

	apicl, err := obj.ctrler.apiClient()
	if err != nil {
		obj.ctrler.logger.Errorf("Error creating API server clent. Err: %v", err)
		return err
	}

	obj.ctrler.stats.Counter("Alert_Writes").Inc()

	// write to api server
	if obj.ObjectMeta.ResourceVersion != "" {
		// update it
		for i := 0; i < maxApisrvWriteRetry; i++ {
			_, err = apicl.MonitoringV1().Alert().UpdateStatus(context.Background(), &obj.Alert)
			if err == nil {
				break
			}
			time.Sleep(time.Millisecond * 100)
		}
	} else {
		//  create
		_, err = apicl.MonitoringV1().Alert().Create(context.Background(), &obj.Alert)
	}

	return nil
}

// AlertHandler is the event handler for Alert object
type AlertHandler interface {
	OnAlertCreate(obj *Alert) error
	OnAlertUpdate(oldObj *Alert, newObj *monitoring.Alert) error
	OnAlertDelete(obj *Alert) error
	GetAlertWatchOptions() *api.ListWatchOptions
}

// OnAlertCreate is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnAlertCreate(obj *Alert) error {
	log.Info("OnAlertCreate is not implemented")
	return nil
}

// OnAlertUpdate is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnAlertUpdate(oldObj *Alert, newObj *monitoring.Alert) error {
	log.Info("OnAlertUpdate is not implemented")
	return nil
}

// OnAlertDelete is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnAlertDelete(obj *Alert) error {
	log.Info("OnAlertDelete is not implemented")
	return nil
}

// GetAlertWatchOptions is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) GetAlertWatchOptions() *api.ListWatchOptions {
	log.Info("GetAlertWatchOptions is not implemented")
	opts := &api.ListWatchOptions{}
	return opts
}

// handleAlertEvent handles Alert events from watcher
func (ct *ctrlerCtx) handleAlertEvent(evt *kvstore.WatchEvent) error {

	if ct.objResolver == nil {
		return ct.handleAlertEventNoResolver(evt)
	}

	switch tp := evt.Object.(type) {
	case *monitoring.Alert:
		eobj := evt.Object.(*monitoring.Alert)
		kind := "Alert"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ctx := &alertCtx{event: evt.Type,
			obj: &Alert{Alert: *eobj, ctrler: ct}}

		var err error
		switch evt.Type {
		case kvstore.Created:
			err = ct.processAdd(ctx)
		case kvstore.Updated:
			err = ct.processUpdate(ctx)
		case kvstore.Deleted:
			err = ct.processDelete(ctx)
		}
		return err
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on Alert watch channel", tp)
	}

	return nil
}

// handleAlertEventNoResolver handles Alert events from watcher
func (ct *ctrlerCtx) handleAlertEventNoResolver(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *monitoring.Alert:
		eobj := evt.Object.(*monitoring.Alert)
		kind := "Alert"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		alertHandler := handler.(AlertHandler)
		// handle based on event type
		ctrlCtx := &alertCtx{event: evt.Type, obj: &Alert{Alert: *eobj, ctrler: ct}}
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			fobj, err := ct.getObject(kind, ctrlCtx.GetKey())
			if err != nil {
				ct.addObject(ctrlCtx)
				ct.stats.Counter("Alert_Created_Events").Inc()

				// call the event handler
				ctrlCtx.Lock()
				err = alertHandler.OnAlertCreate(ctrlCtx.obj)
				ctrlCtx.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctrlCtx.obj, err)
					ct.delObject(kind, ctrlCtx.GetKey())
					return err
				}
			} else {
				if ct.resolver != nil && fobj.GetResourceVersion() >= eobj.GetResourceVersion() {
					// Event already processed.
					ct.logger.Infof("Skipping update due to old resource version")
					return nil
				}
				ctrlCtx := fobj.(*alertCtx)
				ct.stats.Counter("Alert_Updated_Events").Inc()
				ctrlCtx.Lock()
				p := monitoring.Alert{Spec: eobj.Spec,
					ObjectMeta: eobj.ObjectMeta,
					TypeMeta:   eobj.TypeMeta,
					Status:     eobj.Status}

				err = alertHandler.OnAlertUpdate(ctrlCtx.obj, &p)
				ctrlCtx.obj.Alert = *eobj
				ctrlCtx.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctrlCtx.obj, err)
					return err
				}

			}
		case kvstore.Deleted:
			ctrlCtx := &alertCtx{event: evt.Type, obj: &Alert{Alert: *eobj, ctrler: ct}}
			fobj, err := ct.findObject(kind, ctrlCtx.GetKey())
			if err != nil {
				ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
				return err
			}

			obj := fobj.(*Alert)
			ct.stats.Counter("Alert_Deleted_Events").Inc()
			obj.Lock()
			err = alertHandler.OnAlertDelete(obj)
			obj.Unlock()
			if err != nil {
				ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
			}
			ct.delObject(kind, ctrlCtx.GetKey())
			return nil

		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on Alert watch channel", tp)
	}

	return nil
}

type alertCtx struct {
	ctkitBaseCtx
	event kvstore.WatchEventType
	obj   *Alert //
	//   newObj     *monitoring.Alert //update
	newObj *alertCtx //update
}

func (ctx *alertCtx) References() map[string]apiintf.ReferenceObj {
	resp := make(map[string]apiintf.ReferenceObj)
	ctx.obj.References(ctx.obj.GetObjectMeta().Name, ctx.obj.GetObjectMeta().Namespace, resp)
	return resp
}

func (ctx *alertCtx) GetKey() string {
	return ctx.obj.MakeKey("monitoring")
}

func (ctx *alertCtx) GetKind() string {
	return ctx.obj.GetKind()
}

func (ctx *alertCtx) GetResourceVersion() string {
	return ctx.obj.GetResourceVersion()
}

func (ctx *alertCtx) SetEvent(event kvstore.WatchEventType) {
	ctx.event = event
}

func (ctx *alertCtx) SetNewObj(newObj apiintf.CtkitObject) {
	if newObj == nil {
		ctx.newObj = nil
	} else {
		ctx.newObj = newObj.(*alertCtx)
		ctx.newObj.obj.HandlerCtx = ctx.obj.HandlerCtx
	}
}

func (ctx *alertCtx) GetNewObj() apiintf.CtkitObject {
	return ctx.newObj
}

func (ctx *alertCtx) Copy(obj apiintf.CtkitObject) {
	ctx.obj.Alert = obj.(*alertCtx).obj.Alert
}

func (ctx *alertCtx) Lock() {
	ctx.obj.Lock()
}

func (ctx *alertCtx) Unlock() {
	ctx.obj.Unlock()
}

func (ctx *alertCtx) GetObjectMeta() *api.ObjectMeta {
	return ctx.obj.GetObjectMeta()
}

func (ctx *alertCtx) RuntimeObject() runtime.Object {
	var v interface{}
	v = ctx.obj
	return v.(runtime.Object)
}

func (ctx *alertCtx) WorkFunc(context context.Context) error {
	var err error
	evt := ctx.event
	ct := ctx.obj.ctrler
	kind := "Alert"
	ct.Lock()
	handler, ok := ct.handlers[kind]
	ct.Unlock()
	if !ok {
		ct.logger.Fatalf("Cant find the handler for %s", kind)
	}
	alertHandler := handler.(AlertHandler)
	switch evt {
	case kvstore.Created:
		ctx.obj.Lock()
		err = alertHandler.OnAlertCreate(ctx.obj)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctx.obj, err)
			ctx.SetEvent(kvstore.Deleted)
		}
	case kvstore.Updated:
		ct.stats.Counter("Alert_Updated_Events").Inc()
		ctx.obj.Lock()
		p := monitoring.Alert{Spec: ctx.newObj.obj.Spec,
			ObjectMeta: ctx.newObj.obj.ObjectMeta,
			TypeMeta:   ctx.newObj.obj.TypeMeta,
			Status:     ctx.newObj.obj.Status}
		err = alertHandler.OnAlertUpdate(ctx.obj, &p)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctx.obj, err)
			ctx.SetEvent(kvstore.Deleted)
		}
	case kvstore.Deleted:
		ctx.obj.Lock()
		err = alertHandler.OnAlertDelete(ctx.obj)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error deleting %s %+v. Err: %v", kind, ctx.obj, err)
		}
	}
	ct.resolveObject(ctx.event, ctx)
	return nil
}

// handleAlertEventParallel handles Alert events from watcher
func (ct *ctrlerCtx) handleAlertEventParallel(evt *kvstore.WatchEvent) error {

	if ct.objResolver == nil {
		return ct.handleAlertEventParallelWithNoResolver(evt)
	}

	switch tp := evt.Object.(type) {
	case *monitoring.Alert:
		eobj := evt.Object.(*monitoring.Alert)
		kind := "Alert"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ctx := &alertCtx{event: evt.Type, obj: &Alert{Alert: *eobj, ctrler: ct}}

		var err error
		switch evt.Type {
		case kvstore.Created:
			err = ct.processAdd(ctx)
		case kvstore.Updated:
			err = ct.processUpdate(ctx)
		case kvstore.Deleted:
			err = ct.processDelete(ctx)
		}
		return err
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on Alert watch channel", tp)
	}

	return nil
}

// handleAlertEventParallel handles Alert events from watcher
func (ct *ctrlerCtx) handleAlertEventParallelWithNoResolver(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *monitoring.Alert:
		eobj := evt.Object.(*monitoring.Alert)
		kind := "Alert"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		alertHandler := handler.(AlertHandler)
		// handle based on event type
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			workFunc := func(ctx context.Context, ctrlCtx shardworkers.WorkObj) error {
				var err error
				workCtx := ctrlCtx.(*alertCtx)
				eobj := workCtx.obj
				fobj, err := ct.getObject(kind, workCtx.GetKey())
				if err != nil {
					ct.addObject(workCtx)
					ct.stats.Counter("Alert_Created_Events").Inc()
					eobj.Lock()
					err = alertHandler.OnAlertCreate(eobj)
					eobj.Unlock()
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, eobj, err)
						ct.delObject(kind, workCtx.GetKey())
					}
				} else {
					workCtx := fobj.(*alertCtx)
					obj := workCtx.obj
					ct.stats.Counter("Alert_Updated_Events").Inc()
					obj.Lock()
					p := monitoring.Alert{Spec: eobj.Spec,
						ObjectMeta: eobj.ObjectMeta,
						TypeMeta:   eobj.TypeMeta,
						Status:     eobj.Status}

					err = alertHandler.OnAlertUpdate(obj, &p)
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					} else {
						workCtx.obj.Alert = p
					}
					obj.Unlock()
				}
				return err
			}
			ctrlCtx := &alertCtx{event: evt.Type, obj: &Alert{Alert: *eobj, ctrler: ct}}
			ct.runFunction("Alert", ctrlCtx, workFunc)
		case kvstore.Deleted:
			workFunc := func(ctx context.Context, ctrlCtx shardworkers.WorkObj) error {
				var err error
				workCtx := ctrlCtx.(*alertCtx)
				eobj := workCtx.obj
				fobj, err := ct.findObject(kind, workCtx.GetKey())
				if err != nil {
					ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
					return err
				}
				obj := fobj.(*Alert)
				ct.stats.Counter("Alert_Deleted_Events").Inc()
				obj.Lock()
				err = alertHandler.OnAlertDelete(obj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
				}
				ct.delObject(kind, workCtx.GetKey())
				return nil
			}
			ctrlCtx := &alertCtx{event: evt.Type, obj: &Alert{Alert: *eobj, ctrler: ct}}
			ct.runFunction("Alert", ctrlCtx, workFunc)
		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on Alert watch channel", tp)
	}

	return nil
}

// diffAlert does a diff of Alert objects between local cache and API server
func (ct *ctrlerCtx) diffAlert(apicl apiclient.Services) {
	opts := api.ListWatchOptions{}

	// get a list of all objects from API server
	objlist, err := apicl.MonitoringV1().Alert().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Errorf("Error getting a list of objects. Err: %v", err)
		return
	}

	ct.logger.Infof("diffAlert(): AlertList returned %d objects", len(objlist))

	// build an object map
	objmap := make(map[string]*monitoring.Alert)
	for _, obj := range objlist {
		objmap[obj.GetKey()] = obj
	}

	list, err := ct.Alert().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Infof("Failed to get a list of objects. Err: %s", err)
		return
	}

	// if an object is in our local cache and not in API server, trigger delete for it
	for _, obj := range list {
		_, ok := objmap[obj.GetKey()]
		if !ok {
			ct.logger.Infof("diffAlert(): Deleting existing object %#v since its not in apiserver", obj.GetKey())
			evt := kvstore.WatchEvent{
				Type:   kvstore.Deleted,
				Key:    obj.GetKey(),
				Object: &obj.Alert,
			}
			ct.handleAlertEvent(&evt)
		}
	}

	// trigger create event for all others
	for _, obj := range objlist {
		ct.logger.Infof("diffAlert(): Adding object %#v", obj.GetKey())
		evt := kvstore.WatchEvent{
			Type:   kvstore.Created,
			Key:    obj.GetKey(),
			Object: obj,
		}
		ct.handleAlertEvent(&evt)
	}
}

func (ct *ctrlerCtx) runAlertWatcher() {
	kind := "Alert"

	ct.Lock()
	handler, ok := ct.handlers[kind]
	ct.Unlock()
	if !ok {
		ct.logger.Fatalf("Cant find the handler for %s", kind)
	}
	alertHandler := handler.(AlertHandler)

	opts := alertHandler.GetAlertWatchOptions()

	// if there is no API server to connect to, we are done
	if (ct.resolver == nil) || ct.apisrvURL == "" {
		return
	}

	// create context
	ctx, cancel := context.WithCancel(context.Background())
	ct.Lock()
	ct.watchCancel[kind] = cancel
	ct.Unlock()
	logger := ct.logger.WithContext("submodule", "AlertWatcher")

	// create a grpc client
	apiclt, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
	if err == nil {
		ct.diffAlert(apiclt)
	}

	// setup wait group
	ct.waitGrp.Add(1)

	// start a goroutine
	go func() {
		defer ct.waitGrp.Done()
		ct.stats.Counter("Alert_Watch").Inc()
		defer ct.stats.Counter("Alert_Watch").Dec()

		// loop forever
		for {
			// create a grpc client
			apicl, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
			if err != nil {
				logger.Warnf("Failed to connect to gRPC server [%s]\n", ct.apisrvURL)
				ct.stats.Counter("Alert_ApiClientErr").Inc()
			} else {
				logger.Infof("API client connected {%+v}", apicl)

				// Alert object watcher
				wt, werr := apicl.MonitoringV1().Alert().Watch(ctx, opts)
				if werr != nil {
					select {
					case <-ctx.Done():
						logger.Infof("watch %s cancelled", kind)
						return
					default:
					}
					logger.Errorf("Failed to start %s watch (%s)\n", kind, werr)
					// wait for a second and retry connecting to api server
					apicl.Close()
					time.Sleep(time.Second)
					continue
				}
				ct.Lock()
				ct.watchers[kind] = wt
				ct.Unlock()

				// perform a diff with API server and local cache
				time.Sleep(time.Millisecond * 100)
				ct.diffAlert(apicl)

				// handle api server watch events
			innerLoop:
				for {
					// wait for events
					select {
					case evt, ok := <-wt.EventChan():
						if !ok {
							logger.Error("Error receiving from apisrv watcher")
							ct.stats.Counter("Alert_WatchErrors").Inc()
							break innerLoop
						}

						// handle event in parallel
						ct.handleAlertEventParallel(evt)
					}
				}
				apicl.Close()
			}

			// if stop flag is set, we are done
			if ct.stoped {
				logger.Infof("Exiting API server watcher")
				return
			}

			// wait for a second and retry connecting to api server
			time.Sleep(time.Second)
		}
	}()
}

// WatchAlert starts watch on Alert object
func (ct *ctrlerCtx) WatchAlert(handler AlertHandler) error {
	kind := "Alert"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchers[kind]
	ct.Unlock()
	if ok {
		return fmt.Errorf("Alert watcher already exists")
	}

	// save handler
	ct.Lock()
	ct.handlers[kind] = handler
	ct.Unlock()

	// run Alert watcher in a go routine
	ct.runAlertWatcher()

	return nil
}

// StopWatchAlert stops watch on Alert object
func (ct *ctrlerCtx) StopWatchAlert(handler AlertHandler) error {
	kind := "Alert"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchers[kind]
	ct.Unlock()
	if !ok {
		return fmt.Errorf("Alert watcher does not exist")
	}

	ct.Lock()
	cancel, _ := ct.watchCancel[kind]
	cancel()
	delete(ct.watchers, kind)
	delete(ct.watchCancel, kind)
	ct.Unlock()

	time.Sleep(100 * time.Millisecond)

	return nil
}

// AlertAPI returns
type AlertAPI interface {
	Create(obj *monitoring.Alert) error
	SyncCreate(obj *monitoring.Alert) error
	Update(obj *monitoring.Alert) error
	SyncUpdate(obj *monitoring.Alert) error
	Delete(obj *monitoring.Alert) error
	Find(meta *api.ObjectMeta) (*Alert, error)
	List(ctx context.Context, opts *api.ListWatchOptions) ([]*Alert, error)
	Watch(handler AlertHandler) error
	StopWatch(handler AlertHandler) error
}

// dummy struct that implements AlertAPI
type alertAPI struct {
	ct *ctrlerCtx
}

// Create creates Alert object
func (api *alertAPI) Create(obj *monitoring.Alert) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.MonitoringV1().Alert().Create(context.Background(), obj)
		if err != nil && strings.Contains(err.Error(), "AlreadyExists") {
			_, err = apicl.MonitoringV1().Alert().Update(context.Background(), obj)
		}
		return err
	}

	api.ct.handleAlertEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Created})
	return nil
}

// SyncCreate creates Alert object and updates the cache
func (api *alertAPI) SyncCreate(obj *monitoring.Alert) error {
	newObj := obj
	evtType := kvstore.Created
	var writeErr error
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		newObj, writeErr = apicl.MonitoringV1().Alert().Create(context.Background(), obj)
		if writeErr != nil && strings.Contains(err.Error(), "AlreadyExists") {
			newObj, writeErr = apicl.MonitoringV1().Alert().Update(context.Background(), obj)
			evtType = kvstore.Updated
		}
	}

	if writeErr == nil {
		api.ct.handleAlertEvent(&kvstore.WatchEvent{Object: newObj, Type: evtType})
	}

	if writeErr == nil {
		api.ct.handleAlertEvent(&kvstore.WatchEvent{Object: newObj, Type: evtType})
	}

	return writeErr
}

// Update triggers update on Alert object
func (api *alertAPI) Update(obj *monitoring.Alert) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.MonitoringV1().Alert().Update(context.Background(), obj)
		return err
	}

	api.ct.handleAlertEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Updated})
	return nil
}

// SyncUpdate triggers update on Alert object and updates the cache
func (api *alertAPI) SyncUpdate(obj *monitoring.Alert) error {
	newObj := obj
	var writeErr error
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		newObj, writeErr = apicl.MonitoringV1().Alert().Update(context.Background(), obj)
	}

	if writeErr == nil {
		api.ct.handleAlertEvent(&kvstore.WatchEvent{Object: newObj, Type: kvstore.Updated})
	}

	return writeErr
}

// Delete deletes Alert object
func (api *alertAPI) Delete(obj *monitoring.Alert) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.MonitoringV1().Alert().Delete(context.Background(), &obj.ObjectMeta)
		return err
	}

	api.ct.handleAlertEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Deleted})
	return nil
}

// MakeKey generates a KV store key for the object
func (api *alertAPI) getFullKey(tenant, name string) string {
	if tenant != "" {
		return fmt.Sprint(globals.ConfigRootPrefix, "/", "monitoring", "/", "alerts", "/", tenant, "/", name)
	}
	return fmt.Sprint(globals.ConfigRootPrefix, "/", "monitoring", "/", "alerts", "/", name)
}

// Find returns an object by meta
func (api *alertAPI) Find(meta *api.ObjectMeta) (*Alert, error) {
	// find the object
	obj, err := api.ct.FindObject("Alert", meta)
	if err != nil {
		return nil, err
	}

	// asset type
	switch obj.(type) {
	case *Alert:
		hobj := obj.(*Alert)
		return hobj, nil
	default:
		return nil, errors.New("incorrect object type")
	}
}

// List returns a list of all Alert objects
func (api *alertAPI) List(ctx context.Context, opts *api.ListWatchOptions) ([]*Alert, error) {
	var objlist []*Alert
	objs, err := api.ct.List("Alert", ctx, opts)

	if err != nil {
		return nil, err
	}

	for _, obj := range objs {
		switch tp := obj.(type) {
		case *Alert:
			eobj := obj.(*Alert)
			objlist = append(objlist, eobj)
		default:
			log.Fatalf("Got invalid object type %v while looking for Alert", tp)
		}
	}

	return objlist, nil
}

// Watch sets up a event handlers for Alert object
func (api *alertAPI) Watch(handler AlertHandler) error {
	api.ct.startWorkerPool("Alert")
	return api.ct.WatchAlert(handler)
}

// StopWatch stop watch for Tenant Alert object
func (api *alertAPI) StopWatch(handler AlertHandler) error {
	api.ct.Lock()
	api.ct.workPools["Alert"].Stop()
	api.ct.Unlock()
	return api.ct.StopWatchAlert(handler)
}

// Alert returns AlertAPI
func (ct *ctrlerCtx) Alert() AlertAPI {
	return &alertAPI{ct: ct}
}

// AlertPolicy is a wrapper object that implements additional functionality
type AlertPolicy struct {
	sync.Mutex
	monitoring.AlertPolicy
	HandlerCtx interface{} // additional state handlers can store
	ctrler     *ctrlerCtx  // reference back to the controller instance
}

func (obj *AlertPolicy) Write() error {
	// if there is no API server to connect to, we are done
	if (obj.ctrler == nil) || (obj.ctrler.resolver == nil) || obj.ctrler.apisrvURL == "" {
		return nil
	}

	apicl, err := obj.ctrler.apiClient()
	if err != nil {
		obj.ctrler.logger.Errorf("Error creating API server clent. Err: %v", err)
		return err
	}

	obj.ctrler.stats.Counter("AlertPolicy_Writes").Inc()

	// write to api server
	if obj.ObjectMeta.ResourceVersion != "" {
		// update it
		for i := 0; i < maxApisrvWriteRetry; i++ {
			_, err = apicl.MonitoringV1().AlertPolicy().UpdateStatus(context.Background(), &obj.AlertPolicy)
			if err == nil {
				break
			}
			time.Sleep(time.Millisecond * 100)
		}
	} else {
		//  create
		_, err = apicl.MonitoringV1().AlertPolicy().Create(context.Background(), &obj.AlertPolicy)
	}

	return nil
}

// AlertPolicyHandler is the event handler for AlertPolicy object
type AlertPolicyHandler interface {
	OnAlertPolicyCreate(obj *AlertPolicy) error
	OnAlertPolicyUpdate(oldObj *AlertPolicy, newObj *monitoring.AlertPolicy) error
	OnAlertPolicyDelete(obj *AlertPolicy) error
	GetAlertPolicyWatchOptions() *api.ListWatchOptions
}

// OnAlertPolicyCreate is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnAlertPolicyCreate(obj *AlertPolicy) error {
	log.Info("OnAlertPolicyCreate is not implemented")
	return nil
}

// OnAlertPolicyUpdate is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnAlertPolicyUpdate(oldObj *AlertPolicy, newObj *monitoring.AlertPolicy) error {
	log.Info("OnAlertPolicyUpdate is not implemented")
	return nil
}

// OnAlertPolicyDelete is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnAlertPolicyDelete(obj *AlertPolicy) error {
	log.Info("OnAlertPolicyDelete is not implemented")
	return nil
}

// GetAlertPolicyWatchOptions is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) GetAlertPolicyWatchOptions() *api.ListWatchOptions {
	log.Info("GetAlertPolicyWatchOptions is not implemented")
	opts := &api.ListWatchOptions{}
	return opts
}

// handleAlertPolicyEvent handles AlertPolicy events from watcher
func (ct *ctrlerCtx) handleAlertPolicyEvent(evt *kvstore.WatchEvent) error {

	if ct.objResolver == nil {
		return ct.handleAlertPolicyEventNoResolver(evt)
	}

	switch tp := evt.Object.(type) {
	case *monitoring.AlertPolicy:
		eobj := evt.Object.(*monitoring.AlertPolicy)
		kind := "AlertPolicy"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ctx := &alertpolicyCtx{event: evt.Type,
			obj: &AlertPolicy{AlertPolicy: *eobj, ctrler: ct}}

		var err error
		switch evt.Type {
		case kvstore.Created:
			err = ct.processAdd(ctx)
		case kvstore.Updated:
			err = ct.processUpdate(ctx)
		case kvstore.Deleted:
			err = ct.processDelete(ctx)
		}
		return err
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on AlertPolicy watch channel", tp)
	}

	return nil
}

// handleAlertPolicyEventNoResolver handles AlertPolicy events from watcher
func (ct *ctrlerCtx) handleAlertPolicyEventNoResolver(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *monitoring.AlertPolicy:
		eobj := evt.Object.(*monitoring.AlertPolicy)
		kind := "AlertPolicy"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		alertpolicyHandler := handler.(AlertPolicyHandler)
		// handle based on event type
		ctrlCtx := &alertpolicyCtx{event: evt.Type, obj: &AlertPolicy{AlertPolicy: *eobj, ctrler: ct}}
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			fobj, err := ct.getObject(kind, ctrlCtx.GetKey())
			if err != nil {
				ct.addObject(ctrlCtx)
				ct.stats.Counter("AlertPolicy_Created_Events").Inc()

				// call the event handler
				ctrlCtx.Lock()
				err = alertpolicyHandler.OnAlertPolicyCreate(ctrlCtx.obj)
				ctrlCtx.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctrlCtx.obj, err)
					ct.delObject(kind, ctrlCtx.GetKey())
					return err
				}
			} else {
				if ct.resolver != nil && fobj.GetResourceVersion() >= eobj.GetResourceVersion() {
					// Event already processed.
					ct.logger.Infof("Skipping update due to old resource version")
					return nil
				}
				ctrlCtx := fobj.(*alertpolicyCtx)
				ct.stats.Counter("AlertPolicy_Updated_Events").Inc()
				ctrlCtx.Lock()
				p := monitoring.AlertPolicy{Spec: eobj.Spec,
					ObjectMeta: eobj.ObjectMeta,
					TypeMeta:   eobj.TypeMeta,
					Status:     eobj.Status}

				err = alertpolicyHandler.OnAlertPolicyUpdate(ctrlCtx.obj, &p)
				ctrlCtx.obj.AlertPolicy = *eobj
				ctrlCtx.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctrlCtx.obj, err)
					return err
				}

			}
		case kvstore.Deleted:
			ctrlCtx := &alertpolicyCtx{event: evt.Type, obj: &AlertPolicy{AlertPolicy: *eobj, ctrler: ct}}
			fobj, err := ct.findObject(kind, ctrlCtx.GetKey())
			if err != nil {
				ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
				return err
			}

			obj := fobj.(*AlertPolicy)
			ct.stats.Counter("AlertPolicy_Deleted_Events").Inc()
			obj.Lock()
			err = alertpolicyHandler.OnAlertPolicyDelete(obj)
			obj.Unlock()
			if err != nil {
				ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
			}
			ct.delObject(kind, ctrlCtx.GetKey())
			return nil

		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on AlertPolicy watch channel", tp)
	}

	return nil
}

type alertpolicyCtx struct {
	ctkitBaseCtx
	event kvstore.WatchEventType
	obj   *AlertPolicy //
	//   newObj     *monitoring.AlertPolicy //update
	newObj *alertpolicyCtx //update
}

func (ctx *alertpolicyCtx) References() map[string]apiintf.ReferenceObj {
	resp := make(map[string]apiintf.ReferenceObj)
	ctx.obj.References(ctx.obj.GetObjectMeta().Name, ctx.obj.GetObjectMeta().Namespace, resp)
	return resp
}

func (ctx *alertpolicyCtx) GetKey() string {
	return ctx.obj.MakeKey("monitoring")
}

func (ctx *alertpolicyCtx) GetKind() string {
	return ctx.obj.GetKind()
}

func (ctx *alertpolicyCtx) GetResourceVersion() string {
	return ctx.obj.GetResourceVersion()
}

func (ctx *alertpolicyCtx) SetEvent(event kvstore.WatchEventType) {
	ctx.event = event
}

func (ctx *alertpolicyCtx) SetNewObj(newObj apiintf.CtkitObject) {
	if newObj == nil {
		ctx.newObj = nil
	} else {
		ctx.newObj = newObj.(*alertpolicyCtx)
		ctx.newObj.obj.HandlerCtx = ctx.obj.HandlerCtx
	}
}

func (ctx *alertpolicyCtx) GetNewObj() apiintf.CtkitObject {
	return ctx.newObj
}

func (ctx *alertpolicyCtx) Copy(obj apiintf.CtkitObject) {
	ctx.obj.AlertPolicy = obj.(*alertpolicyCtx).obj.AlertPolicy
}

func (ctx *alertpolicyCtx) Lock() {
	ctx.obj.Lock()
}

func (ctx *alertpolicyCtx) Unlock() {
	ctx.obj.Unlock()
}

func (ctx *alertpolicyCtx) GetObjectMeta() *api.ObjectMeta {
	return ctx.obj.GetObjectMeta()
}

func (ctx *alertpolicyCtx) RuntimeObject() runtime.Object {
	var v interface{}
	v = ctx.obj
	return v.(runtime.Object)
}

func (ctx *alertpolicyCtx) WorkFunc(context context.Context) error {
	var err error
	evt := ctx.event
	ct := ctx.obj.ctrler
	kind := "AlertPolicy"
	ct.Lock()
	handler, ok := ct.handlers[kind]
	ct.Unlock()
	if !ok {
		ct.logger.Fatalf("Cant find the handler for %s", kind)
	}
	alertpolicyHandler := handler.(AlertPolicyHandler)
	switch evt {
	case kvstore.Created:
		ctx.obj.Lock()
		err = alertpolicyHandler.OnAlertPolicyCreate(ctx.obj)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctx.obj, err)
			ctx.SetEvent(kvstore.Deleted)
		}
	case kvstore.Updated:
		ct.stats.Counter("AlertPolicy_Updated_Events").Inc()
		ctx.obj.Lock()
		p := monitoring.AlertPolicy{Spec: ctx.newObj.obj.Spec,
			ObjectMeta: ctx.newObj.obj.ObjectMeta,
			TypeMeta:   ctx.newObj.obj.TypeMeta,
			Status:     ctx.newObj.obj.Status}
		err = alertpolicyHandler.OnAlertPolicyUpdate(ctx.obj, &p)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctx.obj, err)
			ctx.SetEvent(kvstore.Deleted)
		}
	case kvstore.Deleted:
		ctx.obj.Lock()
		err = alertpolicyHandler.OnAlertPolicyDelete(ctx.obj)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error deleting %s %+v. Err: %v", kind, ctx.obj, err)
		}
	}
	ct.resolveObject(ctx.event, ctx)
	return nil
}

// handleAlertPolicyEventParallel handles AlertPolicy events from watcher
func (ct *ctrlerCtx) handleAlertPolicyEventParallel(evt *kvstore.WatchEvent) error {

	if ct.objResolver == nil {
		return ct.handleAlertPolicyEventParallelWithNoResolver(evt)
	}

	switch tp := evt.Object.(type) {
	case *monitoring.AlertPolicy:
		eobj := evt.Object.(*monitoring.AlertPolicy)
		kind := "AlertPolicy"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ctx := &alertpolicyCtx{event: evt.Type, obj: &AlertPolicy{AlertPolicy: *eobj, ctrler: ct}}

		var err error
		switch evt.Type {
		case kvstore.Created:
			err = ct.processAdd(ctx)
		case kvstore.Updated:
			err = ct.processUpdate(ctx)
		case kvstore.Deleted:
			err = ct.processDelete(ctx)
		}
		return err
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on AlertPolicy watch channel", tp)
	}

	return nil
}

// handleAlertPolicyEventParallel handles AlertPolicy events from watcher
func (ct *ctrlerCtx) handleAlertPolicyEventParallelWithNoResolver(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *monitoring.AlertPolicy:
		eobj := evt.Object.(*monitoring.AlertPolicy)
		kind := "AlertPolicy"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		alertpolicyHandler := handler.(AlertPolicyHandler)
		// handle based on event type
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			workFunc := func(ctx context.Context, ctrlCtx shardworkers.WorkObj) error {
				var err error
				workCtx := ctrlCtx.(*alertpolicyCtx)
				eobj := workCtx.obj
				fobj, err := ct.getObject(kind, workCtx.GetKey())
				if err != nil {
					ct.addObject(workCtx)
					ct.stats.Counter("AlertPolicy_Created_Events").Inc()
					eobj.Lock()
					err = alertpolicyHandler.OnAlertPolicyCreate(eobj)
					eobj.Unlock()
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, eobj, err)
						ct.delObject(kind, workCtx.GetKey())
					}
				} else {
					workCtx := fobj.(*alertpolicyCtx)
					obj := workCtx.obj
					ct.stats.Counter("AlertPolicy_Updated_Events").Inc()
					obj.Lock()
					p := monitoring.AlertPolicy{Spec: eobj.Spec,
						ObjectMeta: eobj.ObjectMeta,
						TypeMeta:   eobj.TypeMeta,
						Status:     eobj.Status}

					err = alertpolicyHandler.OnAlertPolicyUpdate(obj, &p)
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					} else {
						workCtx.obj.AlertPolicy = p
					}
					obj.Unlock()
				}
				return err
			}
			ctrlCtx := &alertpolicyCtx{event: evt.Type, obj: &AlertPolicy{AlertPolicy: *eobj, ctrler: ct}}
			ct.runFunction("AlertPolicy", ctrlCtx, workFunc)
		case kvstore.Deleted:
			workFunc := func(ctx context.Context, ctrlCtx shardworkers.WorkObj) error {
				var err error
				workCtx := ctrlCtx.(*alertpolicyCtx)
				eobj := workCtx.obj
				fobj, err := ct.findObject(kind, workCtx.GetKey())
				if err != nil {
					ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
					return err
				}
				obj := fobj.(*AlertPolicy)
				ct.stats.Counter("AlertPolicy_Deleted_Events").Inc()
				obj.Lock()
				err = alertpolicyHandler.OnAlertPolicyDelete(obj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
				}
				ct.delObject(kind, workCtx.GetKey())
				return nil
			}
			ctrlCtx := &alertpolicyCtx{event: evt.Type, obj: &AlertPolicy{AlertPolicy: *eobj, ctrler: ct}}
			ct.runFunction("AlertPolicy", ctrlCtx, workFunc)
		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on AlertPolicy watch channel", tp)
	}

	return nil
}

// diffAlertPolicy does a diff of AlertPolicy objects between local cache and API server
func (ct *ctrlerCtx) diffAlertPolicy(apicl apiclient.Services) {
	opts := api.ListWatchOptions{}

	// get a list of all objects from API server
	objlist, err := apicl.MonitoringV1().AlertPolicy().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Errorf("Error getting a list of objects. Err: %v", err)
		return
	}

	ct.logger.Infof("diffAlertPolicy(): AlertPolicyList returned %d objects", len(objlist))

	// build an object map
	objmap := make(map[string]*monitoring.AlertPolicy)
	for _, obj := range objlist {
		objmap[obj.GetKey()] = obj
	}

	list, err := ct.AlertPolicy().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Infof("Failed to get a list of objects. Err: %s", err)
		return
	}

	// if an object is in our local cache and not in API server, trigger delete for it
	for _, obj := range list {
		_, ok := objmap[obj.GetKey()]
		if !ok {
			ct.logger.Infof("diffAlertPolicy(): Deleting existing object %#v since its not in apiserver", obj.GetKey())
			evt := kvstore.WatchEvent{
				Type:   kvstore.Deleted,
				Key:    obj.GetKey(),
				Object: &obj.AlertPolicy,
			}
			ct.handleAlertPolicyEvent(&evt)
		}
	}

	// trigger create event for all others
	for _, obj := range objlist {
		ct.logger.Infof("diffAlertPolicy(): Adding object %#v", obj.GetKey())
		evt := kvstore.WatchEvent{
			Type:   kvstore.Created,
			Key:    obj.GetKey(),
			Object: obj,
		}
		ct.handleAlertPolicyEvent(&evt)
	}
}

func (ct *ctrlerCtx) runAlertPolicyWatcher() {
	kind := "AlertPolicy"

	ct.Lock()
	handler, ok := ct.handlers[kind]
	ct.Unlock()
	if !ok {
		ct.logger.Fatalf("Cant find the handler for %s", kind)
	}
	alertpolicyHandler := handler.(AlertPolicyHandler)

	opts := alertpolicyHandler.GetAlertPolicyWatchOptions()

	// if there is no API server to connect to, we are done
	if (ct.resolver == nil) || ct.apisrvURL == "" {
		return
	}

	// create context
	ctx, cancel := context.WithCancel(context.Background())
	ct.Lock()
	ct.watchCancel[kind] = cancel
	ct.Unlock()
	logger := ct.logger.WithContext("submodule", "AlertPolicyWatcher")

	// create a grpc client
	apiclt, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
	if err == nil {
		ct.diffAlertPolicy(apiclt)
	}

	// setup wait group
	ct.waitGrp.Add(1)

	// start a goroutine
	go func() {
		defer ct.waitGrp.Done()
		ct.stats.Counter("AlertPolicy_Watch").Inc()
		defer ct.stats.Counter("AlertPolicy_Watch").Dec()

		// loop forever
		for {
			// create a grpc client
			apicl, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
			if err != nil {
				logger.Warnf("Failed to connect to gRPC server [%s]\n", ct.apisrvURL)
				ct.stats.Counter("AlertPolicy_ApiClientErr").Inc()
			} else {
				logger.Infof("API client connected {%+v}", apicl)

				// AlertPolicy object watcher
				wt, werr := apicl.MonitoringV1().AlertPolicy().Watch(ctx, opts)
				if werr != nil {
					select {
					case <-ctx.Done():
						logger.Infof("watch %s cancelled", kind)
						return
					default:
					}
					logger.Errorf("Failed to start %s watch (%s)\n", kind, werr)
					// wait for a second and retry connecting to api server
					apicl.Close()
					time.Sleep(time.Second)
					continue
				}
				ct.Lock()
				ct.watchers[kind] = wt
				ct.Unlock()

				// perform a diff with API server and local cache
				time.Sleep(time.Millisecond * 100)
				ct.diffAlertPolicy(apicl)

				// handle api server watch events
			innerLoop:
				for {
					// wait for events
					select {
					case evt, ok := <-wt.EventChan():
						if !ok {
							logger.Error("Error receiving from apisrv watcher")
							ct.stats.Counter("AlertPolicy_WatchErrors").Inc()
							break innerLoop
						}

						// handle event in parallel
						ct.handleAlertPolicyEventParallel(evt)
					}
				}
				apicl.Close()
			}

			// if stop flag is set, we are done
			if ct.stoped {
				logger.Infof("Exiting API server watcher")
				return
			}

			// wait for a second and retry connecting to api server
			time.Sleep(time.Second)
		}
	}()
}

// WatchAlertPolicy starts watch on AlertPolicy object
func (ct *ctrlerCtx) WatchAlertPolicy(handler AlertPolicyHandler) error {
	kind := "AlertPolicy"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchers[kind]
	ct.Unlock()
	if ok {
		return fmt.Errorf("AlertPolicy watcher already exists")
	}

	// save handler
	ct.Lock()
	ct.handlers[kind] = handler
	ct.Unlock()

	// run AlertPolicy watcher in a go routine
	ct.runAlertPolicyWatcher()

	return nil
}

// StopWatchAlertPolicy stops watch on AlertPolicy object
func (ct *ctrlerCtx) StopWatchAlertPolicy(handler AlertPolicyHandler) error {
	kind := "AlertPolicy"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchers[kind]
	ct.Unlock()
	if !ok {
		return fmt.Errorf("AlertPolicy watcher does not exist")
	}

	ct.Lock()
	cancel, _ := ct.watchCancel[kind]
	cancel()
	delete(ct.watchers, kind)
	delete(ct.watchCancel, kind)
	ct.Unlock()

	time.Sleep(100 * time.Millisecond)

	return nil
}

// AlertPolicyAPI returns
type AlertPolicyAPI interface {
	Create(obj *monitoring.AlertPolicy) error
	SyncCreate(obj *monitoring.AlertPolicy) error
	Update(obj *monitoring.AlertPolicy) error
	SyncUpdate(obj *monitoring.AlertPolicy) error
	Delete(obj *monitoring.AlertPolicy) error
	Find(meta *api.ObjectMeta) (*AlertPolicy, error)
	List(ctx context.Context, opts *api.ListWatchOptions) ([]*AlertPolicy, error)
	Watch(handler AlertPolicyHandler) error
	StopWatch(handler AlertPolicyHandler) error
}

// dummy struct that implements AlertPolicyAPI
type alertpolicyAPI struct {
	ct *ctrlerCtx
}

// Create creates AlertPolicy object
func (api *alertpolicyAPI) Create(obj *monitoring.AlertPolicy) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.MonitoringV1().AlertPolicy().Create(context.Background(), obj)
		if err != nil && strings.Contains(err.Error(), "AlreadyExists") {
			_, err = apicl.MonitoringV1().AlertPolicy().Update(context.Background(), obj)
		}
		return err
	}

	api.ct.handleAlertPolicyEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Created})
	return nil
}

// SyncCreate creates AlertPolicy object and updates the cache
func (api *alertpolicyAPI) SyncCreate(obj *monitoring.AlertPolicy) error {
	newObj := obj
	evtType := kvstore.Created
	var writeErr error
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		newObj, writeErr = apicl.MonitoringV1().AlertPolicy().Create(context.Background(), obj)
		if writeErr != nil && strings.Contains(err.Error(), "AlreadyExists") {
			newObj, writeErr = apicl.MonitoringV1().AlertPolicy().Update(context.Background(), obj)
			evtType = kvstore.Updated
		}
	}

	if writeErr == nil {
		api.ct.handleAlertPolicyEvent(&kvstore.WatchEvent{Object: newObj, Type: evtType})
	}

	if writeErr == nil {
		api.ct.handleAlertPolicyEvent(&kvstore.WatchEvent{Object: newObj, Type: evtType})
	}

	return writeErr
}

// Update triggers update on AlertPolicy object
func (api *alertpolicyAPI) Update(obj *monitoring.AlertPolicy) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.MonitoringV1().AlertPolicy().Update(context.Background(), obj)
		return err
	}

	api.ct.handleAlertPolicyEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Updated})
	return nil
}

// SyncUpdate triggers update on AlertPolicy object and updates the cache
func (api *alertpolicyAPI) SyncUpdate(obj *monitoring.AlertPolicy) error {
	newObj := obj
	var writeErr error
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		newObj, writeErr = apicl.MonitoringV1().AlertPolicy().Update(context.Background(), obj)
	}

	if writeErr == nil {
		api.ct.handleAlertPolicyEvent(&kvstore.WatchEvent{Object: newObj, Type: kvstore.Updated})
	}

	return writeErr
}

// Delete deletes AlertPolicy object
func (api *alertpolicyAPI) Delete(obj *monitoring.AlertPolicy) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.MonitoringV1().AlertPolicy().Delete(context.Background(), &obj.ObjectMeta)
		return err
	}

	api.ct.handleAlertPolicyEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Deleted})
	return nil
}

// MakeKey generates a KV store key for the object
func (api *alertpolicyAPI) getFullKey(tenant, name string) string {
	if tenant != "" {
		return fmt.Sprint(globals.ConfigRootPrefix, "/", "monitoring", "/", "alertPolicies", "/", tenant, "/", name)
	}
	return fmt.Sprint(globals.ConfigRootPrefix, "/", "monitoring", "/", "alertPolicies", "/", name)
}

// Find returns an object by meta
func (api *alertpolicyAPI) Find(meta *api.ObjectMeta) (*AlertPolicy, error) {
	// find the object
	obj, err := api.ct.FindObject("AlertPolicy", meta)
	if err != nil {
		return nil, err
	}

	// asset type
	switch obj.(type) {
	case *AlertPolicy:
		hobj := obj.(*AlertPolicy)
		return hobj, nil
	default:
		return nil, errors.New("incorrect object type")
	}
}

// List returns a list of all AlertPolicy objects
func (api *alertpolicyAPI) List(ctx context.Context, opts *api.ListWatchOptions) ([]*AlertPolicy, error) {
	var objlist []*AlertPolicy
	objs, err := api.ct.List("AlertPolicy", ctx, opts)

	if err != nil {
		return nil, err
	}

	for _, obj := range objs {
		switch tp := obj.(type) {
		case *AlertPolicy:
			eobj := obj.(*AlertPolicy)
			objlist = append(objlist, eobj)
		default:
			log.Fatalf("Got invalid object type %v while looking for AlertPolicy", tp)
		}
	}

	return objlist, nil
}

// Watch sets up a event handlers for AlertPolicy object
func (api *alertpolicyAPI) Watch(handler AlertPolicyHandler) error {
	api.ct.startWorkerPool("AlertPolicy")
	return api.ct.WatchAlertPolicy(handler)
}

// StopWatch stop watch for Tenant AlertPolicy object
func (api *alertpolicyAPI) StopWatch(handler AlertPolicyHandler) error {
	api.ct.Lock()
	api.ct.workPools["AlertPolicy"].Stop()
	api.ct.Unlock()
	return api.ct.StopWatchAlertPolicy(handler)
}

// AlertPolicy returns AlertPolicyAPI
func (ct *ctrlerCtx) AlertPolicy() AlertPolicyAPI {
	return &alertpolicyAPI{ct: ct}
}

// AlertDestination is a wrapper object that implements additional functionality
type AlertDestination struct {
	sync.Mutex
	monitoring.AlertDestination
	HandlerCtx interface{} // additional state handlers can store
	ctrler     *ctrlerCtx  // reference back to the controller instance
}

func (obj *AlertDestination) Write() error {
	// if there is no API server to connect to, we are done
	if (obj.ctrler == nil) || (obj.ctrler.resolver == nil) || obj.ctrler.apisrvURL == "" {
		return nil
	}

	apicl, err := obj.ctrler.apiClient()
	if err != nil {
		obj.ctrler.logger.Errorf("Error creating API server clent. Err: %v", err)
		return err
	}

	obj.ctrler.stats.Counter("AlertDestination_Writes").Inc()

	// write to api server
	if obj.ObjectMeta.ResourceVersion != "" {
		// update it
		for i := 0; i < maxApisrvWriteRetry; i++ {
			_, err = apicl.MonitoringV1().AlertDestination().UpdateStatus(context.Background(), &obj.AlertDestination)
			if err == nil {
				break
			}
			time.Sleep(time.Millisecond * 100)
		}
	} else {
		//  create
		_, err = apicl.MonitoringV1().AlertDestination().Create(context.Background(), &obj.AlertDestination)
	}

	return nil
}

// AlertDestinationHandler is the event handler for AlertDestination object
type AlertDestinationHandler interface {
	OnAlertDestinationCreate(obj *AlertDestination) error
	OnAlertDestinationUpdate(oldObj *AlertDestination, newObj *monitoring.AlertDestination) error
	OnAlertDestinationDelete(obj *AlertDestination) error
	GetAlertDestinationWatchOptions() *api.ListWatchOptions
}

// OnAlertDestinationCreate is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnAlertDestinationCreate(obj *AlertDestination) error {
	log.Info("OnAlertDestinationCreate is not implemented")
	return nil
}

// OnAlertDestinationUpdate is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnAlertDestinationUpdate(oldObj *AlertDestination, newObj *monitoring.AlertDestination) error {
	log.Info("OnAlertDestinationUpdate is not implemented")
	return nil
}

// OnAlertDestinationDelete is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnAlertDestinationDelete(obj *AlertDestination) error {
	log.Info("OnAlertDestinationDelete is not implemented")
	return nil
}

// GetAlertDestinationWatchOptions is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) GetAlertDestinationWatchOptions() *api.ListWatchOptions {
	log.Info("GetAlertDestinationWatchOptions is not implemented")
	opts := &api.ListWatchOptions{}
	return opts
}

// handleAlertDestinationEvent handles AlertDestination events from watcher
func (ct *ctrlerCtx) handleAlertDestinationEvent(evt *kvstore.WatchEvent) error {

	if ct.objResolver == nil {
		return ct.handleAlertDestinationEventNoResolver(evt)
	}

	switch tp := evt.Object.(type) {
	case *monitoring.AlertDestination:
		eobj := evt.Object.(*monitoring.AlertDestination)
		kind := "AlertDestination"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ctx := &alertdestinationCtx{event: evt.Type,
			obj: &AlertDestination{AlertDestination: *eobj, ctrler: ct}}

		var err error
		switch evt.Type {
		case kvstore.Created:
			err = ct.processAdd(ctx)
		case kvstore.Updated:
			err = ct.processUpdate(ctx)
		case kvstore.Deleted:
			err = ct.processDelete(ctx)
		}
		return err
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on AlertDestination watch channel", tp)
	}

	return nil
}

// handleAlertDestinationEventNoResolver handles AlertDestination events from watcher
func (ct *ctrlerCtx) handleAlertDestinationEventNoResolver(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *monitoring.AlertDestination:
		eobj := evt.Object.(*monitoring.AlertDestination)
		kind := "AlertDestination"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		alertdestinationHandler := handler.(AlertDestinationHandler)
		// handle based on event type
		ctrlCtx := &alertdestinationCtx{event: evt.Type, obj: &AlertDestination{AlertDestination: *eobj, ctrler: ct}}
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			fobj, err := ct.getObject(kind, ctrlCtx.GetKey())
			if err != nil {
				ct.addObject(ctrlCtx)
				ct.stats.Counter("AlertDestination_Created_Events").Inc()

				// call the event handler
				ctrlCtx.Lock()
				err = alertdestinationHandler.OnAlertDestinationCreate(ctrlCtx.obj)
				ctrlCtx.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctrlCtx.obj, err)
					ct.delObject(kind, ctrlCtx.GetKey())
					return err
				}
			} else {
				if ct.resolver != nil && fobj.GetResourceVersion() >= eobj.GetResourceVersion() {
					// Event already processed.
					ct.logger.Infof("Skipping update due to old resource version")
					return nil
				}
				ctrlCtx := fobj.(*alertdestinationCtx)
				ct.stats.Counter("AlertDestination_Updated_Events").Inc()
				ctrlCtx.Lock()
				p := monitoring.AlertDestination{Spec: eobj.Spec,
					ObjectMeta: eobj.ObjectMeta,
					TypeMeta:   eobj.TypeMeta,
					Status:     eobj.Status}

				err = alertdestinationHandler.OnAlertDestinationUpdate(ctrlCtx.obj, &p)
				ctrlCtx.obj.AlertDestination = *eobj
				ctrlCtx.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctrlCtx.obj, err)
					return err
				}

			}
		case kvstore.Deleted:
			ctrlCtx := &alertdestinationCtx{event: evt.Type, obj: &AlertDestination{AlertDestination: *eobj, ctrler: ct}}
			fobj, err := ct.findObject(kind, ctrlCtx.GetKey())
			if err != nil {
				ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
				return err
			}

			obj := fobj.(*AlertDestination)
			ct.stats.Counter("AlertDestination_Deleted_Events").Inc()
			obj.Lock()
			err = alertdestinationHandler.OnAlertDestinationDelete(obj)
			obj.Unlock()
			if err != nil {
				ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
			}
			ct.delObject(kind, ctrlCtx.GetKey())
			return nil

		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on AlertDestination watch channel", tp)
	}

	return nil
}

type alertdestinationCtx struct {
	ctkitBaseCtx
	event kvstore.WatchEventType
	obj   *AlertDestination //
	//   newObj     *monitoring.AlertDestination //update
	newObj *alertdestinationCtx //update
}

func (ctx *alertdestinationCtx) References() map[string]apiintf.ReferenceObj {
	resp := make(map[string]apiintf.ReferenceObj)
	ctx.obj.References(ctx.obj.GetObjectMeta().Name, ctx.obj.GetObjectMeta().Namespace, resp)
	return resp
}

func (ctx *alertdestinationCtx) GetKey() string {
	return ctx.obj.MakeKey("monitoring")
}

func (ctx *alertdestinationCtx) GetKind() string {
	return ctx.obj.GetKind()
}

func (ctx *alertdestinationCtx) GetResourceVersion() string {
	return ctx.obj.GetResourceVersion()
}

func (ctx *alertdestinationCtx) SetEvent(event kvstore.WatchEventType) {
	ctx.event = event
}

func (ctx *alertdestinationCtx) SetNewObj(newObj apiintf.CtkitObject) {
	if newObj == nil {
		ctx.newObj = nil
	} else {
		ctx.newObj = newObj.(*alertdestinationCtx)
		ctx.newObj.obj.HandlerCtx = ctx.obj.HandlerCtx
	}
}

func (ctx *alertdestinationCtx) GetNewObj() apiintf.CtkitObject {
	return ctx.newObj
}

func (ctx *alertdestinationCtx) Copy(obj apiintf.CtkitObject) {
	ctx.obj.AlertDestination = obj.(*alertdestinationCtx).obj.AlertDestination
}

func (ctx *alertdestinationCtx) Lock() {
	ctx.obj.Lock()
}

func (ctx *alertdestinationCtx) Unlock() {
	ctx.obj.Unlock()
}

func (ctx *alertdestinationCtx) GetObjectMeta() *api.ObjectMeta {
	return ctx.obj.GetObjectMeta()
}

func (ctx *alertdestinationCtx) RuntimeObject() runtime.Object {
	var v interface{}
	v = ctx.obj
	return v.(runtime.Object)
}

func (ctx *alertdestinationCtx) WorkFunc(context context.Context) error {
	var err error
	evt := ctx.event
	ct := ctx.obj.ctrler
	kind := "AlertDestination"
	ct.Lock()
	handler, ok := ct.handlers[kind]
	ct.Unlock()
	if !ok {
		ct.logger.Fatalf("Cant find the handler for %s", kind)
	}
	alertdestinationHandler := handler.(AlertDestinationHandler)
	switch evt {
	case kvstore.Created:
		ctx.obj.Lock()
		err = alertdestinationHandler.OnAlertDestinationCreate(ctx.obj)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctx.obj, err)
			ctx.SetEvent(kvstore.Deleted)
		}
	case kvstore.Updated:
		ct.stats.Counter("AlertDestination_Updated_Events").Inc()
		ctx.obj.Lock()
		p := monitoring.AlertDestination{Spec: ctx.newObj.obj.Spec,
			ObjectMeta: ctx.newObj.obj.ObjectMeta,
			TypeMeta:   ctx.newObj.obj.TypeMeta,
			Status:     ctx.newObj.obj.Status}
		err = alertdestinationHandler.OnAlertDestinationUpdate(ctx.obj, &p)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctx.obj, err)
			ctx.SetEvent(kvstore.Deleted)
		}
	case kvstore.Deleted:
		ctx.obj.Lock()
		err = alertdestinationHandler.OnAlertDestinationDelete(ctx.obj)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error deleting %s %+v. Err: %v", kind, ctx.obj, err)
		}
	}
	ct.resolveObject(ctx.event, ctx)
	return nil
}

// handleAlertDestinationEventParallel handles AlertDestination events from watcher
func (ct *ctrlerCtx) handleAlertDestinationEventParallel(evt *kvstore.WatchEvent) error {

	if ct.objResolver == nil {
		return ct.handleAlertDestinationEventParallelWithNoResolver(evt)
	}

	switch tp := evt.Object.(type) {
	case *monitoring.AlertDestination:
		eobj := evt.Object.(*monitoring.AlertDestination)
		kind := "AlertDestination"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ctx := &alertdestinationCtx{event: evt.Type, obj: &AlertDestination{AlertDestination: *eobj, ctrler: ct}}

		var err error
		switch evt.Type {
		case kvstore.Created:
			err = ct.processAdd(ctx)
		case kvstore.Updated:
			err = ct.processUpdate(ctx)
		case kvstore.Deleted:
			err = ct.processDelete(ctx)
		}
		return err
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on AlertDestination watch channel", tp)
	}

	return nil
}

// handleAlertDestinationEventParallel handles AlertDestination events from watcher
func (ct *ctrlerCtx) handleAlertDestinationEventParallelWithNoResolver(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *monitoring.AlertDestination:
		eobj := evt.Object.(*monitoring.AlertDestination)
		kind := "AlertDestination"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		alertdestinationHandler := handler.(AlertDestinationHandler)
		// handle based on event type
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			workFunc := func(ctx context.Context, ctrlCtx shardworkers.WorkObj) error {
				var err error
				workCtx := ctrlCtx.(*alertdestinationCtx)
				eobj := workCtx.obj
				fobj, err := ct.getObject(kind, workCtx.GetKey())
				if err != nil {
					ct.addObject(workCtx)
					ct.stats.Counter("AlertDestination_Created_Events").Inc()
					eobj.Lock()
					err = alertdestinationHandler.OnAlertDestinationCreate(eobj)
					eobj.Unlock()
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, eobj, err)
						ct.delObject(kind, workCtx.GetKey())
					}
				} else {
					workCtx := fobj.(*alertdestinationCtx)
					obj := workCtx.obj
					ct.stats.Counter("AlertDestination_Updated_Events").Inc()
					obj.Lock()
					p := monitoring.AlertDestination{Spec: eobj.Spec,
						ObjectMeta: eobj.ObjectMeta,
						TypeMeta:   eobj.TypeMeta,
						Status:     eobj.Status}

					err = alertdestinationHandler.OnAlertDestinationUpdate(obj, &p)
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					} else {
						workCtx.obj.AlertDestination = p
					}
					obj.Unlock()
				}
				return err
			}
			ctrlCtx := &alertdestinationCtx{event: evt.Type, obj: &AlertDestination{AlertDestination: *eobj, ctrler: ct}}
			ct.runFunction("AlertDestination", ctrlCtx, workFunc)
		case kvstore.Deleted:
			workFunc := func(ctx context.Context, ctrlCtx shardworkers.WorkObj) error {
				var err error
				workCtx := ctrlCtx.(*alertdestinationCtx)
				eobj := workCtx.obj
				fobj, err := ct.findObject(kind, workCtx.GetKey())
				if err != nil {
					ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
					return err
				}
				obj := fobj.(*AlertDestination)
				ct.stats.Counter("AlertDestination_Deleted_Events").Inc()
				obj.Lock()
				err = alertdestinationHandler.OnAlertDestinationDelete(obj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
				}
				ct.delObject(kind, workCtx.GetKey())
				return nil
			}
			ctrlCtx := &alertdestinationCtx{event: evt.Type, obj: &AlertDestination{AlertDestination: *eobj, ctrler: ct}}
			ct.runFunction("AlertDestination", ctrlCtx, workFunc)
		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on AlertDestination watch channel", tp)
	}

	return nil
}

// diffAlertDestination does a diff of AlertDestination objects between local cache and API server
func (ct *ctrlerCtx) diffAlertDestination(apicl apiclient.Services) {
	opts := api.ListWatchOptions{}

	// get a list of all objects from API server
	objlist, err := apicl.MonitoringV1().AlertDestination().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Errorf("Error getting a list of objects. Err: %v", err)
		return
	}

	ct.logger.Infof("diffAlertDestination(): AlertDestinationList returned %d objects", len(objlist))

	// build an object map
	objmap := make(map[string]*monitoring.AlertDestination)
	for _, obj := range objlist {
		objmap[obj.GetKey()] = obj
	}

	list, err := ct.AlertDestination().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Infof("Failed to get a list of objects. Err: %s", err)
		return
	}

	// if an object is in our local cache and not in API server, trigger delete for it
	for _, obj := range list {
		_, ok := objmap[obj.GetKey()]
		if !ok {
			ct.logger.Infof("diffAlertDestination(): Deleting existing object %#v since its not in apiserver", obj.GetKey())
			evt := kvstore.WatchEvent{
				Type:   kvstore.Deleted,
				Key:    obj.GetKey(),
				Object: &obj.AlertDestination,
			}
			ct.handleAlertDestinationEvent(&evt)
		}
	}

	// trigger create event for all others
	for _, obj := range objlist {
		ct.logger.Infof("diffAlertDestination(): Adding object %#v", obj.GetKey())
		evt := kvstore.WatchEvent{
			Type:   kvstore.Created,
			Key:    obj.GetKey(),
			Object: obj,
		}
		ct.handleAlertDestinationEvent(&evt)
	}
}

func (ct *ctrlerCtx) runAlertDestinationWatcher() {
	kind := "AlertDestination"

	ct.Lock()
	handler, ok := ct.handlers[kind]
	ct.Unlock()
	if !ok {
		ct.logger.Fatalf("Cant find the handler for %s", kind)
	}
	alertdestinationHandler := handler.(AlertDestinationHandler)

	opts := alertdestinationHandler.GetAlertDestinationWatchOptions()

	// if there is no API server to connect to, we are done
	if (ct.resolver == nil) || ct.apisrvURL == "" {
		return
	}

	// create context
	ctx, cancel := context.WithCancel(context.Background())
	ct.Lock()
	ct.watchCancel[kind] = cancel
	ct.Unlock()
	logger := ct.logger.WithContext("submodule", "AlertDestinationWatcher")

	// create a grpc client
	apiclt, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
	if err == nil {
		ct.diffAlertDestination(apiclt)
	}

	// setup wait group
	ct.waitGrp.Add(1)

	// start a goroutine
	go func() {
		defer ct.waitGrp.Done()
		ct.stats.Counter("AlertDestination_Watch").Inc()
		defer ct.stats.Counter("AlertDestination_Watch").Dec()

		// loop forever
		for {
			// create a grpc client
			apicl, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
			if err != nil {
				logger.Warnf("Failed to connect to gRPC server [%s]\n", ct.apisrvURL)
				ct.stats.Counter("AlertDestination_ApiClientErr").Inc()
			} else {
				logger.Infof("API client connected {%+v}", apicl)

				// AlertDestination object watcher
				wt, werr := apicl.MonitoringV1().AlertDestination().Watch(ctx, opts)
				if werr != nil {
					select {
					case <-ctx.Done():
						logger.Infof("watch %s cancelled", kind)
						return
					default:
					}
					logger.Errorf("Failed to start %s watch (%s)\n", kind, werr)
					// wait for a second and retry connecting to api server
					apicl.Close()
					time.Sleep(time.Second)
					continue
				}
				ct.Lock()
				ct.watchers[kind] = wt
				ct.Unlock()

				// perform a diff with API server and local cache
				time.Sleep(time.Millisecond * 100)
				ct.diffAlertDestination(apicl)

				// handle api server watch events
			innerLoop:
				for {
					// wait for events
					select {
					case evt, ok := <-wt.EventChan():
						if !ok {
							logger.Error("Error receiving from apisrv watcher")
							ct.stats.Counter("AlertDestination_WatchErrors").Inc()
							break innerLoop
						}

						// handle event in parallel
						ct.handleAlertDestinationEventParallel(evt)
					}
				}
				apicl.Close()
			}

			// if stop flag is set, we are done
			if ct.stoped {
				logger.Infof("Exiting API server watcher")
				return
			}

			// wait for a second and retry connecting to api server
			time.Sleep(time.Second)
		}
	}()
}

// WatchAlertDestination starts watch on AlertDestination object
func (ct *ctrlerCtx) WatchAlertDestination(handler AlertDestinationHandler) error {
	kind := "AlertDestination"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchers[kind]
	ct.Unlock()
	if ok {
		return fmt.Errorf("AlertDestination watcher already exists")
	}

	// save handler
	ct.Lock()
	ct.handlers[kind] = handler
	ct.Unlock()

	// run AlertDestination watcher in a go routine
	ct.runAlertDestinationWatcher()

	return nil
}

// StopWatchAlertDestination stops watch on AlertDestination object
func (ct *ctrlerCtx) StopWatchAlertDestination(handler AlertDestinationHandler) error {
	kind := "AlertDestination"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchers[kind]
	ct.Unlock()
	if !ok {
		return fmt.Errorf("AlertDestination watcher does not exist")
	}

	ct.Lock()
	cancel, _ := ct.watchCancel[kind]
	cancel()
	delete(ct.watchers, kind)
	delete(ct.watchCancel, kind)
	ct.Unlock()

	time.Sleep(100 * time.Millisecond)

	return nil
}

// AlertDestinationAPI returns
type AlertDestinationAPI interface {
	Create(obj *monitoring.AlertDestination) error
	SyncCreate(obj *monitoring.AlertDestination) error
	Update(obj *monitoring.AlertDestination) error
	SyncUpdate(obj *monitoring.AlertDestination) error
	Delete(obj *monitoring.AlertDestination) error
	Find(meta *api.ObjectMeta) (*AlertDestination, error)
	List(ctx context.Context, opts *api.ListWatchOptions) ([]*AlertDestination, error)
	Watch(handler AlertDestinationHandler) error
	StopWatch(handler AlertDestinationHandler) error
}

// dummy struct that implements AlertDestinationAPI
type alertdestinationAPI struct {
	ct *ctrlerCtx
}

// Create creates AlertDestination object
func (api *alertdestinationAPI) Create(obj *monitoring.AlertDestination) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.MonitoringV1().AlertDestination().Create(context.Background(), obj)
		if err != nil && strings.Contains(err.Error(), "AlreadyExists") {
			_, err = apicl.MonitoringV1().AlertDestination().Update(context.Background(), obj)
		}
		return err
	}

	api.ct.handleAlertDestinationEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Created})
	return nil
}

// SyncCreate creates AlertDestination object and updates the cache
func (api *alertdestinationAPI) SyncCreate(obj *monitoring.AlertDestination) error {
	newObj := obj
	evtType := kvstore.Created
	var writeErr error
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		newObj, writeErr = apicl.MonitoringV1().AlertDestination().Create(context.Background(), obj)
		if writeErr != nil && strings.Contains(err.Error(), "AlreadyExists") {
			newObj, writeErr = apicl.MonitoringV1().AlertDestination().Update(context.Background(), obj)
			evtType = kvstore.Updated
		}
	}

	if writeErr == nil {
		api.ct.handleAlertDestinationEvent(&kvstore.WatchEvent{Object: newObj, Type: evtType})
	}

	if writeErr == nil {
		api.ct.handleAlertDestinationEvent(&kvstore.WatchEvent{Object: newObj, Type: evtType})
	}

	return writeErr
}

// Update triggers update on AlertDestination object
func (api *alertdestinationAPI) Update(obj *monitoring.AlertDestination) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.MonitoringV1().AlertDestination().Update(context.Background(), obj)
		return err
	}

	api.ct.handleAlertDestinationEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Updated})
	return nil
}

// SyncUpdate triggers update on AlertDestination object and updates the cache
func (api *alertdestinationAPI) SyncUpdate(obj *monitoring.AlertDestination) error {
	newObj := obj
	var writeErr error
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		newObj, writeErr = apicl.MonitoringV1().AlertDestination().Update(context.Background(), obj)
	}

	if writeErr == nil {
		api.ct.handleAlertDestinationEvent(&kvstore.WatchEvent{Object: newObj, Type: kvstore.Updated})
	}

	return writeErr
}

// Delete deletes AlertDestination object
func (api *alertdestinationAPI) Delete(obj *monitoring.AlertDestination) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.MonitoringV1().AlertDestination().Delete(context.Background(), &obj.ObjectMeta)
		return err
	}

	api.ct.handleAlertDestinationEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Deleted})
	return nil
}

// MakeKey generates a KV store key for the object
func (api *alertdestinationAPI) getFullKey(tenant, name string) string {
	if tenant != "" {
		return fmt.Sprint(globals.ConfigRootPrefix, "/", "monitoring", "/", "alertDestinations", "/", tenant, "/", name)
	}
	return fmt.Sprint(globals.ConfigRootPrefix, "/", "monitoring", "/", "alertDestinations", "/", name)
}

// Find returns an object by meta
func (api *alertdestinationAPI) Find(meta *api.ObjectMeta) (*AlertDestination, error) {
	// find the object
	obj, err := api.ct.FindObject("AlertDestination", meta)
	if err != nil {
		return nil, err
	}

	// asset type
	switch obj.(type) {
	case *AlertDestination:
		hobj := obj.(*AlertDestination)
		return hobj, nil
	default:
		return nil, errors.New("incorrect object type")
	}
}

// List returns a list of all AlertDestination objects
func (api *alertdestinationAPI) List(ctx context.Context, opts *api.ListWatchOptions) ([]*AlertDestination, error) {
	var objlist []*AlertDestination
	objs, err := api.ct.List("AlertDestination", ctx, opts)

	if err != nil {
		return nil, err
	}

	for _, obj := range objs {
		switch tp := obj.(type) {
		case *AlertDestination:
			eobj := obj.(*AlertDestination)
			objlist = append(objlist, eobj)
		default:
			log.Fatalf("Got invalid object type %v while looking for AlertDestination", tp)
		}
	}

	return objlist, nil
}

// Watch sets up a event handlers for AlertDestination object
func (api *alertdestinationAPI) Watch(handler AlertDestinationHandler) error {
	api.ct.startWorkerPool("AlertDestination")
	return api.ct.WatchAlertDestination(handler)
}

// StopWatch stop watch for Tenant AlertDestination object
func (api *alertdestinationAPI) StopWatch(handler AlertDestinationHandler) error {
	api.ct.Lock()
	api.ct.workPools["AlertDestination"].Stop()
	api.ct.Unlock()
	return api.ct.StopWatchAlertDestination(handler)
}

// AlertDestination returns AlertDestinationAPI
func (ct *ctrlerCtx) AlertDestination() AlertDestinationAPI {
	return &alertdestinationAPI{ct: ct}
}

// MirrorSession is a wrapper object that implements additional functionality
type MirrorSession struct {
	sync.Mutex
	monitoring.MirrorSession
	HandlerCtx interface{} // additional state handlers can store
	ctrler     *ctrlerCtx  // reference back to the controller instance
}

func (obj *MirrorSession) Write() error {
	// if there is no API server to connect to, we are done
	if (obj.ctrler == nil) || (obj.ctrler.resolver == nil) || obj.ctrler.apisrvURL == "" {
		return nil
	}

	apicl, err := obj.ctrler.apiClient()
	if err != nil {
		obj.ctrler.logger.Errorf("Error creating API server clent. Err: %v", err)
		return err
	}

	obj.ctrler.stats.Counter("MirrorSession_Writes").Inc()

	// write to api server
	if obj.ObjectMeta.ResourceVersion != "" {
		// update it
		for i := 0; i < maxApisrvWriteRetry; i++ {
			_, err = apicl.MonitoringV1().MirrorSession().UpdateStatus(context.Background(), &obj.MirrorSession)
			if err == nil {
				break
			}
			time.Sleep(time.Millisecond * 100)
		}
	} else {
		//  create
		_, err = apicl.MonitoringV1().MirrorSession().Create(context.Background(), &obj.MirrorSession)
	}

	return nil
}

// MirrorSessionHandler is the event handler for MirrorSession object
type MirrorSessionHandler interface {
	OnMirrorSessionCreate(obj *MirrorSession) error
	OnMirrorSessionUpdate(oldObj *MirrorSession, newObj *monitoring.MirrorSession) error
	OnMirrorSessionDelete(obj *MirrorSession) error
	GetMirrorSessionWatchOptions() *api.ListWatchOptions
}

// OnMirrorSessionCreate is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnMirrorSessionCreate(obj *MirrorSession) error {
	log.Info("OnMirrorSessionCreate is not implemented")
	return nil
}

// OnMirrorSessionUpdate is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnMirrorSessionUpdate(oldObj *MirrorSession, newObj *monitoring.MirrorSession) error {
	log.Info("OnMirrorSessionUpdate is not implemented")
	return nil
}

// OnMirrorSessionDelete is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnMirrorSessionDelete(obj *MirrorSession) error {
	log.Info("OnMirrorSessionDelete is not implemented")
	return nil
}

// GetMirrorSessionWatchOptions is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) GetMirrorSessionWatchOptions() *api.ListWatchOptions {
	log.Info("GetMirrorSessionWatchOptions is not implemented")
	opts := &api.ListWatchOptions{}
	return opts
}

// handleMirrorSessionEvent handles MirrorSession events from watcher
func (ct *ctrlerCtx) handleMirrorSessionEvent(evt *kvstore.WatchEvent) error {

	if ct.objResolver == nil {
		return ct.handleMirrorSessionEventNoResolver(evt)
	}

	switch tp := evt.Object.(type) {
	case *monitoring.MirrorSession:
		eobj := evt.Object.(*monitoring.MirrorSession)
		kind := "MirrorSession"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ctx := &mirrorsessionCtx{event: evt.Type,
			obj: &MirrorSession{MirrorSession: *eobj, ctrler: ct}}

		var err error
		switch evt.Type {
		case kvstore.Created:
			err = ct.processAdd(ctx)
		case kvstore.Updated:
			err = ct.processUpdate(ctx)
		case kvstore.Deleted:
			err = ct.processDelete(ctx)
		}
		return err
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on MirrorSession watch channel", tp)
	}

	return nil
}

// handleMirrorSessionEventNoResolver handles MirrorSession events from watcher
func (ct *ctrlerCtx) handleMirrorSessionEventNoResolver(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *monitoring.MirrorSession:
		eobj := evt.Object.(*monitoring.MirrorSession)
		kind := "MirrorSession"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		mirrorsessionHandler := handler.(MirrorSessionHandler)
		// handle based on event type
		ctrlCtx := &mirrorsessionCtx{event: evt.Type, obj: &MirrorSession{MirrorSession: *eobj, ctrler: ct}}
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			fobj, err := ct.getObject(kind, ctrlCtx.GetKey())
			if err != nil {
				ct.addObject(ctrlCtx)
				ct.stats.Counter("MirrorSession_Created_Events").Inc()

				// call the event handler
				ctrlCtx.Lock()
				err = mirrorsessionHandler.OnMirrorSessionCreate(ctrlCtx.obj)
				ctrlCtx.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctrlCtx.obj, err)
					ct.delObject(kind, ctrlCtx.GetKey())
					return err
				}
			} else {
				if ct.resolver != nil && fobj.GetResourceVersion() >= eobj.GetResourceVersion() {
					// Event already processed.
					ct.logger.Infof("Skipping update due to old resource version")
					return nil
				}
				ctrlCtx := fobj.(*mirrorsessionCtx)
				ct.stats.Counter("MirrorSession_Updated_Events").Inc()
				ctrlCtx.Lock()
				p := monitoring.MirrorSession{Spec: eobj.Spec,
					ObjectMeta: eobj.ObjectMeta,
					TypeMeta:   eobj.TypeMeta,
					Status:     eobj.Status}

				err = mirrorsessionHandler.OnMirrorSessionUpdate(ctrlCtx.obj, &p)
				ctrlCtx.obj.MirrorSession = *eobj
				ctrlCtx.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctrlCtx.obj, err)
					return err
				}

			}
		case kvstore.Deleted:
			ctrlCtx := &mirrorsessionCtx{event: evt.Type, obj: &MirrorSession{MirrorSession: *eobj, ctrler: ct}}
			fobj, err := ct.findObject(kind, ctrlCtx.GetKey())
			if err != nil {
				ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
				return err
			}

			obj := fobj.(*MirrorSession)
			ct.stats.Counter("MirrorSession_Deleted_Events").Inc()
			obj.Lock()
			err = mirrorsessionHandler.OnMirrorSessionDelete(obj)
			obj.Unlock()
			if err != nil {
				ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
			}
			ct.delObject(kind, ctrlCtx.GetKey())
			return nil

		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on MirrorSession watch channel", tp)
	}

	return nil
}

type mirrorsessionCtx struct {
	ctkitBaseCtx
	event kvstore.WatchEventType
	obj   *MirrorSession //
	//   newObj     *monitoring.MirrorSession //update
	newObj *mirrorsessionCtx //update
}

func (ctx *mirrorsessionCtx) References() map[string]apiintf.ReferenceObj {
	resp := make(map[string]apiintf.ReferenceObj)
	ctx.obj.References(ctx.obj.GetObjectMeta().Name, ctx.obj.GetObjectMeta().Namespace, resp)
	return resp
}

func (ctx *mirrorsessionCtx) GetKey() string {
	return ctx.obj.MakeKey("monitoring")
}

func (ctx *mirrorsessionCtx) GetKind() string {
	return ctx.obj.GetKind()
}

func (ctx *mirrorsessionCtx) GetResourceVersion() string {
	return ctx.obj.GetResourceVersion()
}

func (ctx *mirrorsessionCtx) SetEvent(event kvstore.WatchEventType) {
	ctx.event = event
}

func (ctx *mirrorsessionCtx) SetNewObj(newObj apiintf.CtkitObject) {
	if newObj == nil {
		ctx.newObj = nil
	} else {
		ctx.newObj = newObj.(*mirrorsessionCtx)
		ctx.newObj.obj.HandlerCtx = ctx.obj.HandlerCtx
	}
}

func (ctx *mirrorsessionCtx) GetNewObj() apiintf.CtkitObject {
	return ctx.newObj
}

func (ctx *mirrorsessionCtx) Copy(obj apiintf.CtkitObject) {
	ctx.obj.MirrorSession = obj.(*mirrorsessionCtx).obj.MirrorSession
}

func (ctx *mirrorsessionCtx) Lock() {
	ctx.obj.Lock()
}

func (ctx *mirrorsessionCtx) Unlock() {
	ctx.obj.Unlock()
}

func (ctx *mirrorsessionCtx) GetObjectMeta() *api.ObjectMeta {
	return ctx.obj.GetObjectMeta()
}

func (ctx *mirrorsessionCtx) RuntimeObject() runtime.Object {
	var v interface{}
	v = ctx.obj
	return v.(runtime.Object)
}

func (ctx *mirrorsessionCtx) WorkFunc(context context.Context) error {
	var err error
	evt := ctx.event
	ct := ctx.obj.ctrler
	kind := "MirrorSession"
	ct.Lock()
	handler, ok := ct.handlers[kind]
	ct.Unlock()
	if !ok {
		ct.logger.Fatalf("Cant find the handler for %s", kind)
	}
	mirrorsessionHandler := handler.(MirrorSessionHandler)
	switch evt {
	case kvstore.Created:
		ctx.obj.Lock()
		err = mirrorsessionHandler.OnMirrorSessionCreate(ctx.obj)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctx.obj, err)
			ctx.SetEvent(kvstore.Deleted)
		}
	case kvstore.Updated:
		ct.stats.Counter("MirrorSession_Updated_Events").Inc()
		ctx.obj.Lock()
		p := monitoring.MirrorSession{Spec: ctx.newObj.obj.Spec,
			ObjectMeta: ctx.newObj.obj.ObjectMeta,
			TypeMeta:   ctx.newObj.obj.TypeMeta,
			Status:     ctx.newObj.obj.Status}
		err = mirrorsessionHandler.OnMirrorSessionUpdate(ctx.obj, &p)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctx.obj, err)
			ctx.SetEvent(kvstore.Deleted)
		}
	case kvstore.Deleted:
		ctx.obj.Lock()
		err = mirrorsessionHandler.OnMirrorSessionDelete(ctx.obj)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error deleting %s %+v. Err: %v", kind, ctx.obj, err)
		}
	}
	ct.resolveObject(ctx.event, ctx)
	return nil
}

// handleMirrorSessionEventParallel handles MirrorSession events from watcher
func (ct *ctrlerCtx) handleMirrorSessionEventParallel(evt *kvstore.WatchEvent) error {

	if ct.objResolver == nil {
		return ct.handleMirrorSessionEventParallelWithNoResolver(evt)
	}

	switch tp := evt.Object.(type) {
	case *monitoring.MirrorSession:
		eobj := evt.Object.(*monitoring.MirrorSession)
		kind := "MirrorSession"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ctx := &mirrorsessionCtx{event: evt.Type, obj: &MirrorSession{MirrorSession: *eobj, ctrler: ct}}

		var err error
		switch evt.Type {
		case kvstore.Created:
			err = ct.processAdd(ctx)
		case kvstore.Updated:
			err = ct.processUpdate(ctx)
		case kvstore.Deleted:
			err = ct.processDelete(ctx)
		}
		return err
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on MirrorSession watch channel", tp)
	}

	return nil
}

// handleMirrorSessionEventParallel handles MirrorSession events from watcher
func (ct *ctrlerCtx) handleMirrorSessionEventParallelWithNoResolver(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *monitoring.MirrorSession:
		eobj := evt.Object.(*monitoring.MirrorSession)
		kind := "MirrorSession"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		mirrorsessionHandler := handler.(MirrorSessionHandler)
		// handle based on event type
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			workFunc := func(ctx context.Context, ctrlCtx shardworkers.WorkObj) error {
				var err error
				workCtx := ctrlCtx.(*mirrorsessionCtx)
				eobj := workCtx.obj
				fobj, err := ct.getObject(kind, workCtx.GetKey())
				if err != nil {
					ct.addObject(workCtx)
					ct.stats.Counter("MirrorSession_Created_Events").Inc()
					eobj.Lock()
					err = mirrorsessionHandler.OnMirrorSessionCreate(eobj)
					eobj.Unlock()
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, eobj, err)
						ct.delObject(kind, workCtx.GetKey())
					}
				} else {
					workCtx := fobj.(*mirrorsessionCtx)
					obj := workCtx.obj
					ct.stats.Counter("MirrorSession_Updated_Events").Inc()
					obj.Lock()
					p := monitoring.MirrorSession{Spec: eobj.Spec,
						ObjectMeta: eobj.ObjectMeta,
						TypeMeta:   eobj.TypeMeta,
						Status:     eobj.Status}

					err = mirrorsessionHandler.OnMirrorSessionUpdate(obj, &p)
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					} else {
						workCtx.obj.MirrorSession = p
					}
					obj.Unlock()
				}
				return err
			}
			ctrlCtx := &mirrorsessionCtx{event: evt.Type, obj: &MirrorSession{MirrorSession: *eobj, ctrler: ct}}
			ct.runFunction("MirrorSession", ctrlCtx, workFunc)
		case kvstore.Deleted:
			workFunc := func(ctx context.Context, ctrlCtx shardworkers.WorkObj) error {
				var err error
				workCtx := ctrlCtx.(*mirrorsessionCtx)
				eobj := workCtx.obj
				fobj, err := ct.findObject(kind, workCtx.GetKey())
				if err != nil {
					ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
					return err
				}
				obj := fobj.(*MirrorSession)
				ct.stats.Counter("MirrorSession_Deleted_Events").Inc()
				obj.Lock()
				err = mirrorsessionHandler.OnMirrorSessionDelete(obj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
				}
				ct.delObject(kind, workCtx.GetKey())
				return nil
			}
			ctrlCtx := &mirrorsessionCtx{event: evt.Type, obj: &MirrorSession{MirrorSession: *eobj, ctrler: ct}}
			ct.runFunction("MirrorSession", ctrlCtx, workFunc)
		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on MirrorSession watch channel", tp)
	}

	return nil
}

// diffMirrorSession does a diff of MirrorSession objects between local cache and API server
func (ct *ctrlerCtx) diffMirrorSession(apicl apiclient.Services) {
	opts := api.ListWatchOptions{}

	// get a list of all objects from API server
	objlist, err := apicl.MonitoringV1().MirrorSession().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Errorf("Error getting a list of objects. Err: %v", err)
		return
	}

	ct.logger.Infof("diffMirrorSession(): MirrorSessionList returned %d objects", len(objlist))

	// build an object map
	objmap := make(map[string]*monitoring.MirrorSession)
	for _, obj := range objlist {
		objmap[obj.GetKey()] = obj
	}

	list, err := ct.MirrorSession().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Infof("Failed to get a list of objects. Err: %s", err)
		return
	}

	// if an object is in our local cache and not in API server, trigger delete for it
	for _, obj := range list {
		_, ok := objmap[obj.GetKey()]
		if !ok {
			ct.logger.Infof("diffMirrorSession(): Deleting existing object %#v since its not in apiserver", obj.GetKey())
			evt := kvstore.WatchEvent{
				Type:   kvstore.Deleted,
				Key:    obj.GetKey(),
				Object: &obj.MirrorSession,
			}
			ct.handleMirrorSessionEvent(&evt)
		}
	}

	// trigger create event for all others
	for _, obj := range objlist {
		ct.logger.Infof("diffMirrorSession(): Adding object %#v", obj.GetKey())
		evt := kvstore.WatchEvent{
			Type:   kvstore.Created,
			Key:    obj.GetKey(),
			Object: obj,
		}
		ct.handleMirrorSessionEvent(&evt)
	}
}

func (ct *ctrlerCtx) runMirrorSessionWatcher() {
	kind := "MirrorSession"

	ct.Lock()
	handler, ok := ct.handlers[kind]
	ct.Unlock()
	if !ok {
		ct.logger.Fatalf("Cant find the handler for %s", kind)
	}
	mirrorsessionHandler := handler.(MirrorSessionHandler)

	opts := mirrorsessionHandler.GetMirrorSessionWatchOptions()

	// if there is no API server to connect to, we are done
	if (ct.resolver == nil) || ct.apisrvURL == "" {
		return
	}

	// create context
	ctx, cancel := context.WithCancel(context.Background())
	ct.Lock()
	ct.watchCancel[kind] = cancel
	ct.Unlock()
	logger := ct.logger.WithContext("submodule", "MirrorSessionWatcher")

	// create a grpc client
	apiclt, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
	if err == nil {
		ct.diffMirrorSession(apiclt)
	}

	// setup wait group
	ct.waitGrp.Add(1)

	// start a goroutine
	go func() {
		defer ct.waitGrp.Done()
		ct.stats.Counter("MirrorSession_Watch").Inc()
		defer ct.stats.Counter("MirrorSession_Watch").Dec()

		// loop forever
		for {
			// create a grpc client
			apicl, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
			if err != nil {
				logger.Warnf("Failed to connect to gRPC server [%s]\n", ct.apisrvURL)
				ct.stats.Counter("MirrorSession_ApiClientErr").Inc()
			} else {
				logger.Infof("API client connected {%+v}", apicl)

				// MirrorSession object watcher
				wt, werr := apicl.MonitoringV1().MirrorSession().Watch(ctx, opts)
				if werr != nil {
					select {
					case <-ctx.Done():
						logger.Infof("watch %s cancelled", kind)
						return
					default:
					}
					logger.Errorf("Failed to start %s watch (%s)\n", kind, werr)
					// wait for a second and retry connecting to api server
					apicl.Close()
					time.Sleep(time.Second)
					continue
				}
				ct.Lock()
				ct.watchers[kind] = wt
				ct.Unlock()

				// perform a diff with API server and local cache
				time.Sleep(time.Millisecond * 100)
				ct.diffMirrorSession(apicl)

				// handle api server watch events
			innerLoop:
				for {
					// wait for events
					select {
					case evt, ok := <-wt.EventChan():
						if !ok {
							logger.Error("Error receiving from apisrv watcher")
							ct.stats.Counter("MirrorSession_WatchErrors").Inc()
							break innerLoop
						}

						// handle event in parallel
						ct.handleMirrorSessionEventParallel(evt)
					}
				}
				apicl.Close()
			}

			// if stop flag is set, we are done
			if ct.stoped {
				logger.Infof("Exiting API server watcher")
				return
			}

			// wait for a second and retry connecting to api server
			time.Sleep(time.Second)
		}
	}()
}

// WatchMirrorSession starts watch on MirrorSession object
func (ct *ctrlerCtx) WatchMirrorSession(handler MirrorSessionHandler) error {
	kind := "MirrorSession"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchers[kind]
	ct.Unlock()
	if ok {
		return fmt.Errorf("MirrorSession watcher already exists")
	}

	// save handler
	ct.Lock()
	ct.handlers[kind] = handler
	ct.Unlock()

	// run MirrorSession watcher in a go routine
	ct.runMirrorSessionWatcher()

	return nil
}

// StopWatchMirrorSession stops watch on MirrorSession object
func (ct *ctrlerCtx) StopWatchMirrorSession(handler MirrorSessionHandler) error {
	kind := "MirrorSession"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchers[kind]
	ct.Unlock()
	if !ok {
		return fmt.Errorf("MirrorSession watcher does not exist")
	}

	ct.Lock()
	cancel, _ := ct.watchCancel[kind]
	cancel()
	delete(ct.watchers, kind)
	delete(ct.watchCancel, kind)
	ct.Unlock()

	time.Sleep(100 * time.Millisecond)

	return nil
}

// MirrorSessionAPI returns
type MirrorSessionAPI interface {
	Create(obj *monitoring.MirrorSession) error
	SyncCreate(obj *monitoring.MirrorSession) error
	Update(obj *monitoring.MirrorSession) error
	SyncUpdate(obj *monitoring.MirrorSession) error
	Delete(obj *monitoring.MirrorSession) error
	Find(meta *api.ObjectMeta) (*MirrorSession, error)
	List(ctx context.Context, opts *api.ListWatchOptions) ([]*MirrorSession, error)
	Watch(handler MirrorSessionHandler) error
	StopWatch(handler MirrorSessionHandler) error
}

// dummy struct that implements MirrorSessionAPI
type mirrorsessionAPI struct {
	ct *ctrlerCtx
}

// Create creates MirrorSession object
func (api *mirrorsessionAPI) Create(obj *monitoring.MirrorSession) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.MonitoringV1().MirrorSession().Create(context.Background(), obj)
		if err != nil && strings.Contains(err.Error(), "AlreadyExists") {
			_, err = apicl.MonitoringV1().MirrorSession().Update(context.Background(), obj)
		}
		return err
	}

	api.ct.handleMirrorSessionEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Created})
	return nil
}

// SyncCreate creates MirrorSession object and updates the cache
func (api *mirrorsessionAPI) SyncCreate(obj *monitoring.MirrorSession) error {
	newObj := obj
	evtType := kvstore.Created
	var writeErr error
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		newObj, writeErr = apicl.MonitoringV1().MirrorSession().Create(context.Background(), obj)
		if writeErr != nil && strings.Contains(err.Error(), "AlreadyExists") {
			newObj, writeErr = apicl.MonitoringV1().MirrorSession().Update(context.Background(), obj)
			evtType = kvstore.Updated
		}
	}

	if writeErr == nil {
		api.ct.handleMirrorSessionEvent(&kvstore.WatchEvent{Object: newObj, Type: evtType})
	}

	if writeErr == nil {
		api.ct.handleMirrorSessionEvent(&kvstore.WatchEvent{Object: newObj, Type: evtType})
	}

	return writeErr
}

// Update triggers update on MirrorSession object
func (api *mirrorsessionAPI) Update(obj *monitoring.MirrorSession) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.MonitoringV1().MirrorSession().Update(context.Background(), obj)
		return err
	}

	api.ct.handleMirrorSessionEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Updated})
	return nil
}

// SyncUpdate triggers update on MirrorSession object and updates the cache
func (api *mirrorsessionAPI) SyncUpdate(obj *monitoring.MirrorSession) error {
	newObj := obj
	var writeErr error
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		newObj, writeErr = apicl.MonitoringV1().MirrorSession().Update(context.Background(), obj)
	}

	if writeErr == nil {
		api.ct.handleMirrorSessionEvent(&kvstore.WatchEvent{Object: newObj, Type: kvstore.Updated})
	}

	return writeErr
}

// Delete deletes MirrorSession object
func (api *mirrorsessionAPI) Delete(obj *monitoring.MirrorSession) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.MonitoringV1().MirrorSession().Delete(context.Background(), &obj.ObjectMeta)
		return err
	}

	api.ct.handleMirrorSessionEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Deleted})
	return nil
}

// MakeKey generates a KV store key for the object
func (api *mirrorsessionAPI) getFullKey(tenant, name string) string {
	if tenant != "" {
		return fmt.Sprint(globals.ConfigRootPrefix, "/", "monitoring", "/", "MirrorSession", "/", tenant, "/", name)
	}
	return fmt.Sprint(globals.ConfigRootPrefix, "/", "monitoring", "/", "MirrorSession", "/", name)
}

// Find returns an object by meta
func (api *mirrorsessionAPI) Find(meta *api.ObjectMeta) (*MirrorSession, error) {
	// find the object
	obj, err := api.ct.FindObject("MirrorSession", meta)
	if err != nil {
		return nil, err
	}

	// asset type
	switch obj.(type) {
	case *MirrorSession:
		hobj := obj.(*MirrorSession)
		return hobj, nil
	default:
		return nil, errors.New("incorrect object type")
	}
}

// List returns a list of all MirrorSession objects
func (api *mirrorsessionAPI) List(ctx context.Context, opts *api.ListWatchOptions) ([]*MirrorSession, error) {
	var objlist []*MirrorSession
	objs, err := api.ct.List("MirrorSession", ctx, opts)

	if err != nil {
		return nil, err
	}

	for _, obj := range objs {
		switch tp := obj.(type) {
		case *MirrorSession:
			eobj := obj.(*MirrorSession)
			objlist = append(objlist, eobj)
		default:
			log.Fatalf("Got invalid object type %v while looking for MirrorSession", tp)
		}
	}

	return objlist, nil
}

// Watch sets up a event handlers for MirrorSession object
func (api *mirrorsessionAPI) Watch(handler MirrorSessionHandler) error {
	api.ct.startWorkerPool("MirrorSession")
	return api.ct.WatchMirrorSession(handler)
}

// StopWatch stop watch for Tenant MirrorSession object
func (api *mirrorsessionAPI) StopWatch(handler MirrorSessionHandler) error {
	api.ct.Lock()
	api.ct.workPools["MirrorSession"].Stop()
	api.ct.Unlock()
	return api.ct.StopWatchMirrorSession(handler)
}

// MirrorSession returns MirrorSessionAPI
func (ct *ctrlerCtx) MirrorSession() MirrorSessionAPI {
	return &mirrorsessionAPI{ct: ct}
}

// TroubleshootingSession is a wrapper object that implements additional functionality
type TroubleshootingSession struct {
	sync.Mutex
	monitoring.TroubleshootingSession
	HandlerCtx interface{} // additional state handlers can store
	ctrler     *ctrlerCtx  // reference back to the controller instance
}

func (obj *TroubleshootingSession) Write() error {
	// if there is no API server to connect to, we are done
	if (obj.ctrler == nil) || (obj.ctrler.resolver == nil) || obj.ctrler.apisrvURL == "" {
		return nil
	}

	apicl, err := obj.ctrler.apiClient()
	if err != nil {
		obj.ctrler.logger.Errorf("Error creating API server clent. Err: %v", err)
		return err
	}

	obj.ctrler.stats.Counter("TroubleshootingSession_Writes").Inc()

	// write to api server
	if obj.ObjectMeta.ResourceVersion != "" {
		// update it
		for i := 0; i < maxApisrvWriteRetry; i++ {
			_, err = apicl.MonitoringV1().TroubleshootingSession().UpdateStatus(context.Background(), &obj.TroubleshootingSession)
			if err == nil {
				break
			}
			time.Sleep(time.Millisecond * 100)
		}
	} else {
		//  create
		_, err = apicl.MonitoringV1().TroubleshootingSession().Create(context.Background(), &obj.TroubleshootingSession)
	}

	return nil
}

// TroubleshootingSessionHandler is the event handler for TroubleshootingSession object
type TroubleshootingSessionHandler interface {
	OnTroubleshootingSessionCreate(obj *TroubleshootingSession) error
	OnTroubleshootingSessionUpdate(oldObj *TroubleshootingSession, newObj *monitoring.TroubleshootingSession) error
	OnTroubleshootingSessionDelete(obj *TroubleshootingSession) error
	GetTroubleshootingSessionWatchOptions() *api.ListWatchOptions
}

// OnTroubleshootingSessionCreate is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnTroubleshootingSessionCreate(obj *TroubleshootingSession) error {
	log.Info("OnTroubleshootingSessionCreate is not implemented")
	return nil
}

// OnTroubleshootingSessionUpdate is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnTroubleshootingSessionUpdate(oldObj *TroubleshootingSession, newObj *monitoring.TroubleshootingSession) error {
	log.Info("OnTroubleshootingSessionUpdate is not implemented")
	return nil
}

// OnTroubleshootingSessionDelete is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnTroubleshootingSessionDelete(obj *TroubleshootingSession) error {
	log.Info("OnTroubleshootingSessionDelete is not implemented")
	return nil
}

// GetTroubleshootingSessionWatchOptions is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) GetTroubleshootingSessionWatchOptions() *api.ListWatchOptions {
	log.Info("GetTroubleshootingSessionWatchOptions is not implemented")
	opts := &api.ListWatchOptions{}
	return opts
}

// handleTroubleshootingSessionEvent handles TroubleshootingSession events from watcher
func (ct *ctrlerCtx) handleTroubleshootingSessionEvent(evt *kvstore.WatchEvent) error {

	if ct.objResolver == nil {
		return ct.handleTroubleshootingSessionEventNoResolver(evt)
	}

	switch tp := evt.Object.(type) {
	case *monitoring.TroubleshootingSession:
		eobj := evt.Object.(*monitoring.TroubleshootingSession)
		kind := "TroubleshootingSession"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ctx := &troubleshootingsessionCtx{event: evt.Type,
			obj: &TroubleshootingSession{TroubleshootingSession: *eobj, ctrler: ct}}

		var err error
		switch evt.Type {
		case kvstore.Created:
			err = ct.processAdd(ctx)
		case kvstore.Updated:
			err = ct.processUpdate(ctx)
		case kvstore.Deleted:
			err = ct.processDelete(ctx)
		}
		return err
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on TroubleshootingSession watch channel", tp)
	}

	return nil
}

// handleTroubleshootingSessionEventNoResolver handles TroubleshootingSession events from watcher
func (ct *ctrlerCtx) handleTroubleshootingSessionEventNoResolver(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *monitoring.TroubleshootingSession:
		eobj := evt.Object.(*monitoring.TroubleshootingSession)
		kind := "TroubleshootingSession"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		troubleshootingsessionHandler := handler.(TroubleshootingSessionHandler)
		// handle based on event type
		ctrlCtx := &troubleshootingsessionCtx{event: evt.Type, obj: &TroubleshootingSession{TroubleshootingSession: *eobj, ctrler: ct}}
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			fobj, err := ct.getObject(kind, ctrlCtx.GetKey())
			if err != nil {
				ct.addObject(ctrlCtx)
				ct.stats.Counter("TroubleshootingSession_Created_Events").Inc()

				// call the event handler
				ctrlCtx.Lock()
				err = troubleshootingsessionHandler.OnTroubleshootingSessionCreate(ctrlCtx.obj)
				ctrlCtx.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctrlCtx.obj, err)
					ct.delObject(kind, ctrlCtx.GetKey())
					return err
				}
			} else {
				if ct.resolver != nil && fobj.GetResourceVersion() >= eobj.GetResourceVersion() {
					// Event already processed.
					ct.logger.Infof("Skipping update due to old resource version")
					return nil
				}
				ctrlCtx := fobj.(*troubleshootingsessionCtx)
				ct.stats.Counter("TroubleshootingSession_Updated_Events").Inc()
				ctrlCtx.Lock()
				p := monitoring.TroubleshootingSession{Spec: eobj.Spec,
					ObjectMeta: eobj.ObjectMeta,
					TypeMeta:   eobj.TypeMeta,
					Status:     eobj.Status}

				err = troubleshootingsessionHandler.OnTroubleshootingSessionUpdate(ctrlCtx.obj, &p)
				ctrlCtx.obj.TroubleshootingSession = *eobj
				ctrlCtx.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctrlCtx.obj, err)
					return err
				}

			}
		case kvstore.Deleted:
			ctrlCtx := &troubleshootingsessionCtx{event: evt.Type, obj: &TroubleshootingSession{TroubleshootingSession: *eobj, ctrler: ct}}
			fobj, err := ct.findObject(kind, ctrlCtx.GetKey())
			if err != nil {
				ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
				return err
			}

			obj := fobj.(*TroubleshootingSession)
			ct.stats.Counter("TroubleshootingSession_Deleted_Events").Inc()
			obj.Lock()
			err = troubleshootingsessionHandler.OnTroubleshootingSessionDelete(obj)
			obj.Unlock()
			if err != nil {
				ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
			}
			ct.delObject(kind, ctrlCtx.GetKey())
			return nil

		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on TroubleshootingSession watch channel", tp)
	}

	return nil
}

type troubleshootingsessionCtx struct {
	ctkitBaseCtx
	event kvstore.WatchEventType
	obj   *TroubleshootingSession //
	//   newObj     *monitoring.TroubleshootingSession //update
	newObj *troubleshootingsessionCtx //update
}

func (ctx *troubleshootingsessionCtx) References() map[string]apiintf.ReferenceObj {
	resp := make(map[string]apiintf.ReferenceObj)
	ctx.obj.References(ctx.obj.GetObjectMeta().Name, ctx.obj.GetObjectMeta().Namespace, resp)
	return resp
}

func (ctx *troubleshootingsessionCtx) GetKey() string {
	return ctx.obj.MakeKey("monitoring")
}

func (ctx *troubleshootingsessionCtx) GetKind() string {
	return ctx.obj.GetKind()
}

func (ctx *troubleshootingsessionCtx) GetResourceVersion() string {
	return ctx.obj.GetResourceVersion()
}

func (ctx *troubleshootingsessionCtx) SetEvent(event kvstore.WatchEventType) {
	ctx.event = event
}

func (ctx *troubleshootingsessionCtx) SetNewObj(newObj apiintf.CtkitObject) {
	if newObj == nil {
		ctx.newObj = nil
	} else {
		ctx.newObj = newObj.(*troubleshootingsessionCtx)
		ctx.newObj.obj.HandlerCtx = ctx.obj.HandlerCtx
	}
}

func (ctx *troubleshootingsessionCtx) GetNewObj() apiintf.CtkitObject {
	return ctx.newObj
}

func (ctx *troubleshootingsessionCtx) Copy(obj apiintf.CtkitObject) {
	ctx.obj.TroubleshootingSession = obj.(*troubleshootingsessionCtx).obj.TroubleshootingSession
}

func (ctx *troubleshootingsessionCtx) Lock() {
	ctx.obj.Lock()
}

func (ctx *troubleshootingsessionCtx) Unlock() {
	ctx.obj.Unlock()
}

func (ctx *troubleshootingsessionCtx) GetObjectMeta() *api.ObjectMeta {
	return ctx.obj.GetObjectMeta()
}

func (ctx *troubleshootingsessionCtx) RuntimeObject() runtime.Object {
	var v interface{}
	v = ctx.obj
	return v.(runtime.Object)
}

func (ctx *troubleshootingsessionCtx) WorkFunc(context context.Context) error {
	var err error
	evt := ctx.event
	ct := ctx.obj.ctrler
	kind := "TroubleshootingSession"
	ct.Lock()
	handler, ok := ct.handlers[kind]
	ct.Unlock()
	if !ok {
		ct.logger.Fatalf("Cant find the handler for %s", kind)
	}
	troubleshootingsessionHandler := handler.(TroubleshootingSessionHandler)
	switch evt {
	case kvstore.Created:
		ctx.obj.Lock()
		err = troubleshootingsessionHandler.OnTroubleshootingSessionCreate(ctx.obj)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctx.obj, err)
			ctx.SetEvent(kvstore.Deleted)
		}
	case kvstore.Updated:
		ct.stats.Counter("TroubleshootingSession_Updated_Events").Inc()
		ctx.obj.Lock()
		p := monitoring.TroubleshootingSession{Spec: ctx.newObj.obj.Spec,
			ObjectMeta: ctx.newObj.obj.ObjectMeta,
			TypeMeta:   ctx.newObj.obj.TypeMeta,
			Status:     ctx.newObj.obj.Status}
		err = troubleshootingsessionHandler.OnTroubleshootingSessionUpdate(ctx.obj, &p)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctx.obj, err)
			ctx.SetEvent(kvstore.Deleted)
		}
	case kvstore.Deleted:
		ctx.obj.Lock()
		err = troubleshootingsessionHandler.OnTroubleshootingSessionDelete(ctx.obj)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error deleting %s %+v. Err: %v", kind, ctx.obj, err)
		}
	}
	ct.resolveObject(ctx.event, ctx)
	return nil
}

// handleTroubleshootingSessionEventParallel handles TroubleshootingSession events from watcher
func (ct *ctrlerCtx) handleTroubleshootingSessionEventParallel(evt *kvstore.WatchEvent) error {

	if ct.objResolver == nil {
		return ct.handleTroubleshootingSessionEventParallelWithNoResolver(evt)
	}

	switch tp := evt.Object.(type) {
	case *monitoring.TroubleshootingSession:
		eobj := evt.Object.(*monitoring.TroubleshootingSession)
		kind := "TroubleshootingSession"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ctx := &troubleshootingsessionCtx{event: evt.Type, obj: &TroubleshootingSession{TroubleshootingSession: *eobj, ctrler: ct}}

		var err error
		switch evt.Type {
		case kvstore.Created:
			err = ct.processAdd(ctx)
		case kvstore.Updated:
			err = ct.processUpdate(ctx)
		case kvstore.Deleted:
			err = ct.processDelete(ctx)
		}
		return err
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on TroubleshootingSession watch channel", tp)
	}

	return nil
}

// handleTroubleshootingSessionEventParallel handles TroubleshootingSession events from watcher
func (ct *ctrlerCtx) handleTroubleshootingSessionEventParallelWithNoResolver(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *monitoring.TroubleshootingSession:
		eobj := evt.Object.(*monitoring.TroubleshootingSession)
		kind := "TroubleshootingSession"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		troubleshootingsessionHandler := handler.(TroubleshootingSessionHandler)
		// handle based on event type
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			workFunc := func(ctx context.Context, ctrlCtx shardworkers.WorkObj) error {
				var err error
				workCtx := ctrlCtx.(*troubleshootingsessionCtx)
				eobj := workCtx.obj
				fobj, err := ct.getObject(kind, workCtx.GetKey())
				if err != nil {
					ct.addObject(workCtx)
					ct.stats.Counter("TroubleshootingSession_Created_Events").Inc()
					eobj.Lock()
					err = troubleshootingsessionHandler.OnTroubleshootingSessionCreate(eobj)
					eobj.Unlock()
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, eobj, err)
						ct.delObject(kind, workCtx.GetKey())
					}
				} else {
					workCtx := fobj.(*troubleshootingsessionCtx)
					obj := workCtx.obj
					ct.stats.Counter("TroubleshootingSession_Updated_Events").Inc()
					obj.Lock()
					p := monitoring.TroubleshootingSession{Spec: eobj.Spec,
						ObjectMeta: eobj.ObjectMeta,
						TypeMeta:   eobj.TypeMeta,
						Status:     eobj.Status}

					err = troubleshootingsessionHandler.OnTroubleshootingSessionUpdate(obj, &p)
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					} else {
						workCtx.obj.TroubleshootingSession = p
					}
					obj.Unlock()
				}
				return err
			}
			ctrlCtx := &troubleshootingsessionCtx{event: evt.Type, obj: &TroubleshootingSession{TroubleshootingSession: *eobj, ctrler: ct}}
			ct.runFunction("TroubleshootingSession", ctrlCtx, workFunc)
		case kvstore.Deleted:
			workFunc := func(ctx context.Context, ctrlCtx shardworkers.WorkObj) error {
				var err error
				workCtx := ctrlCtx.(*troubleshootingsessionCtx)
				eobj := workCtx.obj
				fobj, err := ct.findObject(kind, workCtx.GetKey())
				if err != nil {
					ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
					return err
				}
				obj := fobj.(*TroubleshootingSession)
				ct.stats.Counter("TroubleshootingSession_Deleted_Events").Inc()
				obj.Lock()
				err = troubleshootingsessionHandler.OnTroubleshootingSessionDelete(obj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
				}
				ct.delObject(kind, workCtx.GetKey())
				return nil
			}
			ctrlCtx := &troubleshootingsessionCtx{event: evt.Type, obj: &TroubleshootingSession{TroubleshootingSession: *eobj, ctrler: ct}}
			ct.runFunction("TroubleshootingSession", ctrlCtx, workFunc)
		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on TroubleshootingSession watch channel", tp)
	}

	return nil
}

// diffTroubleshootingSession does a diff of TroubleshootingSession objects between local cache and API server
func (ct *ctrlerCtx) diffTroubleshootingSession(apicl apiclient.Services) {
	opts := api.ListWatchOptions{}

	// get a list of all objects from API server
	objlist, err := apicl.MonitoringV1().TroubleshootingSession().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Errorf("Error getting a list of objects. Err: %v", err)
		return
	}

	ct.logger.Infof("diffTroubleshootingSession(): TroubleshootingSessionList returned %d objects", len(objlist))

	// build an object map
	objmap := make(map[string]*monitoring.TroubleshootingSession)
	for _, obj := range objlist {
		objmap[obj.GetKey()] = obj
	}

	list, err := ct.TroubleshootingSession().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Infof("Failed to get a list of objects. Err: %s", err)
		return
	}

	// if an object is in our local cache and not in API server, trigger delete for it
	for _, obj := range list {
		_, ok := objmap[obj.GetKey()]
		if !ok {
			ct.logger.Infof("diffTroubleshootingSession(): Deleting existing object %#v since its not in apiserver", obj.GetKey())
			evt := kvstore.WatchEvent{
				Type:   kvstore.Deleted,
				Key:    obj.GetKey(),
				Object: &obj.TroubleshootingSession,
			}
			ct.handleTroubleshootingSessionEvent(&evt)
		}
	}

	// trigger create event for all others
	for _, obj := range objlist {
		ct.logger.Infof("diffTroubleshootingSession(): Adding object %#v", obj.GetKey())
		evt := kvstore.WatchEvent{
			Type:   kvstore.Created,
			Key:    obj.GetKey(),
			Object: obj,
		}
		ct.handleTroubleshootingSessionEvent(&evt)
	}
}

func (ct *ctrlerCtx) runTroubleshootingSessionWatcher() {
	kind := "TroubleshootingSession"

	ct.Lock()
	handler, ok := ct.handlers[kind]
	ct.Unlock()
	if !ok {
		ct.logger.Fatalf("Cant find the handler for %s", kind)
	}
	troubleshootingsessionHandler := handler.(TroubleshootingSessionHandler)

	opts := troubleshootingsessionHandler.GetTroubleshootingSessionWatchOptions()

	// if there is no API server to connect to, we are done
	if (ct.resolver == nil) || ct.apisrvURL == "" {
		return
	}

	// create context
	ctx, cancel := context.WithCancel(context.Background())
	ct.Lock()
	ct.watchCancel[kind] = cancel
	ct.Unlock()
	logger := ct.logger.WithContext("submodule", "TroubleshootingSessionWatcher")

	// create a grpc client
	apiclt, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
	if err == nil {
		ct.diffTroubleshootingSession(apiclt)
	}

	// setup wait group
	ct.waitGrp.Add(1)

	// start a goroutine
	go func() {
		defer ct.waitGrp.Done()
		ct.stats.Counter("TroubleshootingSession_Watch").Inc()
		defer ct.stats.Counter("TroubleshootingSession_Watch").Dec()

		// loop forever
		for {
			// create a grpc client
			apicl, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
			if err != nil {
				logger.Warnf("Failed to connect to gRPC server [%s]\n", ct.apisrvURL)
				ct.stats.Counter("TroubleshootingSession_ApiClientErr").Inc()
			} else {
				logger.Infof("API client connected {%+v}", apicl)

				// TroubleshootingSession object watcher
				wt, werr := apicl.MonitoringV1().TroubleshootingSession().Watch(ctx, opts)
				if werr != nil {
					select {
					case <-ctx.Done():
						logger.Infof("watch %s cancelled", kind)
						return
					default:
					}
					logger.Errorf("Failed to start %s watch (%s)\n", kind, werr)
					// wait for a second and retry connecting to api server
					apicl.Close()
					time.Sleep(time.Second)
					continue
				}
				ct.Lock()
				ct.watchers[kind] = wt
				ct.Unlock()

				// perform a diff with API server and local cache
				time.Sleep(time.Millisecond * 100)
				ct.diffTroubleshootingSession(apicl)

				// handle api server watch events
			innerLoop:
				for {
					// wait for events
					select {
					case evt, ok := <-wt.EventChan():
						if !ok {
							logger.Error("Error receiving from apisrv watcher")
							ct.stats.Counter("TroubleshootingSession_WatchErrors").Inc()
							break innerLoop
						}

						// handle event in parallel
						ct.handleTroubleshootingSessionEventParallel(evt)
					}
				}
				apicl.Close()
			}

			// if stop flag is set, we are done
			if ct.stoped {
				logger.Infof("Exiting API server watcher")
				return
			}

			// wait for a second and retry connecting to api server
			time.Sleep(time.Second)
		}
	}()
}

// WatchTroubleshootingSession starts watch on TroubleshootingSession object
func (ct *ctrlerCtx) WatchTroubleshootingSession(handler TroubleshootingSessionHandler) error {
	kind := "TroubleshootingSession"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchers[kind]
	ct.Unlock()
	if ok {
		return fmt.Errorf("TroubleshootingSession watcher already exists")
	}

	// save handler
	ct.Lock()
	ct.handlers[kind] = handler
	ct.Unlock()

	// run TroubleshootingSession watcher in a go routine
	ct.runTroubleshootingSessionWatcher()

	return nil
}

// StopWatchTroubleshootingSession stops watch on TroubleshootingSession object
func (ct *ctrlerCtx) StopWatchTroubleshootingSession(handler TroubleshootingSessionHandler) error {
	kind := "TroubleshootingSession"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchers[kind]
	ct.Unlock()
	if !ok {
		return fmt.Errorf("TroubleshootingSession watcher does not exist")
	}

	ct.Lock()
	cancel, _ := ct.watchCancel[kind]
	cancel()
	delete(ct.watchers, kind)
	delete(ct.watchCancel, kind)
	ct.Unlock()

	time.Sleep(100 * time.Millisecond)

	return nil
}

// TroubleshootingSessionAPI returns
type TroubleshootingSessionAPI interface {
	Create(obj *monitoring.TroubleshootingSession) error
	SyncCreate(obj *monitoring.TroubleshootingSession) error
	Update(obj *monitoring.TroubleshootingSession) error
	SyncUpdate(obj *monitoring.TroubleshootingSession) error
	Delete(obj *monitoring.TroubleshootingSession) error
	Find(meta *api.ObjectMeta) (*TroubleshootingSession, error)
	List(ctx context.Context, opts *api.ListWatchOptions) ([]*TroubleshootingSession, error)
	Watch(handler TroubleshootingSessionHandler) error
	StopWatch(handler TroubleshootingSessionHandler) error
}

// dummy struct that implements TroubleshootingSessionAPI
type troubleshootingsessionAPI struct {
	ct *ctrlerCtx
}

// Create creates TroubleshootingSession object
func (api *troubleshootingsessionAPI) Create(obj *monitoring.TroubleshootingSession) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.MonitoringV1().TroubleshootingSession().Create(context.Background(), obj)
		if err != nil && strings.Contains(err.Error(), "AlreadyExists") {
			_, err = apicl.MonitoringV1().TroubleshootingSession().Update(context.Background(), obj)
		}
		return err
	}

	api.ct.handleTroubleshootingSessionEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Created})
	return nil
}

// SyncCreate creates TroubleshootingSession object and updates the cache
func (api *troubleshootingsessionAPI) SyncCreate(obj *monitoring.TroubleshootingSession) error {
	newObj := obj
	evtType := kvstore.Created
	var writeErr error
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		newObj, writeErr = apicl.MonitoringV1().TroubleshootingSession().Create(context.Background(), obj)
		if writeErr != nil && strings.Contains(err.Error(), "AlreadyExists") {
			newObj, writeErr = apicl.MonitoringV1().TroubleshootingSession().Update(context.Background(), obj)
			evtType = kvstore.Updated
		}
	}

	if writeErr == nil {
		api.ct.handleTroubleshootingSessionEvent(&kvstore.WatchEvent{Object: newObj, Type: evtType})
	}

	if writeErr == nil {
		api.ct.handleTroubleshootingSessionEvent(&kvstore.WatchEvent{Object: newObj, Type: evtType})
	}

	return writeErr
}

// Update triggers update on TroubleshootingSession object
func (api *troubleshootingsessionAPI) Update(obj *monitoring.TroubleshootingSession) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.MonitoringV1().TroubleshootingSession().Update(context.Background(), obj)
		return err
	}

	api.ct.handleTroubleshootingSessionEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Updated})
	return nil
}

// SyncUpdate triggers update on TroubleshootingSession object and updates the cache
func (api *troubleshootingsessionAPI) SyncUpdate(obj *monitoring.TroubleshootingSession) error {
	newObj := obj
	var writeErr error
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		newObj, writeErr = apicl.MonitoringV1().TroubleshootingSession().Update(context.Background(), obj)
	}

	if writeErr == nil {
		api.ct.handleTroubleshootingSessionEvent(&kvstore.WatchEvent{Object: newObj, Type: kvstore.Updated})
	}

	return writeErr
}

// Delete deletes TroubleshootingSession object
func (api *troubleshootingsessionAPI) Delete(obj *monitoring.TroubleshootingSession) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.MonitoringV1().TroubleshootingSession().Delete(context.Background(), &obj.ObjectMeta)
		return err
	}

	api.ct.handleTroubleshootingSessionEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Deleted})
	return nil
}

// MakeKey generates a KV store key for the object
func (api *troubleshootingsessionAPI) getFullKey(tenant, name string) string {
	if tenant != "" {
		return fmt.Sprint(globals.ConfigRootPrefix, "/", "monitoring", "/", "TroubleshootingSession", "/", tenant, "/", name)
	}
	return fmt.Sprint(globals.ConfigRootPrefix, "/", "monitoring", "/", "TroubleshootingSession", "/", name)
}

// Find returns an object by meta
func (api *troubleshootingsessionAPI) Find(meta *api.ObjectMeta) (*TroubleshootingSession, error) {
	// find the object
	obj, err := api.ct.FindObject("TroubleshootingSession", meta)
	if err != nil {
		return nil, err
	}

	// asset type
	switch obj.(type) {
	case *TroubleshootingSession:
		hobj := obj.(*TroubleshootingSession)
		return hobj, nil
	default:
		return nil, errors.New("incorrect object type")
	}
}

// List returns a list of all TroubleshootingSession objects
func (api *troubleshootingsessionAPI) List(ctx context.Context, opts *api.ListWatchOptions) ([]*TroubleshootingSession, error) {
	var objlist []*TroubleshootingSession
	objs, err := api.ct.List("TroubleshootingSession", ctx, opts)

	if err != nil {
		return nil, err
	}

	for _, obj := range objs {
		switch tp := obj.(type) {
		case *TroubleshootingSession:
			eobj := obj.(*TroubleshootingSession)
			objlist = append(objlist, eobj)
		default:
			log.Fatalf("Got invalid object type %v while looking for TroubleshootingSession", tp)
		}
	}

	return objlist, nil
}

// Watch sets up a event handlers for TroubleshootingSession object
func (api *troubleshootingsessionAPI) Watch(handler TroubleshootingSessionHandler) error {
	api.ct.startWorkerPool("TroubleshootingSession")
	return api.ct.WatchTroubleshootingSession(handler)
}

// StopWatch stop watch for Tenant TroubleshootingSession object
func (api *troubleshootingsessionAPI) StopWatch(handler TroubleshootingSessionHandler) error {
	api.ct.Lock()
	api.ct.workPools["TroubleshootingSession"].Stop()
	api.ct.Unlock()
	return api.ct.StopWatchTroubleshootingSession(handler)
}

// TroubleshootingSession returns TroubleshootingSessionAPI
func (ct *ctrlerCtx) TroubleshootingSession() TroubleshootingSessionAPI {
	return &troubleshootingsessionAPI{ct: ct}
}

// TechSupportRequest is a wrapper object that implements additional functionality
type TechSupportRequest struct {
	sync.Mutex
	monitoring.TechSupportRequest
	HandlerCtx interface{} // additional state handlers can store
	ctrler     *ctrlerCtx  // reference back to the controller instance
}

func (obj *TechSupportRequest) Write() error {
	// if there is no API server to connect to, we are done
	if (obj.ctrler == nil) || (obj.ctrler.resolver == nil) || obj.ctrler.apisrvURL == "" {
		return nil
	}

	apicl, err := obj.ctrler.apiClient()
	if err != nil {
		obj.ctrler.logger.Errorf("Error creating API server clent. Err: %v", err)
		return err
	}

	obj.ctrler.stats.Counter("TechSupportRequest_Writes").Inc()

	// write to api server
	if obj.ObjectMeta.ResourceVersion != "" {
		// update it
		for i := 0; i < maxApisrvWriteRetry; i++ {
			_, err = apicl.MonitoringV1().TechSupportRequest().UpdateStatus(context.Background(), &obj.TechSupportRequest)
			if err == nil {
				break
			}
			time.Sleep(time.Millisecond * 100)
		}
	} else {
		//  create
		_, err = apicl.MonitoringV1().TechSupportRequest().Create(context.Background(), &obj.TechSupportRequest)
	}

	return nil
}

// TechSupportRequestHandler is the event handler for TechSupportRequest object
type TechSupportRequestHandler interface {
	OnTechSupportRequestCreate(obj *TechSupportRequest) error
	OnTechSupportRequestUpdate(oldObj *TechSupportRequest, newObj *monitoring.TechSupportRequest) error
	OnTechSupportRequestDelete(obj *TechSupportRequest) error
	GetTechSupportRequestWatchOptions() *api.ListWatchOptions
}

// OnTechSupportRequestCreate is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnTechSupportRequestCreate(obj *TechSupportRequest) error {
	log.Info("OnTechSupportRequestCreate is not implemented")
	return nil
}

// OnTechSupportRequestUpdate is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnTechSupportRequestUpdate(oldObj *TechSupportRequest, newObj *monitoring.TechSupportRequest) error {
	log.Info("OnTechSupportRequestUpdate is not implemented")
	return nil
}

// OnTechSupportRequestDelete is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnTechSupportRequestDelete(obj *TechSupportRequest) error {
	log.Info("OnTechSupportRequestDelete is not implemented")
	return nil
}

// GetTechSupportRequestWatchOptions is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) GetTechSupportRequestWatchOptions() *api.ListWatchOptions {
	log.Info("GetTechSupportRequestWatchOptions is not implemented")
	opts := &api.ListWatchOptions{}
	return opts
}

// handleTechSupportRequestEvent handles TechSupportRequest events from watcher
func (ct *ctrlerCtx) handleTechSupportRequestEvent(evt *kvstore.WatchEvent) error {

	if ct.objResolver == nil {
		return ct.handleTechSupportRequestEventNoResolver(evt)
	}

	switch tp := evt.Object.(type) {
	case *monitoring.TechSupportRequest:
		eobj := evt.Object.(*monitoring.TechSupportRequest)
		kind := "TechSupportRequest"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ctx := &techsupportrequestCtx{event: evt.Type,
			obj: &TechSupportRequest{TechSupportRequest: *eobj, ctrler: ct}}

		var err error
		switch evt.Type {
		case kvstore.Created:
			err = ct.processAdd(ctx)
		case kvstore.Updated:
			err = ct.processUpdate(ctx)
		case kvstore.Deleted:
			err = ct.processDelete(ctx)
		}
		return err
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on TechSupportRequest watch channel", tp)
	}

	return nil
}

// handleTechSupportRequestEventNoResolver handles TechSupportRequest events from watcher
func (ct *ctrlerCtx) handleTechSupportRequestEventNoResolver(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *monitoring.TechSupportRequest:
		eobj := evt.Object.(*monitoring.TechSupportRequest)
		kind := "TechSupportRequest"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		techsupportrequestHandler := handler.(TechSupportRequestHandler)
		// handle based on event type
		ctrlCtx := &techsupportrequestCtx{event: evt.Type, obj: &TechSupportRequest{TechSupportRequest: *eobj, ctrler: ct}}
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			fobj, err := ct.getObject(kind, ctrlCtx.GetKey())
			if err != nil {
				ct.addObject(ctrlCtx)
				ct.stats.Counter("TechSupportRequest_Created_Events").Inc()

				// call the event handler
				ctrlCtx.Lock()
				err = techsupportrequestHandler.OnTechSupportRequestCreate(ctrlCtx.obj)
				ctrlCtx.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctrlCtx.obj, err)
					ct.delObject(kind, ctrlCtx.GetKey())
					return err
				}
			} else {
				if ct.resolver != nil && fobj.GetResourceVersion() >= eobj.GetResourceVersion() {
					// Event already processed.
					ct.logger.Infof("Skipping update due to old resource version")
					return nil
				}
				ctrlCtx := fobj.(*techsupportrequestCtx)
				ct.stats.Counter("TechSupportRequest_Updated_Events").Inc()
				ctrlCtx.Lock()
				p := monitoring.TechSupportRequest{Spec: eobj.Spec,
					ObjectMeta: eobj.ObjectMeta,
					TypeMeta:   eobj.TypeMeta,
					Status:     eobj.Status}

				err = techsupportrequestHandler.OnTechSupportRequestUpdate(ctrlCtx.obj, &p)
				ctrlCtx.obj.TechSupportRequest = *eobj
				ctrlCtx.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctrlCtx.obj, err)
					return err
				}

			}
		case kvstore.Deleted:
			ctrlCtx := &techsupportrequestCtx{event: evt.Type, obj: &TechSupportRequest{TechSupportRequest: *eobj, ctrler: ct}}
			fobj, err := ct.findObject(kind, ctrlCtx.GetKey())
			if err != nil {
				ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
				return err
			}

			obj := fobj.(*TechSupportRequest)
			ct.stats.Counter("TechSupportRequest_Deleted_Events").Inc()
			obj.Lock()
			err = techsupportrequestHandler.OnTechSupportRequestDelete(obj)
			obj.Unlock()
			if err != nil {
				ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
			}
			ct.delObject(kind, ctrlCtx.GetKey())
			return nil

		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on TechSupportRequest watch channel", tp)
	}

	return nil
}

type techsupportrequestCtx struct {
	ctkitBaseCtx
	event kvstore.WatchEventType
	obj   *TechSupportRequest //
	//   newObj     *monitoring.TechSupportRequest //update
	newObj *techsupportrequestCtx //update
}

func (ctx *techsupportrequestCtx) References() map[string]apiintf.ReferenceObj {
	resp := make(map[string]apiintf.ReferenceObj)
	ctx.obj.References(ctx.obj.GetObjectMeta().Name, ctx.obj.GetObjectMeta().Namespace, resp)
	return resp
}

func (ctx *techsupportrequestCtx) GetKey() string {
	return ctx.obj.MakeKey("monitoring")
}

func (ctx *techsupportrequestCtx) GetKind() string {
	return ctx.obj.GetKind()
}

func (ctx *techsupportrequestCtx) GetResourceVersion() string {
	return ctx.obj.GetResourceVersion()
}

func (ctx *techsupportrequestCtx) SetEvent(event kvstore.WatchEventType) {
	ctx.event = event
}

func (ctx *techsupportrequestCtx) SetNewObj(newObj apiintf.CtkitObject) {
	if newObj == nil {
		ctx.newObj = nil
	} else {
		ctx.newObj = newObj.(*techsupportrequestCtx)
		ctx.newObj.obj.HandlerCtx = ctx.obj.HandlerCtx
	}
}

func (ctx *techsupportrequestCtx) GetNewObj() apiintf.CtkitObject {
	return ctx.newObj
}

func (ctx *techsupportrequestCtx) Copy(obj apiintf.CtkitObject) {
	ctx.obj.TechSupportRequest = obj.(*techsupportrequestCtx).obj.TechSupportRequest
}

func (ctx *techsupportrequestCtx) Lock() {
	ctx.obj.Lock()
}

func (ctx *techsupportrequestCtx) Unlock() {
	ctx.obj.Unlock()
}

func (ctx *techsupportrequestCtx) GetObjectMeta() *api.ObjectMeta {
	return ctx.obj.GetObjectMeta()
}

func (ctx *techsupportrequestCtx) RuntimeObject() runtime.Object {
	var v interface{}
	v = ctx.obj
	return v.(runtime.Object)
}

func (ctx *techsupportrequestCtx) WorkFunc(context context.Context) error {
	var err error
	evt := ctx.event
	ct := ctx.obj.ctrler
	kind := "TechSupportRequest"
	ct.Lock()
	handler, ok := ct.handlers[kind]
	ct.Unlock()
	if !ok {
		ct.logger.Fatalf("Cant find the handler for %s", kind)
	}
	techsupportrequestHandler := handler.(TechSupportRequestHandler)
	switch evt {
	case kvstore.Created:
		ctx.obj.Lock()
		err = techsupportrequestHandler.OnTechSupportRequestCreate(ctx.obj)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctx.obj, err)
			ctx.SetEvent(kvstore.Deleted)
		}
	case kvstore.Updated:
		ct.stats.Counter("TechSupportRequest_Updated_Events").Inc()
		ctx.obj.Lock()
		p := monitoring.TechSupportRequest{Spec: ctx.newObj.obj.Spec,
			ObjectMeta: ctx.newObj.obj.ObjectMeta,
			TypeMeta:   ctx.newObj.obj.TypeMeta,
			Status:     ctx.newObj.obj.Status}
		err = techsupportrequestHandler.OnTechSupportRequestUpdate(ctx.obj, &p)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctx.obj, err)
			ctx.SetEvent(kvstore.Deleted)
		}
	case kvstore.Deleted:
		ctx.obj.Lock()
		err = techsupportrequestHandler.OnTechSupportRequestDelete(ctx.obj)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error deleting %s %+v. Err: %v", kind, ctx.obj, err)
		}
	}
	ct.resolveObject(ctx.event, ctx)
	return nil
}

// handleTechSupportRequestEventParallel handles TechSupportRequest events from watcher
func (ct *ctrlerCtx) handleTechSupportRequestEventParallel(evt *kvstore.WatchEvent) error {

	if ct.objResolver == nil {
		return ct.handleTechSupportRequestEventParallelWithNoResolver(evt)
	}

	switch tp := evt.Object.(type) {
	case *monitoring.TechSupportRequest:
		eobj := evt.Object.(*monitoring.TechSupportRequest)
		kind := "TechSupportRequest"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ctx := &techsupportrequestCtx{event: evt.Type, obj: &TechSupportRequest{TechSupportRequest: *eobj, ctrler: ct}}

		var err error
		switch evt.Type {
		case kvstore.Created:
			err = ct.processAdd(ctx)
		case kvstore.Updated:
			err = ct.processUpdate(ctx)
		case kvstore.Deleted:
			err = ct.processDelete(ctx)
		}
		return err
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on TechSupportRequest watch channel", tp)
	}

	return nil
}

// handleTechSupportRequestEventParallel handles TechSupportRequest events from watcher
func (ct *ctrlerCtx) handleTechSupportRequestEventParallelWithNoResolver(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *monitoring.TechSupportRequest:
		eobj := evt.Object.(*monitoring.TechSupportRequest)
		kind := "TechSupportRequest"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		techsupportrequestHandler := handler.(TechSupportRequestHandler)
		// handle based on event type
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			workFunc := func(ctx context.Context, ctrlCtx shardworkers.WorkObj) error {
				var err error
				workCtx := ctrlCtx.(*techsupportrequestCtx)
				eobj := workCtx.obj
				fobj, err := ct.getObject(kind, workCtx.GetKey())
				if err != nil {
					ct.addObject(workCtx)
					ct.stats.Counter("TechSupportRequest_Created_Events").Inc()
					eobj.Lock()
					err = techsupportrequestHandler.OnTechSupportRequestCreate(eobj)
					eobj.Unlock()
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, eobj, err)
						ct.delObject(kind, workCtx.GetKey())
					}
				} else {
					workCtx := fobj.(*techsupportrequestCtx)
					obj := workCtx.obj
					ct.stats.Counter("TechSupportRequest_Updated_Events").Inc()
					obj.Lock()
					p := monitoring.TechSupportRequest{Spec: eobj.Spec,
						ObjectMeta: eobj.ObjectMeta,
						TypeMeta:   eobj.TypeMeta,
						Status:     eobj.Status}

					err = techsupportrequestHandler.OnTechSupportRequestUpdate(obj, &p)
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					} else {
						workCtx.obj.TechSupportRequest = p
					}
					obj.Unlock()
				}
				return err
			}
			ctrlCtx := &techsupportrequestCtx{event: evt.Type, obj: &TechSupportRequest{TechSupportRequest: *eobj, ctrler: ct}}
			ct.runFunction("TechSupportRequest", ctrlCtx, workFunc)
		case kvstore.Deleted:
			workFunc := func(ctx context.Context, ctrlCtx shardworkers.WorkObj) error {
				var err error
				workCtx := ctrlCtx.(*techsupportrequestCtx)
				eobj := workCtx.obj
				fobj, err := ct.findObject(kind, workCtx.GetKey())
				if err != nil {
					ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
					return err
				}
				obj := fobj.(*TechSupportRequest)
				ct.stats.Counter("TechSupportRequest_Deleted_Events").Inc()
				obj.Lock()
				err = techsupportrequestHandler.OnTechSupportRequestDelete(obj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
				}
				ct.delObject(kind, workCtx.GetKey())
				return nil
			}
			ctrlCtx := &techsupportrequestCtx{event: evt.Type, obj: &TechSupportRequest{TechSupportRequest: *eobj, ctrler: ct}}
			ct.runFunction("TechSupportRequest", ctrlCtx, workFunc)
		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on TechSupportRequest watch channel", tp)
	}

	return nil
}

// diffTechSupportRequest does a diff of TechSupportRequest objects between local cache and API server
func (ct *ctrlerCtx) diffTechSupportRequest(apicl apiclient.Services) {
	opts := api.ListWatchOptions{}

	// get a list of all objects from API server
	objlist, err := apicl.MonitoringV1().TechSupportRequest().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Errorf("Error getting a list of objects. Err: %v", err)
		return
	}

	ct.logger.Infof("diffTechSupportRequest(): TechSupportRequestList returned %d objects", len(objlist))

	// build an object map
	objmap := make(map[string]*monitoring.TechSupportRequest)
	for _, obj := range objlist {
		objmap[obj.GetKey()] = obj
	}

	list, err := ct.TechSupportRequest().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Infof("Failed to get a list of objects. Err: %s", err)
		return
	}

	// if an object is in our local cache and not in API server, trigger delete for it
	for _, obj := range list {
		_, ok := objmap[obj.GetKey()]
		if !ok {
			ct.logger.Infof("diffTechSupportRequest(): Deleting existing object %#v since its not in apiserver", obj.GetKey())
			evt := kvstore.WatchEvent{
				Type:   kvstore.Deleted,
				Key:    obj.GetKey(),
				Object: &obj.TechSupportRequest,
			}
			ct.handleTechSupportRequestEvent(&evt)
		}
	}

	// trigger create event for all others
	for _, obj := range objlist {
		ct.logger.Infof("diffTechSupportRequest(): Adding object %#v", obj.GetKey())
		evt := kvstore.WatchEvent{
			Type:   kvstore.Created,
			Key:    obj.GetKey(),
			Object: obj,
		}
		ct.handleTechSupportRequestEvent(&evt)
	}
}

func (ct *ctrlerCtx) runTechSupportRequestWatcher() {
	kind := "TechSupportRequest"

	ct.Lock()
	handler, ok := ct.handlers[kind]
	ct.Unlock()
	if !ok {
		ct.logger.Fatalf("Cant find the handler for %s", kind)
	}
	techsupportrequestHandler := handler.(TechSupportRequestHandler)

	opts := techsupportrequestHandler.GetTechSupportRequestWatchOptions()

	// if there is no API server to connect to, we are done
	if (ct.resolver == nil) || ct.apisrvURL == "" {
		return
	}

	// create context
	ctx, cancel := context.WithCancel(context.Background())
	ct.Lock()
	ct.watchCancel[kind] = cancel
	ct.Unlock()
	logger := ct.logger.WithContext("submodule", "TechSupportRequestWatcher")

	// create a grpc client
	apiclt, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
	if err == nil {
		ct.diffTechSupportRequest(apiclt)
	}

	// setup wait group
	ct.waitGrp.Add(1)

	// start a goroutine
	go func() {
		defer ct.waitGrp.Done()
		ct.stats.Counter("TechSupportRequest_Watch").Inc()
		defer ct.stats.Counter("TechSupportRequest_Watch").Dec()

		// loop forever
		for {
			// create a grpc client
			apicl, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
			if err != nil {
				logger.Warnf("Failed to connect to gRPC server [%s]\n", ct.apisrvURL)
				ct.stats.Counter("TechSupportRequest_ApiClientErr").Inc()
			} else {
				logger.Infof("API client connected {%+v}", apicl)

				// TechSupportRequest object watcher
				wt, werr := apicl.MonitoringV1().TechSupportRequest().Watch(ctx, opts)
				if werr != nil {
					select {
					case <-ctx.Done():
						logger.Infof("watch %s cancelled", kind)
						return
					default:
					}
					logger.Errorf("Failed to start %s watch (%s)\n", kind, werr)
					// wait for a second and retry connecting to api server
					apicl.Close()
					time.Sleep(time.Second)
					continue
				}
				ct.Lock()
				ct.watchers[kind] = wt
				ct.Unlock()

				// perform a diff with API server and local cache
				time.Sleep(time.Millisecond * 100)
				ct.diffTechSupportRequest(apicl)

				// handle api server watch events
			innerLoop:
				for {
					// wait for events
					select {
					case evt, ok := <-wt.EventChan():
						if !ok {
							logger.Error("Error receiving from apisrv watcher")
							ct.stats.Counter("TechSupportRequest_WatchErrors").Inc()
							break innerLoop
						}

						// handle event in parallel
						ct.handleTechSupportRequestEventParallel(evt)
					}
				}
				apicl.Close()
			}

			// if stop flag is set, we are done
			if ct.stoped {
				logger.Infof("Exiting API server watcher")
				return
			}

			// wait for a second and retry connecting to api server
			time.Sleep(time.Second)
		}
	}()
}

// WatchTechSupportRequest starts watch on TechSupportRequest object
func (ct *ctrlerCtx) WatchTechSupportRequest(handler TechSupportRequestHandler) error {
	kind := "TechSupportRequest"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchers[kind]
	ct.Unlock()
	if ok {
		return fmt.Errorf("TechSupportRequest watcher already exists")
	}

	// save handler
	ct.Lock()
	ct.handlers[kind] = handler
	ct.Unlock()

	// run TechSupportRequest watcher in a go routine
	ct.runTechSupportRequestWatcher()

	return nil
}

// StopWatchTechSupportRequest stops watch on TechSupportRequest object
func (ct *ctrlerCtx) StopWatchTechSupportRequest(handler TechSupportRequestHandler) error {
	kind := "TechSupportRequest"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchers[kind]
	ct.Unlock()
	if !ok {
		return fmt.Errorf("TechSupportRequest watcher does not exist")
	}

	ct.Lock()
	cancel, _ := ct.watchCancel[kind]
	cancel()
	delete(ct.watchers, kind)
	delete(ct.watchCancel, kind)
	ct.Unlock()

	time.Sleep(100 * time.Millisecond)

	return nil
}

// TechSupportRequestAPI returns
type TechSupportRequestAPI interface {
	Create(obj *monitoring.TechSupportRequest) error
	SyncCreate(obj *monitoring.TechSupportRequest) error
	Update(obj *monitoring.TechSupportRequest) error
	SyncUpdate(obj *monitoring.TechSupportRequest) error
	Delete(obj *monitoring.TechSupportRequest) error
	Find(meta *api.ObjectMeta) (*TechSupportRequest, error)
	List(ctx context.Context, opts *api.ListWatchOptions) ([]*TechSupportRequest, error)
	Watch(handler TechSupportRequestHandler) error
	StopWatch(handler TechSupportRequestHandler) error
}

// dummy struct that implements TechSupportRequestAPI
type techsupportrequestAPI struct {
	ct *ctrlerCtx
}

// Create creates TechSupportRequest object
func (api *techsupportrequestAPI) Create(obj *monitoring.TechSupportRequest) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.MonitoringV1().TechSupportRequest().Create(context.Background(), obj)
		if err != nil && strings.Contains(err.Error(), "AlreadyExists") {
			_, err = apicl.MonitoringV1().TechSupportRequest().Update(context.Background(), obj)
		}
		return err
	}

	api.ct.handleTechSupportRequestEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Created})
	return nil
}

// SyncCreate creates TechSupportRequest object and updates the cache
func (api *techsupportrequestAPI) SyncCreate(obj *monitoring.TechSupportRequest) error {
	newObj := obj
	evtType := kvstore.Created
	var writeErr error
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		newObj, writeErr = apicl.MonitoringV1().TechSupportRequest().Create(context.Background(), obj)
		if writeErr != nil && strings.Contains(err.Error(), "AlreadyExists") {
			newObj, writeErr = apicl.MonitoringV1().TechSupportRequest().Update(context.Background(), obj)
			evtType = kvstore.Updated
		}
	}

	if writeErr == nil {
		api.ct.handleTechSupportRequestEvent(&kvstore.WatchEvent{Object: newObj, Type: evtType})
	}

	if writeErr == nil {
		api.ct.handleTechSupportRequestEvent(&kvstore.WatchEvent{Object: newObj, Type: evtType})
	}

	return writeErr
}

// Update triggers update on TechSupportRequest object
func (api *techsupportrequestAPI) Update(obj *monitoring.TechSupportRequest) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.MonitoringV1().TechSupportRequest().Update(context.Background(), obj)
		return err
	}

	api.ct.handleTechSupportRequestEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Updated})
	return nil
}

// SyncUpdate triggers update on TechSupportRequest object and updates the cache
func (api *techsupportrequestAPI) SyncUpdate(obj *monitoring.TechSupportRequest) error {
	newObj := obj
	var writeErr error
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		newObj, writeErr = apicl.MonitoringV1().TechSupportRequest().Update(context.Background(), obj)
	}

	if writeErr == nil {
		api.ct.handleTechSupportRequestEvent(&kvstore.WatchEvent{Object: newObj, Type: kvstore.Updated})
	}

	return writeErr
}

// Delete deletes TechSupportRequest object
func (api *techsupportrequestAPI) Delete(obj *monitoring.TechSupportRequest) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.MonitoringV1().TechSupportRequest().Delete(context.Background(), &obj.ObjectMeta)
		return err
	}

	api.ct.handleTechSupportRequestEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Deleted})
	return nil
}

// MakeKey generates a KV store key for the object
func (api *techsupportrequestAPI) getFullKey(tenant, name string) string {
	if tenant != "" {
		return fmt.Sprint(globals.ConfigRootPrefix, "/", "monitoring", "/", "techsupport", "/", tenant, "/", name)
	}
	return fmt.Sprint(globals.ConfigRootPrefix, "/", "monitoring", "/", "techsupport", "/", name)
}

// Find returns an object by meta
func (api *techsupportrequestAPI) Find(meta *api.ObjectMeta) (*TechSupportRequest, error) {
	// find the object
	obj, err := api.ct.FindObject("TechSupportRequest", meta)
	if err != nil {
		return nil, err
	}

	// asset type
	switch obj.(type) {
	case *TechSupportRequest:
		hobj := obj.(*TechSupportRequest)
		return hobj, nil
	default:
		return nil, errors.New("incorrect object type")
	}
}

// List returns a list of all TechSupportRequest objects
func (api *techsupportrequestAPI) List(ctx context.Context, opts *api.ListWatchOptions) ([]*TechSupportRequest, error) {
	var objlist []*TechSupportRequest
	objs, err := api.ct.List("TechSupportRequest", ctx, opts)

	if err != nil {
		return nil, err
	}

	for _, obj := range objs {
		switch tp := obj.(type) {
		case *TechSupportRequest:
			eobj := obj.(*TechSupportRequest)
			objlist = append(objlist, eobj)
		default:
			log.Fatalf("Got invalid object type %v while looking for TechSupportRequest", tp)
		}
	}

	return objlist, nil
}

// Watch sets up a event handlers for TechSupportRequest object
func (api *techsupportrequestAPI) Watch(handler TechSupportRequestHandler) error {
	api.ct.startWorkerPool("TechSupportRequest")
	return api.ct.WatchTechSupportRequest(handler)
}

// StopWatch stop watch for Tenant TechSupportRequest object
func (api *techsupportrequestAPI) StopWatch(handler TechSupportRequestHandler) error {
	api.ct.Lock()
	api.ct.workPools["TechSupportRequest"].Stop()
	api.ct.Unlock()
	return api.ct.StopWatchTechSupportRequest(handler)
}

// TechSupportRequest returns TechSupportRequestAPI
func (ct *ctrlerCtx) TechSupportRequest() TechSupportRequestAPI {
	return &techsupportrequestAPI{ct: ct}
}

// ArchiveRequest is a wrapper object that implements additional functionality
type ArchiveRequest struct {
	sync.Mutex
	monitoring.ArchiveRequest
	HandlerCtx interface{} // additional state handlers can store
	ctrler     *ctrlerCtx  // reference back to the controller instance
}

func (obj *ArchiveRequest) Write() error {
	// if there is no API server to connect to, we are done
	if (obj.ctrler == nil) || (obj.ctrler.resolver == nil) || obj.ctrler.apisrvURL == "" {
		return nil
	}

	apicl, err := obj.ctrler.apiClient()
	if err != nil {
		obj.ctrler.logger.Errorf("Error creating API server clent. Err: %v", err)
		return err
	}

	obj.ctrler.stats.Counter("ArchiveRequest_Writes").Inc()

	// write to api server
	if obj.ObjectMeta.ResourceVersion != "" {
		// update it
		for i := 0; i < maxApisrvWriteRetry; i++ {
			_, err = apicl.MonitoringV1().ArchiveRequest().UpdateStatus(context.Background(), &obj.ArchiveRequest)
			if err == nil {
				break
			}
			time.Sleep(time.Millisecond * 100)
		}
	} else {
		//  create
		_, err = apicl.MonitoringV1().ArchiveRequest().Create(context.Background(), &obj.ArchiveRequest)
	}

	return nil
}

// ArchiveRequestHandler is the event handler for ArchiveRequest object
type ArchiveRequestHandler interface {
	OnArchiveRequestCreate(obj *ArchiveRequest) error
	OnArchiveRequestUpdate(oldObj *ArchiveRequest, newObj *monitoring.ArchiveRequest) error
	OnArchiveRequestDelete(obj *ArchiveRequest) error
	GetArchiveRequestWatchOptions() *api.ListWatchOptions
}

// OnArchiveRequestCreate is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnArchiveRequestCreate(obj *ArchiveRequest) error {
	log.Info("OnArchiveRequestCreate is not implemented")
	return nil
}

// OnArchiveRequestUpdate is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnArchiveRequestUpdate(oldObj *ArchiveRequest, newObj *monitoring.ArchiveRequest) error {
	log.Info("OnArchiveRequestUpdate is not implemented")
	return nil
}

// OnArchiveRequestDelete is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnArchiveRequestDelete(obj *ArchiveRequest) error {
	log.Info("OnArchiveRequestDelete is not implemented")
	return nil
}

// GetArchiveRequestWatchOptions is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) GetArchiveRequestWatchOptions() *api.ListWatchOptions {
	log.Info("GetArchiveRequestWatchOptions is not implemented")
	opts := &api.ListWatchOptions{}
	return opts
}

// handleArchiveRequestEvent handles ArchiveRequest events from watcher
func (ct *ctrlerCtx) handleArchiveRequestEvent(evt *kvstore.WatchEvent) error {

	if ct.objResolver == nil {
		return ct.handleArchiveRequestEventNoResolver(evt)
	}

	switch tp := evt.Object.(type) {
	case *monitoring.ArchiveRequest:
		eobj := evt.Object.(*monitoring.ArchiveRequest)
		kind := "ArchiveRequest"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ctx := &archiverequestCtx{event: evt.Type,
			obj: &ArchiveRequest{ArchiveRequest: *eobj, ctrler: ct}}

		var err error
		switch evt.Type {
		case kvstore.Created:
			err = ct.processAdd(ctx)
		case kvstore.Updated:
			err = ct.processUpdate(ctx)
		case kvstore.Deleted:
			err = ct.processDelete(ctx)
		}
		return err
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on ArchiveRequest watch channel", tp)
	}

	return nil
}

// handleArchiveRequestEventNoResolver handles ArchiveRequest events from watcher
func (ct *ctrlerCtx) handleArchiveRequestEventNoResolver(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *monitoring.ArchiveRequest:
		eobj := evt.Object.(*monitoring.ArchiveRequest)
		kind := "ArchiveRequest"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		archiverequestHandler := handler.(ArchiveRequestHandler)
		// handle based on event type
		ctrlCtx := &archiverequestCtx{event: evt.Type, obj: &ArchiveRequest{ArchiveRequest: *eobj, ctrler: ct}}
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			fobj, err := ct.getObject(kind, ctrlCtx.GetKey())
			if err != nil {
				ct.addObject(ctrlCtx)
				ct.stats.Counter("ArchiveRequest_Created_Events").Inc()

				// call the event handler
				ctrlCtx.Lock()
				err = archiverequestHandler.OnArchiveRequestCreate(ctrlCtx.obj)
				ctrlCtx.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctrlCtx.obj, err)
					ct.delObject(kind, ctrlCtx.GetKey())
					return err
				}
			} else {
				if ct.resolver != nil && fobj.GetResourceVersion() >= eobj.GetResourceVersion() {
					// Event already processed.
					ct.logger.Infof("Skipping update due to old resource version")
					return nil
				}
				ctrlCtx := fobj.(*archiverequestCtx)
				ct.stats.Counter("ArchiveRequest_Updated_Events").Inc()
				ctrlCtx.Lock()
				p := monitoring.ArchiveRequest{Spec: eobj.Spec,
					ObjectMeta: eobj.ObjectMeta,
					TypeMeta:   eobj.TypeMeta,
					Status:     eobj.Status}

				err = archiverequestHandler.OnArchiveRequestUpdate(ctrlCtx.obj, &p)
				ctrlCtx.obj.ArchiveRequest = *eobj
				ctrlCtx.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctrlCtx.obj, err)
					return err
				}

			}
		case kvstore.Deleted:
			ctrlCtx := &archiverequestCtx{event: evt.Type, obj: &ArchiveRequest{ArchiveRequest: *eobj, ctrler: ct}}
			fobj, err := ct.findObject(kind, ctrlCtx.GetKey())
			if err != nil {
				ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
				return err
			}

			obj := fobj.(*ArchiveRequest)
			ct.stats.Counter("ArchiveRequest_Deleted_Events").Inc()
			obj.Lock()
			err = archiverequestHandler.OnArchiveRequestDelete(obj)
			obj.Unlock()
			if err != nil {
				ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
			}
			ct.delObject(kind, ctrlCtx.GetKey())
			return nil

		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on ArchiveRequest watch channel", tp)
	}

	return nil
}

type archiverequestCtx struct {
	ctkitBaseCtx
	event kvstore.WatchEventType
	obj   *ArchiveRequest //
	//   newObj     *monitoring.ArchiveRequest //update
	newObj *archiverequestCtx //update
}

func (ctx *archiverequestCtx) References() map[string]apiintf.ReferenceObj {
	resp := make(map[string]apiintf.ReferenceObj)
	ctx.obj.References(ctx.obj.GetObjectMeta().Name, ctx.obj.GetObjectMeta().Namespace, resp)
	return resp
}

func (ctx *archiverequestCtx) GetKey() string {
	return ctx.obj.MakeKey("monitoring")
}

func (ctx *archiverequestCtx) GetKind() string {
	return ctx.obj.GetKind()
}

func (ctx *archiverequestCtx) GetResourceVersion() string {
	return ctx.obj.GetResourceVersion()
}

func (ctx *archiverequestCtx) SetEvent(event kvstore.WatchEventType) {
	ctx.event = event
}

func (ctx *archiverequestCtx) SetNewObj(newObj apiintf.CtkitObject) {
	if newObj == nil {
		ctx.newObj = nil
	} else {
		ctx.newObj = newObj.(*archiverequestCtx)
		ctx.newObj.obj.HandlerCtx = ctx.obj.HandlerCtx
	}
}

func (ctx *archiverequestCtx) GetNewObj() apiintf.CtkitObject {
	return ctx.newObj
}

func (ctx *archiverequestCtx) Copy(obj apiintf.CtkitObject) {
	ctx.obj.ArchiveRequest = obj.(*archiverequestCtx).obj.ArchiveRequest
}

func (ctx *archiverequestCtx) Lock() {
	ctx.obj.Lock()
}

func (ctx *archiverequestCtx) Unlock() {
	ctx.obj.Unlock()
}

func (ctx *archiverequestCtx) GetObjectMeta() *api.ObjectMeta {
	return ctx.obj.GetObjectMeta()
}

func (ctx *archiverequestCtx) RuntimeObject() runtime.Object {
	var v interface{}
	v = ctx.obj
	return v.(runtime.Object)
}

func (ctx *archiverequestCtx) WorkFunc(context context.Context) error {
	var err error
	evt := ctx.event
	ct := ctx.obj.ctrler
	kind := "ArchiveRequest"
	ct.Lock()
	handler, ok := ct.handlers[kind]
	ct.Unlock()
	if !ok {
		ct.logger.Fatalf("Cant find the handler for %s", kind)
	}
	archiverequestHandler := handler.(ArchiveRequestHandler)
	switch evt {
	case kvstore.Created:
		ctx.obj.Lock()
		err = archiverequestHandler.OnArchiveRequestCreate(ctx.obj)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctx.obj, err)
			ctx.SetEvent(kvstore.Deleted)
		}
	case kvstore.Updated:
		ct.stats.Counter("ArchiveRequest_Updated_Events").Inc()
		ctx.obj.Lock()
		p := monitoring.ArchiveRequest{Spec: ctx.newObj.obj.Spec,
			ObjectMeta: ctx.newObj.obj.ObjectMeta,
			TypeMeta:   ctx.newObj.obj.TypeMeta,
			Status:     ctx.newObj.obj.Status}
		err = archiverequestHandler.OnArchiveRequestUpdate(ctx.obj, &p)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctx.obj, err)
			ctx.SetEvent(kvstore.Deleted)
		}
	case kvstore.Deleted:
		ctx.obj.Lock()
		err = archiverequestHandler.OnArchiveRequestDelete(ctx.obj)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error deleting %s %+v. Err: %v", kind, ctx.obj, err)
		}
	}
	ct.resolveObject(ctx.event, ctx)
	return nil
}

// handleArchiveRequestEventParallel handles ArchiveRequest events from watcher
func (ct *ctrlerCtx) handleArchiveRequestEventParallel(evt *kvstore.WatchEvent) error {

	if ct.objResolver == nil {
		return ct.handleArchiveRequestEventParallelWithNoResolver(evt)
	}

	switch tp := evt.Object.(type) {
	case *monitoring.ArchiveRequest:
		eobj := evt.Object.(*monitoring.ArchiveRequest)
		kind := "ArchiveRequest"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ctx := &archiverequestCtx{event: evt.Type, obj: &ArchiveRequest{ArchiveRequest: *eobj, ctrler: ct}}

		var err error
		switch evt.Type {
		case kvstore.Created:
			err = ct.processAdd(ctx)
		case kvstore.Updated:
			err = ct.processUpdate(ctx)
		case kvstore.Deleted:
			err = ct.processDelete(ctx)
		}
		return err
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on ArchiveRequest watch channel", tp)
	}

	return nil
}

// handleArchiveRequestEventParallel handles ArchiveRequest events from watcher
func (ct *ctrlerCtx) handleArchiveRequestEventParallelWithNoResolver(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *monitoring.ArchiveRequest:
		eobj := evt.Object.(*monitoring.ArchiveRequest)
		kind := "ArchiveRequest"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		archiverequestHandler := handler.(ArchiveRequestHandler)
		// handle based on event type
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			workFunc := func(ctx context.Context, ctrlCtx shardworkers.WorkObj) error {
				var err error
				workCtx := ctrlCtx.(*archiverequestCtx)
				eobj := workCtx.obj
				fobj, err := ct.getObject(kind, workCtx.GetKey())
				if err != nil {
					ct.addObject(workCtx)
					ct.stats.Counter("ArchiveRequest_Created_Events").Inc()
					eobj.Lock()
					err = archiverequestHandler.OnArchiveRequestCreate(eobj)
					eobj.Unlock()
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, eobj, err)
						ct.delObject(kind, workCtx.GetKey())
					}
				} else {
					workCtx := fobj.(*archiverequestCtx)
					obj := workCtx.obj
					ct.stats.Counter("ArchiveRequest_Updated_Events").Inc()
					obj.Lock()
					p := monitoring.ArchiveRequest{Spec: eobj.Spec,
						ObjectMeta: eobj.ObjectMeta,
						TypeMeta:   eobj.TypeMeta,
						Status:     eobj.Status}

					err = archiverequestHandler.OnArchiveRequestUpdate(obj, &p)
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					} else {
						workCtx.obj.ArchiveRequest = p
					}
					obj.Unlock()
				}
				return err
			}
			ctrlCtx := &archiverequestCtx{event: evt.Type, obj: &ArchiveRequest{ArchiveRequest: *eobj, ctrler: ct}}
			ct.runFunction("ArchiveRequest", ctrlCtx, workFunc)
		case kvstore.Deleted:
			workFunc := func(ctx context.Context, ctrlCtx shardworkers.WorkObj) error {
				var err error
				workCtx := ctrlCtx.(*archiverequestCtx)
				eobj := workCtx.obj
				fobj, err := ct.findObject(kind, workCtx.GetKey())
				if err != nil {
					ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
					return err
				}
				obj := fobj.(*ArchiveRequest)
				ct.stats.Counter("ArchiveRequest_Deleted_Events").Inc()
				obj.Lock()
				err = archiverequestHandler.OnArchiveRequestDelete(obj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
				}
				ct.delObject(kind, workCtx.GetKey())
				return nil
			}
			ctrlCtx := &archiverequestCtx{event: evt.Type, obj: &ArchiveRequest{ArchiveRequest: *eobj, ctrler: ct}}
			ct.runFunction("ArchiveRequest", ctrlCtx, workFunc)
		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on ArchiveRequest watch channel", tp)
	}

	return nil
}

// diffArchiveRequest does a diff of ArchiveRequest objects between local cache and API server
func (ct *ctrlerCtx) diffArchiveRequest(apicl apiclient.Services) {
	opts := api.ListWatchOptions{}

	// get a list of all objects from API server
	objlist, err := apicl.MonitoringV1().ArchiveRequest().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Errorf("Error getting a list of objects. Err: %v", err)
		return
	}

	ct.logger.Infof("diffArchiveRequest(): ArchiveRequestList returned %d objects", len(objlist))

	// build an object map
	objmap := make(map[string]*monitoring.ArchiveRequest)
	for _, obj := range objlist {
		objmap[obj.GetKey()] = obj
	}

	list, err := ct.ArchiveRequest().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Infof("Failed to get a list of objects. Err: %s", err)
		return
	}

	// if an object is in our local cache and not in API server, trigger delete for it
	for _, obj := range list {
		_, ok := objmap[obj.GetKey()]
		if !ok {
			ct.logger.Infof("diffArchiveRequest(): Deleting existing object %#v since its not in apiserver", obj.GetKey())
			evt := kvstore.WatchEvent{
				Type:   kvstore.Deleted,
				Key:    obj.GetKey(),
				Object: &obj.ArchiveRequest,
			}
			ct.handleArchiveRequestEvent(&evt)
		}
	}

	// trigger create event for all others
	for _, obj := range objlist {
		ct.logger.Infof("diffArchiveRequest(): Adding object %#v", obj.GetKey())
		evt := kvstore.WatchEvent{
			Type:   kvstore.Created,
			Key:    obj.GetKey(),
			Object: obj,
		}
		ct.handleArchiveRequestEvent(&evt)
	}
}

func (ct *ctrlerCtx) runArchiveRequestWatcher() {
	kind := "ArchiveRequest"

	ct.Lock()
	handler, ok := ct.handlers[kind]
	ct.Unlock()
	if !ok {
		ct.logger.Fatalf("Cant find the handler for %s", kind)
	}
	archiverequestHandler := handler.(ArchiveRequestHandler)

	opts := archiverequestHandler.GetArchiveRequestWatchOptions()

	// if there is no API server to connect to, we are done
	if (ct.resolver == nil) || ct.apisrvURL == "" {
		return
	}

	// create context
	ctx, cancel := context.WithCancel(context.Background())
	ct.Lock()
	ct.watchCancel[kind] = cancel
	ct.Unlock()
	logger := ct.logger.WithContext("submodule", "ArchiveRequestWatcher")

	// create a grpc client
	apiclt, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
	if err == nil {
		ct.diffArchiveRequest(apiclt)
	}

	// setup wait group
	ct.waitGrp.Add(1)

	// start a goroutine
	go func() {
		defer ct.waitGrp.Done()
		ct.stats.Counter("ArchiveRequest_Watch").Inc()
		defer ct.stats.Counter("ArchiveRequest_Watch").Dec()

		// loop forever
		for {
			// create a grpc client
			apicl, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
			if err != nil {
				logger.Warnf("Failed to connect to gRPC server [%s]\n", ct.apisrvURL)
				ct.stats.Counter("ArchiveRequest_ApiClientErr").Inc()
			} else {
				logger.Infof("API client connected {%+v}", apicl)

				// ArchiveRequest object watcher
				wt, werr := apicl.MonitoringV1().ArchiveRequest().Watch(ctx, opts)
				if werr != nil {
					select {
					case <-ctx.Done():
						logger.Infof("watch %s cancelled", kind)
						return
					default:
					}
					logger.Errorf("Failed to start %s watch (%s)\n", kind, werr)
					// wait for a second and retry connecting to api server
					apicl.Close()
					time.Sleep(time.Second)
					continue
				}
				ct.Lock()
				ct.watchers[kind] = wt
				ct.Unlock()

				// perform a diff with API server and local cache
				time.Sleep(time.Millisecond * 100)
				ct.diffArchiveRequest(apicl)

				// handle api server watch events
			innerLoop:
				for {
					// wait for events
					select {
					case evt, ok := <-wt.EventChan():
						if !ok {
							logger.Error("Error receiving from apisrv watcher")
							ct.stats.Counter("ArchiveRequest_WatchErrors").Inc()
							break innerLoop
						}

						// handle event in parallel
						ct.handleArchiveRequestEventParallel(evt)
					}
				}
				apicl.Close()
			}

			// if stop flag is set, we are done
			if ct.stoped {
				logger.Infof("Exiting API server watcher")
				return
			}

			// wait for a second and retry connecting to api server
			time.Sleep(time.Second)
		}
	}()
}

// WatchArchiveRequest starts watch on ArchiveRequest object
func (ct *ctrlerCtx) WatchArchiveRequest(handler ArchiveRequestHandler) error {
	kind := "ArchiveRequest"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchers[kind]
	ct.Unlock()
	if ok {
		return fmt.Errorf("ArchiveRequest watcher already exists")
	}

	// save handler
	ct.Lock()
	ct.handlers[kind] = handler
	ct.Unlock()

	// run ArchiveRequest watcher in a go routine
	ct.runArchiveRequestWatcher()

	return nil
}

// StopWatchArchiveRequest stops watch on ArchiveRequest object
func (ct *ctrlerCtx) StopWatchArchiveRequest(handler ArchiveRequestHandler) error {
	kind := "ArchiveRequest"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchers[kind]
	ct.Unlock()
	if !ok {
		return fmt.Errorf("ArchiveRequest watcher does not exist")
	}

	ct.Lock()
	cancel, _ := ct.watchCancel[kind]
	cancel()
	delete(ct.watchers, kind)
	delete(ct.watchCancel, kind)
	ct.Unlock()

	time.Sleep(100 * time.Millisecond)

	return nil
}

// ArchiveRequestAPI returns
type ArchiveRequestAPI interface {
	Create(obj *monitoring.ArchiveRequest) error
	SyncCreate(obj *monitoring.ArchiveRequest) error
	Update(obj *monitoring.ArchiveRequest) error
	SyncUpdate(obj *monitoring.ArchiveRequest) error
	Delete(obj *monitoring.ArchiveRequest) error
	Find(meta *api.ObjectMeta) (*ArchiveRequest, error)
	List(ctx context.Context, opts *api.ListWatchOptions) ([]*ArchiveRequest, error)
	Watch(handler ArchiveRequestHandler) error
	StopWatch(handler ArchiveRequestHandler) error
	Cancel(obj *monitoring.CancelArchiveRequest) (*monitoring.ArchiveRequest, error)
	SyncCancel(obj *monitoring.CancelArchiveRequest) (*monitoring.ArchiveRequest, error)
}

// dummy struct that implements ArchiveRequestAPI
type archiverequestAPI struct {
	ct *ctrlerCtx
}

// Create creates ArchiveRequest object
func (api *archiverequestAPI) Create(obj *monitoring.ArchiveRequest) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.MonitoringV1().ArchiveRequest().Create(context.Background(), obj)
		if err != nil && strings.Contains(err.Error(), "AlreadyExists") {
			_, err = apicl.MonitoringV1().ArchiveRequest().Update(context.Background(), obj)
		}
		return err
	}

	api.ct.handleArchiveRequestEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Created})
	return nil
}

// SyncCreate creates ArchiveRequest object and updates the cache
func (api *archiverequestAPI) SyncCreate(obj *monitoring.ArchiveRequest) error {
	newObj := obj
	evtType := kvstore.Created
	var writeErr error
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		newObj, writeErr = apicl.MonitoringV1().ArchiveRequest().Create(context.Background(), obj)
		if writeErr != nil && strings.Contains(err.Error(), "AlreadyExists") {
			newObj, writeErr = apicl.MonitoringV1().ArchiveRequest().Update(context.Background(), obj)
			evtType = kvstore.Updated
		}
	}

	if writeErr == nil {
		api.ct.handleArchiveRequestEvent(&kvstore.WatchEvent{Object: newObj, Type: evtType})
	}

	if writeErr == nil {
		api.ct.handleArchiveRequestEvent(&kvstore.WatchEvent{Object: newObj, Type: evtType})
	}

	return writeErr
}

// Update triggers update on ArchiveRequest object
func (api *archiverequestAPI) Update(obj *monitoring.ArchiveRequest) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.MonitoringV1().ArchiveRequest().Update(context.Background(), obj)
		return err
	}

	api.ct.handleArchiveRequestEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Updated})
	return nil
}

// SyncUpdate triggers update on ArchiveRequest object and updates the cache
func (api *archiverequestAPI) SyncUpdate(obj *monitoring.ArchiveRequest) error {
	newObj := obj
	var writeErr error
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		newObj, writeErr = apicl.MonitoringV1().ArchiveRequest().Update(context.Background(), obj)
	}

	if writeErr == nil {
		api.ct.handleArchiveRequestEvent(&kvstore.WatchEvent{Object: newObj, Type: kvstore.Updated})
	}

	return writeErr
}

// Delete deletes ArchiveRequest object
func (api *archiverequestAPI) Delete(obj *monitoring.ArchiveRequest) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.MonitoringV1().ArchiveRequest().Delete(context.Background(), &obj.ObjectMeta)
		return err
	}

	api.ct.handleArchiveRequestEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Deleted})
	return nil
}

// MakeKey generates a KV store key for the object
func (api *archiverequestAPI) getFullKey(tenant, name string) string {
	if tenant != "" {
		return fmt.Sprint(globals.ConfigRootPrefix, "/", "monitoring", "/", "archive-requests", "/", tenant, "/", name)
	}
	return fmt.Sprint(globals.ConfigRootPrefix, "/", "monitoring", "/", "archive-requests", "/", name)
}

// Find returns an object by meta
func (api *archiverequestAPI) Find(meta *api.ObjectMeta) (*ArchiveRequest, error) {
	// find the object
	obj, err := api.ct.FindObject("ArchiveRequest", meta)
	if err != nil {
		return nil, err
	}

	// asset type
	switch obj.(type) {
	case *ArchiveRequest:
		hobj := obj.(*ArchiveRequest)
		return hobj, nil
	default:
		return nil, errors.New("incorrect object type")
	}
}

// List returns a list of all ArchiveRequest objects
func (api *archiverequestAPI) List(ctx context.Context, opts *api.ListWatchOptions) ([]*ArchiveRequest, error) {
	var objlist []*ArchiveRequest
	objs, err := api.ct.List("ArchiveRequest", ctx, opts)

	if err != nil {
		return nil, err
	}

	for _, obj := range objs {
		switch tp := obj.(type) {
		case *ArchiveRequest:
			eobj := obj.(*ArchiveRequest)
			objlist = append(objlist, eobj)
		default:
			log.Fatalf("Got invalid object type %v while looking for ArchiveRequest", tp)
		}
	}

	return objlist, nil
}

// Watch sets up a event handlers for ArchiveRequest object
func (api *archiverequestAPI) Watch(handler ArchiveRequestHandler) error {
	api.ct.startWorkerPool("ArchiveRequest")
	return api.ct.WatchArchiveRequest(handler)
}

// StopWatch stop watch for Tenant ArchiveRequest object
func (api *archiverequestAPI) StopWatch(handler ArchiveRequestHandler) error {
	api.ct.Lock()
	api.ct.workPools["ArchiveRequest"].Stop()
	api.ct.Unlock()
	return api.ct.StopWatchArchiveRequest(handler)
}

// Cancel is an API action
func (api *archiverequestAPI) Cancel(obj *monitoring.CancelArchiveRequest) (*monitoring.ArchiveRequest, error) {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return nil, err
		}

		return apicl.MonitoringV1().ArchiveRequest().Cancel(context.Background(), obj)
	}
	return nil, fmt.Errorf("Action not implemented for local operation")
}

// SyncCancel is an API action. Cache will be updated
func (api *archiverequestAPI) SyncCancel(obj *monitoring.CancelArchiveRequest) (*monitoring.ArchiveRequest, error) {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return nil, err
		}

		ret, err := apicl.MonitoringV1().ArchiveRequest().Cancel(context.Background(), obj)
		if err != nil {
			return ret, err
		}
		// Perform Get to update the cache
		newObj, err := apicl.MonitoringV1().ArchiveRequest().Get(context.Background(), obj.GetObjectMeta())
		if err == nil {
			api.ct.handleArchiveRequestEvent(&kvstore.WatchEvent{Object: newObj, Type: kvstore.Updated})
		}
		return ret, err
	}
	return nil, fmt.Errorf("Action not implemented for local operation")
}

// ArchiveRequest returns ArchiveRequestAPI
func (ct *ctrlerCtx) ArchiveRequest() ArchiveRequestAPI {
	return &archiverequestAPI{ct: ct}
}
