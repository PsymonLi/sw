// Code generated by protoc-gen-grpc-pensando DO NOT EDIT.

/*
Package ctkit is a auto generated package.
Input file: svc_monitoring.proto
*/
package ctkit

import (
	"context"
	"fmt"
	"sync"
	"time"

	"github.com/pensando/sw/api"
	"github.com/pensando/sw/api/generated/apiclient"
	"github.com/pensando/sw/api/generated/monitoring"
	"github.com/pensando/sw/venice/utils/kvstore"
	"github.com/pensando/sw/venice/utils/log"
	"github.com/pensando/sw/venice/utils/ref"
	"github.com/pensando/sw/venice/utils/rpckit"
)

// EventPolicy is a wrapper object that implements additional functionality
type EventPolicy struct {
	sync.Mutex
	monitoring.EventPolicy
	HandlerCtx interface{} // additional state handlers can store
	ctrler     *ctrlerCtx  // reference back to the controller instance
}

func (obj *EventPolicy) Write() error {
	// if there is no API server to connect to, we are done
	if (obj.ctrler == nil) || (obj.ctrler.resolver == nil) || obj.ctrler.apisrvURL == "" {
		return nil
	}

	apicl, err := obj.ctrler.apiClient()
	if err != nil {
		log.Errorf("Error creating API server clent. Err: %v", err)
		return err
	}

	// write to api server
	if obj.ObjectMeta.ResourceVersion != "" {
		nobj := *obj
		// FIXME: clear the resource version till we figure out CAS semantics
		nobj.ObjectMeta.ResourceVersion = ""

		// update it
		_, err = apicl.MonitoringV1().EventPolicy().Update(context.Background(), &nobj.EventPolicy)
	} else {
		//  create
		_, err = apicl.MonitoringV1().EventPolicy().Create(context.Background(), &obj.EventPolicy)
	}

	return nil
}

// EventPolicyHandler is the event handler for EventPolicy object
type EventPolicyHandler interface {
	OnEventPolicyCreate(obj *EventPolicy) error
	OnEventPolicyUpdate(obj *EventPolicy) error
	OnEventPolicyDelete(obj *EventPolicy) error
}

// handleEventPolicyEvent handles EventPolicy events from watcher
func (ct *ctrlerCtx) handleEventPolicyEvent(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *monitoring.EventPolicy:
		eobj := evt.Object.(*monitoring.EventPolicy)
		kind := "EventPolicy"

		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		handler, ok := ct.handlers[kind]
		if !ok {
			log.Fatalf("Cant find the handler for %s", kind)
		}
		eventpolicyHandler := handler.(EventPolicyHandler)
		// handle based on event type
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			fobj, err := ct.findObject(kind, eobj.GetKey())
			if err != nil {
				obj := &EventPolicy{
					EventPolicy: *eobj,
					HandlerCtx:  nil,
					ctrler:      ct,
				}
				ct.addObject(kind, obj.GetKey(), obj)
				// call the event handler
				obj.Lock()
				err = eventpolicyHandler.OnEventPolicyCreate(obj)
				obj.Unlock()
				if err != nil {
					log.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					ct.delObject(kind, eobj.GetKey())
					return err
				}
			} else {
				obj := fobj.(*EventPolicy)
				obj.ObjectMeta = eobj.ObjectMeta

				// see if it changed
				if _, ok := ref.ObjDiff(obj.Spec, eobj.Spec); ok {
					obj.Spec = eobj.Spec
					// call the event handler
					obj.Lock()
					err = eventpolicyHandler.OnEventPolicyUpdate(obj)
					obj.Unlock()
					if err != nil {
						log.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
						return err
					}
				}
			}
		case kvstore.Deleted:
			fobj, err := ct.findObject(kind, eobj.GetKey())
			if err != nil {
				log.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
				return err
			}

			obj := fobj.(*EventPolicy)

			// Call the event reactor
			obj.Lock()
			err = eventpolicyHandler.OnEventPolicyDelete(obj)
			obj.Unlock()
			if err != nil {
				log.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
				return err
			}

			ct.delObject(kind, eobj.GetKey())
		}
	default:
		log.Fatalf("API watcher Found object of invalid type: %v on EventPolicy watch channel", tp)
	}

	return nil
}

// diffEventPolicy does a diff of EventPolicy objects between local cache and API server
func (ct *ctrlerCtx) diffEventPolicy(apicl apiclient.Services) {
	opts := api.ListWatchOptions{}

	// get a list of all objects from API server
	objlist, err := apicl.MonitoringV1().EventPolicy().List(context.Background(), &opts)
	if err != nil {
		log.Errorf("Error getting a list of objects. Err: %v", err)
		return
	}

	// build an object map
	objmap := make(map[string]*monitoring.EventPolicy)
	for _, obj := range objlist {
		objmap[obj.GetKey()] = obj
	}

	// if an object is in our local cache and not in API server, trigger delete for it
	for _, obj := range ct.EventPolicy().List() {
		_, ok := objmap[obj.GetKey()]
		if !ok {
			evt := kvstore.WatchEvent{
				Type:   kvstore.Deleted,
				Key:    obj.GetKey(),
				Object: &obj.EventPolicy,
			}
			ct.handleEventPolicyEvent(&evt)
		}
	}

	// trigger create event for all others
	for _, obj := range objlist {
		evt := kvstore.WatchEvent{
			Type:   kvstore.Created,
			Key:    obj.GetKey(),
			Object: obj,
		}
		ct.handleEventPolicyEvent(&evt)
	}
}

func (ct *ctrlerCtx) runEventPolicyWatcher() {
	kind := "EventPolicy"

	// if there is no API server to connect to, we are done
	if (ct.resolver == nil) || ct.apisrvURL == "" {
		return
	}

	// create context
	ctx, cancel := context.WithCancel(context.Background())
	ct.Lock()
	ct.watchCancel[kind] = cancel
	ct.Unlock()
	opts := api.ListWatchOptions{}

	// setup wait group
	ct.waitGrp.Add(1)
	defer ct.waitGrp.Done()

	// loop forever
	for {
		// create a grpc client
		apicl, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, ct.logger, rpckit.WithBalancer(ct.balancer))
		if err != nil {
			log.Warnf("Failed to connect to gRPC server [%s]\n", ct.apisrvURL)
		} else {
			log.Infof("API client connected {%+v}", apicl)

			// EventPolicy object watcher
			wt, werr := apicl.MonitoringV1().EventPolicy().Watch(ctx, &opts)
			if werr != nil {
				log.Errorf("Failed to start %s watch (%s)\n", kind, werr)
				return
			}
			ct.Lock()
			ct.watchers[kind] = wt
			ct.Unlock()

			// perform a diff with API server and local cache
			time.Sleep(time.Millisecond * 100)
			ct.diffEventPolicy(apicl)

			// handle api server watch events
		innerLoop:
			for {
				// wait for events
				select {
				case evt, ok := <-wt.EventChan():
					if !ok {
						log.Error("Error receiving from apisrv watcher")
						break innerLoop
					}

					// handle event
					ct.handleEventPolicyEvent(evt)
				}
			}
			apicl.Close()
		}

		// if stop flag is set, we are done
		if ct.stoped {
			log.Infof("Exiting API server watcher")
			return
		}

		// wait for a second and retry connecting to api server
		time.Sleep(time.Second)
	}
}

// WatchEventPolicy starts watch on EventPolicy object
func (ct *ctrlerCtx) WatchEventPolicy(handler EventPolicyHandler) error {
	kind := "EventPolicy"

	ct.Lock()
	defer ct.Unlock()

	// see if we already have a watcher
	_, ok := ct.watchers[kind]
	if ok {
		return fmt.Errorf("EventPolicy watcher already exists")
	}

	// save handler
	ct.handlers[kind] = handler

	// run EventPolicy watcher in a go routine
	go ct.runEventPolicyWatcher()

	return nil
}

// EventPolicyAPI returns
type EventPolicyAPI interface {
	Create(obj *monitoring.EventPolicy) error
	Update(obj *monitoring.EventPolicy) error
	Delete(obj *monitoring.EventPolicy) error
	List() []*EventPolicy
	Watch(handler EventPolicyHandler) error
}

// dummy struct that implements EventPolicyAPI
type eventpolicyAPI struct {
	ct *ctrlerCtx
}

// Create creates EventPolicy object
func (api *eventpolicyAPI) Create(obj *monitoring.EventPolicy) error {
	return api.ct.handleEventPolicyEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Created})
}

// Update triggers update on EventPolicy object
func (api *eventpolicyAPI) Update(obj *monitoring.EventPolicy) error {
	return api.ct.handleEventPolicyEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Updated})
}

// Delete deletes EventPolicy object
func (api *eventpolicyAPI) Delete(obj *monitoring.EventPolicy) error {
	return api.ct.handleEventPolicyEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Deleted})
}

// List returns a list of all EventPolicy objects
func (api *eventpolicyAPI) List() []*EventPolicy {
	var objlist []*EventPolicy

	objs := api.ct.ListObjects("EventPolicy")
	for _, obj := range objs {
		switch tp := obj.(type) {
		case *EventPolicy:
			eobj := obj.(*EventPolicy)
			objlist = append(objlist, eobj)
		default:
			log.Fatalf("Got invalid object type %v while looking for EventPolicy", tp)
		}
	}

	return objlist
}

// Watch sets up a event handlers for EventPolicy object
func (api *eventpolicyAPI) Watch(handler EventPolicyHandler) error {
	return api.ct.WatchEventPolicy(handler)
}

// EventPolicy returns EventPolicyAPI
func (ct *ctrlerCtx) EventPolicy() EventPolicyAPI {
	return &eventpolicyAPI{ct: ct}
}

// StatsPolicy is a wrapper object that implements additional functionality
type StatsPolicy struct {
	sync.Mutex
	monitoring.StatsPolicy
	HandlerCtx interface{} // additional state handlers can store
	ctrler     *ctrlerCtx  // reference back to the controller instance
}

func (obj *StatsPolicy) Write() error {
	// if there is no API server to connect to, we are done
	if (obj.ctrler == nil) || (obj.ctrler.resolver == nil) || obj.ctrler.apisrvURL == "" {
		return nil
	}

	apicl, err := obj.ctrler.apiClient()
	if err != nil {
		log.Errorf("Error creating API server clent. Err: %v", err)
		return err
	}

	// write to api server
	if obj.ObjectMeta.ResourceVersion != "" {
		nobj := *obj
		// FIXME: clear the resource version till we figure out CAS semantics
		nobj.ObjectMeta.ResourceVersion = ""

		// update it
		_, err = apicl.MonitoringV1().StatsPolicy().Update(context.Background(), &nobj.StatsPolicy)
	} else {
		//  create
		_, err = apicl.MonitoringV1().StatsPolicy().Create(context.Background(), &obj.StatsPolicy)
	}

	return nil
}

// StatsPolicyHandler is the event handler for StatsPolicy object
type StatsPolicyHandler interface {
	OnStatsPolicyCreate(obj *StatsPolicy) error
	OnStatsPolicyUpdate(obj *StatsPolicy) error
	OnStatsPolicyDelete(obj *StatsPolicy) error
}

// handleStatsPolicyEvent handles StatsPolicy events from watcher
func (ct *ctrlerCtx) handleStatsPolicyEvent(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *monitoring.StatsPolicy:
		eobj := evt.Object.(*monitoring.StatsPolicy)
		kind := "StatsPolicy"

		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		handler, ok := ct.handlers[kind]
		if !ok {
			log.Fatalf("Cant find the handler for %s", kind)
		}
		statspolicyHandler := handler.(StatsPolicyHandler)
		// handle based on event type
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			fobj, err := ct.findObject(kind, eobj.GetKey())
			if err != nil {
				obj := &StatsPolicy{
					StatsPolicy: *eobj,
					HandlerCtx:  nil,
					ctrler:      ct,
				}
				ct.addObject(kind, obj.GetKey(), obj)
				// call the event handler
				obj.Lock()
				err = statspolicyHandler.OnStatsPolicyCreate(obj)
				obj.Unlock()
				if err != nil {
					log.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					ct.delObject(kind, eobj.GetKey())
					return err
				}
			} else {
				obj := fobj.(*StatsPolicy)
				obj.ObjectMeta = eobj.ObjectMeta

				// see if it changed
				if _, ok := ref.ObjDiff(obj.Spec, eobj.Spec); ok {
					obj.Spec = eobj.Spec
					// call the event handler
					obj.Lock()
					err = statspolicyHandler.OnStatsPolicyUpdate(obj)
					obj.Unlock()
					if err != nil {
						log.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
						return err
					}
				}
			}
		case kvstore.Deleted:
			fobj, err := ct.findObject(kind, eobj.GetKey())
			if err != nil {
				log.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
				return err
			}

			obj := fobj.(*StatsPolicy)

			// Call the event reactor
			obj.Lock()
			err = statspolicyHandler.OnStatsPolicyDelete(obj)
			obj.Unlock()
			if err != nil {
				log.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
				return err
			}

			ct.delObject(kind, eobj.GetKey())
		}
	default:
		log.Fatalf("API watcher Found object of invalid type: %v on StatsPolicy watch channel", tp)
	}

	return nil
}

// diffStatsPolicy does a diff of StatsPolicy objects between local cache and API server
func (ct *ctrlerCtx) diffStatsPolicy(apicl apiclient.Services) {
	opts := api.ListWatchOptions{}

	// get a list of all objects from API server
	objlist, err := apicl.MonitoringV1().StatsPolicy().List(context.Background(), &opts)
	if err != nil {
		log.Errorf("Error getting a list of objects. Err: %v", err)
		return
	}

	// build an object map
	objmap := make(map[string]*monitoring.StatsPolicy)
	for _, obj := range objlist {
		objmap[obj.GetKey()] = obj
	}

	// if an object is in our local cache and not in API server, trigger delete for it
	for _, obj := range ct.StatsPolicy().List() {
		_, ok := objmap[obj.GetKey()]
		if !ok {
			evt := kvstore.WatchEvent{
				Type:   kvstore.Deleted,
				Key:    obj.GetKey(),
				Object: &obj.StatsPolicy,
			}
			ct.handleStatsPolicyEvent(&evt)
		}
	}

	// trigger create event for all others
	for _, obj := range objlist {
		evt := kvstore.WatchEvent{
			Type:   kvstore.Created,
			Key:    obj.GetKey(),
			Object: obj,
		}
		ct.handleStatsPolicyEvent(&evt)
	}
}

func (ct *ctrlerCtx) runStatsPolicyWatcher() {
	kind := "StatsPolicy"

	// if there is no API server to connect to, we are done
	if (ct.resolver == nil) || ct.apisrvURL == "" {
		return
	}

	// create context
	ctx, cancel := context.WithCancel(context.Background())
	ct.Lock()
	ct.watchCancel[kind] = cancel
	ct.Unlock()
	opts := api.ListWatchOptions{}

	// setup wait group
	ct.waitGrp.Add(1)
	defer ct.waitGrp.Done()

	// loop forever
	for {
		// create a grpc client
		apicl, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, ct.logger, rpckit.WithBalancer(ct.balancer))
		if err != nil {
			log.Warnf("Failed to connect to gRPC server [%s]\n", ct.apisrvURL)
		} else {
			log.Infof("API client connected {%+v}", apicl)

			// StatsPolicy object watcher
			wt, werr := apicl.MonitoringV1().StatsPolicy().Watch(ctx, &opts)
			if werr != nil {
				log.Errorf("Failed to start %s watch (%s)\n", kind, werr)
				return
			}
			ct.Lock()
			ct.watchers[kind] = wt
			ct.Unlock()

			// perform a diff with API server and local cache
			time.Sleep(time.Millisecond * 100)
			ct.diffStatsPolicy(apicl)

			// handle api server watch events
		innerLoop:
			for {
				// wait for events
				select {
				case evt, ok := <-wt.EventChan():
					if !ok {
						log.Error("Error receiving from apisrv watcher")
						break innerLoop
					}

					// handle event
					ct.handleStatsPolicyEvent(evt)
				}
			}
			apicl.Close()
		}

		// if stop flag is set, we are done
		if ct.stoped {
			log.Infof("Exiting API server watcher")
			return
		}

		// wait for a second and retry connecting to api server
		time.Sleep(time.Second)
	}
}

// WatchStatsPolicy starts watch on StatsPolicy object
func (ct *ctrlerCtx) WatchStatsPolicy(handler StatsPolicyHandler) error {
	kind := "StatsPolicy"

	ct.Lock()
	defer ct.Unlock()

	// see if we already have a watcher
	_, ok := ct.watchers[kind]
	if ok {
		return fmt.Errorf("StatsPolicy watcher already exists")
	}

	// save handler
	ct.handlers[kind] = handler

	// run StatsPolicy watcher in a go routine
	go ct.runStatsPolicyWatcher()

	return nil
}

// StatsPolicyAPI returns
type StatsPolicyAPI interface {
	Create(obj *monitoring.StatsPolicy) error
	Update(obj *monitoring.StatsPolicy) error
	Delete(obj *monitoring.StatsPolicy) error
	List() []*StatsPolicy
	Watch(handler StatsPolicyHandler) error
}

// dummy struct that implements StatsPolicyAPI
type statspolicyAPI struct {
	ct *ctrlerCtx
}

// Create creates StatsPolicy object
func (api *statspolicyAPI) Create(obj *monitoring.StatsPolicy) error {
	return api.ct.handleStatsPolicyEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Created})
}

// Update triggers update on StatsPolicy object
func (api *statspolicyAPI) Update(obj *monitoring.StatsPolicy) error {
	return api.ct.handleStatsPolicyEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Updated})
}

// Delete deletes StatsPolicy object
func (api *statspolicyAPI) Delete(obj *monitoring.StatsPolicy) error {
	return api.ct.handleStatsPolicyEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Deleted})
}

// List returns a list of all StatsPolicy objects
func (api *statspolicyAPI) List() []*StatsPolicy {
	var objlist []*StatsPolicy

	objs := api.ct.ListObjects("StatsPolicy")
	for _, obj := range objs {
		switch tp := obj.(type) {
		case *StatsPolicy:
			eobj := obj.(*StatsPolicy)
			objlist = append(objlist, eobj)
		default:
			log.Fatalf("Got invalid object type %v while looking for StatsPolicy", tp)
		}
	}

	return objlist
}

// Watch sets up a event handlers for StatsPolicy object
func (api *statspolicyAPI) Watch(handler StatsPolicyHandler) error {
	return api.ct.WatchStatsPolicy(handler)
}

// StatsPolicy returns StatsPolicyAPI
func (ct *ctrlerCtx) StatsPolicy() StatsPolicyAPI {
	return &statspolicyAPI{ct: ct}
}

// FwlogPolicy is a wrapper object that implements additional functionality
type FwlogPolicy struct {
	sync.Mutex
	monitoring.FwlogPolicy
	HandlerCtx interface{} // additional state handlers can store
	ctrler     *ctrlerCtx  // reference back to the controller instance
}

func (obj *FwlogPolicy) Write() error {
	// if there is no API server to connect to, we are done
	if (obj.ctrler == nil) || (obj.ctrler.resolver == nil) || obj.ctrler.apisrvURL == "" {
		return nil
	}

	apicl, err := obj.ctrler.apiClient()
	if err != nil {
		log.Errorf("Error creating API server clent. Err: %v", err)
		return err
	}

	// write to api server
	if obj.ObjectMeta.ResourceVersion != "" {
		nobj := *obj
		// FIXME: clear the resource version till we figure out CAS semantics
		nobj.ObjectMeta.ResourceVersion = ""

		// update it
		_, err = apicl.MonitoringV1().FwlogPolicy().Update(context.Background(), &nobj.FwlogPolicy)
	} else {
		//  create
		_, err = apicl.MonitoringV1().FwlogPolicy().Create(context.Background(), &obj.FwlogPolicy)
	}

	return nil
}

// FwlogPolicyHandler is the event handler for FwlogPolicy object
type FwlogPolicyHandler interface {
	OnFwlogPolicyCreate(obj *FwlogPolicy) error
	OnFwlogPolicyUpdate(obj *FwlogPolicy) error
	OnFwlogPolicyDelete(obj *FwlogPolicy) error
}

// handleFwlogPolicyEvent handles FwlogPolicy events from watcher
func (ct *ctrlerCtx) handleFwlogPolicyEvent(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *monitoring.FwlogPolicy:
		eobj := evt.Object.(*monitoring.FwlogPolicy)
		kind := "FwlogPolicy"

		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		handler, ok := ct.handlers[kind]
		if !ok {
			log.Fatalf("Cant find the handler for %s", kind)
		}
		fwlogpolicyHandler := handler.(FwlogPolicyHandler)
		// handle based on event type
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			fobj, err := ct.findObject(kind, eobj.GetKey())
			if err != nil {
				obj := &FwlogPolicy{
					FwlogPolicy: *eobj,
					HandlerCtx:  nil,
					ctrler:      ct,
				}
				ct.addObject(kind, obj.GetKey(), obj)
				// call the event handler
				obj.Lock()
				err = fwlogpolicyHandler.OnFwlogPolicyCreate(obj)
				obj.Unlock()
				if err != nil {
					log.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					ct.delObject(kind, eobj.GetKey())
					return err
				}
			} else {
				obj := fobj.(*FwlogPolicy)
				obj.ObjectMeta = eobj.ObjectMeta

				// see if it changed
				if _, ok := ref.ObjDiff(obj.Spec, eobj.Spec); ok {
					obj.Spec = eobj.Spec
					// call the event handler
					obj.Lock()
					err = fwlogpolicyHandler.OnFwlogPolicyUpdate(obj)
					obj.Unlock()
					if err != nil {
						log.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
						return err
					}
				}
			}
		case kvstore.Deleted:
			fobj, err := ct.findObject(kind, eobj.GetKey())
			if err != nil {
				log.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
				return err
			}

			obj := fobj.(*FwlogPolicy)

			// Call the event reactor
			obj.Lock()
			err = fwlogpolicyHandler.OnFwlogPolicyDelete(obj)
			obj.Unlock()
			if err != nil {
				log.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
				return err
			}

			ct.delObject(kind, eobj.GetKey())
		}
	default:
		log.Fatalf("API watcher Found object of invalid type: %v on FwlogPolicy watch channel", tp)
	}

	return nil
}

// diffFwlogPolicy does a diff of FwlogPolicy objects between local cache and API server
func (ct *ctrlerCtx) diffFwlogPolicy(apicl apiclient.Services) {
	opts := api.ListWatchOptions{}

	// get a list of all objects from API server
	objlist, err := apicl.MonitoringV1().FwlogPolicy().List(context.Background(), &opts)
	if err != nil {
		log.Errorf("Error getting a list of objects. Err: %v", err)
		return
	}

	// build an object map
	objmap := make(map[string]*monitoring.FwlogPolicy)
	for _, obj := range objlist {
		objmap[obj.GetKey()] = obj
	}

	// if an object is in our local cache and not in API server, trigger delete for it
	for _, obj := range ct.FwlogPolicy().List() {
		_, ok := objmap[obj.GetKey()]
		if !ok {
			evt := kvstore.WatchEvent{
				Type:   kvstore.Deleted,
				Key:    obj.GetKey(),
				Object: &obj.FwlogPolicy,
			}
			ct.handleFwlogPolicyEvent(&evt)
		}
	}

	// trigger create event for all others
	for _, obj := range objlist {
		evt := kvstore.WatchEvent{
			Type:   kvstore.Created,
			Key:    obj.GetKey(),
			Object: obj,
		}
		ct.handleFwlogPolicyEvent(&evt)
	}
}

func (ct *ctrlerCtx) runFwlogPolicyWatcher() {
	kind := "FwlogPolicy"

	// if there is no API server to connect to, we are done
	if (ct.resolver == nil) || ct.apisrvURL == "" {
		return
	}

	// create context
	ctx, cancel := context.WithCancel(context.Background())
	ct.Lock()
	ct.watchCancel[kind] = cancel
	ct.Unlock()
	opts := api.ListWatchOptions{}

	// setup wait group
	ct.waitGrp.Add(1)
	defer ct.waitGrp.Done()

	// loop forever
	for {
		// create a grpc client
		apicl, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, ct.logger, rpckit.WithBalancer(ct.balancer))
		if err != nil {
			log.Warnf("Failed to connect to gRPC server [%s]\n", ct.apisrvURL)
		} else {
			log.Infof("API client connected {%+v}", apicl)

			// FwlogPolicy object watcher
			wt, werr := apicl.MonitoringV1().FwlogPolicy().Watch(ctx, &opts)
			if werr != nil {
				log.Errorf("Failed to start %s watch (%s)\n", kind, werr)
				return
			}
			ct.Lock()
			ct.watchers[kind] = wt
			ct.Unlock()

			// perform a diff with API server and local cache
			time.Sleep(time.Millisecond * 100)
			ct.diffFwlogPolicy(apicl)

			// handle api server watch events
		innerLoop:
			for {
				// wait for events
				select {
				case evt, ok := <-wt.EventChan():
					if !ok {
						log.Error("Error receiving from apisrv watcher")
						break innerLoop
					}

					// handle event
					ct.handleFwlogPolicyEvent(evt)
				}
			}
			apicl.Close()
		}

		// if stop flag is set, we are done
		if ct.stoped {
			log.Infof("Exiting API server watcher")
			return
		}

		// wait for a second and retry connecting to api server
		time.Sleep(time.Second)
	}
}

// WatchFwlogPolicy starts watch on FwlogPolicy object
func (ct *ctrlerCtx) WatchFwlogPolicy(handler FwlogPolicyHandler) error {
	kind := "FwlogPolicy"

	ct.Lock()
	defer ct.Unlock()

	// see if we already have a watcher
	_, ok := ct.watchers[kind]
	if ok {
		return fmt.Errorf("FwlogPolicy watcher already exists")
	}

	// save handler
	ct.handlers[kind] = handler

	// run FwlogPolicy watcher in a go routine
	go ct.runFwlogPolicyWatcher()

	return nil
}

// FwlogPolicyAPI returns
type FwlogPolicyAPI interface {
	Create(obj *monitoring.FwlogPolicy) error
	Update(obj *monitoring.FwlogPolicy) error
	Delete(obj *monitoring.FwlogPolicy) error
	List() []*FwlogPolicy
	Watch(handler FwlogPolicyHandler) error
}

// dummy struct that implements FwlogPolicyAPI
type fwlogpolicyAPI struct {
	ct *ctrlerCtx
}

// Create creates FwlogPolicy object
func (api *fwlogpolicyAPI) Create(obj *monitoring.FwlogPolicy) error {
	return api.ct.handleFwlogPolicyEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Created})
}

// Update triggers update on FwlogPolicy object
func (api *fwlogpolicyAPI) Update(obj *monitoring.FwlogPolicy) error {
	return api.ct.handleFwlogPolicyEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Updated})
}

// Delete deletes FwlogPolicy object
func (api *fwlogpolicyAPI) Delete(obj *monitoring.FwlogPolicy) error {
	return api.ct.handleFwlogPolicyEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Deleted})
}

// List returns a list of all FwlogPolicy objects
func (api *fwlogpolicyAPI) List() []*FwlogPolicy {
	var objlist []*FwlogPolicy

	objs := api.ct.ListObjects("FwlogPolicy")
	for _, obj := range objs {
		switch tp := obj.(type) {
		case *FwlogPolicy:
			eobj := obj.(*FwlogPolicy)
			objlist = append(objlist, eobj)
		default:
			log.Fatalf("Got invalid object type %v while looking for FwlogPolicy", tp)
		}
	}

	return objlist
}

// Watch sets up a event handlers for FwlogPolicy object
func (api *fwlogpolicyAPI) Watch(handler FwlogPolicyHandler) error {
	return api.ct.WatchFwlogPolicy(handler)
}

// FwlogPolicy returns FwlogPolicyAPI
func (ct *ctrlerCtx) FwlogPolicy() FwlogPolicyAPI {
	return &fwlogpolicyAPI{ct: ct}
}

// FlowExportPolicy is a wrapper object that implements additional functionality
type FlowExportPolicy struct {
	sync.Mutex
	monitoring.FlowExportPolicy
	HandlerCtx interface{} // additional state handlers can store
	ctrler     *ctrlerCtx  // reference back to the controller instance
}

func (obj *FlowExportPolicy) Write() error {
	// if there is no API server to connect to, we are done
	if (obj.ctrler == nil) || (obj.ctrler.resolver == nil) || obj.ctrler.apisrvURL == "" {
		return nil
	}

	apicl, err := obj.ctrler.apiClient()
	if err != nil {
		log.Errorf("Error creating API server clent. Err: %v", err)
		return err
	}

	// write to api server
	if obj.ObjectMeta.ResourceVersion != "" {
		nobj := *obj
		// FIXME: clear the resource version till we figure out CAS semantics
		nobj.ObjectMeta.ResourceVersion = ""

		// update it
		_, err = apicl.MonitoringV1().FlowExportPolicy().Update(context.Background(), &nobj.FlowExportPolicy)
	} else {
		//  create
		_, err = apicl.MonitoringV1().FlowExportPolicy().Create(context.Background(), &obj.FlowExportPolicy)
	}

	return nil
}

// FlowExportPolicyHandler is the event handler for FlowExportPolicy object
type FlowExportPolicyHandler interface {
	OnFlowExportPolicyCreate(obj *FlowExportPolicy) error
	OnFlowExportPolicyUpdate(obj *FlowExportPolicy) error
	OnFlowExportPolicyDelete(obj *FlowExportPolicy) error
}

// handleFlowExportPolicyEvent handles FlowExportPolicy events from watcher
func (ct *ctrlerCtx) handleFlowExportPolicyEvent(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *monitoring.FlowExportPolicy:
		eobj := evt.Object.(*monitoring.FlowExportPolicy)
		kind := "FlowExportPolicy"

		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		handler, ok := ct.handlers[kind]
		if !ok {
			log.Fatalf("Cant find the handler for %s", kind)
		}
		flowexportpolicyHandler := handler.(FlowExportPolicyHandler)
		// handle based on event type
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			fobj, err := ct.findObject(kind, eobj.GetKey())
			if err != nil {
				obj := &FlowExportPolicy{
					FlowExportPolicy: *eobj,
					HandlerCtx:       nil,
					ctrler:           ct,
				}
				ct.addObject(kind, obj.GetKey(), obj)
				// call the event handler
				obj.Lock()
				err = flowexportpolicyHandler.OnFlowExportPolicyCreate(obj)
				obj.Unlock()
				if err != nil {
					log.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					ct.delObject(kind, eobj.GetKey())
					return err
				}
			} else {
				obj := fobj.(*FlowExportPolicy)
				obj.ObjectMeta = eobj.ObjectMeta

				// see if it changed
				if _, ok := ref.ObjDiff(obj.Spec, eobj.Spec); ok {
					obj.Spec = eobj.Spec
					// call the event handler
					obj.Lock()
					err = flowexportpolicyHandler.OnFlowExportPolicyUpdate(obj)
					obj.Unlock()
					if err != nil {
						log.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
						return err
					}
				}
			}
		case kvstore.Deleted:
			fobj, err := ct.findObject(kind, eobj.GetKey())
			if err != nil {
				log.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
				return err
			}

			obj := fobj.(*FlowExportPolicy)

			// Call the event reactor
			obj.Lock()
			err = flowexportpolicyHandler.OnFlowExportPolicyDelete(obj)
			obj.Unlock()
			if err != nil {
				log.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
				return err
			}

			ct.delObject(kind, eobj.GetKey())
		}
	default:
		log.Fatalf("API watcher Found object of invalid type: %v on FlowExportPolicy watch channel", tp)
	}

	return nil
}

// diffFlowExportPolicy does a diff of FlowExportPolicy objects between local cache and API server
func (ct *ctrlerCtx) diffFlowExportPolicy(apicl apiclient.Services) {
	opts := api.ListWatchOptions{}

	// get a list of all objects from API server
	objlist, err := apicl.MonitoringV1().FlowExportPolicy().List(context.Background(), &opts)
	if err != nil {
		log.Errorf("Error getting a list of objects. Err: %v", err)
		return
	}

	// build an object map
	objmap := make(map[string]*monitoring.FlowExportPolicy)
	for _, obj := range objlist {
		objmap[obj.GetKey()] = obj
	}

	// if an object is in our local cache and not in API server, trigger delete for it
	for _, obj := range ct.FlowExportPolicy().List() {
		_, ok := objmap[obj.GetKey()]
		if !ok {
			evt := kvstore.WatchEvent{
				Type:   kvstore.Deleted,
				Key:    obj.GetKey(),
				Object: &obj.FlowExportPolicy,
			}
			ct.handleFlowExportPolicyEvent(&evt)
		}
	}

	// trigger create event for all others
	for _, obj := range objlist {
		evt := kvstore.WatchEvent{
			Type:   kvstore.Created,
			Key:    obj.GetKey(),
			Object: obj,
		}
		ct.handleFlowExportPolicyEvent(&evt)
	}
}

func (ct *ctrlerCtx) runFlowExportPolicyWatcher() {
	kind := "FlowExportPolicy"

	// if there is no API server to connect to, we are done
	if (ct.resolver == nil) || ct.apisrvURL == "" {
		return
	}

	// create context
	ctx, cancel := context.WithCancel(context.Background())
	ct.Lock()
	ct.watchCancel[kind] = cancel
	ct.Unlock()
	opts := api.ListWatchOptions{}

	// setup wait group
	ct.waitGrp.Add(1)
	defer ct.waitGrp.Done()

	// loop forever
	for {
		// create a grpc client
		apicl, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, ct.logger, rpckit.WithBalancer(ct.balancer))
		if err != nil {
			log.Warnf("Failed to connect to gRPC server [%s]\n", ct.apisrvURL)
		} else {
			log.Infof("API client connected {%+v}", apicl)

			// FlowExportPolicy object watcher
			wt, werr := apicl.MonitoringV1().FlowExportPolicy().Watch(ctx, &opts)
			if werr != nil {
				log.Errorf("Failed to start %s watch (%s)\n", kind, werr)
				return
			}
			ct.Lock()
			ct.watchers[kind] = wt
			ct.Unlock()

			// perform a diff with API server and local cache
			time.Sleep(time.Millisecond * 100)
			ct.diffFlowExportPolicy(apicl)

			// handle api server watch events
		innerLoop:
			for {
				// wait for events
				select {
				case evt, ok := <-wt.EventChan():
					if !ok {
						log.Error("Error receiving from apisrv watcher")
						break innerLoop
					}

					// handle event
					ct.handleFlowExportPolicyEvent(evt)
				}
			}
			apicl.Close()
		}

		// if stop flag is set, we are done
		if ct.stoped {
			log.Infof("Exiting API server watcher")
			return
		}

		// wait for a second and retry connecting to api server
		time.Sleep(time.Second)
	}
}

// WatchFlowExportPolicy starts watch on FlowExportPolicy object
func (ct *ctrlerCtx) WatchFlowExportPolicy(handler FlowExportPolicyHandler) error {
	kind := "FlowExportPolicy"

	ct.Lock()
	defer ct.Unlock()

	// see if we already have a watcher
	_, ok := ct.watchers[kind]
	if ok {
		return fmt.Errorf("FlowExportPolicy watcher already exists")
	}

	// save handler
	ct.handlers[kind] = handler

	// run FlowExportPolicy watcher in a go routine
	go ct.runFlowExportPolicyWatcher()

	return nil
}

// FlowExportPolicyAPI returns
type FlowExportPolicyAPI interface {
	Create(obj *monitoring.FlowExportPolicy) error
	Update(obj *monitoring.FlowExportPolicy) error
	Delete(obj *monitoring.FlowExportPolicy) error
	List() []*FlowExportPolicy
	Watch(handler FlowExportPolicyHandler) error
}

// dummy struct that implements FlowExportPolicyAPI
type flowexportpolicyAPI struct {
	ct *ctrlerCtx
}

// Create creates FlowExportPolicy object
func (api *flowexportpolicyAPI) Create(obj *monitoring.FlowExportPolicy) error {
	return api.ct.handleFlowExportPolicyEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Created})
}

// Update triggers update on FlowExportPolicy object
func (api *flowexportpolicyAPI) Update(obj *monitoring.FlowExportPolicy) error {
	return api.ct.handleFlowExportPolicyEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Updated})
}

// Delete deletes FlowExportPolicy object
func (api *flowexportpolicyAPI) Delete(obj *monitoring.FlowExportPolicy) error {
	return api.ct.handleFlowExportPolicyEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Deleted})
}

// List returns a list of all FlowExportPolicy objects
func (api *flowexportpolicyAPI) List() []*FlowExportPolicy {
	var objlist []*FlowExportPolicy

	objs := api.ct.ListObjects("FlowExportPolicy")
	for _, obj := range objs {
		switch tp := obj.(type) {
		case *FlowExportPolicy:
			eobj := obj.(*FlowExportPolicy)
			objlist = append(objlist, eobj)
		default:
			log.Fatalf("Got invalid object type %v while looking for FlowExportPolicy", tp)
		}
	}

	return objlist
}

// Watch sets up a event handlers for FlowExportPolicy object
func (api *flowexportpolicyAPI) Watch(handler FlowExportPolicyHandler) error {
	return api.ct.WatchFlowExportPolicy(handler)
}

// FlowExportPolicy returns FlowExportPolicyAPI
func (ct *ctrlerCtx) FlowExportPolicy() FlowExportPolicyAPI {
	return &flowexportpolicyAPI{ct: ct}
}

// Alert is a wrapper object that implements additional functionality
type Alert struct {
	sync.Mutex
	monitoring.Alert
	HandlerCtx interface{} // additional state handlers can store
	ctrler     *ctrlerCtx  // reference back to the controller instance
}

func (obj *Alert) Write() error {
	// if there is no API server to connect to, we are done
	if (obj.ctrler == nil) || (obj.ctrler.resolver == nil) || obj.ctrler.apisrvURL == "" {
		return nil
	}

	apicl, err := obj.ctrler.apiClient()
	if err != nil {
		log.Errorf("Error creating API server clent. Err: %v", err)
		return err
	}

	// write to api server
	if obj.ObjectMeta.ResourceVersion != "" {
		nobj := *obj
		// FIXME: clear the resource version till we figure out CAS semantics
		nobj.ObjectMeta.ResourceVersion = ""

		// update it
		_, err = apicl.MonitoringV1().Alert().Update(context.Background(), &nobj.Alert)
	} else {
		//  create
		_, err = apicl.MonitoringV1().Alert().Create(context.Background(), &obj.Alert)
	}

	return nil
}

// AlertHandler is the event handler for Alert object
type AlertHandler interface {
	OnAlertCreate(obj *Alert) error
	OnAlertUpdate(obj *Alert) error
	OnAlertDelete(obj *Alert) error
}

// handleAlertEvent handles Alert events from watcher
func (ct *ctrlerCtx) handleAlertEvent(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *monitoring.Alert:
		eobj := evt.Object.(*monitoring.Alert)
		kind := "Alert"

		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		handler, ok := ct.handlers[kind]
		if !ok {
			log.Fatalf("Cant find the handler for %s", kind)
		}
		alertHandler := handler.(AlertHandler)
		// handle based on event type
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			fobj, err := ct.findObject(kind, eobj.GetKey())
			if err != nil {
				obj := &Alert{
					Alert:      *eobj,
					HandlerCtx: nil,
					ctrler:     ct,
				}
				ct.addObject(kind, obj.GetKey(), obj)
				// call the event handler
				obj.Lock()
				err = alertHandler.OnAlertCreate(obj)
				obj.Unlock()
				if err != nil {
					log.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					ct.delObject(kind, eobj.GetKey())
					return err
				}
			} else {
				obj := fobj.(*Alert)
				obj.ObjectMeta = eobj.ObjectMeta

				// see if it changed
				if _, ok := ref.ObjDiff(obj.Spec, eobj.Spec); ok {
					obj.Spec = eobj.Spec
					// call the event handler
					obj.Lock()
					err = alertHandler.OnAlertUpdate(obj)
					obj.Unlock()
					if err != nil {
						log.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
						return err
					}
				}
			}
		case kvstore.Deleted:
			fobj, err := ct.findObject(kind, eobj.GetKey())
			if err != nil {
				log.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
				return err
			}

			obj := fobj.(*Alert)

			// Call the event reactor
			obj.Lock()
			err = alertHandler.OnAlertDelete(obj)
			obj.Unlock()
			if err != nil {
				log.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
				return err
			}

			ct.delObject(kind, eobj.GetKey())
		}
	default:
		log.Fatalf("API watcher Found object of invalid type: %v on Alert watch channel", tp)
	}

	return nil
}

// diffAlert does a diff of Alert objects between local cache and API server
func (ct *ctrlerCtx) diffAlert(apicl apiclient.Services) {
	opts := api.ListWatchOptions{}

	// get a list of all objects from API server
	objlist, err := apicl.MonitoringV1().Alert().List(context.Background(), &opts)
	if err != nil {
		log.Errorf("Error getting a list of objects. Err: %v", err)
		return
	}

	// build an object map
	objmap := make(map[string]*monitoring.Alert)
	for _, obj := range objlist {
		objmap[obj.GetKey()] = obj
	}

	// if an object is in our local cache and not in API server, trigger delete for it
	for _, obj := range ct.Alert().List() {
		_, ok := objmap[obj.GetKey()]
		if !ok {
			evt := kvstore.WatchEvent{
				Type:   kvstore.Deleted,
				Key:    obj.GetKey(),
				Object: &obj.Alert,
			}
			ct.handleAlertEvent(&evt)
		}
	}

	// trigger create event for all others
	for _, obj := range objlist {
		evt := kvstore.WatchEvent{
			Type:   kvstore.Created,
			Key:    obj.GetKey(),
			Object: obj,
		}
		ct.handleAlertEvent(&evt)
	}
}

func (ct *ctrlerCtx) runAlertWatcher() {
	kind := "Alert"

	// if there is no API server to connect to, we are done
	if (ct.resolver == nil) || ct.apisrvURL == "" {
		return
	}

	// create context
	ctx, cancel := context.WithCancel(context.Background())
	ct.Lock()
	ct.watchCancel[kind] = cancel
	ct.Unlock()
	opts := api.ListWatchOptions{}

	// setup wait group
	ct.waitGrp.Add(1)
	defer ct.waitGrp.Done()

	// loop forever
	for {
		// create a grpc client
		apicl, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, ct.logger, rpckit.WithBalancer(ct.balancer))
		if err != nil {
			log.Warnf("Failed to connect to gRPC server [%s]\n", ct.apisrvURL)
		} else {
			log.Infof("API client connected {%+v}", apicl)

			// Alert object watcher
			wt, werr := apicl.MonitoringV1().Alert().Watch(ctx, &opts)
			if werr != nil {
				log.Errorf("Failed to start %s watch (%s)\n", kind, werr)
				return
			}
			ct.Lock()
			ct.watchers[kind] = wt
			ct.Unlock()

			// perform a diff with API server and local cache
			time.Sleep(time.Millisecond * 100)
			ct.diffAlert(apicl)

			// handle api server watch events
		innerLoop:
			for {
				// wait for events
				select {
				case evt, ok := <-wt.EventChan():
					if !ok {
						log.Error("Error receiving from apisrv watcher")
						break innerLoop
					}

					// handle event
					ct.handleAlertEvent(evt)
				}
			}
			apicl.Close()
		}

		// if stop flag is set, we are done
		if ct.stoped {
			log.Infof("Exiting API server watcher")
			return
		}

		// wait for a second and retry connecting to api server
		time.Sleep(time.Second)
	}
}

// WatchAlert starts watch on Alert object
func (ct *ctrlerCtx) WatchAlert(handler AlertHandler) error {
	kind := "Alert"

	ct.Lock()
	defer ct.Unlock()

	// see if we already have a watcher
	_, ok := ct.watchers[kind]
	if ok {
		return fmt.Errorf("Alert watcher already exists")
	}

	// save handler
	ct.handlers[kind] = handler

	// run Alert watcher in a go routine
	go ct.runAlertWatcher()

	return nil
}

// AlertAPI returns
type AlertAPI interface {
	Create(obj *monitoring.Alert) error
	Update(obj *monitoring.Alert) error
	Delete(obj *monitoring.Alert) error
	List() []*Alert
	Watch(handler AlertHandler) error
}

// dummy struct that implements AlertAPI
type alertAPI struct {
	ct *ctrlerCtx
}

// Create creates Alert object
func (api *alertAPI) Create(obj *monitoring.Alert) error {
	return api.ct.handleAlertEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Created})
}

// Update triggers update on Alert object
func (api *alertAPI) Update(obj *monitoring.Alert) error {
	return api.ct.handleAlertEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Updated})
}

// Delete deletes Alert object
func (api *alertAPI) Delete(obj *monitoring.Alert) error {
	return api.ct.handleAlertEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Deleted})
}

// List returns a list of all Alert objects
func (api *alertAPI) List() []*Alert {
	var objlist []*Alert

	objs := api.ct.ListObjects("Alert")
	for _, obj := range objs {
		switch tp := obj.(type) {
		case *Alert:
			eobj := obj.(*Alert)
			objlist = append(objlist, eobj)
		default:
			log.Fatalf("Got invalid object type %v while looking for Alert", tp)
		}
	}

	return objlist
}

// Watch sets up a event handlers for Alert object
func (api *alertAPI) Watch(handler AlertHandler) error {
	return api.ct.WatchAlert(handler)
}

// Alert returns AlertAPI
func (ct *ctrlerCtx) Alert() AlertAPI {
	return &alertAPI{ct: ct}
}

// AlertPolicy is a wrapper object that implements additional functionality
type AlertPolicy struct {
	sync.Mutex
	monitoring.AlertPolicy
	HandlerCtx interface{} // additional state handlers can store
	ctrler     *ctrlerCtx  // reference back to the controller instance
}

func (obj *AlertPolicy) Write() error {
	// if there is no API server to connect to, we are done
	if (obj.ctrler == nil) || (obj.ctrler.resolver == nil) || obj.ctrler.apisrvURL == "" {
		return nil
	}

	apicl, err := obj.ctrler.apiClient()
	if err != nil {
		log.Errorf("Error creating API server clent. Err: %v", err)
		return err
	}

	// write to api server
	if obj.ObjectMeta.ResourceVersion != "" {
		nobj := *obj
		// FIXME: clear the resource version till we figure out CAS semantics
		nobj.ObjectMeta.ResourceVersion = ""

		// update it
		_, err = apicl.MonitoringV1().AlertPolicy().Update(context.Background(), &nobj.AlertPolicy)
	} else {
		//  create
		_, err = apicl.MonitoringV1().AlertPolicy().Create(context.Background(), &obj.AlertPolicy)
	}

	return nil
}

// AlertPolicyHandler is the event handler for AlertPolicy object
type AlertPolicyHandler interface {
	OnAlertPolicyCreate(obj *AlertPolicy) error
	OnAlertPolicyUpdate(obj *AlertPolicy) error
	OnAlertPolicyDelete(obj *AlertPolicy) error
}

// handleAlertPolicyEvent handles AlertPolicy events from watcher
func (ct *ctrlerCtx) handleAlertPolicyEvent(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *monitoring.AlertPolicy:
		eobj := evt.Object.(*monitoring.AlertPolicy)
		kind := "AlertPolicy"

		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		handler, ok := ct.handlers[kind]
		if !ok {
			log.Fatalf("Cant find the handler for %s", kind)
		}
		alertpolicyHandler := handler.(AlertPolicyHandler)
		// handle based on event type
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			fobj, err := ct.findObject(kind, eobj.GetKey())
			if err != nil {
				obj := &AlertPolicy{
					AlertPolicy: *eobj,
					HandlerCtx:  nil,
					ctrler:      ct,
				}
				ct.addObject(kind, obj.GetKey(), obj)
				// call the event handler
				obj.Lock()
				err = alertpolicyHandler.OnAlertPolicyCreate(obj)
				obj.Unlock()
				if err != nil {
					log.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					ct.delObject(kind, eobj.GetKey())
					return err
				}
			} else {
				obj := fobj.(*AlertPolicy)
				obj.ObjectMeta = eobj.ObjectMeta

				// see if it changed
				if _, ok := ref.ObjDiff(obj.Spec, eobj.Spec); ok {
					obj.Spec = eobj.Spec
					// call the event handler
					obj.Lock()
					err = alertpolicyHandler.OnAlertPolicyUpdate(obj)
					obj.Unlock()
					if err != nil {
						log.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
						return err
					}
				}
			}
		case kvstore.Deleted:
			fobj, err := ct.findObject(kind, eobj.GetKey())
			if err != nil {
				log.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
				return err
			}

			obj := fobj.(*AlertPolicy)

			// Call the event reactor
			obj.Lock()
			err = alertpolicyHandler.OnAlertPolicyDelete(obj)
			obj.Unlock()
			if err != nil {
				log.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
				return err
			}

			ct.delObject(kind, eobj.GetKey())
		}
	default:
		log.Fatalf("API watcher Found object of invalid type: %v on AlertPolicy watch channel", tp)
	}

	return nil
}

// diffAlertPolicy does a diff of AlertPolicy objects between local cache and API server
func (ct *ctrlerCtx) diffAlertPolicy(apicl apiclient.Services) {
	opts := api.ListWatchOptions{}

	// get a list of all objects from API server
	objlist, err := apicl.MonitoringV1().AlertPolicy().List(context.Background(), &opts)
	if err != nil {
		log.Errorf("Error getting a list of objects. Err: %v", err)
		return
	}

	// build an object map
	objmap := make(map[string]*monitoring.AlertPolicy)
	for _, obj := range objlist {
		objmap[obj.GetKey()] = obj
	}

	// if an object is in our local cache and not in API server, trigger delete for it
	for _, obj := range ct.AlertPolicy().List() {
		_, ok := objmap[obj.GetKey()]
		if !ok {
			evt := kvstore.WatchEvent{
				Type:   kvstore.Deleted,
				Key:    obj.GetKey(),
				Object: &obj.AlertPolicy,
			}
			ct.handleAlertPolicyEvent(&evt)
		}
	}

	// trigger create event for all others
	for _, obj := range objlist {
		evt := kvstore.WatchEvent{
			Type:   kvstore.Created,
			Key:    obj.GetKey(),
			Object: obj,
		}
		ct.handleAlertPolicyEvent(&evt)
	}
}

func (ct *ctrlerCtx) runAlertPolicyWatcher() {
	kind := "AlertPolicy"

	// if there is no API server to connect to, we are done
	if (ct.resolver == nil) || ct.apisrvURL == "" {
		return
	}

	// create context
	ctx, cancel := context.WithCancel(context.Background())
	ct.Lock()
	ct.watchCancel[kind] = cancel
	ct.Unlock()
	opts := api.ListWatchOptions{}

	// setup wait group
	ct.waitGrp.Add(1)
	defer ct.waitGrp.Done()

	// loop forever
	for {
		// create a grpc client
		apicl, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, ct.logger, rpckit.WithBalancer(ct.balancer))
		if err != nil {
			log.Warnf("Failed to connect to gRPC server [%s]\n", ct.apisrvURL)
		} else {
			log.Infof("API client connected {%+v}", apicl)

			// AlertPolicy object watcher
			wt, werr := apicl.MonitoringV1().AlertPolicy().Watch(ctx, &opts)
			if werr != nil {
				log.Errorf("Failed to start %s watch (%s)\n", kind, werr)
				return
			}
			ct.Lock()
			ct.watchers[kind] = wt
			ct.Unlock()

			// perform a diff with API server and local cache
			time.Sleep(time.Millisecond * 100)
			ct.diffAlertPolicy(apicl)

			// handle api server watch events
		innerLoop:
			for {
				// wait for events
				select {
				case evt, ok := <-wt.EventChan():
					if !ok {
						log.Error("Error receiving from apisrv watcher")
						break innerLoop
					}

					// handle event
					ct.handleAlertPolicyEvent(evt)
				}
			}
			apicl.Close()
		}

		// if stop flag is set, we are done
		if ct.stoped {
			log.Infof("Exiting API server watcher")
			return
		}

		// wait for a second and retry connecting to api server
		time.Sleep(time.Second)
	}
}

// WatchAlertPolicy starts watch on AlertPolicy object
func (ct *ctrlerCtx) WatchAlertPolicy(handler AlertPolicyHandler) error {
	kind := "AlertPolicy"

	ct.Lock()
	defer ct.Unlock()

	// see if we already have a watcher
	_, ok := ct.watchers[kind]
	if ok {
		return fmt.Errorf("AlertPolicy watcher already exists")
	}

	// save handler
	ct.handlers[kind] = handler

	// run AlertPolicy watcher in a go routine
	go ct.runAlertPolicyWatcher()

	return nil
}

// AlertPolicyAPI returns
type AlertPolicyAPI interface {
	Create(obj *monitoring.AlertPolicy) error
	Update(obj *monitoring.AlertPolicy) error
	Delete(obj *monitoring.AlertPolicy) error
	List() []*AlertPolicy
	Watch(handler AlertPolicyHandler) error
}

// dummy struct that implements AlertPolicyAPI
type alertpolicyAPI struct {
	ct *ctrlerCtx
}

// Create creates AlertPolicy object
func (api *alertpolicyAPI) Create(obj *monitoring.AlertPolicy) error {
	return api.ct.handleAlertPolicyEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Created})
}

// Update triggers update on AlertPolicy object
func (api *alertpolicyAPI) Update(obj *monitoring.AlertPolicy) error {
	return api.ct.handleAlertPolicyEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Updated})
}

// Delete deletes AlertPolicy object
func (api *alertpolicyAPI) Delete(obj *monitoring.AlertPolicy) error {
	return api.ct.handleAlertPolicyEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Deleted})
}

// List returns a list of all AlertPolicy objects
func (api *alertpolicyAPI) List() []*AlertPolicy {
	var objlist []*AlertPolicy

	objs := api.ct.ListObjects("AlertPolicy")
	for _, obj := range objs {
		switch tp := obj.(type) {
		case *AlertPolicy:
			eobj := obj.(*AlertPolicy)
			objlist = append(objlist, eobj)
		default:
			log.Fatalf("Got invalid object type %v while looking for AlertPolicy", tp)
		}
	}

	return objlist
}

// Watch sets up a event handlers for AlertPolicy object
func (api *alertpolicyAPI) Watch(handler AlertPolicyHandler) error {
	return api.ct.WatchAlertPolicy(handler)
}

// AlertPolicy returns AlertPolicyAPI
func (ct *ctrlerCtx) AlertPolicy() AlertPolicyAPI {
	return &alertpolicyAPI{ct: ct}
}

// AlertDestination is a wrapper object that implements additional functionality
type AlertDestination struct {
	sync.Mutex
	monitoring.AlertDestination
	HandlerCtx interface{} // additional state handlers can store
	ctrler     *ctrlerCtx  // reference back to the controller instance
}

func (obj *AlertDestination) Write() error {
	// if there is no API server to connect to, we are done
	if (obj.ctrler == nil) || (obj.ctrler.resolver == nil) || obj.ctrler.apisrvURL == "" {
		return nil
	}

	apicl, err := obj.ctrler.apiClient()
	if err != nil {
		log.Errorf("Error creating API server clent. Err: %v", err)
		return err
	}

	// write to api server
	if obj.ObjectMeta.ResourceVersion != "" {
		nobj := *obj
		// FIXME: clear the resource version till we figure out CAS semantics
		nobj.ObjectMeta.ResourceVersion = ""

		// update it
		_, err = apicl.MonitoringV1().AlertDestination().Update(context.Background(), &nobj.AlertDestination)
	} else {
		//  create
		_, err = apicl.MonitoringV1().AlertDestination().Create(context.Background(), &obj.AlertDestination)
	}

	return nil
}

// AlertDestinationHandler is the event handler for AlertDestination object
type AlertDestinationHandler interface {
	OnAlertDestinationCreate(obj *AlertDestination) error
	OnAlertDestinationUpdate(obj *AlertDestination) error
	OnAlertDestinationDelete(obj *AlertDestination) error
}

// handleAlertDestinationEvent handles AlertDestination events from watcher
func (ct *ctrlerCtx) handleAlertDestinationEvent(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *monitoring.AlertDestination:
		eobj := evt.Object.(*monitoring.AlertDestination)
		kind := "AlertDestination"

		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		handler, ok := ct.handlers[kind]
		if !ok {
			log.Fatalf("Cant find the handler for %s", kind)
		}
		alertdestinationHandler := handler.(AlertDestinationHandler)
		// handle based on event type
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			fobj, err := ct.findObject(kind, eobj.GetKey())
			if err != nil {
				obj := &AlertDestination{
					AlertDestination: *eobj,
					HandlerCtx:       nil,
					ctrler:           ct,
				}
				ct.addObject(kind, obj.GetKey(), obj)
				// call the event handler
				obj.Lock()
				err = alertdestinationHandler.OnAlertDestinationCreate(obj)
				obj.Unlock()
				if err != nil {
					log.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					ct.delObject(kind, eobj.GetKey())
					return err
				}
			} else {
				obj := fobj.(*AlertDestination)
				obj.ObjectMeta = eobj.ObjectMeta

				// see if it changed
				if _, ok := ref.ObjDiff(obj.Spec, eobj.Spec); ok {
					obj.Spec = eobj.Spec
					// call the event handler
					obj.Lock()
					err = alertdestinationHandler.OnAlertDestinationUpdate(obj)
					obj.Unlock()
					if err != nil {
						log.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
						return err
					}
				}
			}
		case kvstore.Deleted:
			fobj, err := ct.findObject(kind, eobj.GetKey())
			if err != nil {
				log.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
				return err
			}

			obj := fobj.(*AlertDestination)

			// Call the event reactor
			obj.Lock()
			err = alertdestinationHandler.OnAlertDestinationDelete(obj)
			obj.Unlock()
			if err != nil {
				log.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
				return err
			}

			ct.delObject(kind, eobj.GetKey())
		}
	default:
		log.Fatalf("API watcher Found object of invalid type: %v on AlertDestination watch channel", tp)
	}

	return nil
}

// diffAlertDestination does a diff of AlertDestination objects between local cache and API server
func (ct *ctrlerCtx) diffAlertDestination(apicl apiclient.Services) {
	opts := api.ListWatchOptions{}

	// get a list of all objects from API server
	objlist, err := apicl.MonitoringV1().AlertDestination().List(context.Background(), &opts)
	if err != nil {
		log.Errorf("Error getting a list of objects. Err: %v", err)
		return
	}

	// build an object map
	objmap := make(map[string]*monitoring.AlertDestination)
	for _, obj := range objlist {
		objmap[obj.GetKey()] = obj
	}

	// if an object is in our local cache and not in API server, trigger delete for it
	for _, obj := range ct.AlertDestination().List() {
		_, ok := objmap[obj.GetKey()]
		if !ok {
			evt := kvstore.WatchEvent{
				Type:   kvstore.Deleted,
				Key:    obj.GetKey(),
				Object: &obj.AlertDestination,
			}
			ct.handleAlertDestinationEvent(&evt)
		}
	}

	// trigger create event for all others
	for _, obj := range objlist {
		evt := kvstore.WatchEvent{
			Type:   kvstore.Created,
			Key:    obj.GetKey(),
			Object: obj,
		}
		ct.handleAlertDestinationEvent(&evt)
	}
}

func (ct *ctrlerCtx) runAlertDestinationWatcher() {
	kind := "AlertDestination"

	// if there is no API server to connect to, we are done
	if (ct.resolver == nil) || ct.apisrvURL == "" {
		return
	}

	// create context
	ctx, cancel := context.WithCancel(context.Background())
	ct.Lock()
	ct.watchCancel[kind] = cancel
	ct.Unlock()
	opts := api.ListWatchOptions{}

	// setup wait group
	ct.waitGrp.Add(1)
	defer ct.waitGrp.Done()

	// loop forever
	for {
		// create a grpc client
		apicl, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, ct.logger, rpckit.WithBalancer(ct.balancer))
		if err != nil {
			log.Warnf("Failed to connect to gRPC server [%s]\n", ct.apisrvURL)
		} else {
			log.Infof("API client connected {%+v}", apicl)

			// AlertDestination object watcher
			wt, werr := apicl.MonitoringV1().AlertDestination().Watch(ctx, &opts)
			if werr != nil {
				log.Errorf("Failed to start %s watch (%s)\n", kind, werr)
				return
			}
			ct.Lock()
			ct.watchers[kind] = wt
			ct.Unlock()

			// perform a diff with API server and local cache
			time.Sleep(time.Millisecond * 100)
			ct.diffAlertDestination(apicl)

			// handle api server watch events
		innerLoop:
			for {
				// wait for events
				select {
				case evt, ok := <-wt.EventChan():
					if !ok {
						log.Error("Error receiving from apisrv watcher")
						break innerLoop
					}

					// handle event
					ct.handleAlertDestinationEvent(evt)
				}
			}
			apicl.Close()
		}

		// if stop flag is set, we are done
		if ct.stoped {
			log.Infof("Exiting API server watcher")
			return
		}

		// wait for a second and retry connecting to api server
		time.Sleep(time.Second)
	}
}

// WatchAlertDestination starts watch on AlertDestination object
func (ct *ctrlerCtx) WatchAlertDestination(handler AlertDestinationHandler) error {
	kind := "AlertDestination"

	ct.Lock()
	defer ct.Unlock()

	// see if we already have a watcher
	_, ok := ct.watchers[kind]
	if ok {
		return fmt.Errorf("AlertDestination watcher already exists")
	}

	// save handler
	ct.handlers[kind] = handler

	// run AlertDestination watcher in a go routine
	go ct.runAlertDestinationWatcher()

	return nil
}

// AlertDestinationAPI returns
type AlertDestinationAPI interface {
	Create(obj *monitoring.AlertDestination) error
	Update(obj *monitoring.AlertDestination) error
	Delete(obj *monitoring.AlertDestination) error
	List() []*AlertDestination
	Watch(handler AlertDestinationHandler) error
}

// dummy struct that implements AlertDestinationAPI
type alertdestinationAPI struct {
	ct *ctrlerCtx
}

// Create creates AlertDestination object
func (api *alertdestinationAPI) Create(obj *monitoring.AlertDestination) error {
	return api.ct.handleAlertDestinationEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Created})
}

// Update triggers update on AlertDestination object
func (api *alertdestinationAPI) Update(obj *monitoring.AlertDestination) error {
	return api.ct.handleAlertDestinationEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Updated})
}

// Delete deletes AlertDestination object
func (api *alertdestinationAPI) Delete(obj *monitoring.AlertDestination) error {
	return api.ct.handleAlertDestinationEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Deleted})
}

// List returns a list of all AlertDestination objects
func (api *alertdestinationAPI) List() []*AlertDestination {
	var objlist []*AlertDestination

	objs := api.ct.ListObjects("AlertDestination")
	for _, obj := range objs {
		switch tp := obj.(type) {
		case *AlertDestination:
			eobj := obj.(*AlertDestination)
			objlist = append(objlist, eobj)
		default:
			log.Fatalf("Got invalid object type %v while looking for AlertDestination", tp)
		}
	}

	return objlist
}

// Watch sets up a event handlers for AlertDestination object
func (api *alertdestinationAPI) Watch(handler AlertDestinationHandler) error {
	return api.ct.WatchAlertDestination(handler)
}

// AlertDestination returns AlertDestinationAPI
func (ct *ctrlerCtx) AlertDestination() AlertDestinationAPI {
	return &alertdestinationAPI{ct: ct}
}

// MirrorSession is a wrapper object that implements additional functionality
type MirrorSession struct {
	sync.Mutex
	monitoring.MirrorSession
	HandlerCtx interface{} // additional state handlers can store
	ctrler     *ctrlerCtx  // reference back to the controller instance
}

func (obj *MirrorSession) Write() error {
	// if there is no API server to connect to, we are done
	if (obj.ctrler == nil) || (obj.ctrler.resolver == nil) || obj.ctrler.apisrvURL == "" {
		return nil
	}

	apicl, err := obj.ctrler.apiClient()
	if err != nil {
		log.Errorf("Error creating API server clent. Err: %v", err)
		return err
	}

	// write to api server
	if obj.ObjectMeta.ResourceVersion != "" {
		nobj := *obj
		// FIXME: clear the resource version till we figure out CAS semantics
		nobj.ObjectMeta.ResourceVersion = ""

		// update it
		_, err = apicl.MonitoringV1().MirrorSession().Update(context.Background(), &nobj.MirrorSession)
	} else {
		//  create
		_, err = apicl.MonitoringV1().MirrorSession().Create(context.Background(), &obj.MirrorSession)
	}

	return nil
}

// MirrorSessionHandler is the event handler for MirrorSession object
type MirrorSessionHandler interface {
	OnMirrorSessionCreate(obj *MirrorSession) error
	OnMirrorSessionUpdate(obj *MirrorSession) error
	OnMirrorSessionDelete(obj *MirrorSession) error
}

// handleMirrorSessionEvent handles MirrorSession events from watcher
func (ct *ctrlerCtx) handleMirrorSessionEvent(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *monitoring.MirrorSession:
		eobj := evt.Object.(*monitoring.MirrorSession)
		kind := "MirrorSession"

		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		handler, ok := ct.handlers[kind]
		if !ok {
			log.Fatalf("Cant find the handler for %s", kind)
		}
		mirrorsessionHandler := handler.(MirrorSessionHandler)
		// handle based on event type
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			fobj, err := ct.findObject(kind, eobj.GetKey())
			if err != nil {
				obj := &MirrorSession{
					MirrorSession: *eobj,
					HandlerCtx:    nil,
					ctrler:        ct,
				}
				ct.addObject(kind, obj.GetKey(), obj)
				// call the event handler
				obj.Lock()
				err = mirrorsessionHandler.OnMirrorSessionCreate(obj)
				obj.Unlock()
				if err != nil {
					log.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					ct.delObject(kind, eobj.GetKey())
					return err
				}
			} else {
				obj := fobj.(*MirrorSession)
				obj.ObjectMeta = eobj.ObjectMeta

				// see if it changed
				if _, ok := ref.ObjDiff(obj.Spec, eobj.Spec); ok {
					obj.Spec = eobj.Spec
					// call the event handler
					obj.Lock()
					err = mirrorsessionHandler.OnMirrorSessionUpdate(obj)
					obj.Unlock()
					if err != nil {
						log.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
						return err
					}
				}
			}
		case kvstore.Deleted:
			fobj, err := ct.findObject(kind, eobj.GetKey())
			if err != nil {
				log.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
				return err
			}

			obj := fobj.(*MirrorSession)

			// Call the event reactor
			obj.Lock()
			err = mirrorsessionHandler.OnMirrorSessionDelete(obj)
			obj.Unlock()
			if err != nil {
				log.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
				return err
			}

			ct.delObject(kind, eobj.GetKey())
		}
	default:
		log.Fatalf("API watcher Found object of invalid type: %v on MirrorSession watch channel", tp)
	}

	return nil
}

// diffMirrorSession does a diff of MirrorSession objects between local cache and API server
func (ct *ctrlerCtx) diffMirrorSession(apicl apiclient.Services) {
	opts := api.ListWatchOptions{}

	// get a list of all objects from API server
	objlist, err := apicl.MonitoringV1().MirrorSession().List(context.Background(), &opts)
	if err != nil {
		log.Errorf("Error getting a list of objects. Err: %v", err)
		return
	}

	// build an object map
	objmap := make(map[string]*monitoring.MirrorSession)
	for _, obj := range objlist {
		objmap[obj.GetKey()] = obj
	}

	// if an object is in our local cache and not in API server, trigger delete for it
	for _, obj := range ct.MirrorSession().List() {
		_, ok := objmap[obj.GetKey()]
		if !ok {
			evt := kvstore.WatchEvent{
				Type:   kvstore.Deleted,
				Key:    obj.GetKey(),
				Object: &obj.MirrorSession,
			}
			ct.handleMirrorSessionEvent(&evt)
		}
	}

	// trigger create event for all others
	for _, obj := range objlist {
		evt := kvstore.WatchEvent{
			Type:   kvstore.Created,
			Key:    obj.GetKey(),
			Object: obj,
		}
		ct.handleMirrorSessionEvent(&evt)
	}
}

func (ct *ctrlerCtx) runMirrorSessionWatcher() {
	kind := "MirrorSession"

	// if there is no API server to connect to, we are done
	if (ct.resolver == nil) || ct.apisrvURL == "" {
		return
	}

	// create context
	ctx, cancel := context.WithCancel(context.Background())
	ct.Lock()
	ct.watchCancel[kind] = cancel
	ct.Unlock()
	opts := api.ListWatchOptions{}

	// setup wait group
	ct.waitGrp.Add(1)
	defer ct.waitGrp.Done()

	// loop forever
	for {
		// create a grpc client
		apicl, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, ct.logger, rpckit.WithBalancer(ct.balancer))
		if err != nil {
			log.Warnf("Failed to connect to gRPC server [%s]\n", ct.apisrvURL)
		} else {
			log.Infof("API client connected {%+v}", apicl)

			// MirrorSession object watcher
			wt, werr := apicl.MonitoringV1().MirrorSession().Watch(ctx, &opts)
			if werr != nil {
				log.Errorf("Failed to start %s watch (%s)\n", kind, werr)
				return
			}
			ct.Lock()
			ct.watchers[kind] = wt
			ct.Unlock()

			// perform a diff with API server and local cache
			time.Sleep(time.Millisecond * 100)
			ct.diffMirrorSession(apicl)

			// handle api server watch events
		innerLoop:
			for {
				// wait for events
				select {
				case evt, ok := <-wt.EventChan():
					if !ok {
						log.Error("Error receiving from apisrv watcher")
						break innerLoop
					}

					// handle event
					ct.handleMirrorSessionEvent(evt)
				}
			}
			apicl.Close()
		}

		// if stop flag is set, we are done
		if ct.stoped {
			log.Infof("Exiting API server watcher")
			return
		}

		// wait for a second and retry connecting to api server
		time.Sleep(time.Second)
	}
}

// WatchMirrorSession starts watch on MirrorSession object
func (ct *ctrlerCtx) WatchMirrorSession(handler MirrorSessionHandler) error {
	kind := "MirrorSession"

	ct.Lock()
	defer ct.Unlock()

	// see if we already have a watcher
	_, ok := ct.watchers[kind]
	if ok {
		return fmt.Errorf("MirrorSession watcher already exists")
	}

	// save handler
	ct.handlers[kind] = handler

	// run MirrorSession watcher in a go routine
	go ct.runMirrorSessionWatcher()

	return nil
}

// MirrorSessionAPI returns
type MirrorSessionAPI interface {
	Create(obj *monitoring.MirrorSession) error
	Update(obj *monitoring.MirrorSession) error
	Delete(obj *monitoring.MirrorSession) error
	List() []*MirrorSession
	Watch(handler MirrorSessionHandler) error
}

// dummy struct that implements MirrorSessionAPI
type mirrorsessionAPI struct {
	ct *ctrlerCtx
}

// Create creates MirrorSession object
func (api *mirrorsessionAPI) Create(obj *monitoring.MirrorSession) error {
	return api.ct.handleMirrorSessionEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Created})
}

// Update triggers update on MirrorSession object
func (api *mirrorsessionAPI) Update(obj *monitoring.MirrorSession) error {
	return api.ct.handleMirrorSessionEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Updated})
}

// Delete deletes MirrorSession object
func (api *mirrorsessionAPI) Delete(obj *monitoring.MirrorSession) error {
	return api.ct.handleMirrorSessionEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Deleted})
}

// List returns a list of all MirrorSession objects
func (api *mirrorsessionAPI) List() []*MirrorSession {
	var objlist []*MirrorSession

	objs := api.ct.ListObjects("MirrorSession")
	for _, obj := range objs {
		switch tp := obj.(type) {
		case *MirrorSession:
			eobj := obj.(*MirrorSession)
			objlist = append(objlist, eobj)
		default:
			log.Fatalf("Got invalid object type %v while looking for MirrorSession", tp)
		}
	}

	return objlist
}

// Watch sets up a event handlers for MirrorSession object
func (api *mirrorsessionAPI) Watch(handler MirrorSessionHandler) error {
	return api.ct.WatchMirrorSession(handler)
}

// MirrorSession returns MirrorSessionAPI
func (ct *ctrlerCtx) MirrorSession() MirrorSessionAPI {
	return &mirrorsessionAPI{ct: ct}
}

// TroubleshootingSession is a wrapper object that implements additional functionality
type TroubleshootingSession struct {
	sync.Mutex
	monitoring.TroubleshootingSession
	HandlerCtx interface{} // additional state handlers can store
	ctrler     *ctrlerCtx  // reference back to the controller instance
}

func (obj *TroubleshootingSession) Write() error {
	// if there is no API server to connect to, we are done
	if (obj.ctrler == nil) || (obj.ctrler.resolver == nil) || obj.ctrler.apisrvURL == "" {
		return nil
	}

	apicl, err := obj.ctrler.apiClient()
	if err != nil {
		log.Errorf("Error creating API server clent. Err: %v", err)
		return err
	}

	// write to api server
	if obj.ObjectMeta.ResourceVersion != "" {
		nobj := *obj
		// FIXME: clear the resource version till we figure out CAS semantics
		nobj.ObjectMeta.ResourceVersion = ""

		// update it
		_, err = apicl.MonitoringV1().TroubleshootingSession().Update(context.Background(), &nobj.TroubleshootingSession)
	} else {
		//  create
		_, err = apicl.MonitoringV1().TroubleshootingSession().Create(context.Background(), &obj.TroubleshootingSession)
	}

	return nil
}

// TroubleshootingSessionHandler is the event handler for TroubleshootingSession object
type TroubleshootingSessionHandler interface {
	OnTroubleshootingSessionCreate(obj *TroubleshootingSession) error
	OnTroubleshootingSessionUpdate(obj *TroubleshootingSession) error
	OnTroubleshootingSessionDelete(obj *TroubleshootingSession) error
}

// handleTroubleshootingSessionEvent handles TroubleshootingSession events from watcher
func (ct *ctrlerCtx) handleTroubleshootingSessionEvent(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *monitoring.TroubleshootingSession:
		eobj := evt.Object.(*monitoring.TroubleshootingSession)
		kind := "TroubleshootingSession"

		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		handler, ok := ct.handlers[kind]
		if !ok {
			log.Fatalf("Cant find the handler for %s", kind)
		}
		troubleshootingsessionHandler := handler.(TroubleshootingSessionHandler)
		// handle based on event type
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			fobj, err := ct.findObject(kind, eobj.GetKey())
			if err != nil {
				obj := &TroubleshootingSession{
					TroubleshootingSession: *eobj,
					HandlerCtx:             nil,
					ctrler:                 ct,
				}
				ct.addObject(kind, obj.GetKey(), obj)
				// call the event handler
				obj.Lock()
				err = troubleshootingsessionHandler.OnTroubleshootingSessionCreate(obj)
				obj.Unlock()
				if err != nil {
					log.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					ct.delObject(kind, eobj.GetKey())
					return err
				}
			} else {
				obj := fobj.(*TroubleshootingSession)
				obj.ObjectMeta = eobj.ObjectMeta

				// see if it changed
				if _, ok := ref.ObjDiff(obj.Spec, eobj.Spec); ok {
					obj.Spec = eobj.Spec
					// call the event handler
					obj.Lock()
					err = troubleshootingsessionHandler.OnTroubleshootingSessionUpdate(obj)
					obj.Unlock()
					if err != nil {
						log.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
						return err
					}
				}
			}
		case kvstore.Deleted:
			fobj, err := ct.findObject(kind, eobj.GetKey())
			if err != nil {
				log.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
				return err
			}

			obj := fobj.(*TroubleshootingSession)

			// Call the event reactor
			obj.Lock()
			err = troubleshootingsessionHandler.OnTroubleshootingSessionDelete(obj)
			obj.Unlock()
			if err != nil {
				log.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
				return err
			}

			ct.delObject(kind, eobj.GetKey())
		}
	default:
		log.Fatalf("API watcher Found object of invalid type: %v on TroubleshootingSession watch channel", tp)
	}

	return nil
}

// diffTroubleshootingSession does a diff of TroubleshootingSession objects between local cache and API server
func (ct *ctrlerCtx) diffTroubleshootingSession(apicl apiclient.Services) {
	opts := api.ListWatchOptions{}

	// get a list of all objects from API server
	objlist, err := apicl.MonitoringV1().TroubleshootingSession().List(context.Background(), &opts)
	if err != nil {
		log.Errorf("Error getting a list of objects. Err: %v", err)
		return
	}

	// build an object map
	objmap := make(map[string]*monitoring.TroubleshootingSession)
	for _, obj := range objlist {
		objmap[obj.GetKey()] = obj
	}

	// if an object is in our local cache and not in API server, trigger delete for it
	for _, obj := range ct.TroubleshootingSession().List() {
		_, ok := objmap[obj.GetKey()]
		if !ok {
			evt := kvstore.WatchEvent{
				Type:   kvstore.Deleted,
				Key:    obj.GetKey(),
				Object: &obj.TroubleshootingSession,
			}
			ct.handleTroubleshootingSessionEvent(&evt)
		}
	}

	// trigger create event for all others
	for _, obj := range objlist {
		evt := kvstore.WatchEvent{
			Type:   kvstore.Created,
			Key:    obj.GetKey(),
			Object: obj,
		}
		ct.handleTroubleshootingSessionEvent(&evt)
	}
}

func (ct *ctrlerCtx) runTroubleshootingSessionWatcher() {
	kind := "TroubleshootingSession"

	// if there is no API server to connect to, we are done
	if (ct.resolver == nil) || ct.apisrvURL == "" {
		return
	}

	// create context
	ctx, cancel := context.WithCancel(context.Background())
	ct.Lock()
	ct.watchCancel[kind] = cancel
	ct.Unlock()
	opts := api.ListWatchOptions{}

	// setup wait group
	ct.waitGrp.Add(1)
	defer ct.waitGrp.Done()

	// loop forever
	for {
		// create a grpc client
		apicl, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, ct.logger, rpckit.WithBalancer(ct.balancer))
		if err != nil {
			log.Warnf("Failed to connect to gRPC server [%s]\n", ct.apisrvURL)
		} else {
			log.Infof("API client connected {%+v}", apicl)

			// TroubleshootingSession object watcher
			wt, werr := apicl.MonitoringV1().TroubleshootingSession().Watch(ctx, &opts)
			if werr != nil {
				log.Errorf("Failed to start %s watch (%s)\n", kind, werr)
				return
			}
			ct.Lock()
			ct.watchers[kind] = wt
			ct.Unlock()

			// perform a diff with API server and local cache
			time.Sleep(time.Millisecond * 100)
			ct.diffTroubleshootingSession(apicl)

			// handle api server watch events
		innerLoop:
			for {
				// wait for events
				select {
				case evt, ok := <-wt.EventChan():
					if !ok {
						log.Error("Error receiving from apisrv watcher")
						break innerLoop
					}

					// handle event
					ct.handleTroubleshootingSessionEvent(evt)
				}
			}
			apicl.Close()
		}

		// if stop flag is set, we are done
		if ct.stoped {
			log.Infof("Exiting API server watcher")
			return
		}

		// wait for a second and retry connecting to api server
		time.Sleep(time.Second)
	}
}

// WatchTroubleshootingSession starts watch on TroubleshootingSession object
func (ct *ctrlerCtx) WatchTroubleshootingSession(handler TroubleshootingSessionHandler) error {
	kind := "TroubleshootingSession"

	ct.Lock()
	defer ct.Unlock()

	// see if we already have a watcher
	_, ok := ct.watchers[kind]
	if ok {
		return fmt.Errorf("TroubleshootingSession watcher already exists")
	}

	// save handler
	ct.handlers[kind] = handler

	// run TroubleshootingSession watcher in a go routine
	go ct.runTroubleshootingSessionWatcher()

	return nil
}

// TroubleshootingSessionAPI returns
type TroubleshootingSessionAPI interface {
	Create(obj *monitoring.TroubleshootingSession) error
	Update(obj *monitoring.TroubleshootingSession) error
	Delete(obj *monitoring.TroubleshootingSession) error
	List() []*TroubleshootingSession
	Watch(handler TroubleshootingSessionHandler) error
}

// dummy struct that implements TroubleshootingSessionAPI
type troubleshootingsessionAPI struct {
	ct *ctrlerCtx
}

// Create creates TroubleshootingSession object
func (api *troubleshootingsessionAPI) Create(obj *monitoring.TroubleshootingSession) error {
	return api.ct.handleTroubleshootingSessionEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Created})
}

// Update triggers update on TroubleshootingSession object
func (api *troubleshootingsessionAPI) Update(obj *monitoring.TroubleshootingSession) error {
	return api.ct.handleTroubleshootingSessionEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Updated})
}

// Delete deletes TroubleshootingSession object
func (api *troubleshootingsessionAPI) Delete(obj *monitoring.TroubleshootingSession) error {
	return api.ct.handleTroubleshootingSessionEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Deleted})
}

// List returns a list of all TroubleshootingSession objects
func (api *troubleshootingsessionAPI) List() []*TroubleshootingSession {
	var objlist []*TroubleshootingSession

	objs := api.ct.ListObjects("TroubleshootingSession")
	for _, obj := range objs {
		switch tp := obj.(type) {
		case *TroubleshootingSession:
			eobj := obj.(*TroubleshootingSession)
			objlist = append(objlist, eobj)
		default:
			log.Fatalf("Got invalid object type %v while looking for TroubleshootingSession", tp)
		}
	}

	return objlist
}

// Watch sets up a event handlers for TroubleshootingSession object
func (api *troubleshootingsessionAPI) Watch(handler TroubleshootingSessionHandler) error {
	return api.ct.WatchTroubleshootingSession(handler)
}

// TroubleshootingSession returns TroubleshootingSessionAPI
func (ct *ctrlerCtx) TroubleshootingSession() TroubleshootingSessionAPI {
	return &troubleshootingsessionAPI{ct: ct}
}

// TechSupportRequest is a wrapper object that implements additional functionality
type TechSupportRequest struct {
	sync.Mutex
	monitoring.TechSupportRequest
	HandlerCtx interface{} // additional state handlers can store
	ctrler     *ctrlerCtx  // reference back to the controller instance
}

func (obj *TechSupportRequest) Write() error {
	// if there is no API server to connect to, we are done
	if (obj.ctrler == nil) || (obj.ctrler.resolver == nil) || obj.ctrler.apisrvURL == "" {
		return nil
	}

	apicl, err := obj.ctrler.apiClient()
	if err != nil {
		log.Errorf("Error creating API server clent. Err: %v", err)
		return err
	}

	// write to api server
	if obj.ObjectMeta.ResourceVersion != "" {
		nobj := *obj
		// FIXME: clear the resource version till we figure out CAS semantics
		nobj.ObjectMeta.ResourceVersion = ""

		// update it
		_, err = apicl.MonitoringV1().TechSupportRequest().Update(context.Background(), &nobj.TechSupportRequest)
	} else {
		//  create
		_, err = apicl.MonitoringV1().TechSupportRequest().Create(context.Background(), &obj.TechSupportRequest)
	}

	return nil
}

// TechSupportRequestHandler is the event handler for TechSupportRequest object
type TechSupportRequestHandler interface {
	OnTechSupportRequestCreate(obj *TechSupportRequest) error
	OnTechSupportRequestUpdate(obj *TechSupportRequest) error
	OnTechSupportRequestDelete(obj *TechSupportRequest) error
}

// handleTechSupportRequestEvent handles TechSupportRequest events from watcher
func (ct *ctrlerCtx) handleTechSupportRequestEvent(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *monitoring.TechSupportRequest:
		eobj := evt.Object.(*monitoring.TechSupportRequest)
		kind := "TechSupportRequest"

		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		handler, ok := ct.handlers[kind]
		if !ok {
			log.Fatalf("Cant find the handler for %s", kind)
		}
		techsupportrequestHandler := handler.(TechSupportRequestHandler)
		// handle based on event type
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			fobj, err := ct.findObject(kind, eobj.GetKey())
			if err != nil {
				obj := &TechSupportRequest{
					TechSupportRequest: *eobj,
					HandlerCtx:         nil,
					ctrler:             ct,
				}
				ct.addObject(kind, obj.GetKey(), obj)
				// call the event handler
				obj.Lock()
				err = techsupportrequestHandler.OnTechSupportRequestCreate(obj)
				obj.Unlock()
				if err != nil {
					log.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					ct.delObject(kind, eobj.GetKey())
					return err
				}
			} else {
				obj := fobj.(*TechSupportRequest)
				obj.ObjectMeta = eobj.ObjectMeta

				// see if it changed
				if _, ok := ref.ObjDiff(obj.Spec, eobj.Spec); ok {
					obj.Spec = eobj.Spec
					// call the event handler
					obj.Lock()
					err = techsupportrequestHandler.OnTechSupportRequestUpdate(obj)
					obj.Unlock()
					if err != nil {
						log.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
						return err
					}
				}
			}
		case kvstore.Deleted:
			fobj, err := ct.findObject(kind, eobj.GetKey())
			if err != nil {
				log.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
				return err
			}

			obj := fobj.(*TechSupportRequest)

			// Call the event reactor
			obj.Lock()
			err = techsupportrequestHandler.OnTechSupportRequestDelete(obj)
			obj.Unlock()
			if err != nil {
				log.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
				return err
			}

			ct.delObject(kind, eobj.GetKey())
		}
	default:
		log.Fatalf("API watcher Found object of invalid type: %v on TechSupportRequest watch channel", tp)
	}

	return nil
}

// diffTechSupportRequest does a diff of TechSupportRequest objects between local cache and API server
func (ct *ctrlerCtx) diffTechSupportRequest(apicl apiclient.Services) {
	opts := api.ListWatchOptions{}

	// get a list of all objects from API server
	objlist, err := apicl.MonitoringV1().TechSupportRequest().List(context.Background(), &opts)
	if err != nil {
		log.Errorf("Error getting a list of objects. Err: %v", err)
		return
	}

	// build an object map
	objmap := make(map[string]*monitoring.TechSupportRequest)
	for _, obj := range objlist {
		objmap[obj.GetKey()] = obj
	}

	// if an object is in our local cache and not in API server, trigger delete for it
	for _, obj := range ct.TechSupportRequest().List() {
		_, ok := objmap[obj.GetKey()]
		if !ok {
			evt := kvstore.WatchEvent{
				Type:   kvstore.Deleted,
				Key:    obj.GetKey(),
				Object: &obj.TechSupportRequest,
			}
			ct.handleTechSupportRequestEvent(&evt)
		}
	}

	// trigger create event for all others
	for _, obj := range objlist {
		evt := kvstore.WatchEvent{
			Type:   kvstore.Created,
			Key:    obj.GetKey(),
			Object: obj,
		}
		ct.handleTechSupportRequestEvent(&evt)
	}
}

func (ct *ctrlerCtx) runTechSupportRequestWatcher() {
	kind := "TechSupportRequest"

	// if there is no API server to connect to, we are done
	if (ct.resolver == nil) || ct.apisrvURL == "" {
		return
	}

	// create context
	ctx, cancel := context.WithCancel(context.Background())
	ct.Lock()
	ct.watchCancel[kind] = cancel
	ct.Unlock()
	opts := api.ListWatchOptions{}

	// setup wait group
	ct.waitGrp.Add(1)
	defer ct.waitGrp.Done()

	// loop forever
	for {
		// create a grpc client
		apicl, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, ct.logger, rpckit.WithBalancer(ct.balancer))
		if err != nil {
			log.Warnf("Failed to connect to gRPC server [%s]\n", ct.apisrvURL)
		} else {
			log.Infof("API client connected {%+v}", apicl)

			// TechSupportRequest object watcher
			wt, werr := apicl.MonitoringV1().TechSupportRequest().Watch(ctx, &opts)
			if werr != nil {
				log.Errorf("Failed to start %s watch (%s)\n", kind, werr)
				return
			}
			ct.Lock()
			ct.watchers[kind] = wt
			ct.Unlock()

			// perform a diff with API server and local cache
			time.Sleep(time.Millisecond * 100)
			ct.diffTechSupportRequest(apicl)

			// handle api server watch events
		innerLoop:
			for {
				// wait for events
				select {
				case evt, ok := <-wt.EventChan():
					if !ok {
						log.Error("Error receiving from apisrv watcher")
						break innerLoop
					}

					// handle event
					ct.handleTechSupportRequestEvent(evt)
				}
			}
			apicl.Close()
		}

		// if stop flag is set, we are done
		if ct.stoped {
			log.Infof("Exiting API server watcher")
			return
		}

		// wait for a second and retry connecting to api server
		time.Sleep(time.Second)
	}
}

// WatchTechSupportRequest starts watch on TechSupportRequest object
func (ct *ctrlerCtx) WatchTechSupportRequest(handler TechSupportRequestHandler) error {
	kind := "TechSupportRequest"

	ct.Lock()
	defer ct.Unlock()

	// see if we already have a watcher
	_, ok := ct.watchers[kind]
	if ok {
		return fmt.Errorf("TechSupportRequest watcher already exists")
	}

	// save handler
	ct.handlers[kind] = handler

	// run TechSupportRequest watcher in a go routine
	go ct.runTechSupportRequestWatcher()

	return nil
}

// TechSupportRequestAPI returns
type TechSupportRequestAPI interface {
	Create(obj *monitoring.TechSupportRequest) error
	Update(obj *monitoring.TechSupportRequest) error
	Delete(obj *monitoring.TechSupportRequest) error
	List() []*TechSupportRequest
	Watch(handler TechSupportRequestHandler) error
}

// dummy struct that implements TechSupportRequestAPI
type techsupportrequestAPI struct {
	ct *ctrlerCtx
}

// Create creates TechSupportRequest object
func (api *techsupportrequestAPI) Create(obj *monitoring.TechSupportRequest) error {
	return api.ct.handleTechSupportRequestEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Created})
}

// Update triggers update on TechSupportRequest object
func (api *techsupportrequestAPI) Update(obj *monitoring.TechSupportRequest) error {
	return api.ct.handleTechSupportRequestEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Updated})
}

// Delete deletes TechSupportRequest object
func (api *techsupportrequestAPI) Delete(obj *monitoring.TechSupportRequest) error {
	return api.ct.handleTechSupportRequestEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Deleted})
}

// List returns a list of all TechSupportRequest objects
func (api *techsupportrequestAPI) List() []*TechSupportRequest {
	var objlist []*TechSupportRequest

	objs := api.ct.ListObjects("TechSupportRequest")
	for _, obj := range objs {
		switch tp := obj.(type) {
		case *TechSupportRequest:
			eobj := obj.(*TechSupportRequest)
			objlist = append(objlist, eobj)
		default:
			log.Fatalf("Got invalid object type %v while looking for TechSupportRequest", tp)
		}
	}

	return objlist
}

// Watch sets up a event handlers for TechSupportRequest object
func (api *techsupportrequestAPI) Watch(handler TechSupportRequestHandler) error {
	return api.ct.WatchTechSupportRequest(handler)
}

// TechSupportRequest returns TechSupportRequestAPI
func (ct *ctrlerCtx) TechSupportRequest() TechSupportRequestAPI {
	return &techsupportrequestAPI{ct: ct}
}
