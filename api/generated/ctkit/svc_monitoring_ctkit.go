// Code generated by protoc-gen-grpc-pensando DO NOT EDIT.

/*
Package ctkit is a auto generated package.
Input file: svc_monitoring.proto
*/
package ctkit

import (
	"context"
	"errors"
	"fmt"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/pensando/sw/api"
	"github.com/pensando/sw/api/generated/apiclient"
	"github.com/pensando/sw/api/generated/monitoring"
	apiintf "github.com/pensando/sw/api/interfaces"
	"github.com/pensando/sw/venice/globals"
	"github.com/pensando/sw/venice/utils/balancer"
	"github.com/pensando/sw/venice/utils/kvstore"
	"github.com/pensando/sw/venice/utils/log"
	"github.com/pensando/sw/venice/utils/rpckit"
	"github.com/pensando/sw/venice/utils/runtime"
	"github.com/pensando/sw/venice/utils/shardworkers"
)

// EventPolicy is a wrapper object that implements additional functionality
type EventPolicy struct {
	sync.Mutex
	monitoring.EventPolicy
	HandlerCtx interface{} // additional state handlers can store
	ctrler     *ctrlerCtx  // reference back to the controller instance
	internal   bool
}

func (obj *EventPolicy) SetInternal() {
	obj.internal = true
}

func (obj *EventPolicy) Write() error {
	// if there is no API server to connect to, we are done
	if (obj.ctrler == nil) || (obj.ctrler.resolver == nil) || obj.ctrler.apisrvURL == "" {
		return nil
	}

	apicl, err := obj.ctrler.apiClient()
	if err != nil {
		obj.ctrler.logger.Errorf("Error creating API server clent. Err: %v", err)
		return err
	}

	obj.ctrler.stats.Counter("EventPolicy_Writes").Inc()

	// write to api server
	if obj.ObjectMeta.ResourceVersion != "" {
		// update it
		for i := 0; i < maxApisrvWriteRetry; i++ {
			_, err = apicl.MonitoringV1().EventPolicy().UpdateStatus(context.Background(), &obj.EventPolicy)
			if err == nil {
				break
			}
			time.Sleep(time.Millisecond * 100)
		}
	} else {
		//  create
		_, err = apicl.MonitoringV1().EventPolicy().Create(context.Background(), &obj.EventPolicy)
	}

	return nil
}

// EventPolicyHandler is the event handler for EventPolicy object
type EventPolicyHandler interface {
	OnEventPolicyCreate(obj *EventPolicy) error
	OnEventPolicyUpdate(oldObj *EventPolicy, newObj *monitoring.EventPolicy) error
	OnEventPolicyDelete(obj *EventPolicy) error
	GetEventPolicyWatchOptions() *api.ListWatchOptions
	OnEventPolicyReconnect()
}

// OnEventPolicyCreate is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnEventPolicyCreate(obj *EventPolicy) error {
	log.Info("OnEventPolicyCreate is not implemented")
	return nil
}

// OnEventPolicyUpdate is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnEventPolicyUpdate(oldObj *EventPolicy, newObj *monitoring.EventPolicy) error {
	log.Info("OnEventPolicyUpdate is not implemented")
	return nil
}

// OnEventPolicyDelete is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnEventPolicyDelete(obj *EventPolicy) error {
	log.Info("OnEventPolicyDelete is not implemented")
	return nil
}

// GetEventPolicyWatchOptions is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) GetEventPolicyWatchOptions() *api.ListWatchOptions {
	log.Info("GetEventPolicyWatchOptions is not implemented")
	opts := &api.ListWatchOptions{}
	return opts
}

// OnEventPolicyReconnect is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnEventPolicyReconnect() {
	log.Info("OnEventPolicyReconnect is not implemented")
	return
}

// handleEventPolicyEvent handles EventPolicy events from watcher
func (ct *ctrlerCtx) handleEventPolicyEvent(evt *kvstore.WatchEvent) error {

	if ct.objResolver == nil {
		return ct.handleEventPolicyEventNoResolver(evt)
	}

	switch tp := evt.Object.(type) {
	case *monitoring.EventPolicy:
		eobj := evt.Object.(*monitoring.EventPolicy)
		kind := "EventPolicy"

		eobj.ApplyStorageTransformer(context.Background(), true /*encrypt*/)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		eobj.ApplyStorageTransformer(context.Background(), false /*decrypt*/)

		ctx := &eventpolicyCtx{event: evt.Type,
			obj: &EventPolicy{EventPolicy: *eobj, ctrler: ct}}

		var err error
		switch evt.Type {
		case kvstore.Created:
			err = ct.processAdd(ctx)
		case kvstore.Updated:
			err = ct.processUpdate(ctx)
		case kvstore.Deleted:
			err = ct.processDelete(ctx)
		}
		return err
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on EventPolicy watch channel", tp)
	}

	return nil
}

// handleEventPolicyEventNoResolver handles EventPolicy events from watcher
func (ct *ctrlerCtx) handleEventPolicyEventNoResolver(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *monitoring.EventPolicy:
		eobj := evt.Object.(*monitoring.EventPolicy)
		kind := "EventPolicy"

		eobj.ApplyStorageTransformer(context.Background(), true /*encrypt*/)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		eobj.ApplyStorageTransformer(context.Background(), false /*decrypt*/)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		eventpolicyHandler := handler.(EventPolicyHandler)
		// handle based on event type
		ctrlCtx := &eventpolicyCtx{event: evt.Type, obj: &EventPolicy{EventPolicy: *eobj, ctrler: ct}}
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			fobj, err := ct.getObject(kind, ctrlCtx.GetKey())
			if err != nil {
				ct.addObject(ctrlCtx)
				ct.stats.Counter("EventPolicy_Created_Events").Inc()

				// call the event handler
				ctrlCtx.Lock()
				err = eventpolicyHandler.OnEventPolicyCreate(ctrlCtx.obj)
				ctrlCtx.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctrlCtx.obj.GetObjectMeta(), err)
					ct.delObject(kind, ctrlCtx.GetKey())
					return err
				}
			} else {
				fResVer, fErr := strconv.ParseInt(fobj.GetResourceVersion(), 10, 64)
				eResVer, eErr := strconv.ParseInt(eobj.GetResourceVersion(), 10, 64)
				if ct.resolver != nil && fErr == nil && eErr == nil && fResVer >= eResVer {
					// Event already processed.
					ct.logger.Infof("Skipping update due to old resource version")
					return nil
				}
				ctrlCtx := fobj.(*eventpolicyCtx)
				ct.stats.Counter("EventPolicy_Updated_Events").Inc()
				ctrlCtx.Lock()
				p := monitoring.EventPolicy{Spec: eobj.Spec,
					ObjectMeta: eobj.ObjectMeta,
					TypeMeta:   eobj.TypeMeta,
					Status:     eobj.Status}

				err = eventpolicyHandler.OnEventPolicyUpdate(ctrlCtx.obj, &p)
				ctrlCtx.obj.EventPolicy = *eobj
				ctrlCtx.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctrlCtx.obj.GetObjectMeta(), err)
					return err
				}

			}
		case kvstore.Deleted:
			ctrlCtx := &eventpolicyCtx{event: evt.Type, obj: &EventPolicy{EventPolicy: *eobj, ctrler: ct}}
			fobj, err := ct.findObject(kind, ctrlCtx.GetKey())
			if err != nil {
				ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
				return err
			}

			obj := fobj.(*EventPolicy)
			ct.stats.Counter("EventPolicy_Deleted_Events").Inc()
			obj.Lock()
			err = eventpolicyHandler.OnEventPolicyDelete(obj)
			obj.Unlock()
			if err != nil {
				ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj.GetObjectMeta(), err)
			}
			ct.delObject(kind, ctrlCtx.GetKey())
			return nil

		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on EventPolicy watch channel", tp)
	}

	return nil
}

type eventpolicyCtx struct {
	ctkitBaseCtx
	event kvstore.WatchEventType
	obj   *EventPolicy //
	//   newObj     *monitoring.EventPolicy //update
	newObj *eventpolicyCtx //update
}

func (ctx *eventpolicyCtx) References() map[string]apiintf.ReferenceObj {
	if ctx.references == nil {
		resp := make(map[string]apiintf.ReferenceObj)
		ctx.references = resp
		ctx.obj.References(ctx.obj.GetObjectMeta().Name, ctx.obj.GetObjectMeta().Namespace, resp)
		ctx.obj.ctrler.filterOutRefs(ctx)
	}
	return ctx.references
}

func (ctx *eventpolicyCtx) GetKey() string {
	return ctx.obj.MakeKey("monitoring")

}

func (ctx *eventpolicyCtx) IsInternal() bool {
	return ctx.obj.internal
}

func (ctx *eventpolicyCtx) GetKind() string {
	return ctx.obj.GetKind()
}

func (ctx *eventpolicyCtx) GetResourceVersion() string {
	return ctx.obj.GetResourceVersion()
}

func (ctx *eventpolicyCtx) SetEvent(event kvstore.WatchEventType) {
	ctx.event = event
}

func (ctx *eventpolicyCtx) SetNewObj(newObj apiintf.CtkitObject) {
	if newObj == nil {
		ctx.newObj = nil
	} else {
		ctx.newObj = newObj.(*eventpolicyCtx)
		ctx.newObj.obj.HandlerCtx = ctx.obj.HandlerCtx
		ctx.references = newObj.References()
	}
}

func (ctx *eventpolicyCtx) GetNewObj() apiintf.CtkitObject {
	return ctx.newObj
}

func (ctx *eventpolicyCtx) Copy(obj apiintf.CtkitObject) {
	ctx.obj.EventPolicy = obj.(*eventpolicyCtx).obj.EventPolicy
	ctx.SetWatchTs(obj.GetWatchTs())
}

func (ctx *eventpolicyCtx) Lock() {
	ctx.obj.Lock()
}

func (ctx *eventpolicyCtx) Unlock() {
	ctx.obj.Unlock()
}

func (ctx *eventpolicyCtx) GetObjectMeta() *api.ObjectMeta {
	return ctx.obj.GetObjectMeta()
}

func (ctx *eventpolicyCtx) RuntimeObject() runtime.Object {
	var v interface{}
	v = ctx.obj
	return v.(runtime.Object)
}

func (ctx *eventpolicyCtx) WorkFunc(context context.Context) error {
	var err error
	evt := ctx.event
	ct := ctx.obj.ctrler
	kind := "EventPolicy"
	ct.Lock()
	handler, ok := ct.handlers[kind]
	ct.Unlock()
	if !ok {
		ct.logger.Fatalf("Cant find the handler for %s", kind)
	}
	eventpolicyHandler := handler.(EventPolicyHandler)
	switch evt {
	case kvstore.Created:
		ctx.obj.Lock()
		err = eventpolicyHandler.OnEventPolicyCreate(ctx.obj)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctx.obj.GetObjectMeta(), err)
			ctx.SetEvent(kvstore.Deleted)
		}
	case kvstore.Updated:
		ct.stats.Counter("EventPolicy_Updated_Events").Inc()
		ctx.obj.Lock()
		p := monitoring.EventPolicy{Spec: ctx.newObj.obj.Spec,
			ObjectMeta: ctx.newObj.obj.ObjectMeta,
			TypeMeta:   ctx.newObj.obj.TypeMeta,
			Status:     ctx.newObj.obj.Status}
		err = eventpolicyHandler.OnEventPolicyUpdate(ctx.obj, &p)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctx.obj.GetObjectMeta(), err)
			ctx.SetEvent(kvstore.Deleted)
		}
	case kvstore.Deleted:
		ctx.obj.Lock()
		err = eventpolicyHandler.OnEventPolicyDelete(ctx.obj)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error deleting %s %+v. Err: %v", kind, ctx.obj.GetObjectMeta(), err)
		}
	}
	ct.resolveObject(ctx.event, ctx)
	return nil
}

// handleEventPolicyEventParallel handles EventPolicy events from watcher
func (ct *ctrlerCtx) handleEventPolicyEventParallel(evt *kvstore.WatchEvent) error {

	if ct.objResolver == nil {
		return ct.handleEventPolicyEventParallelWithNoResolver(evt)
	}

	switch tp := evt.Object.(type) {
	case *monitoring.EventPolicy:
		eobj := evt.Object.(*monitoring.EventPolicy)
		kind := "EventPolicy"

		eobj.ApplyStorageTransformer(context.Background(), true /*encrypt*/)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		eobj.ApplyStorageTransformer(context.Background(), false /*decrypt*/)

		ctx := &eventpolicyCtx{event: evt.Type, obj: &EventPolicy{EventPolicy: *eobj, ctrler: ct}}
		ctx.SetWatchTs(evt.WatchTS)

		var err error
		switch evt.Type {
		case kvstore.Created:
			err = ct.processAdd(ctx)
		case kvstore.Updated:
			err = ct.processUpdate(ctx)
		case kvstore.Deleted:
			err = ct.processDelete(ctx)
		}
		return err
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on EventPolicy watch channel", tp)
	}

	return nil
}

// handleEventPolicyEventParallel handles EventPolicy events from watcher
func (ct *ctrlerCtx) handleEventPolicyEventParallelWithNoResolver(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *monitoring.EventPolicy:
		eobj := evt.Object.(*monitoring.EventPolicy)
		kind := "EventPolicy"

		eobj.ApplyStorageTransformer(context.Background(), true /*encrypt*/)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		eobj.ApplyStorageTransformer(context.Background(), false /*decrypt*/)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		eventpolicyHandler := handler.(EventPolicyHandler)
		// handle based on event type
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			workFunc := func(ctx context.Context, ctrlCtx shardworkers.WorkObj) error {
				var err error
				workCtx := ctrlCtx.(*eventpolicyCtx)
				eobj := workCtx.obj
				fobj, err := ct.getObject(kind, workCtx.GetKey())
				if err != nil {
					ct.addObject(workCtx)
					ct.stats.Counter("EventPolicy_Created_Events").Inc()
					eobj.Lock()
					err = eventpolicyHandler.OnEventPolicyCreate(eobj)
					eobj.Unlock()
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, eobj.GetObjectMeta(), err)
						ct.delObject(kind, workCtx.GetKey())
					}
				} else {
					workCtx = fobj.(*eventpolicyCtx)
					obj := workCtx.obj
					ct.stats.Counter("EventPolicy_Updated_Events").Inc()
					obj.Lock()
					p := monitoring.EventPolicy{Spec: eobj.Spec,
						ObjectMeta: eobj.ObjectMeta,
						TypeMeta:   eobj.TypeMeta,
						Status:     eobj.Status}

					err = eventpolicyHandler.OnEventPolicyUpdate(obj, &p)
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj.GetObjectMeta(), err)
					} else {
						workCtx.obj.EventPolicy = p
					}
					obj.Unlock()
				}
				workCtx.SetWatchTs(evt.WatchTS)
				return err
			}
			ctrlCtx := &eventpolicyCtx{event: evt.Type, obj: &EventPolicy{EventPolicy: *eobj, ctrler: ct}}
			ct.runFunction("EventPolicy", ctrlCtx, workFunc)
		case kvstore.Deleted:
			workFunc := func(ctx context.Context, ctrlCtx shardworkers.WorkObj) error {
				var err error
				workCtx := ctrlCtx.(*eventpolicyCtx)
				eobj := workCtx.obj
				fobj, err := ct.findObject(kind, workCtx.GetKey())
				if err != nil {
					ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
					return err
				}
				obj := fobj.(*EventPolicy)
				ct.stats.Counter("EventPolicy_Deleted_Events").Inc()
				obj.Lock()
				err = eventpolicyHandler.OnEventPolicyDelete(obj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj.GetObjectMeta(), err)
				}
				ct.delObject(kind, workCtx.GetKey())
				return nil
			}
			ctrlCtx := &eventpolicyCtx{event: evt.Type, obj: &EventPolicy{EventPolicy: *eobj, ctrler: ct}}
			ct.runFunction("EventPolicy", ctrlCtx, workFunc)
		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on EventPolicy watch channel", tp)
	}

	return nil
}

// diffEventPolicy does a diff of EventPolicy objects between local cache and API server
func (ct *ctrlerCtx) diffEventPolicy(apicl apiclient.Services) {
	opts := api.ListWatchOptions{}

	// get a list of all objects from API server
	objlist, err := apicl.MonitoringV1().EventPolicy().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Errorf("Error getting a list of objects. Err: %v", err)
		return
	}

	ct.logger.Infof("diffEventPolicy(): EventPolicyList returned %d objects", len(objlist))

	// build an object map
	objmap := make(map[string]*monitoring.EventPolicy)
	for _, obj := range objlist {
		objmap[obj.GetKey()] = obj
	}

	list, err := ct.EventPolicy().List(context.Background(), &opts)
	if err != nil && !strings.Contains(err.Error(), "not found in local cache") {
		ct.logger.Infof("Failed to get a list of objects. Err: %s", err)
		return
	}

	// if an object is in our local cache and not in API server, trigger delete for it
	for _, obj := range list {
		_, ok := objmap[obj.GetKey()]
		if !ok {
			ct.logger.Infof("diffEventPolicy(): Deleting existing object %#v since its not in apiserver", obj.GetKey())
			evt := kvstore.WatchEvent{
				Type:   kvstore.Deleted,
				Key:    obj.GetKey(),
				Object: &obj.EventPolicy,
			}
			ct.handleEventPolicyEvent(&evt)
		}
	}

	// trigger create event for all others
	for _, obj := range objlist {
		ct.logger.Infof("diffEventPolicy(): Adding object %#v", obj.GetKey())
		evt := kvstore.WatchEvent{
			Type:   kvstore.Created,
			Key:    obj.GetKey(),
			Object: obj,
		}
		ct.handleEventPolicyEvent(&evt)
	}
}

func (ct *ctrlerCtx) runEventPolicyWatcher() {
	kind := "EventPolicy"

	ct.Lock()
	handler, ok := ct.handlers[kind]
	ct.Unlock()
	if !ok {
		ct.logger.Fatalf("Cant find the handler for %s", kind)
	}
	eventpolicyHandler := handler.(EventPolicyHandler)

	opts := eventpolicyHandler.GetEventPolicyWatchOptions()

	// if there is no API server to connect to, we are done
	if (ct.resolver == nil) || ct.apisrvURL == "" {
		return
	}

	// create context
	ctx, cancel := context.WithCancel(context.Background())
	ct.Lock()
	ct.watchCancel[kind] = cancel
	ct.Unlock()
	logger := ct.logger.WithContext("submodule", "EventPolicyWatcher")
	for {
		if ctx.Err() != nil {
			return
		}

		apiclt, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
		// create a grpc client
		if err == nil {
			// Upon successful connection perform the diff, and start watch goroutine
			ct.diffEventPolicy(apiclt)
			break
		}

		logger.Warnf("Failed to connect to gRPC server [%s]\n", ct.apisrvURL)
		time.Sleep(time.Second)
	}

	// setup wait group
	ct.waitGrp.Add(1)

	// start a goroutine
	go func() {
		defer ct.waitGrp.Done()
		ct.stats.Counter("EventPolicy_Watch").Inc()
		defer ct.stats.Counter("EventPolicy_Watch").Dec()

		// loop forever
		for {
			// create a grpc client
			apicl, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
			if err != nil {
				logger.Warnf("Failed to connect to gRPC server [%s]\n", ct.apisrvURL)
				ct.stats.Counter("EventPolicy_ApiClientErr").Inc()
			} else {
				logger.Infof("API client connected {%+v}", apicl)

				// EventPolicy object watcher
				wt, werr := apicl.MonitoringV1().EventPolicy().Watch(ctx, opts)
				if werr != nil {
					select {
					case <-ctx.Done():
						logger.Infof("watch %s cancelled", kind)
						return
					default:
					}
					logger.Errorf("Failed to start %s watch (%s)\n", kind, werr)
					// wait for a second and retry connecting to api server
					apicl.Close()
					time.Sleep(time.Second)
					continue
				}
				ct.Lock()
				ct.watchers[kind] = wt
				ct.Unlock()

				// perform a diff with API server and local cache
				// Sleeping to give time for other apiclient's to reconnect
				// before calling reconnect handler
				time.Sleep(time.Second)
				ct.diffEventPolicy(apicl)
				eventpolicyHandler.OnEventPolicyReconnect()

				// handle api server watch events
			innerLoop:
				for {
					// wait for events
					select {
					case evt, ok := <-wt.EventChan():
						if !ok {
							logger.Error("Error receiving from apisrv watcher")
							ct.stats.Counter("EventPolicy_WatchErrors").Inc()
							break innerLoop
						}

						// handle event in parallel
						ct.handleEventPolicyEventParallel(evt)
					}
				}
				apicl.Close()
			}

			// if stop flag is set, we are done
			if ct.stoped {
				logger.Infof("Exiting API server watcher")
				return
			}

			// wait for a second and retry connecting to api server
			time.Sleep(time.Second)
		}
	}()
}

// WatchEventPolicy starts watch on EventPolicy object
func (ct *ctrlerCtx) WatchEventPolicy(handler EventPolicyHandler) error {
	kind := "EventPolicy"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchCancel[kind]
	ct.Unlock()
	if ok {
		return fmt.Errorf("EventPolicy watcher already exists")
	}

	// save handler
	ct.Lock()
	ct.handlers[kind] = handler
	ct.Unlock()

	// run EventPolicy watcher in a go routine
	ct.runEventPolicyWatcher()

	return nil
}

// StopWatchEventPolicy stops watch on EventPolicy object
func (ct *ctrlerCtx) StopWatchEventPolicy(handler EventPolicyHandler) error {
	kind := "EventPolicy"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchCancel[kind]
	ct.Unlock()
	if !ok {
		return fmt.Errorf("EventPolicy watcher does not exist")
	}

	ct.Lock()
	cancel, _ := ct.watchCancel[kind]
	cancel()
	if _, ok := ct.watchers[kind]; ok {
		delete(ct.watchers, kind)
	}
	delete(ct.watchCancel, kind)
	ct.Unlock()

	time.Sleep(100 * time.Millisecond)

	return nil
}

// EventPolicyAPI returns
type EventPolicyAPI interface {
	Create(obj *monitoring.EventPolicy) error
	SyncCreate(obj *monitoring.EventPolicy) error
	Update(obj *monitoring.EventPolicy) error
	SyncUpdate(obj *monitoring.EventPolicy) error
	Label(obj *api.Label) error
	Delete(obj *monitoring.EventPolicy) error
	Find(meta *api.ObjectMeta) (*EventPolicy, error)
	List(ctx context.Context, opts *api.ListWatchOptions) ([]*EventPolicy, error)
	ApisrvList(ctx context.Context, opts *api.ListWatchOptions) ([]*monitoring.EventPolicy, error)
	Watch(handler EventPolicyHandler) error
	ClearCache(handler EventPolicyHandler)
	StopWatch(handler EventPolicyHandler) error
}

// dummy struct that implements EventPolicyAPI
type eventpolicyAPI struct {
	ct *ctrlerCtx
}

// Create creates EventPolicy object
func (api *eventpolicyAPI) Create(obj *monitoring.EventPolicy) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.MonitoringV1().EventPolicy().Create(context.Background(), obj)
		if err != nil && strings.Contains(err.Error(), "AlreadyExists") {
			_, err = apicl.MonitoringV1().EventPolicy().Update(context.Background(), obj)

		}
		return err
	}

	api.ct.handleEventPolicyEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Created})
	return nil
}

// SyncCreate creates EventPolicy object and updates the cache
func (api *eventpolicyAPI) SyncCreate(obj *monitoring.EventPolicy) error {
	newObj := obj
	evtType := kvstore.Created
	var writeErr error
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		newObj, writeErr = apicl.MonitoringV1().EventPolicy().Create(context.Background(), obj)
		if writeErr != nil && strings.Contains(writeErr.Error(), "AlreadyExists") {
			newObj, writeErr = apicl.MonitoringV1().EventPolicy().Update(context.Background(), obj)
			evtType = kvstore.Updated
		}
	}

	if writeErr == nil {
		api.ct.handleEventPolicyEvent(&kvstore.WatchEvent{Object: newObj, Type: evtType})
	}
	return writeErr
}

// Update triggers update on EventPolicy object
func (api *eventpolicyAPI) Update(obj *monitoring.EventPolicy) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.MonitoringV1().EventPolicy().Update(context.Background(), obj)
		return err
	}

	api.ct.handleEventPolicyEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Updated})
	return nil
}

// SyncUpdate triggers update on EventPolicy object and updates the cache
func (api *eventpolicyAPI) SyncUpdate(obj *monitoring.EventPolicy) error {
	if api.ct.objResolver != nil {
		log.Fatal("Cannot use Sync update when object resolver is enabled on ctkit")
	}
	newObj := obj
	var writeErr error
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		newObj, writeErr = apicl.MonitoringV1().EventPolicy().Update(context.Background(), obj)
	}

	if writeErr == nil {
		api.ct.handleEventPolicyEvent(&kvstore.WatchEvent{Object: newObj, Type: kvstore.Updated})
	}

	return writeErr
}

// Label labels EventPolicy object
func (api *eventpolicyAPI) Label(obj *api.Label) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.MonitoringV1().EventPolicy().Label(context.Background(), obj)
		return err
	}

	ctkitObj, err := api.Find(obj.GetObjectMeta())
	if err != nil {
		return err
	}
	writeObj := ctkitObj.EventPolicy
	writeObj.Labels = obj.Labels

	api.ct.handleEventPolicyEvent(&kvstore.WatchEvent{Object: &writeObj, Type: kvstore.Updated})
	return nil
}

// Delete deletes EventPolicy object
func (api *eventpolicyAPI) Delete(obj *monitoring.EventPolicy) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.MonitoringV1().EventPolicy().Delete(context.Background(), &obj.ObjectMeta)
		return err
	}

	api.ct.handleEventPolicyEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Deleted})
	return nil
}

// MakeKey generates a KV store key for the object
func (api *eventpolicyAPI) getFullKey(tenant, name string) string {
	if tenant != "" {
		return fmt.Sprint(globals.ConfigRootPrefix, "/", "monitoring", "/", "event-policy", "/", tenant, "/", name)
	}
	return fmt.Sprint(globals.ConfigRootPrefix, "/", "monitoring", "/", "event-policy", "/", name)
}

// Find returns an object by meta
func (api *eventpolicyAPI) Find(meta *api.ObjectMeta) (*EventPolicy, error) {
	// find the object
	obj, err := api.ct.FindObject("EventPolicy", meta)
	if err != nil {
		return nil, err
	}

	// asset type
	switch obj.(type) {
	case *EventPolicy:
		hobj := obj.(*EventPolicy)
		return hobj, nil
	default:
		return nil, errors.New("incorrect object type")
	}
}

// List returns a list of all EventPolicy objects
func (api *eventpolicyAPI) List(ctx context.Context, opts *api.ListWatchOptions) ([]*EventPolicy, error) {
	var objlist []*EventPolicy
	objs, err := api.ct.List("EventPolicy", ctx, opts)

	if err != nil {
		return nil, err
	}

	for _, obj := range objs {
		switch tp := obj.(type) {
		case *EventPolicy:
			eobj := obj.(*EventPolicy)
			objlist = append(objlist, eobj)
		default:
			log.Fatalf("Got invalid object type %v while looking for EventPolicy", tp)
		}
	}

	return objlist, nil
}

// ApisrvList returns a list of all EventPolicy objects from apiserver
func (api *eventpolicyAPI) ApisrvList(ctx context.Context, opts *api.ListWatchOptions) ([]*monitoring.EventPolicy, error) {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return nil, err
		}

		return apicl.MonitoringV1().EventPolicy().List(context.Background(), opts)
	}

	// List from local cache
	ctkitObjs, err := api.List(ctx, opts)
	if err != nil {
		return nil, err
	}
	var ret []*monitoring.EventPolicy
	for _, obj := range ctkitObjs {
		ret = append(ret, &obj.EventPolicy)
	}
	return ret, nil
}

// Watch sets up a event handlers for EventPolicy object
func (api *eventpolicyAPI) Watch(handler EventPolicyHandler) error {
	api.ct.startWorkerPool("EventPolicy")
	return api.ct.WatchEventPolicy(handler)
}

// StopWatch stop watch for Tenant EventPolicy object
func (api *eventpolicyAPI) StopWatch(handler EventPolicyHandler) error {
	api.ct.Lock()
	api.ct.workPools["EventPolicy"].Stop()
	api.ct.Unlock()
	return api.ct.StopWatchEventPolicy(handler)
}

// ClearCache removes all EventPolicy objects in ctkit
func (api *eventpolicyAPI) ClearCache(handler EventPolicyHandler) {
	api.ct.delKind("EventPolicy")
}

// EventPolicy returns EventPolicyAPI
func (ct *ctrlerCtx) EventPolicy() EventPolicyAPI {
	kind := "EventPolicy"
	if _, ok := ct.apiInfMap[kind]; !ok {
		s := &eventpolicyAPI{ct: ct}
		ct.apiInfMap[kind] = s
	}
	return ct.apiInfMap[kind].(*eventpolicyAPI)
}

// FwlogPolicy is a wrapper object that implements additional functionality
type FwlogPolicy struct {
	sync.Mutex
	monitoring.FwlogPolicy
	HandlerCtx interface{} // additional state handlers can store
	ctrler     *ctrlerCtx  // reference back to the controller instance
	internal   bool
}

func (obj *FwlogPolicy) SetInternal() {
	obj.internal = true
}

func (obj *FwlogPolicy) Write() error {
	// if there is no API server to connect to, we are done
	if (obj.ctrler == nil) || (obj.ctrler.resolver == nil) || obj.ctrler.apisrvURL == "" {
		return nil
	}

	apicl, err := obj.ctrler.apiClient()
	if err != nil {
		obj.ctrler.logger.Errorf("Error creating API server clent. Err: %v", err)
		return err
	}

	obj.ctrler.stats.Counter("FwlogPolicy_Writes").Inc()

	// write to api server
	if obj.ObjectMeta.ResourceVersion != "" {
		// update it
		for i := 0; i < maxApisrvWriteRetry; i++ {
			_, err = apicl.MonitoringV1().FwlogPolicy().UpdateStatus(context.Background(), &obj.FwlogPolicy)
			if err == nil {
				break
			}
			time.Sleep(time.Millisecond * 100)
		}
	} else {
		//  create
		_, err = apicl.MonitoringV1().FwlogPolicy().Create(context.Background(), &obj.FwlogPolicy)
	}

	return nil
}

// FwlogPolicyHandler is the event handler for FwlogPolicy object
type FwlogPolicyHandler interface {
	OnFwlogPolicyCreate(obj *FwlogPolicy) error
	OnFwlogPolicyUpdate(oldObj *FwlogPolicy, newObj *monitoring.FwlogPolicy) error
	OnFwlogPolicyDelete(obj *FwlogPolicy) error
	GetFwlogPolicyWatchOptions() *api.ListWatchOptions
	OnFwlogPolicyReconnect()
}

// OnFwlogPolicyCreate is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnFwlogPolicyCreate(obj *FwlogPolicy) error {
	log.Info("OnFwlogPolicyCreate is not implemented")
	return nil
}

// OnFwlogPolicyUpdate is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnFwlogPolicyUpdate(oldObj *FwlogPolicy, newObj *monitoring.FwlogPolicy) error {
	log.Info("OnFwlogPolicyUpdate is not implemented")
	return nil
}

// OnFwlogPolicyDelete is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnFwlogPolicyDelete(obj *FwlogPolicy) error {
	log.Info("OnFwlogPolicyDelete is not implemented")
	return nil
}

// GetFwlogPolicyWatchOptions is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) GetFwlogPolicyWatchOptions() *api.ListWatchOptions {
	log.Info("GetFwlogPolicyWatchOptions is not implemented")
	opts := &api.ListWatchOptions{}
	return opts
}

// OnFwlogPolicyReconnect is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnFwlogPolicyReconnect() {
	log.Info("OnFwlogPolicyReconnect is not implemented")
	return
}

// handleFwlogPolicyEvent handles FwlogPolicy events from watcher
func (ct *ctrlerCtx) handleFwlogPolicyEvent(evt *kvstore.WatchEvent) error {

	if ct.objResolver == nil {
		return ct.handleFwlogPolicyEventNoResolver(evt)
	}

	switch tp := evt.Object.(type) {
	case *monitoring.FwlogPolicy:
		eobj := evt.Object.(*monitoring.FwlogPolicy)
		kind := "FwlogPolicy"

		eobj.ApplyStorageTransformer(context.Background(), true /*encrypt*/)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		eobj.ApplyStorageTransformer(context.Background(), false /*decrypt*/)

		ctx := &fwlogpolicyCtx{event: evt.Type,
			obj: &FwlogPolicy{FwlogPolicy: *eobj, ctrler: ct}}

		var err error
		switch evt.Type {
		case kvstore.Created:
			err = ct.processAdd(ctx)
		case kvstore.Updated:
			err = ct.processUpdate(ctx)
		case kvstore.Deleted:
			err = ct.processDelete(ctx)
		}
		return err
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on FwlogPolicy watch channel", tp)
	}

	return nil
}

// handleFwlogPolicyEventNoResolver handles FwlogPolicy events from watcher
func (ct *ctrlerCtx) handleFwlogPolicyEventNoResolver(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *monitoring.FwlogPolicy:
		eobj := evt.Object.(*monitoring.FwlogPolicy)
		kind := "FwlogPolicy"

		eobj.ApplyStorageTransformer(context.Background(), true /*encrypt*/)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		eobj.ApplyStorageTransformer(context.Background(), false /*decrypt*/)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		fwlogpolicyHandler := handler.(FwlogPolicyHandler)
		// handle based on event type
		ctrlCtx := &fwlogpolicyCtx{event: evt.Type, obj: &FwlogPolicy{FwlogPolicy: *eobj, ctrler: ct}}
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			fobj, err := ct.getObject(kind, ctrlCtx.GetKey())
			if err != nil {
				ct.addObject(ctrlCtx)
				ct.stats.Counter("FwlogPolicy_Created_Events").Inc()

				// call the event handler
				ctrlCtx.Lock()
				err = fwlogpolicyHandler.OnFwlogPolicyCreate(ctrlCtx.obj)
				ctrlCtx.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctrlCtx.obj.GetObjectMeta(), err)
					ct.delObject(kind, ctrlCtx.GetKey())
					return err
				}
			} else {
				fResVer, fErr := strconv.ParseInt(fobj.GetResourceVersion(), 10, 64)
				eResVer, eErr := strconv.ParseInt(eobj.GetResourceVersion(), 10, 64)
				if ct.resolver != nil && fErr == nil && eErr == nil && fResVer >= eResVer {
					// Event already processed.
					ct.logger.Infof("Skipping update due to old resource version")
					return nil
				}
				ctrlCtx := fobj.(*fwlogpolicyCtx)
				ct.stats.Counter("FwlogPolicy_Updated_Events").Inc()
				ctrlCtx.Lock()
				p := monitoring.FwlogPolicy{Spec: eobj.Spec,
					ObjectMeta: eobj.ObjectMeta,
					TypeMeta:   eobj.TypeMeta,
					Status:     eobj.Status}

				err = fwlogpolicyHandler.OnFwlogPolicyUpdate(ctrlCtx.obj, &p)
				ctrlCtx.obj.FwlogPolicy = *eobj
				ctrlCtx.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctrlCtx.obj.GetObjectMeta(), err)
					return err
				}

			}
		case kvstore.Deleted:
			ctrlCtx := &fwlogpolicyCtx{event: evt.Type, obj: &FwlogPolicy{FwlogPolicy: *eobj, ctrler: ct}}
			fobj, err := ct.findObject(kind, ctrlCtx.GetKey())
			if err != nil {
				ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
				return err
			}

			obj := fobj.(*FwlogPolicy)
			ct.stats.Counter("FwlogPolicy_Deleted_Events").Inc()
			obj.Lock()
			err = fwlogpolicyHandler.OnFwlogPolicyDelete(obj)
			obj.Unlock()
			if err != nil {
				ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj.GetObjectMeta(), err)
			}
			ct.delObject(kind, ctrlCtx.GetKey())
			return nil

		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on FwlogPolicy watch channel", tp)
	}

	return nil
}

type fwlogpolicyCtx struct {
	ctkitBaseCtx
	event kvstore.WatchEventType
	obj   *FwlogPolicy //
	//   newObj     *monitoring.FwlogPolicy //update
	newObj *fwlogpolicyCtx //update
}

func (ctx *fwlogpolicyCtx) References() map[string]apiintf.ReferenceObj {
	if ctx.references == nil {
		resp := make(map[string]apiintf.ReferenceObj)
		ctx.references = resp
		ctx.obj.References(ctx.obj.GetObjectMeta().Name, ctx.obj.GetObjectMeta().Namespace, resp)
		ctx.obj.ctrler.filterOutRefs(ctx)
	}
	return ctx.references
}

func (ctx *fwlogpolicyCtx) GetKey() string {
	return ctx.obj.MakeKey("monitoring")

}

func (ctx *fwlogpolicyCtx) IsInternal() bool {
	return ctx.obj.internal
}

func (ctx *fwlogpolicyCtx) GetKind() string {
	return ctx.obj.GetKind()
}

func (ctx *fwlogpolicyCtx) GetResourceVersion() string {
	return ctx.obj.GetResourceVersion()
}

func (ctx *fwlogpolicyCtx) SetEvent(event kvstore.WatchEventType) {
	ctx.event = event
}

func (ctx *fwlogpolicyCtx) SetNewObj(newObj apiintf.CtkitObject) {
	if newObj == nil {
		ctx.newObj = nil
	} else {
		ctx.newObj = newObj.(*fwlogpolicyCtx)
		ctx.newObj.obj.HandlerCtx = ctx.obj.HandlerCtx
		ctx.references = newObj.References()
	}
}

func (ctx *fwlogpolicyCtx) GetNewObj() apiintf.CtkitObject {
	return ctx.newObj
}

func (ctx *fwlogpolicyCtx) Copy(obj apiintf.CtkitObject) {
	ctx.obj.FwlogPolicy = obj.(*fwlogpolicyCtx).obj.FwlogPolicy
	ctx.SetWatchTs(obj.GetWatchTs())
}

func (ctx *fwlogpolicyCtx) Lock() {
	ctx.obj.Lock()
}

func (ctx *fwlogpolicyCtx) Unlock() {
	ctx.obj.Unlock()
}

func (ctx *fwlogpolicyCtx) GetObjectMeta() *api.ObjectMeta {
	return ctx.obj.GetObjectMeta()
}

func (ctx *fwlogpolicyCtx) RuntimeObject() runtime.Object {
	var v interface{}
	v = ctx.obj
	return v.(runtime.Object)
}

func (ctx *fwlogpolicyCtx) WorkFunc(context context.Context) error {
	var err error
	evt := ctx.event
	ct := ctx.obj.ctrler
	kind := "FwlogPolicy"
	ct.Lock()
	handler, ok := ct.handlers[kind]
	ct.Unlock()
	if !ok {
		ct.logger.Fatalf("Cant find the handler for %s", kind)
	}
	fwlogpolicyHandler := handler.(FwlogPolicyHandler)
	switch evt {
	case kvstore.Created:
		ctx.obj.Lock()
		err = fwlogpolicyHandler.OnFwlogPolicyCreate(ctx.obj)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctx.obj.GetObjectMeta(), err)
			ctx.SetEvent(kvstore.Deleted)
		}
	case kvstore.Updated:
		ct.stats.Counter("FwlogPolicy_Updated_Events").Inc()
		ctx.obj.Lock()
		p := monitoring.FwlogPolicy{Spec: ctx.newObj.obj.Spec,
			ObjectMeta: ctx.newObj.obj.ObjectMeta,
			TypeMeta:   ctx.newObj.obj.TypeMeta,
			Status:     ctx.newObj.obj.Status}
		err = fwlogpolicyHandler.OnFwlogPolicyUpdate(ctx.obj, &p)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctx.obj.GetObjectMeta(), err)
			ctx.SetEvent(kvstore.Deleted)
		}
	case kvstore.Deleted:
		ctx.obj.Lock()
		err = fwlogpolicyHandler.OnFwlogPolicyDelete(ctx.obj)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error deleting %s %+v. Err: %v", kind, ctx.obj.GetObjectMeta(), err)
		}
	}
	ct.resolveObject(ctx.event, ctx)
	return nil
}

// handleFwlogPolicyEventParallel handles FwlogPolicy events from watcher
func (ct *ctrlerCtx) handleFwlogPolicyEventParallel(evt *kvstore.WatchEvent) error {

	if ct.objResolver == nil {
		return ct.handleFwlogPolicyEventParallelWithNoResolver(evt)
	}

	switch tp := evt.Object.(type) {
	case *monitoring.FwlogPolicy:
		eobj := evt.Object.(*monitoring.FwlogPolicy)
		kind := "FwlogPolicy"

		eobj.ApplyStorageTransformer(context.Background(), true /*encrypt*/)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		eobj.ApplyStorageTransformer(context.Background(), false /*decrypt*/)

		ctx := &fwlogpolicyCtx{event: evt.Type, obj: &FwlogPolicy{FwlogPolicy: *eobj, ctrler: ct}}
		ctx.SetWatchTs(evt.WatchTS)

		var err error
		switch evt.Type {
		case kvstore.Created:
			err = ct.processAdd(ctx)
		case kvstore.Updated:
			err = ct.processUpdate(ctx)
		case kvstore.Deleted:
			err = ct.processDelete(ctx)
		}
		return err
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on FwlogPolicy watch channel", tp)
	}

	return nil
}

// handleFwlogPolicyEventParallel handles FwlogPolicy events from watcher
func (ct *ctrlerCtx) handleFwlogPolicyEventParallelWithNoResolver(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *monitoring.FwlogPolicy:
		eobj := evt.Object.(*monitoring.FwlogPolicy)
		kind := "FwlogPolicy"

		eobj.ApplyStorageTransformer(context.Background(), true /*encrypt*/)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		eobj.ApplyStorageTransformer(context.Background(), false /*decrypt*/)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		fwlogpolicyHandler := handler.(FwlogPolicyHandler)
		// handle based on event type
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			workFunc := func(ctx context.Context, ctrlCtx shardworkers.WorkObj) error {
				var err error
				workCtx := ctrlCtx.(*fwlogpolicyCtx)
				eobj := workCtx.obj
				fobj, err := ct.getObject(kind, workCtx.GetKey())
				if err != nil {
					ct.addObject(workCtx)
					ct.stats.Counter("FwlogPolicy_Created_Events").Inc()
					eobj.Lock()
					err = fwlogpolicyHandler.OnFwlogPolicyCreate(eobj)
					eobj.Unlock()
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, eobj.GetObjectMeta(), err)
						ct.delObject(kind, workCtx.GetKey())
					}
				} else {
					workCtx = fobj.(*fwlogpolicyCtx)
					obj := workCtx.obj
					ct.stats.Counter("FwlogPolicy_Updated_Events").Inc()
					obj.Lock()
					p := monitoring.FwlogPolicy{Spec: eobj.Spec,
						ObjectMeta: eobj.ObjectMeta,
						TypeMeta:   eobj.TypeMeta,
						Status:     eobj.Status}

					err = fwlogpolicyHandler.OnFwlogPolicyUpdate(obj, &p)
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj.GetObjectMeta(), err)
					} else {
						workCtx.obj.FwlogPolicy = p
					}
					obj.Unlock()
				}
				workCtx.SetWatchTs(evt.WatchTS)
				return err
			}
			ctrlCtx := &fwlogpolicyCtx{event: evt.Type, obj: &FwlogPolicy{FwlogPolicy: *eobj, ctrler: ct}}
			ct.runFunction("FwlogPolicy", ctrlCtx, workFunc)
		case kvstore.Deleted:
			workFunc := func(ctx context.Context, ctrlCtx shardworkers.WorkObj) error {
				var err error
				workCtx := ctrlCtx.(*fwlogpolicyCtx)
				eobj := workCtx.obj
				fobj, err := ct.findObject(kind, workCtx.GetKey())
				if err != nil {
					ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
					return err
				}
				obj := fobj.(*FwlogPolicy)
				ct.stats.Counter("FwlogPolicy_Deleted_Events").Inc()
				obj.Lock()
				err = fwlogpolicyHandler.OnFwlogPolicyDelete(obj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj.GetObjectMeta(), err)
				}
				ct.delObject(kind, workCtx.GetKey())
				return nil
			}
			ctrlCtx := &fwlogpolicyCtx{event: evt.Type, obj: &FwlogPolicy{FwlogPolicy: *eobj, ctrler: ct}}
			ct.runFunction("FwlogPolicy", ctrlCtx, workFunc)
		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on FwlogPolicy watch channel", tp)
	}

	return nil
}

// diffFwlogPolicy does a diff of FwlogPolicy objects between local cache and API server
func (ct *ctrlerCtx) diffFwlogPolicy(apicl apiclient.Services) {
	opts := api.ListWatchOptions{}

	// get a list of all objects from API server
	objlist, err := apicl.MonitoringV1().FwlogPolicy().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Errorf("Error getting a list of objects. Err: %v", err)
		return
	}

	ct.logger.Infof("diffFwlogPolicy(): FwlogPolicyList returned %d objects", len(objlist))

	// build an object map
	objmap := make(map[string]*monitoring.FwlogPolicy)
	for _, obj := range objlist {
		objmap[obj.GetKey()] = obj
	}

	list, err := ct.FwlogPolicy().List(context.Background(), &opts)
	if err != nil && !strings.Contains(err.Error(), "not found in local cache") {
		ct.logger.Infof("Failed to get a list of objects. Err: %s", err)
		return
	}

	// if an object is in our local cache and not in API server, trigger delete for it
	for _, obj := range list {
		_, ok := objmap[obj.GetKey()]
		if !ok {
			ct.logger.Infof("diffFwlogPolicy(): Deleting existing object %#v since its not in apiserver", obj.GetKey())
			evt := kvstore.WatchEvent{
				Type:   kvstore.Deleted,
				Key:    obj.GetKey(),
				Object: &obj.FwlogPolicy,
			}
			ct.handleFwlogPolicyEvent(&evt)
		}
	}

	// trigger create event for all others
	for _, obj := range objlist {
		ct.logger.Infof("diffFwlogPolicy(): Adding object %#v", obj.GetKey())
		evt := kvstore.WatchEvent{
			Type:   kvstore.Created,
			Key:    obj.GetKey(),
			Object: obj,
		}
		ct.handleFwlogPolicyEvent(&evt)
	}
}

func (ct *ctrlerCtx) runFwlogPolicyWatcher() {
	kind := "FwlogPolicy"

	ct.Lock()
	handler, ok := ct.handlers[kind]
	ct.Unlock()
	if !ok {
		ct.logger.Fatalf("Cant find the handler for %s", kind)
	}
	fwlogpolicyHandler := handler.(FwlogPolicyHandler)

	opts := fwlogpolicyHandler.GetFwlogPolicyWatchOptions()

	// if there is no API server to connect to, we are done
	if (ct.resolver == nil) || ct.apisrvURL == "" {
		return
	}

	// create context
	ctx, cancel := context.WithCancel(context.Background())
	ct.Lock()
	ct.watchCancel[kind] = cancel
	ct.Unlock()
	logger := ct.logger.WithContext("submodule", "FwlogPolicyWatcher")
	for {
		if ctx.Err() != nil {
			return
		}

		apiclt, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
		// create a grpc client
		if err == nil {
			// Upon successful connection perform the diff, and start watch goroutine
			ct.diffFwlogPolicy(apiclt)
			break
		}

		logger.Warnf("Failed to connect to gRPC server [%s]\n", ct.apisrvURL)
		time.Sleep(time.Second)
	}

	// setup wait group
	ct.waitGrp.Add(1)

	// start a goroutine
	go func() {
		defer ct.waitGrp.Done()
		ct.stats.Counter("FwlogPolicy_Watch").Inc()
		defer ct.stats.Counter("FwlogPolicy_Watch").Dec()

		// loop forever
		for {
			// create a grpc client
			apicl, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
			if err != nil {
				logger.Warnf("Failed to connect to gRPC server [%s]\n", ct.apisrvURL)
				ct.stats.Counter("FwlogPolicy_ApiClientErr").Inc()
			} else {
				logger.Infof("API client connected {%+v}", apicl)

				// FwlogPolicy object watcher
				wt, werr := apicl.MonitoringV1().FwlogPolicy().Watch(ctx, opts)
				if werr != nil {
					select {
					case <-ctx.Done():
						logger.Infof("watch %s cancelled", kind)
						return
					default:
					}
					logger.Errorf("Failed to start %s watch (%s)\n", kind, werr)
					// wait for a second and retry connecting to api server
					apicl.Close()
					time.Sleep(time.Second)
					continue
				}
				ct.Lock()
				ct.watchers[kind] = wt
				ct.Unlock()

				// perform a diff with API server and local cache
				// Sleeping to give time for other apiclient's to reconnect
				// before calling reconnect handler
				time.Sleep(time.Second)
				ct.diffFwlogPolicy(apicl)
				fwlogpolicyHandler.OnFwlogPolicyReconnect()

				// handle api server watch events
			innerLoop:
				for {
					// wait for events
					select {
					case evt, ok := <-wt.EventChan():
						if !ok {
							logger.Error("Error receiving from apisrv watcher")
							ct.stats.Counter("FwlogPolicy_WatchErrors").Inc()
							break innerLoop
						}

						// handle event in parallel
						ct.handleFwlogPolicyEventParallel(evt)
					}
				}
				apicl.Close()
			}

			// if stop flag is set, we are done
			if ct.stoped {
				logger.Infof("Exiting API server watcher")
				return
			}

			// wait for a second and retry connecting to api server
			time.Sleep(time.Second)
		}
	}()
}

// WatchFwlogPolicy starts watch on FwlogPolicy object
func (ct *ctrlerCtx) WatchFwlogPolicy(handler FwlogPolicyHandler) error {
	kind := "FwlogPolicy"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchCancel[kind]
	ct.Unlock()
	if ok {
		return fmt.Errorf("FwlogPolicy watcher already exists")
	}

	// save handler
	ct.Lock()
	ct.handlers[kind] = handler
	ct.Unlock()

	// run FwlogPolicy watcher in a go routine
	ct.runFwlogPolicyWatcher()

	return nil
}

// StopWatchFwlogPolicy stops watch on FwlogPolicy object
func (ct *ctrlerCtx) StopWatchFwlogPolicy(handler FwlogPolicyHandler) error {
	kind := "FwlogPolicy"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchCancel[kind]
	ct.Unlock()
	if !ok {
		return fmt.Errorf("FwlogPolicy watcher does not exist")
	}

	ct.Lock()
	cancel, _ := ct.watchCancel[kind]
	cancel()
	if _, ok := ct.watchers[kind]; ok {
		delete(ct.watchers, kind)
	}
	delete(ct.watchCancel, kind)
	ct.Unlock()

	time.Sleep(100 * time.Millisecond)

	return nil
}

// FwlogPolicyAPI returns
type FwlogPolicyAPI interface {
	Create(obj *monitoring.FwlogPolicy) error
	SyncCreate(obj *monitoring.FwlogPolicy) error
	Update(obj *monitoring.FwlogPolicy) error
	SyncUpdate(obj *monitoring.FwlogPolicy) error
	Label(obj *api.Label) error
	Delete(obj *monitoring.FwlogPolicy) error
	Find(meta *api.ObjectMeta) (*FwlogPolicy, error)
	List(ctx context.Context, opts *api.ListWatchOptions) ([]*FwlogPolicy, error)
	ApisrvList(ctx context.Context, opts *api.ListWatchOptions) ([]*monitoring.FwlogPolicy, error)
	Watch(handler FwlogPolicyHandler) error
	ClearCache(handler FwlogPolicyHandler)
	StopWatch(handler FwlogPolicyHandler) error
}

// dummy struct that implements FwlogPolicyAPI
type fwlogpolicyAPI struct {
	ct *ctrlerCtx
}

// Create creates FwlogPolicy object
func (api *fwlogpolicyAPI) Create(obj *monitoring.FwlogPolicy) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.MonitoringV1().FwlogPolicy().Create(context.Background(), obj)
		if err != nil && strings.Contains(err.Error(), "AlreadyExists") {
			_, err = apicl.MonitoringV1().FwlogPolicy().Update(context.Background(), obj)

		}
		return err
	}

	api.ct.handleFwlogPolicyEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Created})
	return nil
}

// SyncCreate creates FwlogPolicy object and updates the cache
func (api *fwlogpolicyAPI) SyncCreate(obj *monitoring.FwlogPolicy) error {
	newObj := obj
	evtType := kvstore.Created
	var writeErr error
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		newObj, writeErr = apicl.MonitoringV1().FwlogPolicy().Create(context.Background(), obj)
		if writeErr != nil && strings.Contains(writeErr.Error(), "AlreadyExists") {
			newObj, writeErr = apicl.MonitoringV1().FwlogPolicy().Update(context.Background(), obj)
			evtType = kvstore.Updated
		}
	}

	if writeErr == nil {
		api.ct.handleFwlogPolicyEvent(&kvstore.WatchEvent{Object: newObj, Type: evtType})
	}
	return writeErr
}

// Update triggers update on FwlogPolicy object
func (api *fwlogpolicyAPI) Update(obj *monitoring.FwlogPolicy) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.MonitoringV1().FwlogPolicy().Update(context.Background(), obj)
		return err
	}

	api.ct.handleFwlogPolicyEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Updated})
	return nil
}

// SyncUpdate triggers update on FwlogPolicy object and updates the cache
func (api *fwlogpolicyAPI) SyncUpdate(obj *monitoring.FwlogPolicy) error {
	if api.ct.objResolver != nil {
		log.Fatal("Cannot use Sync update when object resolver is enabled on ctkit")
	}
	newObj := obj
	var writeErr error
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		newObj, writeErr = apicl.MonitoringV1().FwlogPolicy().Update(context.Background(), obj)
	}

	if writeErr == nil {
		api.ct.handleFwlogPolicyEvent(&kvstore.WatchEvent{Object: newObj, Type: kvstore.Updated})
	}

	return writeErr
}

// Label labels FwlogPolicy object
func (api *fwlogpolicyAPI) Label(obj *api.Label) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.MonitoringV1().FwlogPolicy().Label(context.Background(), obj)
		return err
	}

	ctkitObj, err := api.Find(obj.GetObjectMeta())
	if err != nil {
		return err
	}
	writeObj := ctkitObj.FwlogPolicy
	writeObj.Labels = obj.Labels

	api.ct.handleFwlogPolicyEvent(&kvstore.WatchEvent{Object: &writeObj, Type: kvstore.Updated})
	return nil
}

// Delete deletes FwlogPolicy object
func (api *fwlogpolicyAPI) Delete(obj *monitoring.FwlogPolicy) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.MonitoringV1().FwlogPolicy().Delete(context.Background(), &obj.ObjectMeta)
		return err
	}

	api.ct.handleFwlogPolicyEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Deleted})
	return nil
}

// MakeKey generates a KV store key for the object
func (api *fwlogpolicyAPI) getFullKey(tenant, name string) string {
	if tenant != "" {
		return fmt.Sprint(globals.ConfigRootPrefix, "/", "monitoring", "/", "fwlogPolicy", "/", tenant, "/", name)
	}
	return fmt.Sprint(globals.ConfigRootPrefix, "/", "monitoring", "/", "fwlogPolicy", "/", name)
}

// Find returns an object by meta
func (api *fwlogpolicyAPI) Find(meta *api.ObjectMeta) (*FwlogPolicy, error) {
	// find the object
	obj, err := api.ct.FindObject("FwlogPolicy", meta)
	if err != nil {
		return nil, err
	}

	// asset type
	switch obj.(type) {
	case *FwlogPolicy:
		hobj := obj.(*FwlogPolicy)
		return hobj, nil
	default:
		return nil, errors.New("incorrect object type")
	}
}

// List returns a list of all FwlogPolicy objects
func (api *fwlogpolicyAPI) List(ctx context.Context, opts *api.ListWatchOptions) ([]*FwlogPolicy, error) {
	var objlist []*FwlogPolicy
	objs, err := api.ct.List("FwlogPolicy", ctx, opts)

	if err != nil {
		return nil, err
	}

	for _, obj := range objs {
		switch tp := obj.(type) {
		case *FwlogPolicy:
			eobj := obj.(*FwlogPolicy)
			objlist = append(objlist, eobj)
		default:
			log.Fatalf("Got invalid object type %v while looking for FwlogPolicy", tp)
		}
	}

	return objlist, nil
}

// ApisrvList returns a list of all FwlogPolicy objects from apiserver
func (api *fwlogpolicyAPI) ApisrvList(ctx context.Context, opts *api.ListWatchOptions) ([]*monitoring.FwlogPolicy, error) {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return nil, err
		}

		return apicl.MonitoringV1().FwlogPolicy().List(context.Background(), opts)
	}

	// List from local cache
	ctkitObjs, err := api.List(ctx, opts)
	if err != nil {
		return nil, err
	}
	var ret []*monitoring.FwlogPolicy
	for _, obj := range ctkitObjs {
		ret = append(ret, &obj.FwlogPolicy)
	}
	return ret, nil
}

// Watch sets up a event handlers for FwlogPolicy object
func (api *fwlogpolicyAPI) Watch(handler FwlogPolicyHandler) error {
	api.ct.startWorkerPool("FwlogPolicy")
	return api.ct.WatchFwlogPolicy(handler)
}

// StopWatch stop watch for Tenant FwlogPolicy object
func (api *fwlogpolicyAPI) StopWatch(handler FwlogPolicyHandler) error {
	api.ct.Lock()
	api.ct.workPools["FwlogPolicy"].Stop()
	api.ct.Unlock()
	return api.ct.StopWatchFwlogPolicy(handler)
}

// ClearCache removes all FwlogPolicy objects in ctkit
func (api *fwlogpolicyAPI) ClearCache(handler FwlogPolicyHandler) {
	api.ct.delKind("FwlogPolicy")
}

// FwlogPolicy returns FwlogPolicyAPI
func (ct *ctrlerCtx) FwlogPolicy() FwlogPolicyAPI {
	kind := "FwlogPolicy"
	if _, ok := ct.apiInfMap[kind]; !ok {
		s := &fwlogpolicyAPI{ct: ct}
		ct.apiInfMap[kind] = s
	}
	return ct.apiInfMap[kind].(*fwlogpolicyAPI)
}

// FlowExportPolicy is a wrapper object that implements additional functionality
type FlowExportPolicy struct {
	sync.Mutex
	monitoring.FlowExportPolicy
	HandlerCtx interface{} // additional state handlers can store
	ctrler     *ctrlerCtx  // reference back to the controller instance
	internal   bool
}

func (obj *FlowExportPolicy) SetInternal() {
	obj.internal = true
}

func (obj *FlowExportPolicy) Write() error {
	// if there is no API server to connect to, we are done
	if (obj.ctrler == nil) || (obj.ctrler.resolver == nil) || obj.ctrler.apisrvURL == "" {
		return nil
	}

	apicl, err := obj.ctrler.apiClient()
	if err != nil {
		obj.ctrler.logger.Errorf("Error creating API server clent. Err: %v", err)
		return err
	}

	obj.ctrler.stats.Counter("FlowExportPolicy_Writes").Inc()

	// write to api server
	if obj.ObjectMeta.ResourceVersion != "" {
		// update it
		for i := 0; i < maxApisrvWriteRetry; i++ {
			_, err = apicl.MonitoringV1().FlowExportPolicy().UpdateStatus(context.Background(), &obj.FlowExportPolicy)
			if err == nil {
				break
			}
			time.Sleep(time.Millisecond * 100)
		}
	} else {
		//  create
		_, err = apicl.MonitoringV1().FlowExportPolicy().Create(context.Background(), &obj.FlowExportPolicy)
	}

	return nil
}

// FlowExportPolicyHandler is the event handler for FlowExportPolicy object
type FlowExportPolicyHandler interface {
	OnFlowExportPolicyCreate(obj *FlowExportPolicy) error
	OnFlowExportPolicyUpdate(oldObj *FlowExportPolicy, newObj *monitoring.FlowExportPolicy) error
	OnFlowExportPolicyDelete(obj *FlowExportPolicy) error
	GetFlowExportPolicyWatchOptions() *api.ListWatchOptions
	OnFlowExportPolicyReconnect()
}

// OnFlowExportPolicyCreate is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnFlowExportPolicyCreate(obj *FlowExportPolicy) error {
	log.Info("OnFlowExportPolicyCreate is not implemented")
	return nil
}

// OnFlowExportPolicyUpdate is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnFlowExportPolicyUpdate(oldObj *FlowExportPolicy, newObj *monitoring.FlowExportPolicy) error {
	log.Info("OnFlowExportPolicyUpdate is not implemented")
	return nil
}

// OnFlowExportPolicyDelete is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnFlowExportPolicyDelete(obj *FlowExportPolicy) error {
	log.Info("OnFlowExportPolicyDelete is not implemented")
	return nil
}

// GetFlowExportPolicyWatchOptions is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) GetFlowExportPolicyWatchOptions() *api.ListWatchOptions {
	log.Info("GetFlowExportPolicyWatchOptions is not implemented")
	opts := &api.ListWatchOptions{}
	return opts
}

// OnFlowExportPolicyReconnect is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnFlowExportPolicyReconnect() {
	log.Info("OnFlowExportPolicyReconnect is not implemented")
	return
}

// handleFlowExportPolicyEvent handles FlowExportPolicy events from watcher
func (ct *ctrlerCtx) handleFlowExportPolicyEvent(evt *kvstore.WatchEvent) error {

	if ct.objResolver == nil {
		return ct.handleFlowExportPolicyEventNoResolver(evt)
	}

	switch tp := evt.Object.(type) {
	case *monitoring.FlowExportPolicy:
		eobj := evt.Object.(*monitoring.FlowExportPolicy)
		kind := "FlowExportPolicy"

		eobj.ApplyStorageTransformer(context.Background(), true /*encrypt*/)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		eobj.ApplyStorageTransformer(context.Background(), false /*decrypt*/)

		ctx := &flowexportpolicyCtx{event: evt.Type,
			obj: &FlowExportPolicy{FlowExportPolicy: *eobj, ctrler: ct}}

		var err error
		switch evt.Type {
		case kvstore.Created:
			err = ct.processAdd(ctx)
		case kvstore.Updated:
			err = ct.processUpdate(ctx)
		case kvstore.Deleted:
			err = ct.processDelete(ctx)
		}
		return err
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on FlowExportPolicy watch channel", tp)
	}

	return nil
}

// handleFlowExportPolicyEventNoResolver handles FlowExportPolicy events from watcher
func (ct *ctrlerCtx) handleFlowExportPolicyEventNoResolver(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *monitoring.FlowExportPolicy:
		eobj := evt.Object.(*monitoring.FlowExportPolicy)
		kind := "FlowExportPolicy"

		eobj.ApplyStorageTransformer(context.Background(), true /*encrypt*/)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		eobj.ApplyStorageTransformer(context.Background(), false /*decrypt*/)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		flowexportpolicyHandler := handler.(FlowExportPolicyHandler)
		// handle based on event type
		ctrlCtx := &flowexportpolicyCtx{event: evt.Type, obj: &FlowExportPolicy{FlowExportPolicy: *eobj, ctrler: ct}}
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			fobj, err := ct.getObject(kind, ctrlCtx.GetKey())
			if err != nil {
				ct.addObject(ctrlCtx)
				ct.stats.Counter("FlowExportPolicy_Created_Events").Inc()

				// call the event handler
				ctrlCtx.Lock()
				err = flowexportpolicyHandler.OnFlowExportPolicyCreate(ctrlCtx.obj)
				ctrlCtx.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctrlCtx.obj.GetObjectMeta(), err)
					ct.delObject(kind, ctrlCtx.GetKey())
					return err
				}
			} else {
				fResVer, fErr := strconv.ParseInt(fobj.GetResourceVersion(), 10, 64)
				eResVer, eErr := strconv.ParseInt(eobj.GetResourceVersion(), 10, 64)
				if ct.resolver != nil && fErr == nil && eErr == nil && fResVer >= eResVer {
					// Event already processed.
					ct.logger.Infof("Skipping update due to old resource version")
					return nil
				}
				ctrlCtx := fobj.(*flowexportpolicyCtx)
				ct.stats.Counter("FlowExportPolicy_Updated_Events").Inc()
				ctrlCtx.Lock()
				p := monitoring.FlowExportPolicy{Spec: eobj.Spec,
					ObjectMeta: eobj.ObjectMeta,
					TypeMeta:   eobj.TypeMeta,
					Status:     eobj.Status}

				err = flowexportpolicyHandler.OnFlowExportPolicyUpdate(ctrlCtx.obj, &p)
				ctrlCtx.obj.FlowExportPolicy = *eobj
				ctrlCtx.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctrlCtx.obj.GetObjectMeta(), err)
					return err
				}

			}
		case kvstore.Deleted:
			ctrlCtx := &flowexportpolicyCtx{event: evt.Type, obj: &FlowExportPolicy{FlowExportPolicy: *eobj, ctrler: ct}}
			fobj, err := ct.findObject(kind, ctrlCtx.GetKey())
			if err != nil {
				ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
				return err
			}

			obj := fobj.(*FlowExportPolicy)
			ct.stats.Counter("FlowExportPolicy_Deleted_Events").Inc()
			obj.Lock()
			err = flowexportpolicyHandler.OnFlowExportPolicyDelete(obj)
			obj.Unlock()
			if err != nil {
				ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj.GetObjectMeta(), err)
			}
			ct.delObject(kind, ctrlCtx.GetKey())
			return nil

		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on FlowExportPolicy watch channel", tp)
	}

	return nil
}

type flowexportpolicyCtx struct {
	ctkitBaseCtx
	event kvstore.WatchEventType
	obj   *FlowExportPolicy //
	//   newObj     *monitoring.FlowExportPolicy //update
	newObj *flowexportpolicyCtx //update
}

func (ctx *flowexportpolicyCtx) References() map[string]apiintf.ReferenceObj {
	if ctx.references == nil {
		resp := make(map[string]apiintf.ReferenceObj)
		ctx.references = resp
		ctx.obj.References(ctx.obj.GetObjectMeta().Name, ctx.obj.GetObjectMeta().Namespace, resp)
		ctx.obj.ctrler.filterOutRefs(ctx)
	}
	return ctx.references
}

func (ctx *flowexportpolicyCtx) GetKey() string {
	return ctx.obj.MakeKey("monitoring")

}

func (ctx *flowexportpolicyCtx) IsInternal() bool {
	return ctx.obj.internal
}

func (ctx *flowexportpolicyCtx) GetKind() string {
	return ctx.obj.GetKind()
}

func (ctx *flowexportpolicyCtx) GetResourceVersion() string {
	return ctx.obj.GetResourceVersion()
}

func (ctx *flowexportpolicyCtx) SetEvent(event kvstore.WatchEventType) {
	ctx.event = event
}

func (ctx *flowexportpolicyCtx) SetNewObj(newObj apiintf.CtkitObject) {
	if newObj == nil {
		ctx.newObj = nil
	} else {
		ctx.newObj = newObj.(*flowexportpolicyCtx)
		ctx.newObj.obj.HandlerCtx = ctx.obj.HandlerCtx
		ctx.references = newObj.References()
	}
}

func (ctx *flowexportpolicyCtx) GetNewObj() apiintf.CtkitObject {
	return ctx.newObj
}

func (ctx *flowexportpolicyCtx) Copy(obj apiintf.CtkitObject) {
	ctx.obj.FlowExportPolicy = obj.(*flowexportpolicyCtx).obj.FlowExportPolicy
	ctx.SetWatchTs(obj.GetWatchTs())
}

func (ctx *flowexportpolicyCtx) Lock() {
	ctx.obj.Lock()
}

func (ctx *flowexportpolicyCtx) Unlock() {
	ctx.obj.Unlock()
}

func (ctx *flowexportpolicyCtx) GetObjectMeta() *api.ObjectMeta {
	return ctx.obj.GetObjectMeta()
}

func (ctx *flowexportpolicyCtx) RuntimeObject() runtime.Object {
	var v interface{}
	v = ctx.obj
	return v.(runtime.Object)
}

func (ctx *flowexportpolicyCtx) WorkFunc(context context.Context) error {
	var err error
	evt := ctx.event
	ct := ctx.obj.ctrler
	kind := "FlowExportPolicy"
	ct.Lock()
	handler, ok := ct.handlers[kind]
	ct.Unlock()
	if !ok {
		ct.logger.Fatalf("Cant find the handler for %s", kind)
	}
	flowexportpolicyHandler := handler.(FlowExportPolicyHandler)
	switch evt {
	case kvstore.Created:
		ctx.obj.Lock()
		err = flowexportpolicyHandler.OnFlowExportPolicyCreate(ctx.obj)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctx.obj.GetObjectMeta(), err)
			ctx.SetEvent(kvstore.Deleted)
		}
	case kvstore.Updated:
		ct.stats.Counter("FlowExportPolicy_Updated_Events").Inc()
		ctx.obj.Lock()
		p := monitoring.FlowExportPolicy{Spec: ctx.newObj.obj.Spec,
			ObjectMeta: ctx.newObj.obj.ObjectMeta,
			TypeMeta:   ctx.newObj.obj.TypeMeta,
			Status:     ctx.newObj.obj.Status}
		err = flowexportpolicyHandler.OnFlowExportPolicyUpdate(ctx.obj, &p)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctx.obj.GetObjectMeta(), err)
			ctx.SetEvent(kvstore.Deleted)
		}
	case kvstore.Deleted:
		ctx.obj.Lock()
		err = flowexportpolicyHandler.OnFlowExportPolicyDelete(ctx.obj)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error deleting %s %+v. Err: %v", kind, ctx.obj.GetObjectMeta(), err)
		}
	}
	ct.resolveObject(ctx.event, ctx)
	return nil
}

// handleFlowExportPolicyEventParallel handles FlowExportPolicy events from watcher
func (ct *ctrlerCtx) handleFlowExportPolicyEventParallel(evt *kvstore.WatchEvent) error {

	if ct.objResolver == nil {
		return ct.handleFlowExportPolicyEventParallelWithNoResolver(evt)
	}

	switch tp := evt.Object.(type) {
	case *monitoring.FlowExportPolicy:
		eobj := evt.Object.(*monitoring.FlowExportPolicy)
		kind := "FlowExportPolicy"

		eobj.ApplyStorageTransformer(context.Background(), true /*encrypt*/)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		eobj.ApplyStorageTransformer(context.Background(), false /*decrypt*/)

		ctx := &flowexportpolicyCtx{event: evt.Type, obj: &FlowExportPolicy{FlowExportPolicy: *eobj, ctrler: ct}}
		ctx.SetWatchTs(evt.WatchTS)

		var err error
		switch evt.Type {
		case kvstore.Created:
			err = ct.processAdd(ctx)
		case kvstore.Updated:
			err = ct.processUpdate(ctx)
		case kvstore.Deleted:
			err = ct.processDelete(ctx)
		}
		return err
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on FlowExportPolicy watch channel", tp)
	}

	return nil
}

// handleFlowExportPolicyEventParallel handles FlowExportPolicy events from watcher
func (ct *ctrlerCtx) handleFlowExportPolicyEventParallelWithNoResolver(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *monitoring.FlowExportPolicy:
		eobj := evt.Object.(*monitoring.FlowExportPolicy)
		kind := "FlowExportPolicy"

		eobj.ApplyStorageTransformer(context.Background(), true /*encrypt*/)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		eobj.ApplyStorageTransformer(context.Background(), false /*decrypt*/)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		flowexportpolicyHandler := handler.(FlowExportPolicyHandler)
		// handle based on event type
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			workFunc := func(ctx context.Context, ctrlCtx shardworkers.WorkObj) error {
				var err error
				workCtx := ctrlCtx.(*flowexportpolicyCtx)
				eobj := workCtx.obj
				fobj, err := ct.getObject(kind, workCtx.GetKey())
				if err != nil {
					ct.addObject(workCtx)
					ct.stats.Counter("FlowExportPolicy_Created_Events").Inc()
					eobj.Lock()
					err = flowexportpolicyHandler.OnFlowExportPolicyCreate(eobj)
					eobj.Unlock()
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, eobj.GetObjectMeta(), err)
						ct.delObject(kind, workCtx.GetKey())
					}
				} else {
					workCtx = fobj.(*flowexportpolicyCtx)
					obj := workCtx.obj
					ct.stats.Counter("FlowExportPolicy_Updated_Events").Inc()
					obj.Lock()
					p := monitoring.FlowExportPolicy{Spec: eobj.Spec,
						ObjectMeta: eobj.ObjectMeta,
						TypeMeta:   eobj.TypeMeta,
						Status:     eobj.Status}

					err = flowexportpolicyHandler.OnFlowExportPolicyUpdate(obj, &p)
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj.GetObjectMeta(), err)
					} else {
						workCtx.obj.FlowExportPolicy = p
					}
					obj.Unlock()
				}
				workCtx.SetWatchTs(evt.WatchTS)
				return err
			}
			ctrlCtx := &flowexportpolicyCtx{event: evt.Type, obj: &FlowExportPolicy{FlowExportPolicy: *eobj, ctrler: ct}}
			ct.runFunction("FlowExportPolicy", ctrlCtx, workFunc)
		case kvstore.Deleted:
			workFunc := func(ctx context.Context, ctrlCtx shardworkers.WorkObj) error {
				var err error
				workCtx := ctrlCtx.(*flowexportpolicyCtx)
				eobj := workCtx.obj
				fobj, err := ct.findObject(kind, workCtx.GetKey())
				if err != nil {
					ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
					return err
				}
				obj := fobj.(*FlowExportPolicy)
				ct.stats.Counter("FlowExportPolicy_Deleted_Events").Inc()
				obj.Lock()
				err = flowexportpolicyHandler.OnFlowExportPolicyDelete(obj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj.GetObjectMeta(), err)
				}
				ct.delObject(kind, workCtx.GetKey())
				return nil
			}
			ctrlCtx := &flowexportpolicyCtx{event: evt.Type, obj: &FlowExportPolicy{FlowExportPolicy: *eobj, ctrler: ct}}
			ct.runFunction("FlowExportPolicy", ctrlCtx, workFunc)
		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on FlowExportPolicy watch channel", tp)
	}

	return nil
}

// diffFlowExportPolicy does a diff of FlowExportPolicy objects between local cache and API server
func (ct *ctrlerCtx) diffFlowExportPolicy(apicl apiclient.Services) {
	opts := api.ListWatchOptions{}

	// get a list of all objects from API server
	objlist, err := apicl.MonitoringV1().FlowExportPolicy().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Errorf("Error getting a list of objects. Err: %v", err)
		return
	}

	ct.logger.Infof("diffFlowExportPolicy(): FlowExportPolicyList returned %d objects", len(objlist))

	// build an object map
	objmap := make(map[string]*monitoring.FlowExportPolicy)
	for _, obj := range objlist {
		objmap[obj.GetKey()] = obj
	}

	list, err := ct.FlowExportPolicy().List(context.Background(), &opts)
	if err != nil && !strings.Contains(err.Error(), "not found in local cache") {
		ct.logger.Infof("Failed to get a list of objects. Err: %s", err)
		return
	}

	// if an object is in our local cache and not in API server, trigger delete for it
	for _, obj := range list {
		_, ok := objmap[obj.GetKey()]
		if !ok {
			ct.logger.Infof("diffFlowExportPolicy(): Deleting existing object %#v since its not in apiserver", obj.GetKey())
			evt := kvstore.WatchEvent{
				Type:   kvstore.Deleted,
				Key:    obj.GetKey(),
				Object: &obj.FlowExportPolicy,
			}
			ct.handleFlowExportPolicyEvent(&evt)
		}
	}

	// trigger create event for all others
	for _, obj := range objlist {
		ct.logger.Infof("diffFlowExportPolicy(): Adding object %#v", obj.GetKey())
		evt := kvstore.WatchEvent{
			Type:   kvstore.Created,
			Key:    obj.GetKey(),
			Object: obj,
		}
		ct.handleFlowExportPolicyEvent(&evt)
	}
}

func (ct *ctrlerCtx) runFlowExportPolicyWatcher() {
	kind := "FlowExportPolicy"

	ct.Lock()
	handler, ok := ct.handlers[kind]
	ct.Unlock()
	if !ok {
		ct.logger.Fatalf("Cant find the handler for %s", kind)
	}
	flowexportpolicyHandler := handler.(FlowExportPolicyHandler)

	opts := flowexportpolicyHandler.GetFlowExportPolicyWatchOptions()

	// if there is no API server to connect to, we are done
	if (ct.resolver == nil) || ct.apisrvURL == "" {
		return
	}

	// create context
	ctx, cancel := context.WithCancel(context.Background())
	ct.Lock()
	ct.watchCancel[kind] = cancel
	ct.Unlock()
	logger := ct.logger.WithContext("submodule", "FlowExportPolicyWatcher")
	for {
		if ctx.Err() != nil {
			return
		}

		apiclt, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
		// create a grpc client
		if err == nil {
			// Upon successful connection perform the diff, and start watch goroutine
			ct.diffFlowExportPolicy(apiclt)
			break
		}

		logger.Warnf("Failed to connect to gRPC server [%s]\n", ct.apisrvURL)
		time.Sleep(time.Second)
	}

	// setup wait group
	ct.waitGrp.Add(1)

	// start a goroutine
	go func() {
		defer ct.waitGrp.Done()
		ct.stats.Counter("FlowExportPolicy_Watch").Inc()
		defer ct.stats.Counter("FlowExportPolicy_Watch").Dec()

		// loop forever
		for {
			// create a grpc client
			apicl, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
			if err != nil {
				logger.Warnf("Failed to connect to gRPC server [%s]\n", ct.apisrvURL)
				ct.stats.Counter("FlowExportPolicy_ApiClientErr").Inc()
			} else {
				logger.Infof("API client connected {%+v}", apicl)

				// FlowExportPolicy object watcher
				wt, werr := apicl.MonitoringV1().FlowExportPolicy().Watch(ctx, opts)
				if werr != nil {
					select {
					case <-ctx.Done():
						logger.Infof("watch %s cancelled", kind)
						return
					default:
					}
					logger.Errorf("Failed to start %s watch (%s)\n", kind, werr)
					// wait for a second and retry connecting to api server
					apicl.Close()
					time.Sleep(time.Second)
					continue
				}
				ct.Lock()
				ct.watchers[kind] = wt
				ct.Unlock()

				// perform a diff with API server and local cache
				// Sleeping to give time for other apiclient's to reconnect
				// before calling reconnect handler
				time.Sleep(time.Second)
				ct.diffFlowExportPolicy(apicl)
				flowexportpolicyHandler.OnFlowExportPolicyReconnect()

				// handle api server watch events
			innerLoop:
				for {
					// wait for events
					select {
					case evt, ok := <-wt.EventChan():
						if !ok {
							logger.Error("Error receiving from apisrv watcher")
							ct.stats.Counter("FlowExportPolicy_WatchErrors").Inc()
							break innerLoop
						}

						// handle event in parallel
						ct.handleFlowExportPolicyEventParallel(evt)
					}
				}
				apicl.Close()
			}

			// if stop flag is set, we are done
			if ct.stoped {
				logger.Infof("Exiting API server watcher")
				return
			}

			// wait for a second and retry connecting to api server
			time.Sleep(time.Second)
		}
	}()
}

// WatchFlowExportPolicy starts watch on FlowExportPolicy object
func (ct *ctrlerCtx) WatchFlowExportPolicy(handler FlowExportPolicyHandler) error {
	kind := "FlowExportPolicy"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchCancel[kind]
	ct.Unlock()
	if ok {
		return fmt.Errorf("FlowExportPolicy watcher already exists")
	}

	// save handler
	ct.Lock()
	ct.handlers[kind] = handler
	ct.Unlock()

	// run FlowExportPolicy watcher in a go routine
	ct.runFlowExportPolicyWatcher()

	return nil
}

// StopWatchFlowExportPolicy stops watch on FlowExportPolicy object
func (ct *ctrlerCtx) StopWatchFlowExportPolicy(handler FlowExportPolicyHandler) error {
	kind := "FlowExportPolicy"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchCancel[kind]
	ct.Unlock()
	if !ok {
		return fmt.Errorf("FlowExportPolicy watcher does not exist")
	}

	ct.Lock()
	cancel, _ := ct.watchCancel[kind]
	cancel()
	if _, ok := ct.watchers[kind]; ok {
		delete(ct.watchers, kind)
	}
	delete(ct.watchCancel, kind)
	ct.Unlock()

	time.Sleep(100 * time.Millisecond)

	return nil
}

// FlowExportPolicyAPI returns
type FlowExportPolicyAPI interface {
	Create(obj *monitoring.FlowExportPolicy) error
	SyncCreate(obj *monitoring.FlowExportPolicy) error
	Update(obj *monitoring.FlowExportPolicy) error
	SyncUpdate(obj *monitoring.FlowExportPolicy) error
	Label(obj *api.Label) error
	Delete(obj *monitoring.FlowExportPolicy) error
	Find(meta *api.ObjectMeta) (*FlowExportPolicy, error)
	List(ctx context.Context, opts *api.ListWatchOptions) ([]*FlowExportPolicy, error)
	ApisrvList(ctx context.Context, opts *api.ListWatchOptions) ([]*monitoring.FlowExportPolicy, error)
	Watch(handler FlowExportPolicyHandler) error
	ClearCache(handler FlowExportPolicyHandler)
	StopWatch(handler FlowExportPolicyHandler) error
}

// dummy struct that implements FlowExportPolicyAPI
type flowexportpolicyAPI struct {
	ct *ctrlerCtx
}

// Create creates FlowExportPolicy object
func (api *flowexportpolicyAPI) Create(obj *monitoring.FlowExportPolicy) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.MonitoringV1().FlowExportPolicy().Create(context.Background(), obj)
		if err != nil && strings.Contains(err.Error(), "AlreadyExists") {
			_, err = apicl.MonitoringV1().FlowExportPolicy().Update(context.Background(), obj)

		}
		return err
	}

	api.ct.handleFlowExportPolicyEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Created})
	return nil
}

// SyncCreate creates FlowExportPolicy object and updates the cache
func (api *flowexportpolicyAPI) SyncCreate(obj *monitoring.FlowExportPolicy) error {
	newObj := obj
	evtType := kvstore.Created
	var writeErr error
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		newObj, writeErr = apicl.MonitoringV1().FlowExportPolicy().Create(context.Background(), obj)
		if writeErr != nil && strings.Contains(writeErr.Error(), "AlreadyExists") {
			newObj, writeErr = apicl.MonitoringV1().FlowExportPolicy().Update(context.Background(), obj)
			evtType = kvstore.Updated
		}
	}

	if writeErr == nil {
		api.ct.handleFlowExportPolicyEvent(&kvstore.WatchEvent{Object: newObj, Type: evtType})
	}
	return writeErr
}

// Update triggers update on FlowExportPolicy object
func (api *flowexportpolicyAPI) Update(obj *monitoring.FlowExportPolicy) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.MonitoringV1().FlowExportPolicy().Update(context.Background(), obj)
		return err
	}

	api.ct.handleFlowExportPolicyEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Updated})
	return nil
}

// SyncUpdate triggers update on FlowExportPolicy object and updates the cache
func (api *flowexportpolicyAPI) SyncUpdate(obj *monitoring.FlowExportPolicy) error {
	if api.ct.objResolver != nil {
		log.Fatal("Cannot use Sync update when object resolver is enabled on ctkit")
	}
	newObj := obj
	var writeErr error
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		newObj, writeErr = apicl.MonitoringV1().FlowExportPolicy().Update(context.Background(), obj)
	}

	if writeErr == nil {
		api.ct.handleFlowExportPolicyEvent(&kvstore.WatchEvent{Object: newObj, Type: kvstore.Updated})
	}

	return writeErr
}

// Label labels FlowExportPolicy object
func (api *flowexportpolicyAPI) Label(obj *api.Label) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.MonitoringV1().FlowExportPolicy().Label(context.Background(), obj)
		return err
	}

	ctkitObj, err := api.Find(obj.GetObjectMeta())
	if err != nil {
		return err
	}
	writeObj := ctkitObj.FlowExportPolicy
	writeObj.Labels = obj.Labels

	api.ct.handleFlowExportPolicyEvent(&kvstore.WatchEvent{Object: &writeObj, Type: kvstore.Updated})
	return nil
}

// Delete deletes FlowExportPolicy object
func (api *flowexportpolicyAPI) Delete(obj *monitoring.FlowExportPolicy) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.MonitoringV1().FlowExportPolicy().Delete(context.Background(), &obj.ObjectMeta)
		return err
	}

	api.ct.handleFlowExportPolicyEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Deleted})
	return nil
}

// MakeKey generates a KV store key for the object
func (api *flowexportpolicyAPI) getFullKey(tenant, name string) string {
	if tenant != "" {
		return fmt.Sprint(globals.ConfigRootPrefix, "/", "monitoring", "/", "flowExportPolicy", "/", tenant, "/", name)
	}
	return fmt.Sprint(globals.ConfigRootPrefix, "/", "monitoring", "/", "flowExportPolicy", "/", name)
}

// Find returns an object by meta
func (api *flowexportpolicyAPI) Find(meta *api.ObjectMeta) (*FlowExportPolicy, error) {
	// find the object
	obj, err := api.ct.FindObject("FlowExportPolicy", meta)
	if err != nil {
		return nil, err
	}

	// asset type
	switch obj.(type) {
	case *FlowExportPolicy:
		hobj := obj.(*FlowExportPolicy)
		return hobj, nil
	default:
		return nil, errors.New("incorrect object type")
	}
}

// List returns a list of all FlowExportPolicy objects
func (api *flowexportpolicyAPI) List(ctx context.Context, opts *api.ListWatchOptions) ([]*FlowExportPolicy, error) {
	var objlist []*FlowExportPolicy
	objs, err := api.ct.List("FlowExportPolicy", ctx, opts)

	if err != nil {
		return nil, err
	}

	for _, obj := range objs {
		switch tp := obj.(type) {
		case *FlowExportPolicy:
			eobj := obj.(*FlowExportPolicy)
			objlist = append(objlist, eobj)
		default:
			log.Fatalf("Got invalid object type %v while looking for FlowExportPolicy", tp)
		}
	}

	return objlist, nil
}

// ApisrvList returns a list of all FlowExportPolicy objects from apiserver
func (api *flowexportpolicyAPI) ApisrvList(ctx context.Context, opts *api.ListWatchOptions) ([]*monitoring.FlowExportPolicy, error) {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return nil, err
		}

		return apicl.MonitoringV1().FlowExportPolicy().List(context.Background(), opts)
	}

	// List from local cache
	ctkitObjs, err := api.List(ctx, opts)
	if err != nil {
		return nil, err
	}
	var ret []*monitoring.FlowExportPolicy
	for _, obj := range ctkitObjs {
		ret = append(ret, &obj.FlowExportPolicy)
	}
	return ret, nil
}

// Watch sets up a event handlers for FlowExportPolicy object
func (api *flowexportpolicyAPI) Watch(handler FlowExportPolicyHandler) error {
	api.ct.startWorkerPool("FlowExportPolicy")
	return api.ct.WatchFlowExportPolicy(handler)
}

// StopWatch stop watch for Tenant FlowExportPolicy object
func (api *flowexportpolicyAPI) StopWatch(handler FlowExportPolicyHandler) error {
	api.ct.Lock()
	api.ct.workPools["FlowExportPolicy"].Stop()
	api.ct.Unlock()
	return api.ct.StopWatchFlowExportPolicy(handler)
}

// ClearCache removes all FlowExportPolicy objects in ctkit
func (api *flowexportpolicyAPI) ClearCache(handler FlowExportPolicyHandler) {
	api.ct.delKind("FlowExportPolicy")
}

// FlowExportPolicy returns FlowExportPolicyAPI
func (ct *ctrlerCtx) FlowExportPolicy() FlowExportPolicyAPI {
	kind := "FlowExportPolicy"
	if _, ok := ct.apiInfMap[kind]; !ok {
		s := &flowexportpolicyAPI{ct: ct}
		ct.apiInfMap[kind] = s
	}
	return ct.apiInfMap[kind].(*flowexportpolicyAPI)
}

// Alert is a wrapper object that implements additional functionality
type Alert struct {
	sync.Mutex
	monitoring.Alert
	HandlerCtx interface{} // additional state handlers can store
	ctrler     *ctrlerCtx  // reference back to the controller instance
	internal   bool
}

func (obj *Alert) SetInternal() {
	obj.internal = true
}

func (obj *Alert) Write() error {
	// if there is no API server to connect to, we are done
	if (obj.ctrler == nil) || (obj.ctrler.resolver == nil) || obj.ctrler.apisrvURL == "" {
		return nil
	}

	apicl, err := obj.ctrler.apiClient()
	if err != nil {
		obj.ctrler.logger.Errorf("Error creating API server clent. Err: %v", err)
		return err
	}

	obj.ctrler.stats.Counter("Alert_Writes").Inc()

	// write to api server
	if obj.ObjectMeta.ResourceVersion != "" {
		// update it
		for i := 0; i < maxApisrvWriteRetry; i++ {
			_, err = apicl.MonitoringV1().Alert().UpdateStatus(context.Background(), &obj.Alert)
			if err == nil {
				break
			}
			time.Sleep(time.Millisecond * 100)
		}
	} else {
		//  create
		_, err = apicl.MonitoringV1().Alert().Create(context.Background(), &obj.Alert)
	}

	return nil
}

// AlertHandler is the event handler for Alert object
type AlertHandler interface {
	OnAlertCreate(obj *Alert) error
	OnAlertUpdate(oldObj *Alert, newObj *monitoring.Alert) error
	OnAlertDelete(obj *Alert) error
	GetAlertWatchOptions() *api.ListWatchOptions
	OnAlertReconnect()
}

// OnAlertCreate is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnAlertCreate(obj *Alert) error {
	log.Info("OnAlertCreate is not implemented")
	return nil
}

// OnAlertUpdate is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnAlertUpdate(oldObj *Alert, newObj *monitoring.Alert) error {
	log.Info("OnAlertUpdate is not implemented")
	return nil
}

// OnAlertDelete is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnAlertDelete(obj *Alert) error {
	log.Info("OnAlertDelete is not implemented")
	return nil
}

// GetAlertWatchOptions is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) GetAlertWatchOptions() *api.ListWatchOptions {
	log.Info("GetAlertWatchOptions is not implemented")
	opts := &api.ListWatchOptions{}
	return opts
}

// OnAlertReconnect is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnAlertReconnect() {
	log.Info("OnAlertReconnect is not implemented")
	return
}

// handleAlertEvent handles Alert events from watcher
func (ct *ctrlerCtx) handleAlertEvent(evt *kvstore.WatchEvent) error {

	if ct.objResolver == nil {
		return ct.handleAlertEventNoResolver(evt)
	}

	switch tp := evt.Object.(type) {
	case *monitoring.Alert:
		eobj := evt.Object.(*monitoring.Alert)
		kind := "Alert"

		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ctx := &alertCtx{event: evt.Type,
			obj: &Alert{Alert: *eobj, ctrler: ct}}

		var err error
		switch evt.Type {
		case kvstore.Created:
			err = ct.processAdd(ctx)
		case kvstore.Updated:
			err = ct.processUpdate(ctx)
		case kvstore.Deleted:
			err = ct.processDelete(ctx)
		}
		return err
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on Alert watch channel", tp)
	}

	return nil
}

// handleAlertEventNoResolver handles Alert events from watcher
func (ct *ctrlerCtx) handleAlertEventNoResolver(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *monitoring.Alert:
		eobj := evt.Object.(*monitoring.Alert)
		kind := "Alert"

		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		alertHandler := handler.(AlertHandler)
		// handle based on event type
		ctrlCtx := &alertCtx{event: evt.Type, obj: &Alert{Alert: *eobj, ctrler: ct}}
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			fobj, err := ct.getObject(kind, ctrlCtx.GetKey())
			if err != nil {
				ct.addObject(ctrlCtx)
				ct.stats.Counter("Alert_Created_Events").Inc()

				// call the event handler
				ctrlCtx.Lock()
				err = alertHandler.OnAlertCreate(ctrlCtx.obj)
				ctrlCtx.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctrlCtx.obj.GetObjectMeta(), err)
					ct.delObject(kind, ctrlCtx.GetKey())
					return err
				}
			} else {
				fResVer, fErr := strconv.ParseInt(fobj.GetResourceVersion(), 10, 64)
				eResVer, eErr := strconv.ParseInt(eobj.GetResourceVersion(), 10, 64)
				if ct.resolver != nil && fErr == nil && eErr == nil && fResVer >= eResVer {
					// Event already processed.
					ct.logger.Infof("Skipping update due to old resource version")
					return nil
				}
				ctrlCtx := fobj.(*alertCtx)
				ct.stats.Counter("Alert_Updated_Events").Inc()
				ctrlCtx.Lock()
				p := monitoring.Alert{Spec: eobj.Spec,
					ObjectMeta: eobj.ObjectMeta,
					TypeMeta:   eobj.TypeMeta,
					Status:     eobj.Status}

				err = alertHandler.OnAlertUpdate(ctrlCtx.obj, &p)
				ctrlCtx.obj.Alert = *eobj
				ctrlCtx.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctrlCtx.obj.GetObjectMeta(), err)
					return err
				}

			}
		case kvstore.Deleted:
			ctrlCtx := &alertCtx{event: evt.Type, obj: &Alert{Alert: *eobj, ctrler: ct}}
			fobj, err := ct.findObject(kind, ctrlCtx.GetKey())
			if err != nil {
				ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
				return err
			}

			obj := fobj.(*Alert)
			ct.stats.Counter("Alert_Deleted_Events").Inc()
			obj.Lock()
			err = alertHandler.OnAlertDelete(obj)
			obj.Unlock()
			if err != nil {
				ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj.GetObjectMeta(), err)
			}
			ct.delObject(kind, ctrlCtx.GetKey())
			return nil

		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on Alert watch channel", tp)
	}

	return nil
}

type alertCtx struct {
	ctkitBaseCtx
	event kvstore.WatchEventType
	obj   *Alert //
	//   newObj     *monitoring.Alert //update
	newObj *alertCtx //update
}

func (ctx *alertCtx) References() map[string]apiintf.ReferenceObj {
	if ctx.references == nil {
		resp := make(map[string]apiintf.ReferenceObj)
		ctx.references = resp
		ctx.obj.References(ctx.obj.GetObjectMeta().Name, ctx.obj.GetObjectMeta().Namespace, resp)
		ctx.obj.ctrler.filterOutRefs(ctx)
	}
	return ctx.references
}

func (ctx *alertCtx) GetKey() string {
	return ctx.obj.MakeKey("monitoring")

}

func (ctx *alertCtx) IsInternal() bool {
	return ctx.obj.internal
}

func (ctx *alertCtx) GetKind() string {
	return ctx.obj.GetKind()
}

func (ctx *alertCtx) GetResourceVersion() string {
	return ctx.obj.GetResourceVersion()
}

func (ctx *alertCtx) SetEvent(event kvstore.WatchEventType) {
	ctx.event = event
}

func (ctx *alertCtx) SetNewObj(newObj apiintf.CtkitObject) {
	if newObj == nil {
		ctx.newObj = nil
	} else {
		ctx.newObj = newObj.(*alertCtx)
		ctx.newObj.obj.HandlerCtx = ctx.obj.HandlerCtx
		ctx.references = newObj.References()
	}
}

func (ctx *alertCtx) GetNewObj() apiintf.CtkitObject {
	return ctx.newObj
}

func (ctx *alertCtx) Copy(obj apiintf.CtkitObject) {
	ctx.obj.Alert = obj.(*alertCtx).obj.Alert
	ctx.SetWatchTs(obj.GetWatchTs())
}

func (ctx *alertCtx) Lock() {
	ctx.obj.Lock()
}

func (ctx *alertCtx) Unlock() {
	ctx.obj.Unlock()
}

func (ctx *alertCtx) GetObjectMeta() *api.ObjectMeta {
	return ctx.obj.GetObjectMeta()
}

func (ctx *alertCtx) RuntimeObject() runtime.Object {
	var v interface{}
	v = ctx.obj
	return v.(runtime.Object)
}

func (ctx *alertCtx) WorkFunc(context context.Context) error {
	var err error
	evt := ctx.event
	ct := ctx.obj.ctrler
	kind := "Alert"
	ct.Lock()
	handler, ok := ct.handlers[kind]
	ct.Unlock()
	if !ok {
		ct.logger.Fatalf("Cant find the handler for %s", kind)
	}
	alertHandler := handler.(AlertHandler)
	switch evt {
	case kvstore.Created:
		ctx.obj.Lock()
		err = alertHandler.OnAlertCreate(ctx.obj)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctx.obj.GetObjectMeta(), err)
			ctx.SetEvent(kvstore.Deleted)
		}
	case kvstore.Updated:
		ct.stats.Counter("Alert_Updated_Events").Inc()
		ctx.obj.Lock()
		p := monitoring.Alert{Spec: ctx.newObj.obj.Spec,
			ObjectMeta: ctx.newObj.obj.ObjectMeta,
			TypeMeta:   ctx.newObj.obj.TypeMeta,
			Status:     ctx.newObj.obj.Status}
		err = alertHandler.OnAlertUpdate(ctx.obj, &p)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctx.obj.GetObjectMeta(), err)
			ctx.SetEvent(kvstore.Deleted)
		}
	case kvstore.Deleted:
		ctx.obj.Lock()
		err = alertHandler.OnAlertDelete(ctx.obj)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error deleting %s %+v. Err: %v", kind, ctx.obj.GetObjectMeta(), err)
		}
	}
	ct.resolveObject(ctx.event, ctx)
	return nil
}

// handleAlertEventParallel handles Alert events from watcher
func (ct *ctrlerCtx) handleAlertEventParallel(evt *kvstore.WatchEvent) error {

	if ct.objResolver == nil {
		return ct.handleAlertEventParallelWithNoResolver(evt)
	}

	switch tp := evt.Object.(type) {
	case *monitoring.Alert:
		eobj := evt.Object.(*monitoring.Alert)
		kind := "Alert"

		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ctx := &alertCtx{event: evt.Type, obj: &Alert{Alert: *eobj, ctrler: ct}}
		ctx.SetWatchTs(evt.WatchTS)

		var err error
		switch evt.Type {
		case kvstore.Created:
			err = ct.processAdd(ctx)
		case kvstore.Updated:
			err = ct.processUpdate(ctx)
		case kvstore.Deleted:
			err = ct.processDelete(ctx)
		}
		return err
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on Alert watch channel", tp)
	}

	return nil
}

// handleAlertEventParallel handles Alert events from watcher
func (ct *ctrlerCtx) handleAlertEventParallelWithNoResolver(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *monitoring.Alert:
		eobj := evt.Object.(*monitoring.Alert)
		kind := "Alert"

		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		alertHandler := handler.(AlertHandler)
		// handle based on event type
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			workFunc := func(ctx context.Context, ctrlCtx shardworkers.WorkObj) error {
				var err error
				workCtx := ctrlCtx.(*alertCtx)
				eobj := workCtx.obj
				fobj, err := ct.getObject(kind, workCtx.GetKey())
				if err != nil {
					ct.addObject(workCtx)
					ct.stats.Counter("Alert_Created_Events").Inc()
					eobj.Lock()
					err = alertHandler.OnAlertCreate(eobj)
					eobj.Unlock()
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, eobj.GetObjectMeta(), err)
						ct.delObject(kind, workCtx.GetKey())
					}
				} else {
					workCtx = fobj.(*alertCtx)
					obj := workCtx.obj
					ct.stats.Counter("Alert_Updated_Events").Inc()
					obj.Lock()
					p := monitoring.Alert{Spec: eobj.Spec,
						ObjectMeta: eobj.ObjectMeta,
						TypeMeta:   eobj.TypeMeta,
						Status:     eobj.Status}

					err = alertHandler.OnAlertUpdate(obj, &p)
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj.GetObjectMeta(), err)
					} else {
						workCtx.obj.Alert = p
					}
					obj.Unlock()
				}
				workCtx.SetWatchTs(evt.WatchTS)
				return err
			}
			ctrlCtx := &alertCtx{event: evt.Type, obj: &Alert{Alert: *eobj, ctrler: ct}}
			ct.runFunction("Alert", ctrlCtx, workFunc)
		case kvstore.Deleted:
			workFunc := func(ctx context.Context, ctrlCtx shardworkers.WorkObj) error {
				var err error
				workCtx := ctrlCtx.(*alertCtx)
				eobj := workCtx.obj
				fobj, err := ct.findObject(kind, workCtx.GetKey())
				if err != nil {
					ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
					return err
				}
				obj := fobj.(*Alert)
				ct.stats.Counter("Alert_Deleted_Events").Inc()
				obj.Lock()
				err = alertHandler.OnAlertDelete(obj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj.GetObjectMeta(), err)
				}
				ct.delObject(kind, workCtx.GetKey())
				return nil
			}
			ctrlCtx := &alertCtx{event: evt.Type, obj: &Alert{Alert: *eobj, ctrler: ct}}
			ct.runFunction("Alert", ctrlCtx, workFunc)
		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on Alert watch channel", tp)
	}

	return nil
}

// diffAlert does a diff of Alert objects between local cache and API server
func (ct *ctrlerCtx) diffAlert(apicl apiclient.Services) {
	opts := api.ListWatchOptions{}

	// get a list of all objects from API server
	objlist, err := apicl.MonitoringV1().Alert().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Errorf("Error getting a list of objects. Err: %v", err)
		return
	}

	ct.logger.Infof("diffAlert(): AlertList returned %d objects", len(objlist))

	// build an object map
	objmap := make(map[string]*monitoring.Alert)
	for _, obj := range objlist {
		objmap[obj.GetKey()] = obj
	}

	list, err := ct.Alert().List(context.Background(), &opts)
	if err != nil && !strings.Contains(err.Error(), "not found in local cache") {
		ct.logger.Infof("Failed to get a list of objects. Err: %s", err)
		return
	}

	// if an object is in our local cache and not in API server, trigger delete for it
	for _, obj := range list {
		_, ok := objmap[obj.GetKey()]
		if !ok {
			ct.logger.Infof("diffAlert(): Deleting existing object %#v since its not in apiserver", obj.GetKey())
			evt := kvstore.WatchEvent{
				Type:   kvstore.Deleted,
				Key:    obj.GetKey(),
				Object: &obj.Alert,
			}
			ct.handleAlertEvent(&evt)
		}
	}

	// trigger create event for all others
	for _, obj := range objlist {
		ct.logger.Infof("diffAlert(): Adding object %#v", obj.GetKey())
		evt := kvstore.WatchEvent{
			Type:   kvstore.Created,
			Key:    obj.GetKey(),
			Object: obj,
		}
		ct.handleAlertEvent(&evt)
	}
}

func (ct *ctrlerCtx) runAlertWatcher() {
	kind := "Alert"

	ct.Lock()
	handler, ok := ct.handlers[kind]
	ct.Unlock()
	if !ok {
		ct.logger.Fatalf("Cant find the handler for %s", kind)
	}
	alertHandler := handler.(AlertHandler)

	opts := alertHandler.GetAlertWatchOptions()

	// if there is no API server to connect to, we are done
	if (ct.resolver == nil) || ct.apisrvURL == "" {
		return
	}

	// create context
	ctx, cancel := context.WithCancel(context.Background())
	ct.Lock()
	ct.watchCancel[kind] = cancel
	ct.Unlock()
	logger := ct.logger.WithContext("submodule", "AlertWatcher")
	for {
		if ctx.Err() != nil {
			return
		}

		apiclt, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
		// create a grpc client
		if err == nil {
			// Upon successful connection perform the diff, and start watch goroutine
			ct.diffAlert(apiclt)
			break
		}

		logger.Warnf("Failed to connect to gRPC server [%s]\n", ct.apisrvURL)
		time.Sleep(time.Second)
	}

	// setup wait group
	ct.waitGrp.Add(1)

	// start a goroutine
	go func() {
		defer ct.waitGrp.Done()
		ct.stats.Counter("Alert_Watch").Inc()
		defer ct.stats.Counter("Alert_Watch").Dec()

		// loop forever
		for {
			// create a grpc client
			apicl, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
			if err != nil {
				logger.Warnf("Failed to connect to gRPC server [%s]\n", ct.apisrvURL)
				ct.stats.Counter("Alert_ApiClientErr").Inc()
			} else {
				logger.Infof("API client connected {%+v}", apicl)

				// Alert object watcher
				wt, werr := apicl.MonitoringV1().Alert().Watch(ctx, opts)
				if werr != nil {
					select {
					case <-ctx.Done():
						logger.Infof("watch %s cancelled", kind)
						return
					default:
					}
					logger.Errorf("Failed to start %s watch (%s)\n", kind, werr)
					// wait for a second and retry connecting to api server
					apicl.Close()
					time.Sleep(time.Second)
					continue
				}
				ct.Lock()
				ct.watchers[kind] = wt
				ct.Unlock()

				// perform a diff with API server and local cache
				// Sleeping to give time for other apiclient's to reconnect
				// before calling reconnect handler
				time.Sleep(time.Second)
				ct.diffAlert(apicl)
				alertHandler.OnAlertReconnect()

				// handle api server watch events
			innerLoop:
				for {
					// wait for events
					select {
					case evt, ok := <-wt.EventChan():
						if !ok {
							logger.Error("Error receiving from apisrv watcher")
							ct.stats.Counter("Alert_WatchErrors").Inc()
							break innerLoop
						}

						// handle event in parallel
						ct.handleAlertEventParallel(evt)
					}
				}
				apicl.Close()
			}

			// if stop flag is set, we are done
			if ct.stoped {
				logger.Infof("Exiting API server watcher")
				return
			}

			// wait for a second and retry connecting to api server
			time.Sleep(time.Second)
		}
	}()
}

// WatchAlert starts watch on Alert object
func (ct *ctrlerCtx) WatchAlert(handler AlertHandler) error {
	kind := "Alert"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchCancel[kind]
	ct.Unlock()
	if ok {
		return fmt.Errorf("Alert watcher already exists")
	}

	// save handler
	ct.Lock()
	ct.handlers[kind] = handler
	ct.Unlock()

	// run Alert watcher in a go routine
	ct.runAlertWatcher()

	return nil
}

// StopWatchAlert stops watch on Alert object
func (ct *ctrlerCtx) StopWatchAlert(handler AlertHandler) error {
	kind := "Alert"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchCancel[kind]
	ct.Unlock()
	if !ok {
		return fmt.Errorf("Alert watcher does not exist")
	}

	ct.Lock()
	cancel, _ := ct.watchCancel[kind]
	cancel()
	if _, ok := ct.watchers[kind]; ok {
		delete(ct.watchers, kind)
	}
	delete(ct.watchCancel, kind)
	ct.Unlock()

	time.Sleep(100 * time.Millisecond)

	return nil
}

// AlertAPI returns
type AlertAPI interface {
	Create(obj *monitoring.Alert) error
	SyncCreate(obj *monitoring.Alert) error
	Update(obj *monitoring.Alert) error
	SyncUpdate(obj *monitoring.Alert) error
	Label(obj *api.Label) error
	Delete(obj *monitoring.Alert) error
	Find(meta *api.ObjectMeta) (*Alert, error)
	List(ctx context.Context, opts *api.ListWatchOptions) ([]*Alert, error)
	ApisrvList(ctx context.Context, opts *api.ListWatchOptions) ([]*monitoring.Alert, error)
	Watch(handler AlertHandler) error
	ClearCache(handler AlertHandler)
	StopWatch(handler AlertHandler) error
}

// dummy struct that implements AlertAPI
type alertAPI struct {
	ct *ctrlerCtx
}

// Create creates Alert object
func (api *alertAPI) Create(obj *monitoring.Alert) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.MonitoringV1().Alert().Create(context.Background(), obj)
		if err != nil && strings.Contains(err.Error(), "AlreadyExists") {
			_, err = apicl.MonitoringV1().Alert().Update(context.Background(), obj)

		}
		return err
	}

	api.ct.handleAlertEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Created})
	return nil
}

// SyncCreate creates Alert object and updates the cache
func (api *alertAPI) SyncCreate(obj *monitoring.Alert) error {
	newObj := obj
	evtType := kvstore.Created
	var writeErr error
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		newObj, writeErr = apicl.MonitoringV1().Alert().Create(context.Background(), obj)
		if writeErr != nil && strings.Contains(writeErr.Error(), "AlreadyExists") {
			newObj, writeErr = apicl.MonitoringV1().Alert().Update(context.Background(), obj)
			evtType = kvstore.Updated
		}
	}

	if writeErr == nil {
		api.ct.handleAlertEvent(&kvstore.WatchEvent{Object: newObj, Type: evtType})
	}
	return writeErr
}

// Update triggers update on Alert object
func (api *alertAPI) Update(obj *monitoring.Alert) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.MonitoringV1().Alert().Update(context.Background(), obj)
		return err
	}

	api.ct.handleAlertEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Updated})
	return nil
}

// SyncUpdate triggers update on Alert object and updates the cache
func (api *alertAPI) SyncUpdate(obj *monitoring.Alert) error {
	if api.ct.objResolver != nil {
		log.Fatal("Cannot use Sync update when object resolver is enabled on ctkit")
	}
	newObj := obj
	var writeErr error
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		newObj, writeErr = apicl.MonitoringV1().Alert().Update(context.Background(), obj)
	}

	if writeErr == nil {
		api.ct.handleAlertEvent(&kvstore.WatchEvent{Object: newObj, Type: kvstore.Updated})
	}

	return writeErr
}

// Label labels Alert object
func (api *alertAPI) Label(obj *api.Label) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.MonitoringV1().Alert().Label(context.Background(), obj)
		return err
	}

	ctkitObj, err := api.Find(obj.GetObjectMeta())
	if err != nil {
		return err
	}
	writeObj := ctkitObj.Alert
	writeObj.Labels = obj.Labels

	api.ct.handleAlertEvent(&kvstore.WatchEvent{Object: &writeObj, Type: kvstore.Updated})
	return nil
}

// Delete deletes Alert object
func (api *alertAPI) Delete(obj *monitoring.Alert) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.MonitoringV1().Alert().Delete(context.Background(), &obj.ObjectMeta)
		return err
	}

	api.ct.handleAlertEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Deleted})
	return nil
}

// MakeKey generates a KV store key for the object
func (api *alertAPI) getFullKey(tenant, name string) string {
	if tenant != "" {
		return fmt.Sprint(globals.ConfigRootPrefix, "/", "monitoring", "/", "alerts", "/", tenant, "/", name)
	}
	return fmt.Sprint(globals.ConfigRootPrefix, "/", "monitoring", "/", "alerts", "/", name)
}

// Find returns an object by meta
func (api *alertAPI) Find(meta *api.ObjectMeta) (*Alert, error) {
	// find the object
	obj, err := api.ct.FindObject("Alert", meta)
	if err != nil {
		return nil, err
	}

	// asset type
	switch obj.(type) {
	case *Alert:
		hobj := obj.(*Alert)
		return hobj, nil
	default:
		return nil, errors.New("incorrect object type")
	}
}

// List returns a list of all Alert objects
func (api *alertAPI) List(ctx context.Context, opts *api.ListWatchOptions) ([]*Alert, error) {
	var objlist []*Alert
	objs, err := api.ct.List("Alert", ctx, opts)

	if err != nil {
		return nil, err
	}

	for _, obj := range objs {
		switch tp := obj.(type) {
		case *Alert:
			eobj := obj.(*Alert)
			objlist = append(objlist, eobj)
		default:
			log.Fatalf("Got invalid object type %v while looking for Alert", tp)
		}
	}

	return objlist, nil
}

// ApisrvList returns a list of all Alert objects from apiserver
func (api *alertAPI) ApisrvList(ctx context.Context, opts *api.ListWatchOptions) ([]*monitoring.Alert, error) {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return nil, err
		}

		return apicl.MonitoringV1().Alert().List(context.Background(), opts)
	}

	// List from local cache
	ctkitObjs, err := api.List(ctx, opts)
	if err != nil {
		return nil, err
	}
	var ret []*monitoring.Alert
	for _, obj := range ctkitObjs {
		ret = append(ret, &obj.Alert)
	}
	return ret, nil
}

// Watch sets up a event handlers for Alert object
func (api *alertAPI) Watch(handler AlertHandler) error {
	api.ct.startWorkerPool("Alert")
	return api.ct.WatchAlert(handler)
}

// StopWatch stop watch for Tenant Alert object
func (api *alertAPI) StopWatch(handler AlertHandler) error {
	api.ct.Lock()
	api.ct.workPools["Alert"].Stop()
	api.ct.Unlock()
	return api.ct.StopWatchAlert(handler)
}

// ClearCache removes all Alert objects in ctkit
func (api *alertAPI) ClearCache(handler AlertHandler) {
	api.ct.delKind("Alert")
}

// Alert returns AlertAPI
func (ct *ctrlerCtx) Alert() AlertAPI {
	kind := "Alert"
	if _, ok := ct.apiInfMap[kind]; !ok {
		s := &alertAPI{ct: ct}
		ct.apiInfMap[kind] = s
	}
	return ct.apiInfMap[kind].(*alertAPI)
}

// AlertPolicy is a wrapper object that implements additional functionality
type AlertPolicy struct {
	sync.Mutex
	monitoring.AlertPolicy
	HandlerCtx interface{} // additional state handlers can store
	ctrler     *ctrlerCtx  // reference back to the controller instance
	internal   bool
}

func (obj *AlertPolicy) SetInternal() {
	obj.internal = true
}

func (obj *AlertPolicy) Write() error {
	// if there is no API server to connect to, we are done
	if (obj.ctrler == nil) || (obj.ctrler.resolver == nil) || obj.ctrler.apisrvURL == "" {
		return nil
	}

	apicl, err := obj.ctrler.apiClient()
	if err != nil {
		obj.ctrler.logger.Errorf("Error creating API server clent. Err: %v", err)
		return err
	}

	obj.ctrler.stats.Counter("AlertPolicy_Writes").Inc()

	// write to api server
	if obj.ObjectMeta.ResourceVersion != "" {
		// update it
		for i := 0; i < maxApisrvWriteRetry; i++ {
			_, err = apicl.MonitoringV1().AlertPolicy().UpdateStatus(context.Background(), &obj.AlertPolicy)
			if err == nil {
				break
			}
			time.Sleep(time.Millisecond * 100)
		}
	} else {
		//  create
		_, err = apicl.MonitoringV1().AlertPolicy().Create(context.Background(), &obj.AlertPolicy)
	}

	return nil
}

// AlertPolicyHandler is the event handler for AlertPolicy object
type AlertPolicyHandler interface {
	OnAlertPolicyCreate(obj *AlertPolicy) error
	OnAlertPolicyUpdate(oldObj *AlertPolicy, newObj *monitoring.AlertPolicy) error
	OnAlertPolicyDelete(obj *AlertPolicy) error
	GetAlertPolicyWatchOptions() *api.ListWatchOptions
	OnAlertPolicyReconnect()
}

// OnAlertPolicyCreate is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnAlertPolicyCreate(obj *AlertPolicy) error {
	log.Info("OnAlertPolicyCreate is not implemented")
	return nil
}

// OnAlertPolicyUpdate is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnAlertPolicyUpdate(oldObj *AlertPolicy, newObj *monitoring.AlertPolicy) error {
	log.Info("OnAlertPolicyUpdate is not implemented")
	return nil
}

// OnAlertPolicyDelete is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnAlertPolicyDelete(obj *AlertPolicy) error {
	log.Info("OnAlertPolicyDelete is not implemented")
	return nil
}

// GetAlertPolicyWatchOptions is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) GetAlertPolicyWatchOptions() *api.ListWatchOptions {
	log.Info("GetAlertPolicyWatchOptions is not implemented")
	opts := &api.ListWatchOptions{}
	return opts
}

// OnAlertPolicyReconnect is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnAlertPolicyReconnect() {
	log.Info("OnAlertPolicyReconnect is not implemented")
	return
}

// handleAlertPolicyEvent handles AlertPolicy events from watcher
func (ct *ctrlerCtx) handleAlertPolicyEvent(evt *kvstore.WatchEvent) error {

	if ct.objResolver == nil {
		return ct.handleAlertPolicyEventNoResolver(evt)
	}

	switch tp := evt.Object.(type) {
	case *monitoring.AlertPolicy:
		eobj := evt.Object.(*monitoring.AlertPolicy)
		kind := "AlertPolicy"

		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ctx := &alertpolicyCtx{event: evt.Type,
			obj: &AlertPolicy{AlertPolicy: *eobj, ctrler: ct}}

		var err error
		switch evt.Type {
		case kvstore.Created:
			err = ct.processAdd(ctx)
		case kvstore.Updated:
			err = ct.processUpdate(ctx)
		case kvstore.Deleted:
			err = ct.processDelete(ctx)
		}
		return err
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on AlertPolicy watch channel", tp)
	}

	return nil
}

// handleAlertPolicyEventNoResolver handles AlertPolicy events from watcher
func (ct *ctrlerCtx) handleAlertPolicyEventNoResolver(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *monitoring.AlertPolicy:
		eobj := evt.Object.(*monitoring.AlertPolicy)
		kind := "AlertPolicy"

		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		alertpolicyHandler := handler.(AlertPolicyHandler)
		// handle based on event type
		ctrlCtx := &alertpolicyCtx{event: evt.Type, obj: &AlertPolicy{AlertPolicy: *eobj, ctrler: ct}}
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			fobj, err := ct.getObject(kind, ctrlCtx.GetKey())
			if err != nil {
				ct.addObject(ctrlCtx)
				ct.stats.Counter("AlertPolicy_Created_Events").Inc()

				// call the event handler
				ctrlCtx.Lock()
				err = alertpolicyHandler.OnAlertPolicyCreate(ctrlCtx.obj)
				ctrlCtx.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctrlCtx.obj.GetObjectMeta(), err)
					ct.delObject(kind, ctrlCtx.GetKey())
					return err
				}
			} else {
				fResVer, fErr := strconv.ParseInt(fobj.GetResourceVersion(), 10, 64)
				eResVer, eErr := strconv.ParseInt(eobj.GetResourceVersion(), 10, 64)
				if ct.resolver != nil && fErr == nil && eErr == nil && fResVer >= eResVer {
					// Event already processed.
					ct.logger.Infof("Skipping update due to old resource version")
					return nil
				}
				ctrlCtx := fobj.(*alertpolicyCtx)
				ct.stats.Counter("AlertPolicy_Updated_Events").Inc()
				ctrlCtx.Lock()
				p := monitoring.AlertPolicy{Spec: eobj.Spec,
					ObjectMeta: eobj.ObjectMeta,
					TypeMeta:   eobj.TypeMeta,
					Status:     eobj.Status}

				err = alertpolicyHandler.OnAlertPolicyUpdate(ctrlCtx.obj, &p)
				ctrlCtx.obj.AlertPolicy = *eobj
				ctrlCtx.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctrlCtx.obj.GetObjectMeta(), err)
					return err
				}

			}
		case kvstore.Deleted:
			ctrlCtx := &alertpolicyCtx{event: evt.Type, obj: &AlertPolicy{AlertPolicy: *eobj, ctrler: ct}}
			fobj, err := ct.findObject(kind, ctrlCtx.GetKey())
			if err != nil {
				ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
				return err
			}

			obj := fobj.(*AlertPolicy)
			ct.stats.Counter("AlertPolicy_Deleted_Events").Inc()
			obj.Lock()
			err = alertpolicyHandler.OnAlertPolicyDelete(obj)
			obj.Unlock()
			if err != nil {
				ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj.GetObjectMeta(), err)
			}
			ct.delObject(kind, ctrlCtx.GetKey())
			return nil

		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on AlertPolicy watch channel", tp)
	}

	return nil
}

type alertpolicyCtx struct {
	ctkitBaseCtx
	event kvstore.WatchEventType
	obj   *AlertPolicy //
	//   newObj     *monitoring.AlertPolicy //update
	newObj *alertpolicyCtx //update
}

func (ctx *alertpolicyCtx) References() map[string]apiintf.ReferenceObj {
	if ctx.references == nil {
		resp := make(map[string]apiintf.ReferenceObj)
		ctx.references = resp
		ctx.obj.References(ctx.obj.GetObjectMeta().Name, ctx.obj.GetObjectMeta().Namespace, resp)
		ctx.obj.ctrler.filterOutRefs(ctx)
	}
	return ctx.references
}

func (ctx *alertpolicyCtx) GetKey() string {
	return ctx.obj.MakeKey("monitoring")

}

func (ctx *alertpolicyCtx) IsInternal() bool {
	return ctx.obj.internal
}

func (ctx *alertpolicyCtx) GetKind() string {
	return ctx.obj.GetKind()
}

func (ctx *alertpolicyCtx) GetResourceVersion() string {
	return ctx.obj.GetResourceVersion()
}

func (ctx *alertpolicyCtx) SetEvent(event kvstore.WatchEventType) {
	ctx.event = event
}

func (ctx *alertpolicyCtx) SetNewObj(newObj apiintf.CtkitObject) {
	if newObj == nil {
		ctx.newObj = nil
	} else {
		ctx.newObj = newObj.(*alertpolicyCtx)
		ctx.newObj.obj.HandlerCtx = ctx.obj.HandlerCtx
		ctx.references = newObj.References()
	}
}

func (ctx *alertpolicyCtx) GetNewObj() apiintf.CtkitObject {
	return ctx.newObj
}

func (ctx *alertpolicyCtx) Copy(obj apiintf.CtkitObject) {
	ctx.obj.AlertPolicy = obj.(*alertpolicyCtx).obj.AlertPolicy
	ctx.SetWatchTs(obj.GetWatchTs())
}

func (ctx *alertpolicyCtx) Lock() {
	ctx.obj.Lock()
}

func (ctx *alertpolicyCtx) Unlock() {
	ctx.obj.Unlock()
}

func (ctx *alertpolicyCtx) GetObjectMeta() *api.ObjectMeta {
	return ctx.obj.GetObjectMeta()
}

func (ctx *alertpolicyCtx) RuntimeObject() runtime.Object {
	var v interface{}
	v = ctx.obj
	return v.(runtime.Object)
}

func (ctx *alertpolicyCtx) WorkFunc(context context.Context) error {
	var err error
	evt := ctx.event
	ct := ctx.obj.ctrler
	kind := "AlertPolicy"
	ct.Lock()
	handler, ok := ct.handlers[kind]
	ct.Unlock()
	if !ok {
		ct.logger.Fatalf("Cant find the handler for %s", kind)
	}
	alertpolicyHandler := handler.(AlertPolicyHandler)
	switch evt {
	case kvstore.Created:
		ctx.obj.Lock()
		err = alertpolicyHandler.OnAlertPolicyCreate(ctx.obj)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctx.obj.GetObjectMeta(), err)
			ctx.SetEvent(kvstore.Deleted)
		}
	case kvstore.Updated:
		ct.stats.Counter("AlertPolicy_Updated_Events").Inc()
		ctx.obj.Lock()
		p := monitoring.AlertPolicy{Spec: ctx.newObj.obj.Spec,
			ObjectMeta: ctx.newObj.obj.ObjectMeta,
			TypeMeta:   ctx.newObj.obj.TypeMeta,
			Status:     ctx.newObj.obj.Status}
		err = alertpolicyHandler.OnAlertPolicyUpdate(ctx.obj, &p)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctx.obj.GetObjectMeta(), err)
			ctx.SetEvent(kvstore.Deleted)
		}
	case kvstore.Deleted:
		ctx.obj.Lock()
		err = alertpolicyHandler.OnAlertPolicyDelete(ctx.obj)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error deleting %s %+v. Err: %v", kind, ctx.obj.GetObjectMeta(), err)
		}
	}
	ct.resolveObject(ctx.event, ctx)
	return nil
}

// handleAlertPolicyEventParallel handles AlertPolicy events from watcher
func (ct *ctrlerCtx) handleAlertPolicyEventParallel(evt *kvstore.WatchEvent) error {

	if ct.objResolver == nil {
		return ct.handleAlertPolicyEventParallelWithNoResolver(evt)
	}

	switch tp := evt.Object.(type) {
	case *monitoring.AlertPolicy:
		eobj := evt.Object.(*monitoring.AlertPolicy)
		kind := "AlertPolicy"

		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ctx := &alertpolicyCtx{event: evt.Type, obj: &AlertPolicy{AlertPolicy: *eobj, ctrler: ct}}
		ctx.SetWatchTs(evt.WatchTS)

		var err error
		switch evt.Type {
		case kvstore.Created:
			err = ct.processAdd(ctx)
		case kvstore.Updated:
			err = ct.processUpdate(ctx)
		case kvstore.Deleted:
			err = ct.processDelete(ctx)
		}
		return err
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on AlertPolicy watch channel", tp)
	}

	return nil
}

// handleAlertPolicyEventParallel handles AlertPolicy events from watcher
func (ct *ctrlerCtx) handleAlertPolicyEventParallelWithNoResolver(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *monitoring.AlertPolicy:
		eobj := evt.Object.(*monitoring.AlertPolicy)
		kind := "AlertPolicy"

		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		alertpolicyHandler := handler.(AlertPolicyHandler)
		// handle based on event type
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			workFunc := func(ctx context.Context, ctrlCtx shardworkers.WorkObj) error {
				var err error
				workCtx := ctrlCtx.(*alertpolicyCtx)
				eobj := workCtx.obj
				fobj, err := ct.getObject(kind, workCtx.GetKey())
				if err != nil {
					ct.addObject(workCtx)
					ct.stats.Counter("AlertPolicy_Created_Events").Inc()
					eobj.Lock()
					err = alertpolicyHandler.OnAlertPolicyCreate(eobj)
					eobj.Unlock()
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, eobj.GetObjectMeta(), err)
						ct.delObject(kind, workCtx.GetKey())
					}
				} else {
					workCtx = fobj.(*alertpolicyCtx)
					obj := workCtx.obj
					ct.stats.Counter("AlertPolicy_Updated_Events").Inc()
					obj.Lock()
					p := monitoring.AlertPolicy{Spec: eobj.Spec,
						ObjectMeta: eobj.ObjectMeta,
						TypeMeta:   eobj.TypeMeta,
						Status:     eobj.Status}

					err = alertpolicyHandler.OnAlertPolicyUpdate(obj, &p)
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj.GetObjectMeta(), err)
					} else {
						workCtx.obj.AlertPolicy = p
					}
					obj.Unlock()
				}
				workCtx.SetWatchTs(evt.WatchTS)
				return err
			}
			ctrlCtx := &alertpolicyCtx{event: evt.Type, obj: &AlertPolicy{AlertPolicy: *eobj, ctrler: ct}}
			ct.runFunction("AlertPolicy", ctrlCtx, workFunc)
		case kvstore.Deleted:
			workFunc := func(ctx context.Context, ctrlCtx shardworkers.WorkObj) error {
				var err error
				workCtx := ctrlCtx.(*alertpolicyCtx)
				eobj := workCtx.obj
				fobj, err := ct.findObject(kind, workCtx.GetKey())
				if err != nil {
					ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
					return err
				}
				obj := fobj.(*AlertPolicy)
				ct.stats.Counter("AlertPolicy_Deleted_Events").Inc()
				obj.Lock()
				err = alertpolicyHandler.OnAlertPolicyDelete(obj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj.GetObjectMeta(), err)
				}
				ct.delObject(kind, workCtx.GetKey())
				return nil
			}
			ctrlCtx := &alertpolicyCtx{event: evt.Type, obj: &AlertPolicy{AlertPolicy: *eobj, ctrler: ct}}
			ct.runFunction("AlertPolicy", ctrlCtx, workFunc)
		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on AlertPolicy watch channel", tp)
	}

	return nil
}

// diffAlertPolicy does a diff of AlertPolicy objects between local cache and API server
func (ct *ctrlerCtx) diffAlertPolicy(apicl apiclient.Services) {
	opts := api.ListWatchOptions{}

	// get a list of all objects from API server
	objlist, err := apicl.MonitoringV1().AlertPolicy().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Errorf("Error getting a list of objects. Err: %v", err)
		return
	}

	ct.logger.Infof("diffAlertPolicy(): AlertPolicyList returned %d objects", len(objlist))

	// build an object map
	objmap := make(map[string]*monitoring.AlertPolicy)
	for _, obj := range objlist {
		objmap[obj.GetKey()] = obj
	}

	list, err := ct.AlertPolicy().List(context.Background(), &opts)
	if err != nil && !strings.Contains(err.Error(), "not found in local cache") {
		ct.logger.Infof("Failed to get a list of objects. Err: %s", err)
		return
	}

	// if an object is in our local cache and not in API server, trigger delete for it
	for _, obj := range list {
		_, ok := objmap[obj.GetKey()]
		if !ok {
			ct.logger.Infof("diffAlertPolicy(): Deleting existing object %#v since its not in apiserver", obj.GetKey())
			evt := kvstore.WatchEvent{
				Type:   kvstore.Deleted,
				Key:    obj.GetKey(),
				Object: &obj.AlertPolicy,
			}
			ct.handleAlertPolicyEvent(&evt)
		}
	}

	// trigger create event for all others
	for _, obj := range objlist {
		ct.logger.Infof("diffAlertPolicy(): Adding object %#v", obj.GetKey())
		evt := kvstore.WatchEvent{
			Type:   kvstore.Created,
			Key:    obj.GetKey(),
			Object: obj,
		}
		ct.handleAlertPolicyEvent(&evt)
	}
}

func (ct *ctrlerCtx) runAlertPolicyWatcher() {
	kind := "AlertPolicy"

	ct.Lock()
	handler, ok := ct.handlers[kind]
	ct.Unlock()
	if !ok {
		ct.logger.Fatalf("Cant find the handler for %s", kind)
	}
	alertpolicyHandler := handler.(AlertPolicyHandler)

	opts := alertpolicyHandler.GetAlertPolicyWatchOptions()

	// if there is no API server to connect to, we are done
	if (ct.resolver == nil) || ct.apisrvURL == "" {
		return
	}

	// create context
	ctx, cancel := context.WithCancel(context.Background())
	ct.Lock()
	ct.watchCancel[kind] = cancel
	ct.Unlock()
	logger := ct.logger.WithContext("submodule", "AlertPolicyWatcher")
	for {
		if ctx.Err() != nil {
			return
		}

		apiclt, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
		// create a grpc client
		if err == nil {
			// Upon successful connection perform the diff, and start watch goroutine
			ct.diffAlertPolicy(apiclt)
			break
		}

		logger.Warnf("Failed to connect to gRPC server [%s]\n", ct.apisrvURL)
		time.Sleep(time.Second)
	}

	// setup wait group
	ct.waitGrp.Add(1)

	// start a goroutine
	go func() {
		defer ct.waitGrp.Done()
		ct.stats.Counter("AlertPolicy_Watch").Inc()
		defer ct.stats.Counter("AlertPolicy_Watch").Dec()

		// loop forever
		for {
			// create a grpc client
			apicl, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
			if err != nil {
				logger.Warnf("Failed to connect to gRPC server [%s]\n", ct.apisrvURL)
				ct.stats.Counter("AlertPolicy_ApiClientErr").Inc()
			} else {
				logger.Infof("API client connected {%+v}", apicl)

				// AlertPolicy object watcher
				wt, werr := apicl.MonitoringV1().AlertPolicy().Watch(ctx, opts)
				if werr != nil {
					select {
					case <-ctx.Done():
						logger.Infof("watch %s cancelled", kind)
						return
					default:
					}
					logger.Errorf("Failed to start %s watch (%s)\n", kind, werr)
					// wait for a second and retry connecting to api server
					apicl.Close()
					time.Sleep(time.Second)
					continue
				}
				ct.Lock()
				ct.watchers[kind] = wt
				ct.Unlock()

				// perform a diff with API server and local cache
				// Sleeping to give time for other apiclient's to reconnect
				// before calling reconnect handler
				time.Sleep(time.Second)
				ct.diffAlertPolicy(apicl)
				alertpolicyHandler.OnAlertPolicyReconnect()

				// handle api server watch events
			innerLoop:
				for {
					// wait for events
					select {
					case evt, ok := <-wt.EventChan():
						if !ok {
							logger.Error("Error receiving from apisrv watcher")
							ct.stats.Counter("AlertPolicy_WatchErrors").Inc()
							break innerLoop
						}

						// handle event in parallel
						ct.handleAlertPolicyEventParallel(evt)
					}
				}
				apicl.Close()
			}

			// if stop flag is set, we are done
			if ct.stoped {
				logger.Infof("Exiting API server watcher")
				return
			}

			// wait for a second and retry connecting to api server
			time.Sleep(time.Second)
		}
	}()
}

// WatchAlertPolicy starts watch on AlertPolicy object
func (ct *ctrlerCtx) WatchAlertPolicy(handler AlertPolicyHandler) error {
	kind := "AlertPolicy"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchCancel[kind]
	ct.Unlock()
	if ok {
		return fmt.Errorf("AlertPolicy watcher already exists")
	}

	// save handler
	ct.Lock()
	ct.handlers[kind] = handler
	ct.Unlock()

	// run AlertPolicy watcher in a go routine
	ct.runAlertPolicyWatcher()

	return nil
}

// StopWatchAlertPolicy stops watch on AlertPolicy object
func (ct *ctrlerCtx) StopWatchAlertPolicy(handler AlertPolicyHandler) error {
	kind := "AlertPolicy"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchCancel[kind]
	ct.Unlock()
	if !ok {
		return fmt.Errorf("AlertPolicy watcher does not exist")
	}

	ct.Lock()
	cancel, _ := ct.watchCancel[kind]
	cancel()
	if _, ok := ct.watchers[kind]; ok {
		delete(ct.watchers, kind)
	}
	delete(ct.watchCancel, kind)
	ct.Unlock()

	time.Sleep(100 * time.Millisecond)

	return nil
}

// AlertPolicyAPI returns
type AlertPolicyAPI interface {
	Create(obj *monitoring.AlertPolicy) error
	SyncCreate(obj *monitoring.AlertPolicy) error
	Update(obj *monitoring.AlertPolicy) error
	SyncUpdate(obj *monitoring.AlertPolicy) error
	Label(obj *api.Label) error
	Delete(obj *monitoring.AlertPolicy) error
	Find(meta *api.ObjectMeta) (*AlertPolicy, error)
	List(ctx context.Context, opts *api.ListWatchOptions) ([]*AlertPolicy, error)
	ApisrvList(ctx context.Context, opts *api.ListWatchOptions) ([]*monitoring.AlertPolicy, error)
	Watch(handler AlertPolicyHandler) error
	ClearCache(handler AlertPolicyHandler)
	StopWatch(handler AlertPolicyHandler) error
}

// dummy struct that implements AlertPolicyAPI
type alertpolicyAPI struct {
	ct *ctrlerCtx
}

// Create creates AlertPolicy object
func (api *alertpolicyAPI) Create(obj *monitoring.AlertPolicy) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.MonitoringV1().AlertPolicy().Create(context.Background(), obj)
		if err != nil && strings.Contains(err.Error(), "AlreadyExists") {
			_, err = apicl.MonitoringV1().AlertPolicy().Update(context.Background(), obj)

		}
		return err
	}

	api.ct.handleAlertPolicyEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Created})
	return nil
}

// SyncCreate creates AlertPolicy object and updates the cache
func (api *alertpolicyAPI) SyncCreate(obj *monitoring.AlertPolicy) error {
	newObj := obj
	evtType := kvstore.Created
	var writeErr error
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		newObj, writeErr = apicl.MonitoringV1().AlertPolicy().Create(context.Background(), obj)
		if writeErr != nil && strings.Contains(writeErr.Error(), "AlreadyExists") {
			newObj, writeErr = apicl.MonitoringV1().AlertPolicy().Update(context.Background(), obj)
			evtType = kvstore.Updated
		}
	}

	if writeErr == nil {
		api.ct.handleAlertPolicyEvent(&kvstore.WatchEvent{Object: newObj, Type: evtType})
	}
	return writeErr
}

// Update triggers update on AlertPolicy object
func (api *alertpolicyAPI) Update(obj *monitoring.AlertPolicy) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.MonitoringV1().AlertPolicy().Update(context.Background(), obj)
		return err
	}

	api.ct.handleAlertPolicyEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Updated})
	return nil
}

// SyncUpdate triggers update on AlertPolicy object and updates the cache
func (api *alertpolicyAPI) SyncUpdate(obj *monitoring.AlertPolicy) error {
	if api.ct.objResolver != nil {
		log.Fatal("Cannot use Sync update when object resolver is enabled on ctkit")
	}
	newObj := obj
	var writeErr error
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		newObj, writeErr = apicl.MonitoringV1().AlertPolicy().Update(context.Background(), obj)
	}

	if writeErr == nil {
		api.ct.handleAlertPolicyEvent(&kvstore.WatchEvent{Object: newObj, Type: kvstore.Updated})
	}

	return writeErr
}

// Label labels AlertPolicy object
func (api *alertpolicyAPI) Label(obj *api.Label) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.MonitoringV1().AlertPolicy().Label(context.Background(), obj)
		return err
	}

	ctkitObj, err := api.Find(obj.GetObjectMeta())
	if err != nil {
		return err
	}
	writeObj := ctkitObj.AlertPolicy
	writeObj.Labels = obj.Labels

	api.ct.handleAlertPolicyEvent(&kvstore.WatchEvent{Object: &writeObj, Type: kvstore.Updated})
	return nil
}

// Delete deletes AlertPolicy object
func (api *alertpolicyAPI) Delete(obj *monitoring.AlertPolicy) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.MonitoringV1().AlertPolicy().Delete(context.Background(), &obj.ObjectMeta)
		return err
	}

	api.ct.handleAlertPolicyEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Deleted})
	return nil
}

// MakeKey generates a KV store key for the object
func (api *alertpolicyAPI) getFullKey(tenant, name string) string {
	if tenant != "" {
		return fmt.Sprint(globals.ConfigRootPrefix, "/", "monitoring", "/", "alertPolicies", "/", tenant, "/", name)
	}
	return fmt.Sprint(globals.ConfigRootPrefix, "/", "monitoring", "/", "alertPolicies", "/", name)
}

// Find returns an object by meta
func (api *alertpolicyAPI) Find(meta *api.ObjectMeta) (*AlertPolicy, error) {
	// find the object
	obj, err := api.ct.FindObject("AlertPolicy", meta)
	if err != nil {
		return nil, err
	}

	// asset type
	switch obj.(type) {
	case *AlertPolicy:
		hobj := obj.(*AlertPolicy)
		return hobj, nil
	default:
		return nil, errors.New("incorrect object type")
	}
}

// List returns a list of all AlertPolicy objects
func (api *alertpolicyAPI) List(ctx context.Context, opts *api.ListWatchOptions) ([]*AlertPolicy, error) {
	var objlist []*AlertPolicy
	objs, err := api.ct.List("AlertPolicy", ctx, opts)

	if err != nil {
		return nil, err
	}

	for _, obj := range objs {
		switch tp := obj.(type) {
		case *AlertPolicy:
			eobj := obj.(*AlertPolicy)
			objlist = append(objlist, eobj)
		default:
			log.Fatalf("Got invalid object type %v while looking for AlertPolicy", tp)
		}
	}

	return objlist, nil
}

// ApisrvList returns a list of all AlertPolicy objects from apiserver
func (api *alertpolicyAPI) ApisrvList(ctx context.Context, opts *api.ListWatchOptions) ([]*monitoring.AlertPolicy, error) {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return nil, err
		}

		return apicl.MonitoringV1().AlertPolicy().List(context.Background(), opts)
	}

	// List from local cache
	ctkitObjs, err := api.List(ctx, opts)
	if err != nil {
		return nil, err
	}
	var ret []*monitoring.AlertPolicy
	for _, obj := range ctkitObjs {
		ret = append(ret, &obj.AlertPolicy)
	}
	return ret, nil
}

// Watch sets up a event handlers for AlertPolicy object
func (api *alertpolicyAPI) Watch(handler AlertPolicyHandler) error {
	api.ct.startWorkerPool("AlertPolicy")
	return api.ct.WatchAlertPolicy(handler)
}

// StopWatch stop watch for Tenant AlertPolicy object
func (api *alertpolicyAPI) StopWatch(handler AlertPolicyHandler) error {
	api.ct.Lock()
	api.ct.workPools["AlertPolicy"].Stop()
	api.ct.Unlock()
	return api.ct.StopWatchAlertPolicy(handler)
}

// ClearCache removes all AlertPolicy objects in ctkit
func (api *alertpolicyAPI) ClearCache(handler AlertPolicyHandler) {
	api.ct.delKind("AlertPolicy")
}

// AlertPolicy returns AlertPolicyAPI
func (ct *ctrlerCtx) AlertPolicy() AlertPolicyAPI {
	kind := "AlertPolicy"
	if _, ok := ct.apiInfMap[kind]; !ok {
		s := &alertpolicyAPI{ct: ct}
		ct.apiInfMap[kind] = s
	}
	return ct.apiInfMap[kind].(*alertpolicyAPI)
}

// StatsAlertPolicy is a wrapper object that implements additional functionality
type StatsAlertPolicy struct {
	sync.Mutex
	monitoring.StatsAlertPolicy
	HandlerCtx interface{} // additional state handlers can store
	ctrler     *ctrlerCtx  // reference back to the controller instance
	internal   bool
}

func (obj *StatsAlertPolicy) SetInternal() {
	obj.internal = true
}

func (obj *StatsAlertPolicy) Write() error {
	// if there is no API server to connect to, we are done
	if (obj.ctrler == nil) || (obj.ctrler.resolver == nil) || obj.ctrler.apisrvURL == "" {
		return nil
	}

	apicl, err := obj.ctrler.apiClient()
	if err != nil {
		obj.ctrler.logger.Errorf("Error creating API server clent. Err: %v", err)
		return err
	}

	obj.ctrler.stats.Counter("StatsAlertPolicy_Writes").Inc()

	// write to api server
	if obj.ObjectMeta.ResourceVersion != "" {
		// update it
		for i := 0; i < maxApisrvWriteRetry; i++ {
			_, err = apicl.MonitoringV1().StatsAlertPolicy().UpdateStatus(context.Background(), &obj.StatsAlertPolicy)
			if err == nil {
				break
			}
			time.Sleep(time.Millisecond * 100)
		}
	} else {
		//  create
		_, err = apicl.MonitoringV1().StatsAlertPolicy().Create(context.Background(), &obj.StatsAlertPolicy)
	}

	return nil
}

// StatsAlertPolicyHandler is the event handler for StatsAlertPolicy object
type StatsAlertPolicyHandler interface {
	OnStatsAlertPolicyCreate(obj *StatsAlertPolicy) error
	OnStatsAlertPolicyUpdate(oldObj *StatsAlertPolicy, newObj *monitoring.StatsAlertPolicy) error
	OnStatsAlertPolicyDelete(obj *StatsAlertPolicy) error
	GetStatsAlertPolicyWatchOptions() *api.ListWatchOptions
	OnStatsAlertPolicyReconnect()
}

// OnStatsAlertPolicyCreate is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnStatsAlertPolicyCreate(obj *StatsAlertPolicy) error {
	log.Info("OnStatsAlertPolicyCreate is not implemented")
	return nil
}

// OnStatsAlertPolicyUpdate is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnStatsAlertPolicyUpdate(oldObj *StatsAlertPolicy, newObj *monitoring.StatsAlertPolicy) error {
	log.Info("OnStatsAlertPolicyUpdate is not implemented")
	return nil
}

// OnStatsAlertPolicyDelete is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnStatsAlertPolicyDelete(obj *StatsAlertPolicy) error {
	log.Info("OnStatsAlertPolicyDelete is not implemented")
	return nil
}

// GetStatsAlertPolicyWatchOptions is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) GetStatsAlertPolicyWatchOptions() *api.ListWatchOptions {
	log.Info("GetStatsAlertPolicyWatchOptions is not implemented")
	opts := &api.ListWatchOptions{}
	return opts
}

// OnStatsAlertPolicyReconnect is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnStatsAlertPolicyReconnect() {
	log.Info("OnStatsAlertPolicyReconnect is not implemented")
	return
}

// handleStatsAlertPolicyEvent handles StatsAlertPolicy events from watcher
func (ct *ctrlerCtx) handleStatsAlertPolicyEvent(evt *kvstore.WatchEvent) error {

	if ct.objResolver == nil {
		return ct.handleStatsAlertPolicyEventNoResolver(evt)
	}

	switch tp := evt.Object.(type) {
	case *monitoring.StatsAlertPolicy:
		eobj := evt.Object.(*monitoring.StatsAlertPolicy)
		kind := "StatsAlertPolicy"

		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ctx := &statsalertpolicyCtx{event: evt.Type,
			obj: &StatsAlertPolicy{StatsAlertPolicy: *eobj, ctrler: ct}}

		var err error
		switch evt.Type {
		case kvstore.Created:
			err = ct.processAdd(ctx)
		case kvstore.Updated:
			err = ct.processUpdate(ctx)
		case kvstore.Deleted:
			err = ct.processDelete(ctx)
		}
		return err
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on StatsAlertPolicy watch channel", tp)
	}

	return nil
}

// handleStatsAlertPolicyEventNoResolver handles StatsAlertPolicy events from watcher
func (ct *ctrlerCtx) handleStatsAlertPolicyEventNoResolver(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *monitoring.StatsAlertPolicy:
		eobj := evt.Object.(*monitoring.StatsAlertPolicy)
		kind := "StatsAlertPolicy"

		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		statsalertpolicyHandler := handler.(StatsAlertPolicyHandler)
		// handle based on event type
		ctrlCtx := &statsalertpolicyCtx{event: evt.Type, obj: &StatsAlertPolicy{StatsAlertPolicy: *eobj, ctrler: ct}}
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			fobj, err := ct.getObject(kind, ctrlCtx.GetKey())
			if err != nil {
				ct.addObject(ctrlCtx)
				ct.stats.Counter("StatsAlertPolicy_Created_Events").Inc()

				// call the event handler
				ctrlCtx.Lock()
				err = statsalertpolicyHandler.OnStatsAlertPolicyCreate(ctrlCtx.obj)
				ctrlCtx.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctrlCtx.obj.GetObjectMeta(), err)
					ct.delObject(kind, ctrlCtx.GetKey())
					return err
				}
			} else {
				fResVer, fErr := strconv.ParseInt(fobj.GetResourceVersion(), 10, 64)
				eResVer, eErr := strconv.ParseInt(eobj.GetResourceVersion(), 10, 64)
				if ct.resolver != nil && fErr == nil && eErr == nil && fResVer >= eResVer {
					// Event already processed.
					ct.logger.Infof("Skipping update due to old resource version")
					return nil
				}
				ctrlCtx := fobj.(*statsalertpolicyCtx)
				ct.stats.Counter("StatsAlertPolicy_Updated_Events").Inc()
				ctrlCtx.Lock()
				p := monitoring.StatsAlertPolicy{Spec: eobj.Spec,
					ObjectMeta: eobj.ObjectMeta,
					TypeMeta:   eobj.TypeMeta,
					Status:     eobj.Status}

				err = statsalertpolicyHandler.OnStatsAlertPolicyUpdate(ctrlCtx.obj, &p)
				ctrlCtx.obj.StatsAlertPolicy = *eobj
				ctrlCtx.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctrlCtx.obj.GetObjectMeta(), err)
					return err
				}

			}
		case kvstore.Deleted:
			ctrlCtx := &statsalertpolicyCtx{event: evt.Type, obj: &StatsAlertPolicy{StatsAlertPolicy: *eobj, ctrler: ct}}
			fobj, err := ct.findObject(kind, ctrlCtx.GetKey())
			if err != nil {
				ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
				return err
			}

			obj := fobj.(*StatsAlertPolicy)
			ct.stats.Counter("StatsAlertPolicy_Deleted_Events").Inc()
			obj.Lock()
			err = statsalertpolicyHandler.OnStatsAlertPolicyDelete(obj)
			obj.Unlock()
			if err != nil {
				ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj.GetObjectMeta(), err)
			}
			ct.delObject(kind, ctrlCtx.GetKey())
			return nil

		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on StatsAlertPolicy watch channel", tp)
	}

	return nil
}

type statsalertpolicyCtx struct {
	ctkitBaseCtx
	event kvstore.WatchEventType
	obj   *StatsAlertPolicy //
	//   newObj     *monitoring.StatsAlertPolicy //update
	newObj *statsalertpolicyCtx //update
}

func (ctx *statsalertpolicyCtx) References() map[string]apiintf.ReferenceObj {
	if ctx.references == nil {
		resp := make(map[string]apiintf.ReferenceObj)
		ctx.references = resp
		ctx.obj.References(ctx.obj.GetObjectMeta().Name, ctx.obj.GetObjectMeta().Namespace, resp)
		ctx.obj.ctrler.filterOutRefs(ctx)
	}
	return ctx.references
}

func (ctx *statsalertpolicyCtx) GetKey() string {
	return ctx.obj.MakeKey("monitoring")

}

func (ctx *statsalertpolicyCtx) IsInternal() bool {
	return ctx.obj.internal
}

func (ctx *statsalertpolicyCtx) GetKind() string {
	return ctx.obj.GetKind()
}

func (ctx *statsalertpolicyCtx) GetResourceVersion() string {
	return ctx.obj.GetResourceVersion()
}

func (ctx *statsalertpolicyCtx) SetEvent(event kvstore.WatchEventType) {
	ctx.event = event
}

func (ctx *statsalertpolicyCtx) SetNewObj(newObj apiintf.CtkitObject) {
	if newObj == nil {
		ctx.newObj = nil
	} else {
		ctx.newObj = newObj.(*statsalertpolicyCtx)
		ctx.newObj.obj.HandlerCtx = ctx.obj.HandlerCtx
		ctx.references = newObj.References()
	}
}

func (ctx *statsalertpolicyCtx) GetNewObj() apiintf.CtkitObject {
	return ctx.newObj
}

func (ctx *statsalertpolicyCtx) Copy(obj apiintf.CtkitObject) {
	ctx.obj.StatsAlertPolicy = obj.(*statsalertpolicyCtx).obj.StatsAlertPolicy
	ctx.SetWatchTs(obj.GetWatchTs())
}

func (ctx *statsalertpolicyCtx) Lock() {
	ctx.obj.Lock()
}

func (ctx *statsalertpolicyCtx) Unlock() {
	ctx.obj.Unlock()
}

func (ctx *statsalertpolicyCtx) GetObjectMeta() *api.ObjectMeta {
	return ctx.obj.GetObjectMeta()
}

func (ctx *statsalertpolicyCtx) RuntimeObject() runtime.Object {
	var v interface{}
	v = ctx.obj
	return v.(runtime.Object)
}

func (ctx *statsalertpolicyCtx) WorkFunc(context context.Context) error {
	var err error
	evt := ctx.event
	ct := ctx.obj.ctrler
	kind := "StatsAlertPolicy"
	ct.Lock()
	handler, ok := ct.handlers[kind]
	ct.Unlock()
	if !ok {
		ct.logger.Fatalf("Cant find the handler for %s", kind)
	}
	statsalertpolicyHandler := handler.(StatsAlertPolicyHandler)
	switch evt {
	case kvstore.Created:
		ctx.obj.Lock()
		err = statsalertpolicyHandler.OnStatsAlertPolicyCreate(ctx.obj)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctx.obj.GetObjectMeta(), err)
			ctx.SetEvent(kvstore.Deleted)
		}
	case kvstore.Updated:
		ct.stats.Counter("StatsAlertPolicy_Updated_Events").Inc()
		ctx.obj.Lock()
		p := monitoring.StatsAlertPolicy{Spec: ctx.newObj.obj.Spec,
			ObjectMeta: ctx.newObj.obj.ObjectMeta,
			TypeMeta:   ctx.newObj.obj.TypeMeta,
			Status:     ctx.newObj.obj.Status}
		err = statsalertpolicyHandler.OnStatsAlertPolicyUpdate(ctx.obj, &p)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctx.obj.GetObjectMeta(), err)
			ctx.SetEvent(kvstore.Deleted)
		}
	case kvstore.Deleted:
		ctx.obj.Lock()
		err = statsalertpolicyHandler.OnStatsAlertPolicyDelete(ctx.obj)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error deleting %s %+v. Err: %v", kind, ctx.obj.GetObjectMeta(), err)
		}
	}
	ct.resolveObject(ctx.event, ctx)
	return nil
}

// handleStatsAlertPolicyEventParallel handles StatsAlertPolicy events from watcher
func (ct *ctrlerCtx) handleStatsAlertPolicyEventParallel(evt *kvstore.WatchEvent) error {

	if ct.objResolver == nil {
		return ct.handleStatsAlertPolicyEventParallelWithNoResolver(evt)
	}

	switch tp := evt.Object.(type) {
	case *monitoring.StatsAlertPolicy:
		eobj := evt.Object.(*monitoring.StatsAlertPolicy)
		kind := "StatsAlertPolicy"

		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ctx := &statsalertpolicyCtx{event: evt.Type, obj: &StatsAlertPolicy{StatsAlertPolicy: *eobj, ctrler: ct}}
		ctx.SetWatchTs(evt.WatchTS)

		var err error
		switch evt.Type {
		case kvstore.Created:
			err = ct.processAdd(ctx)
		case kvstore.Updated:
			err = ct.processUpdate(ctx)
		case kvstore.Deleted:
			err = ct.processDelete(ctx)
		}
		return err
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on StatsAlertPolicy watch channel", tp)
	}

	return nil
}

// handleStatsAlertPolicyEventParallel handles StatsAlertPolicy events from watcher
func (ct *ctrlerCtx) handleStatsAlertPolicyEventParallelWithNoResolver(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *monitoring.StatsAlertPolicy:
		eobj := evt.Object.(*monitoring.StatsAlertPolicy)
		kind := "StatsAlertPolicy"

		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		statsalertpolicyHandler := handler.(StatsAlertPolicyHandler)
		// handle based on event type
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			workFunc := func(ctx context.Context, ctrlCtx shardworkers.WorkObj) error {
				var err error
				workCtx := ctrlCtx.(*statsalertpolicyCtx)
				eobj := workCtx.obj
				fobj, err := ct.getObject(kind, workCtx.GetKey())
				if err != nil {
					ct.addObject(workCtx)
					ct.stats.Counter("StatsAlertPolicy_Created_Events").Inc()
					eobj.Lock()
					err = statsalertpolicyHandler.OnStatsAlertPolicyCreate(eobj)
					eobj.Unlock()
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, eobj.GetObjectMeta(), err)
						ct.delObject(kind, workCtx.GetKey())
					}
				} else {
					workCtx = fobj.(*statsalertpolicyCtx)
					obj := workCtx.obj
					ct.stats.Counter("StatsAlertPolicy_Updated_Events").Inc()
					obj.Lock()
					p := monitoring.StatsAlertPolicy{Spec: eobj.Spec,
						ObjectMeta: eobj.ObjectMeta,
						TypeMeta:   eobj.TypeMeta,
						Status:     eobj.Status}

					err = statsalertpolicyHandler.OnStatsAlertPolicyUpdate(obj, &p)
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj.GetObjectMeta(), err)
					} else {
						workCtx.obj.StatsAlertPolicy = p
					}
					obj.Unlock()
				}
				workCtx.SetWatchTs(evt.WatchTS)
				return err
			}
			ctrlCtx := &statsalertpolicyCtx{event: evt.Type, obj: &StatsAlertPolicy{StatsAlertPolicy: *eobj, ctrler: ct}}
			ct.runFunction("StatsAlertPolicy", ctrlCtx, workFunc)
		case kvstore.Deleted:
			workFunc := func(ctx context.Context, ctrlCtx shardworkers.WorkObj) error {
				var err error
				workCtx := ctrlCtx.(*statsalertpolicyCtx)
				eobj := workCtx.obj
				fobj, err := ct.findObject(kind, workCtx.GetKey())
				if err != nil {
					ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
					return err
				}
				obj := fobj.(*StatsAlertPolicy)
				ct.stats.Counter("StatsAlertPolicy_Deleted_Events").Inc()
				obj.Lock()
				err = statsalertpolicyHandler.OnStatsAlertPolicyDelete(obj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj.GetObjectMeta(), err)
				}
				ct.delObject(kind, workCtx.GetKey())
				return nil
			}
			ctrlCtx := &statsalertpolicyCtx{event: evt.Type, obj: &StatsAlertPolicy{StatsAlertPolicy: *eobj, ctrler: ct}}
			ct.runFunction("StatsAlertPolicy", ctrlCtx, workFunc)
		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on StatsAlertPolicy watch channel", tp)
	}

	return nil
}

// diffStatsAlertPolicy does a diff of StatsAlertPolicy objects between local cache and API server
func (ct *ctrlerCtx) diffStatsAlertPolicy(apicl apiclient.Services) {
	opts := api.ListWatchOptions{}

	// get a list of all objects from API server
	objlist, err := apicl.MonitoringV1().StatsAlertPolicy().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Errorf("Error getting a list of objects. Err: %v", err)
		return
	}

	ct.logger.Infof("diffStatsAlertPolicy(): StatsAlertPolicyList returned %d objects", len(objlist))

	// build an object map
	objmap := make(map[string]*monitoring.StatsAlertPolicy)
	for _, obj := range objlist {
		objmap[obj.GetKey()] = obj
	}

	list, err := ct.StatsAlertPolicy().List(context.Background(), &opts)
	if err != nil && !strings.Contains(err.Error(), "not found in local cache") {
		ct.logger.Infof("Failed to get a list of objects. Err: %s", err)
		return
	}

	// if an object is in our local cache and not in API server, trigger delete for it
	for _, obj := range list {
		_, ok := objmap[obj.GetKey()]
		if !ok {
			ct.logger.Infof("diffStatsAlertPolicy(): Deleting existing object %#v since its not in apiserver", obj.GetKey())
			evt := kvstore.WatchEvent{
				Type:   kvstore.Deleted,
				Key:    obj.GetKey(),
				Object: &obj.StatsAlertPolicy,
			}
			ct.handleStatsAlertPolicyEvent(&evt)
		}
	}

	// trigger create event for all others
	for _, obj := range objlist {
		ct.logger.Infof("diffStatsAlertPolicy(): Adding object %#v", obj.GetKey())
		evt := kvstore.WatchEvent{
			Type:   kvstore.Created,
			Key:    obj.GetKey(),
			Object: obj,
		}
		ct.handleStatsAlertPolicyEvent(&evt)
	}
}

func (ct *ctrlerCtx) runStatsAlertPolicyWatcher() {
	kind := "StatsAlertPolicy"

	ct.Lock()
	handler, ok := ct.handlers[kind]
	ct.Unlock()
	if !ok {
		ct.logger.Fatalf("Cant find the handler for %s", kind)
	}
	statsalertpolicyHandler := handler.(StatsAlertPolicyHandler)

	opts := statsalertpolicyHandler.GetStatsAlertPolicyWatchOptions()

	// if there is no API server to connect to, we are done
	if (ct.resolver == nil) || ct.apisrvURL == "" {
		return
	}

	// create context
	ctx, cancel := context.WithCancel(context.Background())
	ct.Lock()
	ct.watchCancel[kind] = cancel
	ct.Unlock()
	logger := ct.logger.WithContext("submodule", "StatsAlertPolicyWatcher")
	for {
		if ctx.Err() != nil {
			return
		}

		apiclt, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
		// create a grpc client
		if err == nil {
			// Upon successful connection perform the diff, and start watch goroutine
			ct.diffStatsAlertPolicy(apiclt)
			break
		}

		logger.Warnf("Failed to connect to gRPC server [%s]\n", ct.apisrvURL)
		time.Sleep(time.Second)
	}

	// setup wait group
	ct.waitGrp.Add(1)

	// start a goroutine
	go func() {
		defer ct.waitGrp.Done()
		ct.stats.Counter("StatsAlertPolicy_Watch").Inc()
		defer ct.stats.Counter("StatsAlertPolicy_Watch").Dec()

		// loop forever
		for {
			// create a grpc client
			apicl, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
			if err != nil {
				logger.Warnf("Failed to connect to gRPC server [%s]\n", ct.apisrvURL)
				ct.stats.Counter("StatsAlertPolicy_ApiClientErr").Inc()
			} else {
				logger.Infof("API client connected {%+v}", apicl)

				// StatsAlertPolicy object watcher
				wt, werr := apicl.MonitoringV1().StatsAlertPolicy().Watch(ctx, opts)
				if werr != nil {
					select {
					case <-ctx.Done():
						logger.Infof("watch %s cancelled", kind)
						return
					default:
					}
					logger.Errorf("Failed to start %s watch (%s)\n", kind, werr)
					// wait for a second and retry connecting to api server
					apicl.Close()
					time.Sleep(time.Second)
					continue
				}
				ct.Lock()
				ct.watchers[kind] = wt
				ct.Unlock()

				// perform a diff with API server and local cache
				// Sleeping to give time for other apiclient's to reconnect
				// before calling reconnect handler
				time.Sleep(time.Second)
				ct.diffStatsAlertPolicy(apicl)
				statsalertpolicyHandler.OnStatsAlertPolicyReconnect()

				// handle api server watch events
			innerLoop:
				for {
					// wait for events
					select {
					case evt, ok := <-wt.EventChan():
						if !ok {
							logger.Error("Error receiving from apisrv watcher")
							ct.stats.Counter("StatsAlertPolicy_WatchErrors").Inc()
							break innerLoop
						}

						// handle event in parallel
						ct.handleStatsAlertPolicyEventParallel(evt)
					}
				}
				apicl.Close()
			}

			// if stop flag is set, we are done
			if ct.stoped {
				logger.Infof("Exiting API server watcher")
				return
			}

			// wait for a second and retry connecting to api server
			time.Sleep(time.Second)
		}
	}()
}

// WatchStatsAlertPolicy starts watch on StatsAlertPolicy object
func (ct *ctrlerCtx) WatchStatsAlertPolicy(handler StatsAlertPolicyHandler) error {
	kind := "StatsAlertPolicy"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchCancel[kind]
	ct.Unlock()
	if ok {
		return fmt.Errorf("StatsAlertPolicy watcher already exists")
	}

	// save handler
	ct.Lock()
	ct.handlers[kind] = handler
	ct.Unlock()

	// run StatsAlertPolicy watcher in a go routine
	ct.runStatsAlertPolicyWatcher()

	return nil
}

// StopWatchStatsAlertPolicy stops watch on StatsAlertPolicy object
func (ct *ctrlerCtx) StopWatchStatsAlertPolicy(handler StatsAlertPolicyHandler) error {
	kind := "StatsAlertPolicy"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchCancel[kind]
	ct.Unlock()
	if !ok {
		return fmt.Errorf("StatsAlertPolicy watcher does not exist")
	}

	ct.Lock()
	cancel, _ := ct.watchCancel[kind]
	cancel()
	if _, ok := ct.watchers[kind]; ok {
		delete(ct.watchers, kind)
	}
	delete(ct.watchCancel, kind)
	ct.Unlock()

	time.Sleep(100 * time.Millisecond)

	return nil
}

// StatsAlertPolicyAPI returns
type StatsAlertPolicyAPI interface {
	Create(obj *monitoring.StatsAlertPolicy) error
	SyncCreate(obj *monitoring.StatsAlertPolicy) error
	Update(obj *monitoring.StatsAlertPolicy) error
	SyncUpdate(obj *monitoring.StatsAlertPolicy) error
	Label(obj *api.Label) error
	Delete(obj *monitoring.StatsAlertPolicy) error
	Find(meta *api.ObjectMeta) (*StatsAlertPolicy, error)
	List(ctx context.Context, opts *api.ListWatchOptions) ([]*StatsAlertPolicy, error)
	ApisrvList(ctx context.Context, opts *api.ListWatchOptions) ([]*monitoring.StatsAlertPolicy, error)
	Watch(handler StatsAlertPolicyHandler) error
	ClearCache(handler StatsAlertPolicyHandler)
	StopWatch(handler StatsAlertPolicyHandler) error
}

// dummy struct that implements StatsAlertPolicyAPI
type statsalertpolicyAPI struct {
	ct *ctrlerCtx
}

// Create creates StatsAlertPolicy object
func (api *statsalertpolicyAPI) Create(obj *monitoring.StatsAlertPolicy) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.MonitoringV1().StatsAlertPolicy().Create(context.Background(), obj)
		if err != nil && strings.Contains(err.Error(), "AlreadyExists") {
			_, err = apicl.MonitoringV1().StatsAlertPolicy().Update(context.Background(), obj)

		}
		return err
	}

	api.ct.handleStatsAlertPolicyEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Created})
	return nil
}

// SyncCreate creates StatsAlertPolicy object and updates the cache
func (api *statsalertpolicyAPI) SyncCreate(obj *monitoring.StatsAlertPolicy) error {
	newObj := obj
	evtType := kvstore.Created
	var writeErr error
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		newObj, writeErr = apicl.MonitoringV1().StatsAlertPolicy().Create(context.Background(), obj)
		if writeErr != nil && strings.Contains(writeErr.Error(), "AlreadyExists") {
			newObj, writeErr = apicl.MonitoringV1().StatsAlertPolicy().Update(context.Background(), obj)
			evtType = kvstore.Updated
		}
	}

	if writeErr == nil {
		api.ct.handleStatsAlertPolicyEvent(&kvstore.WatchEvent{Object: newObj, Type: evtType})
	}
	return writeErr
}

// Update triggers update on StatsAlertPolicy object
func (api *statsalertpolicyAPI) Update(obj *monitoring.StatsAlertPolicy) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.MonitoringV1().StatsAlertPolicy().Update(context.Background(), obj)
		return err
	}

	api.ct.handleStatsAlertPolicyEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Updated})
	return nil
}

// SyncUpdate triggers update on StatsAlertPolicy object and updates the cache
func (api *statsalertpolicyAPI) SyncUpdate(obj *monitoring.StatsAlertPolicy) error {
	if api.ct.objResolver != nil {
		log.Fatal("Cannot use Sync update when object resolver is enabled on ctkit")
	}
	newObj := obj
	var writeErr error
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		newObj, writeErr = apicl.MonitoringV1().StatsAlertPolicy().Update(context.Background(), obj)
	}

	if writeErr == nil {
		api.ct.handleStatsAlertPolicyEvent(&kvstore.WatchEvent{Object: newObj, Type: kvstore.Updated})
	}

	return writeErr
}

// Label labels StatsAlertPolicy object
func (api *statsalertpolicyAPI) Label(obj *api.Label) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.MonitoringV1().StatsAlertPolicy().Label(context.Background(), obj)
		return err
	}

	ctkitObj, err := api.Find(obj.GetObjectMeta())
	if err != nil {
		return err
	}
	writeObj := ctkitObj.StatsAlertPolicy
	writeObj.Labels = obj.Labels

	api.ct.handleStatsAlertPolicyEvent(&kvstore.WatchEvent{Object: &writeObj, Type: kvstore.Updated})
	return nil
}

// Delete deletes StatsAlertPolicy object
func (api *statsalertpolicyAPI) Delete(obj *monitoring.StatsAlertPolicy) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.MonitoringV1().StatsAlertPolicy().Delete(context.Background(), &obj.ObjectMeta)
		return err
	}

	api.ct.handleStatsAlertPolicyEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Deleted})
	return nil
}

// MakeKey generates a KV store key for the object
func (api *statsalertpolicyAPI) getFullKey(tenant, name string) string {
	if tenant != "" {
		return fmt.Sprint(globals.ConfigRootPrefix, "/", "monitoring", "/", "statsAlertPolicies", "/", tenant, "/", name)
	}
	return fmt.Sprint(globals.ConfigRootPrefix, "/", "monitoring", "/", "statsAlertPolicies", "/", name)
}

// Find returns an object by meta
func (api *statsalertpolicyAPI) Find(meta *api.ObjectMeta) (*StatsAlertPolicy, error) {
	// find the object
	obj, err := api.ct.FindObject("StatsAlertPolicy", meta)
	if err != nil {
		return nil, err
	}

	// asset type
	switch obj.(type) {
	case *StatsAlertPolicy:
		hobj := obj.(*StatsAlertPolicy)
		return hobj, nil
	default:
		return nil, errors.New("incorrect object type")
	}
}

// List returns a list of all StatsAlertPolicy objects
func (api *statsalertpolicyAPI) List(ctx context.Context, opts *api.ListWatchOptions) ([]*StatsAlertPolicy, error) {
	var objlist []*StatsAlertPolicy
	objs, err := api.ct.List("StatsAlertPolicy", ctx, opts)

	if err != nil {
		return nil, err
	}

	for _, obj := range objs {
		switch tp := obj.(type) {
		case *StatsAlertPolicy:
			eobj := obj.(*StatsAlertPolicy)
			objlist = append(objlist, eobj)
		default:
			log.Fatalf("Got invalid object type %v while looking for StatsAlertPolicy", tp)
		}
	}

	return objlist, nil
}

// ApisrvList returns a list of all StatsAlertPolicy objects from apiserver
func (api *statsalertpolicyAPI) ApisrvList(ctx context.Context, opts *api.ListWatchOptions) ([]*monitoring.StatsAlertPolicy, error) {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return nil, err
		}

		return apicl.MonitoringV1().StatsAlertPolicy().List(context.Background(), opts)
	}

	// List from local cache
	ctkitObjs, err := api.List(ctx, opts)
	if err != nil {
		return nil, err
	}
	var ret []*monitoring.StatsAlertPolicy
	for _, obj := range ctkitObjs {
		ret = append(ret, &obj.StatsAlertPolicy)
	}
	return ret, nil
}

// Watch sets up a event handlers for StatsAlertPolicy object
func (api *statsalertpolicyAPI) Watch(handler StatsAlertPolicyHandler) error {
	api.ct.startWorkerPool("StatsAlertPolicy")
	return api.ct.WatchStatsAlertPolicy(handler)
}

// StopWatch stop watch for Tenant StatsAlertPolicy object
func (api *statsalertpolicyAPI) StopWatch(handler StatsAlertPolicyHandler) error {
	api.ct.Lock()
	api.ct.workPools["StatsAlertPolicy"].Stop()
	api.ct.Unlock()
	return api.ct.StopWatchStatsAlertPolicy(handler)
}

// ClearCache removes all StatsAlertPolicy objects in ctkit
func (api *statsalertpolicyAPI) ClearCache(handler StatsAlertPolicyHandler) {
	api.ct.delKind("StatsAlertPolicy")
}

// StatsAlertPolicy returns StatsAlertPolicyAPI
func (ct *ctrlerCtx) StatsAlertPolicy() StatsAlertPolicyAPI {
	kind := "StatsAlertPolicy"
	if _, ok := ct.apiInfMap[kind]; !ok {
		s := &statsalertpolicyAPI{ct: ct}
		ct.apiInfMap[kind] = s
	}
	return ct.apiInfMap[kind].(*statsalertpolicyAPI)
}

// AlertDestination is a wrapper object that implements additional functionality
type AlertDestination struct {
	sync.Mutex
	monitoring.AlertDestination
	HandlerCtx interface{} // additional state handlers can store
	ctrler     *ctrlerCtx  // reference back to the controller instance
	internal   bool
}

func (obj *AlertDestination) SetInternal() {
	obj.internal = true
}

func (obj *AlertDestination) Write() error {
	// if there is no API server to connect to, we are done
	if (obj.ctrler == nil) || (obj.ctrler.resolver == nil) || obj.ctrler.apisrvURL == "" {
		return nil
	}

	apicl, err := obj.ctrler.apiClient()
	if err != nil {
		obj.ctrler.logger.Errorf("Error creating API server clent. Err: %v", err)
		return err
	}

	obj.ctrler.stats.Counter("AlertDestination_Writes").Inc()

	// write to api server
	if obj.ObjectMeta.ResourceVersion != "" {
		// update it
		for i := 0; i < maxApisrvWriteRetry; i++ {
			_, err = apicl.MonitoringV1().AlertDestination().UpdateStatus(context.Background(), &obj.AlertDestination)
			if err == nil {
				break
			}
			time.Sleep(time.Millisecond * 100)
		}
	} else {
		//  create
		_, err = apicl.MonitoringV1().AlertDestination().Create(context.Background(), &obj.AlertDestination)
	}

	return nil
}

// AlertDestinationHandler is the event handler for AlertDestination object
type AlertDestinationHandler interface {
	OnAlertDestinationCreate(obj *AlertDestination) error
	OnAlertDestinationUpdate(oldObj *AlertDestination, newObj *monitoring.AlertDestination) error
	OnAlertDestinationDelete(obj *AlertDestination) error
	GetAlertDestinationWatchOptions() *api.ListWatchOptions
	OnAlertDestinationReconnect()
}

// OnAlertDestinationCreate is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnAlertDestinationCreate(obj *AlertDestination) error {
	log.Info("OnAlertDestinationCreate is not implemented")
	return nil
}

// OnAlertDestinationUpdate is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnAlertDestinationUpdate(oldObj *AlertDestination, newObj *monitoring.AlertDestination) error {
	log.Info("OnAlertDestinationUpdate is not implemented")
	return nil
}

// OnAlertDestinationDelete is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnAlertDestinationDelete(obj *AlertDestination) error {
	log.Info("OnAlertDestinationDelete is not implemented")
	return nil
}

// GetAlertDestinationWatchOptions is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) GetAlertDestinationWatchOptions() *api.ListWatchOptions {
	log.Info("GetAlertDestinationWatchOptions is not implemented")
	opts := &api.ListWatchOptions{}
	return opts
}

// OnAlertDestinationReconnect is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnAlertDestinationReconnect() {
	log.Info("OnAlertDestinationReconnect is not implemented")
	return
}

// handleAlertDestinationEvent handles AlertDestination events from watcher
func (ct *ctrlerCtx) handleAlertDestinationEvent(evt *kvstore.WatchEvent) error {

	if ct.objResolver == nil {
		return ct.handleAlertDestinationEventNoResolver(evt)
	}

	switch tp := evt.Object.(type) {
	case *monitoring.AlertDestination:
		eobj := evt.Object.(*monitoring.AlertDestination)
		kind := "AlertDestination"

		eobj.ApplyStorageTransformer(context.Background(), true /*encrypt*/)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		eobj.ApplyStorageTransformer(context.Background(), false /*decrypt*/)

		ctx := &alertdestinationCtx{event: evt.Type,
			obj: &AlertDestination{AlertDestination: *eobj, ctrler: ct}}

		var err error
		switch evt.Type {
		case kvstore.Created:
			err = ct.processAdd(ctx)
		case kvstore.Updated:
			err = ct.processUpdate(ctx)
		case kvstore.Deleted:
			err = ct.processDelete(ctx)
		}
		return err
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on AlertDestination watch channel", tp)
	}

	return nil
}

// handleAlertDestinationEventNoResolver handles AlertDestination events from watcher
func (ct *ctrlerCtx) handleAlertDestinationEventNoResolver(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *monitoring.AlertDestination:
		eobj := evt.Object.(*monitoring.AlertDestination)
		kind := "AlertDestination"

		eobj.ApplyStorageTransformer(context.Background(), true /*encrypt*/)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		eobj.ApplyStorageTransformer(context.Background(), false /*decrypt*/)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		alertdestinationHandler := handler.(AlertDestinationHandler)
		// handle based on event type
		ctrlCtx := &alertdestinationCtx{event: evt.Type, obj: &AlertDestination{AlertDestination: *eobj, ctrler: ct}}
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			fobj, err := ct.getObject(kind, ctrlCtx.GetKey())
			if err != nil {
				ct.addObject(ctrlCtx)
				ct.stats.Counter("AlertDestination_Created_Events").Inc()

				// call the event handler
				ctrlCtx.Lock()
				err = alertdestinationHandler.OnAlertDestinationCreate(ctrlCtx.obj)
				ctrlCtx.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctrlCtx.obj.GetObjectMeta(), err)
					ct.delObject(kind, ctrlCtx.GetKey())
					return err
				}
			} else {
				fResVer, fErr := strconv.ParseInt(fobj.GetResourceVersion(), 10, 64)
				eResVer, eErr := strconv.ParseInt(eobj.GetResourceVersion(), 10, 64)
				if ct.resolver != nil && fErr == nil && eErr == nil && fResVer >= eResVer {
					// Event already processed.
					ct.logger.Infof("Skipping update due to old resource version")
					return nil
				}
				ctrlCtx := fobj.(*alertdestinationCtx)
				ct.stats.Counter("AlertDestination_Updated_Events").Inc()
				ctrlCtx.Lock()
				p := monitoring.AlertDestination{Spec: eobj.Spec,
					ObjectMeta: eobj.ObjectMeta,
					TypeMeta:   eobj.TypeMeta,
					Status:     eobj.Status}

				err = alertdestinationHandler.OnAlertDestinationUpdate(ctrlCtx.obj, &p)
				ctrlCtx.obj.AlertDestination = *eobj
				ctrlCtx.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctrlCtx.obj.GetObjectMeta(), err)
					return err
				}

			}
		case kvstore.Deleted:
			ctrlCtx := &alertdestinationCtx{event: evt.Type, obj: &AlertDestination{AlertDestination: *eobj, ctrler: ct}}
			fobj, err := ct.findObject(kind, ctrlCtx.GetKey())
			if err != nil {
				ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
				return err
			}

			obj := fobj.(*AlertDestination)
			ct.stats.Counter("AlertDestination_Deleted_Events").Inc()
			obj.Lock()
			err = alertdestinationHandler.OnAlertDestinationDelete(obj)
			obj.Unlock()
			if err != nil {
				ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj.GetObjectMeta(), err)
			}
			ct.delObject(kind, ctrlCtx.GetKey())
			return nil

		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on AlertDestination watch channel", tp)
	}

	return nil
}

type alertdestinationCtx struct {
	ctkitBaseCtx
	event kvstore.WatchEventType
	obj   *AlertDestination //
	//   newObj     *monitoring.AlertDestination //update
	newObj *alertdestinationCtx //update
}

func (ctx *alertdestinationCtx) References() map[string]apiintf.ReferenceObj {
	if ctx.references == nil {
		resp := make(map[string]apiintf.ReferenceObj)
		ctx.references = resp
		ctx.obj.References(ctx.obj.GetObjectMeta().Name, ctx.obj.GetObjectMeta().Namespace, resp)
		ctx.obj.ctrler.filterOutRefs(ctx)
	}
	return ctx.references
}

func (ctx *alertdestinationCtx) GetKey() string {
	return ctx.obj.MakeKey("monitoring")

}

func (ctx *alertdestinationCtx) IsInternal() bool {
	return ctx.obj.internal
}

func (ctx *alertdestinationCtx) GetKind() string {
	return ctx.obj.GetKind()
}

func (ctx *alertdestinationCtx) GetResourceVersion() string {
	return ctx.obj.GetResourceVersion()
}

func (ctx *alertdestinationCtx) SetEvent(event kvstore.WatchEventType) {
	ctx.event = event
}

func (ctx *alertdestinationCtx) SetNewObj(newObj apiintf.CtkitObject) {
	if newObj == nil {
		ctx.newObj = nil
	} else {
		ctx.newObj = newObj.(*alertdestinationCtx)
		ctx.newObj.obj.HandlerCtx = ctx.obj.HandlerCtx
		ctx.references = newObj.References()
	}
}

func (ctx *alertdestinationCtx) GetNewObj() apiintf.CtkitObject {
	return ctx.newObj
}

func (ctx *alertdestinationCtx) Copy(obj apiintf.CtkitObject) {
	ctx.obj.AlertDestination = obj.(*alertdestinationCtx).obj.AlertDestination
	ctx.SetWatchTs(obj.GetWatchTs())
}

func (ctx *alertdestinationCtx) Lock() {
	ctx.obj.Lock()
}

func (ctx *alertdestinationCtx) Unlock() {
	ctx.obj.Unlock()
}

func (ctx *alertdestinationCtx) GetObjectMeta() *api.ObjectMeta {
	return ctx.obj.GetObjectMeta()
}

func (ctx *alertdestinationCtx) RuntimeObject() runtime.Object {
	var v interface{}
	v = ctx.obj
	return v.(runtime.Object)
}

func (ctx *alertdestinationCtx) WorkFunc(context context.Context) error {
	var err error
	evt := ctx.event
	ct := ctx.obj.ctrler
	kind := "AlertDestination"
	ct.Lock()
	handler, ok := ct.handlers[kind]
	ct.Unlock()
	if !ok {
		ct.logger.Fatalf("Cant find the handler for %s", kind)
	}
	alertdestinationHandler := handler.(AlertDestinationHandler)
	switch evt {
	case kvstore.Created:
		ctx.obj.Lock()
		err = alertdestinationHandler.OnAlertDestinationCreate(ctx.obj)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctx.obj.GetObjectMeta(), err)
			ctx.SetEvent(kvstore.Deleted)
		}
	case kvstore.Updated:
		ct.stats.Counter("AlertDestination_Updated_Events").Inc()
		ctx.obj.Lock()
		p := monitoring.AlertDestination{Spec: ctx.newObj.obj.Spec,
			ObjectMeta: ctx.newObj.obj.ObjectMeta,
			TypeMeta:   ctx.newObj.obj.TypeMeta,
			Status:     ctx.newObj.obj.Status}
		err = alertdestinationHandler.OnAlertDestinationUpdate(ctx.obj, &p)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctx.obj.GetObjectMeta(), err)
			ctx.SetEvent(kvstore.Deleted)
		}
	case kvstore.Deleted:
		ctx.obj.Lock()
		err = alertdestinationHandler.OnAlertDestinationDelete(ctx.obj)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error deleting %s %+v. Err: %v", kind, ctx.obj.GetObjectMeta(), err)
		}
	}
	ct.resolveObject(ctx.event, ctx)
	return nil
}

// handleAlertDestinationEventParallel handles AlertDestination events from watcher
func (ct *ctrlerCtx) handleAlertDestinationEventParallel(evt *kvstore.WatchEvent) error {

	if ct.objResolver == nil {
		return ct.handleAlertDestinationEventParallelWithNoResolver(evt)
	}

	switch tp := evt.Object.(type) {
	case *monitoring.AlertDestination:
		eobj := evt.Object.(*monitoring.AlertDestination)
		kind := "AlertDestination"

		eobj.ApplyStorageTransformer(context.Background(), true /*encrypt*/)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		eobj.ApplyStorageTransformer(context.Background(), false /*decrypt*/)

		ctx := &alertdestinationCtx{event: evt.Type, obj: &AlertDestination{AlertDestination: *eobj, ctrler: ct}}
		ctx.SetWatchTs(evt.WatchTS)

		var err error
		switch evt.Type {
		case kvstore.Created:
			err = ct.processAdd(ctx)
		case kvstore.Updated:
			err = ct.processUpdate(ctx)
		case kvstore.Deleted:
			err = ct.processDelete(ctx)
		}
		return err
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on AlertDestination watch channel", tp)
	}

	return nil
}

// handleAlertDestinationEventParallel handles AlertDestination events from watcher
func (ct *ctrlerCtx) handleAlertDestinationEventParallelWithNoResolver(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *monitoring.AlertDestination:
		eobj := evt.Object.(*monitoring.AlertDestination)
		kind := "AlertDestination"

		eobj.ApplyStorageTransformer(context.Background(), true /*encrypt*/)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		eobj.ApplyStorageTransformer(context.Background(), false /*decrypt*/)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		alertdestinationHandler := handler.(AlertDestinationHandler)
		// handle based on event type
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			workFunc := func(ctx context.Context, ctrlCtx shardworkers.WorkObj) error {
				var err error
				workCtx := ctrlCtx.(*alertdestinationCtx)
				eobj := workCtx.obj
				fobj, err := ct.getObject(kind, workCtx.GetKey())
				if err != nil {
					ct.addObject(workCtx)
					ct.stats.Counter("AlertDestination_Created_Events").Inc()
					eobj.Lock()
					err = alertdestinationHandler.OnAlertDestinationCreate(eobj)
					eobj.Unlock()
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, eobj.GetObjectMeta(), err)
						ct.delObject(kind, workCtx.GetKey())
					}
				} else {
					workCtx = fobj.(*alertdestinationCtx)
					obj := workCtx.obj
					ct.stats.Counter("AlertDestination_Updated_Events").Inc()
					obj.Lock()
					p := monitoring.AlertDestination{Spec: eobj.Spec,
						ObjectMeta: eobj.ObjectMeta,
						TypeMeta:   eobj.TypeMeta,
						Status:     eobj.Status}

					err = alertdestinationHandler.OnAlertDestinationUpdate(obj, &p)
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj.GetObjectMeta(), err)
					} else {
						workCtx.obj.AlertDestination = p
					}
					obj.Unlock()
				}
				workCtx.SetWatchTs(evt.WatchTS)
				return err
			}
			ctrlCtx := &alertdestinationCtx{event: evt.Type, obj: &AlertDestination{AlertDestination: *eobj, ctrler: ct}}
			ct.runFunction("AlertDestination", ctrlCtx, workFunc)
		case kvstore.Deleted:
			workFunc := func(ctx context.Context, ctrlCtx shardworkers.WorkObj) error {
				var err error
				workCtx := ctrlCtx.(*alertdestinationCtx)
				eobj := workCtx.obj
				fobj, err := ct.findObject(kind, workCtx.GetKey())
				if err != nil {
					ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
					return err
				}
				obj := fobj.(*AlertDestination)
				ct.stats.Counter("AlertDestination_Deleted_Events").Inc()
				obj.Lock()
				err = alertdestinationHandler.OnAlertDestinationDelete(obj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj.GetObjectMeta(), err)
				}
				ct.delObject(kind, workCtx.GetKey())
				return nil
			}
			ctrlCtx := &alertdestinationCtx{event: evt.Type, obj: &AlertDestination{AlertDestination: *eobj, ctrler: ct}}
			ct.runFunction("AlertDestination", ctrlCtx, workFunc)
		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on AlertDestination watch channel", tp)
	}

	return nil
}

// diffAlertDestination does a diff of AlertDestination objects between local cache and API server
func (ct *ctrlerCtx) diffAlertDestination(apicl apiclient.Services) {
	opts := api.ListWatchOptions{}

	// get a list of all objects from API server
	objlist, err := apicl.MonitoringV1().AlertDestination().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Errorf("Error getting a list of objects. Err: %v", err)
		return
	}

	ct.logger.Infof("diffAlertDestination(): AlertDestinationList returned %d objects", len(objlist))

	// build an object map
	objmap := make(map[string]*monitoring.AlertDestination)
	for _, obj := range objlist {
		objmap[obj.GetKey()] = obj
	}

	list, err := ct.AlertDestination().List(context.Background(), &opts)
	if err != nil && !strings.Contains(err.Error(), "not found in local cache") {
		ct.logger.Infof("Failed to get a list of objects. Err: %s", err)
		return
	}

	// if an object is in our local cache and not in API server, trigger delete for it
	for _, obj := range list {
		_, ok := objmap[obj.GetKey()]
		if !ok {
			ct.logger.Infof("diffAlertDestination(): Deleting existing object %#v since its not in apiserver", obj.GetKey())
			evt := kvstore.WatchEvent{
				Type:   kvstore.Deleted,
				Key:    obj.GetKey(),
				Object: &obj.AlertDestination,
			}
			ct.handleAlertDestinationEvent(&evt)
		}
	}

	// trigger create event for all others
	for _, obj := range objlist {
		ct.logger.Infof("diffAlertDestination(): Adding object %#v", obj.GetKey())
		evt := kvstore.WatchEvent{
			Type:   kvstore.Created,
			Key:    obj.GetKey(),
			Object: obj,
		}
		ct.handleAlertDestinationEvent(&evt)
	}
}

func (ct *ctrlerCtx) runAlertDestinationWatcher() {
	kind := "AlertDestination"

	ct.Lock()
	handler, ok := ct.handlers[kind]
	ct.Unlock()
	if !ok {
		ct.logger.Fatalf("Cant find the handler for %s", kind)
	}
	alertdestinationHandler := handler.(AlertDestinationHandler)

	opts := alertdestinationHandler.GetAlertDestinationWatchOptions()

	// if there is no API server to connect to, we are done
	if (ct.resolver == nil) || ct.apisrvURL == "" {
		return
	}

	// create context
	ctx, cancel := context.WithCancel(context.Background())
	ct.Lock()
	ct.watchCancel[kind] = cancel
	ct.Unlock()
	logger := ct.logger.WithContext("submodule", "AlertDestinationWatcher")
	for {
		if ctx.Err() != nil {
			return
		}

		apiclt, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
		// create a grpc client
		if err == nil {
			// Upon successful connection perform the diff, and start watch goroutine
			ct.diffAlertDestination(apiclt)
			break
		}

		logger.Warnf("Failed to connect to gRPC server [%s]\n", ct.apisrvURL)
		time.Sleep(time.Second)
	}

	// setup wait group
	ct.waitGrp.Add(1)

	// start a goroutine
	go func() {
		defer ct.waitGrp.Done()
		ct.stats.Counter("AlertDestination_Watch").Inc()
		defer ct.stats.Counter("AlertDestination_Watch").Dec()

		// loop forever
		for {
			// create a grpc client
			apicl, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
			if err != nil {
				logger.Warnf("Failed to connect to gRPC server [%s]\n", ct.apisrvURL)
				ct.stats.Counter("AlertDestination_ApiClientErr").Inc()
			} else {
				logger.Infof("API client connected {%+v}", apicl)

				// AlertDestination object watcher
				wt, werr := apicl.MonitoringV1().AlertDestination().Watch(ctx, opts)
				if werr != nil {
					select {
					case <-ctx.Done():
						logger.Infof("watch %s cancelled", kind)
						return
					default:
					}
					logger.Errorf("Failed to start %s watch (%s)\n", kind, werr)
					// wait for a second and retry connecting to api server
					apicl.Close()
					time.Sleep(time.Second)
					continue
				}
				ct.Lock()
				ct.watchers[kind] = wt
				ct.Unlock()

				// perform a diff with API server and local cache
				// Sleeping to give time for other apiclient's to reconnect
				// before calling reconnect handler
				time.Sleep(time.Second)
				ct.diffAlertDestination(apicl)
				alertdestinationHandler.OnAlertDestinationReconnect()

				// handle api server watch events
			innerLoop:
				for {
					// wait for events
					select {
					case evt, ok := <-wt.EventChan():
						if !ok {
							logger.Error("Error receiving from apisrv watcher")
							ct.stats.Counter("AlertDestination_WatchErrors").Inc()
							break innerLoop
						}

						// handle event in parallel
						ct.handleAlertDestinationEventParallel(evt)
					}
				}
				apicl.Close()
			}

			// if stop flag is set, we are done
			if ct.stoped {
				logger.Infof("Exiting API server watcher")
				return
			}

			// wait for a second and retry connecting to api server
			time.Sleep(time.Second)
		}
	}()
}

// WatchAlertDestination starts watch on AlertDestination object
func (ct *ctrlerCtx) WatchAlertDestination(handler AlertDestinationHandler) error {
	kind := "AlertDestination"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchCancel[kind]
	ct.Unlock()
	if ok {
		return fmt.Errorf("AlertDestination watcher already exists")
	}

	// save handler
	ct.Lock()
	ct.handlers[kind] = handler
	ct.Unlock()

	// run AlertDestination watcher in a go routine
	ct.runAlertDestinationWatcher()

	return nil
}

// StopWatchAlertDestination stops watch on AlertDestination object
func (ct *ctrlerCtx) StopWatchAlertDestination(handler AlertDestinationHandler) error {
	kind := "AlertDestination"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchCancel[kind]
	ct.Unlock()
	if !ok {
		return fmt.Errorf("AlertDestination watcher does not exist")
	}

	ct.Lock()
	cancel, _ := ct.watchCancel[kind]
	cancel()
	if _, ok := ct.watchers[kind]; ok {
		delete(ct.watchers, kind)
	}
	delete(ct.watchCancel, kind)
	ct.Unlock()

	time.Sleep(100 * time.Millisecond)

	return nil
}

// AlertDestinationAPI returns
type AlertDestinationAPI interface {
	Create(obj *monitoring.AlertDestination) error
	SyncCreate(obj *monitoring.AlertDestination) error
	Update(obj *monitoring.AlertDestination) error
	SyncUpdate(obj *monitoring.AlertDestination) error
	Label(obj *api.Label) error
	Delete(obj *monitoring.AlertDestination) error
	Find(meta *api.ObjectMeta) (*AlertDestination, error)
	List(ctx context.Context, opts *api.ListWatchOptions) ([]*AlertDestination, error)
	ApisrvList(ctx context.Context, opts *api.ListWatchOptions) ([]*monitoring.AlertDestination, error)
	Watch(handler AlertDestinationHandler) error
	ClearCache(handler AlertDestinationHandler)
	StopWatch(handler AlertDestinationHandler) error
}

// dummy struct that implements AlertDestinationAPI
type alertdestinationAPI struct {
	ct *ctrlerCtx
}

// Create creates AlertDestination object
func (api *alertdestinationAPI) Create(obj *monitoring.AlertDestination) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.MonitoringV1().AlertDestination().Create(context.Background(), obj)
		if err != nil && strings.Contains(err.Error(), "AlreadyExists") {
			_, err = apicl.MonitoringV1().AlertDestination().Update(context.Background(), obj)

		}
		return err
	}

	api.ct.handleAlertDestinationEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Created})
	return nil
}

// SyncCreate creates AlertDestination object and updates the cache
func (api *alertdestinationAPI) SyncCreate(obj *monitoring.AlertDestination) error {
	newObj := obj
	evtType := kvstore.Created
	var writeErr error
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		newObj, writeErr = apicl.MonitoringV1().AlertDestination().Create(context.Background(), obj)
		if writeErr != nil && strings.Contains(writeErr.Error(), "AlreadyExists") {
			newObj, writeErr = apicl.MonitoringV1().AlertDestination().Update(context.Background(), obj)
			evtType = kvstore.Updated
		}
	}

	if writeErr == nil {
		api.ct.handleAlertDestinationEvent(&kvstore.WatchEvent{Object: newObj, Type: evtType})
	}
	return writeErr
}

// Update triggers update on AlertDestination object
func (api *alertdestinationAPI) Update(obj *monitoring.AlertDestination) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.MonitoringV1().AlertDestination().Update(context.Background(), obj)
		return err
	}

	api.ct.handleAlertDestinationEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Updated})
	return nil
}

// SyncUpdate triggers update on AlertDestination object and updates the cache
func (api *alertdestinationAPI) SyncUpdate(obj *monitoring.AlertDestination) error {
	if api.ct.objResolver != nil {
		log.Fatal("Cannot use Sync update when object resolver is enabled on ctkit")
	}
	newObj := obj
	var writeErr error
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		newObj, writeErr = apicl.MonitoringV1().AlertDestination().Update(context.Background(), obj)
	}

	if writeErr == nil {
		api.ct.handleAlertDestinationEvent(&kvstore.WatchEvent{Object: newObj, Type: kvstore.Updated})
	}

	return writeErr
}

// Label labels AlertDestination object
func (api *alertdestinationAPI) Label(obj *api.Label) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.MonitoringV1().AlertDestination().Label(context.Background(), obj)
		return err
	}

	ctkitObj, err := api.Find(obj.GetObjectMeta())
	if err != nil {
		return err
	}
	writeObj := ctkitObj.AlertDestination
	writeObj.Labels = obj.Labels

	api.ct.handleAlertDestinationEvent(&kvstore.WatchEvent{Object: &writeObj, Type: kvstore.Updated})
	return nil
}

// Delete deletes AlertDestination object
func (api *alertdestinationAPI) Delete(obj *monitoring.AlertDestination) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.MonitoringV1().AlertDestination().Delete(context.Background(), &obj.ObjectMeta)
		return err
	}

	api.ct.handleAlertDestinationEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Deleted})
	return nil
}

// MakeKey generates a KV store key for the object
func (api *alertdestinationAPI) getFullKey(tenant, name string) string {
	if tenant != "" {
		return fmt.Sprint(globals.ConfigRootPrefix, "/", "monitoring", "/", "alertDestinations", "/", tenant, "/", name)
	}
	return fmt.Sprint(globals.ConfigRootPrefix, "/", "monitoring", "/", "alertDestinations", "/", name)
}

// Find returns an object by meta
func (api *alertdestinationAPI) Find(meta *api.ObjectMeta) (*AlertDestination, error) {
	// find the object
	obj, err := api.ct.FindObject("AlertDestination", meta)
	if err != nil {
		return nil, err
	}

	// asset type
	switch obj.(type) {
	case *AlertDestination:
		hobj := obj.(*AlertDestination)
		return hobj, nil
	default:
		return nil, errors.New("incorrect object type")
	}
}

// List returns a list of all AlertDestination objects
func (api *alertdestinationAPI) List(ctx context.Context, opts *api.ListWatchOptions) ([]*AlertDestination, error) {
	var objlist []*AlertDestination
	objs, err := api.ct.List("AlertDestination", ctx, opts)

	if err != nil {
		return nil, err
	}

	for _, obj := range objs {
		switch tp := obj.(type) {
		case *AlertDestination:
			eobj := obj.(*AlertDestination)
			objlist = append(objlist, eobj)
		default:
			log.Fatalf("Got invalid object type %v while looking for AlertDestination", tp)
		}
	}

	return objlist, nil
}

// ApisrvList returns a list of all AlertDestination objects from apiserver
func (api *alertdestinationAPI) ApisrvList(ctx context.Context, opts *api.ListWatchOptions) ([]*monitoring.AlertDestination, error) {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return nil, err
		}

		return apicl.MonitoringV1().AlertDestination().List(context.Background(), opts)
	}

	// List from local cache
	ctkitObjs, err := api.List(ctx, opts)
	if err != nil {
		return nil, err
	}
	var ret []*monitoring.AlertDestination
	for _, obj := range ctkitObjs {
		ret = append(ret, &obj.AlertDestination)
	}
	return ret, nil
}

// Watch sets up a event handlers for AlertDestination object
func (api *alertdestinationAPI) Watch(handler AlertDestinationHandler) error {
	api.ct.startWorkerPool("AlertDestination")
	return api.ct.WatchAlertDestination(handler)
}

// StopWatch stop watch for Tenant AlertDestination object
func (api *alertdestinationAPI) StopWatch(handler AlertDestinationHandler) error {
	api.ct.Lock()
	api.ct.workPools["AlertDestination"].Stop()
	api.ct.Unlock()
	return api.ct.StopWatchAlertDestination(handler)
}

// ClearCache removes all AlertDestination objects in ctkit
func (api *alertdestinationAPI) ClearCache(handler AlertDestinationHandler) {
	api.ct.delKind("AlertDestination")
}

// AlertDestination returns AlertDestinationAPI
func (ct *ctrlerCtx) AlertDestination() AlertDestinationAPI {
	kind := "AlertDestination"
	if _, ok := ct.apiInfMap[kind]; !ok {
		s := &alertdestinationAPI{ct: ct}
		ct.apiInfMap[kind] = s
	}
	return ct.apiInfMap[kind].(*alertdestinationAPI)
}

// MirrorSession is a wrapper object that implements additional functionality
type MirrorSession struct {
	sync.Mutex
	monitoring.MirrorSession
	HandlerCtx interface{} // additional state handlers can store
	ctrler     *ctrlerCtx  // reference back to the controller instance
	internal   bool
}

func (obj *MirrorSession) SetInternal() {
	obj.internal = true
}

func (obj *MirrorSession) Write() error {
	// if there is no API server to connect to, we are done
	if (obj.ctrler == nil) || (obj.ctrler.resolver == nil) || obj.ctrler.apisrvURL == "" {
		return nil
	}

	apicl, err := obj.ctrler.apiClient()
	if err != nil {
		obj.ctrler.logger.Errorf("Error creating API server clent. Err: %v", err)
		return err
	}

	obj.ctrler.stats.Counter("MirrorSession_Writes").Inc()

	// write to api server
	if obj.ObjectMeta.ResourceVersion != "" {
		// update it
		for i := 0; i < maxApisrvWriteRetry; i++ {
			_, err = apicl.MonitoringV1().MirrorSession().UpdateStatus(context.Background(), &obj.MirrorSession)
			if err == nil {
				break
			}
			time.Sleep(time.Millisecond * 100)
		}
	} else {
		//  create
		_, err = apicl.MonitoringV1().MirrorSession().Create(context.Background(), &obj.MirrorSession)
	}

	return nil
}

// MirrorSessionHandler is the event handler for MirrorSession object
type MirrorSessionHandler interface {
	OnMirrorSessionCreate(obj *MirrorSession) error
	OnMirrorSessionUpdate(oldObj *MirrorSession, newObj *monitoring.MirrorSession) error
	OnMirrorSessionDelete(obj *MirrorSession) error
	GetMirrorSessionWatchOptions() *api.ListWatchOptions
	OnMirrorSessionReconnect()
}

// OnMirrorSessionCreate is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnMirrorSessionCreate(obj *MirrorSession) error {
	log.Info("OnMirrorSessionCreate is not implemented")
	return nil
}

// OnMirrorSessionUpdate is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnMirrorSessionUpdate(oldObj *MirrorSession, newObj *monitoring.MirrorSession) error {
	log.Info("OnMirrorSessionUpdate is not implemented")
	return nil
}

// OnMirrorSessionDelete is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnMirrorSessionDelete(obj *MirrorSession) error {
	log.Info("OnMirrorSessionDelete is not implemented")
	return nil
}

// GetMirrorSessionWatchOptions is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) GetMirrorSessionWatchOptions() *api.ListWatchOptions {
	log.Info("GetMirrorSessionWatchOptions is not implemented")
	opts := &api.ListWatchOptions{}
	return opts
}

// OnMirrorSessionReconnect is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnMirrorSessionReconnect() {
	log.Info("OnMirrorSessionReconnect is not implemented")
	return
}

// handleMirrorSessionEvent handles MirrorSession events from watcher
func (ct *ctrlerCtx) handleMirrorSessionEvent(evt *kvstore.WatchEvent) error {

	if ct.objResolver == nil {
		return ct.handleMirrorSessionEventNoResolver(evt)
	}

	switch tp := evt.Object.(type) {
	case *monitoring.MirrorSession:
		eobj := evt.Object.(*monitoring.MirrorSession)
		kind := "MirrorSession"

		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ctx := &mirrorsessionCtx{event: evt.Type,
			obj: &MirrorSession{MirrorSession: *eobj, ctrler: ct}}

		var err error
		switch evt.Type {
		case kvstore.Created:
			err = ct.processAdd(ctx)
		case kvstore.Updated:
			err = ct.processUpdate(ctx)
		case kvstore.Deleted:
			err = ct.processDelete(ctx)
		}
		return err
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on MirrorSession watch channel", tp)
	}

	return nil
}

// handleMirrorSessionEventNoResolver handles MirrorSession events from watcher
func (ct *ctrlerCtx) handleMirrorSessionEventNoResolver(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *monitoring.MirrorSession:
		eobj := evt.Object.(*monitoring.MirrorSession)
		kind := "MirrorSession"

		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		mirrorsessionHandler := handler.(MirrorSessionHandler)
		// handle based on event type
		ctrlCtx := &mirrorsessionCtx{event: evt.Type, obj: &MirrorSession{MirrorSession: *eobj, ctrler: ct}}
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			fobj, err := ct.getObject(kind, ctrlCtx.GetKey())
			if err != nil {
				ct.addObject(ctrlCtx)
				ct.stats.Counter("MirrorSession_Created_Events").Inc()

				// call the event handler
				ctrlCtx.Lock()
				err = mirrorsessionHandler.OnMirrorSessionCreate(ctrlCtx.obj)
				ctrlCtx.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctrlCtx.obj.GetObjectMeta(), err)
					ct.delObject(kind, ctrlCtx.GetKey())
					return err
				}
			} else {
				fResVer, fErr := strconv.ParseInt(fobj.GetResourceVersion(), 10, 64)
				eResVer, eErr := strconv.ParseInt(eobj.GetResourceVersion(), 10, 64)
				if ct.resolver != nil && fErr == nil && eErr == nil && fResVer >= eResVer {
					// Event already processed.
					ct.logger.Infof("Skipping update due to old resource version")
					return nil
				}
				ctrlCtx := fobj.(*mirrorsessionCtx)
				ct.stats.Counter("MirrorSession_Updated_Events").Inc()
				ctrlCtx.Lock()
				p := monitoring.MirrorSession{Spec: eobj.Spec,
					ObjectMeta: eobj.ObjectMeta,
					TypeMeta:   eobj.TypeMeta,
					Status:     eobj.Status}

				err = mirrorsessionHandler.OnMirrorSessionUpdate(ctrlCtx.obj, &p)
				ctrlCtx.obj.MirrorSession = *eobj
				ctrlCtx.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctrlCtx.obj.GetObjectMeta(), err)
					return err
				}

			}
		case kvstore.Deleted:
			ctrlCtx := &mirrorsessionCtx{event: evt.Type, obj: &MirrorSession{MirrorSession: *eobj, ctrler: ct}}
			fobj, err := ct.findObject(kind, ctrlCtx.GetKey())
			if err != nil {
				ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
				return err
			}

			obj := fobj.(*MirrorSession)
			ct.stats.Counter("MirrorSession_Deleted_Events").Inc()
			obj.Lock()
			err = mirrorsessionHandler.OnMirrorSessionDelete(obj)
			obj.Unlock()
			if err != nil {
				ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj.GetObjectMeta(), err)
			}
			ct.delObject(kind, ctrlCtx.GetKey())
			return nil

		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on MirrorSession watch channel", tp)
	}

	return nil
}

type mirrorsessionCtx struct {
	ctkitBaseCtx
	event kvstore.WatchEventType
	obj   *MirrorSession //
	//   newObj     *monitoring.MirrorSession //update
	newObj *mirrorsessionCtx //update
}

func (ctx *mirrorsessionCtx) References() map[string]apiintf.ReferenceObj {
	if ctx.references == nil {
		resp := make(map[string]apiintf.ReferenceObj)
		ctx.references = resp
		ctx.obj.References(ctx.obj.GetObjectMeta().Name, ctx.obj.GetObjectMeta().Namespace, resp)
		ctx.obj.ctrler.filterOutRefs(ctx)
	}
	return ctx.references
}

func (ctx *mirrorsessionCtx) GetKey() string {
	return ctx.obj.MakeKey("monitoring")

}

func (ctx *mirrorsessionCtx) IsInternal() bool {
	return ctx.obj.internal
}

func (ctx *mirrorsessionCtx) GetKind() string {
	return ctx.obj.GetKind()
}

func (ctx *mirrorsessionCtx) GetResourceVersion() string {
	return ctx.obj.GetResourceVersion()
}

func (ctx *mirrorsessionCtx) SetEvent(event kvstore.WatchEventType) {
	ctx.event = event
}

func (ctx *mirrorsessionCtx) SetNewObj(newObj apiintf.CtkitObject) {
	if newObj == nil {
		ctx.newObj = nil
	} else {
		ctx.newObj = newObj.(*mirrorsessionCtx)
		ctx.newObj.obj.HandlerCtx = ctx.obj.HandlerCtx
		ctx.references = newObj.References()
	}
}

func (ctx *mirrorsessionCtx) GetNewObj() apiintf.CtkitObject {
	return ctx.newObj
}

func (ctx *mirrorsessionCtx) Copy(obj apiintf.CtkitObject) {
	ctx.obj.MirrorSession = obj.(*mirrorsessionCtx).obj.MirrorSession
	ctx.SetWatchTs(obj.GetWatchTs())
}

func (ctx *mirrorsessionCtx) Lock() {
	ctx.obj.Lock()
}

func (ctx *mirrorsessionCtx) Unlock() {
	ctx.obj.Unlock()
}

func (ctx *mirrorsessionCtx) GetObjectMeta() *api.ObjectMeta {
	return ctx.obj.GetObjectMeta()
}

func (ctx *mirrorsessionCtx) RuntimeObject() runtime.Object {
	var v interface{}
	v = ctx.obj
	return v.(runtime.Object)
}

func (ctx *mirrorsessionCtx) WorkFunc(context context.Context) error {
	var err error
	evt := ctx.event
	ct := ctx.obj.ctrler
	kind := "MirrorSession"
	ct.Lock()
	handler, ok := ct.handlers[kind]
	ct.Unlock()
	if !ok {
		ct.logger.Fatalf("Cant find the handler for %s", kind)
	}
	mirrorsessionHandler := handler.(MirrorSessionHandler)
	switch evt {
	case kvstore.Created:
		ctx.obj.Lock()
		err = mirrorsessionHandler.OnMirrorSessionCreate(ctx.obj)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctx.obj.GetObjectMeta(), err)
			ctx.SetEvent(kvstore.Deleted)
		}
	case kvstore.Updated:
		ct.stats.Counter("MirrorSession_Updated_Events").Inc()
		ctx.obj.Lock()
		p := monitoring.MirrorSession{Spec: ctx.newObj.obj.Spec,
			ObjectMeta: ctx.newObj.obj.ObjectMeta,
			TypeMeta:   ctx.newObj.obj.TypeMeta,
			Status:     ctx.newObj.obj.Status}
		err = mirrorsessionHandler.OnMirrorSessionUpdate(ctx.obj, &p)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctx.obj.GetObjectMeta(), err)
			ctx.SetEvent(kvstore.Deleted)
		}
	case kvstore.Deleted:
		ctx.obj.Lock()
		err = mirrorsessionHandler.OnMirrorSessionDelete(ctx.obj)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error deleting %s %+v. Err: %v", kind, ctx.obj.GetObjectMeta(), err)
		}
	}
	ct.resolveObject(ctx.event, ctx)
	return nil
}

// handleMirrorSessionEventParallel handles MirrorSession events from watcher
func (ct *ctrlerCtx) handleMirrorSessionEventParallel(evt *kvstore.WatchEvent) error {

	if ct.objResolver == nil {
		return ct.handleMirrorSessionEventParallelWithNoResolver(evt)
	}

	switch tp := evt.Object.(type) {
	case *monitoring.MirrorSession:
		eobj := evt.Object.(*monitoring.MirrorSession)
		kind := "MirrorSession"

		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ctx := &mirrorsessionCtx{event: evt.Type, obj: &MirrorSession{MirrorSession: *eobj, ctrler: ct}}
		ctx.SetWatchTs(evt.WatchTS)

		var err error
		switch evt.Type {
		case kvstore.Created:
			err = ct.processAdd(ctx)
		case kvstore.Updated:
			err = ct.processUpdate(ctx)
		case kvstore.Deleted:
			err = ct.processDelete(ctx)
		}
		return err
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on MirrorSession watch channel", tp)
	}

	return nil
}

// handleMirrorSessionEventParallel handles MirrorSession events from watcher
func (ct *ctrlerCtx) handleMirrorSessionEventParallelWithNoResolver(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *monitoring.MirrorSession:
		eobj := evt.Object.(*monitoring.MirrorSession)
		kind := "MirrorSession"

		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		mirrorsessionHandler := handler.(MirrorSessionHandler)
		// handle based on event type
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			workFunc := func(ctx context.Context, ctrlCtx shardworkers.WorkObj) error {
				var err error
				workCtx := ctrlCtx.(*mirrorsessionCtx)
				eobj := workCtx.obj
				fobj, err := ct.getObject(kind, workCtx.GetKey())
				if err != nil {
					ct.addObject(workCtx)
					ct.stats.Counter("MirrorSession_Created_Events").Inc()
					eobj.Lock()
					err = mirrorsessionHandler.OnMirrorSessionCreate(eobj)
					eobj.Unlock()
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, eobj.GetObjectMeta(), err)
						ct.delObject(kind, workCtx.GetKey())
					}
				} else {
					workCtx = fobj.(*mirrorsessionCtx)
					obj := workCtx.obj
					ct.stats.Counter("MirrorSession_Updated_Events").Inc()
					obj.Lock()
					p := monitoring.MirrorSession{Spec: eobj.Spec,
						ObjectMeta: eobj.ObjectMeta,
						TypeMeta:   eobj.TypeMeta,
						Status:     eobj.Status}

					err = mirrorsessionHandler.OnMirrorSessionUpdate(obj, &p)
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj.GetObjectMeta(), err)
					} else {
						workCtx.obj.MirrorSession = p
					}
					obj.Unlock()
				}
				workCtx.SetWatchTs(evt.WatchTS)
				return err
			}
			ctrlCtx := &mirrorsessionCtx{event: evt.Type, obj: &MirrorSession{MirrorSession: *eobj, ctrler: ct}}
			ct.runFunction("MirrorSession", ctrlCtx, workFunc)
		case kvstore.Deleted:
			workFunc := func(ctx context.Context, ctrlCtx shardworkers.WorkObj) error {
				var err error
				workCtx := ctrlCtx.(*mirrorsessionCtx)
				eobj := workCtx.obj
				fobj, err := ct.findObject(kind, workCtx.GetKey())
				if err != nil {
					ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
					return err
				}
				obj := fobj.(*MirrorSession)
				ct.stats.Counter("MirrorSession_Deleted_Events").Inc()
				obj.Lock()
				err = mirrorsessionHandler.OnMirrorSessionDelete(obj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj.GetObjectMeta(), err)
				}
				ct.delObject(kind, workCtx.GetKey())
				return nil
			}
			ctrlCtx := &mirrorsessionCtx{event: evt.Type, obj: &MirrorSession{MirrorSession: *eobj, ctrler: ct}}
			ct.runFunction("MirrorSession", ctrlCtx, workFunc)
		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on MirrorSession watch channel", tp)
	}

	return nil
}

// diffMirrorSession does a diff of MirrorSession objects between local cache and API server
func (ct *ctrlerCtx) diffMirrorSession(apicl apiclient.Services) {
	opts := api.ListWatchOptions{}

	// get a list of all objects from API server
	objlist, err := apicl.MonitoringV1().MirrorSession().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Errorf("Error getting a list of objects. Err: %v", err)
		return
	}

	ct.logger.Infof("diffMirrorSession(): MirrorSessionList returned %d objects", len(objlist))

	// build an object map
	objmap := make(map[string]*monitoring.MirrorSession)
	for _, obj := range objlist {
		objmap[obj.GetKey()] = obj
	}

	list, err := ct.MirrorSession().List(context.Background(), &opts)
	if err != nil && !strings.Contains(err.Error(), "not found in local cache") {
		ct.logger.Infof("Failed to get a list of objects. Err: %s", err)
		return
	}

	// if an object is in our local cache and not in API server, trigger delete for it
	for _, obj := range list {
		_, ok := objmap[obj.GetKey()]
		if !ok {
			ct.logger.Infof("diffMirrorSession(): Deleting existing object %#v since its not in apiserver", obj.GetKey())
			evt := kvstore.WatchEvent{
				Type:   kvstore.Deleted,
				Key:    obj.GetKey(),
				Object: &obj.MirrorSession,
			}
			ct.handleMirrorSessionEvent(&evt)
		}
	}

	// trigger create event for all others
	for _, obj := range objlist {
		ct.logger.Infof("diffMirrorSession(): Adding object %#v", obj.GetKey())
		evt := kvstore.WatchEvent{
			Type:   kvstore.Created,
			Key:    obj.GetKey(),
			Object: obj,
		}
		ct.handleMirrorSessionEvent(&evt)
	}
}

func (ct *ctrlerCtx) runMirrorSessionWatcher() {
	kind := "MirrorSession"

	ct.Lock()
	handler, ok := ct.handlers[kind]
	ct.Unlock()
	if !ok {
		ct.logger.Fatalf("Cant find the handler for %s", kind)
	}
	mirrorsessionHandler := handler.(MirrorSessionHandler)

	opts := mirrorsessionHandler.GetMirrorSessionWatchOptions()

	// if there is no API server to connect to, we are done
	if (ct.resolver == nil) || ct.apisrvURL == "" {
		return
	}

	// create context
	ctx, cancel := context.WithCancel(context.Background())
	ct.Lock()
	ct.watchCancel[kind] = cancel
	ct.Unlock()
	logger := ct.logger.WithContext("submodule", "MirrorSessionWatcher")
	for {
		if ctx.Err() != nil {
			return
		}

		apiclt, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
		// create a grpc client
		if err == nil {
			// Upon successful connection perform the diff, and start watch goroutine
			ct.diffMirrorSession(apiclt)
			break
		}

		logger.Warnf("Failed to connect to gRPC server [%s]\n", ct.apisrvURL)
		time.Sleep(time.Second)
	}

	// setup wait group
	ct.waitGrp.Add(1)

	// start a goroutine
	go func() {
		defer ct.waitGrp.Done()
		ct.stats.Counter("MirrorSession_Watch").Inc()
		defer ct.stats.Counter("MirrorSession_Watch").Dec()

		// loop forever
		for {
			// create a grpc client
			apicl, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
			if err != nil {
				logger.Warnf("Failed to connect to gRPC server [%s]\n", ct.apisrvURL)
				ct.stats.Counter("MirrorSession_ApiClientErr").Inc()
			} else {
				logger.Infof("API client connected {%+v}", apicl)

				// MirrorSession object watcher
				wt, werr := apicl.MonitoringV1().MirrorSession().Watch(ctx, opts)
				if werr != nil {
					select {
					case <-ctx.Done():
						logger.Infof("watch %s cancelled", kind)
						return
					default:
					}
					logger.Errorf("Failed to start %s watch (%s)\n", kind, werr)
					// wait for a second and retry connecting to api server
					apicl.Close()
					time.Sleep(time.Second)
					continue
				}
				ct.Lock()
				ct.watchers[kind] = wt
				ct.Unlock()

				// perform a diff with API server and local cache
				// Sleeping to give time for other apiclient's to reconnect
				// before calling reconnect handler
				time.Sleep(time.Second)
				ct.diffMirrorSession(apicl)
				mirrorsessionHandler.OnMirrorSessionReconnect()

				// handle api server watch events
			innerLoop:
				for {
					// wait for events
					select {
					case evt, ok := <-wt.EventChan():
						if !ok {
							logger.Error("Error receiving from apisrv watcher")
							ct.stats.Counter("MirrorSession_WatchErrors").Inc()
							break innerLoop
						}

						// handle event in parallel
						ct.handleMirrorSessionEventParallel(evt)
					}
				}
				apicl.Close()
			}

			// if stop flag is set, we are done
			if ct.stoped {
				logger.Infof("Exiting API server watcher")
				return
			}

			// wait for a second and retry connecting to api server
			time.Sleep(time.Second)
		}
	}()
}

// WatchMirrorSession starts watch on MirrorSession object
func (ct *ctrlerCtx) WatchMirrorSession(handler MirrorSessionHandler) error {
	kind := "MirrorSession"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchCancel[kind]
	ct.Unlock()
	if ok {
		return fmt.Errorf("MirrorSession watcher already exists")
	}

	// save handler
	ct.Lock()
	ct.handlers[kind] = handler
	ct.Unlock()

	// run MirrorSession watcher in a go routine
	ct.runMirrorSessionWatcher()

	return nil
}

// StopWatchMirrorSession stops watch on MirrorSession object
func (ct *ctrlerCtx) StopWatchMirrorSession(handler MirrorSessionHandler) error {
	kind := "MirrorSession"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchCancel[kind]
	ct.Unlock()
	if !ok {
		return fmt.Errorf("MirrorSession watcher does not exist")
	}

	ct.Lock()
	cancel, _ := ct.watchCancel[kind]
	cancel()
	if _, ok := ct.watchers[kind]; ok {
		delete(ct.watchers, kind)
	}
	delete(ct.watchCancel, kind)
	ct.Unlock()

	time.Sleep(100 * time.Millisecond)

	return nil
}

// MirrorSessionAPI returns
type MirrorSessionAPI interface {
	Create(obj *monitoring.MirrorSession) error
	SyncCreate(obj *monitoring.MirrorSession) error
	Update(obj *monitoring.MirrorSession) error
	SyncUpdate(obj *monitoring.MirrorSession) error
	Label(obj *api.Label) error
	Delete(obj *monitoring.MirrorSession) error
	Find(meta *api.ObjectMeta) (*MirrorSession, error)
	List(ctx context.Context, opts *api.ListWatchOptions) ([]*MirrorSession, error)
	ApisrvList(ctx context.Context, opts *api.ListWatchOptions) ([]*monitoring.MirrorSession, error)
	Watch(handler MirrorSessionHandler) error
	ClearCache(handler MirrorSessionHandler)
	StopWatch(handler MirrorSessionHandler) error
}

// dummy struct that implements MirrorSessionAPI
type mirrorsessionAPI struct {
	ct *ctrlerCtx
}

// Create creates MirrorSession object
func (api *mirrorsessionAPI) Create(obj *monitoring.MirrorSession) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.MonitoringV1().MirrorSession().Create(context.Background(), obj)
		if err != nil && strings.Contains(err.Error(), "AlreadyExists") {
			_, err = apicl.MonitoringV1().MirrorSession().Update(context.Background(), obj)

		}
		return err
	}

	api.ct.handleMirrorSessionEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Created})
	return nil
}

// SyncCreate creates MirrorSession object and updates the cache
func (api *mirrorsessionAPI) SyncCreate(obj *monitoring.MirrorSession) error {
	newObj := obj
	evtType := kvstore.Created
	var writeErr error
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		newObj, writeErr = apicl.MonitoringV1().MirrorSession().Create(context.Background(), obj)
		if writeErr != nil && strings.Contains(writeErr.Error(), "AlreadyExists") {
			newObj, writeErr = apicl.MonitoringV1().MirrorSession().Update(context.Background(), obj)
			evtType = kvstore.Updated
		}
	}

	if writeErr == nil {
		api.ct.handleMirrorSessionEvent(&kvstore.WatchEvent{Object: newObj, Type: evtType})
	}
	return writeErr
}

// Update triggers update on MirrorSession object
func (api *mirrorsessionAPI) Update(obj *monitoring.MirrorSession) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.MonitoringV1().MirrorSession().Update(context.Background(), obj)
		return err
	}

	api.ct.handleMirrorSessionEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Updated})
	return nil
}

// SyncUpdate triggers update on MirrorSession object and updates the cache
func (api *mirrorsessionAPI) SyncUpdate(obj *monitoring.MirrorSession) error {
	if api.ct.objResolver != nil {
		log.Fatal("Cannot use Sync update when object resolver is enabled on ctkit")
	}
	newObj := obj
	var writeErr error
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		newObj, writeErr = apicl.MonitoringV1().MirrorSession().Update(context.Background(), obj)
	}

	if writeErr == nil {
		api.ct.handleMirrorSessionEvent(&kvstore.WatchEvent{Object: newObj, Type: kvstore.Updated})
	}

	return writeErr
}

// Label labels MirrorSession object
func (api *mirrorsessionAPI) Label(obj *api.Label) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.MonitoringV1().MirrorSession().Label(context.Background(), obj)
		return err
	}

	ctkitObj, err := api.Find(obj.GetObjectMeta())
	if err != nil {
		return err
	}
	writeObj := ctkitObj.MirrorSession
	writeObj.Labels = obj.Labels

	api.ct.handleMirrorSessionEvent(&kvstore.WatchEvent{Object: &writeObj, Type: kvstore.Updated})
	return nil
}

// Delete deletes MirrorSession object
func (api *mirrorsessionAPI) Delete(obj *monitoring.MirrorSession) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.MonitoringV1().MirrorSession().Delete(context.Background(), &obj.ObjectMeta)
		return err
	}

	api.ct.handleMirrorSessionEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Deleted})
	return nil
}

// MakeKey generates a KV store key for the object
func (api *mirrorsessionAPI) getFullKey(tenant, name string) string {
	if tenant != "" {
		return fmt.Sprint(globals.ConfigRootPrefix, "/", "monitoring", "/", "MirrorSession", "/", tenant, "/", name)
	}
	return fmt.Sprint(globals.ConfigRootPrefix, "/", "monitoring", "/", "MirrorSession", "/", name)
}

// Find returns an object by meta
func (api *mirrorsessionAPI) Find(meta *api.ObjectMeta) (*MirrorSession, error) {
	// find the object
	obj, err := api.ct.FindObject("MirrorSession", meta)
	if err != nil {
		return nil, err
	}

	// asset type
	switch obj.(type) {
	case *MirrorSession:
		hobj := obj.(*MirrorSession)
		return hobj, nil
	default:
		return nil, errors.New("incorrect object type")
	}
}

// List returns a list of all MirrorSession objects
func (api *mirrorsessionAPI) List(ctx context.Context, opts *api.ListWatchOptions) ([]*MirrorSession, error) {
	var objlist []*MirrorSession
	objs, err := api.ct.List("MirrorSession", ctx, opts)

	if err != nil {
		return nil, err
	}

	for _, obj := range objs {
		switch tp := obj.(type) {
		case *MirrorSession:
			eobj := obj.(*MirrorSession)
			objlist = append(objlist, eobj)
		default:
			log.Fatalf("Got invalid object type %v while looking for MirrorSession", tp)
		}
	}

	return objlist, nil
}

// ApisrvList returns a list of all MirrorSession objects from apiserver
func (api *mirrorsessionAPI) ApisrvList(ctx context.Context, opts *api.ListWatchOptions) ([]*monitoring.MirrorSession, error) {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return nil, err
		}

		return apicl.MonitoringV1().MirrorSession().List(context.Background(), opts)
	}

	// List from local cache
	ctkitObjs, err := api.List(ctx, opts)
	if err != nil {
		return nil, err
	}
	var ret []*monitoring.MirrorSession
	for _, obj := range ctkitObjs {
		ret = append(ret, &obj.MirrorSession)
	}
	return ret, nil
}

// Watch sets up a event handlers for MirrorSession object
func (api *mirrorsessionAPI) Watch(handler MirrorSessionHandler) error {
	api.ct.startWorkerPool("MirrorSession")
	return api.ct.WatchMirrorSession(handler)
}

// StopWatch stop watch for Tenant MirrorSession object
func (api *mirrorsessionAPI) StopWatch(handler MirrorSessionHandler) error {
	api.ct.Lock()
	api.ct.workPools["MirrorSession"].Stop()
	api.ct.Unlock()
	return api.ct.StopWatchMirrorSession(handler)
}

// ClearCache removes all MirrorSession objects in ctkit
func (api *mirrorsessionAPI) ClearCache(handler MirrorSessionHandler) {
	api.ct.delKind("MirrorSession")
}

// MirrorSession returns MirrorSessionAPI
func (ct *ctrlerCtx) MirrorSession() MirrorSessionAPI {
	kind := "MirrorSession"
	if _, ok := ct.apiInfMap[kind]; !ok {
		s := &mirrorsessionAPI{ct: ct}
		ct.apiInfMap[kind] = s
	}
	return ct.apiInfMap[kind].(*mirrorsessionAPI)
}

// TroubleshootingSession is a wrapper object that implements additional functionality
type TroubleshootingSession struct {
	sync.Mutex
	monitoring.TroubleshootingSession
	HandlerCtx interface{} // additional state handlers can store
	ctrler     *ctrlerCtx  // reference back to the controller instance
	internal   bool
}

func (obj *TroubleshootingSession) SetInternal() {
	obj.internal = true
}

func (obj *TroubleshootingSession) Write() error {
	// if there is no API server to connect to, we are done
	if (obj.ctrler == nil) || (obj.ctrler.resolver == nil) || obj.ctrler.apisrvURL == "" {
		return nil
	}

	apicl, err := obj.ctrler.apiClient()
	if err != nil {
		obj.ctrler.logger.Errorf("Error creating API server clent. Err: %v", err)
		return err
	}

	obj.ctrler.stats.Counter("TroubleshootingSession_Writes").Inc()

	// write to api server
	if obj.ObjectMeta.ResourceVersion != "" {
		// update it
		for i := 0; i < maxApisrvWriteRetry; i++ {
			_, err = apicl.MonitoringV1().TroubleshootingSession().UpdateStatus(context.Background(), &obj.TroubleshootingSession)
			if err == nil {
				break
			}
			time.Sleep(time.Millisecond * 100)
		}
	} else {
		//  create
		_, err = apicl.MonitoringV1().TroubleshootingSession().Create(context.Background(), &obj.TroubleshootingSession)
	}

	return nil
}

// TroubleshootingSessionHandler is the event handler for TroubleshootingSession object
type TroubleshootingSessionHandler interface {
	OnTroubleshootingSessionCreate(obj *TroubleshootingSession) error
	OnTroubleshootingSessionUpdate(oldObj *TroubleshootingSession, newObj *monitoring.TroubleshootingSession) error
	OnTroubleshootingSessionDelete(obj *TroubleshootingSession) error
	GetTroubleshootingSessionWatchOptions() *api.ListWatchOptions
	OnTroubleshootingSessionReconnect()
}

// OnTroubleshootingSessionCreate is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnTroubleshootingSessionCreate(obj *TroubleshootingSession) error {
	log.Info("OnTroubleshootingSessionCreate is not implemented")
	return nil
}

// OnTroubleshootingSessionUpdate is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnTroubleshootingSessionUpdate(oldObj *TroubleshootingSession, newObj *monitoring.TroubleshootingSession) error {
	log.Info("OnTroubleshootingSessionUpdate is not implemented")
	return nil
}

// OnTroubleshootingSessionDelete is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnTroubleshootingSessionDelete(obj *TroubleshootingSession) error {
	log.Info("OnTroubleshootingSessionDelete is not implemented")
	return nil
}

// GetTroubleshootingSessionWatchOptions is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) GetTroubleshootingSessionWatchOptions() *api.ListWatchOptions {
	log.Info("GetTroubleshootingSessionWatchOptions is not implemented")
	opts := &api.ListWatchOptions{}
	return opts
}

// OnTroubleshootingSessionReconnect is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnTroubleshootingSessionReconnect() {
	log.Info("OnTroubleshootingSessionReconnect is not implemented")
	return
}

// handleTroubleshootingSessionEvent handles TroubleshootingSession events from watcher
func (ct *ctrlerCtx) handleTroubleshootingSessionEvent(evt *kvstore.WatchEvent) error {

	if ct.objResolver == nil {
		return ct.handleTroubleshootingSessionEventNoResolver(evt)
	}

	switch tp := evt.Object.(type) {
	case *monitoring.TroubleshootingSession:
		eobj := evt.Object.(*monitoring.TroubleshootingSession)
		kind := "TroubleshootingSession"

		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ctx := &troubleshootingsessionCtx{event: evt.Type,
			obj: &TroubleshootingSession{TroubleshootingSession: *eobj, ctrler: ct}}

		var err error
		switch evt.Type {
		case kvstore.Created:
			err = ct.processAdd(ctx)
		case kvstore.Updated:
			err = ct.processUpdate(ctx)
		case kvstore.Deleted:
			err = ct.processDelete(ctx)
		}
		return err
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on TroubleshootingSession watch channel", tp)
	}

	return nil
}

// handleTroubleshootingSessionEventNoResolver handles TroubleshootingSession events from watcher
func (ct *ctrlerCtx) handleTroubleshootingSessionEventNoResolver(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *monitoring.TroubleshootingSession:
		eobj := evt.Object.(*monitoring.TroubleshootingSession)
		kind := "TroubleshootingSession"

		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		troubleshootingsessionHandler := handler.(TroubleshootingSessionHandler)
		// handle based on event type
		ctrlCtx := &troubleshootingsessionCtx{event: evt.Type, obj: &TroubleshootingSession{TroubleshootingSession: *eobj, ctrler: ct}}
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			fobj, err := ct.getObject(kind, ctrlCtx.GetKey())
			if err != nil {
				ct.addObject(ctrlCtx)
				ct.stats.Counter("TroubleshootingSession_Created_Events").Inc()

				// call the event handler
				ctrlCtx.Lock()
				err = troubleshootingsessionHandler.OnTroubleshootingSessionCreate(ctrlCtx.obj)
				ctrlCtx.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctrlCtx.obj.GetObjectMeta(), err)
					ct.delObject(kind, ctrlCtx.GetKey())
					return err
				}
			} else {
				fResVer, fErr := strconv.ParseInt(fobj.GetResourceVersion(), 10, 64)
				eResVer, eErr := strconv.ParseInt(eobj.GetResourceVersion(), 10, 64)
				if ct.resolver != nil && fErr == nil && eErr == nil && fResVer >= eResVer {
					// Event already processed.
					ct.logger.Infof("Skipping update due to old resource version")
					return nil
				}
				ctrlCtx := fobj.(*troubleshootingsessionCtx)
				ct.stats.Counter("TroubleshootingSession_Updated_Events").Inc()
				ctrlCtx.Lock()
				p := monitoring.TroubleshootingSession{Spec: eobj.Spec,
					ObjectMeta: eobj.ObjectMeta,
					TypeMeta:   eobj.TypeMeta,
					Status:     eobj.Status}

				err = troubleshootingsessionHandler.OnTroubleshootingSessionUpdate(ctrlCtx.obj, &p)
				ctrlCtx.obj.TroubleshootingSession = *eobj
				ctrlCtx.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctrlCtx.obj.GetObjectMeta(), err)
					return err
				}

			}
		case kvstore.Deleted:
			ctrlCtx := &troubleshootingsessionCtx{event: evt.Type, obj: &TroubleshootingSession{TroubleshootingSession: *eobj, ctrler: ct}}
			fobj, err := ct.findObject(kind, ctrlCtx.GetKey())
			if err != nil {
				ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
				return err
			}

			obj := fobj.(*TroubleshootingSession)
			ct.stats.Counter("TroubleshootingSession_Deleted_Events").Inc()
			obj.Lock()
			err = troubleshootingsessionHandler.OnTroubleshootingSessionDelete(obj)
			obj.Unlock()
			if err != nil {
				ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj.GetObjectMeta(), err)
			}
			ct.delObject(kind, ctrlCtx.GetKey())
			return nil

		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on TroubleshootingSession watch channel", tp)
	}

	return nil
}

type troubleshootingsessionCtx struct {
	ctkitBaseCtx
	event kvstore.WatchEventType
	obj   *TroubleshootingSession //
	//   newObj     *monitoring.TroubleshootingSession //update
	newObj *troubleshootingsessionCtx //update
}

func (ctx *troubleshootingsessionCtx) References() map[string]apiintf.ReferenceObj {
	if ctx.references == nil {
		resp := make(map[string]apiintf.ReferenceObj)
		ctx.references = resp
		ctx.obj.References(ctx.obj.GetObjectMeta().Name, ctx.obj.GetObjectMeta().Namespace, resp)
		ctx.obj.ctrler.filterOutRefs(ctx)
	}
	return ctx.references
}

func (ctx *troubleshootingsessionCtx) GetKey() string {
	return ctx.obj.MakeKey("monitoring")

}

func (ctx *troubleshootingsessionCtx) IsInternal() bool {
	return ctx.obj.internal
}

func (ctx *troubleshootingsessionCtx) GetKind() string {
	return ctx.obj.GetKind()
}

func (ctx *troubleshootingsessionCtx) GetResourceVersion() string {
	return ctx.obj.GetResourceVersion()
}

func (ctx *troubleshootingsessionCtx) SetEvent(event kvstore.WatchEventType) {
	ctx.event = event
}

func (ctx *troubleshootingsessionCtx) SetNewObj(newObj apiintf.CtkitObject) {
	if newObj == nil {
		ctx.newObj = nil
	} else {
		ctx.newObj = newObj.(*troubleshootingsessionCtx)
		ctx.newObj.obj.HandlerCtx = ctx.obj.HandlerCtx
		ctx.references = newObj.References()
	}
}

func (ctx *troubleshootingsessionCtx) GetNewObj() apiintf.CtkitObject {
	return ctx.newObj
}

func (ctx *troubleshootingsessionCtx) Copy(obj apiintf.CtkitObject) {
	ctx.obj.TroubleshootingSession = obj.(*troubleshootingsessionCtx).obj.TroubleshootingSession
	ctx.SetWatchTs(obj.GetWatchTs())
}

func (ctx *troubleshootingsessionCtx) Lock() {
	ctx.obj.Lock()
}

func (ctx *troubleshootingsessionCtx) Unlock() {
	ctx.obj.Unlock()
}

func (ctx *troubleshootingsessionCtx) GetObjectMeta() *api.ObjectMeta {
	return ctx.obj.GetObjectMeta()
}

func (ctx *troubleshootingsessionCtx) RuntimeObject() runtime.Object {
	var v interface{}
	v = ctx.obj
	return v.(runtime.Object)
}

func (ctx *troubleshootingsessionCtx) WorkFunc(context context.Context) error {
	var err error
	evt := ctx.event
	ct := ctx.obj.ctrler
	kind := "TroubleshootingSession"
	ct.Lock()
	handler, ok := ct.handlers[kind]
	ct.Unlock()
	if !ok {
		ct.logger.Fatalf("Cant find the handler for %s", kind)
	}
	troubleshootingsessionHandler := handler.(TroubleshootingSessionHandler)
	switch evt {
	case kvstore.Created:
		ctx.obj.Lock()
		err = troubleshootingsessionHandler.OnTroubleshootingSessionCreate(ctx.obj)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctx.obj.GetObjectMeta(), err)
			ctx.SetEvent(kvstore.Deleted)
		}
	case kvstore.Updated:
		ct.stats.Counter("TroubleshootingSession_Updated_Events").Inc()
		ctx.obj.Lock()
		p := monitoring.TroubleshootingSession{Spec: ctx.newObj.obj.Spec,
			ObjectMeta: ctx.newObj.obj.ObjectMeta,
			TypeMeta:   ctx.newObj.obj.TypeMeta,
			Status:     ctx.newObj.obj.Status}
		err = troubleshootingsessionHandler.OnTroubleshootingSessionUpdate(ctx.obj, &p)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctx.obj.GetObjectMeta(), err)
			ctx.SetEvent(kvstore.Deleted)
		}
	case kvstore.Deleted:
		ctx.obj.Lock()
		err = troubleshootingsessionHandler.OnTroubleshootingSessionDelete(ctx.obj)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error deleting %s %+v. Err: %v", kind, ctx.obj.GetObjectMeta(), err)
		}
	}
	ct.resolveObject(ctx.event, ctx)
	return nil
}

// handleTroubleshootingSessionEventParallel handles TroubleshootingSession events from watcher
func (ct *ctrlerCtx) handleTroubleshootingSessionEventParallel(evt *kvstore.WatchEvent) error {

	if ct.objResolver == nil {
		return ct.handleTroubleshootingSessionEventParallelWithNoResolver(evt)
	}

	switch tp := evt.Object.(type) {
	case *monitoring.TroubleshootingSession:
		eobj := evt.Object.(*monitoring.TroubleshootingSession)
		kind := "TroubleshootingSession"

		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ctx := &troubleshootingsessionCtx{event: evt.Type, obj: &TroubleshootingSession{TroubleshootingSession: *eobj, ctrler: ct}}
		ctx.SetWatchTs(evt.WatchTS)

		var err error
		switch evt.Type {
		case kvstore.Created:
			err = ct.processAdd(ctx)
		case kvstore.Updated:
			err = ct.processUpdate(ctx)
		case kvstore.Deleted:
			err = ct.processDelete(ctx)
		}
		return err
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on TroubleshootingSession watch channel", tp)
	}

	return nil
}

// handleTroubleshootingSessionEventParallel handles TroubleshootingSession events from watcher
func (ct *ctrlerCtx) handleTroubleshootingSessionEventParallelWithNoResolver(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *monitoring.TroubleshootingSession:
		eobj := evt.Object.(*monitoring.TroubleshootingSession)
		kind := "TroubleshootingSession"

		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		troubleshootingsessionHandler := handler.(TroubleshootingSessionHandler)
		// handle based on event type
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			workFunc := func(ctx context.Context, ctrlCtx shardworkers.WorkObj) error {
				var err error
				workCtx := ctrlCtx.(*troubleshootingsessionCtx)
				eobj := workCtx.obj
				fobj, err := ct.getObject(kind, workCtx.GetKey())
				if err != nil {
					ct.addObject(workCtx)
					ct.stats.Counter("TroubleshootingSession_Created_Events").Inc()
					eobj.Lock()
					err = troubleshootingsessionHandler.OnTroubleshootingSessionCreate(eobj)
					eobj.Unlock()
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, eobj.GetObjectMeta(), err)
						ct.delObject(kind, workCtx.GetKey())
					}
				} else {
					workCtx = fobj.(*troubleshootingsessionCtx)
					obj := workCtx.obj
					ct.stats.Counter("TroubleshootingSession_Updated_Events").Inc()
					obj.Lock()
					p := monitoring.TroubleshootingSession{Spec: eobj.Spec,
						ObjectMeta: eobj.ObjectMeta,
						TypeMeta:   eobj.TypeMeta,
						Status:     eobj.Status}

					err = troubleshootingsessionHandler.OnTroubleshootingSessionUpdate(obj, &p)
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj.GetObjectMeta(), err)
					} else {
						workCtx.obj.TroubleshootingSession = p
					}
					obj.Unlock()
				}
				workCtx.SetWatchTs(evt.WatchTS)
				return err
			}
			ctrlCtx := &troubleshootingsessionCtx{event: evt.Type, obj: &TroubleshootingSession{TroubleshootingSession: *eobj, ctrler: ct}}
			ct.runFunction("TroubleshootingSession", ctrlCtx, workFunc)
		case kvstore.Deleted:
			workFunc := func(ctx context.Context, ctrlCtx shardworkers.WorkObj) error {
				var err error
				workCtx := ctrlCtx.(*troubleshootingsessionCtx)
				eobj := workCtx.obj
				fobj, err := ct.findObject(kind, workCtx.GetKey())
				if err != nil {
					ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
					return err
				}
				obj := fobj.(*TroubleshootingSession)
				ct.stats.Counter("TroubleshootingSession_Deleted_Events").Inc()
				obj.Lock()
				err = troubleshootingsessionHandler.OnTroubleshootingSessionDelete(obj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj.GetObjectMeta(), err)
				}
				ct.delObject(kind, workCtx.GetKey())
				return nil
			}
			ctrlCtx := &troubleshootingsessionCtx{event: evt.Type, obj: &TroubleshootingSession{TroubleshootingSession: *eobj, ctrler: ct}}
			ct.runFunction("TroubleshootingSession", ctrlCtx, workFunc)
		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on TroubleshootingSession watch channel", tp)
	}

	return nil
}

// diffTroubleshootingSession does a diff of TroubleshootingSession objects between local cache and API server
func (ct *ctrlerCtx) diffTroubleshootingSession(apicl apiclient.Services) {
	opts := api.ListWatchOptions{}

	// get a list of all objects from API server
	objlist, err := apicl.MonitoringV1().TroubleshootingSession().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Errorf("Error getting a list of objects. Err: %v", err)
		return
	}

	ct.logger.Infof("diffTroubleshootingSession(): TroubleshootingSessionList returned %d objects", len(objlist))

	// build an object map
	objmap := make(map[string]*monitoring.TroubleshootingSession)
	for _, obj := range objlist {
		objmap[obj.GetKey()] = obj
	}

	list, err := ct.TroubleshootingSession().List(context.Background(), &opts)
	if err != nil && !strings.Contains(err.Error(), "not found in local cache") {
		ct.logger.Infof("Failed to get a list of objects. Err: %s", err)
		return
	}

	// if an object is in our local cache and not in API server, trigger delete for it
	for _, obj := range list {
		_, ok := objmap[obj.GetKey()]
		if !ok {
			ct.logger.Infof("diffTroubleshootingSession(): Deleting existing object %#v since its not in apiserver", obj.GetKey())
			evt := kvstore.WatchEvent{
				Type:   kvstore.Deleted,
				Key:    obj.GetKey(),
				Object: &obj.TroubleshootingSession,
			}
			ct.handleTroubleshootingSessionEvent(&evt)
		}
	}

	// trigger create event for all others
	for _, obj := range objlist {
		ct.logger.Infof("diffTroubleshootingSession(): Adding object %#v", obj.GetKey())
		evt := kvstore.WatchEvent{
			Type:   kvstore.Created,
			Key:    obj.GetKey(),
			Object: obj,
		}
		ct.handleTroubleshootingSessionEvent(&evt)
	}
}

func (ct *ctrlerCtx) runTroubleshootingSessionWatcher() {
	kind := "TroubleshootingSession"

	ct.Lock()
	handler, ok := ct.handlers[kind]
	ct.Unlock()
	if !ok {
		ct.logger.Fatalf("Cant find the handler for %s", kind)
	}
	troubleshootingsessionHandler := handler.(TroubleshootingSessionHandler)

	opts := troubleshootingsessionHandler.GetTroubleshootingSessionWatchOptions()

	// if there is no API server to connect to, we are done
	if (ct.resolver == nil) || ct.apisrvURL == "" {
		return
	}

	// create context
	ctx, cancel := context.WithCancel(context.Background())
	ct.Lock()
	ct.watchCancel[kind] = cancel
	ct.Unlock()
	logger := ct.logger.WithContext("submodule", "TroubleshootingSessionWatcher")
	for {
		if ctx.Err() != nil {
			return
		}

		apiclt, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
		// create a grpc client
		if err == nil {
			// Upon successful connection perform the diff, and start watch goroutine
			ct.diffTroubleshootingSession(apiclt)
			break
		}

		logger.Warnf("Failed to connect to gRPC server [%s]\n", ct.apisrvURL)
		time.Sleep(time.Second)
	}

	// setup wait group
	ct.waitGrp.Add(1)

	// start a goroutine
	go func() {
		defer ct.waitGrp.Done()
		ct.stats.Counter("TroubleshootingSession_Watch").Inc()
		defer ct.stats.Counter("TroubleshootingSession_Watch").Dec()

		// loop forever
		for {
			// create a grpc client
			apicl, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
			if err != nil {
				logger.Warnf("Failed to connect to gRPC server [%s]\n", ct.apisrvURL)
				ct.stats.Counter("TroubleshootingSession_ApiClientErr").Inc()
			} else {
				logger.Infof("API client connected {%+v}", apicl)

				// TroubleshootingSession object watcher
				wt, werr := apicl.MonitoringV1().TroubleshootingSession().Watch(ctx, opts)
				if werr != nil {
					select {
					case <-ctx.Done():
						logger.Infof("watch %s cancelled", kind)
						return
					default:
					}
					logger.Errorf("Failed to start %s watch (%s)\n", kind, werr)
					// wait for a second and retry connecting to api server
					apicl.Close()
					time.Sleep(time.Second)
					continue
				}
				ct.Lock()
				ct.watchers[kind] = wt
				ct.Unlock()

				// perform a diff with API server and local cache
				// Sleeping to give time for other apiclient's to reconnect
				// before calling reconnect handler
				time.Sleep(time.Second)
				ct.diffTroubleshootingSession(apicl)
				troubleshootingsessionHandler.OnTroubleshootingSessionReconnect()

				// handle api server watch events
			innerLoop:
				for {
					// wait for events
					select {
					case evt, ok := <-wt.EventChan():
						if !ok {
							logger.Error("Error receiving from apisrv watcher")
							ct.stats.Counter("TroubleshootingSession_WatchErrors").Inc()
							break innerLoop
						}

						// handle event in parallel
						ct.handleTroubleshootingSessionEventParallel(evt)
					}
				}
				apicl.Close()
			}

			// if stop flag is set, we are done
			if ct.stoped {
				logger.Infof("Exiting API server watcher")
				return
			}

			// wait for a second and retry connecting to api server
			time.Sleep(time.Second)
		}
	}()
}

// WatchTroubleshootingSession starts watch on TroubleshootingSession object
func (ct *ctrlerCtx) WatchTroubleshootingSession(handler TroubleshootingSessionHandler) error {
	kind := "TroubleshootingSession"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchCancel[kind]
	ct.Unlock()
	if ok {
		return fmt.Errorf("TroubleshootingSession watcher already exists")
	}

	// save handler
	ct.Lock()
	ct.handlers[kind] = handler
	ct.Unlock()

	// run TroubleshootingSession watcher in a go routine
	ct.runTroubleshootingSessionWatcher()

	return nil
}

// StopWatchTroubleshootingSession stops watch on TroubleshootingSession object
func (ct *ctrlerCtx) StopWatchTroubleshootingSession(handler TroubleshootingSessionHandler) error {
	kind := "TroubleshootingSession"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchCancel[kind]
	ct.Unlock()
	if !ok {
		return fmt.Errorf("TroubleshootingSession watcher does not exist")
	}

	ct.Lock()
	cancel, _ := ct.watchCancel[kind]
	cancel()
	if _, ok := ct.watchers[kind]; ok {
		delete(ct.watchers, kind)
	}
	delete(ct.watchCancel, kind)
	ct.Unlock()

	time.Sleep(100 * time.Millisecond)

	return nil
}

// TroubleshootingSessionAPI returns
type TroubleshootingSessionAPI interface {
	Create(obj *monitoring.TroubleshootingSession) error
	SyncCreate(obj *monitoring.TroubleshootingSession) error
	Update(obj *monitoring.TroubleshootingSession) error
	SyncUpdate(obj *monitoring.TroubleshootingSession) error
	Label(obj *api.Label) error
	Delete(obj *monitoring.TroubleshootingSession) error
	Find(meta *api.ObjectMeta) (*TroubleshootingSession, error)
	List(ctx context.Context, opts *api.ListWatchOptions) ([]*TroubleshootingSession, error)
	ApisrvList(ctx context.Context, opts *api.ListWatchOptions) ([]*monitoring.TroubleshootingSession, error)
	Watch(handler TroubleshootingSessionHandler) error
	ClearCache(handler TroubleshootingSessionHandler)
	StopWatch(handler TroubleshootingSessionHandler) error
}

// dummy struct that implements TroubleshootingSessionAPI
type troubleshootingsessionAPI struct {
	ct *ctrlerCtx
}

// Create creates TroubleshootingSession object
func (api *troubleshootingsessionAPI) Create(obj *monitoring.TroubleshootingSession) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.MonitoringV1().TroubleshootingSession().Create(context.Background(), obj)
		if err != nil && strings.Contains(err.Error(), "AlreadyExists") {
			_, err = apicl.MonitoringV1().TroubleshootingSession().Update(context.Background(), obj)

		}
		return err
	}

	api.ct.handleTroubleshootingSessionEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Created})
	return nil
}

// SyncCreate creates TroubleshootingSession object and updates the cache
func (api *troubleshootingsessionAPI) SyncCreate(obj *monitoring.TroubleshootingSession) error {
	newObj := obj
	evtType := kvstore.Created
	var writeErr error
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		newObj, writeErr = apicl.MonitoringV1().TroubleshootingSession().Create(context.Background(), obj)
		if writeErr != nil && strings.Contains(writeErr.Error(), "AlreadyExists") {
			newObj, writeErr = apicl.MonitoringV1().TroubleshootingSession().Update(context.Background(), obj)
			evtType = kvstore.Updated
		}
	}

	if writeErr == nil {
		api.ct.handleTroubleshootingSessionEvent(&kvstore.WatchEvent{Object: newObj, Type: evtType})
	}
	return writeErr
}

// Update triggers update on TroubleshootingSession object
func (api *troubleshootingsessionAPI) Update(obj *monitoring.TroubleshootingSession) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.MonitoringV1().TroubleshootingSession().Update(context.Background(), obj)
		return err
	}

	api.ct.handleTroubleshootingSessionEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Updated})
	return nil
}

// SyncUpdate triggers update on TroubleshootingSession object and updates the cache
func (api *troubleshootingsessionAPI) SyncUpdate(obj *monitoring.TroubleshootingSession) error {
	if api.ct.objResolver != nil {
		log.Fatal("Cannot use Sync update when object resolver is enabled on ctkit")
	}
	newObj := obj
	var writeErr error
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		newObj, writeErr = apicl.MonitoringV1().TroubleshootingSession().Update(context.Background(), obj)
	}

	if writeErr == nil {
		api.ct.handleTroubleshootingSessionEvent(&kvstore.WatchEvent{Object: newObj, Type: kvstore.Updated})
	}

	return writeErr
}

// Label labels TroubleshootingSession object
func (api *troubleshootingsessionAPI) Label(obj *api.Label) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.MonitoringV1().TroubleshootingSession().Label(context.Background(), obj)
		return err
	}

	ctkitObj, err := api.Find(obj.GetObjectMeta())
	if err != nil {
		return err
	}
	writeObj := ctkitObj.TroubleshootingSession
	writeObj.Labels = obj.Labels

	api.ct.handleTroubleshootingSessionEvent(&kvstore.WatchEvent{Object: &writeObj, Type: kvstore.Updated})
	return nil
}

// Delete deletes TroubleshootingSession object
func (api *troubleshootingsessionAPI) Delete(obj *monitoring.TroubleshootingSession) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.MonitoringV1().TroubleshootingSession().Delete(context.Background(), &obj.ObjectMeta)
		return err
	}

	api.ct.handleTroubleshootingSessionEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Deleted})
	return nil
}

// MakeKey generates a KV store key for the object
func (api *troubleshootingsessionAPI) getFullKey(tenant, name string) string {
	if tenant != "" {
		return fmt.Sprint(globals.ConfigRootPrefix, "/", "monitoring", "/", "TroubleshootingSession", "/", tenant, "/", name)
	}
	return fmt.Sprint(globals.ConfigRootPrefix, "/", "monitoring", "/", "TroubleshootingSession", "/", name)
}

// Find returns an object by meta
func (api *troubleshootingsessionAPI) Find(meta *api.ObjectMeta) (*TroubleshootingSession, error) {
	// find the object
	obj, err := api.ct.FindObject("TroubleshootingSession", meta)
	if err != nil {
		return nil, err
	}

	// asset type
	switch obj.(type) {
	case *TroubleshootingSession:
		hobj := obj.(*TroubleshootingSession)
		return hobj, nil
	default:
		return nil, errors.New("incorrect object type")
	}
}

// List returns a list of all TroubleshootingSession objects
func (api *troubleshootingsessionAPI) List(ctx context.Context, opts *api.ListWatchOptions) ([]*TroubleshootingSession, error) {
	var objlist []*TroubleshootingSession
	objs, err := api.ct.List("TroubleshootingSession", ctx, opts)

	if err != nil {
		return nil, err
	}

	for _, obj := range objs {
		switch tp := obj.(type) {
		case *TroubleshootingSession:
			eobj := obj.(*TroubleshootingSession)
			objlist = append(objlist, eobj)
		default:
			log.Fatalf("Got invalid object type %v while looking for TroubleshootingSession", tp)
		}
	}

	return objlist, nil
}

// ApisrvList returns a list of all TroubleshootingSession objects from apiserver
func (api *troubleshootingsessionAPI) ApisrvList(ctx context.Context, opts *api.ListWatchOptions) ([]*monitoring.TroubleshootingSession, error) {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return nil, err
		}

		return apicl.MonitoringV1().TroubleshootingSession().List(context.Background(), opts)
	}

	// List from local cache
	ctkitObjs, err := api.List(ctx, opts)
	if err != nil {
		return nil, err
	}
	var ret []*monitoring.TroubleshootingSession
	for _, obj := range ctkitObjs {
		ret = append(ret, &obj.TroubleshootingSession)
	}
	return ret, nil
}

// Watch sets up a event handlers for TroubleshootingSession object
func (api *troubleshootingsessionAPI) Watch(handler TroubleshootingSessionHandler) error {
	api.ct.startWorkerPool("TroubleshootingSession")
	return api.ct.WatchTroubleshootingSession(handler)
}

// StopWatch stop watch for Tenant TroubleshootingSession object
func (api *troubleshootingsessionAPI) StopWatch(handler TroubleshootingSessionHandler) error {
	api.ct.Lock()
	api.ct.workPools["TroubleshootingSession"].Stop()
	api.ct.Unlock()
	return api.ct.StopWatchTroubleshootingSession(handler)
}

// ClearCache removes all TroubleshootingSession objects in ctkit
func (api *troubleshootingsessionAPI) ClearCache(handler TroubleshootingSessionHandler) {
	api.ct.delKind("TroubleshootingSession")
}

// TroubleshootingSession returns TroubleshootingSessionAPI
func (ct *ctrlerCtx) TroubleshootingSession() TroubleshootingSessionAPI {
	kind := "TroubleshootingSession"
	if _, ok := ct.apiInfMap[kind]; !ok {
		s := &troubleshootingsessionAPI{ct: ct}
		ct.apiInfMap[kind] = s
	}
	return ct.apiInfMap[kind].(*troubleshootingsessionAPI)
}

// TechSupportRequest is a wrapper object that implements additional functionality
type TechSupportRequest struct {
	sync.Mutex
	monitoring.TechSupportRequest
	HandlerCtx interface{} // additional state handlers can store
	ctrler     *ctrlerCtx  // reference back to the controller instance
	internal   bool
}

func (obj *TechSupportRequest) SetInternal() {
	obj.internal = true
}

func (obj *TechSupportRequest) Write() error {
	// if there is no API server to connect to, we are done
	if (obj.ctrler == nil) || (obj.ctrler.resolver == nil) || obj.ctrler.apisrvURL == "" {
		return nil
	}

	apicl, err := obj.ctrler.apiClient()
	if err != nil {
		obj.ctrler.logger.Errorf("Error creating API server clent. Err: %v", err)
		return err
	}

	obj.ctrler.stats.Counter("TechSupportRequest_Writes").Inc()

	// write to api server
	if obj.ObjectMeta.ResourceVersion != "" {
		// update it
		for i := 0; i < maxApisrvWriteRetry; i++ {
			_, err = apicl.MonitoringV1().TechSupportRequest().UpdateStatus(context.Background(), &obj.TechSupportRequest)
			if err == nil {
				break
			}
			time.Sleep(time.Millisecond * 100)
		}
	} else {
		//  create
		_, err = apicl.MonitoringV1().TechSupportRequest().Create(context.Background(), &obj.TechSupportRequest)
	}

	return nil
}

// TechSupportRequestHandler is the event handler for TechSupportRequest object
type TechSupportRequestHandler interface {
	OnTechSupportRequestCreate(obj *TechSupportRequest) error
	OnTechSupportRequestUpdate(oldObj *TechSupportRequest, newObj *monitoring.TechSupportRequest) error
	OnTechSupportRequestDelete(obj *TechSupportRequest) error
	GetTechSupportRequestWatchOptions() *api.ListWatchOptions
	OnTechSupportRequestReconnect()
}

// OnTechSupportRequestCreate is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnTechSupportRequestCreate(obj *TechSupportRequest) error {
	log.Info("OnTechSupportRequestCreate is not implemented")
	return nil
}

// OnTechSupportRequestUpdate is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnTechSupportRequestUpdate(oldObj *TechSupportRequest, newObj *monitoring.TechSupportRequest) error {
	log.Info("OnTechSupportRequestUpdate is not implemented")
	return nil
}

// OnTechSupportRequestDelete is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnTechSupportRequestDelete(obj *TechSupportRequest) error {
	log.Info("OnTechSupportRequestDelete is not implemented")
	return nil
}

// GetTechSupportRequestWatchOptions is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) GetTechSupportRequestWatchOptions() *api.ListWatchOptions {
	log.Info("GetTechSupportRequestWatchOptions is not implemented")
	opts := &api.ListWatchOptions{}
	return opts
}

// OnTechSupportRequestReconnect is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnTechSupportRequestReconnect() {
	log.Info("OnTechSupportRequestReconnect is not implemented")
	return
}

// handleTechSupportRequestEvent handles TechSupportRequest events from watcher
func (ct *ctrlerCtx) handleTechSupportRequestEvent(evt *kvstore.WatchEvent) error {

	if ct.objResolver == nil {
		return ct.handleTechSupportRequestEventNoResolver(evt)
	}

	switch tp := evt.Object.(type) {
	case *monitoring.TechSupportRequest:
		eobj := evt.Object.(*monitoring.TechSupportRequest)
		kind := "TechSupportRequest"

		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ctx := &techsupportrequestCtx{event: evt.Type,
			obj: &TechSupportRequest{TechSupportRequest: *eobj, ctrler: ct}}

		var err error
		switch evt.Type {
		case kvstore.Created:
			err = ct.processAdd(ctx)
		case kvstore.Updated:
			err = ct.processUpdate(ctx)
		case kvstore.Deleted:
			err = ct.processDelete(ctx)
		}
		return err
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on TechSupportRequest watch channel", tp)
	}

	return nil
}

// handleTechSupportRequestEventNoResolver handles TechSupportRequest events from watcher
func (ct *ctrlerCtx) handleTechSupportRequestEventNoResolver(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *monitoring.TechSupportRequest:
		eobj := evt.Object.(*monitoring.TechSupportRequest)
		kind := "TechSupportRequest"

		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		techsupportrequestHandler := handler.(TechSupportRequestHandler)
		// handle based on event type
		ctrlCtx := &techsupportrequestCtx{event: evt.Type, obj: &TechSupportRequest{TechSupportRequest: *eobj, ctrler: ct}}
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			fobj, err := ct.getObject(kind, ctrlCtx.GetKey())
			if err != nil {
				ct.addObject(ctrlCtx)
				ct.stats.Counter("TechSupportRequest_Created_Events").Inc()

				// call the event handler
				ctrlCtx.Lock()
				err = techsupportrequestHandler.OnTechSupportRequestCreate(ctrlCtx.obj)
				ctrlCtx.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctrlCtx.obj.GetObjectMeta(), err)
					ct.delObject(kind, ctrlCtx.GetKey())
					return err
				}
			} else {
				fResVer, fErr := strconv.ParseInt(fobj.GetResourceVersion(), 10, 64)
				eResVer, eErr := strconv.ParseInt(eobj.GetResourceVersion(), 10, 64)
				if ct.resolver != nil && fErr == nil && eErr == nil && fResVer >= eResVer {
					// Event already processed.
					ct.logger.Infof("Skipping update due to old resource version")
					return nil
				}
				ctrlCtx := fobj.(*techsupportrequestCtx)
				ct.stats.Counter("TechSupportRequest_Updated_Events").Inc()
				ctrlCtx.Lock()
				p := monitoring.TechSupportRequest{Spec: eobj.Spec,
					ObjectMeta: eobj.ObjectMeta,
					TypeMeta:   eobj.TypeMeta,
					Status:     eobj.Status}

				err = techsupportrequestHandler.OnTechSupportRequestUpdate(ctrlCtx.obj, &p)
				ctrlCtx.obj.TechSupportRequest = *eobj
				ctrlCtx.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctrlCtx.obj.GetObjectMeta(), err)
					return err
				}

			}
		case kvstore.Deleted:
			ctrlCtx := &techsupportrequestCtx{event: evt.Type, obj: &TechSupportRequest{TechSupportRequest: *eobj, ctrler: ct}}
			fobj, err := ct.findObject(kind, ctrlCtx.GetKey())
			if err != nil {
				ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
				return err
			}

			obj := fobj.(*TechSupportRequest)
			ct.stats.Counter("TechSupportRequest_Deleted_Events").Inc()
			obj.Lock()
			err = techsupportrequestHandler.OnTechSupportRequestDelete(obj)
			obj.Unlock()
			if err != nil {
				ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj.GetObjectMeta(), err)
			}
			ct.delObject(kind, ctrlCtx.GetKey())
			return nil

		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on TechSupportRequest watch channel", tp)
	}

	return nil
}

type techsupportrequestCtx struct {
	ctkitBaseCtx
	event kvstore.WatchEventType
	obj   *TechSupportRequest //
	//   newObj     *monitoring.TechSupportRequest //update
	newObj *techsupportrequestCtx //update
}

func (ctx *techsupportrequestCtx) References() map[string]apiintf.ReferenceObj {
	if ctx.references == nil {
		resp := make(map[string]apiintf.ReferenceObj)
		ctx.references = resp
		ctx.obj.References(ctx.obj.GetObjectMeta().Name, ctx.obj.GetObjectMeta().Namespace, resp)
		ctx.obj.ctrler.filterOutRefs(ctx)
	}
	return ctx.references
}

func (ctx *techsupportrequestCtx) GetKey() string {
	return ctx.obj.MakeKey("monitoring")

}

func (ctx *techsupportrequestCtx) IsInternal() bool {
	return ctx.obj.internal
}

func (ctx *techsupportrequestCtx) GetKind() string {
	return ctx.obj.GetKind()
}

func (ctx *techsupportrequestCtx) GetResourceVersion() string {
	return ctx.obj.GetResourceVersion()
}

func (ctx *techsupportrequestCtx) SetEvent(event kvstore.WatchEventType) {
	ctx.event = event
}

func (ctx *techsupportrequestCtx) SetNewObj(newObj apiintf.CtkitObject) {
	if newObj == nil {
		ctx.newObj = nil
	} else {
		ctx.newObj = newObj.(*techsupportrequestCtx)
		ctx.newObj.obj.HandlerCtx = ctx.obj.HandlerCtx
		ctx.references = newObj.References()
	}
}

func (ctx *techsupportrequestCtx) GetNewObj() apiintf.CtkitObject {
	return ctx.newObj
}

func (ctx *techsupportrequestCtx) Copy(obj apiintf.CtkitObject) {
	ctx.obj.TechSupportRequest = obj.(*techsupportrequestCtx).obj.TechSupportRequest
	ctx.SetWatchTs(obj.GetWatchTs())
}

func (ctx *techsupportrequestCtx) Lock() {
	ctx.obj.Lock()
}

func (ctx *techsupportrequestCtx) Unlock() {
	ctx.obj.Unlock()
}

func (ctx *techsupportrequestCtx) GetObjectMeta() *api.ObjectMeta {
	return ctx.obj.GetObjectMeta()
}

func (ctx *techsupportrequestCtx) RuntimeObject() runtime.Object {
	var v interface{}
	v = ctx.obj
	return v.(runtime.Object)
}

func (ctx *techsupportrequestCtx) WorkFunc(context context.Context) error {
	var err error
	evt := ctx.event
	ct := ctx.obj.ctrler
	kind := "TechSupportRequest"
	ct.Lock()
	handler, ok := ct.handlers[kind]
	ct.Unlock()
	if !ok {
		ct.logger.Fatalf("Cant find the handler for %s", kind)
	}
	techsupportrequestHandler := handler.(TechSupportRequestHandler)
	switch evt {
	case kvstore.Created:
		ctx.obj.Lock()
		err = techsupportrequestHandler.OnTechSupportRequestCreate(ctx.obj)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctx.obj.GetObjectMeta(), err)
			ctx.SetEvent(kvstore.Deleted)
		}
	case kvstore.Updated:
		ct.stats.Counter("TechSupportRequest_Updated_Events").Inc()
		ctx.obj.Lock()
		p := monitoring.TechSupportRequest{Spec: ctx.newObj.obj.Spec,
			ObjectMeta: ctx.newObj.obj.ObjectMeta,
			TypeMeta:   ctx.newObj.obj.TypeMeta,
			Status:     ctx.newObj.obj.Status}
		err = techsupportrequestHandler.OnTechSupportRequestUpdate(ctx.obj, &p)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctx.obj.GetObjectMeta(), err)
			ctx.SetEvent(kvstore.Deleted)
		}
	case kvstore.Deleted:
		ctx.obj.Lock()
		err = techsupportrequestHandler.OnTechSupportRequestDelete(ctx.obj)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error deleting %s %+v. Err: %v", kind, ctx.obj.GetObjectMeta(), err)
		}
	}
	ct.resolveObject(ctx.event, ctx)
	return nil
}

// handleTechSupportRequestEventParallel handles TechSupportRequest events from watcher
func (ct *ctrlerCtx) handleTechSupportRequestEventParallel(evt *kvstore.WatchEvent) error {

	if ct.objResolver == nil {
		return ct.handleTechSupportRequestEventParallelWithNoResolver(evt)
	}

	switch tp := evt.Object.(type) {
	case *monitoring.TechSupportRequest:
		eobj := evt.Object.(*monitoring.TechSupportRequest)
		kind := "TechSupportRequest"

		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ctx := &techsupportrequestCtx{event: evt.Type, obj: &TechSupportRequest{TechSupportRequest: *eobj, ctrler: ct}}
		ctx.SetWatchTs(evt.WatchTS)

		var err error
		switch evt.Type {
		case kvstore.Created:
			err = ct.processAdd(ctx)
		case kvstore.Updated:
			err = ct.processUpdate(ctx)
		case kvstore.Deleted:
			err = ct.processDelete(ctx)
		}
		return err
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on TechSupportRequest watch channel", tp)
	}

	return nil
}

// handleTechSupportRequestEventParallel handles TechSupportRequest events from watcher
func (ct *ctrlerCtx) handleTechSupportRequestEventParallelWithNoResolver(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *monitoring.TechSupportRequest:
		eobj := evt.Object.(*monitoring.TechSupportRequest)
		kind := "TechSupportRequest"

		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		techsupportrequestHandler := handler.(TechSupportRequestHandler)
		// handle based on event type
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			workFunc := func(ctx context.Context, ctrlCtx shardworkers.WorkObj) error {
				var err error
				workCtx := ctrlCtx.(*techsupportrequestCtx)
				eobj := workCtx.obj
				fobj, err := ct.getObject(kind, workCtx.GetKey())
				if err != nil {
					ct.addObject(workCtx)
					ct.stats.Counter("TechSupportRequest_Created_Events").Inc()
					eobj.Lock()
					err = techsupportrequestHandler.OnTechSupportRequestCreate(eobj)
					eobj.Unlock()
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, eobj.GetObjectMeta(), err)
						ct.delObject(kind, workCtx.GetKey())
					}
				} else {
					workCtx = fobj.(*techsupportrequestCtx)
					obj := workCtx.obj
					ct.stats.Counter("TechSupportRequest_Updated_Events").Inc()
					obj.Lock()
					p := monitoring.TechSupportRequest{Spec: eobj.Spec,
						ObjectMeta: eobj.ObjectMeta,
						TypeMeta:   eobj.TypeMeta,
						Status:     eobj.Status}

					err = techsupportrequestHandler.OnTechSupportRequestUpdate(obj, &p)
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj.GetObjectMeta(), err)
					} else {
						workCtx.obj.TechSupportRequest = p
					}
					obj.Unlock()
				}
				workCtx.SetWatchTs(evt.WatchTS)
				return err
			}
			ctrlCtx := &techsupportrequestCtx{event: evt.Type, obj: &TechSupportRequest{TechSupportRequest: *eobj, ctrler: ct}}
			ct.runFunction("TechSupportRequest", ctrlCtx, workFunc)
		case kvstore.Deleted:
			workFunc := func(ctx context.Context, ctrlCtx shardworkers.WorkObj) error {
				var err error
				workCtx := ctrlCtx.(*techsupportrequestCtx)
				eobj := workCtx.obj
				fobj, err := ct.findObject(kind, workCtx.GetKey())
				if err != nil {
					ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
					return err
				}
				obj := fobj.(*TechSupportRequest)
				ct.stats.Counter("TechSupportRequest_Deleted_Events").Inc()
				obj.Lock()
				err = techsupportrequestHandler.OnTechSupportRequestDelete(obj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj.GetObjectMeta(), err)
				}
				ct.delObject(kind, workCtx.GetKey())
				return nil
			}
			ctrlCtx := &techsupportrequestCtx{event: evt.Type, obj: &TechSupportRequest{TechSupportRequest: *eobj, ctrler: ct}}
			ct.runFunction("TechSupportRequest", ctrlCtx, workFunc)
		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on TechSupportRequest watch channel", tp)
	}

	return nil
}

// diffTechSupportRequest does a diff of TechSupportRequest objects between local cache and API server
func (ct *ctrlerCtx) diffTechSupportRequest(apicl apiclient.Services) {
	opts := api.ListWatchOptions{}

	// get a list of all objects from API server
	objlist, err := apicl.MonitoringV1().TechSupportRequest().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Errorf("Error getting a list of objects. Err: %v", err)
		return
	}

	ct.logger.Infof("diffTechSupportRequest(): TechSupportRequestList returned %d objects", len(objlist))

	// build an object map
	objmap := make(map[string]*monitoring.TechSupportRequest)
	for _, obj := range objlist {
		objmap[obj.GetKey()] = obj
	}

	list, err := ct.TechSupportRequest().List(context.Background(), &opts)
	if err != nil && !strings.Contains(err.Error(), "not found in local cache") {
		ct.logger.Infof("Failed to get a list of objects. Err: %s", err)
		return
	}

	// if an object is in our local cache and not in API server, trigger delete for it
	for _, obj := range list {
		_, ok := objmap[obj.GetKey()]
		if !ok {
			ct.logger.Infof("diffTechSupportRequest(): Deleting existing object %#v since its not in apiserver", obj.GetKey())
			evt := kvstore.WatchEvent{
				Type:   kvstore.Deleted,
				Key:    obj.GetKey(),
				Object: &obj.TechSupportRequest,
			}
			ct.handleTechSupportRequestEvent(&evt)
		}
	}

	// trigger create event for all others
	for _, obj := range objlist {
		ct.logger.Infof("diffTechSupportRequest(): Adding object %#v", obj.GetKey())
		evt := kvstore.WatchEvent{
			Type:   kvstore.Created,
			Key:    obj.GetKey(),
			Object: obj,
		}
		ct.handleTechSupportRequestEvent(&evt)
	}
}

func (ct *ctrlerCtx) runTechSupportRequestWatcher() {
	kind := "TechSupportRequest"

	ct.Lock()
	handler, ok := ct.handlers[kind]
	ct.Unlock()
	if !ok {
		ct.logger.Fatalf("Cant find the handler for %s", kind)
	}
	techsupportrequestHandler := handler.(TechSupportRequestHandler)

	opts := techsupportrequestHandler.GetTechSupportRequestWatchOptions()

	// if there is no API server to connect to, we are done
	if (ct.resolver == nil) || ct.apisrvURL == "" {
		return
	}

	// create context
	ctx, cancel := context.WithCancel(context.Background())
	ct.Lock()
	ct.watchCancel[kind] = cancel
	ct.Unlock()
	logger := ct.logger.WithContext("submodule", "TechSupportRequestWatcher")
	for {
		if ctx.Err() != nil {
			return
		}

		apiclt, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
		// create a grpc client
		if err == nil {
			// Upon successful connection perform the diff, and start watch goroutine
			ct.diffTechSupportRequest(apiclt)
			break
		}

		logger.Warnf("Failed to connect to gRPC server [%s]\n", ct.apisrvURL)
		time.Sleep(time.Second)
	}

	// setup wait group
	ct.waitGrp.Add(1)

	// start a goroutine
	go func() {
		defer ct.waitGrp.Done()
		ct.stats.Counter("TechSupportRequest_Watch").Inc()
		defer ct.stats.Counter("TechSupportRequest_Watch").Dec()

		// loop forever
		for {
			// create a grpc client
			apicl, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
			if err != nil {
				logger.Warnf("Failed to connect to gRPC server [%s]\n", ct.apisrvURL)
				ct.stats.Counter("TechSupportRequest_ApiClientErr").Inc()
			} else {
				logger.Infof("API client connected {%+v}", apicl)

				// TechSupportRequest object watcher
				wt, werr := apicl.MonitoringV1().TechSupportRequest().Watch(ctx, opts)
				if werr != nil {
					select {
					case <-ctx.Done():
						logger.Infof("watch %s cancelled", kind)
						return
					default:
					}
					logger.Errorf("Failed to start %s watch (%s)\n", kind, werr)
					// wait for a second and retry connecting to api server
					apicl.Close()
					time.Sleep(time.Second)
					continue
				}
				ct.Lock()
				ct.watchers[kind] = wt
				ct.Unlock()

				// perform a diff with API server and local cache
				// Sleeping to give time for other apiclient's to reconnect
				// before calling reconnect handler
				time.Sleep(time.Second)
				ct.diffTechSupportRequest(apicl)
				techsupportrequestHandler.OnTechSupportRequestReconnect()

				// handle api server watch events
			innerLoop:
				for {
					// wait for events
					select {
					case evt, ok := <-wt.EventChan():
						if !ok {
							logger.Error("Error receiving from apisrv watcher")
							ct.stats.Counter("TechSupportRequest_WatchErrors").Inc()
							break innerLoop
						}

						// handle event in parallel
						ct.handleTechSupportRequestEventParallel(evt)
					}
				}
				apicl.Close()
			}

			// if stop flag is set, we are done
			if ct.stoped {
				logger.Infof("Exiting API server watcher")
				return
			}

			// wait for a second and retry connecting to api server
			time.Sleep(time.Second)
		}
	}()
}

// WatchTechSupportRequest starts watch on TechSupportRequest object
func (ct *ctrlerCtx) WatchTechSupportRequest(handler TechSupportRequestHandler) error {
	kind := "TechSupportRequest"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchCancel[kind]
	ct.Unlock()
	if ok {
		return fmt.Errorf("TechSupportRequest watcher already exists")
	}

	// save handler
	ct.Lock()
	ct.handlers[kind] = handler
	ct.Unlock()

	// run TechSupportRequest watcher in a go routine
	ct.runTechSupportRequestWatcher()

	return nil
}

// StopWatchTechSupportRequest stops watch on TechSupportRequest object
func (ct *ctrlerCtx) StopWatchTechSupportRequest(handler TechSupportRequestHandler) error {
	kind := "TechSupportRequest"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchCancel[kind]
	ct.Unlock()
	if !ok {
		return fmt.Errorf("TechSupportRequest watcher does not exist")
	}

	ct.Lock()
	cancel, _ := ct.watchCancel[kind]
	cancel()
	if _, ok := ct.watchers[kind]; ok {
		delete(ct.watchers, kind)
	}
	delete(ct.watchCancel, kind)
	ct.Unlock()

	time.Sleep(100 * time.Millisecond)

	return nil
}

// TechSupportRequestAPI returns
type TechSupportRequestAPI interface {
	Create(obj *monitoring.TechSupportRequest) error
	SyncCreate(obj *monitoring.TechSupportRequest) error
	Update(obj *monitoring.TechSupportRequest) error
	SyncUpdate(obj *monitoring.TechSupportRequest) error
	Label(obj *api.Label) error
	Delete(obj *monitoring.TechSupportRequest) error
	Find(meta *api.ObjectMeta) (*TechSupportRequest, error)
	List(ctx context.Context, opts *api.ListWatchOptions) ([]*TechSupportRequest, error)
	ApisrvList(ctx context.Context, opts *api.ListWatchOptions) ([]*monitoring.TechSupportRequest, error)
	Watch(handler TechSupportRequestHandler) error
	ClearCache(handler TechSupportRequestHandler)
	StopWatch(handler TechSupportRequestHandler) error
}

// dummy struct that implements TechSupportRequestAPI
type techsupportrequestAPI struct {
	ct *ctrlerCtx
}

// Create creates TechSupportRequest object
func (api *techsupportrequestAPI) Create(obj *monitoring.TechSupportRequest) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.MonitoringV1().TechSupportRequest().Create(context.Background(), obj)
		if err != nil && strings.Contains(err.Error(), "AlreadyExists") {
			_, err = apicl.MonitoringV1().TechSupportRequest().Update(context.Background(), obj)

		}
		return err
	}

	api.ct.handleTechSupportRequestEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Created})
	return nil
}

// SyncCreate creates TechSupportRequest object and updates the cache
func (api *techsupportrequestAPI) SyncCreate(obj *monitoring.TechSupportRequest) error {
	newObj := obj
	evtType := kvstore.Created
	var writeErr error
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		newObj, writeErr = apicl.MonitoringV1().TechSupportRequest().Create(context.Background(), obj)
		if writeErr != nil && strings.Contains(writeErr.Error(), "AlreadyExists") {
			newObj, writeErr = apicl.MonitoringV1().TechSupportRequest().Update(context.Background(), obj)
			evtType = kvstore.Updated
		}
	}

	if writeErr == nil {
		api.ct.handleTechSupportRequestEvent(&kvstore.WatchEvent{Object: newObj, Type: evtType})
	}
	return writeErr
}

// Update triggers update on TechSupportRequest object
func (api *techsupportrequestAPI) Update(obj *monitoring.TechSupportRequest) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.MonitoringV1().TechSupportRequest().Update(context.Background(), obj)
		return err
	}

	api.ct.handleTechSupportRequestEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Updated})
	return nil
}

// SyncUpdate triggers update on TechSupportRequest object and updates the cache
func (api *techsupportrequestAPI) SyncUpdate(obj *monitoring.TechSupportRequest) error {
	if api.ct.objResolver != nil {
		log.Fatal("Cannot use Sync update when object resolver is enabled on ctkit")
	}
	newObj := obj
	var writeErr error
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		newObj, writeErr = apicl.MonitoringV1().TechSupportRequest().Update(context.Background(), obj)
	}

	if writeErr == nil {
		api.ct.handleTechSupportRequestEvent(&kvstore.WatchEvent{Object: newObj, Type: kvstore.Updated})
	}

	return writeErr
}

// Label labels TechSupportRequest object
func (api *techsupportrequestAPI) Label(obj *api.Label) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.MonitoringV1().TechSupportRequest().Label(context.Background(), obj)
		return err
	}

	ctkitObj, err := api.Find(obj.GetObjectMeta())
	if err != nil {
		return err
	}
	writeObj := ctkitObj.TechSupportRequest
	writeObj.Labels = obj.Labels

	api.ct.handleTechSupportRequestEvent(&kvstore.WatchEvent{Object: &writeObj, Type: kvstore.Updated})
	return nil
}

// Delete deletes TechSupportRequest object
func (api *techsupportrequestAPI) Delete(obj *monitoring.TechSupportRequest) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.MonitoringV1().TechSupportRequest().Delete(context.Background(), &obj.ObjectMeta)
		return err
	}

	api.ct.handleTechSupportRequestEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Deleted})
	return nil
}

// MakeKey generates a KV store key for the object
func (api *techsupportrequestAPI) getFullKey(tenant, name string) string {
	if tenant != "" {
		return fmt.Sprint(globals.ConfigRootPrefix, "/", "monitoring", "/", "techsupport", "/", tenant, "/", name)
	}
	return fmt.Sprint(globals.ConfigRootPrefix, "/", "monitoring", "/", "techsupport", "/", name)
}

// Find returns an object by meta
func (api *techsupportrequestAPI) Find(meta *api.ObjectMeta) (*TechSupportRequest, error) {
	// find the object
	obj, err := api.ct.FindObject("TechSupportRequest", meta)
	if err != nil {
		return nil, err
	}

	// asset type
	switch obj.(type) {
	case *TechSupportRequest:
		hobj := obj.(*TechSupportRequest)
		return hobj, nil
	default:
		return nil, errors.New("incorrect object type")
	}
}

// List returns a list of all TechSupportRequest objects
func (api *techsupportrequestAPI) List(ctx context.Context, opts *api.ListWatchOptions) ([]*TechSupportRequest, error) {
	var objlist []*TechSupportRequest
	objs, err := api.ct.List("TechSupportRequest", ctx, opts)

	if err != nil {
		return nil, err
	}

	for _, obj := range objs {
		switch tp := obj.(type) {
		case *TechSupportRequest:
			eobj := obj.(*TechSupportRequest)
			objlist = append(objlist, eobj)
		default:
			log.Fatalf("Got invalid object type %v while looking for TechSupportRequest", tp)
		}
	}

	return objlist, nil
}

// ApisrvList returns a list of all TechSupportRequest objects from apiserver
func (api *techsupportrequestAPI) ApisrvList(ctx context.Context, opts *api.ListWatchOptions) ([]*monitoring.TechSupportRequest, error) {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return nil, err
		}

		return apicl.MonitoringV1().TechSupportRequest().List(context.Background(), opts)
	}

	// List from local cache
	ctkitObjs, err := api.List(ctx, opts)
	if err != nil {
		return nil, err
	}
	var ret []*monitoring.TechSupportRequest
	for _, obj := range ctkitObjs {
		ret = append(ret, &obj.TechSupportRequest)
	}
	return ret, nil
}

// Watch sets up a event handlers for TechSupportRequest object
func (api *techsupportrequestAPI) Watch(handler TechSupportRequestHandler) error {
	api.ct.startWorkerPool("TechSupportRequest")
	return api.ct.WatchTechSupportRequest(handler)
}

// StopWatch stop watch for Tenant TechSupportRequest object
func (api *techsupportrequestAPI) StopWatch(handler TechSupportRequestHandler) error {
	api.ct.Lock()
	api.ct.workPools["TechSupportRequest"].Stop()
	api.ct.Unlock()
	return api.ct.StopWatchTechSupportRequest(handler)
}

// ClearCache removes all TechSupportRequest objects in ctkit
func (api *techsupportrequestAPI) ClearCache(handler TechSupportRequestHandler) {
	api.ct.delKind("TechSupportRequest")
}

// TechSupportRequest returns TechSupportRequestAPI
func (ct *ctrlerCtx) TechSupportRequest() TechSupportRequestAPI {
	kind := "TechSupportRequest"
	if _, ok := ct.apiInfMap[kind]; !ok {
		s := &techsupportrequestAPI{ct: ct}
		ct.apiInfMap[kind] = s
	}
	return ct.apiInfMap[kind].(*techsupportrequestAPI)
}

// ArchiveRequest is a wrapper object that implements additional functionality
type ArchiveRequest struct {
	sync.Mutex
	monitoring.ArchiveRequest
	HandlerCtx interface{} // additional state handlers can store
	ctrler     *ctrlerCtx  // reference back to the controller instance
	internal   bool
}

func (obj *ArchiveRequest) SetInternal() {
	obj.internal = true
}

func (obj *ArchiveRequest) Write() error {
	// if there is no API server to connect to, we are done
	if (obj.ctrler == nil) || (obj.ctrler.resolver == nil) || obj.ctrler.apisrvURL == "" {
		return nil
	}

	apicl, err := obj.ctrler.apiClient()
	if err != nil {
		obj.ctrler.logger.Errorf("Error creating API server clent. Err: %v", err)
		return err
	}

	obj.ctrler.stats.Counter("ArchiveRequest_Writes").Inc()

	// write to api server
	if obj.ObjectMeta.ResourceVersion != "" {
		// update it
		for i := 0; i < maxApisrvWriteRetry; i++ {
			_, err = apicl.MonitoringV1().ArchiveRequest().UpdateStatus(context.Background(), &obj.ArchiveRequest)
			if err == nil {
				break
			}
			time.Sleep(time.Millisecond * 100)
		}
	} else {
		//  create
		_, err = apicl.MonitoringV1().ArchiveRequest().Create(context.Background(), &obj.ArchiveRequest)
	}

	return nil
}

// ArchiveRequestHandler is the event handler for ArchiveRequest object
type ArchiveRequestHandler interface {
	OnArchiveRequestCreate(obj *ArchiveRequest) error
	OnArchiveRequestUpdate(oldObj *ArchiveRequest, newObj *monitoring.ArchiveRequest) error
	OnArchiveRequestDelete(obj *ArchiveRequest) error
	GetArchiveRequestWatchOptions() *api.ListWatchOptions
	OnArchiveRequestReconnect()
}

// OnArchiveRequestCreate is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnArchiveRequestCreate(obj *ArchiveRequest) error {
	log.Info("OnArchiveRequestCreate is not implemented")
	return nil
}

// OnArchiveRequestUpdate is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnArchiveRequestUpdate(oldObj *ArchiveRequest, newObj *monitoring.ArchiveRequest) error {
	log.Info("OnArchiveRequestUpdate is not implemented")
	return nil
}

// OnArchiveRequestDelete is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnArchiveRequestDelete(obj *ArchiveRequest) error {
	log.Info("OnArchiveRequestDelete is not implemented")
	return nil
}

// GetArchiveRequestWatchOptions is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) GetArchiveRequestWatchOptions() *api.ListWatchOptions {
	log.Info("GetArchiveRequestWatchOptions is not implemented")
	opts := &api.ListWatchOptions{}
	return opts
}

// OnArchiveRequestReconnect is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnArchiveRequestReconnect() {
	log.Info("OnArchiveRequestReconnect is not implemented")
	return
}

// handleArchiveRequestEvent handles ArchiveRequest events from watcher
func (ct *ctrlerCtx) handleArchiveRequestEvent(evt *kvstore.WatchEvent) error {

	if ct.objResolver == nil {
		return ct.handleArchiveRequestEventNoResolver(evt)
	}

	switch tp := evt.Object.(type) {
	case *monitoring.ArchiveRequest:
		eobj := evt.Object.(*monitoring.ArchiveRequest)
		kind := "ArchiveRequest"

		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ctx := &archiverequestCtx{event: evt.Type,
			obj: &ArchiveRequest{ArchiveRequest: *eobj, ctrler: ct}}

		var err error
		switch evt.Type {
		case kvstore.Created:
			err = ct.processAdd(ctx)
		case kvstore.Updated:
			err = ct.processUpdate(ctx)
		case kvstore.Deleted:
			err = ct.processDelete(ctx)
		}
		return err
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on ArchiveRequest watch channel", tp)
	}

	return nil
}

// handleArchiveRequestEventNoResolver handles ArchiveRequest events from watcher
func (ct *ctrlerCtx) handleArchiveRequestEventNoResolver(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *monitoring.ArchiveRequest:
		eobj := evt.Object.(*monitoring.ArchiveRequest)
		kind := "ArchiveRequest"

		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		archiverequestHandler := handler.(ArchiveRequestHandler)
		// handle based on event type
		ctrlCtx := &archiverequestCtx{event: evt.Type, obj: &ArchiveRequest{ArchiveRequest: *eobj, ctrler: ct}}
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			fobj, err := ct.getObject(kind, ctrlCtx.GetKey())
			if err != nil {
				ct.addObject(ctrlCtx)
				ct.stats.Counter("ArchiveRequest_Created_Events").Inc()

				// call the event handler
				ctrlCtx.Lock()
				err = archiverequestHandler.OnArchiveRequestCreate(ctrlCtx.obj)
				ctrlCtx.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctrlCtx.obj.GetObjectMeta(), err)
					ct.delObject(kind, ctrlCtx.GetKey())
					return err
				}
			} else {
				fResVer, fErr := strconv.ParseInt(fobj.GetResourceVersion(), 10, 64)
				eResVer, eErr := strconv.ParseInt(eobj.GetResourceVersion(), 10, 64)
				if ct.resolver != nil && fErr == nil && eErr == nil && fResVer >= eResVer {
					// Event already processed.
					ct.logger.Infof("Skipping update due to old resource version")
					return nil
				}
				ctrlCtx := fobj.(*archiverequestCtx)
				ct.stats.Counter("ArchiveRequest_Updated_Events").Inc()
				ctrlCtx.Lock()
				p := monitoring.ArchiveRequest{Spec: eobj.Spec,
					ObjectMeta: eobj.ObjectMeta,
					TypeMeta:   eobj.TypeMeta,
					Status:     eobj.Status}

				err = archiverequestHandler.OnArchiveRequestUpdate(ctrlCtx.obj, &p)
				ctrlCtx.obj.ArchiveRequest = *eobj
				ctrlCtx.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctrlCtx.obj.GetObjectMeta(), err)
					return err
				}

			}
		case kvstore.Deleted:
			ctrlCtx := &archiverequestCtx{event: evt.Type, obj: &ArchiveRequest{ArchiveRequest: *eobj, ctrler: ct}}
			fobj, err := ct.findObject(kind, ctrlCtx.GetKey())
			if err != nil {
				ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
				return err
			}

			obj := fobj.(*ArchiveRequest)
			ct.stats.Counter("ArchiveRequest_Deleted_Events").Inc()
			obj.Lock()
			err = archiverequestHandler.OnArchiveRequestDelete(obj)
			obj.Unlock()
			if err != nil {
				ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj.GetObjectMeta(), err)
			}
			ct.delObject(kind, ctrlCtx.GetKey())
			return nil

		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on ArchiveRequest watch channel", tp)
	}

	return nil
}

type archiverequestCtx struct {
	ctkitBaseCtx
	event kvstore.WatchEventType
	obj   *ArchiveRequest //
	//   newObj     *monitoring.ArchiveRequest //update
	newObj *archiverequestCtx //update
}

func (ctx *archiverequestCtx) References() map[string]apiintf.ReferenceObj {
	if ctx.references == nil {
		resp := make(map[string]apiintf.ReferenceObj)
		ctx.references = resp
		ctx.obj.References(ctx.obj.GetObjectMeta().Name, ctx.obj.GetObjectMeta().Namespace, resp)
		ctx.obj.ctrler.filterOutRefs(ctx)
	}
	return ctx.references
}

func (ctx *archiverequestCtx) GetKey() string {
	return ctx.obj.MakeKey("monitoring")

}

func (ctx *archiverequestCtx) IsInternal() bool {
	return ctx.obj.internal
}

func (ctx *archiverequestCtx) GetKind() string {
	return ctx.obj.GetKind()
}

func (ctx *archiverequestCtx) GetResourceVersion() string {
	return ctx.obj.GetResourceVersion()
}

func (ctx *archiverequestCtx) SetEvent(event kvstore.WatchEventType) {
	ctx.event = event
}

func (ctx *archiverequestCtx) SetNewObj(newObj apiintf.CtkitObject) {
	if newObj == nil {
		ctx.newObj = nil
	} else {
		ctx.newObj = newObj.(*archiverequestCtx)
		ctx.newObj.obj.HandlerCtx = ctx.obj.HandlerCtx
		ctx.references = newObj.References()
	}
}

func (ctx *archiverequestCtx) GetNewObj() apiintf.CtkitObject {
	return ctx.newObj
}

func (ctx *archiverequestCtx) Copy(obj apiintf.CtkitObject) {
	ctx.obj.ArchiveRequest = obj.(*archiverequestCtx).obj.ArchiveRequest
	ctx.SetWatchTs(obj.GetWatchTs())
}

func (ctx *archiverequestCtx) Lock() {
	ctx.obj.Lock()
}

func (ctx *archiverequestCtx) Unlock() {
	ctx.obj.Unlock()
}

func (ctx *archiverequestCtx) GetObjectMeta() *api.ObjectMeta {
	return ctx.obj.GetObjectMeta()
}

func (ctx *archiverequestCtx) RuntimeObject() runtime.Object {
	var v interface{}
	v = ctx.obj
	return v.(runtime.Object)
}

func (ctx *archiverequestCtx) WorkFunc(context context.Context) error {
	var err error
	evt := ctx.event
	ct := ctx.obj.ctrler
	kind := "ArchiveRequest"
	ct.Lock()
	handler, ok := ct.handlers[kind]
	ct.Unlock()
	if !ok {
		ct.logger.Fatalf("Cant find the handler for %s", kind)
	}
	archiverequestHandler := handler.(ArchiveRequestHandler)
	switch evt {
	case kvstore.Created:
		ctx.obj.Lock()
		err = archiverequestHandler.OnArchiveRequestCreate(ctx.obj)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctx.obj.GetObjectMeta(), err)
			ctx.SetEvent(kvstore.Deleted)
		}
	case kvstore.Updated:
		ct.stats.Counter("ArchiveRequest_Updated_Events").Inc()
		ctx.obj.Lock()
		p := monitoring.ArchiveRequest{Spec: ctx.newObj.obj.Spec,
			ObjectMeta: ctx.newObj.obj.ObjectMeta,
			TypeMeta:   ctx.newObj.obj.TypeMeta,
			Status:     ctx.newObj.obj.Status}
		err = archiverequestHandler.OnArchiveRequestUpdate(ctx.obj, &p)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctx.obj.GetObjectMeta(), err)
			ctx.SetEvent(kvstore.Deleted)
		}
	case kvstore.Deleted:
		ctx.obj.Lock()
		err = archiverequestHandler.OnArchiveRequestDelete(ctx.obj)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error deleting %s %+v. Err: %v", kind, ctx.obj.GetObjectMeta(), err)
		}
	}
	ct.resolveObject(ctx.event, ctx)
	return nil
}

// handleArchiveRequestEventParallel handles ArchiveRequest events from watcher
func (ct *ctrlerCtx) handleArchiveRequestEventParallel(evt *kvstore.WatchEvent) error {

	if ct.objResolver == nil {
		return ct.handleArchiveRequestEventParallelWithNoResolver(evt)
	}

	switch tp := evt.Object.(type) {
	case *monitoring.ArchiveRequest:
		eobj := evt.Object.(*monitoring.ArchiveRequest)
		kind := "ArchiveRequest"

		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ctx := &archiverequestCtx{event: evt.Type, obj: &ArchiveRequest{ArchiveRequest: *eobj, ctrler: ct}}
		ctx.SetWatchTs(evt.WatchTS)

		var err error
		switch evt.Type {
		case kvstore.Created:
			err = ct.processAdd(ctx)
		case kvstore.Updated:
			err = ct.processUpdate(ctx)
		case kvstore.Deleted:
			err = ct.processDelete(ctx)
		}
		return err
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on ArchiveRequest watch channel", tp)
	}

	return nil
}

// handleArchiveRequestEventParallel handles ArchiveRequest events from watcher
func (ct *ctrlerCtx) handleArchiveRequestEventParallelWithNoResolver(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *monitoring.ArchiveRequest:
		eobj := evt.Object.(*monitoring.ArchiveRequest)
		kind := "ArchiveRequest"

		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		archiverequestHandler := handler.(ArchiveRequestHandler)
		// handle based on event type
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			workFunc := func(ctx context.Context, ctrlCtx shardworkers.WorkObj) error {
				var err error
				workCtx := ctrlCtx.(*archiverequestCtx)
				eobj := workCtx.obj
				fobj, err := ct.getObject(kind, workCtx.GetKey())
				if err != nil {
					ct.addObject(workCtx)
					ct.stats.Counter("ArchiveRequest_Created_Events").Inc()
					eobj.Lock()
					err = archiverequestHandler.OnArchiveRequestCreate(eobj)
					eobj.Unlock()
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, eobj.GetObjectMeta(), err)
						ct.delObject(kind, workCtx.GetKey())
					}
				} else {
					workCtx = fobj.(*archiverequestCtx)
					obj := workCtx.obj
					ct.stats.Counter("ArchiveRequest_Updated_Events").Inc()
					obj.Lock()
					p := monitoring.ArchiveRequest{Spec: eobj.Spec,
						ObjectMeta: eobj.ObjectMeta,
						TypeMeta:   eobj.TypeMeta,
						Status:     eobj.Status}

					err = archiverequestHandler.OnArchiveRequestUpdate(obj, &p)
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj.GetObjectMeta(), err)
					} else {
						workCtx.obj.ArchiveRequest = p
					}
					obj.Unlock()
				}
				workCtx.SetWatchTs(evt.WatchTS)
				return err
			}
			ctrlCtx := &archiverequestCtx{event: evt.Type, obj: &ArchiveRequest{ArchiveRequest: *eobj, ctrler: ct}}
			ct.runFunction("ArchiveRequest", ctrlCtx, workFunc)
		case kvstore.Deleted:
			workFunc := func(ctx context.Context, ctrlCtx shardworkers.WorkObj) error {
				var err error
				workCtx := ctrlCtx.(*archiverequestCtx)
				eobj := workCtx.obj
				fobj, err := ct.findObject(kind, workCtx.GetKey())
				if err != nil {
					ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
					return err
				}
				obj := fobj.(*ArchiveRequest)
				ct.stats.Counter("ArchiveRequest_Deleted_Events").Inc()
				obj.Lock()
				err = archiverequestHandler.OnArchiveRequestDelete(obj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj.GetObjectMeta(), err)
				}
				ct.delObject(kind, workCtx.GetKey())
				return nil
			}
			ctrlCtx := &archiverequestCtx{event: evt.Type, obj: &ArchiveRequest{ArchiveRequest: *eobj, ctrler: ct}}
			ct.runFunction("ArchiveRequest", ctrlCtx, workFunc)
		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on ArchiveRequest watch channel", tp)
	}

	return nil
}

// diffArchiveRequest does a diff of ArchiveRequest objects between local cache and API server
func (ct *ctrlerCtx) diffArchiveRequest(apicl apiclient.Services) {
	opts := api.ListWatchOptions{}

	// get a list of all objects from API server
	objlist, err := apicl.MonitoringV1().ArchiveRequest().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Errorf("Error getting a list of objects. Err: %v", err)
		return
	}

	ct.logger.Infof("diffArchiveRequest(): ArchiveRequestList returned %d objects", len(objlist))

	// build an object map
	objmap := make(map[string]*monitoring.ArchiveRequest)
	for _, obj := range objlist {
		objmap[obj.GetKey()] = obj
	}

	list, err := ct.ArchiveRequest().List(context.Background(), &opts)
	if err != nil && !strings.Contains(err.Error(), "not found in local cache") {
		ct.logger.Infof("Failed to get a list of objects. Err: %s", err)
		return
	}

	// if an object is in our local cache and not in API server, trigger delete for it
	for _, obj := range list {
		_, ok := objmap[obj.GetKey()]
		if !ok {
			ct.logger.Infof("diffArchiveRequest(): Deleting existing object %#v since its not in apiserver", obj.GetKey())
			evt := kvstore.WatchEvent{
				Type:   kvstore.Deleted,
				Key:    obj.GetKey(),
				Object: &obj.ArchiveRequest,
			}
			ct.handleArchiveRequestEvent(&evt)
		}
	}

	// trigger create event for all others
	for _, obj := range objlist {
		ct.logger.Infof("diffArchiveRequest(): Adding object %#v", obj.GetKey())
		evt := kvstore.WatchEvent{
			Type:   kvstore.Created,
			Key:    obj.GetKey(),
			Object: obj,
		}
		ct.handleArchiveRequestEvent(&evt)
	}
}

func (ct *ctrlerCtx) runArchiveRequestWatcher() {
	kind := "ArchiveRequest"

	ct.Lock()
	handler, ok := ct.handlers[kind]
	ct.Unlock()
	if !ok {
		ct.logger.Fatalf("Cant find the handler for %s", kind)
	}
	archiverequestHandler := handler.(ArchiveRequestHandler)

	opts := archiverequestHandler.GetArchiveRequestWatchOptions()

	// if there is no API server to connect to, we are done
	if (ct.resolver == nil) || ct.apisrvURL == "" {
		return
	}

	// create context
	ctx, cancel := context.WithCancel(context.Background())
	ct.Lock()
	ct.watchCancel[kind] = cancel
	ct.Unlock()
	logger := ct.logger.WithContext("submodule", "ArchiveRequestWatcher")
	for {
		if ctx.Err() != nil {
			return
		}

		apiclt, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
		// create a grpc client
		if err == nil {
			// Upon successful connection perform the diff, and start watch goroutine
			ct.diffArchiveRequest(apiclt)
			break
		}

		logger.Warnf("Failed to connect to gRPC server [%s]\n", ct.apisrvURL)
		time.Sleep(time.Second)
	}

	// setup wait group
	ct.waitGrp.Add(1)

	// start a goroutine
	go func() {
		defer ct.waitGrp.Done()
		ct.stats.Counter("ArchiveRequest_Watch").Inc()
		defer ct.stats.Counter("ArchiveRequest_Watch").Dec()

		// loop forever
		for {
			// create a grpc client
			apicl, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
			if err != nil {
				logger.Warnf("Failed to connect to gRPC server [%s]\n", ct.apisrvURL)
				ct.stats.Counter("ArchiveRequest_ApiClientErr").Inc()
			} else {
				logger.Infof("API client connected {%+v}", apicl)

				// ArchiveRequest object watcher
				wt, werr := apicl.MonitoringV1().ArchiveRequest().Watch(ctx, opts)
				if werr != nil {
					select {
					case <-ctx.Done():
						logger.Infof("watch %s cancelled", kind)
						return
					default:
					}
					logger.Errorf("Failed to start %s watch (%s)\n", kind, werr)
					// wait for a second and retry connecting to api server
					apicl.Close()
					time.Sleep(time.Second)
					continue
				}
				ct.Lock()
				ct.watchers[kind] = wt
				ct.Unlock()

				// perform a diff with API server and local cache
				// Sleeping to give time for other apiclient's to reconnect
				// before calling reconnect handler
				time.Sleep(time.Second)
				ct.diffArchiveRequest(apicl)
				archiverequestHandler.OnArchiveRequestReconnect()

				// handle api server watch events
			innerLoop:
				for {
					// wait for events
					select {
					case evt, ok := <-wt.EventChan():
						if !ok {
							logger.Error("Error receiving from apisrv watcher")
							ct.stats.Counter("ArchiveRequest_WatchErrors").Inc()
							break innerLoop
						}

						// handle event in parallel
						ct.handleArchiveRequestEventParallel(evt)
					}
				}
				apicl.Close()
			}

			// if stop flag is set, we are done
			if ct.stoped {
				logger.Infof("Exiting API server watcher")
				return
			}

			// wait for a second and retry connecting to api server
			time.Sleep(time.Second)
		}
	}()
}

// WatchArchiveRequest starts watch on ArchiveRequest object
func (ct *ctrlerCtx) WatchArchiveRequest(handler ArchiveRequestHandler) error {
	kind := "ArchiveRequest"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchCancel[kind]
	ct.Unlock()
	if ok {
		return fmt.Errorf("ArchiveRequest watcher already exists")
	}

	// save handler
	ct.Lock()
	ct.handlers[kind] = handler
	ct.Unlock()

	// run ArchiveRequest watcher in a go routine
	ct.runArchiveRequestWatcher()

	return nil
}

// StopWatchArchiveRequest stops watch on ArchiveRequest object
func (ct *ctrlerCtx) StopWatchArchiveRequest(handler ArchiveRequestHandler) error {
	kind := "ArchiveRequest"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchCancel[kind]
	ct.Unlock()
	if !ok {
		return fmt.Errorf("ArchiveRequest watcher does not exist")
	}

	ct.Lock()
	cancel, _ := ct.watchCancel[kind]
	cancel()
	if _, ok := ct.watchers[kind]; ok {
		delete(ct.watchers, kind)
	}
	delete(ct.watchCancel, kind)
	ct.Unlock()

	time.Sleep(100 * time.Millisecond)

	return nil
}

// ArchiveRequestAPI returns
type ArchiveRequestAPI interface {
	Create(obj *monitoring.ArchiveRequest) error
	SyncCreate(obj *monitoring.ArchiveRequest) error
	Update(obj *monitoring.ArchiveRequest) error
	SyncUpdate(obj *monitoring.ArchiveRequest) error
	Label(obj *api.Label) error
	Delete(obj *monitoring.ArchiveRequest) error
	Find(meta *api.ObjectMeta) (*ArchiveRequest, error)
	List(ctx context.Context, opts *api.ListWatchOptions) ([]*ArchiveRequest, error)
	ApisrvList(ctx context.Context, opts *api.ListWatchOptions) ([]*monitoring.ArchiveRequest, error)
	Watch(handler ArchiveRequestHandler) error
	ClearCache(handler ArchiveRequestHandler)
	StopWatch(handler ArchiveRequestHandler) error
	Cancel(obj *monitoring.CancelArchiveRequest) (*monitoring.ArchiveRequest, error)
	RegisterLocalCancelHandler(fn func(*monitoring.CancelArchiveRequest) (*monitoring.ArchiveRequest, error))
	SyncCancel(obj *monitoring.CancelArchiveRequest) (*monitoring.ArchiveRequest, error)
	RegisterLocalSyncCancelHandler(fn func(*monitoring.CancelArchiveRequest) (*monitoring.ArchiveRequest, error))
}

// dummy struct that implements ArchiveRequestAPI
type archiverequestAPI struct {
	ct *ctrlerCtx

	localCancelHandler     func(obj *monitoring.CancelArchiveRequest) (*monitoring.ArchiveRequest, error)
	localSyncCancelHandler func(obj *monitoring.CancelArchiveRequest) (*monitoring.ArchiveRequest, error)
}

// Create creates ArchiveRequest object
func (api *archiverequestAPI) Create(obj *monitoring.ArchiveRequest) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.MonitoringV1().ArchiveRequest().Create(context.Background(), obj)
		if err != nil && strings.Contains(err.Error(), "AlreadyExists") {
			_, err = apicl.MonitoringV1().ArchiveRequest().Update(context.Background(), obj)

		}
		return err
	}

	api.ct.handleArchiveRequestEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Created})
	return nil
}

// SyncCreate creates ArchiveRequest object and updates the cache
func (api *archiverequestAPI) SyncCreate(obj *monitoring.ArchiveRequest) error {
	newObj := obj
	evtType := kvstore.Created
	var writeErr error
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		newObj, writeErr = apicl.MonitoringV1().ArchiveRequest().Create(context.Background(), obj)
		if writeErr != nil && strings.Contains(writeErr.Error(), "AlreadyExists") {
			newObj, writeErr = apicl.MonitoringV1().ArchiveRequest().Update(context.Background(), obj)
			evtType = kvstore.Updated
		}
	}

	if writeErr == nil {
		api.ct.handleArchiveRequestEvent(&kvstore.WatchEvent{Object: newObj, Type: evtType})
	}
	return writeErr
}

// Update triggers update on ArchiveRequest object
func (api *archiverequestAPI) Update(obj *monitoring.ArchiveRequest) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.MonitoringV1().ArchiveRequest().Update(context.Background(), obj)
		return err
	}

	api.ct.handleArchiveRequestEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Updated})
	return nil
}

// SyncUpdate triggers update on ArchiveRequest object and updates the cache
func (api *archiverequestAPI) SyncUpdate(obj *monitoring.ArchiveRequest) error {
	if api.ct.objResolver != nil {
		log.Fatal("Cannot use Sync update when object resolver is enabled on ctkit")
	}
	newObj := obj
	var writeErr error
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		newObj, writeErr = apicl.MonitoringV1().ArchiveRequest().Update(context.Background(), obj)
	}

	if writeErr == nil {
		api.ct.handleArchiveRequestEvent(&kvstore.WatchEvent{Object: newObj, Type: kvstore.Updated})
	}

	return writeErr
}

// Label labels ArchiveRequest object
func (api *archiverequestAPI) Label(obj *api.Label) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.MonitoringV1().ArchiveRequest().Label(context.Background(), obj)
		return err
	}

	ctkitObj, err := api.Find(obj.GetObjectMeta())
	if err != nil {
		return err
	}
	writeObj := ctkitObj.ArchiveRequest
	writeObj.Labels = obj.Labels

	api.ct.handleArchiveRequestEvent(&kvstore.WatchEvent{Object: &writeObj, Type: kvstore.Updated})
	return nil
}

// Delete deletes ArchiveRequest object
func (api *archiverequestAPI) Delete(obj *monitoring.ArchiveRequest) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.MonitoringV1().ArchiveRequest().Delete(context.Background(), &obj.ObjectMeta)
		return err
	}

	api.ct.handleArchiveRequestEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Deleted})
	return nil
}

// MakeKey generates a KV store key for the object
func (api *archiverequestAPI) getFullKey(tenant, name string) string {
	if tenant != "" {
		return fmt.Sprint(globals.ConfigRootPrefix, "/", "monitoring", "/", "archive-requests", "/", tenant, "/", name)
	}
	return fmt.Sprint(globals.ConfigRootPrefix, "/", "monitoring", "/", "archive-requests", "/", name)
}

// Find returns an object by meta
func (api *archiverequestAPI) Find(meta *api.ObjectMeta) (*ArchiveRequest, error) {
	// find the object
	obj, err := api.ct.FindObject("ArchiveRequest", meta)
	if err != nil {
		return nil, err
	}

	// asset type
	switch obj.(type) {
	case *ArchiveRequest:
		hobj := obj.(*ArchiveRequest)
		return hobj, nil
	default:
		return nil, errors.New("incorrect object type")
	}
}

// List returns a list of all ArchiveRequest objects
func (api *archiverequestAPI) List(ctx context.Context, opts *api.ListWatchOptions) ([]*ArchiveRequest, error) {
	var objlist []*ArchiveRequest
	objs, err := api.ct.List("ArchiveRequest", ctx, opts)

	if err != nil {
		return nil, err
	}

	for _, obj := range objs {
		switch tp := obj.(type) {
		case *ArchiveRequest:
			eobj := obj.(*ArchiveRequest)
			objlist = append(objlist, eobj)
		default:
			log.Fatalf("Got invalid object type %v while looking for ArchiveRequest", tp)
		}
	}

	return objlist, nil
}

// ApisrvList returns a list of all ArchiveRequest objects from apiserver
func (api *archiverequestAPI) ApisrvList(ctx context.Context, opts *api.ListWatchOptions) ([]*monitoring.ArchiveRequest, error) {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return nil, err
		}

		return apicl.MonitoringV1().ArchiveRequest().List(context.Background(), opts)
	}

	// List from local cache
	ctkitObjs, err := api.List(ctx, opts)
	if err != nil {
		return nil, err
	}
	var ret []*monitoring.ArchiveRequest
	for _, obj := range ctkitObjs {
		ret = append(ret, &obj.ArchiveRequest)
	}
	return ret, nil
}

// Watch sets up a event handlers for ArchiveRequest object
func (api *archiverequestAPI) Watch(handler ArchiveRequestHandler) error {
	api.ct.startWorkerPool("ArchiveRequest")
	return api.ct.WatchArchiveRequest(handler)
}

// StopWatch stop watch for Tenant ArchiveRequest object
func (api *archiverequestAPI) StopWatch(handler ArchiveRequestHandler) error {
	api.ct.Lock()
	api.ct.workPools["ArchiveRequest"].Stop()
	api.ct.Unlock()
	return api.ct.StopWatchArchiveRequest(handler)
}

// ClearCache removes all ArchiveRequest objects in ctkit
func (api *archiverequestAPI) ClearCache(handler ArchiveRequestHandler) {
	api.ct.delKind("ArchiveRequest")
}

// Cancel is an API action
func (api *archiverequestAPI) Cancel(obj *monitoring.CancelArchiveRequest) (*monitoring.ArchiveRequest, error) {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return nil, err
		}

		return apicl.MonitoringV1().ArchiveRequest().Cancel(context.Background(), obj)
	}
	if api.localCancelHandler != nil {
		return api.localCancelHandler(obj)
	}
	return nil, fmt.Errorf("Action not implemented for local operation")
}

// SyncCancel is an API action. Cache will be updated
func (api *archiverequestAPI) SyncCancel(obj *monitoring.CancelArchiveRequest) (*monitoring.ArchiveRequest, error) {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return nil, err
		}

		ret, err := apicl.MonitoringV1().ArchiveRequest().Cancel(context.Background(), obj)
		if err != nil {
			return ret, err
		}
		// Perform Get to update the cache
		newObj, err := apicl.MonitoringV1().ArchiveRequest().Get(context.Background(), obj.GetObjectMeta())
		if err == nil {
			api.ct.handleArchiveRequestEvent(&kvstore.WatchEvent{Object: newObj, Type: kvstore.Updated})
		}
		return ret, err
	}
	if api.localSyncCancelHandler != nil {
		return api.localSyncCancelHandler(obj)
	}
	return nil, fmt.Errorf("Action not implemented for local operation")
}

func (api *archiverequestAPI) RegisterLocalCancelHandler(fn func(*monitoring.CancelArchiveRequest) (*monitoring.ArchiveRequest, error)) {
	api.localCancelHandler = fn
}

func (api *archiverequestAPI) RegisterLocalSyncCancelHandler(fn func(*monitoring.CancelArchiveRequest) (*monitoring.ArchiveRequest, error)) {
	api.localSyncCancelHandler = fn
}

// ArchiveRequest returns ArchiveRequestAPI
func (ct *ctrlerCtx) ArchiveRequest() ArchiveRequestAPI {
	kind := "ArchiveRequest"
	if _, ok := ct.apiInfMap[kind]; !ok {
		s := &archiverequestAPI{ct: ct}
		ct.apiInfMap[kind] = s
	}
	return ct.apiInfMap[kind].(*archiverequestAPI)
}

// AuditPolicy is a wrapper object that implements additional functionality
type AuditPolicy struct {
	sync.Mutex
	monitoring.AuditPolicy
	HandlerCtx interface{} // additional state handlers can store
	ctrler     *ctrlerCtx  // reference back to the controller instance
	internal   bool
}

func (obj *AuditPolicy) SetInternal() {
	obj.internal = true
}

func (obj *AuditPolicy) Write() error {
	// if there is no API server to connect to, we are done
	if (obj.ctrler == nil) || (obj.ctrler.resolver == nil) || obj.ctrler.apisrvURL == "" {
		return nil
	}

	apicl, err := obj.ctrler.apiClient()
	if err != nil {
		obj.ctrler.logger.Errorf("Error creating API server clent. Err: %v", err)
		return err
	}

	obj.ctrler.stats.Counter("AuditPolicy_Writes").Inc()

	// write to api server
	if obj.ObjectMeta.ResourceVersion != "" {
		// update it
		for i := 0; i < maxApisrvWriteRetry; i++ {
			_, err = apicl.MonitoringV1().AuditPolicy().UpdateStatus(context.Background(), &obj.AuditPolicy)
			if err == nil {
				break
			}
			time.Sleep(time.Millisecond * 100)
		}
	} else {
		//  create
		_, err = apicl.MonitoringV1().AuditPolicy().Create(context.Background(), &obj.AuditPolicy)
	}

	return nil
}

// AuditPolicyHandler is the event handler for AuditPolicy object
type AuditPolicyHandler interface {
	OnAuditPolicyCreate(obj *AuditPolicy) error
	OnAuditPolicyUpdate(oldObj *AuditPolicy, newObj *monitoring.AuditPolicy) error
	OnAuditPolicyDelete(obj *AuditPolicy) error
	GetAuditPolicyWatchOptions() *api.ListWatchOptions
	OnAuditPolicyReconnect()
}

// OnAuditPolicyCreate is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnAuditPolicyCreate(obj *AuditPolicy) error {
	log.Info("OnAuditPolicyCreate is not implemented")
	return nil
}

// OnAuditPolicyUpdate is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnAuditPolicyUpdate(oldObj *AuditPolicy, newObj *monitoring.AuditPolicy) error {
	log.Info("OnAuditPolicyUpdate is not implemented")
	return nil
}

// OnAuditPolicyDelete is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnAuditPolicyDelete(obj *AuditPolicy) error {
	log.Info("OnAuditPolicyDelete is not implemented")
	return nil
}

// GetAuditPolicyWatchOptions is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) GetAuditPolicyWatchOptions() *api.ListWatchOptions {
	log.Info("GetAuditPolicyWatchOptions is not implemented")
	opts := &api.ListWatchOptions{}
	return opts
}

// OnAuditPolicyReconnect is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnAuditPolicyReconnect() {
	log.Info("OnAuditPolicyReconnect is not implemented")
	return
}

// handleAuditPolicyEvent handles AuditPolicy events from watcher
func (ct *ctrlerCtx) handleAuditPolicyEvent(evt *kvstore.WatchEvent) error {

	if ct.objResolver == nil {
		return ct.handleAuditPolicyEventNoResolver(evt)
	}

	switch tp := evt.Object.(type) {
	case *monitoring.AuditPolicy:
		eobj := evt.Object.(*monitoring.AuditPolicy)
		kind := "AuditPolicy"

		eobj.ApplyStorageTransformer(context.Background(), true /*encrypt*/)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		eobj.ApplyStorageTransformer(context.Background(), false /*decrypt*/)

		ctx := &auditpolicyCtx{event: evt.Type,
			obj: &AuditPolicy{AuditPolicy: *eobj, ctrler: ct}}

		var err error
		switch evt.Type {
		case kvstore.Created:
			err = ct.processAdd(ctx)
		case kvstore.Updated:
			err = ct.processUpdate(ctx)
		case kvstore.Deleted:
			err = ct.processDelete(ctx)
		}
		return err
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on AuditPolicy watch channel", tp)
	}

	return nil
}

// handleAuditPolicyEventNoResolver handles AuditPolicy events from watcher
func (ct *ctrlerCtx) handleAuditPolicyEventNoResolver(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *monitoring.AuditPolicy:
		eobj := evt.Object.(*monitoring.AuditPolicy)
		kind := "AuditPolicy"

		eobj.ApplyStorageTransformer(context.Background(), true /*encrypt*/)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		eobj.ApplyStorageTransformer(context.Background(), false /*decrypt*/)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		auditpolicyHandler := handler.(AuditPolicyHandler)
		// handle based on event type
		ctrlCtx := &auditpolicyCtx{event: evt.Type, obj: &AuditPolicy{AuditPolicy: *eobj, ctrler: ct}}
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			fobj, err := ct.getObject(kind, ctrlCtx.GetKey())
			if err != nil {
				ct.addObject(ctrlCtx)
				ct.stats.Counter("AuditPolicy_Created_Events").Inc()

				// call the event handler
				ctrlCtx.Lock()
				err = auditpolicyHandler.OnAuditPolicyCreate(ctrlCtx.obj)
				ctrlCtx.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctrlCtx.obj.GetObjectMeta(), err)
					ct.delObject(kind, ctrlCtx.GetKey())
					return err
				}
			} else {
				fResVer, fErr := strconv.ParseInt(fobj.GetResourceVersion(), 10, 64)
				eResVer, eErr := strconv.ParseInt(eobj.GetResourceVersion(), 10, 64)
				if ct.resolver != nil && fErr == nil && eErr == nil && fResVer >= eResVer {
					// Event already processed.
					ct.logger.Infof("Skipping update due to old resource version")
					return nil
				}
				ctrlCtx := fobj.(*auditpolicyCtx)
				ct.stats.Counter("AuditPolicy_Updated_Events").Inc()
				ctrlCtx.Lock()
				p := monitoring.AuditPolicy{Spec: eobj.Spec,
					ObjectMeta: eobj.ObjectMeta,
					TypeMeta:   eobj.TypeMeta,
					Status:     eobj.Status}

				err = auditpolicyHandler.OnAuditPolicyUpdate(ctrlCtx.obj, &p)
				ctrlCtx.obj.AuditPolicy = *eobj
				ctrlCtx.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctrlCtx.obj.GetObjectMeta(), err)
					return err
				}

			}
		case kvstore.Deleted:
			ctrlCtx := &auditpolicyCtx{event: evt.Type, obj: &AuditPolicy{AuditPolicy: *eobj, ctrler: ct}}
			fobj, err := ct.findObject(kind, ctrlCtx.GetKey())
			if err != nil {
				ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
				return err
			}

			obj := fobj.(*AuditPolicy)
			ct.stats.Counter("AuditPolicy_Deleted_Events").Inc()
			obj.Lock()
			err = auditpolicyHandler.OnAuditPolicyDelete(obj)
			obj.Unlock()
			if err != nil {
				ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj.GetObjectMeta(), err)
			}
			ct.delObject(kind, ctrlCtx.GetKey())
			return nil

		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on AuditPolicy watch channel", tp)
	}

	return nil
}

type auditpolicyCtx struct {
	ctkitBaseCtx
	event kvstore.WatchEventType
	obj   *AuditPolicy //
	//   newObj     *monitoring.AuditPolicy //update
	newObj *auditpolicyCtx //update
}

func (ctx *auditpolicyCtx) References() map[string]apiintf.ReferenceObj {
	if ctx.references == nil {
		resp := make(map[string]apiintf.ReferenceObj)
		ctx.references = resp
		ctx.obj.References(ctx.obj.GetObjectMeta().Name, ctx.obj.GetObjectMeta().Namespace, resp)
		ctx.obj.ctrler.filterOutRefs(ctx)
	}
	return ctx.references
}

func (ctx *auditpolicyCtx) GetKey() string {
	return ctx.obj.MakeKey("monitoring")

}

func (ctx *auditpolicyCtx) IsInternal() bool {
	return ctx.obj.internal
}

func (ctx *auditpolicyCtx) GetKind() string {
	return ctx.obj.GetKind()
}

func (ctx *auditpolicyCtx) GetResourceVersion() string {
	return ctx.obj.GetResourceVersion()
}

func (ctx *auditpolicyCtx) SetEvent(event kvstore.WatchEventType) {
	ctx.event = event
}

func (ctx *auditpolicyCtx) SetNewObj(newObj apiintf.CtkitObject) {
	if newObj == nil {
		ctx.newObj = nil
	} else {
		ctx.newObj = newObj.(*auditpolicyCtx)
		ctx.newObj.obj.HandlerCtx = ctx.obj.HandlerCtx
		ctx.references = newObj.References()
	}
}

func (ctx *auditpolicyCtx) GetNewObj() apiintf.CtkitObject {
	return ctx.newObj
}

func (ctx *auditpolicyCtx) Copy(obj apiintf.CtkitObject) {
	ctx.obj.AuditPolicy = obj.(*auditpolicyCtx).obj.AuditPolicy
	ctx.SetWatchTs(obj.GetWatchTs())
}

func (ctx *auditpolicyCtx) Lock() {
	ctx.obj.Lock()
}

func (ctx *auditpolicyCtx) Unlock() {
	ctx.obj.Unlock()
}

func (ctx *auditpolicyCtx) GetObjectMeta() *api.ObjectMeta {
	return ctx.obj.GetObjectMeta()
}

func (ctx *auditpolicyCtx) RuntimeObject() runtime.Object {
	var v interface{}
	v = ctx.obj
	return v.(runtime.Object)
}

func (ctx *auditpolicyCtx) WorkFunc(context context.Context) error {
	var err error
	evt := ctx.event
	ct := ctx.obj.ctrler
	kind := "AuditPolicy"
	ct.Lock()
	handler, ok := ct.handlers[kind]
	ct.Unlock()
	if !ok {
		ct.logger.Fatalf("Cant find the handler for %s", kind)
	}
	auditpolicyHandler := handler.(AuditPolicyHandler)
	switch evt {
	case kvstore.Created:
		ctx.obj.Lock()
		err = auditpolicyHandler.OnAuditPolicyCreate(ctx.obj)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctx.obj.GetObjectMeta(), err)
			ctx.SetEvent(kvstore.Deleted)
		}
	case kvstore.Updated:
		ct.stats.Counter("AuditPolicy_Updated_Events").Inc()
		ctx.obj.Lock()
		p := monitoring.AuditPolicy{Spec: ctx.newObj.obj.Spec,
			ObjectMeta: ctx.newObj.obj.ObjectMeta,
			TypeMeta:   ctx.newObj.obj.TypeMeta,
			Status:     ctx.newObj.obj.Status}
		err = auditpolicyHandler.OnAuditPolicyUpdate(ctx.obj, &p)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctx.obj.GetObjectMeta(), err)
			ctx.SetEvent(kvstore.Deleted)
		}
	case kvstore.Deleted:
		ctx.obj.Lock()
		err = auditpolicyHandler.OnAuditPolicyDelete(ctx.obj)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error deleting %s %+v. Err: %v", kind, ctx.obj.GetObjectMeta(), err)
		}
	}
	ct.resolveObject(ctx.event, ctx)
	return nil
}

// handleAuditPolicyEventParallel handles AuditPolicy events from watcher
func (ct *ctrlerCtx) handleAuditPolicyEventParallel(evt *kvstore.WatchEvent) error {

	if ct.objResolver == nil {
		return ct.handleAuditPolicyEventParallelWithNoResolver(evt)
	}

	switch tp := evt.Object.(type) {
	case *monitoring.AuditPolicy:
		eobj := evt.Object.(*monitoring.AuditPolicy)
		kind := "AuditPolicy"

		eobj.ApplyStorageTransformer(context.Background(), true /*encrypt*/)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		eobj.ApplyStorageTransformer(context.Background(), false /*decrypt*/)

		ctx := &auditpolicyCtx{event: evt.Type, obj: &AuditPolicy{AuditPolicy: *eobj, ctrler: ct}}
		ctx.SetWatchTs(evt.WatchTS)

		var err error
		switch evt.Type {
		case kvstore.Created:
			err = ct.processAdd(ctx)
		case kvstore.Updated:
			err = ct.processUpdate(ctx)
		case kvstore.Deleted:
			err = ct.processDelete(ctx)
		}
		return err
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on AuditPolicy watch channel", tp)
	}

	return nil
}

// handleAuditPolicyEventParallel handles AuditPolicy events from watcher
func (ct *ctrlerCtx) handleAuditPolicyEventParallelWithNoResolver(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *monitoring.AuditPolicy:
		eobj := evt.Object.(*monitoring.AuditPolicy)
		kind := "AuditPolicy"

		eobj.ApplyStorageTransformer(context.Background(), true /*encrypt*/)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		eobj.ApplyStorageTransformer(context.Background(), false /*decrypt*/)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		auditpolicyHandler := handler.(AuditPolicyHandler)
		// handle based on event type
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			workFunc := func(ctx context.Context, ctrlCtx shardworkers.WorkObj) error {
				var err error
				workCtx := ctrlCtx.(*auditpolicyCtx)
				eobj := workCtx.obj
				fobj, err := ct.getObject(kind, workCtx.GetKey())
				if err != nil {
					ct.addObject(workCtx)
					ct.stats.Counter("AuditPolicy_Created_Events").Inc()
					eobj.Lock()
					err = auditpolicyHandler.OnAuditPolicyCreate(eobj)
					eobj.Unlock()
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, eobj.GetObjectMeta(), err)
						ct.delObject(kind, workCtx.GetKey())
					}
				} else {
					workCtx = fobj.(*auditpolicyCtx)
					obj := workCtx.obj
					ct.stats.Counter("AuditPolicy_Updated_Events").Inc()
					obj.Lock()
					p := monitoring.AuditPolicy{Spec: eobj.Spec,
						ObjectMeta: eobj.ObjectMeta,
						TypeMeta:   eobj.TypeMeta,
						Status:     eobj.Status}

					err = auditpolicyHandler.OnAuditPolicyUpdate(obj, &p)
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj.GetObjectMeta(), err)
					} else {
						workCtx.obj.AuditPolicy = p
					}
					obj.Unlock()
				}
				workCtx.SetWatchTs(evt.WatchTS)
				return err
			}
			ctrlCtx := &auditpolicyCtx{event: evt.Type, obj: &AuditPolicy{AuditPolicy: *eobj, ctrler: ct}}
			ct.runFunction("AuditPolicy", ctrlCtx, workFunc)
		case kvstore.Deleted:
			workFunc := func(ctx context.Context, ctrlCtx shardworkers.WorkObj) error {
				var err error
				workCtx := ctrlCtx.(*auditpolicyCtx)
				eobj := workCtx.obj
				fobj, err := ct.findObject(kind, workCtx.GetKey())
				if err != nil {
					ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
					return err
				}
				obj := fobj.(*AuditPolicy)
				ct.stats.Counter("AuditPolicy_Deleted_Events").Inc()
				obj.Lock()
				err = auditpolicyHandler.OnAuditPolicyDelete(obj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj.GetObjectMeta(), err)
				}
				ct.delObject(kind, workCtx.GetKey())
				return nil
			}
			ctrlCtx := &auditpolicyCtx{event: evt.Type, obj: &AuditPolicy{AuditPolicy: *eobj, ctrler: ct}}
			ct.runFunction("AuditPolicy", ctrlCtx, workFunc)
		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on AuditPolicy watch channel", tp)
	}

	return nil
}

// diffAuditPolicy does a diff of AuditPolicy objects between local cache and API server
func (ct *ctrlerCtx) diffAuditPolicy(apicl apiclient.Services) {
	opts := api.ListWatchOptions{}

	// get a list of all objects from API server
	objlist, err := apicl.MonitoringV1().AuditPolicy().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Errorf("Error getting a list of objects. Err: %v", err)
		return
	}

	ct.logger.Infof("diffAuditPolicy(): AuditPolicyList returned %d objects", len(objlist))

	// build an object map
	objmap := make(map[string]*monitoring.AuditPolicy)
	for _, obj := range objlist {
		objmap[obj.GetKey()] = obj
	}

	list, err := ct.AuditPolicy().List(context.Background(), &opts)
	if err != nil && !strings.Contains(err.Error(), "not found in local cache") {
		ct.logger.Infof("Failed to get a list of objects. Err: %s", err)
		return
	}

	// if an object is in our local cache and not in API server, trigger delete for it
	for _, obj := range list {
		_, ok := objmap[obj.GetKey()]
		if !ok {
			ct.logger.Infof("diffAuditPolicy(): Deleting existing object %#v since its not in apiserver", obj.GetKey())
			evt := kvstore.WatchEvent{
				Type:   kvstore.Deleted,
				Key:    obj.GetKey(),
				Object: &obj.AuditPolicy,
			}
			ct.handleAuditPolicyEvent(&evt)
		}
	}

	// trigger create event for all others
	for _, obj := range objlist {
		ct.logger.Infof("diffAuditPolicy(): Adding object %#v", obj.GetKey())
		evt := kvstore.WatchEvent{
			Type:   kvstore.Created,
			Key:    obj.GetKey(),
			Object: obj,
		}
		ct.handleAuditPolicyEvent(&evt)
	}
}

func (ct *ctrlerCtx) runAuditPolicyWatcher() {
	kind := "AuditPolicy"

	ct.Lock()
	handler, ok := ct.handlers[kind]
	ct.Unlock()
	if !ok {
		ct.logger.Fatalf("Cant find the handler for %s", kind)
	}
	auditpolicyHandler := handler.(AuditPolicyHandler)

	opts := auditpolicyHandler.GetAuditPolicyWatchOptions()

	// if there is no API server to connect to, we are done
	if (ct.resolver == nil) || ct.apisrvURL == "" {
		return
	}

	// create context
	ctx, cancel := context.WithCancel(context.Background())
	ct.Lock()
	ct.watchCancel[kind] = cancel
	ct.Unlock()
	logger := ct.logger.WithContext("submodule", "AuditPolicyWatcher")
	for {
		if ctx.Err() != nil {
			return
		}

		apiclt, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
		// create a grpc client
		if err == nil {
			// Upon successful connection perform the diff, and start watch goroutine
			ct.diffAuditPolicy(apiclt)
			break
		}

		logger.Warnf("Failed to connect to gRPC server [%s]\n", ct.apisrvURL)
		time.Sleep(time.Second)
	}

	// setup wait group
	ct.waitGrp.Add(1)

	// start a goroutine
	go func() {
		defer ct.waitGrp.Done()
		ct.stats.Counter("AuditPolicy_Watch").Inc()
		defer ct.stats.Counter("AuditPolicy_Watch").Dec()

		// loop forever
		for {
			// create a grpc client
			apicl, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
			if err != nil {
				logger.Warnf("Failed to connect to gRPC server [%s]\n", ct.apisrvURL)
				ct.stats.Counter("AuditPolicy_ApiClientErr").Inc()
			} else {
				logger.Infof("API client connected {%+v}", apicl)

				// AuditPolicy object watcher
				wt, werr := apicl.MonitoringV1().AuditPolicy().Watch(ctx, opts)
				if werr != nil {
					select {
					case <-ctx.Done():
						logger.Infof("watch %s cancelled", kind)
						return
					default:
					}
					logger.Errorf("Failed to start %s watch (%s)\n", kind, werr)
					// wait for a second and retry connecting to api server
					apicl.Close()
					time.Sleep(time.Second)
					continue
				}
				ct.Lock()
				ct.watchers[kind] = wt
				ct.Unlock()

				// perform a diff with API server and local cache
				// Sleeping to give time for other apiclient's to reconnect
				// before calling reconnect handler
				time.Sleep(time.Second)
				ct.diffAuditPolicy(apicl)
				auditpolicyHandler.OnAuditPolicyReconnect()

				// handle api server watch events
			innerLoop:
				for {
					// wait for events
					select {
					case evt, ok := <-wt.EventChan():
						if !ok {
							logger.Error("Error receiving from apisrv watcher")
							ct.stats.Counter("AuditPolicy_WatchErrors").Inc()
							break innerLoop
						}

						// handle event in parallel
						ct.handleAuditPolicyEventParallel(evt)
					}
				}
				apicl.Close()
			}

			// if stop flag is set, we are done
			if ct.stoped {
				logger.Infof("Exiting API server watcher")
				return
			}

			// wait for a second and retry connecting to api server
			time.Sleep(time.Second)
		}
	}()
}

// WatchAuditPolicy starts watch on AuditPolicy object
func (ct *ctrlerCtx) WatchAuditPolicy(handler AuditPolicyHandler) error {
	kind := "AuditPolicy"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchCancel[kind]
	ct.Unlock()
	if ok {
		return fmt.Errorf("AuditPolicy watcher already exists")
	}

	// save handler
	ct.Lock()
	ct.handlers[kind] = handler
	ct.Unlock()

	// run AuditPolicy watcher in a go routine
	ct.runAuditPolicyWatcher()

	return nil
}

// StopWatchAuditPolicy stops watch on AuditPolicy object
func (ct *ctrlerCtx) StopWatchAuditPolicy(handler AuditPolicyHandler) error {
	kind := "AuditPolicy"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchCancel[kind]
	ct.Unlock()
	if !ok {
		return fmt.Errorf("AuditPolicy watcher does not exist")
	}

	ct.Lock()
	cancel, _ := ct.watchCancel[kind]
	cancel()
	if _, ok := ct.watchers[kind]; ok {
		delete(ct.watchers, kind)
	}
	delete(ct.watchCancel, kind)
	ct.Unlock()

	time.Sleep(100 * time.Millisecond)

	return nil
}

// AuditPolicyAPI returns
type AuditPolicyAPI interface {
	Create(obj *monitoring.AuditPolicy) error
	SyncCreate(obj *monitoring.AuditPolicy) error
	Update(obj *monitoring.AuditPolicy) error
	SyncUpdate(obj *monitoring.AuditPolicy) error
	Label(obj *api.Label) error
	Delete(obj *monitoring.AuditPolicy) error
	Find(meta *api.ObjectMeta) (*AuditPolicy, error)
	List(ctx context.Context, opts *api.ListWatchOptions) ([]*AuditPolicy, error)
	ApisrvList(ctx context.Context, opts *api.ListWatchOptions) ([]*monitoring.AuditPolicy, error)
	Watch(handler AuditPolicyHandler) error
	ClearCache(handler AuditPolicyHandler)
	StopWatch(handler AuditPolicyHandler) error
}

// dummy struct that implements AuditPolicyAPI
type auditpolicyAPI struct {
	ct *ctrlerCtx
}

// Create creates AuditPolicy object
func (api *auditpolicyAPI) Create(obj *monitoring.AuditPolicy) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.MonitoringV1().AuditPolicy().Create(context.Background(), obj)
		if err != nil && strings.Contains(err.Error(), "AlreadyExists") {
			_, err = apicl.MonitoringV1().AuditPolicy().Update(context.Background(), obj)

		}
		return err
	}

	api.ct.handleAuditPolicyEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Created})
	return nil
}

// SyncCreate creates AuditPolicy object and updates the cache
func (api *auditpolicyAPI) SyncCreate(obj *monitoring.AuditPolicy) error {
	newObj := obj
	evtType := kvstore.Created
	var writeErr error
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		newObj, writeErr = apicl.MonitoringV1().AuditPolicy().Create(context.Background(), obj)
		if writeErr != nil && strings.Contains(writeErr.Error(), "AlreadyExists") {
			newObj, writeErr = apicl.MonitoringV1().AuditPolicy().Update(context.Background(), obj)
			evtType = kvstore.Updated
		}
	}

	if writeErr == nil {
		api.ct.handleAuditPolicyEvent(&kvstore.WatchEvent{Object: newObj, Type: evtType})
	}
	return writeErr
}

// Update triggers update on AuditPolicy object
func (api *auditpolicyAPI) Update(obj *monitoring.AuditPolicy) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.MonitoringV1().AuditPolicy().Update(context.Background(), obj)
		return err
	}

	api.ct.handleAuditPolicyEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Updated})
	return nil
}

// SyncUpdate triggers update on AuditPolicy object and updates the cache
func (api *auditpolicyAPI) SyncUpdate(obj *monitoring.AuditPolicy) error {
	if api.ct.objResolver != nil {
		log.Fatal("Cannot use Sync update when object resolver is enabled on ctkit")
	}
	newObj := obj
	var writeErr error
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		newObj, writeErr = apicl.MonitoringV1().AuditPolicy().Update(context.Background(), obj)
	}

	if writeErr == nil {
		api.ct.handleAuditPolicyEvent(&kvstore.WatchEvent{Object: newObj, Type: kvstore.Updated})
	}

	return writeErr
}

// Label labels AuditPolicy object
func (api *auditpolicyAPI) Label(obj *api.Label) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.MonitoringV1().AuditPolicy().Label(context.Background(), obj)
		return err
	}

	ctkitObj, err := api.Find(obj.GetObjectMeta())
	if err != nil {
		return err
	}
	writeObj := ctkitObj.AuditPolicy
	writeObj.Labels = obj.Labels

	api.ct.handleAuditPolicyEvent(&kvstore.WatchEvent{Object: &writeObj, Type: kvstore.Updated})
	return nil
}

// Delete deletes AuditPolicy object
func (api *auditpolicyAPI) Delete(obj *monitoring.AuditPolicy) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.MonitoringV1().AuditPolicy().Delete(context.Background(), &obj.ObjectMeta)
		return err
	}

	api.ct.handleAuditPolicyEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Deleted})
	return nil
}

// MakeKey generates a KV store key for the object
func (api *auditpolicyAPI) getFullKey(tenant, name string) string {
	if tenant != "" {
		return fmt.Sprint(globals.ConfigRootPrefix, "/", "monitoring", "/", "audit-policy", "/", tenant, "/", name)
	}
	return fmt.Sprint(globals.ConfigRootPrefix, "/", "monitoring", "/", "audit-policy", "/", name)
}

// Find returns an object by meta
func (api *auditpolicyAPI) Find(meta *api.ObjectMeta) (*AuditPolicy, error) {
	// find the object
	obj, err := api.ct.FindObject("AuditPolicy", meta)
	if err != nil {
		return nil, err
	}

	// asset type
	switch obj.(type) {
	case *AuditPolicy:
		hobj := obj.(*AuditPolicy)
		return hobj, nil
	default:
		return nil, errors.New("incorrect object type")
	}
}

// List returns a list of all AuditPolicy objects
func (api *auditpolicyAPI) List(ctx context.Context, opts *api.ListWatchOptions) ([]*AuditPolicy, error) {
	var objlist []*AuditPolicy
	objs, err := api.ct.List("AuditPolicy", ctx, opts)

	if err != nil {
		return nil, err
	}

	for _, obj := range objs {
		switch tp := obj.(type) {
		case *AuditPolicy:
			eobj := obj.(*AuditPolicy)
			objlist = append(objlist, eobj)
		default:
			log.Fatalf("Got invalid object type %v while looking for AuditPolicy", tp)
		}
	}

	return objlist, nil
}

// ApisrvList returns a list of all AuditPolicy objects from apiserver
func (api *auditpolicyAPI) ApisrvList(ctx context.Context, opts *api.ListWatchOptions) ([]*monitoring.AuditPolicy, error) {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return nil, err
		}

		return apicl.MonitoringV1().AuditPolicy().List(context.Background(), opts)
	}

	// List from local cache
	ctkitObjs, err := api.List(ctx, opts)
	if err != nil {
		return nil, err
	}
	var ret []*monitoring.AuditPolicy
	for _, obj := range ctkitObjs {
		ret = append(ret, &obj.AuditPolicy)
	}
	return ret, nil
}

// Watch sets up a event handlers for AuditPolicy object
func (api *auditpolicyAPI) Watch(handler AuditPolicyHandler) error {
	api.ct.startWorkerPool("AuditPolicy")
	return api.ct.WatchAuditPolicy(handler)
}

// StopWatch stop watch for Tenant AuditPolicy object
func (api *auditpolicyAPI) StopWatch(handler AuditPolicyHandler) error {
	api.ct.Lock()
	api.ct.workPools["AuditPolicy"].Stop()
	api.ct.Unlock()
	return api.ct.StopWatchAuditPolicy(handler)
}

// ClearCache removes all AuditPolicy objects in ctkit
func (api *auditpolicyAPI) ClearCache(handler AuditPolicyHandler) {
	api.ct.delKind("AuditPolicy")
}

// AuditPolicy returns AuditPolicyAPI
func (ct *ctrlerCtx) AuditPolicy() AuditPolicyAPI {
	kind := "AuditPolicy"
	if _, ok := ct.apiInfMap[kind]; !ok {
		s := &auditpolicyAPI{ct: ct}
		ct.apiInfMap[kind] = s
	}
	return ct.apiInfMap[kind].(*auditpolicyAPI)
}
