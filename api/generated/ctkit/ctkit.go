// Code generated by protoc-gen-grpc-pensando DO NOT EDIT.

package ctkit

import (
	"context"
	"fmt"
	"sync"
	"time"

	"github.com/pensando/sw/api"
	"github.com/pensando/sw/api/generated/apiclient"

	"github.com/pensando/sw/venice/utils/balancer"
	"github.com/pensando/sw/venice/utils/kvstore"
	"github.com/pensando/sw/venice/utils/log"
	"github.com/pensando/sw/venice/utils/resolver"
	"github.com/pensando/sw/venice/utils/rpckit"
	"github.com/pensando/sw/venice/utils/runtime"
	"github.com/pensando/sw/venice/utils/tsdb"
)

// db of objects for a kind
type kindStore struct {
	objects map[string]runtime.Object
}

type ctrlerCtx struct {
	sync.Mutex                                // lock for the controller
	name        string                        // controller name
	apisrvURL   string                        // API server URL
	logger      log.Logger                    // logger
	resolver    resolver.Interface            // name resolver
	balancer    balancer.Balancer             // grpc load balancer
	stoped      bool                          // stop the watchers
	watchers    map[string]kvstore.Watcher    // watchers
	watchCancel map[string]context.CancelFunc // stop watcher
	handlers    map[string]interface{}        // event handlers
	waitGrp     sync.WaitGroup                // wait group to wait on all go routines to exit
	kinds       map[string]*kindStore         // DB of all kinds
	apicl       apiclient.Services            // api client to write
	stats       tsdb.Obj                      // ctkit stats
}

// Controller is the main interface provided by controller instance
type Controller interface {
	FindObject(kind string, ometa *api.ObjectMeta) (runtime.Object, error)
	ListObjects(kind string) []runtime.Object
	Stop() error // stop the controller

	User() UserAPI                                       // return User API interface
	AuthenticationPolicy() AuthenticationPolicyAPI       // return AuthenticationPolicy API interface
	Role() RoleAPI                                       // return Role API interface
	RoleBinding() RoleBindingAPI                         // return RoleBinding API interface
	Order() OrderAPI                                     // return Order API interface
	Book() BookAPI                                       // return Book API interface
	Publisher() PublisherAPI                             // return Publisher API interface
	Store() StoreAPI                                     // return Store API interface
	Coupon() CouponAPI                                   // return Coupon API interface
	Customer() CustomerAPI                               // return Customer API interface
	Cluster() ClusterAPI                                 // return Cluster API interface
	Node() NodeAPI                                       // return Node API interface
	Host() HostAPI                                       // return Host API interface
	SmartNIC() SmartNICAPI                               // return SmartNIC API interface
	Tenant() TenantAPI                                   // return Tenant API interface
	EventPolicy() EventPolicyAPI                         // return EventPolicy API interface
	StatsPolicy() StatsPolicyAPI                         // return StatsPolicy API interface
	FwlogPolicy() FwlogPolicyAPI                         // return FwlogPolicy API interface
	FlowExportPolicy() FlowExportPolicyAPI               // return FlowExportPolicy API interface
	Alert() AlertAPI                                     // return Alert API interface
	AlertPolicy() AlertPolicyAPI                         // return AlertPolicy API interface
	AlertDestination() AlertDestinationAPI               // return AlertDestination API interface
	MirrorSession() MirrorSessionAPI                     // return MirrorSession API interface
	TroubleshootingSession() TroubleshootingSessionAPI   // return TroubleshootingSession API interface
	TechSupportRequest() TechSupportRequestAPI           // return TechSupportRequest API interface
	Network() NetworkAPI                                 // return Network API interface
	Service() ServiceAPI                                 // return Service API interface
	LbPolicy() LbPolicyAPI                               // return LbPolicy API interface
	VirtualRouter() VirtualRouterAPI                     // return VirtualRouter API interface
	Bucket() BucketAPI                                   // return Bucket API interface
	Object() ObjectAPI                                   // return Object API interface
	Rollout() RolloutAPI                                 // return Rollout API interface
	SecurityGroup() SecurityGroupAPI                     // return SecurityGroup API interface
	SGPolicy() SGPolicyAPI                               // return SGPolicy API interface
	App() AppAPI                                         // return App API interface
	FirewallProfile() FirewallProfileAPI                 // return FirewallProfile API interface
	Certificate() CertificateAPI                         // return Certificate API interface
	TrafficEncryptionPolicy() TrafficEncryptionPolicyAPI // return TrafficEncryptionPolicy API interface
	Buffer() BufferAPI                                   // return Buffer API interface
	Endpoint() EndpointAPI                               // return Endpoint API interface
	Workload() WorkloadAPI                               // return Workload API interface
}

// NewController creates a new instance of controler
func NewController(name string, apisrvURL string, resolver resolver.Interface, logger log.Logger) (Controller, error) {
	keyTags := map[string]string{"node": "venice", "module": name, "kind": "CtkitStats"}
	tsdbObj, err := tsdb.NewObj("CtkitStats", keyTags, nil, nil)
	if err != nil {
		log.Errorf("unable to create tsdb object, keys %+v", keyTags)
		return nil, err
	}

	// create controller context
	ctrl := ctrlerCtx{
		name:        name,
		apisrvURL:   apisrvURL,
		logger:      logger.WithContext("submodule", name+"-Watcher"),
		resolver:    resolver,
		balancer:    balancer.New(resolver),
		stoped:      false,
		watchers:    make(map[string]kvstore.Watcher),
		watchCancel: make(map[string]context.CancelFunc),
		handlers:    make(map[string]interface{}),
		kinds:       make(map[string]*kindStore),
		stats:       tsdbObj,
	}

	return &ctrl, nil
}

// Stop stops the controller
func (ct *ctrlerCtx) Stop() error {
	ct.stoped = true

	// stop all watchers
	for _, wt := range ct.watchers {
		wt.Stop()
	}

	// cancel all watchers
	for _, cancel := range ct.watchCancel {
		cancel()
	}

	// stop api client
	if ct.apicl != nil {
		ct.apicl.Close()
		ct.apicl = nil
	}

	// wait for all goroutines to exit
	ct.waitGrp.Wait()

	return nil
}

func (ct *ctrlerCtx) apiClient() (apiclient.Services, error) {
	ct.Lock()
	apicl := ct.apicl
	ct.Unlock()
	if apicl != nil {
		return apicl, nil
	}

	for i := 0; i < 10; i++ {
		// create a grpc client
		apicl, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, ct.logger, rpckit.WithBalancer(ct.balancer))
		if err == nil {
			ct.Lock()
			ct.apicl = apicl
			ct.Unlock()
			return apicl, nil
		}

		log.Warnf("Failed to connect to gRPC server [%s]\n", ct.apisrvURL)
		time.Sleep(time.Millisecond * 100)
	}

	return nil, fmt.Errorf("Error connecting to api client")
}

func (ct *ctrlerCtx) addObject(kind, key string, obj runtime.Object) error {
	ct.Lock()
	defer ct.Unlock()

	ks, ok := ct.kinds[kind]
	if !ok {
		ks = &kindStore{
			objects: make(map[string]runtime.Object),
		}
		ct.kinds[kind] = ks
	}

	ct.stats.Counter(kind + "_Objects").Inc()

	// insert the object into kind store
	ks.objects[key] = obj

	return nil
}

func (ct *ctrlerCtx) findObject(kind, key string) (runtime.Object, error) {
	ct.Lock()
	defer ct.Unlock()

	ks, ok := ct.kinds[kind]
	if !ok {
		return nil, fmt.Errorf("Object %s/%s not found", kind, key)
	}

	obj, ok := ks.objects[key]
	if !ok {
		return nil, fmt.Errorf("Object %s/%s not found", kind, key)
	}

	return obj, nil
}

// FindObject finds an objetc by meta
func (ct *ctrlerCtx) FindObject(kind string, ometa *api.ObjectMeta) (runtime.Object, error) {
	return ct.findObject(kind, ometa.GetKey())
}

// ListObjects returns a list of object of a kind
func (ct *ctrlerCtx) ListObjects(kind string) []runtime.Object {
	ct.Lock()
	defer ct.Unlock()

	ks, ok := ct.kinds[kind]
	if !ok {
		return []runtime.Object{}
	}

	var objlist []runtime.Object
	for _, obj := range ks.objects {
		objlist = append(objlist, obj)
	}

	return objlist
}

func (ct *ctrlerCtx) delObject(kind, key string) error {
	ct.Lock()
	defer ct.Unlock()

	ks, ok := ct.kinds[kind]
	if !ok {
		return fmt.Errorf("Object %s/%s not found", kind, key)
	}

	_, ok = ks.objects[key]
	if !ok {
		return fmt.Errorf("Object %s/%s not found", kind, key)
	}

	ct.stats.Counter(kind + "_Objects").Dec()

	// delete the object
	delete(ks.objects, key)

	return nil
}
