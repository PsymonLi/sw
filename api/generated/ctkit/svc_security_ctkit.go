// Code generated by protoc-gen-grpc-pensando DO NOT EDIT.

/*
Package ctkit is a auto generated package.
Input file: svc_security.proto
*/
package ctkit

import (
	"context"
	"fmt"
	"strings"
	"sync"
	"time"

	"github.com/pensando/sw/api"
	"github.com/pensando/sw/api/generated/apiclient"
	"github.com/pensando/sw/api/generated/security"
	"github.com/pensando/sw/venice/utils/balancer"
	"github.com/pensando/sw/venice/utils/kvstore"
	"github.com/pensando/sw/venice/utils/log"
	"github.com/pensando/sw/venice/utils/ref"
	"github.com/pensando/sw/venice/utils/rpckit"
)

// SecurityGroup is a wrapper object that implements additional functionality
type SecurityGroup struct {
	sync.Mutex
	security.SecurityGroup
	HandlerCtx interface{} // additional state handlers can store
	ctrler     *ctrlerCtx  // reference back to the controller instance
}

func (obj *SecurityGroup) Write() error {
	// if there is no API server to connect to, we are done
	if (obj.ctrler == nil) || (obj.ctrler.resolver == nil) || obj.ctrler.apisrvURL == "" {
		return nil
	}

	apicl, err := obj.ctrler.apiClient()
	if err != nil {
		obj.ctrler.logger.Errorf("Error creating API server clent. Err: %v", err)
		return err
	}

	obj.ctrler.stats.Counter("SecurityGroup_Writes").Inc()

	// write to api server
	if obj.ObjectMeta.ResourceVersion != "" {
		nobj := obj.SecurityGroup
		// FIXME: clear the resource version till we figure out CAS semantics
		// update it
		_, err = apicl.SecurityV1().SecurityGroup().Update(context.Background(), &nobj)
	} else {
		//  create
		_, err = apicl.SecurityV1().SecurityGroup().Create(context.Background(), &obj.SecurityGroup)
	}

	return nil
}

// SecurityGroupHandler is the event handler for SecurityGroup object
type SecurityGroupHandler interface {
	OnSecurityGroupCreate(obj *SecurityGroup) error
	OnSecurityGroupUpdate(obj *SecurityGroup) error
	OnSecurityGroupDelete(obj *SecurityGroup) error
}

// handleSecurityGroupEvent handles SecurityGroup events from watcher
func (ct *ctrlerCtx) handleSecurityGroupEvent(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *security.SecurityGroup:
		eobj := evt.Object.(*security.SecurityGroup)
		kind := "SecurityGroup"

		ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		handler, ok := ct.handlers[kind]
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		securitygroupHandler := handler.(SecurityGroupHandler)
		// handle based on event type
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			fobj, err := ct.findObject(kind, eobj.GetKey())
			if err != nil {
				obj := &SecurityGroup{
					SecurityGroup: *eobj,
					HandlerCtx:    nil,
					ctrler:        ct,
				}
				ct.addObject(kind, obj.GetKey(), obj)
				ct.stats.Counter("SecurityGroup_Created_Events").Inc()

				// call the event handler
				obj.Lock()
				err = securitygroupHandler.OnSecurityGroupCreate(obj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					ct.delObject(kind, eobj.GetKey())
					return err
				}
			} else {
				obj := fobj.(*SecurityGroup)

				// see if it changed
				_, ok := ref.ObjDiff(obj.Spec, eobj.Spec)
				if ok || obj.ObjectMeta.GenerationID != eobj.ObjectMeta.GenerationID {
					obj.ObjectMeta = eobj.ObjectMeta
					obj.Spec = eobj.Spec

					ct.stats.Counter("SecurityGroup_Updated_Events").Inc()

					// call the event handler
					obj.Lock()
					err = securitygroupHandler.OnSecurityGroupUpdate(obj)
					obj.Unlock()
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
						return err
					}
				}
			}
		case kvstore.Deleted:
			fobj, err := ct.findObject(kind, eobj.GetKey())
			if err != nil {
				ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
				return err
			}

			obj := fobj.(*SecurityGroup)

			ct.stats.Counter("SecurityGroup_Deleted_Events").Inc()

			// Call the event reactor
			obj.Lock()
			err = securitygroupHandler.OnSecurityGroupDelete(obj)
			obj.Unlock()
			if err != nil {
				ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
			}

			ct.delObject(kind, eobj.GetKey())
		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on SecurityGroup watch channel", tp)
	}

	return nil
}

// diffSecurityGroup does a diff of SecurityGroup objects between local cache and API server
func (ct *ctrlerCtx) diffSecurityGroup(apicl apiclient.Services) {
	opts := api.ListWatchOptions{}

	// get a list of all objects from API server
	objlist, err := apicl.SecurityV1().SecurityGroup().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Errorf("Error getting a list of objects. Err: %v", err)
		return
	}

	// build an object map
	objmap := make(map[string]*security.SecurityGroup)
	for _, obj := range objlist {
		objmap[obj.GetKey()] = obj
	}

	// if an object is in our local cache and not in API server, trigger delete for it
	for _, obj := range ct.SecurityGroup().List() {
		_, ok := objmap[obj.GetKey()]
		if !ok {
			evt := kvstore.WatchEvent{
				Type:   kvstore.Deleted,
				Key:    obj.GetKey(),
				Object: &obj.SecurityGroup,
			}
			ct.handleSecurityGroupEvent(&evt)
		}
	}

	// trigger create event for all others
	for _, obj := range objlist {
		evt := kvstore.WatchEvent{
			Type:   kvstore.Created,
			Key:    obj.GetKey(),
			Object: obj,
		}
		ct.handleSecurityGroupEvent(&evt)
	}
}

func (ct *ctrlerCtx) runSecurityGroupWatcher() {
	kind := "SecurityGroup"

	// if there is no API server to connect to, we are done
	if (ct.resolver == nil) || ct.apisrvURL == "" {
		return
	}

	// create context
	ctx, cancel := context.WithCancel(context.Background())
	ct.Lock()
	ct.watchCancel[kind] = cancel
	ct.Unlock()
	opts := api.ListWatchOptions{}

	// setup wait group
	ct.waitGrp.Add(1)
	defer ct.waitGrp.Done()
	logger := ct.logger.WithContext("submodule", "SecurityGroupWatcher")

	ct.stats.Counter("SecurityGroup_Watch").Inc()
	defer ct.stats.Counter("SecurityGroup_Watch").Dec()

	// loop forever
	for {
		// create a grpc client
		apicl, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
		if err != nil {
			logger.Warnf("Failed to connect to gRPC server [%s]\n", ct.apisrvURL)
			ct.stats.Counter("SecurityGroup_ApiClientErr").Inc()
		} else {
			logger.Infof("API client connected {%+v}", apicl)

			// SecurityGroup object watcher
			wt, werr := apicl.SecurityV1().SecurityGroup().Watch(ctx, &opts)
			if werr != nil {
				logger.Errorf("Failed to start %s watch (%s)\n", kind, werr)
				// wait for a second and retry connecting to api server
				apicl.Close()
				time.Sleep(time.Second)
				continue
			}
			ct.Lock()
			ct.watchers[kind] = wt
			ct.Unlock()

			// perform a diff with API server and local cache
			time.Sleep(time.Millisecond * 100)
			ct.diffSecurityGroup(apicl)

			// handle api server watch events
		innerLoop:
			for {
				// wait for events
				select {
				case evt, ok := <-wt.EventChan():
					if !ok {
						logger.Error("Error receiving from apisrv watcher")
						ct.stats.Counter("SecurityGroup_WatchErrors").Inc()
						break innerLoop
					}

					// handle event
					ct.handleSecurityGroupEvent(evt)
				}
			}
			apicl.Close()
		}

		// if stop flag is set, we are done
		if ct.stoped {
			logger.Infof("Exiting API server watcher")
			return
		}

		// wait for a second and retry connecting to api server
		time.Sleep(time.Second)
	}
}

// WatchSecurityGroup starts watch on SecurityGroup object
func (ct *ctrlerCtx) WatchSecurityGroup(handler SecurityGroupHandler) error {
	kind := "SecurityGroup"

	ct.Lock()
	defer ct.Unlock()

	// see if we already have a watcher
	_, ok := ct.watchers[kind]
	if ok {
		return fmt.Errorf("SecurityGroup watcher already exists")
	}

	// save handler
	ct.handlers[kind] = handler

	// run SecurityGroup watcher in a go routine
	go ct.runSecurityGroupWatcher()

	return nil
}

// SecurityGroupAPI returns
type SecurityGroupAPI interface {
	Create(obj *security.SecurityGroup) error
	Update(obj *security.SecurityGroup) error
	Delete(obj *security.SecurityGroup) error
	List() []*SecurityGroup
	Watch(handler SecurityGroupHandler) error
}

// dummy struct that implements SecurityGroupAPI
type securitygroupAPI struct {
	ct *ctrlerCtx
}

// Create creates SecurityGroup object
func (api *securitygroupAPI) Create(obj *security.SecurityGroup) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.SecurityV1().SecurityGroup().Create(context.Background(), obj)
		if err != nil && strings.Contains(err.Error(), "AlreadyExists") {
			_, err = apicl.SecurityV1().SecurityGroup().Update(context.Background(), obj)
		}
		if err != nil {
			return err
		}
	}

	return api.ct.handleSecurityGroupEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Created})
}

// Update triggers update on SecurityGroup object
func (api *securitygroupAPI) Update(obj *security.SecurityGroup) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.SecurityV1().SecurityGroup().Update(context.Background(), obj)
		if err != nil {
			return err
		}
	}

	return api.ct.handleSecurityGroupEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Updated})
}

// Delete deletes SecurityGroup object
func (api *securitygroupAPI) Delete(obj *security.SecurityGroup) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		apicl.SecurityV1().SecurityGroup().Delete(context.Background(), &obj.ObjectMeta)
	}

	return api.ct.handleSecurityGroupEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Deleted})
}

// List returns a list of all SecurityGroup objects
func (api *securitygroupAPI) List() []*SecurityGroup {
	var objlist []*SecurityGroup

	objs := api.ct.ListObjects("SecurityGroup")
	for _, obj := range objs {
		switch tp := obj.(type) {
		case *SecurityGroup:
			eobj := obj.(*SecurityGroup)
			objlist = append(objlist, eobj)
		default:
			log.Fatalf("Got invalid object type %v while looking for SecurityGroup", tp)
		}
	}

	return objlist
}

// Watch sets up a event handlers for SecurityGroup object
func (api *securitygroupAPI) Watch(handler SecurityGroupHandler) error {
	return api.ct.WatchSecurityGroup(handler)
}

// SecurityGroup returns SecurityGroupAPI
func (ct *ctrlerCtx) SecurityGroup() SecurityGroupAPI {
	return &securitygroupAPI{ct: ct}
}

// SGPolicy is a wrapper object that implements additional functionality
type SGPolicy struct {
	sync.Mutex
	security.SGPolicy
	HandlerCtx interface{} // additional state handlers can store
	ctrler     *ctrlerCtx  // reference back to the controller instance
}

func (obj *SGPolicy) Write() error {
	// if there is no API server to connect to, we are done
	if (obj.ctrler == nil) || (obj.ctrler.resolver == nil) || obj.ctrler.apisrvURL == "" {
		return nil
	}

	apicl, err := obj.ctrler.apiClient()
	if err != nil {
		obj.ctrler.logger.Errorf("Error creating API server clent. Err: %v", err)
		return err
	}

	obj.ctrler.stats.Counter("SGPolicy_Writes").Inc()

	// write to api server
	if obj.ObjectMeta.ResourceVersion != "" {
		nobj := obj.SGPolicy
		// FIXME: clear the resource version till we figure out CAS semantics
		// update it
		_, err = apicl.SecurityV1().SGPolicy().Update(context.Background(), &nobj)
	} else {
		//  create
		_, err = apicl.SecurityV1().SGPolicy().Create(context.Background(), &obj.SGPolicy)
	}

	return nil
}

// SGPolicyHandler is the event handler for SGPolicy object
type SGPolicyHandler interface {
	OnSGPolicyCreate(obj *SGPolicy) error
	OnSGPolicyUpdate(obj *SGPolicy) error
	OnSGPolicyDelete(obj *SGPolicy) error
}

// handleSGPolicyEvent handles SGPolicy events from watcher
func (ct *ctrlerCtx) handleSGPolicyEvent(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *security.SGPolicy:
		eobj := evt.Object.(*security.SGPolicy)
		kind := "SGPolicy"

		ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		handler, ok := ct.handlers[kind]
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		sgpolicyHandler := handler.(SGPolicyHandler)
		// handle based on event type
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			fobj, err := ct.findObject(kind, eobj.GetKey())
			if err != nil {
				obj := &SGPolicy{
					SGPolicy:   *eobj,
					HandlerCtx: nil,
					ctrler:     ct,
				}
				ct.addObject(kind, obj.GetKey(), obj)
				ct.stats.Counter("SGPolicy_Created_Events").Inc()

				// call the event handler
				obj.Lock()
				err = sgpolicyHandler.OnSGPolicyCreate(obj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					ct.delObject(kind, eobj.GetKey())
					return err
				}
			} else {
				obj := fobj.(*SGPolicy)

				// see if it changed
				_, ok := ref.ObjDiff(obj.Spec, eobj.Spec)
				if ok || obj.ObjectMeta.GenerationID != eobj.ObjectMeta.GenerationID {
					obj.ObjectMeta = eobj.ObjectMeta
					obj.Spec = eobj.Spec

					ct.stats.Counter("SGPolicy_Updated_Events").Inc()

					// call the event handler
					obj.Lock()
					err = sgpolicyHandler.OnSGPolicyUpdate(obj)
					obj.Unlock()
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
						return err
					}
				}
			}
		case kvstore.Deleted:
			fobj, err := ct.findObject(kind, eobj.GetKey())
			if err != nil {
				ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
				return err
			}

			obj := fobj.(*SGPolicy)

			ct.stats.Counter("SGPolicy_Deleted_Events").Inc()

			// Call the event reactor
			obj.Lock()
			err = sgpolicyHandler.OnSGPolicyDelete(obj)
			obj.Unlock()
			if err != nil {
				ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
			}

			ct.delObject(kind, eobj.GetKey())
		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on SGPolicy watch channel", tp)
	}

	return nil
}

// diffSGPolicy does a diff of SGPolicy objects between local cache and API server
func (ct *ctrlerCtx) diffSGPolicy(apicl apiclient.Services) {
	opts := api.ListWatchOptions{}

	// get a list of all objects from API server
	objlist, err := apicl.SecurityV1().SGPolicy().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Errorf("Error getting a list of objects. Err: %v", err)
		return
	}

	// build an object map
	objmap := make(map[string]*security.SGPolicy)
	for _, obj := range objlist {
		objmap[obj.GetKey()] = obj
	}

	// if an object is in our local cache and not in API server, trigger delete for it
	for _, obj := range ct.SGPolicy().List() {
		_, ok := objmap[obj.GetKey()]
		if !ok {
			evt := kvstore.WatchEvent{
				Type:   kvstore.Deleted,
				Key:    obj.GetKey(),
				Object: &obj.SGPolicy,
			}
			ct.handleSGPolicyEvent(&evt)
		}
	}

	// trigger create event for all others
	for _, obj := range objlist {
		evt := kvstore.WatchEvent{
			Type:   kvstore.Created,
			Key:    obj.GetKey(),
			Object: obj,
		}
		ct.handleSGPolicyEvent(&evt)
	}
}

func (ct *ctrlerCtx) runSGPolicyWatcher() {
	kind := "SGPolicy"

	// if there is no API server to connect to, we are done
	if (ct.resolver == nil) || ct.apisrvURL == "" {
		return
	}

	// create context
	ctx, cancel := context.WithCancel(context.Background())
	ct.Lock()
	ct.watchCancel[kind] = cancel
	ct.Unlock()
	opts := api.ListWatchOptions{}

	// setup wait group
	ct.waitGrp.Add(1)
	defer ct.waitGrp.Done()
	logger := ct.logger.WithContext("submodule", "SGPolicyWatcher")

	ct.stats.Counter("SGPolicy_Watch").Inc()
	defer ct.stats.Counter("SGPolicy_Watch").Dec()

	// loop forever
	for {
		// create a grpc client
		apicl, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
		if err != nil {
			logger.Warnf("Failed to connect to gRPC server [%s]\n", ct.apisrvURL)
			ct.stats.Counter("SGPolicy_ApiClientErr").Inc()
		} else {
			logger.Infof("API client connected {%+v}", apicl)

			// SGPolicy object watcher
			wt, werr := apicl.SecurityV1().SGPolicy().Watch(ctx, &opts)
			if werr != nil {
				logger.Errorf("Failed to start %s watch (%s)\n", kind, werr)
				// wait for a second and retry connecting to api server
				apicl.Close()
				time.Sleep(time.Second)
				continue
			}
			ct.Lock()
			ct.watchers[kind] = wt
			ct.Unlock()

			// perform a diff with API server and local cache
			time.Sleep(time.Millisecond * 100)
			ct.diffSGPolicy(apicl)

			// handle api server watch events
		innerLoop:
			for {
				// wait for events
				select {
				case evt, ok := <-wt.EventChan():
					if !ok {
						logger.Error("Error receiving from apisrv watcher")
						ct.stats.Counter("SGPolicy_WatchErrors").Inc()
						break innerLoop
					}

					// handle event
					ct.handleSGPolicyEvent(evt)
				}
			}
			apicl.Close()
		}

		// if stop flag is set, we are done
		if ct.stoped {
			logger.Infof("Exiting API server watcher")
			return
		}

		// wait for a second and retry connecting to api server
		time.Sleep(time.Second)
	}
}

// WatchSGPolicy starts watch on SGPolicy object
func (ct *ctrlerCtx) WatchSGPolicy(handler SGPolicyHandler) error {
	kind := "SGPolicy"

	ct.Lock()
	defer ct.Unlock()

	// see if we already have a watcher
	_, ok := ct.watchers[kind]
	if ok {
		return fmt.Errorf("SGPolicy watcher already exists")
	}

	// save handler
	ct.handlers[kind] = handler

	// run SGPolicy watcher in a go routine
	go ct.runSGPolicyWatcher()

	return nil
}

// SGPolicyAPI returns
type SGPolicyAPI interface {
	Create(obj *security.SGPolicy) error
	Update(obj *security.SGPolicy) error
	Delete(obj *security.SGPolicy) error
	List() []*SGPolicy
	Watch(handler SGPolicyHandler) error
}

// dummy struct that implements SGPolicyAPI
type sgpolicyAPI struct {
	ct *ctrlerCtx
}

// Create creates SGPolicy object
func (api *sgpolicyAPI) Create(obj *security.SGPolicy) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.SecurityV1().SGPolicy().Create(context.Background(), obj)
		if err != nil && strings.Contains(err.Error(), "AlreadyExists") {
			_, err = apicl.SecurityV1().SGPolicy().Update(context.Background(), obj)
		}
		if err != nil {
			return err
		}
	}

	return api.ct.handleSGPolicyEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Created})
}

// Update triggers update on SGPolicy object
func (api *sgpolicyAPI) Update(obj *security.SGPolicy) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.SecurityV1().SGPolicy().Update(context.Background(), obj)
		if err != nil {
			return err
		}
	}

	return api.ct.handleSGPolicyEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Updated})
}

// Delete deletes SGPolicy object
func (api *sgpolicyAPI) Delete(obj *security.SGPolicy) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		apicl.SecurityV1().SGPolicy().Delete(context.Background(), &obj.ObjectMeta)
	}

	return api.ct.handleSGPolicyEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Deleted})
}

// List returns a list of all SGPolicy objects
func (api *sgpolicyAPI) List() []*SGPolicy {
	var objlist []*SGPolicy

	objs := api.ct.ListObjects("SGPolicy")
	for _, obj := range objs {
		switch tp := obj.(type) {
		case *SGPolicy:
			eobj := obj.(*SGPolicy)
			objlist = append(objlist, eobj)
		default:
			log.Fatalf("Got invalid object type %v while looking for SGPolicy", tp)
		}
	}

	return objlist
}

// Watch sets up a event handlers for SGPolicy object
func (api *sgpolicyAPI) Watch(handler SGPolicyHandler) error {
	return api.ct.WatchSGPolicy(handler)
}

// SGPolicy returns SGPolicyAPI
func (ct *ctrlerCtx) SGPolicy() SGPolicyAPI {
	return &sgpolicyAPI{ct: ct}
}

// App is a wrapper object that implements additional functionality
type App struct {
	sync.Mutex
	security.App
	HandlerCtx interface{} // additional state handlers can store
	ctrler     *ctrlerCtx  // reference back to the controller instance
}

func (obj *App) Write() error {
	// if there is no API server to connect to, we are done
	if (obj.ctrler == nil) || (obj.ctrler.resolver == nil) || obj.ctrler.apisrvURL == "" {
		return nil
	}

	apicl, err := obj.ctrler.apiClient()
	if err != nil {
		obj.ctrler.logger.Errorf("Error creating API server clent. Err: %v", err)
		return err
	}

	obj.ctrler.stats.Counter("App_Writes").Inc()

	// write to api server
	if obj.ObjectMeta.ResourceVersion != "" {
		nobj := obj.App
		// FIXME: clear the resource version till we figure out CAS semantics
		// update it
		_, err = apicl.SecurityV1().App().Update(context.Background(), &nobj)
	} else {
		//  create
		_, err = apicl.SecurityV1().App().Create(context.Background(), &obj.App)
	}

	return nil
}

// AppHandler is the event handler for App object
type AppHandler interface {
	OnAppCreate(obj *App) error
	OnAppUpdate(obj *App) error
	OnAppDelete(obj *App) error
}

// handleAppEvent handles App events from watcher
func (ct *ctrlerCtx) handleAppEvent(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *security.App:
		eobj := evt.Object.(*security.App)
		kind := "App"

		ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		handler, ok := ct.handlers[kind]
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		appHandler := handler.(AppHandler)
		// handle based on event type
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			fobj, err := ct.findObject(kind, eobj.GetKey())
			if err != nil {
				obj := &App{
					App:        *eobj,
					HandlerCtx: nil,
					ctrler:     ct,
				}
				ct.addObject(kind, obj.GetKey(), obj)
				ct.stats.Counter("App_Created_Events").Inc()

				// call the event handler
				obj.Lock()
				err = appHandler.OnAppCreate(obj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					ct.delObject(kind, eobj.GetKey())
					return err
				}
			} else {
				obj := fobj.(*App)

				// see if it changed
				_, ok := ref.ObjDiff(obj.Spec, eobj.Spec)
				if ok || obj.ObjectMeta.GenerationID != eobj.ObjectMeta.GenerationID {
					obj.ObjectMeta = eobj.ObjectMeta
					obj.Spec = eobj.Spec

					ct.stats.Counter("App_Updated_Events").Inc()

					// call the event handler
					obj.Lock()
					err = appHandler.OnAppUpdate(obj)
					obj.Unlock()
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
						return err
					}
				}
			}
		case kvstore.Deleted:
			fobj, err := ct.findObject(kind, eobj.GetKey())
			if err != nil {
				ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
				return err
			}

			obj := fobj.(*App)

			ct.stats.Counter("App_Deleted_Events").Inc()

			// Call the event reactor
			obj.Lock()
			err = appHandler.OnAppDelete(obj)
			obj.Unlock()
			if err != nil {
				ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
			}

			ct.delObject(kind, eobj.GetKey())
		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on App watch channel", tp)
	}

	return nil
}

// diffApp does a diff of App objects between local cache and API server
func (ct *ctrlerCtx) diffApp(apicl apiclient.Services) {
	opts := api.ListWatchOptions{}

	// get a list of all objects from API server
	objlist, err := apicl.SecurityV1().App().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Errorf("Error getting a list of objects. Err: %v", err)
		return
	}

	// build an object map
	objmap := make(map[string]*security.App)
	for _, obj := range objlist {
		objmap[obj.GetKey()] = obj
	}

	// if an object is in our local cache and not in API server, trigger delete for it
	for _, obj := range ct.App().List() {
		_, ok := objmap[obj.GetKey()]
		if !ok {
			evt := kvstore.WatchEvent{
				Type:   kvstore.Deleted,
				Key:    obj.GetKey(),
				Object: &obj.App,
			}
			ct.handleAppEvent(&evt)
		}
	}

	// trigger create event for all others
	for _, obj := range objlist {
		evt := kvstore.WatchEvent{
			Type:   kvstore.Created,
			Key:    obj.GetKey(),
			Object: obj,
		}
		ct.handleAppEvent(&evt)
	}
}

func (ct *ctrlerCtx) runAppWatcher() {
	kind := "App"

	// if there is no API server to connect to, we are done
	if (ct.resolver == nil) || ct.apisrvURL == "" {
		return
	}

	// create context
	ctx, cancel := context.WithCancel(context.Background())
	ct.Lock()
	ct.watchCancel[kind] = cancel
	ct.Unlock()
	opts := api.ListWatchOptions{}

	// setup wait group
	ct.waitGrp.Add(1)
	defer ct.waitGrp.Done()
	logger := ct.logger.WithContext("submodule", "AppWatcher")

	ct.stats.Counter("App_Watch").Inc()
	defer ct.stats.Counter("App_Watch").Dec()

	// loop forever
	for {
		// create a grpc client
		apicl, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
		if err != nil {
			logger.Warnf("Failed to connect to gRPC server [%s]\n", ct.apisrvURL)
			ct.stats.Counter("App_ApiClientErr").Inc()
		} else {
			logger.Infof("API client connected {%+v}", apicl)

			// App object watcher
			wt, werr := apicl.SecurityV1().App().Watch(ctx, &opts)
			if werr != nil {
				logger.Errorf("Failed to start %s watch (%s)\n", kind, werr)
				// wait for a second and retry connecting to api server
				apicl.Close()
				time.Sleep(time.Second)
				continue
			}
			ct.Lock()
			ct.watchers[kind] = wt
			ct.Unlock()

			// perform a diff with API server and local cache
			time.Sleep(time.Millisecond * 100)
			ct.diffApp(apicl)

			// handle api server watch events
		innerLoop:
			for {
				// wait for events
				select {
				case evt, ok := <-wt.EventChan():
					if !ok {
						logger.Error("Error receiving from apisrv watcher")
						ct.stats.Counter("App_WatchErrors").Inc()
						break innerLoop
					}

					// handle event
					ct.handleAppEvent(evt)
				}
			}
			apicl.Close()
		}

		// if stop flag is set, we are done
		if ct.stoped {
			logger.Infof("Exiting API server watcher")
			return
		}

		// wait for a second and retry connecting to api server
		time.Sleep(time.Second)
	}
}

// WatchApp starts watch on App object
func (ct *ctrlerCtx) WatchApp(handler AppHandler) error {
	kind := "App"

	ct.Lock()
	defer ct.Unlock()

	// see if we already have a watcher
	_, ok := ct.watchers[kind]
	if ok {
		return fmt.Errorf("App watcher already exists")
	}

	// save handler
	ct.handlers[kind] = handler

	// run App watcher in a go routine
	go ct.runAppWatcher()

	return nil
}

// AppAPI returns
type AppAPI interface {
	Create(obj *security.App) error
	Update(obj *security.App) error
	Delete(obj *security.App) error
	List() []*App
	Watch(handler AppHandler) error
}

// dummy struct that implements AppAPI
type appAPI struct {
	ct *ctrlerCtx
}

// Create creates App object
func (api *appAPI) Create(obj *security.App) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.SecurityV1().App().Create(context.Background(), obj)
		if err != nil && strings.Contains(err.Error(), "AlreadyExists") {
			_, err = apicl.SecurityV1().App().Update(context.Background(), obj)
		}
		if err != nil {
			return err
		}
	}

	return api.ct.handleAppEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Created})
}

// Update triggers update on App object
func (api *appAPI) Update(obj *security.App) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.SecurityV1().App().Update(context.Background(), obj)
		if err != nil {
			return err
		}
	}

	return api.ct.handleAppEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Updated})
}

// Delete deletes App object
func (api *appAPI) Delete(obj *security.App) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		apicl.SecurityV1().App().Delete(context.Background(), &obj.ObjectMeta)
	}

	return api.ct.handleAppEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Deleted})
}

// List returns a list of all App objects
func (api *appAPI) List() []*App {
	var objlist []*App

	objs := api.ct.ListObjects("App")
	for _, obj := range objs {
		switch tp := obj.(type) {
		case *App:
			eobj := obj.(*App)
			objlist = append(objlist, eobj)
		default:
			log.Fatalf("Got invalid object type %v while looking for App", tp)
		}
	}

	return objlist
}

// Watch sets up a event handlers for App object
func (api *appAPI) Watch(handler AppHandler) error {
	return api.ct.WatchApp(handler)
}

// App returns AppAPI
func (ct *ctrlerCtx) App() AppAPI {
	return &appAPI{ct: ct}
}

// FirewallProfile is a wrapper object that implements additional functionality
type FirewallProfile struct {
	sync.Mutex
	security.FirewallProfile
	HandlerCtx interface{} // additional state handlers can store
	ctrler     *ctrlerCtx  // reference back to the controller instance
}

func (obj *FirewallProfile) Write() error {
	// if there is no API server to connect to, we are done
	if (obj.ctrler == nil) || (obj.ctrler.resolver == nil) || obj.ctrler.apisrvURL == "" {
		return nil
	}

	apicl, err := obj.ctrler.apiClient()
	if err != nil {
		obj.ctrler.logger.Errorf("Error creating API server clent. Err: %v", err)
		return err
	}

	obj.ctrler.stats.Counter("FirewallProfile_Writes").Inc()

	// write to api server
	if obj.ObjectMeta.ResourceVersion != "" {
		nobj := obj.FirewallProfile
		// FIXME: clear the resource version till we figure out CAS semantics
		// update it
		_, err = apicl.SecurityV1().FirewallProfile().Update(context.Background(), &nobj)
	} else {
		//  create
		_, err = apicl.SecurityV1().FirewallProfile().Create(context.Background(), &obj.FirewallProfile)
	}

	return nil
}

// FirewallProfileHandler is the event handler for FirewallProfile object
type FirewallProfileHandler interface {
	OnFirewallProfileCreate(obj *FirewallProfile) error
	OnFirewallProfileUpdate(obj *FirewallProfile) error
	OnFirewallProfileDelete(obj *FirewallProfile) error
}

// handleFirewallProfileEvent handles FirewallProfile events from watcher
func (ct *ctrlerCtx) handleFirewallProfileEvent(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *security.FirewallProfile:
		eobj := evt.Object.(*security.FirewallProfile)
		kind := "FirewallProfile"

		ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		handler, ok := ct.handlers[kind]
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		firewallprofileHandler := handler.(FirewallProfileHandler)
		// handle based on event type
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			fobj, err := ct.findObject(kind, eobj.GetKey())
			if err != nil {
				obj := &FirewallProfile{
					FirewallProfile: *eobj,
					HandlerCtx:      nil,
					ctrler:          ct,
				}
				ct.addObject(kind, obj.GetKey(), obj)
				ct.stats.Counter("FirewallProfile_Created_Events").Inc()

				// call the event handler
				obj.Lock()
				err = firewallprofileHandler.OnFirewallProfileCreate(obj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					ct.delObject(kind, eobj.GetKey())
					return err
				}
			} else {
				obj := fobj.(*FirewallProfile)

				// see if it changed
				_, ok := ref.ObjDiff(obj.Spec, eobj.Spec)
				if ok || obj.ObjectMeta.GenerationID != eobj.ObjectMeta.GenerationID {
					obj.ObjectMeta = eobj.ObjectMeta
					obj.Spec = eobj.Spec

					ct.stats.Counter("FirewallProfile_Updated_Events").Inc()

					// call the event handler
					obj.Lock()
					err = firewallprofileHandler.OnFirewallProfileUpdate(obj)
					obj.Unlock()
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
						return err
					}
				}
			}
		case kvstore.Deleted:
			fobj, err := ct.findObject(kind, eobj.GetKey())
			if err != nil {
				ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
				return err
			}

			obj := fobj.(*FirewallProfile)

			ct.stats.Counter("FirewallProfile_Deleted_Events").Inc()

			// Call the event reactor
			obj.Lock()
			err = firewallprofileHandler.OnFirewallProfileDelete(obj)
			obj.Unlock()
			if err != nil {
				ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
			}

			ct.delObject(kind, eobj.GetKey())
		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on FirewallProfile watch channel", tp)
	}

	return nil
}

// diffFirewallProfile does a diff of FirewallProfile objects between local cache and API server
func (ct *ctrlerCtx) diffFirewallProfile(apicl apiclient.Services) {
	opts := api.ListWatchOptions{}

	// get a list of all objects from API server
	objlist, err := apicl.SecurityV1().FirewallProfile().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Errorf("Error getting a list of objects. Err: %v", err)
		return
	}

	// build an object map
	objmap := make(map[string]*security.FirewallProfile)
	for _, obj := range objlist {
		objmap[obj.GetKey()] = obj
	}

	// if an object is in our local cache and not in API server, trigger delete for it
	for _, obj := range ct.FirewallProfile().List() {
		_, ok := objmap[obj.GetKey()]
		if !ok {
			evt := kvstore.WatchEvent{
				Type:   kvstore.Deleted,
				Key:    obj.GetKey(),
				Object: &obj.FirewallProfile,
			}
			ct.handleFirewallProfileEvent(&evt)
		}
	}

	// trigger create event for all others
	for _, obj := range objlist {
		evt := kvstore.WatchEvent{
			Type:   kvstore.Created,
			Key:    obj.GetKey(),
			Object: obj,
		}
		ct.handleFirewallProfileEvent(&evt)
	}
}

func (ct *ctrlerCtx) runFirewallProfileWatcher() {
	kind := "FirewallProfile"

	// if there is no API server to connect to, we are done
	if (ct.resolver == nil) || ct.apisrvURL == "" {
		return
	}

	// create context
	ctx, cancel := context.WithCancel(context.Background())
	ct.Lock()
	ct.watchCancel[kind] = cancel
	ct.Unlock()
	opts := api.ListWatchOptions{}

	// setup wait group
	ct.waitGrp.Add(1)
	defer ct.waitGrp.Done()
	logger := ct.logger.WithContext("submodule", "FirewallProfileWatcher")

	ct.stats.Counter("FirewallProfile_Watch").Inc()
	defer ct.stats.Counter("FirewallProfile_Watch").Dec()

	// loop forever
	for {
		// create a grpc client
		apicl, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
		if err != nil {
			logger.Warnf("Failed to connect to gRPC server [%s]\n", ct.apisrvURL)
			ct.stats.Counter("FirewallProfile_ApiClientErr").Inc()
		} else {
			logger.Infof("API client connected {%+v}", apicl)

			// FirewallProfile object watcher
			wt, werr := apicl.SecurityV1().FirewallProfile().Watch(ctx, &opts)
			if werr != nil {
				logger.Errorf("Failed to start %s watch (%s)\n", kind, werr)
				// wait for a second and retry connecting to api server
				apicl.Close()
				time.Sleep(time.Second)
				continue
			}
			ct.Lock()
			ct.watchers[kind] = wt
			ct.Unlock()

			// perform a diff with API server and local cache
			time.Sleep(time.Millisecond * 100)
			ct.diffFirewallProfile(apicl)

			// handle api server watch events
		innerLoop:
			for {
				// wait for events
				select {
				case evt, ok := <-wt.EventChan():
					if !ok {
						logger.Error("Error receiving from apisrv watcher")
						ct.stats.Counter("FirewallProfile_WatchErrors").Inc()
						break innerLoop
					}

					// handle event
					ct.handleFirewallProfileEvent(evt)
				}
			}
			apicl.Close()
		}

		// if stop flag is set, we are done
		if ct.stoped {
			logger.Infof("Exiting API server watcher")
			return
		}

		// wait for a second and retry connecting to api server
		time.Sleep(time.Second)
	}
}

// WatchFirewallProfile starts watch on FirewallProfile object
func (ct *ctrlerCtx) WatchFirewallProfile(handler FirewallProfileHandler) error {
	kind := "FirewallProfile"

	ct.Lock()
	defer ct.Unlock()

	// see if we already have a watcher
	_, ok := ct.watchers[kind]
	if ok {
		return fmt.Errorf("FirewallProfile watcher already exists")
	}

	// save handler
	ct.handlers[kind] = handler

	// run FirewallProfile watcher in a go routine
	go ct.runFirewallProfileWatcher()

	return nil
}

// FirewallProfileAPI returns
type FirewallProfileAPI interface {
	Create(obj *security.FirewallProfile) error
	Update(obj *security.FirewallProfile) error
	Delete(obj *security.FirewallProfile) error
	List() []*FirewallProfile
	Watch(handler FirewallProfileHandler) error
}

// dummy struct that implements FirewallProfileAPI
type firewallprofileAPI struct {
	ct *ctrlerCtx
}

// Create creates FirewallProfile object
func (api *firewallprofileAPI) Create(obj *security.FirewallProfile) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.SecurityV1().FirewallProfile().Create(context.Background(), obj)
		if err != nil && strings.Contains(err.Error(), "AlreadyExists") {
			_, err = apicl.SecurityV1().FirewallProfile().Update(context.Background(), obj)
		}
		if err != nil {
			return err
		}
	}

	return api.ct.handleFirewallProfileEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Created})
}

// Update triggers update on FirewallProfile object
func (api *firewallprofileAPI) Update(obj *security.FirewallProfile) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.SecurityV1().FirewallProfile().Update(context.Background(), obj)
		if err != nil {
			return err
		}
	}

	return api.ct.handleFirewallProfileEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Updated})
}

// Delete deletes FirewallProfile object
func (api *firewallprofileAPI) Delete(obj *security.FirewallProfile) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		apicl.SecurityV1().FirewallProfile().Delete(context.Background(), &obj.ObjectMeta)
	}

	return api.ct.handleFirewallProfileEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Deleted})
}

// List returns a list of all FirewallProfile objects
func (api *firewallprofileAPI) List() []*FirewallProfile {
	var objlist []*FirewallProfile

	objs := api.ct.ListObjects("FirewallProfile")
	for _, obj := range objs {
		switch tp := obj.(type) {
		case *FirewallProfile:
			eobj := obj.(*FirewallProfile)
			objlist = append(objlist, eobj)
		default:
			log.Fatalf("Got invalid object type %v while looking for FirewallProfile", tp)
		}
	}

	return objlist
}

// Watch sets up a event handlers for FirewallProfile object
func (api *firewallprofileAPI) Watch(handler FirewallProfileHandler) error {
	return api.ct.WatchFirewallProfile(handler)
}

// FirewallProfile returns FirewallProfileAPI
func (ct *ctrlerCtx) FirewallProfile() FirewallProfileAPI {
	return &firewallprofileAPI{ct: ct}
}

// Certificate is a wrapper object that implements additional functionality
type Certificate struct {
	sync.Mutex
	security.Certificate
	HandlerCtx interface{} // additional state handlers can store
	ctrler     *ctrlerCtx  // reference back to the controller instance
}

func (obj *Certificate) Write() error {
	// if there is no API server to connect to, we are done
	if (obj.ctrler == nil) || (obj.ctrler.resolver == nil) || obj.ctrler.apisrvURL == "" {
		return nil
	}

	apicl, err := obj.ctrler.apiClient()
	if err != nil {
		obj.ctrler.logger.Errorf("Error creating API server clent. Err: %v", err)
		return err
	}

	obj.ctrler.stats.Counter("Certificate_Writes").Inc()

	// write to api server
	if obj.ObjectMeta.ResourceVersion != "" {
		nobj := obj.Certificate
		// FIXME: clear the resource version till we figure out CAS semantics
		// update it
		_, err = apicl.SecurityV1().Certificate().Update(context.Background(), &nobj)
	} else {
		//  create
		_, err = apicl.SecurityV1().Certificate().Create(context.Background(), &obj.Certificate)
	}

	return nil
}

// CertificateHandler is the event handler for Certificate object
type CertificateHandler interface {
	OnCertificateCreate(obj *Certificate) error
	OnCertificateUpdate(obj *Certificate) error
	OnCertificateDelete(obj *Certificate) error
}

// handleCertificateEvent handles Certificate events from watcher
func (ct *ctrlerCtx) handleCertificateEvent(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *security.Certificate:
		eobj := evt.Object.(*security.Certificate)
		kind := "Certificate"

		ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		handler, ok := ct.handlers[kind]
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		certificateHandler := handler.(CertificateHandler)
		// handle based on event type
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			fobj, err := ct.findObject(kind, eobj.GetKey())
			if err != nil {
				obj := &Certificate{
					Certificate: *eobj,
					HandlerCtx:  nil,
					ctrler:      ct,
				}
				ct.addObject(kind, obj.GetKey(), obj)
				ct.stats.Counter("Certificate_Created_Events").Inc()

				// call the event handler
				obj.Lock()
				err = certificateHandler.OnCertificateCreate(obj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					ct.delObject(kind, eobj.GetKey())
					return err
				}
			} else {
				obj := fobj.(*Certificate)

				// see if it changed
				_, ok := ref.ObjDiff(obj.Spec, eobj.Spec)
				if ok || obj.ObjectMeta.GenerationID != eobj.ObjectMeta.GenerationID {
					obj.ObjectMeta = eobj.ObjectMeta
					obj.Spec = eobj.Spec

					ct.stats.Counter("Certificate_Updated_Events").Inc()

					// call the event handler
					obj.Lock()
					err = certificateHandler.OnCertificateUpdate(obj)
					obj.Unlock()
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
						return err
					}
				}
			}
		case kvstore.Deleted:
			fobj, err := ct.findObject(kind, eobj.GetKey())
			if err != nil {
				ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
				return err
			}

			obj := fobj.(*Certificate)

			ct.stats.Counter("Certificate_Deleted_Events").Inc()

			// Call the event reactor
			obj.Lock()
			err = certificateHandler.OnCertificateDelete(obj)
			obj.Unlock()
			if err != nil {
				ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
			}

			ct.delObject(kind, eobj.GetKey())
		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on Certificate watch channel", tp)
	}

	return nil
}

// diffCertificate does a diff of Certificate objects between local cache and API server
func (ct *ctrlerCtx) diffCertificate(apicl apiclient.Services) {
	opts := api.ListWatchOptions{}

	// get a list of all objects from API server
	objlist, err := apicl.SecurityV1().Certificate().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Errorf("Error getting a list of objects. Err: %v", err)
		return
	}

	// build an object map
	objmap := make(map[string]*security.Certificate)
	for _, obj := range objlist {
		objmap[obj.GetKey()] = obj
	}

	// if an object is in our local cache and not in API server, trigger delete for it
	for _, obj := range ct.Certificate().List() {
		_, ok := objmap[obj.GetKey()]
		if !ok {
			evt := kvstore.WatchEvent{
				Type:   kvstore.Deleted,
				Key:    obj.GetKey(),
				Object: &obj.Certificate,
			}
			ct.handleCertificateEvent(&evt)
		}
	}

	// trigger create event for all others
	for _, obj := range objlist {
		evt := kvstore.WatchEvent{
			Type:   kvstore.Created,
			Key:    obj.GetKey(),
			Object: obj,
		}
		ct.handleCertificateEvent(&evt)
	}
}

func (ct *ctrlerCtx) runCertificateWatcher() {
	kind := "Certificate"

	// if there is no API server to connect to, we are done
	if (ct.resolver == nil) || ct.apisrvURL == "" {
		return
	}

	// create context
	ctx, cancel := context.WithCancel(context.Background())
	ct.Lock()
	ct.watchCancel[kind] = cancel
	ct.Unlock()
	opts := api.ListWatchOptions{}

	// setup wait group
	ct.waitGrp.Add(1)
	defer ct.waitGrp.Done()
	logger := ct.logger.WithContext("submodule", "CertificateWatcher")

	ct.stats.Counter("Certificate_Watch").Inc()
	defer ct.stats.Counter("Certificate_Watch").Dec()

	// loop forever
	for {
		// create a grpc client
		apicl, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
		if err != nil {
			logger.Warnf("Failed to connect to gRPC server [%s]\n", ct.apisrvURL)
			ct.stats.Counter("Certificate_ApiClientErr").Inc()
		} else {
			logger.Infof("API client connected {%+v}", apicl)

			// Certificate object watcher
			wt, werr := apicl.SecurityV1().Certificate().Watch(ctx, &opts)
			if werr != nil {
				logger.Errorf("Failed to start %s watch (%s)\n", kind, werr)
				// wait for a second and retry connecting to api server
				apicl.Close()
				time.Sleep(time.Second)
				continue
			}
			ct.Lock()
			ct.watchers[kind] = wt
			ct.Unlock()

			// perform a diff with API server and local cache
			time.Sleep(time.Millisecond * 100)
			ct.diffCertificate(apicl)

			// handle api server watch events
		innerLoop:
			for {
				// wait for events
				select {
				case evt, ok := <-wt.EventChan():
					if !ok {
						logger.Error("Error receiving from apisrv watcher")
						ct.stats.Counter("Certificate_WatchErrors").Inc()
						break innerLoop
					}

					// handle event
					ct.handleCertificateEvent(evt)
				}
			}
			apicl.Close()
		}

		// if stop flag is set, we are done
		if ct.stoped {
			logger.Infof("Exiting API server watcher")
			return
		}

		// wait for a second and retry connecting to api server
		time.Sleep(time.Second)
	}
}

// WatchCertificate starts watch on Certificate object
func (ct *ctrlerCtx) WatchCertificate(handler CertificateHandler) error {
	kind := "Certificate"

	ct.Lock()
	defer ct.Unlock()

	// see if we already have a watcher
	_, ok := ct.watchers[kind]
	if ok {
		return fmt.Errorf("Certificate watcher already exists")
	}

	// save handler
	ct.handlers[kind] = handler

	// run Certificate watcher in a go routine
	go ct.runCertificateWatcher()

	return nil
}

// CertificateAPI returns
type CertificateAPI interface {
	Create(obj *security.Certificate) error
	Update(obj *security.Certificate) error
	Delete(obj *security.Certificate) error
	List() []*Certificate
	Watch(handler CertificateHandler) error
}

// dummy struct that implements CertificateAPI
type certificateAPI struct {
	ct *ctrlerCtx
}

// Create creates Certificate object
func (api *certificateAPI) Create(obj *security.Certificate) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.SecurityV1().Certificate().Create(context.Background(), obj)
		if err != nil && strings.Contains(err.Error(), "AlreadyExists") {
			_, err = apicl.SecurityV1().Certificate().Update(context.Background(), obj)
		}
		if err != nil {
			return err
		}
	}

	return api.ct.handleCertificateEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Created})
}

// Update triggers update on Certificate object
func (api *certificateAPI) Update(obj *security.Certificate) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.SecurityV1().Certificate().Update(context.Background(), obj)
		if err != nil {
			return err
		}
	}

	return api.ct.handleCertificateEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Updated})
}

// Delete deletes Certificate object
func (api *certificateAPI) Delete(obj *security.Certificate) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		apicl.SecurityV1().Certificate().Delete(context.Background(), &obj.ObjectMeta)
	}

	return api.ct.handleCertificateEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Deleted})
}

// List returns a list of all Certificate objects
func (api *certificateAPI) List() []*Certificate {
	var objlist []*Certificate

	objs := api.ct.ListObjects("Certificate")
	for _, obj := range objs {
		switch tp := obj.(type) {
		case *Certificate:
			eobj := obj.(*Certificate)
			objlist = append(objlist, eobj)
		default:
			log.Fatalf("Got invalid object type %v while looking for Certificate", tp)
		}
	}

	return objlist
}

// Watch sets up a event handlers for Certificate object
func (api *certificateAPI) Watch(handler CertificateHandler) error {
	return api.ct.WatchCertificate(handler)
}

// Certificate returns CertificateAPI
func (ct *ctrlerCtx) Certificate() CertificateAPI {
	return &certificateAPI{ct: ct}
}

// TrafficEncryptionPolicy is a wrapper object that implements additional functionality
type TrafficEncryptionPolicy struct {
	sync.Mutex
	security.TrafficEncryptionPolicy
	HandlerCtx interface{} // additional state handlers can store
	ctrler     *ctrlerCtx  // reference back to the controller instance
}

func (obj *TrafficEncryptionPolicy) Write() error {
	// if there is no API server to connect to, we are done
	if (obj.ctrler == nil) || (obj.ctrler.resolver == nil) || obj.ctrler.apisrvURL == "" {
		return nil
	}

	apicl, err := obj.ctrler.apiClient()
	if err != nil {
		obj.ctrler.logger.Errorf("Error creating API server clent. Err: %v", err)
		return err
	}

	obj.ctrler.stats.Counter("TrafficEncryptionPolicy_Writes").Inc()

	// write to api server
	if obj.ObjectMeta.ResourceVersion != "" {
		nobj := obj.TrafficEncryptionPolicy
		// FIXME: clear the resource version till we figure out CAS semantics
		// update it
		_, err = apicl.SecurityV1().TrafficEncryptionPolicy().Update(context.Background(), &nobj)
	} else {
		//  create
		_, err = apicl.SecurityV1().TrafficEncryptionPolicy().Create(context.Background(), &obj.TrafficEncryptionPolicy)
	}

	return nil
}

// TrafficEncryptionPolicyHandler is the event handler for TrafficEncryptionPolicy object
type TrafficEncryptionPolicyHandler interface {
	OnTrafficEncryptionPolicyCreate(obj *TrafficEncryptionPolicy) error
	OnTrafficEncryptionPolicyUpdate(obj *TrafficEncryptionPolicy) error
	OnTrafficEncryptionPolicyDelete(obj *TrafficEncryptionPolicy) error
}

// handleTrafficEncryptionPolicyEvent handles TrafficEncryptionPolicy events from watcher
func (ct *ctrlerCtx) handleTrafficEncryptionPolicyEvent(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *security.TrafficEncryptionPolicy:
		eobj := evt.Object.(*security.TrafficEncryptionPolicy)
		kind := "TrafficEncryptionPolicy"

		ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		handler, ok := ct.handlers[kind]
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		trafficencryptionpolicyHandler := handler.(TrafficEncryptionPolicyHandler)
		// handle based on event type
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			fobj, err := ct.findObject(kind, eobj.GetKey())
			if err != nil {
				obj := &TrafficEncryptionPolicy{
					TrafficEncryptionPolicy: *eobj,
					HandlerCtx:              nil,
					ctrler:                  ct,
				}
				ct.addObject(kind, obj.GetKey(), obj)
				ct.stats.Counter("TrafficEncryptionPolicy_Created_Events").Inc()

				// call the event handler
				obj.Lock()
				err = trafficencryptionpolicyHandler.OnTrafficEncryptionPolicyCreate(obj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					ct.delObject(kind, eobj.GetKey())
					return err
				}
			} else {
				obj := fobj.(*TrafficEncryptionPolicy)

				// see if it changed
				_, ok := ref.ObjDiff(obj.Spec, eobj.Spec)
				if ok || obj.ObjectMeta.GenerationID != eobj.ObjectMeta.GenerationID {
					obj.ObjectMeta = eobj.ObjectMeta
					obj.Spec = eobj.Spec

					ct.stats.Counter("TrafficEncryptionPolicy_Updated_Events").Inc()

					// call the event handler
					obj.Lock()
					err = trafficencryptionpolicyHandler.OnTrafficEncryptionPolicyUpdate(obj)
					obj.Unlock()
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
						return err
					}
				}
			}
		case kvstore.Deleted:
			fobj, err := ct.findObject(kind, eobj.GetKey())
			if err != nil {
				ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
				return err
			}

			obj := fobj.(*TrafficEncryptionPolicy)

			ct.stats.Counter("TrafficEncryptionPolicy_Deleted_Events").Inc()

			// Call the event reactor
			obj.Lock()
			err = trafficencryptionpolicyHandler.OnTrafficEncryptionPolicyDelete(obj)
			obj.Unlock()
			if err != nil {
				ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
			}

			ct.delObject(kind, eobj.GetKey())
		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on TrafficEncryptionPolicy watch channel", tp)
	}

	return nil
}

// diffTrafficEncryptionPolicy does a diff of TrafficEncryptionPolicy objects between local cache and API server
func (ct *ctrlerCtx) diffTrafficEncryptionPolicy(apicl apiclient.Services) {
	opts := api.ListWatchOptions{}

	// get a list of all objects from API server
	objlist, err := apicl.SecurityV1().TrafficEncryptionPolicy().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Errorf("Error getting a list of objects. Err: %v", err)
		return
	}

	// build an object map
	objmap := make(map[string]*security.TrafficEncryptionPolicy)
	for _, obj := range objlist {
		objmap[obj.GetKey()] = obj
	}

	// if an object is in our local cache and not in API server, trigger delete for it
	for _, obj := range ct.TrafficEncryptionPolicy().List() {
		_, ok := objmap[obj.GetKey()]
		if !ok {
			evt := kvstore.WatchEvent{
				Type:   kvstore.Deleted,
				Key:    obj.GetKey(),
				Object: &obj.TrafficEncryptionPolicy,
			}
			ct.handleTrafficEncryptionPolicyEvent(&evt)
		}
	}

	// trigger create event for all others
	for _, obj := range objlist {
		evt := kvstore.WatchEvent{
			Type:   kvstore.Created,
			Key:    obj.GetKey(),
			Object: obj,
		}
		ct.handleTrafficEncryptionPolicyEvent(&evt)
	}
}

func (ct *ctrlerCtx) runTrafficEncryptionPolicyWatcher() {
	kind := "TrafficEncryptionPolicy"

	// if there is no API server to connect to, we are done
	if (ct.resolver == nil) || ct.apisrvURL == "" {
		return
	}

	// create context
	ctx, cancel := context.WithCancel(context.Background())
	ct.Lock()
	ct.watchCancel[kind] = cancel
	ct.Unlock()
	opts := api.ListWatchOptions{}

	// setup wait group
	ct.waitGrp.Add(1)
	defer ct.waitGrp.Done()
	logger := ct.logger.WithContext("submodule", "TrafficEncryptionPolicyWatcher")

	ct.stats.Counter("TrafficEncryptionPolicy_Watch").Inc()
	defer ct.stats.Counter("TrafficEncryptionPolicy_Watch").Dec()

	// loop forever
	for {
		// create a grpc client
		apicl, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
		if err != nil {
			logger.Warnf("Failed to connect to gRPC server [%s]\n", ct.apisrvURL)
			ct.stats.Counter("TrafficEncryptionPolicy_ApiClientErr").Inc()
		} else {
			logger.Infof("API client connected {%+v}", apicl)

			// TrafficEncryptionPolicy object watcher
			wt, werr := apicl.SecurityV1().TrafficEncryptionPolicy().Watch(ctx, &opts)
			if werr != nil {
				logger.Errorf("Failed to start %s watch (%s)\n", kind, werr)
				// wait for a second and retry connecting to api server
				apicl.Close()
				time.Sleep(time.Second)
				continue
			}
			ct.Lock()
			ct.watchers[kind] = wt
			ct.Unlock()

			// perform a diff with API server and local cache
			time.Sleep(time.Millisecond * 100)
			ct.diffTrafficEncryptionPolicy(apicl)

			// handle api server watch events
		innerLoop:
			for {
				// wait for events
				select {
				case evt, ok := <-wt.EventChan():
					if !ok {
						logger.Error("Error receiving from apisrv watcher")
						ct.stats.Counter("TrafficEncryptionPolicy_WatchErrors").Inc()
						break innerLoop
					}

					// handle event
					ct.handleTrafficEncryptionPolicyEvent(evt)
				}
			}
			apicl.Close()
		}

		// if stop flag is set, we are done
		if ct.stoped {
			logger.Infof("Exiting API server watcher")
			return
		}

		// wait for a second and retry connecting to api server
		time.Sleep(time.Second)
	}
}

// WatchTrafficEncryptionPolicy starts watch on TrafficEncryptionPolicy object
func (ct *ctrlerCtx) WatchTrafficEncryptionPolicy(handler TrafficEncryptionPolicyHandler) error {
	kind := "TrafficEncryptionPolicy"

	ct.Lock()
	defer ct.Unlock()

	// see if we already have a watcher
	_, ok := ct.watchers[kind]
	if ok {
		return fmt.Errorf("TrafficEncryptionPolicy watcher already exists")
	}

	// save handler
	ct.handlers[kind] = handler

	// run TrafficEncryptionPolicy watcher in a go routine
	go ct.runTrafficEncryptionPolicyWatcher()

	return nil
}

// TrafficEncryptionPolicyAPI returns
type TrafficEncryptionPolicyAPI interface {
	Create(obj *security.TrafficEncryptionPolicy) error
	Update(obj *security.TrafficEncryptionPolicy) error
	Delete(obj *security.TrafficEncryptionPolicy) error
	List() []*TrafficEncryptionPolicy
	Watch(handler TrafficEncryptionPolicyHandler) error
}

// dummy struct that implements TrafficEncryptionPolicyAPI
type trafficencryptionpolicyAPI struct {
	ct *ctrlerCtx
}

// Create creates TrafficEncryptionPolicy object
func (api *trafficencryptionpolicyAPI) Create(obj *security.TrafficEncryptionPolicy) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.SecurityV1().TrafficEncryptionPolicy().Create(context.Background(), obj)
		if err != nil && strings.Contains(err.Error(), "AlreadyExists") {
			_, err = apicl.SecurityV1().TrafficEncryptionPolicy().Update(context.Background(), obj)
		}
		if err != nil {
			return err
		}
	}

	return api.ct.handleTrafficEncryptionPolicyEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Created})
}

// Update triggers update on TrafficEncryptionPolicy object
func (api *trafficencryptionpolicyAPI) Update(obj *security.TrafficEncryptionPolicy) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.SecurityV1().TrafficEncryptionPolicy().Update(context.Background(), obj)
		if err != nil {
			return err
		}
	}

	return api.ct.handleTrafficEncryptionPolicyEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Updated})
}

// Delete deletes TrafficEncryptionPolicy object
func (api *trafficencryptionpolicyAPI) Delete(obj *security.TrafficEncryptionPolicy) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		apicl.SecurityV1().TrafficEncryptionPolicy().Delete(context.Background(), &obj.ObjectMeta)
	}

	return api.ct.handleTrafficEncryptionPolicyEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Deleted})
}

// List returns a list of all TrafficEncryptionPolicy objects
func (api *trafficencryptionpolicyAPI) List() []*TrafficEncryptionPolicy {
	var objlist []*TrafficEncryptionPolicy

	objs := api.ct.ListObjects("TrafficEncryptionPolicy")
	for _, obj := range objs {
		switch tp := obj.(type) {
		case *TrafficEncryptionPolicy:
			eobj := obj.(*TrafficEncryptionPolicy)
			objlist = append(objlist, eobj)
		default:
			log.Fatalf("Got invalid object type %v while looking for TrafficEncryptionPolicy", tp)
		}
	}

	return objlist
}

// Watch sets up a event handlers for TrafficEncryptionPolicy object
func (api *trafficencryptionpolicyAPI) Watch(handler TrafficEncryptionPolicyHandler) error {
	return api.ct.WatchTrafficEncryptionPolicy(handler)
}

// TrafficEncryptionPolicy returns TrafficEncryptionPolicyAPI
func (ct *ctrlerCtx) TrafficEncryptionPolicy() TrafficEncryptionPolicyAPI {
	return &trafficencryptionpolicyAPI{ct: ct}
}
