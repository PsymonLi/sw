// Code generated by protoc-gen-grpc-pensando DO NOT EDIT.

/*
Package ctkit is a auto generated package.
Input file: svc_security.proto
*/
package ctkit

import (
	"context"
	"errors"
	"fmt"
	"strings"
	"sync"
	"time"

	"github.com/pensando/sw/api"
	"github.com/pensando/sw/api/generated/apiclient"
	"github.com/pensando/sw/api/generated/security"
	apiintf "github.com/pensando/sw/api/interfaces"
	"github.com/pensando/sw/venice/globals"
	"github.com/pensando/sw/venice/utils/balancer"
	"github.com/pensando/sw/venice/utils/kvstore"
	"github.com/pensando/sw/venice/utils/log"
	"github.com/pensando/sw/venice/utils/rpckit"
	"github.com/pensando/sw/venice/utils/runtime"
	"github.com/pensando/sw/venice/utils/shardworkers"
)

// SecurityGroup is a wrapper object that implements additional functionality
type SecurityGroup struct {
	sync.Mutex
	security.SecurityGroup
	HandlerCtx interface{} // additional state handlers can store
	ctrler     *ctrlerCtx  // reference back to the controller instance
}

func (obj *SecurityGroup) Write() error {
	// if there is no API server to connect to, we are done
	if (obj.ctrler == nil) || (obj.ctrler.resolver == nil) || obj.ctrler.apisrvURL == "" {
		return nil
	}

	apicl, err := obj.ctrler.apiClient()
	if err != nil {
		obj.ctrler.logger.Errorf("Error creating API server clent. Err: %v", err)
		return err
	}

	obj.ctrler.stats.Counter("SecurityGroup_Writes").Inc()

	// write to api server
	if obj.ObjectMeta.ResourceVersion != "" {
		// update it
		for i := 0; i < maxApisrvWriteRetry; i++ {
			_, err = apicl.SecurityV1().SecurityGroup().UpdateStatus(context.Background(), &obj.SecurityGroup)
			if err == nil {
				break
			}
			time.Sleep(time.Millisecond * 100)
		}
	} else {
		//  create
		_, err = apicl.SecurityV1().SecurityGroup().Create(context.Background(), &obj.SecurityGroup)
	}

	return nil
}

// SecurityGroupHandler is the event handler for SecurityGroup object
type SecurityGroupHandler interface {
	OnSecurityGroupCreate(obj *SecurityGroup) error
	OnSecurityGroupUpdate(oldObj *SecurityGroup, newObj *security.SecurityGroup) error
	OnSecurityGroupDelete(obj *SecurityGroup) error
	GetSecurityGroupWatchOptions() *api.ListWatchOptions
}

// OnSecurityGroupCreate is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnSecurityGroupCreate(obj *SecurityGroup) error {
	log.Info("OnSecurityGroupCreate is not implemented")
	return nil
}

// OnSecurityGroupUpdate is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnSecurityGroupUpdate(oldObj *SecurityGroup, newObj *security.SecurityGroup) error {
	log.Info("OnSecurityGroupUpdate is not implemented")
	return nil
}

// OnSecurityGroupDelete is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnSecurityGroupDelete(obj *SecurityGroup) error {
	log.Info("OnSecurityGroupDelete is not implemented")
	return nil
}

// GetSecurityGroupWatchOptions is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) GetSecurityGroupWatchOptions() *api.ListWatchOptions {
	log.Info("GetSecurityGroupWatchOptions is not implemented")
	opts := &api.ListWatchOptions{}
	return opts
}

// handleSecurityGroupEvent handles SecurityGroup events from watcher
func (ct *ctrlerCtx) handleSecurityGroupEvent(evt *kvstore.WatchEvent) error {

	if ct.objResolver == nil {
		return ct.handleSecurityGroupEventNoResolver(evt)
	}

	switch tp := evt.Object.(type) {
	case *security.SecurityGroup:
		eobj := evt.Object.(*security.SecurityGroup)
		kind := "SecurityGroup"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ctx := &securitygroupCtx{event: evt.Type,
			obj: &SecurityGroup{SecurityGroup: *eobj, ctrler: ct}}

		var err error
		switch evt.Type {
		case kvstore.Created:
			err = ct.processAdd(ctx)
		case kvstore.Updated:
			err = ct.processUpdate(ctx)
		case kvstore.Deleted:
			err = ct.processDelete(ctx)
		}
		return err
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on SecurityGroup watch channel", tp)
	}

	return nil
}

// handleSecurityGroupEventNoResolver handles SecurityGroup events from watcher
func (ct *ctrlerCtx) handleSecurityGroupEventNoResolver(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *security.SecurityGroup:
		eobj := evt.Object.(*security.SecurityGroup)
		kind := "SecurityGroup"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		securitygroupHandler := handler.(SecurityGroupHandler)
		// handle based on event type
		ctrlCtx := &securitygroupCtx{event: evt.Type, obj: &SecurityGroup{SecurityGroup: *eobj, ctrler: ct}}
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			fobj, err := ct.getObject(kind, ctrlCtx.GetKey())
			if err != nil {
				ct.addObject(ctrlCtx)
				ct.stats.Counter("SecurityGroup_Created_Events").Inc()

				// call the event handler
				ctrlCtx.Lock()
				err = securitygroupHandler.OnSecurityGroupCreate(ctrlCtx.obj)
				ctrlCtx.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctrlCtx.obj, err)
					ct.delObject(kind, ctrlCtx.GetKey())
					return err
				}
			} else {
				ctrlCtx := fobj.(*securitygroupCtx)
				ct.stats.Counter("SecurityGroup_Updated_Events").Inc()
				ctrlCtx.Lock()
				p := security.SecurityGroup{Spec: eobj.Spec,
					ObjectMeta: eobj.ObjectMeta,
					TypeMeta:   eobj.TypeMeta,
					Status:     eobj.Status}

				err = securitygroupHandler.OnSecurityGroupUpdate(ctrlCtx.obj, &p)
				ctrlCtx.obj.SecurityGroup = *eobj
				ctrlCtx.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctrlCtx.obj, err)
					return err
				}

			}
		case kvstore.Deleted:
			ctrlCtx := &securitygroupCtx{event: evt.Type, obj: &SecurityGroup{SecurityGroup: *eobj, ctrler: ct}}
			fobj, err := ct.findObject(kind, ctrlCtx.GetKey())
			if err != nil {
				ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
				return err
			}

			obj := fobj.(*SecurityGroup)
			ct.stats.Counter("SecurityGroup_Deleted_Events").Inc()
			obj.Lock()
			err = securitygroupHandler.OnSecurityGroupDelete(obj)
			obj.Unlock()
			if err != nil {
				ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
			}
			ct.delObject(kind, ctrlCtx.GetKey())
			return nil

		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on SecurityGroup watch channel", tp)
	}

	return nil
}

type securitygroupCtx struct {
	ctkitBaseCtx
	event kvstore.WatchEventType
	obj   *SecurityGroup //
	//   newObj     *security.SecurityGroup //update
	newObj *securitygroupCtx //update
}

func (ctx *securitygroupCtx) References() map[string]apiintf.ReferenceObj {
	resp := make(map[string]apiintf.ReferenceObj)
	ctx.obj.References(ctx.obj.GetObjectMeta().Name, ctx.obj.GetObjectMeta().Namespace, resp)
	return resp
}

func (ctx *securitygroupCtx) GetKey() string {
	return ctx.obj.MakeKey("security")
}

func (ctx *securitygroupCtx) GetKind() string {
	return ctx.obj.GetKind()
}

func (ctx *securitygroupCtx) SetEvent(event kvstore.WatchEventType) {
	ctx.event = event
}

func (ctx *securitygroupCtx) SetNewObj(newObj apiintf.CtkitObject) {
	if newObj == nil {
		ctx.newObj = nil
	} else {
		ctx.newObj = newObj.(*securitygroupCtx)
		ctx.newObj.obj.HandlerCtx = ctx.obj.HandlerCtx
	}
}

func (ctx *securitygroupCtx) GetNewObj() apiintf.CtkitObject {
	return ctx.newObj
}

func (ctx *securitygroupCtx) Copy(obj apiintf.CtkitObject) {
	ctx.obj.SecurityGroup = obj.(*securitygroupCtx).obj.SecurityGroup
}

func (ctx *securitygroupCtx) Lock() {
	ctx.obj.Lock()
}

func (ctx *securitygroupCtx) Unlock() {
	ctx.obj.Unlock()
}

func (ctx *securitygroupCtx) GetObjectMeta() *api.ObjectMeta {
	return ctx.obj.GetObjectMeta()
}

func (ctx *securitygroupCtx) RuntimeObject() runtime.Object {
	var v interface{}
	v = ctx.obj
	return v.(runtime.Object)
}

func (ctx *securitygroupCtx) WorkFunc(context context.Context) error {
	var err error
	evt := ctx.event
	ct := ctx.obj.ctrler
	kind := "SecurityGroup"
	ct.Lock()
	handler, ok := ct.handlers[kind]
	ct.Unlock()
	if !ok {
		ct.logger.Fatalf("Cant find the handler for %s", kind)
	}
	securitygroupHandler := handler.(SecurityGroupHandler)
	switch evt {
	case kvstore.Created:
		ctx.obj.Lock()
		err = securitygroupHandler.OnSecurityGroupCreate(ctx.obj)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctx.obj, err)
			ctx.SetEvent(kvstore.Deleted)
		}
	case kvstore.Updated:
		ct.stats.Counter("SecurityGroup_Updated_Events").Inc()
		ctx.obj.Lock()
		p := security.SecurityGroup{Spec: ctx.newObj.obj.Spec,
			ObjectMeta: ctx.newObj.obj.ObjectMeta,
			TypeMeta:   ctx.newObj.obj.TypeMeta,
			Status:     ctx.newObj.obj.Status}
		err = securitygroupHandler.OnSecurityGroupUpdate(ctx.obj, &p)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctx.obj, err)
			ctx.SetEvent(kvstore.Deleted)
		}
	case kvstore.Deleted:
		ctx.obj.Lock()
		err = securitygroupHandler.OnSecurityGroupDelete(ctx.obj)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error deleting %s %+v. Err: %v", kind, ctx.obj, err)
		}
	}
	ct.resolveObject(ctx.event, ctx)
	return nil
}

// handleSecurityGroupEventParallel handles SecurityGroup events from watcher
func (ct *ctrlerCtx) handleSecurityGroupEventParallel(evt *kvstore.WatchEvent) error {

	if ct.objResolver == nil {
		return ct.handleSecurityGroupEventParallelWithNoResolver(evt)
	}

	switch tp := evt.Object.(type) {
	case *security.SecurityGroup:
		eobj := evt.Object.(*security.SecurityGroup)
		kind := "SecurityGroup"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ctx := &securitygroupCtx{event: evt.Type, obj: &SecurityGroup{SecurityGroup: *eobj, ctrler: ct}}

		var err error
		switch evt.Type {
		case kvstore.Created:
			err = ct.processAdd(ctx)
		case kvstore.Updated:
			err = ct.processUpdate(ctx)
		case kvstore.Deleted:
			err = ct.processDelete(ctx)
		}
		return err
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on SecurityGroup watch channel", tp)
	}

	return nil
}

// handleSecurityGroupEventParallel handles SecurityGroup events from watcher
func (ct *ctrlerCtx) handleSecurityGroupEventParallelWithNoResolver(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *security.SecurityGroup:
		eobj := evt.Object.(*security.SecurityGroup)
		kind := "SecurityGroup"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		securitygroupHandler := handler.(SecurityGroupHandler)
		// handle based on event type
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			workFunc := func(ctx context.Context, ctrlCtx shardworkers.WorkObj) error {
				var err error
				workCtx := ctrlCtx.(*securitygroupCtx)
				eobj := workCtx.obj
				fobj, err := ct.getObject(kind, workCtx.GetKey())
				if err != nil {
					ct.addObject(workCtx)
					ct.stats.Counter("SecurityGroup_Created_Events").Inc()
					eobj.Lock()
					err = securitygroupHandler.OnSecurityGroupCreate(eobj)
					eobj.Unlock()
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, eobj, err)
						ct.delObject(kind, workCtx.GetKey())
					}
				} else {
					workCtx := fobj.(*securitygroupCtx)
					obj := workCtx.obj
					ct.stats.Counter("SecurityGroup_Updated_Events").Inc()
					obj.Lock()
					p := security.SecurityGroup{Spec: eobj.Spec,
						ObjectMeta: eobj.ObjectMeta,
						TypeMeta:   eobj.TypeMeta,
						Status:     eobj.Status}

					err = securitygroupHandler.OnSecurityGroupUpdate(obj, &p)
					workCtx.obj.SecurityGroup = p
					obj.Unlock()
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					}
				}
				return err
			}
			ctrlCtx := &securitygroupCtx{event: evt.Type, obj: &SecurityGroup{SecurityGroup: *eobj, ctrler: ct}}
			ct.runFunction("SecurityGroup", ctrlCtx, workFunc)
		case kvstore.Deleted:
			workFunc := func(ctx context.Context, ctrlCtx shardworkers.WorkObj) error {
				var err error
				workCtx := ctrlCtx.(*securitygroupCtx)
				eobj := workCtx.obj
				fobj, err := ct.findObject(kind, workCtx.GetKey())
				if err != nil {
					ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
					return err
				}
				obj := fobj.(*SecurityGroup)
				ct.stats.Counter("SecurityGroup_Deleted_Events").Inc()
				obj.Lock()
				err = securitygroupHandler.OnSecurityGroupDelete(obj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
				}
				ct.delObject(kind, workCtx.GetKey())
				return nil
			}
			ctrlCtx := &securitygroupCtx{event: evt.Type, obj: &SecurityGroup{SecurityGroup: *eobj, ctrler: ct}}
			ct.runFunction("SecurityGroup", ctrlCtx, workFunc)
		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on SecurityGroup watch channel", tp)
	}

	return nil
}

// diffSecurityGroup does a diff of SecurityGroup objects between local cache and API server
func (ct *ctrlerCtx) diffSecurityGroup(apicl apiclient.Services) {
	opts := api.ListWatchOptions{}

	// get a list of all objects from API server
	objlist, err := apicl.SecurityV1().SecurityGroup().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Errorf("Error getting a list of objects. Err: %v", err)
		return
	}

	ct.logger.Infof("diffSecurityGroup(): SecurityGroupList returned %d objects", len(objlist))

	// build an object map
	objmap := make(map[string]*security.SecurityGroup)
	for _, obj := range objlist {
		objmap[obj.GetKey()] = obj
	}

	list, err := ct.SecurityGroup().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Infof("Failed to get a list of objects. Err: %s", err)
		return
	}

	// if an object is in our local cache and not in API server, trigger delete for it
	for _, obj := range list {
		_, ok := objmap[obj.GetKey()]
		if !ok {
			ct.logger.Infof("diffSecurityGroup(): Deleting existing object %#v since its not in apiserver", obj.GetKey())
			evt := kvstore.WatchEvent{
				Type:   kvstore.Deleted,
				Key:    obj.GetKey(),
				Object: &obj.SecurityGroup,
			}
			ct.handleSecurityGroupEvent(&evt)
		}
	}

	// trigger create event for all others
	for _, obj := range objlist {
		ct.logger.Infof("diffSecurityGroup(): Adding object %#v", obj.GetKey())
		evt := kvstore.WatchEvent{
			Type:   kvstore.Created,
			Key:    obj.GetKey(),
			Object: obj,
		}
		ct.handleSecurityGroupEvent(&evt)
	}
}

func (ct *ctrlerCtx) runSecurityGroupWatcher() {
	kind := "SecurityGroup"

	ct.Lock()
	handler, ok := ct.handlers[kind]
	ct.Unlock()
	if !ok {
		ct.logger.Fatalf("Cant find the handler for %s", kind)
	}
	securitygroupHandler := handler.(SecurityGroupHandler)

	opts := securitygroupHandler.GetSecurityGroupWatchOptions()

	// if there is no API server to connect to, we are done
	if (ct.resolver == nil) || ct.apisrvURL == "" {
		return
	}

	// create context
	ctx, cancel := context.WithCancel(context.Background())
	ct.Lock()
	ct.watchCancel[kind] = cancel
	ct.Unlock()
	logger := ct.logger.WithContext("submodule", "SecurityGroupWatcher")

	// create a grpc client
	apiclt, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
	if err == nil {
		ct.diffSecurityGroup(apiclt)
	}

	// setup wait group
	ct.waitGrp.Add(1)

	// start a goroutine
	go func() {
		defer ct.waitGrp.Done()
		ct.stats.Counter("SecurityGroup_Watch").Inc()
		defer ct.stats.Counter("SecurityGroup_Watch").Dec()

		// loop forever
		for {
			// create a grpc client
			apicl, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
			if err != nil {
				logger.Warnf("Failed to connect to gRPC server [%s]\n", ct.apisrvURL)
				ct.stats.Counter("SecurityGroup_ApiClientErr").Inc()
			} else {
				logger.Infof("API client connected {%+v}", apicl)

				// SecurityGroup object watcher
				wt, werr := apicl.SecurityV1().SecurityGroup().Watch(ctx, opts)
				if werr != nil {
					select {
					case <-ctx.Done():
						logger.Infof("watch %s cancelled", kind)
						return
					default:
					}
					logger.Errorf("Failed to start %s watch (%s)\n", kind, werr)
					// wait for a second and retry connecting to api server
					apicl.Close()
					time.Sleep(time.Second)
					continue
				}
				ct.Lock()
				ct.watchers[kind] = wt
				ct.Unlock()

				// perform a diff with API server and local cache
				time.Sleep(time.Millisecond * 100)
				ct.diffSecurityGroup(apicl)

				// handle api server watch events
			innerLoop:
				for {
					// wait for events
					select {
					case evt, ok := <-wt.EventChan():
						if !ok {
							logger.Error("Error receiving from apisrv watcher")
							ct.stats.Counter("SecurityGroup_WatchErrors").Inc()
							break innerLoop
						}

						// handle event in parallel
						ct.handleSecurityGroupEventParallel(evt)
					}
				}
				apicl.Close()
			}

			// if stop flag is set, we are done
			if ct.stoped {
				logger.Infof("Exiting API server watcher")
				return
			}

			// wait for a second and retry connecting to api server
			time.Sleep(time.Second)
		}
	}()
}

// WatchSecurityGroup starts watch on SecurityGroup object
func (ct *ctrlerCtx) WatchSecurityGroup(handler SecurityGroupHandler) error {
	kind := "SecurityGroup"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchers[kind]
	ct.Unlock()
	if ok {
		return fmt.Errorf("SecurityGroup watcher already exists")
	}

	// save handler
	ct.Lock()
	ct.handlers[kind] = handler
	ct.Unlock()

	// run SecurityGroup watcher in a go routine
	ct.runSecurityGroupWatcher()

	return nil
}

// StopWatchSecurityGroup stops watch on SecurityGroup object
func (ct *ctrlerCtx) StopWatchSecurityGroup(handler SecurityGroupHandler) error {
	kind := "SecurityGroup"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchers[kind]
	ct.Unlock()
	if !ok {
		return fmt.Errorf("SecurityGroup watcher does not exist")
	}

	ct.Lock()
	cancel, _ := ct.watchCancel[kind]
	cancel()
	delete(ct.watchers, kind)
	delete(ct.watchCancel, kind)
	ct.Unlock()

	time.Sleep(100 * time.Millisecond)

	return nil
}

// SecurityGroupAPI returns
type SecurityGroupAPI interface {
	Create(obj *security.SecurityGroup) error
	CreateEvent(obj *security.SecurityGroup) error
	Update(obj *security.SecurityGroup) error
	Delete(obj *security.SecurityGroup) error
	Find(meta *api.ObjectMeta) (*SecurityGroup, error)
	List(ctx context.Context, opts *api.ListWatchOptions) ([]*SecurityGroup, error)
	Watch(handler SecurityGroupHandler) error
	StopWatch(handler SecurityGroupHandler) error
}

// dummy struct that implements SecurityGroupAPI
type securitygroupAPI struct {
	ct *ctrlerCtx
}

// Create creates SecurityGroup object
func (api *securitygroupAPI) Create(obj *security.SecurityGroup) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.SecurityV1().SecurityGroup().Create(context.Background(), obj)
		if err != nil && strings.Contains(err.Error(), "AlreadyExists") {
			_, err = apicl.SecurityV1().SecurityGroup().Update(context.Background(), obj)
		}
		return err
	}

	api.ct.handleSecurityGroupEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Created})
	return nil
}

// CreateEvent creates SecurityGroup object and synchronously triggers local event
func (api *securitygroupAPI) CreateEvent(obj *security.SecurityGroup) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.SecurityV1().SecurityGroup().Create(context.Background(), obj)
		if err != nil && strings.Contains(err.Error(), "AlreadyExists") {
			_, err = apicl.SecurityV1().SecurityGroup().Update(context.Background(), obj)
		}
		if err != nil {
			api.ct.logger.Errorf("Error creating object in api server. Err: %v", err)
			return err
		}
		return err
	}

	api.ct.handleSecurityGroupEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Created})
	return nil
}

// Update triggers update on SecurityGroup object
func (api *securitygroupAPI) Update(obj *security.SecurityGroup) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.SecurityV1().SecurityGroup().Update(context.Background(), obj)
		return err
	}

	api.ct.handleSecurityGroupEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Updated})
	return nil
}

// Delete deletes SecurityGroup object
func (api *securitygroupAPI) Delete(obj *security.SecurityGroup) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.SecurityV1().SecurityGroup().Delete(context.Background(), &obj.ObjectMeta)
		return err
	}

	api.ct.handleSecurityGroupEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Deleted})
	return nil
}

// MakeKey generates a KV store key for the object
func (api *securitygroupAPI) getFullKey(tenant, name string) string {
	if tenant != "" {
		return fmt.Sprint(globals.ConfigRootPrefix, "/", "security", "/", "security-groups", "/", tenant, "/", name)
	}
	return fmt.Sprint(globals.ConfigRootPrefix, "/", "security", "/", "security-groups", "/", name)
}

// Find returns an object by meta
func (api *securitygroupAPI) Find(meta *api.ObjectMeta) (*SecurityGroup, error) {
	// find the object
	obj, err := api.ct.FindObject("SecurityGroup", meta)
	if err != nil {
		return nil, err
	}

	// asset type
	switch obj.(type) {
	case *SecurityGroup:
		hobj := obj.(*SecurityGroup)
		return hobj, nil
	default:
		return nil, errors.New("incorrect object type")
	}
}

// List returns a list of all SecurityGroup objects
func (api *securitygroupAPI) List(ctx context.Context, opts *api.ListWatchOptions) ([]*SecurityGroup, error) {
	var objlist []*SecurityGroup
	objs, err := api.ct.List("SecurityGroup", ctx, opts)

	if err != nil {
		return nil, err
	}

	for _, obj := range objs {
		switch tp := obj.(type) {
		case *SecurityGroup:
			eobj := obj.(*SecurityGroup)
			objlist = append(objlist, eobj)
		default:
			log.Fatalf("Got invalid object type %v while looking for SecurityGroup", tp)
		}
	}

	return objlist, nil
}

// Watch sets up a event handlers for SecurityGroup object
func (api *securitygroupAPI) Watch(handler SecurityGroupHandler) error {
	api.ct.startWorkerPool("SecurityGroup")
	return api.ct.WatchSecurityGroup(handler)
}

// StopWatch stop watch for Tenant SecurityGroup object
func (api *securitygroupAPI) StopWatch(handler SecurityGroupHandler) error {
	api.ct.Lock()
	api.ct.workPools["SecurityGroup"].Stop()
	api.ct.Unlock()
	return api.ct.StopWatchSecurityGroup(handler)
}

// SecurityGroup returns SecurityGroupAPI
func (ct *ctrlerCtx) SecurityGroup() SecurityGroupAPI {
	return &securitygroupAPI{ct: ct}
}

// NetworkSecurityPolicy is a wrapper object that implements additional functionality
type NetworkSecurityPolicy struct {
	sync.Mutex
	security.NetworkSecurityPolicy
	HandlerCtx interface{} // additional state handlers can store
	ctrler     *ctrlerCtx  // reference back to the controller instance
}

func (obj *NetworkSecurityPolicy) Write() error {
	// if there is no API server to connect to, we are done
	if (obj.ctrler == nil) || (obj.ctrler.resolver == nil) || obj.ctrler.apisrvURL == "" {
		return nil
	}

	apicl, err := obj.ctrler.apiClient()
	if err != nil {
		obj.ctrler.logger.Errorf("Error creating API server clent. Err: %v", err)
		return err
	}

	obj.ctrler.stats.Counter("NetworkSecurityPolicy_Writes").Inc()

	// write to api server
	if obj.ObjectMeta.ResourceVersion != "" {
		// update it
		for i := 0; i < maxApisrvWriteRetry; i++ {
			_, err = apicl.SecurityV1().NetworkSecurityPolicy().UpdateStatus(context.Background(), &obj.NetworkSecurityPolicy)
			if err == nil {
				break
			}
			time.Sleep(time.Millisecond * 100)
		}
	} else {
		//  create
		_, err = apicl.SecurityV1().NetworkSecurityPolicy().Create(context.Background(), &obj.NetworkSecurityPolicy)
	}

	return nil
}

// NetworkSecurityPolicyHandler is the event handler for NetworkSecurityPolicy object
type NetworkSecurityPolicyHandler interface {
	OnNetworkSecurityPolicyCreate(obj *NetworkSecurityPolicy) error
	OnNetworkSecurityPolicyUpdate(oldObj *NetworkSecurityPolicy, newObj *security.NetworkSecurityPolicy) error
	OnNetworkSecurityPolicyDelete(obj *NetworkSecurityPolicy) error
	GetNetworkSecurityPolicyWatchOptions() *api.ListWatchOptions
}

// OnNetworkSecurityPolicyCreate is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnNetworkSecurityPolicyCreate(obj *NetworkSecurityPolicy) error {
	log.Info("OnNetworkSecurityPolicyCreate is not implemented")
	return nil
}

// OnNetworkSecurityPolicyUpdate is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnNetworkSecurityPolicyUpdate(oldObj *NetworkSecurityPolicy, newObj *security.NetworkSecurityPolicy) error {
	log.Info("OnNetworkSecurityPolicyUpdate is not implemented")
	return nil
}

// OnNetworkSecurityPolicyDelete is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnNetworkSecurityPolicyDelete(obj *NetworkSecurityPolicy) error {
	log.Info("OnNetworkSecurityPolicyDelete is not implemented")
	return nil
}

// GetNetworkSecurityPolicyWatchOptions is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) GetNetworkSecurityPolicyWatchOptions() *api.ListWatchOptions {
	log.Info("GetNetworkSecurityPolicyWatchOptions is not implemented")
	opts := &api.ListWatchOptions{}
	return opts
}

// handleNetworkSecurityPolicyEvent handles NetworkSecurityPolicy events from watcher
func (ct *ctrlerCtx) handleNetworkSecurityPolicyEvent(evt *kvstore.WatchEvent) error {

	if ct.objResolver == nil {
		return ct.handleNetworkSecurityPolicyEventNoResolver(evt)
	}

	switch tp := evt.Object.(type) {
	case *security.NetworkSecurityPolicy:
		eobj := evt.Object.(*security.NetworkSecurityPolicy)
		kind := "NetworkSecurityPolicy"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ctx := &networksecuritypolicyCtx{event: evt.Type,
			obj: &NetworkSecurityPolicy{NetworkSecurityPolicy: *eobj, ctrler: ct}}

		var err error
		switch evt.Type {
		case kvstore.Created:
			err = ct.processAdd(ctx)
		case kvstore.Updated:
			err = ct.processUpdate(ctx)
		case kvstore.Deleted:
			err = ct.processDelete(ctx)
		}
		return err
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on NetworkSecurityPolicy watch channel", tp)
	}

	return nil
}

// handleNetworkSecurityPolicyEventNoResolver handles NetworkSecurityPolicy events from watcher
func (ct *ctrlerCtx) handleNetworkSecurityPolicyEventNoResolver(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *security.NetworkSecurityPolicy:
		eobj := evt.Object.(*security.NetworkSecurityPolicy)
		kind := "NetworkSecurityPolicy"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		networksecuritypolicyHandler := handler.(NetworkSecurityPolicyHandler)
		// handle based on event type
		ctrlCtx := &networksecuritypolicyCtx{event: evt.Type, obj: &NetworkSecurityPolicy{NetworkSecurityPolicy: *eobj, ctrler: ct}}
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			fobj, err := ct.getObject(kind, ctrlCtx.GetKey())
			if err != nil {
				ct.addObject(ctrlCtx)
				ct.stats.Counter("NetworkSecurityPolicy_Created_Events").Inc()

				// call the event handler
				ctrlCtx.Lock()
				err = networksecuritypolicyHandler.OnNetworkSecurityPolicyCreate(ctrlCtx.obj)
				ctrlCtx.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctrlCtx.obj, err)
					ct.delObject(kind, ctrlCtx.GetKey())
					return err
				}
			} else {
				ctrlCtx := fobj.(*networksecuritypolicyCtx)
				ct.stats.Counter("NetworkSecurityPolicy_Updated_Events").Inc()
				ctrlCtx.Lock()
				p := security.NetworkSecurityPolicy{Spec: eobj.Spec,
					ObjectMeta: eobj.ObjectMeta,
					TypeMeta:   eobj.TypeMeta,
					Status:     eobj.Status}

				err = networksecuritypolicyHandler.OnNetworkSecurityPolicyUpdate(ctrlCtx.obj, &p)
				ctrlCtx.obj.NetworkSecurityPolicy = *eobj
				ctrlCtx.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctrlCtx.obj, err)
					return err
				}

			}
		case kvstore.Deleted:
			ctrlCtx := &networksecuritypolicyCtx{event: evt.Type, obj: &NetworkSecurityPolicy{NetworkSecurityPolicy: *eobj, ctrler: ct}}
			fobj, err := ct.findObject(kind, ctrlCtx.GetKey())
			if err != nil {
				ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
				return err
			}

			obj := fobj.(*NetworkSecurityPolicy)
			ct.stats.Counter("NetworkSecurityPolicy_Deleted_Events").Inc()
			obj.Lock()
			err = networksecuritypolicyHandler.OnNetworkSecurityPolicyDelete(obj)
			obj.Unlock()
			if err != nil {
				ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
			}
			ct.delObject(kind, ctrlCtx.GetKey())
			return nil

		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on NetworkSecurityPolicy watch channel", tp)
	}

	return nil
}

type networksecuritypolicyCtx struct {
	ctkitBaseCtx
	event kvstore.WatchEventType
	obj   *NetworkSecurityPolicy //
	//   newObj     *security.NetworkSecurityPolicy //update
	newObj *networksecuritypolicyCtx //update
}

func (ctx *networksecuritypolicyCtx) References() map[string]apiintf.ReferenceObj {
	resp := make(map[string]apiintf.ReferenceObj)
	ctx.obj.References(ctx.obj.GetObjectMeta().Name, ctx.obj.GetObjectMeta().Namespace, resp)
	return resp
}

func (ctx *networksecuritypolicyCtx) GetKey() string {
	return ctx.obj.MakeKey("security")
}

func (ctx *networksecuritypolicyCtx) GetKind() string {
	return ctx.obj.GetKind()
}

func (ctx *networksecuritypolicyCtx) SetEvent(event kvstore.WatchEventType) {
	ctx.event = event
}

func (ctx *networksecuritypolicyCtx) SetNewObj(newObj apiintf.CtkitObject) {
	if newObj == nil {
		ctx.newObj = nil
	} else {
		ctx.newObj = newObj.(*networksecuritypolicyCtx)
		ctx.newObj.obj.HandlerCtx = ctx.obj.HandlerCtx
	}
}

func (ctx *networksecuritypolicyCtx) GetNewObj() apiintf.CtkitObject {
	return ctx.newObj
}

func (ctx *networksecuritypolicyCtx) Copy(obj apiintf.CtkitObject) {
	ctx.obj.NetworkSecurityPolicy = obj.(*networksecuritypolicyCtx).obj.NetworkSecurityPolicy
}

func (ctx *networksecuritypolicyCtx) Lock() {
	ctx.obj.Lock()
}

func (ctx *networksecuritypolicyCtx) Unlock() {
	ctx.obj.Unlock()
}

func (ctx *networksecuritypolicyCtx) GetObjectMeta() *api.ObjectMeta {
	return ctx.obj.GetObjectMeta()
}

func (ctx *networksecuritypolicyCtx) RuntimeObject() runtime.Object {
	var v interface{}
	v = ctx.obj
	return v.(runtime.Object)
}

func (ctx *networksecuritypolicyCtx) WorkFunc(context context.Context) error {
	var err error
	evt := ctx.event
	ct := ctx.obj.ctrler
	kind := "NetworkSecurityPolicy"
	ct.Lock()
	handler, ok := ct.handlers[kind]
	ct.Unlock()
	if !ok {
		ct.logger.Fatalf("Cant find the handler for %s", kind)
	}
	networksecuritypolicyHandler := handler.(NetworkSecurityPolicyHandler)
	switch evt {
	case kvstore.Created:
		ctx.obj.Lock()
		err = networksecuritypolicyHandler.OnNetworkSecurityPolicyCreate(ctx.obj)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctx.obj, err)
			ctx.SetEvent(kvstore.Deleted)
		}
	case kvstore.Updated:
		ct.stats.Counter("NetworkSecurityPolicy_Updated_Events").Inc()
		ctx.obj.Lock()
		p := security.NetworkSecurityPolicy{Spec: ctx.newObj.obj.Spec,
			ObjectMeta: ctx.newObj.obj.ObjectMeta,
			TypeMeta:   ctx.newObj.obj.TypeMeta,
			Status:     ctx.newObj.obj.Status}
		err = networksecuritypolicyHandler.OnNetworkSecurityPolicyUpdate(ctx.obj, &p)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctx.obj, err)
			ctx.SetEvent(kvstore.Deleted)
		}
	case kvstore.Deleted:
		ctx.obj.Lock()
		err = networksecuritypolicyHandler.OnNetworkSecurityPolicyDelete(ctx.obj)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error deleting %s %+v. Err: %v", kind, ctx.obj, err)
		}
	}
	ct.resolveObject(ctx.event, ctx)
	return nil
}

// handleNetworkSecurityPolicyEventParallel handles NetworkSecurityPolicy events from watcher
func (ct *ctrlerCtx) handleNetworkSecurityPolicyEventParallel(evt *kvstore.WatchEvent) error {

	if ct.objResolver == nil {
		return ct.handleNetworkSecurityPolicyEventParallelWithNoResolver(evt)
	}

	switch tp := evt.Object.(type) {
	case *security.NetworkSecurityPolicy:
		eobj := evt.Object.(*security.NetworkSecurityPolicy)
		kind := "NetworkSecurityPolicy"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ctx := &networksecuritypolicyCtx{event: evt.Type, obj: &NetworkSecurityPolicy{NetworkSecurityPolicy: *eobj, ctrler: ct}}

		var err error
		switch evt.Type {
		case kvstore.Created:
			err = ct.processAdd(ctx)
		case kvstore.Updated:
			err = ct.processUpdate(ctx)
		case kvstore.Deleted:
			err = ct.processDelete(ctx)
		}
		return err
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on NetworkSecurityPolicy watch channel", tp)
	}

	return nil
}

// handleNetworkSecurityPolicyEventParallel handles NetworkSecurityPolicy events from watcher
func (ct *ctrlerCtx) handleNetworkSecurityPolicyEventParallelWithNoResolver(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *security.NetworkSecurityPolicy:
		eobj := evt.Object.(*security.NetworkSecurityPolicy)
		kind := "NetworkSecurityPolicy"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		networksecuritypolicyHandler := handler.(NetworkSecurityPolicyHandler)
		// handle based on event type
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			workFunc := func(ctx context.Context, ctrlCtx shardworkers.WorkObj) error {
				var err error
				workCtx := ctrlCtx.(*networksecuritypolicyCtx)
				eobj := workCtx.obj
				fobj, err := ct.getObject(kind, workCtx.GetKey())
				if err != nil {
					ct.addObject(workCtx)
					ct.stats.Counter("NetworkSecurityPolicy_Created_Events").Inc()
					eobj.Lock()
					err = networksecuritypolicyHandler.OnNetworkSecurityPolicyCreate(eobj)
					eobj.Unlock()
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, eobj, err)
						ct.delObject(kind, workCtx.GetKey())
					}
				} else {
					workCtx := fobj.(*networksecuritypolicyCtx)
					obj := workCtx.obj
					ct.stats.Counter("NetworkSecurityPolicy_Updated_Events").Inc()
					obj.Lock()
					p := security.NetworkSecurityPolicy{Spec: eobj.Spec,
						ObjectMeta: eobj.ObjectMeta,
						TypeMeta:   eobj.TypeMeta,
						Status:     eobj.Status}

					err = networksecuritypolicyHandler.OnNetworkSecurityPolicyUpdate(obj, &p)
					workCtx.obj.NetworkSecurityPolicy = p
					obj.Unlock()
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					}
				}
				return err
			}
			ctrlCtx := &networksecuritypolicyCtx{event: evt.Type, obj: &NetworkSecurityPolicy{NetworkSecurityPolicy: *eobj, ctrler: ct}}
			ct.runFunction("NetworkSecurityPolicy", ctrlCtx, workFunc)
		case kvstore.Deleted:
			workFunc := func(ctx context.Context, ctrlCtx shardworkers.WorkObj) error {
				var err error
				workCtx := ctrlCtx.(*networksecuritypolicyCtx)
				eobj := workCtx.obj
				fobj, err := ct.findObject(kind, workCtx.GetKey())
				if err != nil {
					ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
					return err
				}
				obj := fobj.(*NetworkSecurityPolicy)
				ct.stats.Counter("NetworkSecurityPolicy_Deleted_Events").Inc()
				obj.Lock()
				err = networksecuritypolicyHandler.OnNetworkSecurityPolicyDelete(obj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
				}
				ct.delObject(kind, workCtx.GetKey())
				return nil
			}
			ctrlCtx := &networksecuritypolicyCtx{event: evt.Type, obj: &NetworkSecurityPolicy{NetworkSecurityPolicy: *eobj, ctrler: ct}}
			ct.runFunction("NetworkSecurityPolicy", ctrlCtx, workFunc)
		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on NetworkSecurityPolicy watch channel", tp)
	}

	return nil
}

// diffNetworkSecurityPolicy does a diff of NetworkSecurityPolicy objects between local cache and API server
func (ct *ctrlerCtx) diffNetworkSecurityPolicy(apicl apiclient.Services) {
	opts := api.ListWatchOptions{}

	// get a list of all objects from API server
	objlist, err := apicl.SecurityV1().NetworkSecurityPolicy().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Errorf("Error getting a list of objects. Err: %v", err)
		return
	}

	ct.logger.Infof("diffNetworkSecurityPolicy(): NetworkSecurityPolicyList returned %d objects", len(objlist))

	// build an object map
	objmap := make(map[string]*security.NetworkSecurityPolicy)
	for _, obj := range objlist {
		objmap[obj.GetKey()] = obj
	}

	list, err := ct.NetworkSecurityPolicy().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Infof("Failed to get a list of objects. Err: %s", err)
		return
	}

	// if an object is in our local cache and not in API server, trigger delete for it
	for _, obj := range list {
		_, ok := objmap[obj.GetKey()]
		if !ok {
			ct.logger.Infof("diffNetworkSecurityPolicy(): Deleting existing object %#v since its not in apiserver", obj.GetKey())
			evt := kvstore.WatchEvent{
				Type:   kvstore.Deleted,
				Key:    obj.GetKey(),
				Object: &obj.NetworkSecurityPolicy,
			}
			ct.handleNetworkSecurityPolicyEvent(&evt)
		}
	}

	// trigger create event for all others
	for _, obj := range objlist {
		ct.logger.Infof("diffNetworkSecurityPolicy(): Adding object %#v", obj.GetKey())
		evt := kvstore.WatchEvent{
			Type:   kvstore.Created,
			Key:    obj.GetKey(),
			Object: obj,
		}
		ct.handleNetworkSecurityPolicyEvent(&evt)
	}
}

func (ct *ctrlerCtx) runNetworkSecurityPolicyWatcher() {
	kind := "NetworkSecurityPolicy"

	ct.Lock()
	handler, ok := ct.handlers[kind]
	ct.Unlock()
	if !ok {
		ct.logger.Fatalf("Cant find the handler for %s", kind)
	}
	networksecuritypolicyHandler := handler.(NetworkSecurityPolicyHandler)

	opts := networksecuritypolicyHandler.GetNetworkSecurityPolicyWatchOptions()

	// if there is no API server to connect to, we are done
	if (ct.resolver == nil) || ct.apisrvURL == "" {
		return
	}

	// create context
	ctx, cancel := context.WithCancel(context.Background())
	ct.Lock()
	ct.watchCancel[kind] = cancel
	ct.Unlock()
	logger := ct.logger.WithContext("submodule", "NetworkSecurityPolicyWatcher")

	// create a grpc client
	apiclt, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
	if err == nil {
		ct.diffNetworkSecurityPolicy(apiclt)
	}

	// setup wait group
	ct.waitGrp.Add(1)

	// start a goroutine
	go func() {
		defer ct.waitGrp.Done()
		ct.stats.Counter("NetworkSecurityPolicy_Watch").Inc()
		defer ct.stats.Counter("NetworkSecurityPolicy_Watch").Dec()

		// loop forever
		for {
			// create a grpc client
			apicl, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
			if err != nil {
				logger.Warnf("Failed to connect to gRPC server [%s]\n", ct.apisrvURL)
				ct.stats.Counter("NetworkSecurityPolicy_ApiClientErr").Inc()
			} else {
				logger.Infof("API client connected {%+v}", apicl)

				// NetworkSecurityPolicy object watcher
				wt, werr := apicl.SecurityV1().NetworkSecurityPolicy().Watch(ctx, opts)
				if werr != nil {
					select {
					case <-ctx.Done():
						logger.Infof("watch %s cancelled", kind)
						return
					default:
					}
					logger.Errorf("Failed to start %s watch (%s)\n", kind, werr)
					// wait for a second and retry connecting to api server
					apicl.Close()
					time.Sleep(time.Second)
					continue
				}
				ct.Lock()
				ct.watchers[kind] = wt
				ct.Unlock()

				// perform a diff with API server and local cache
				time.Sleep(time.Millisecond * 100)
				ct.diffNetworkSecurityPolicy(apicl)

				// handle api server watch events
			innerLoop:
				for {
					// wait for events
					select {
					case evt, ok := <-wt.EventChan():
						if !ok {
							logger.Error("Error receiving from apisrv watcher")
							ct.stats.Counter("NetworkSecurityPolicy_WatchErrors").Inc()
							break innerLoop
						}

						// handle event in parallel
						ct.handleNetworkSecurityPolicyEventParallel(evt)
					}
				}
				apicl.Close()
			}

			// if stop flag is set, we are done
			if ct.stoped {
				logger.Infof("Exiting API server watcher")
				return
			}

			// wait for a second and retry connecting to api server
			time.Sleep(time.Second)
		}
	}()
}

// WatchNetworkSecurityPolicy starts watch on NetworkSecurityPolicy object
func (ct *ctrlerCtx) WatchNetworkSecurityPolicy(handler NetworkSecurityPolicyHandler) error {
	kind := "NetworkSecurityPolicy"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchers[kind]
	ct.Unlock()
	if ok {
		return fmt.Errorf("NetworkSecurityPolicy watcher already exists")
	}

	// save handler
	ct.Lock()
	ct.handlers[kind] = handler
	ct.Unlock()

	// run NetworkSecurityPolicy watcher in a go routine
	ct.runNetworkSecurityPolicyWatcher()

	return nil
}

// StopWatchNetworkSecurityPolicy stops watch on NetworkSecurityPolicy object
func (ct *ctrlerCtx) StopWatchNetworkSecurityPolicy(handler NetworkSecurityPolicyHandler) error {
	kind := "NetworkSecurityPolicy"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchers[kind]
	ct.Unlock()
	if !ok {
		return fmt.Errorf("NetworkSecurityPolicy watcher does not exist")
	}

	ct.Lock()
	cancel, _ := ct.watchCancel[kind]
	cancel()
	delete(ct.watchers, kind)
	delete(ct.watchCancel, kind)
	ct.Unlock()

	time.Sleep(100 * time.Millisecond)

	return nil
}

// NetworkSecurityPolicyAPI returns
type NetworkSecurityPolicyAPI interface {
	Create(obj *security.NetworkSecurityPolicy) error
	CreateEvent(obj *security.NetworkSecurityPolicy) error
	Update(obj *security.NetworkSecurityPolicy) error
	Delete(obj *security.NetworkSecurityPolicy) error
	Find(meta *api.ObjectMeta) (*NetworkSecurityPolicy, error)
	List(ctx context.Context, opts *api.ListWatchOptions) ([]*NetworkSecurityPolicy, error)
	Watch(handler NetworkSecurityPolicyHandler) error
	StopWatch(handler NetworkSecurityPolicyHandler) error
}

// dummy struct that implements NetworkSecurityPolicyAPI
type networksecuritypolicyAPI struct {
	ct *ctrlerCtx
}

// Create creates NetworkSecurityPolicy object
func (api *networksecuritypolicyAPI) Create(obj *security.NetworkSecurityPolicy) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.SecurityV1().NetworkSecurityPolicy().Create(context.Background(), obj)
		if err != nil && strings.Contains(err.Error(), "AlreadyExists") {
			_, err = apicl.SecurityV1().NetworkSecurityPolicy().Update(context.Background(), obj)
		}
		return err
	}

	api.ct.handleNetworkSecurityPolicyEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Created})
	return nil
}

// CreateEvent creates NetworkSecurityPolicy object and synchronously triggers local event
func (api *networksecuritypolicyAPI) CreateEvent(obj *security.NetworkSecurityPolicy) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.SecurityV1().NetworkSecurityPolicy().Create(context.Background(), obj)
		if err != nil && strings.Contains(err.Error(), "AlreadyExists") {
			_, err = apicl.SecurityV1().NetworkSecurityPolicy().Update(context.Background(), obj)
		}
		if err != nil {
			api.ct.logger.Errorf("Error creating object in api server. Err: %v", err)
			return err
		}
		return err
	}

	api.ct.handleNetworkSecurityPolicyEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Created})
	return nil
}

// Update triggers update on NetworkSecurityPolicy object
func (api *networksecuritypolicyAPI) Update(obj *security.NetworkSecurityPolicy) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.SecurityV1().NetworkSecurityPolicy().Update(context.Background(), obj)
		return err
	}

	api.ct.handleNetworkSecurityPolicyEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Updated})
	return nil
}

// Delete deletes NetworkSecurityPolicy object
func (api *networksecuritypolicyAPI) Delete(obj *security.NetworkSecurityPolicy) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.SecurityV1().NetworkSecurityPolicy().Delete(context.Background(), &obj.ObjectMeta)
		return err
	}

	api.ct.handleNetworkSecurityPolicyEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Deleted})
	return nil
}

// MakeKey generates a KV store key for the object
func (api *networksecuritypolicyAPI) getFullKey(tenant, name string) string {
	if tenant != "" {
		return fmt.Sprint(globals.ConfigRootPrefix, "/", "security", "/", "networksecuritypolicies", "/", tenant, "/", name)
	}
	return fmt.Sprint(globals.ConfigRootPrefix, "/", "security", "/", "networksecuritypolicies", "/", name)
}

// Find returns an object by meta
func (api *networksecuritypolicyAPI) Find(meta *api.ObjectMeta) (*NetworkSecurityPolicy, error) {
	// find the object
	obj, err := api.ct.FindObject("NetworkSecurityPolicy", meta)
	if err != nil {
		return nil, err
	}

	// asset type
	switch obj.(type) {
	case *NetworkSecurityPolicy:
		hobj := obj.(*NetworkSecurityPolicy)
		return hobj, nil
	default:
		return nil, errors.New("incorrect object type")
	}
}

// List returns a list of all NetworkSecurityPolicy objects
func (api *networksecuritypolicyAPI) List(ctx context.Context, opts *api.ListWatchOptions) ([]*NetworkSecurityPolicy, error) {
	var objlist []*NetworkSecurityPolicy
	objs, err := api.ct.List("NetworkSecurityPolicy", ctx, opts)

	if err != nil {
		return nil, err
	}

	for _, obj := range objs {
		switch tp := obj.(type) {
		case *NetworkSecurityPolicy:
			eobj := obj.(*NetworkSecurityPolicy)
			objlist = append(objlist, eobj)
		default:
			log.Fatalf("Got invalid object type %v while looking for NetworkSecurityPolicy", tp)
		}
	}

	return objlist, nil
}

// Watch sets up a event handlers for NetworkSecurityPolicy object
func (api *networksecuritypolicyAPI) Watch(handler NetworkSecurityPolicyHandler) error {
	api.ct.startWorkerPool("NetworkSecurityPolicy")
	return api.ct.WatchNetworkSecurityPolicy(handler)
}

// StopWatch stop watch for Tenant NetworkSecurityPolicy object
func (api *networksecuritypolicyAPI) StopWatch(handler NetworkSecurityPolicyHandler) error {
	api.ct.Lock()
	api.ct.workPools["NetworkSecurityPolicy"].Stop()
	api.ct.Unlock()
	return api.ct.StopWatchNetworkSecurityPolicy(handler)
}

// NetworkSecurityPolicy returns NetworkSecurityPolicyAPI
func (ct *ctrlerCtx) NetworkSecurityPolicy() NetworkSecurityPolicyAPI {
	return &networksecuritypolicyAPI{ct: ct}
}

// App is a wrapper object that implements additional functionality
type App struct {
	sync.Mutex
	security.App
	HandlerCtx interface{} // additional state handlers can store
	ctrler     *ctrlerCtx  // reference back to the controller instance
}

func (obj *App) Write() error {
	// if there is no API server to connect to, we are done
	if (obj.ctrler == nil) || (obj.ctrler.resolver == nil) || obj.ctrler.apisrvURL == "" {
		return nil
	}

	apicl, err := obj.ctrler.apiClient()
	if err != nil {
		obj.ctrler.logger.Errorf("Error creating API server clent. Err: %v", err)
		return err
	}

	obj.ctrler.stats.Counter("App_Writes").Inc()

	// write to api server
	if obj.ObjectMeta.ResourceVersion != "" {
		// update it
		for i := 0; i < maxApisrvWriteRetry; i++ {
			_, err = apicl.SecurityV1().App().UpdateStatus(context.Background(), &obj.App)
			if err == nil {
				break
			}
			time.Sleep(time.Millisecond * 100)
		}
	} else {
		//  create
		_, err = apicl.SecurityV1().App().Create(context.Background(), &obj.App)
	}

	return nil
}

// AppHandler is the event handler for App object
type AppHandler interface {
	OnAppCreate(obj *App) error
	OnAppUpdate(oldObj *App, newObj *security.App) error
	OnAppDelete(obj *App) error
	GetAppWatchOptions() *api.ListWatchOptions
}

// OnAppCreate is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnAppCreate(obj *App) error {
	log.Info("OnAppCreate is not implemented")
	return nil
}

// OnAppUpdate is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnAppUpdate(oldObj *App, newObj *security.App) error {
	log.Info("OnAppUpdate is not implemented")
	return nil
}

// OnAppDelete is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnAppDelete(obj *App) error {
	log.Info("OnAppDelete is not implemented")
	return nil
}

// GetAppWatchOptions is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) GetAppWatchOptions() *api.ListWatchOptions {
	log.Info("GetAppWatchOptions is not implemented")
	opts := &api.ListWatchOptions{}
	return opts
}

// handleAppEvent handles App events from watcher
func (ct *ctrlerCtx) handleAppEvent(evt *kvstore.WatchEvent) error {

	if ct.objResolver == nil {
		return ct.handleAppEventNoResolver(evt)
	}

	switch tp := evt.Object.(type) {
	case *security.App:
		eobj := evt.Object.(*security.App)
		kind := "App"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ctx := &appCtx{event: evt.Type,
			obj: &App{App: *eobj, ctrler: ct}}

		var err error
		switch evt.Type {
		case kvstore.Created:
			err = ct.processAdd(ctx)
		case kvstore.Updated:
			err = ct.processUpdate(ctx)
		case kvstore.Deleted:
			err = ct.processDelete(ctx)
		}
		return err
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on App watch channel", tp)
	}

	return nil
}

// handleAppEventNoResolver handles App events from watcher
func (ct *ctrlerCtx) handleAppEventNoResolver(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *security.App:
		eobj := evt.Object.(*security.App)
		kind := "App"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		appHandler := handler.(AppHandler)
		// handle based on event type
		ctrlCtx := &appCtx{event: evt.Type, obj: &App{App: *eobj, ctrler: ct}}
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			fobj, err := ct.getObject(kind, ctrlCtx.GetKey())
			if err != nil {
				ct.addObject(ctrlCtx)
				ct.stats.Counter("App_Created_Events").Inc()

				// call the event handler
				ctrlCtx.Lock()
				err = appHandler.OnAppCreate(ctrlCtx.obj)
				ctrlCtx.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctrlCtx.obj, err)
					ct.delObject(kind, ctrlCtx.GetKey())
					return err
				}
			} else {
				ctrlCtx := fobj.(*appCtx)
				ct.stats.Counter("App_Updated_Events").Inc()
				ctrlCtx.Lock()
				p := security.App{Spec: eobj.Spec,
					ObjectMeta: eobj.ObjectMeta,
					TypeMeta:   eobj.TypeMeta,
					Status:     eobj.Status}

				err = appHandler.OnAppUpdate(ctrlCtx.obj, &p)
				ctrlCtx.obj.App = *eobj
				ctrlCtx.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctrlCtx.obj, err)
					return err
				}

			}
		case kvstore.Deleted:
			ctrlCtx := &appCtx{event: evt.Type, obj: &App{App: *eobj, ctrler: ct}}
			fobj, err := ct.findObject(kind, ctrlCtx.GetKey())
			if err != nil {
				ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
				return err
			}

			obj := fobj.(*App)
			ct.stats.Counter("App_Deleted_Events").Inc()
			obj.Lock()
			err = appHandler.OnAppDelete(obj)
			obj.Unlock()
			if err != nil {
				ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
			}
			ct.delObject(kind, ctrlCtx.GetKey())
			return nil

		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on App watch channel", tp)
	}

	return nil
}

type appCtx struct {
	ctkitBaseCtx
	event kvstore.WatchEventType
	obj   *App //
	//   newObj     *security.App //update
	newObj *appCtx //update
}

func (ctx *appCtx) References() map[string]apiintf.ReferenceObj {
	resp := make(map[string]apiintf.ReferenceObj)
	ctx.obj.References(ctx.obj.GetObjectMeta().Name, ctx.obj.GetObjectMeta().Namespace, resp)
	return resp
}

func (ctx *appCtx) GetKey() string {
	return ctx.obj.MakeKey("security")
}

func (ctx *appCtx) GetKind() string {
	return ctx.obj.GetKind()
}

func (ctx *appCtx) SetEvent(event kvstore.WatchEventType) {
	ctx.event = event
}

func (ctx *appCtx) SetNewObj(newObj apiintf.CtkitObject) {
	if newObj == nil {
		ctx.newObj = nil
	} else {
		ctx.newObj = newObj.(*appCtx)
		ctx.newObj.obj.HandlerCtx = ctx.obj.HandlerCtx
	}
}

func (ctx *appCtx) GetNewObj() apiintf.CtkitObject {
	return ctx.newObj
}

func (ctx *appCtx) Copy(obj apiintf.CtkitObject) {
	ctx.obj.App = obj.(*appCtx).obj.App
}

func (ctx *appCtx) Lock() {
	ctx.obj.Lock()
}

func (ctx *appCtx) Unlock() {
	ctx.obj.Unlock()
}

func (ctx *appCtx) GetObjectMeta() *api.ObjectMeta {
	return ctx.obj.GetObjectMeta()
}

func (ctx *appCtx) RuntimeObject() runtime.Object {
	var v interface{}
	v = ctx.obj
	return v.(runtime.Object)
}

func (ctx *appCtx) WorkFunc(context context.Context) error {
	var err error
	evt := ctx.event
	ct := ctx.obj.ctrler
	kind := "App"
	ct.Lock()
	handler, ok := ct.handlers[kind]
	ct.Unlock()
	if !ok {
		ct.logger.Fatalf("Cant find the handler for %s", kind)
	}
	appHandler := handler.(AppHandler)
	switch evt {
	case kvstore.Created:
		ctx.obj.Lock()
		err = appHandler.OnAppCreate(ctx.obj)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctx.obj, err)
			ctx.SetEvent(kvstore.Deleted)
		}
	case kvstore.Updated:
		ct.stats.Counter("App_Updated_Events").Inc()
		ctx.obj.Lock()
		p := security.App{Spec: ctx.newObj.obj.Spec,
			ObjectMeta: ctx.newObj.obj.ObjectMeta,
			TypeMeta:   ctx.newObj.obj.TypeMeta,
			Status:     ctx.newObj.obj.Status}
		err = appHandler.OnAppUpdate(ctx.obj, &p)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctx.obj, err)
			ctx.SetEvent(kvstore.Deleted)
		}
	case kvstore.Deleted:
		ctx.obj.Lock()
		err = appHandler.OnAppDelete(ctx.obj)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error deleting %s %+v. Err: %v", kind, ctx.obj, err)
		}
	}
	ct.resolveObject(ctx.event, ctx)
	return nil
}

// handleAppEventParallel handles App events from watcher
func (ct *ctrlerCtx) handleAppEventParallel(evt *kvstore.WatchEvent) error {

	if ct.objResolver == nil {
		return ct.handleAppEventParallelWithNoResolver(evt)
	}

	switch tp := evt.Object.(type) {
	case *security.App:
		eobj := evt.Object.(*security.App)
		kind := "App"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ctx := &appCtx{event: evt.Type, obj: &App{App: *eobj, ctrler: ct}}

		var err error
		switch evt.Type {
		case kvstore.Created:
			err = ct.processAdd(ctx)
		case kvstore.Updated:
			err = ct.processUpdate(ctx)
		case kvstore.Deleted:
			err = ct.processDelete(ctx)
		}
		return err
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on App watch channel", tp)
	}

	return nil
}

// handleAppEventParallel handles App events from watcher
func (ct *ctrlerCtx) handleAppEventParallelWithNoResolver(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *security.App:
		eobj := evt.Object.(*security.App)
		kind := "App"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		appHandler := handler.(AppHandler)
		// handle based on event type
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			workFunc := func(ctx context.Context, ctrlCtx shardworkers.WorkObj) error {
				var err error
				workCtx := ctrlCtx.(*appCtx)
				eobj := workCtx.obj
				fobj, err := ct.getObject(kind, workCtx.GetKey())
				if err != nil {
					ct.addObject(workCtx)
					ct.stats.Counter("App_Created_Events").Inc()
					eobj.Lock()
					err = appHandler.OnAppCreate(eobj)
					eobj.Unlock()
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, eobj, err)
						ct.delObject(kind, workCtx.GetKey())
					}
				} else {
					workCtx := fobj.(*appCtx)
					obj := workCtx.obj
					ct.stats.Counter("App_Updated_Events").Inc()
					obj.Lock()
					p := security.App{Spec: eobj.Spec,
						ObjectMeta: eobj.ObjectMeta,
						TypeMeta:   eobj.TypeMeta,
						Status:     eobj.Status}

					err = appHandler.OnAppUpdate(obj, &p)
					workCtx.obj.App = p
					obj.Unlock()
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					}
				}
				return err
			}
			ctrlCtx := &appCtx{event: evt.Type, obj: &App{App: *eobj, ctrler: ct}}
			ct.runFunction("App", ctrlCtx, workFunc)
		case kvstore.Deleted:
			workFunc := func(ctx context.Context, ctrlCtx shardworkers.WorkObj) error {
				var err error
				workCtx := ctrlCtx.(*appCtx)
				eobj := workCtx.obj
				fobj, err := ct.findObject(kind, workCtx.GetKey())
				if err != nil {
					ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
					return err
				}
				obj := fobj.(*App)
				ct.stats.Counter("App_Deleted_Events").Inc()
				obj.Lock()
				err = appHandler.OnAppDelete(obj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
				}
				ct.delObject(kind, workCtx.GetKey())
				return nil
			}
			ctrlCtx := &appCtx{event: evt.Type, obj: &App{App: *eobj, ctrler: ct}}
			ct.runFunction("App", ctrlCtx, workFunc)
		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on App watch channel", tp)
	}

	return nil
}

// diffApp does a diff of App objects between local cache and API server
func (ct *ctrlerCtx) diffApp(apicl apiclient.Services) {
	opts := api.ListWatchOptions{}

	// get a list of all objects from API server
	objlist, err := apicl.SecurityV1().App().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Errorf("Error getting a list of objects. Err: %v", err)
		return
	}

	ct.logger.Infof("diffApp(): AppList returned %d objects", len(objlist))

	// build an object map
	objmap := make(map[string]*security.App)
	for _, obj := range objlist {
		objmap[obj.GetKey()] = obj
	}

	list, err := ct.App().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Infof("Failed to get a list of objects. Err: %s", err)
		return
	}

	// if an object is in our local cache and not in API server, trigger delete for it
	for _, obj := range list {
		_, ok := objmap[obj.GetKey()]
		if !ok {
			ct.logger.Infof("diffApp(): Deleting existing object %#v since its not in apiserver", obj.GetKey())
			evt := kvstore.WatchEvent{
				Type:   kvstore.Deleted,
				Key:    obj.GetKey(),
				Object: &obj.App,
			}
			ct.handleAppEvent(&evt)
		}
	}

	// trigger create event for all others
	for _, obj := range objlist {
		ct.logger.Infof("diffApp(): Adding object %#v", obj.GetKey())
		evt := kvstore.WatchEvent{
			Type:   kvstore.Created,
			Key:    obj.GetKey(),
			Object: obj,
		}
		ct.handleAppEvent(&evt)
	}
}

func (ct *ctrlerCtx) runAppWatcher() {
	kind := "App"

	ct.Lock()
	handler, ok := ct.handlers[kind]
	ct.Unlock()
	if !ok {
		ct.logger.Fatalf("Cant find the handler for %s", kind)
	}
	appHandler := handler.(AppHandler)

	opts := appHandler.GetAppWatchOptions()

	// if there is no API server to connect to, we are done
	if (ct.resolver == nil) || ct.apisrvURL == "" {
		return
	}

	// create context
	ctx, cancel := context.WithCancel(context.Background())
	ct.Lock()
	ct.watchCancel[kind] = cancel
	ct.Unlock()
	logger := ct.logger.WithContext("submodule", "AppWatcher")

	// create a grpc client
	apiclt, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
	if err == nil {
		ct.diffApp(apiclt)
	}

	// setup wait group
	ct.waitGrp.Add(1)

	// start a goroutine
	go func() {
		defer ct.waitGrp.Done()
		ct.stats.Counter("App_Watch").Inc()
		defer ct.stats.Counter("App_Watch").Dec()

		// loop forever
		for {
			// create a grpc client
			apicl, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
			if err != nil {
				logger.Warnf("Failed to connect to gRPC server [%s]\n", ct.apisrvURL)
				ct.stats.Counter("App_ApiClientErr").Inc()
			} else {
				logger.Infof("API client connected {%+v}", apicl)

				// App object watcher
				wt, werr := apicl.SecurityV1().App().Watch(ctx, opts)
				if werr != nil {
					select {
					case <-ctx.Done():
						logger.Infof("watch %s cancelled", kind)
						return
					default:
					}
					logger.Errorf("Failed to start %s watch (%s)\n", kind, werr)
					// wait for a second and retry connecting to api server
					apicl.Close()
					time.Sleep(time.Second)
					continue
				}
				ct.Lock()
				ct.watchers[kind] = wt
				ct.Unlock()

				// perform a diff with API server and local cache
				time.Sleep(time.Millisecond * 100)
				ct.diffApp(apicl)

				// handle api server watch events
			innerLoop:
				for {
					// wait for events
					select {
					case evt, ok := <-wt.EventChan():
						if !ok {
							logger.Error("Error receiving from apisrv watcher")
							ct.stats.Counter("App_WatchErrors").Inc()
							break innerLoop
						}

						// handle event in parallel
						ct.handleAppEventParallel(evt)
					}
				}
				apicl.Close()
			}

			// if stop flag is set, we are done
			if ct.stoped {
				logger.Infof("Exiting API server watcher")
				return
			}

			// wait for a second and retry connecting to api server
			time.Sleep(time.Second)
		}
	}()
}

// WatchApp starts watch on App object
func (ct *ctrlerCtx) WatchApp(handler AppHandler) error {
	kind := "App"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchers[kind]
	ct.Unlock()
	if ok {
		return fmt.Errorf("App watcher already exists")
	}

	// save handler
	ct.Lock()
	ct.handlers[kind] = handler
	ct.Unlock()

	// run App watcher in a go routine
	ct.runAppWatcher()

	return nil
}

// StopWatchApp stops watch on App object
func (ct *ctrlerCtx) StopWatchApp(handler AppHandler) error {
	kind := "App"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchers[kind]
	ct.Unlock()
	if !ok {
		return fmt.Errorf("App watcher does not exist")
	}

	ct.Lock()
	cancel, _ := ct.watchCancel[kind]
	cancel()
	delete(ct.watchers, kind)
	delete(ct.watchCancel, kind)
	ct.Unlock()

	time.Sleep(100 * time.Millisecond)

	return nil
}

// AppAPI returns
type AppAPI interface {
	Create(obj *security.App) error
	CreateEvent(obj *security.App) error
	Update(obj *security.App) error
	Delete(obj *security.App) error
	Find(meta *api.ObjectMeta) (*App, error)
	List(ctx context.Context, opts *api.ListWatchOptions) ([]*App, error)
	Watch(handler AppHandler) error
	StopWatch(handler AppHandler) error
}

// dummy struct that implements AppAPI
type appAPI struct {
	ct *ctrlerCtx
}

// Create creates App object
func (api *appAPI) Create(obj *security.App) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.SecurityV1().App().Create(context.Background(), obj)
		if err != nil && strings.Contains(err.Error(), "AlreadyExists") {
			_, err = apicl.SecurityV1().App().Update(context.Background(), obj)
		}
		return err
	}

	api.ct.handleAppEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Created})
	return nil
}

// CreateEvent creates App object and synchronously triggers local event
func (api *appAPI) CreateEvent(obj *security.App) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.SecurityV1().App().Create(context.Background(), obj)
		if err != nil && strings.Contains(err.Error(), "AlreadyExists") {
			_, err = apicl.SecurityV1().App().Update(context.Background(), obj)
		}
		if err != nil {
			api.ct.logger.Errorf("Error creating object in api server. Err: %v", err)
			return err
		}
		return err
	}

	api.ct.handleAppEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Created})
	return nil
}

// Update triggers update on App object
func (api *appAPI) Update(obj *security.App) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.SecurityV1().App().Update(context.Background(), obj)
		return err
	}

	api.ct.handleAppEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Updated})
	return nil
}

// Delete deletes App object
func (api *appAPI) Delete(obj *security.App) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.SecurityV1().App().Delete(context.Background(), &obj.ObjectMeta)
		return err
	}

	api.ct.handleAppEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Deleted})
	return nil
}

// MakeKey generates a KV store key for the object
func (api *appAPI) getFullKey(tenant, name string) string {
	if tenant != "" {
		return fmt.Sprint(globals.ConfigRootPrefix, "/", "security", "/", "apps", "/", tenant, "/", name)
	}
	return fmt.Sprint(globals.ConfigRootPrefix, "/", "security", "/", "apps", "/", name)
}

// Find returns an object by meta
func (api *appAPI) Find(meta *api.ObjectMeta) (*App, error) {
	// find the object
	obj, err := api.ct.FindObject("App", meta)
	if err != nil {
		return nil, err
	}

	// asset type
	switch obj.(type) {
	case *App:
		hobj := obj.(*App)
		return hobj, nil
	default:
		return nil, errors.New("incorrect object type")
	}
}

// List returns a list of all App objects
func (api *appAPI) List(ctx context.Context, opts *api.ListWatchOptions) ([]*App, error) {
	var objlist []*App
	objs, err := api.ct.List("App", ctx, opts)

	if err != nil {
		return nil, err
	}

	for _, obj := range objs {
		switch tp := obj.(type) {
		case *App:
			eobj := obj.(*App)
			objlist = append(objlist, eobj)
		default:
			log.Fatalf("Got invalid object type %v while looking for App", tp)
		}
	}

	return objlist, nil
}

// Watch sets up a event handlers for App object
func (api *appAPI) Watch(handler AppHandler) error {
	api.ct.startWorkerPool("App")
	return api.ct.WatchApp(handler)
}

// StopWatch stop watch for Tenant App object
func (api *appAPI) StopWatch(handler AppHandler) error {
	api.ct.Lock()
	api.ct.workPools["App"].Stop()
	api.ct.Unlock()
	return api.ct.StopWatchApp(handler)
}

// App returns AppAPI
func (ct *ctrlerCtx) App() AppAPI {
	return &appAPI{ct: ct}
}

// FirewallProfile is a wrapper object that implements additional functionality
type FirewallProfile struct {
	sync.Mutex
	security.FirewallProfile
	HandlerCtx interface{} // additional state handlers can store
	ctrler     *ctrlerCtx  // reference back to the controller instance
}

func (obj *FirewallProfile) Write() error {
	// if there is no API server to connect to, we are done
	if (obj.ctrler == nil) || (obj.ctrler.resolver == nil) || obj.ctrler.apisrvURL == "" {
		return nil
	}

	apicl, err := obj.ctrler.apiClient()
	if err != nil {
		obj.ctrler.logger.Errorf("Error creating API server clent. Err: %v", err)
		return err
	}

	obj.ctrler.stats.Counter("FirewallProfile_Writes").Inc()

	// write to api server
	if obj.ObjectMeta.ResourceVersion != "" {
		// update it
		for i := 0; i < maxApisrvWriteRetry; i++ {
			_, err = apicl.SecurityV1().FirewallProfile().UpdateStatus(context.Background(), &obj.FirewallProfile)
			if err == nil {
				break
			}
			time.Sleep(time.Millisecond * 100)
		}
	} else {
		//  create
		_, err = apicl.SecurityV1().FirewallProfile().Create(context.Background(), &obj.FirewallProfile)
	}

	return nil
}

// FirewallProfileHandler is the event handler for FirewallProfile object
type FirewallProfileHandler interface {
	OnFirewallProfileCreate(obj *FirewallProfile) error
	OnFirewallProfileUpdate(oldObj *FirewallProfile, newObj *security.FirewallProfile) error
	OnFirewallProfileDelete(obj *FirewallProfile) error
	GetFirewallProfileWatchOptions() *api.ListWatchOptions
}

// OnFirewallProfileCreate is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnFirewallProfileCreate(obj *FirewallProfile) error {
	log.Info("OnFirewallProfileCreate is not implemented")
	return nil
}

// OnFirewallProfileUpdate is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnFirewallProfileUpdate(oldObj *FirewallProfile, newObj *security.FirewallProfile) error {
	log.Info("OnFirewallProfileUpdate is not implemented")
	return nil
}

// OnFirewallProfileDelete is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnFirewallProfileDelete(obj *FirewallProfile) error {
	log.Info("OnFirewallProfileDelete is not implemented")
	return nil
}

// GetFirewallProfileWatchOptions is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) GetFirewallProfileWatchOptions() *api.ListWatchOptions {
	log.Info("GetFirewallProfileWatchOptions is not implemented")
	opts := &api.ListWatchOptions{}
	return opts
}

// handleFirewallProfileEvent handles FirewallProfile events from watcher
func (ct *ctrlerCtx) handleFirewallProfileEvent(evt *kvstore.WatchEvent) error {

	if ct.objResolver == nil {
		return ct.handleFirewallProfileEventNoResolver(evt)
	}

	switch tp := evt.Object.(type) {
	case *security.FirewallProfile:
		eobj := evt.Object.(*security.FirewallProfile)
		kind := "FirewallProfile"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ctx := &firewallprofileCtx{event: evt.Type,
			obj: &FirewallProfile{FirewallProfile: *eobj, ctrler: ct}}

		var err error
		switch evt.Type {
		case kvstore.Created:
			err = ct.processAdd(ctx)
		case kvstore.Updated:
			err = ct.processUpdate(ctx)
		case kvstore.Deleted:
			err = ct.processDelete(ctx)
		}
		return err
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on FirewallProfile watch channel", tp)
	}

	return nil
}

// handleFirewallProfileEventNoResolver handles FirewallProfile events from watcher
func (ct *ctrlerCtx) handleFirewallProfileEventNoResolver(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *security.FirewallProfile:
		eobj := evt.Object.(*security.FirewallProfile)
		kind := "FirewallProfile"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		firewallprofileHandler := handler.(FirewallProfileHandler)
		// handle based on event type
		ctrlCtx := &firewallprofileCtx{event: evt.Type, obj: &FirewallProfile{FirewallProfile: *eobj, ctrler: ct}}
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			fobj, err := ct.getObject(kind, ctrlCtx.GetKey())
			if err != nil {
				ct.addObject(ctrlCtx)
				ct.stats.Counter("FirewallProfile_Created_Events").Inc()

				// call the event handler
				ctrlCtx.Lock()
				err = firewallprofileHandler.OnFirewallProfileCreate(ctrlCtx.obj)
				ctrlCtx.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctrlCtx.obj, err)
					ct.delObject(kind, ctrlCtx.GetKey())
					return err
				}
			} else {
				ctrlCtx := fobj.(*firewallprofileCtx)
				ct.stats.Counter("FirewallProfile_Updated_Events").Inc()
				ctrlCtx.Lock()
				p := security.FirewallProfile{Spec: eobj.Spec,
					ObjectMeta: eobj.ObjectMeta,
					TypeMeta:   eobj.TypeMeta,
					Status:     eobj.Status}

				err = firewallprofileHandler.OnFirewallProfileUpdate(ctrlCtx.obj, &p)
				ctrlCtx.obj.FirewallProfile = *eobj
				ctrlCtx.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctrlCtx.obj, err)
					return err
				}

			}
		case kvstore.Deleted:
			ctrlCtx := &firewallprofileCtx{event: evt.Type, obj: &FirewallProfile{FirewallProfile: *eobj, ctrler: ct}}
			fobj, err := ct.findObject(kind, ctrlCtx.GetKey())
			if err != nil {
				ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
				return err
			}

			obj := fobj.(*FirewallProfile)
			ct.stats.Counter("FirewallProfile_Deleted_Events").Inc()
			obj.Lock()
			err = firewallprofileHandler.OnFirewallProfileDelete(obj)
			obj.Unlock()
			if err != nil {
				ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
			}
			ct.delObject(kind, ctrlCtx.GetKey())
			return nil

		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on FirewallProfile watch channel", tp)
	}

	return nil
}

type firewallprofileCtx struct {
	ctkitBaseCtx
	event kvstore.WatchEventType
	obj   *FirewallProfile //
	//   newObj     *security.FirewallProfile //update
	newObj *firewallprofileCtx //update
}

func (ctx *firewallprofileCtx) References() map[string]apiintf.ReferenceObj {
	resp := make(map[string]apiintf.ReferenceObj)
	ctx.obj.References(ctx.obj.GetObjectMeta().Name, ctx.obj.GetObjectMeta().Namespace, resp)
	return resp
}

func (ctx *firewallprofileCtx) GetKey() string {
	return ctx.obj.MakeKey("security")
}

func (ctx *firewallprofileCtx) GetKind() string {
	return ctx.obj.GetKind()
}

func (ctx *firewallprofileCtx) SetEvent(event kvstore.WatchEventType) {
	ctx.event = event
}

func (ctx *firewallprofileCtx) SetNewObj(newObj apiintf.CtkitObject) {
	if newObj == nil {
		ctx.newObj = nil
	} else {
		ctx.newObj = newObj.(*firewallprofileCtx)
		ctx.newObj.obj.HandlerCtx = ctx.obj.HandlerCtx
	}
}

func (ctx *firewallprofileCtx) GetNewObj() apiintf.CtkitObject {
	return ctx.newObj
}

func (ctx *firewallprofileCtx) Copy(obj apiintf.CtkitObject) {
	ctx.obj.FirewallProfile = obj.(*firewallprofileCtx).obj.FirewallProfile
}

func (ctx *firewallprofileCtx) Lock() {
	ctx.obj.Lock()
}

func (ctx *firewallprofileCtx) Unlock() {
	ctx.obj.Unlock()
}

func (ctx *firewallprofileCtx) GetObjectMeta() *api.ObjectMeta {
	return ctx.obj.GetObjectMeta()
}

func (ctx *firewallprofileCtx) RuntimeObject() runtime.Object {
	var v interface{}
	v = ctx.obj
	return v.(runtime.Object)
}

func (ctx *firewallprofileCtx) WorkFunc(context context.Context) error {
	var err error
	evt := ctx.event
	ct := ctx.obj.ctrler
	kind := "FirewallProfile"
	ct.Lock()
	handler, ok := ct.handlers[kind]
	ct.Unlock()
	if !ok {
		ct.logger.Fatalf("Cant find the handler for %s", kind)
	}
	firewallprofileHandler := handler.(FirewallProfileHandler)
	switch evt {
	case kvstore.Created:
		ctx.obj.Lock()
		err = firewallprofileHandler.OnFirewallProfileCreate(ctx.obj)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctx.obj, err)
			ctx.SetEvent(kvstore.Deleted)
		}
	case kvstore.Updated:
		ct.stats.Counter("FirewallProfile_Updated_Events").Inc()
		ctx.obj.Lock()
		p := security.FirewallProfile{Spec: ctx.newObj.obj.Spec,
			ObjectMeta: ctx.newObj.obj.ObjectMeta,
			TypeMeta:   ctx.newObj.obj.TypeMeta,
			Status:     ctx.newObj.obj.Status}
		err = firewallprofileHandler.OnFirewallProfileUpdate(ctx.obj, &p)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctx.obj, err)
			ctx.SetEvent(kvstore.Deleted)
		}
	case kvstore.Deleted:
		ctx.obj.Lock()
		err = firewallprofileHandler.OnFirewallProfileDelete(ctx.obj)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error deleting %s %+v. Err: %v", kind, ctx.obj, err)
		}
	}
	ct.resolveObject(ctx.event, ctx)
	return nil
}

// handleFirewallProfileEventParallel handles FirewallProfile events from watcher
func (ct *ctrlerCtx) handleFirewallProfileEventParallel(evt *kvstore.WatchEvent) error {

	if ct.objResolver == nil {
		return ct.handleFirewallProfileEventParallelWithNoResolver(evt)
	}

	switch tp := evt.Object.(type) {
	case *security.FirewallProfile:
		eobj := evt.Object.(*security.FirewallProfile)
		kind := "FirewallProfile"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ctx := &firewallprofileCtx{event: evt.Type, obj: &FirewallProfile{FirewallProfile: *eobj, ctrler: ct}}

		var err error
		switch evt.Type {
		case kvstore.Created:
			err = ct.processAdd(ctx)
		case kvstore.Updated:
			err = ct.processUpdate(ctx)
		case kvstore.Deleted:
			err = ct.processDelete(ctx)
		}
		return err
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on FirewallProfile watch channel", tp)
	}

	return nil
}

// handleFirewallProfileEventParallel handles FirewallProfile events from watcher
func (ct *ctrlerCtx) handleFirewallProfileEventParallelWithNoResolver(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *security.FirewallProfile:
		eobj := evt.Object.(*security.FirewallProfile)
		kind := "FirewallProfile"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		firewallprofileHandler := handler.(FirewallProfileHandler)
		// handle based on event type
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			workFunc := func(ctx context.Context, ctrlCtx shardworkers.WorkObj) error {
				var err error
				workCtx := ctrlCtx.(*firewallprofileCtx)
				eobj := workCtx.obj
				fobj, err := ct.getObject(kind, workCtx.GetKey())
				if err != nil {
					ct.addObject(workCtx)
					ct.stats.Counter("FirewallProfile_Created_Events").Inc()
					eobj.Lock()
					err = firewallprofileHandler.OnFirewallProfileCreate(eobj)
					eobj.Unlock()
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, eobj, err)
						ct.delObject(kind, workCtx.GetKey())
					}
				} else {
					workCtx := fobj.(*firewallprofileCtx)
					obj := workCtx.obj
					ct.stats.Counter("FirewallProfile_Updated_Events").Inc()
					obj.Lock()
					p := security.FirewallProfile{Spec: eobj.Spec,
						ObjectMeta: eobj.ObjectMeta,
						TypeMeta:   eobj.TypeMeta,
						Status:     eobj.Status}

					err = firewallprofileHandler.OnFirewallProfileUpdate(obj, &p)
					workCtx.obj.FirewallProfile = p
					obj.Unlock()
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					}
				}
				return err
			}
			ctrlCtx := &firewallprofileCtx{event: evt.Type, obj: &FirewallProfile{FirewallProfile: *eobj, ctrler: ct}}
			ct.runFunction("FirewallProfile", ctrlCtx, workFunc)
		case kvstore.Deleted:
			workFunc := func(ctx context.Context, ctrlCtx shardworkers.WorkObj) error {
				var err error
				workCtx := ctrlCtx.(*firewallprofileCtx)
				eobj := workCtx.obj
				fobj, err := ct.findObject(kind, workCtx.GetKey())
				if err != nil {
					ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
					return err
				}
				obj := fobj.(*FirewallProfile)
				ct.stats.Counter("FirewallProfile_Deleted_Events").Inc()
				obj.Lock()
				err = firewallprofileHandler.OnFirewallProfileDelete(obj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
				}
				ct.delObject(kind, workCtx.GetKey())
				return nil
			}
			ctrlCtx := &firewallprofileCtx{event: evt.Type, obj: &FirewallProfile{FirewallProfile: *eobj, ctrler: ct}}
			ct.runFunction("FirewallProfile", ctrlCtx, workFunc)
		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on FirewallProfile watch channel", tp)
	}

	return nil
}

// diffFirewallProfile does a diff of FirewallProfile objects between local cache and API server
func (ct *ctrlerCtx) diffFirewallProfile(apicl apiclient.Services) {
	opts := api.ListWatchOptions{}

	// get a list of all objects from API server
	objlist, err := apicl.SecurityV1().FirewallProfile().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Errorf("Error getting a list of objects. Err: %v", err)
		return
	}

	ct.logger.Infof("diffFirewallProfile(): FirewallProfileList returned %d objects", len(objlist))

	// build an object map
	objmap := make(map[string]*security.FirewallProfile)
	for _, obj := range objlist {
		objmap[obj.GetKey()] = obj
	}

	list, err := ct.FirewallProfile().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Infof("Failed to get a list of objects. Err: %s", err)
		return
	}

	// if an object is in our local cache and not in API server, trigger delete for it
	for _, obj := range list {
		_, ok := objmap[obj.GetKey()]
		if !ok {
			ct.logger.Infof("diffFirewallProfile(): Deleting existing object %#v since its not in apiserver", obj.GetKey())
			evt := kvstore.WatchEvent{
				Type:   kvstore.Deleted,
				Key:    obj.GetKey(),
				Object: &obj.FirewallProfile,
			}
			ct.handleFirewallProfileEvent(&evt)
		}
	}

	// trigger create event for all others
	for _, obj := range objlist {
		ct.logger.Infof("diffFirewallProfile(): Adding object %#v", obj.GetKey())
		evt := kvstore.WatchEvent{
			Type:   kvstore.Created,
			Key:    obj.GetKey(),
			Object: obj,
		}
		ct.handleFirewallProfileEvent(&evt)
	}
}

func (ct *ctrlerCtx) runFirewallProfileWatcher() {
	kind := "FirewallProfile"

	ct.Lock()
	handler, ok := ct.handlers[kind]
	ct.Unlock()
	if !ok {
		ct.logger.Fatalf("Cant find the handler for %s", kind)
	}
	firewallprofileHandler := handler.(FirewallProfileHandler)

	opts := firewallprofileHandler.GetFirewallProfileWatchOptions()

	// if there is no API server to connect to, we are done
	if (ct.resolver == nil) || ct.apisrvURL == "" {
		return
	}

	// create context
	ctx, cancel := context.WithCancel(context.Background())
	ct.Lock()
	ct.watchCancel[kind] = cancel
	ct.Unlock()
	logger := ct.logger.WithContext("submodule", "FirewallProfileWatcher")

	// create a grpc client
	apiclt, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
	if err == nil {
		ct.diffFirewallProfile(apiclt)
	}

	// setup wait group
	ct.waitGrp.Add(1)

	// start a goroutine
	go func() {
		defer ct.waitGrp.Done()
		ct.stats.Counter("FirewallProfile_Watch").Inc()
		defer ct.stats.Counter("FirewallProfile_Watch").Dec()

		// loop forever
		for {
			// create a grpc client
			apicl, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
			if err != nil {
				logger.Warnf("Failed to connect to gRPC server [%s]\n", ct.apisrvURL)
				ct.stats.Counter("FirewallProfile_ApiClientErr").Inc()
			} else {
				logger.Infof("API client connected {%+v}", apicl)

				// FirewallProfile object watcher
				wt, werr := apicl.SecurityV1().FirewallProfile().Watch(ctx, opts)
				if werr != nil {
					select {
					case <-ctx.Done():
						logger.Infof("watch %s cancelled", kind)
						return
					default:
					}
					logger.Errorf("Failed to start %s watch (%s)\n", kind, werr)
					// wait for a second and retry connecting to api server
					apicl.Close()
					time.Sleep(time.Second)
					continue
				}
				ct.Lock()
				ct.watchers[kind] = wt
				ct.Unlock()

				// perform a diff with API server and local cache
				time.Sleep(time.Millisecond * 100)
				ct.diffFirewallProfile(apicl)

				// handle api server watch events
			innerLoop:
				for {
					// wait for events
					select {
					case evt, ok := <-wt.EventChan():
						if !ok {
							logger.Error("Error receiving from apisrv watcher")
							ct.stats.Counter("FirewallProfile_WatchErrors").Inc()
							break innerLoop
						}

						// handle event in parallel
						ct.handleFirewallProfileEventParallel(evt)
					}
				}
				apicl.Close()
			}

			// if stop flag is set, we are done
			if ct.stoped {
				logger.Infof("Exiting API server watcher")
				return
			}

			// wait for a second and retry connecting to api server
			time.Sleep(time.Second)
		}
	}()
}

// WatchFirewallProfile starts watch on FirewallProfile object
func (ct *ctrlerCtx) WatchFirewallProfile(handler FirewallProfileHandler) error {
	kind := "FirewallProfile"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchers[kind]
	ct.Unlock()
	if ok {
		return fmt.Errorf("FirewallProfile watcher already exists")
	}

	// save handler
	ct.Lock()
	ct.handlers[kind] = handler
	ct.Unlock()

	// run FirewallProfile watcher in a go routine
	ct.runFirewallProfileWatcher()

	return nil
}

// StopWatchFirewallProfile stops watch on FirewallProfile object
func (ct *ctrlerCtx) StopWatchFirewallProfile(handler FirewallProfileHandler) error {
	kind := "FirewallProfile"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchers[kind]
	ct.Unlock()
	if !ok {
		return fmt.Errorf("FirewallProfile watcher does not exist")
	}

	ct.Lock()
	cancel, _ := ct.watchCancel[kind]
	cancel()
	delete(ct.watchers, kind)
	delete(ct.watchCancel, kind)
	ct.Unlock()

	time.Sleep(100 * time.Millisecond)

	return nil
}

// FirewallProfileAPI returns
type FirewallProfileAPI interface {
	Create(obj *security.FirewallProfile) error
	CreateEvent(obj *security.FirewallProfile) error
	Update(obj *security.FirewallProfile) error
	Delete(obj *security.FirewallProfile) error
	Find(meta *api.ObjectMeta) (*FirewallProfile, error)
	List(ctx context.Context, opts *api.ListWatchOptions) ([]*FirewallProfile, error)
	Watch(handler FirewallProfileHandler) error
	StopWatch(handler FirewallProfileHandler) error
}

// dummy struct that implements FirewallProfileAPI
type firewallprofileAPI struct {
	ct *ctrlerCtx
}

// Create creates FirewallProfile object
func (api *firewallprofileAPI) Create(obj *security.FirewallProfile) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.SecurityV1().FirewallProfile().Create(context.Background(), obj)
		if err != nil && strings.Contains(err.Error(), "AlreadyExists") {
			_, err = apicl.SecurityV1().FirewallProfile().Update(context.Background(), obj)
		}
		return err
	}

	api.ct.handleFirewallProfileEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Created})
	return nil
}

// CreateEvent creates FirewallProfile object and synchronously triggers local event
func (api *firewallprofileAPI) CreateEvent(obj *security.FirewallProfile) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.SecurityV1().FirewallProfile().Create(context.Background(), obj)
		if err != nil && strings.Contains(err.Error(), "AlreadyExists") {
			_, err = apicl.SecurityV1().FirewallProfile().Update(context.Background(), obj)
		}
		if err != nil {
			api.ct.logger.Errorf("Error creating object in api server. Err: %v", err)
			return err
		}
		return err
	}

	api.ct.handleFirewallProfileEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Created})
	return nil
}

// Update triggers update on FirewallProfile object
func (api *firewallprofileAPI) Update(obj *security.FirewallProfile) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.SecurityV1().FirewallProfile().Update(context.Background(), obj)
		return err
	}

	api.ct.handleFirewallProfileEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Updated})
	return nil
}

// Delete deletes FirewallProfile object
func (api *firewallprofileAPI) Delete(obj *security.FirewallProfile) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.SecurityV1().FirewallProfile().Delete(context.Background(), &obj.ObjectMeta)
		return err
	}

	api.ct.handleFirewallProfileEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Deleted})
	return nil
}

// MakeKey generates a KV store key for the object
func (api *firewallprofileAPI) getFullKey(tenant, name string) string {
	if tenant != "" {
		return fmt.Sprint(globals.ConfigRootPrefix, "/", "security", "/", "firewallprofiles", "/", tenant, "/", name)
	}
	return fmt.Sprint(globals.ConfigRootPrefix, "/", "security", "/", "firewallprofiles", "/", name)
}

// Find returns an object by meta
func (api *firewallprofileAPI) Find(meta *api.ObjectMeta) (*FirewallProfile, error) {
	// find the object
	obj, err := api.ct.FindObject("FirewallProfile", meta)
	if err != nil {
		return nil, err
	}

	// asset type
	switch obj.(type) {
	case *FirewallProfile:
		hobj := obj.(*FirewallProfile)
		return hobj, nil
	default:
		return nil, errors.New("incorrect object type")
	}
}

// List returns a list of all FirewallProfile objects
func (api *firewallprofileAPI) List(ctx context.Context, opts *api.ListWatchOptions) ([]*FirewallProfile, error) {
	var objlist []*FirewallProfile
	objs, err := api.ct.List("FirewallProfile", ctx, opts)

	if err != nil {
		return nil, err
	}

	for _, obj := range objs {
		switch tp := obj.(type) {
		case *FirewallProfile:
			eobj := obj.(*FirewallProfile)
			objlist = append(objlist, eobj)
		default:
			log.Fatalf("Got invalid object type %v while looking for FirewallProfile", tp)
		}
	}

	return objlist, nil
}

// Watch sets up a event handlers for FirewallProfile object
func (api *firewallprofileAPI) Watch(handler FirewallProfileHandler) error {
	api.ct.startWorkerPool("FirewallProfile")
	return api.ct.WatchFirewallProfile(handler)
}

// StopWatch stop watch for Tenant FirewallProfile object
func (api *firewallprofileAPI) StopWatch(handler FirewallProfileHandler) error {
	api.ct.Lock()
	api.ct.workPools["FirewallProfile"].Stop()
	api.ct.Unlock()
	return api.ct.StopWatchFirewallProfile(handler)
}

// FirewallProfile returns FirewallProfileAPI
func (ct *ctrlerCtx) FirewallProfile() FirewallProfileAPI {
	return &firewallprofileAPI{ct: ct}
}

// Certificate is a wrapper object that implements additional functionality
type Certificate struct {
	sync.Mutex
	security.Certificate
	HandlerCtx interface{} // additional state handlers can store
	ctrler     *ctrlerCtx  // reference back to the controller instance
}

func (obj *Certificate) Write() error {
	// if there is no API server to connect to, we are done
	if (obj.ctrler == nil) || (obj.ctrler.resolver == nil) || obj.ctrler.apisrvURL == "" {
		return nil
	}

	apicl, err := obj.ctrler.apiClient()
	if err != nil {
		obj.ctrler.logger.Errorf("Error creating API server clent. Err: %v", err)
		return err
	}

	obj.ctrler.stats.Counter("Certificate_Writes").Inc()

	// write to api server
	if obj.ObjectMeta.ResourceVersion != "" {
		// update it
		for i := 0; i < maxApisrvWriteRetry; i++ {
			_, err = apicl.SecurityV1().Certificate().UpdateStatus(context.Background(), &obj.Certificate)
			if err == nil {
				break
			}
			time.Sleep(time.Millisecond * 100)
		}
	} else {
		//  create
		_, err = apicl.SecurityV1().Certificate().Create(context.Background(), &obj.Certificate)
	}

	return nil
}

// CertificateHandler is the event handler for Certificate object
type CertificateHandler interface {
	OnCertificateCreate(obj *Certificate) error
	OnCertificateUpdate(oldObj *Certificate, newObj *security.Certificate) error
	OnCertificateDelete(obj *Certificate) error
	GetCertificateWatchOptions() *api.ListWatchOptions
}

// OnCertificateCreate is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnCertificateCreate(obj *Certificate) error {
	log.Info("OnCertificateCreate is not implemented")
	return nil
}

// OnCertificateUpdate is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnCertificateUpdate(oldObj *Certificate, newObj *security.Certificate) error {
	log.Info("OnCertificateUpdate is not implemented")
	return nil
}

// OnCertificateDelete is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnCertificateDelete(obj *Certificate) error {
	log.Info("OnCertificateDelete is not implemented")
	return nil
}

// GetCertificateWatchOptions is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) GetCertificateWatchOptions() *api.ListWatchOptions {
	log.Info("GetCertificateWatchOptions is not implemented")
	opts := &api.ListWatchOptions{}
	return opts
}

// handleCertificateEvent handles Certificate events from watcher
func (ct *ctrlerCtx) handleCertificateEvent(evt *kvstore.WatchEvent) error {

	if ct.objResolver == nil {
		return ct.handleCertificateEventNoResolver(evt)
	}

	switch tp := evt.Object.(type) {
	case *security.Certificate:
		eobj := evt.Object.(*security.Certificate)
		kind := "Certificate"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ctx := &certificateCtx{event: evt.Type,
			obj: &Certificate{Certificate: *eobj, ctrler: ct}}

		var err error
		switch evt.Type {
		case kvstore.Created:
			err = ct.processAdd(ctx)
		case kvstore.Updated:
			err = ct.processUpdate(ctx)
		case kvstore.Deleted:
			err = ct.processDelete(ctx)
		}
		return err
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on Certificate watch channel", tp)
	}

	return nil
}

// handleCertificateEventNoResolver handles Certificate events from watcher
func (ct *ctrlerCtx) handleCertificateEventNoResolver(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *security.Certificate:
		eobj := evt.Object.(*security.Certificate)
		kind := "Certificate"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		certificateHandler := handler.(CertificateHandler)
		// handle based on event type
		ctrlCtx := &certificateCtx{event: evt.Type, obj: &Certificate{Certificate: *eobj, ctrler: ct}}
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			fobj, err := ct.getObject(kind, ctrlCtx.GetKey())
			if err != nil {
				ct.addObject(ctrlCtx)
				ct.stats.Counter("Certificate_Created_Events").Inc()

				// call the event handler
				ctrlCtx.Lock()
				err = certificateHandler.OnCertificateCreate(ctrlCtx.obj)
				ctrlCtx.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctrlCtx.obj, err)
					ct.delObject(kind, ctrlCtx.GetKey())
					return err
				}
			} else {
				ctrlCtx := fobj.(*certificateCtx)
				ct.stats.Counter("Certificate_Updated_Events").Inc()
				ctrlCtx.Lock()
				p := security.Certificate{Spec: eobj.Spec,
					ObjectMeta: eobj.ObjectMeta,
					TypeMeta:   eobj.TypeMeta,
					Status:     eobj.Status}

				err = certificateHandler.OnCertificateUpdate(ctrlCtx.obj, &p)
				ctrlCtx.obj.Certificate = *eobj
				ctrlCtx.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctrlCtx.obj, err)
					return err
				}

			}
		case kvstore.Deleted:
			ctrlCtx := &certificateCtx{event: evt.Type, obj: &Certificate{Certificate: *eobj, ctrler: ct}}
			fobj, err := ct.findObject(kind, ctrlCtx.GetKey())
			if err != nil {
				ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
				return err
			}

			obj := fobj.(*Certificate)
			ct.stats.Counter("Certificate_Deleted_Events").Inc()
			obj.Lock()
			err = certificateHandler.OnCertificateDelete(obj)
			obj.Unlock()
			if err != nil {
				ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
			}
			ct.delObject(kind, ctrlCtx.GetKey())
			return nil

		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on Certificate watch channel", tp)
	}

	return nil
}

type certificateCtx struct {
	ctkitBaseCtx
	event kvstore.WatchEventType
	obj   *Certificate //
	//   newObj     *security.Certificate //update
	newObj *certificateCtx //update
}

func (ctx *certificateCtx) References() map[string]apiintf.ReferenceObj {
	resp := make(map[string]apiintf.ReferenceObj)
	ctx.obj.References(ctx.obj.GetObjectMeta().Name, ctx.obj.GetObjectMeta().Namespace, resp)
	return resp
}

func (ctx *certificateCtx) GetKey() string {
	return ctx.obj.MakeKey("security")
}

func (ctx *certificateCtx) GetKind() string {
	return ctx.obj.GetKind()
}

func (ctx *certificateCtx) SetEvent(event kvstore.WatchEventType) {
	ctx.event = event
}

func (ctx *certificateCtx) SetNewObj(newObj apiintf.CtkitObject) {
	if newObj == nil {
		ctx.newObj = nil
	} else {
		ctx.newObj = newObj.(*certificateCtx)
		ctx.newObj.obj.HandlerCtx = ctx.obj.HandlerCtx
	}
}

func (ctx *certificateCtx) GetNewObj() apiintf.CtkitObject {
	return ctx.newObj
}

func (ctx *certificateCtx) Copy(obj apiintf.CtkitObject) {
	ctx.obj.Certificate = obj.(*certificateCtx).obj.Certificate
}

func (ctx *certificateCtx) Lock() {
	ctx.obj.Lock()
}

func (ctx *certificateCtx) Unlock() {
	ctx.obj.Unlock()
}

func (ctx *certificateCtx) GetObjectMeta() *api.ObjectMeta {
	return ctx.obj.GetObjectMeta()
}

func (ctx *certificateCtx) RuntimeObject() runtime.Object {
	var v interface{}
	v = ctx.obj
	return v.(runtime.Object)
}

func (ctx *certificateCtx) WorkFunc(context context.Context) error {
	var err error
	evt := ctx.event
	ct := ctx.obj.ctrler
	kind := "Certificate"
	ct.Lock()
	handler, ok := ct.handlers[kind]
	ct.Unlock()
	if !ok {
		ct.logger.Fatalf("Cant find the handler for %s", kind)
	}
	certificateHandler := handler.(CertificateHandler)
	switch evt {
	case kvstore.Created:
		ctx.obj.Lock()
		err = certificateHandler.OnCertificateCreate(ctx.obj)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctx.obj, err)
			ctx.SetEvent(kvstore.Deleted)
		}
	case kvstore.Updated:
		ct.stats.Counter("Certificate_Updated_Events").Inc()
		ctx.obj.Lock()
		p := security.Certificate{Spec: ctx.newObj.obj.Spec,
			ObjectMeta: ctx.newObj.obj.ObjectMeta,
			TypeMeta:   ctx.newObj.obj.TypeMeta,
			Status:     ctx.newObj.obj.Status}
		err = certificateHandler.OnCertificateUpdate(ctx.obj, &p)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctx.obj, err)
			ctx.SetEvent(kvstore.Deleted)
		}
	case kvstore.Deleted:
		ctx.obj.Lock()
		err = certificateHandler.OnCertificateDelete(ctx.obj)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error deleting %s %+v. Err: %v", kind, ctx.obj, err)
		}
	}
	ct.resolveObject(ctx.event, ctx)
	return nil
}

// handleCertificateEventParallel handles Certificate events from watcher
func (ct *ctrlerCtx) handleCertificateEventParallel(evt *kvstore.WatchEvent) error {

	if ct.objResolver == nil {
		return ct.handleCertificateEventParallelWithNoResolver(evt)
	}

	switch tp := evt.Object.(type) {
	case *security.Certificate:
		eobj := evt.Object.(*security.Certificate)
		kind := "Certificate"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ctx := &certificateCtx{event: evt.Type, obj: &Certificate{Certificate: *eobj, ctrler: ct}}

		var err error
		switch evt.Type {
		case kvstore.Created:
			err = ct.processAdd(ctx)
		case kvstore.Updated:
			err = ct.processUpdate(ctx)
		case kvstore.Deleted:
			err = ct.processDelete(ctx)
		}
		return err
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on Certificate watch channel", tp)
	}

	return nil
}

// handleCertificateEventParallel handles Certificate events from watcher
func (ct *ctrlerCtx) handleCertificateEventParallelWithNoResolver(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *security.Certificate:
		eobj := evt.Object.(*security.Certificate)
		kind := "Certificate"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		certificateHandler := handler.(CertificateHandler)
		// handle based on event type
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			workFunc := func(ctx context.Context, ctrlCtx shardworkers.WorkObj) error {
				var err error
				workCtx := ctrlCtx.(*certificateCtx)
				eobj := workCtx.obj
				fobj, err := ct.getObject(kind, workCtx.GetKey())
				if err != nil {
					ct.addObject(workCtx)
					ct.stats.Counter("Certificate_Created_Events").Inc()
					eobj.Lock()
					err = certificateHandler.OnCertificateCreate(eobj)
					eobj.Unlock()
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, eobj, err)
						ct.delObject(kind, workCtx.GetKey())
					}
				} else {
					workCtx := fobj.(*certificateCtx)
					obj := workCtx.obj
					ct.stats.Counter("Certificate_Updated_Events").Inc()
					obj.Lock()
					p := security.Certificate{Spec: eobj.Spec,
						ObjectMeta: eobj.ObjectMeta,
						TypeMeta:   eobj.TypeMeta,
						Status:     eobj.Status}

					err = certificateHandler.OnCertificateUpdate(obj, &p)
					workCtx.obj.Certificate = p
					obj.Unlock()
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					}
				}
				return err
			}
			ctrlCtx := &certificateCtx{event: evt.Type, obj: &Certificate{Certificate: *eobj, ctrler: ct}}
			ct.runFunction("Certificate", ctrlCtx, workFunc)
		case kvstore.Deleted:
			workFunc := func(ctx context.Context, ctrlCtx shardworkers.WorkObj) error {
				var err error
				workCtx := ctrlCtx.(*certificateCtx)
				eobj := workCtx.obj
				fobj, err := ct.findObject(kind, workCtx.GetKey())
				if err != nil {
					ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
					return err
				}
				obj := fobj.(*Certificate)
				ct.stats.Counter("Certificate_Deleted_Events").Inc()
				obj.Lock()
				err = certificateHandler.OnCertificateDelete(obj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
				}
				ct.delObject(kind, workCtx.GetKey())
				return nil
			}
			ctrlCtx := &certificateCtx{event: evt.Type, obj: &Certificate{Certificate: *eobj, ctrler: ct}}
			ct.runFunction("Certificate", ctrlCtx, workFunc)
		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on Certificate watch channel", tp)
	}

	return nil
}

// diffCertificate does a diff of Certificate objects between local cache and API server
func (ct *ctrlerCtx) diffCertificate(apicl apiclient.Services) {
	opts := api.ListWatchOptions{}

	// get a list of all objects from API server
	objlist, err := apicl.SecurityV1().Certificate().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Errorf("Error getting a list of objects. Err: %v", err)
		return
	}

	ct.logger.Infof("diffCertificate(): CertificateList returned %d objects", len(objlist))

	// build an object map
	objmap := make(map[string]*security.Certificate)
	for _, obj := range objlist {
		objmap[obj.GetKey()] = obj
	}

	list, err := ct.Certificate().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Infof("Failed to get a list of objects. Err: %s", err)
		return
	}

	// if an object is in our local cache and not in API server, trigger delete for it
	for _, obj := range list {
		_, ok := objmap[obj.GetKey()]
		if !ok {
			ct.logger.Infof("diffCertificate(): Deleting existing object %#v since its not in apiserver", obj.GetKey())
			evt := kvstore.WatchEvent{
				Type:   kvstore.Deleted,
				Key:    obj.GetKey(),
				Object: &obj.Certificate,
			}
			ct.handleCertificateEvent(&evt)
		}
	}

	// trigger create event for all others
	for _, obj := range objlist {
		ct.logger.Infof("diffCertificate(): Adding object %#v", obj.GetKey())
		evt := kvstore.WatchEvent{
			Type:   kvstore.Created,
			Key:    obj.GetKey(),
			Object: obj,
		}
		ct.handleCertificateEvent(&evt)
	}
}

func (ct *ctrlerCtx) runCertificateWatcher() {
	kind := "Certificate"

	ct.Lock()
	handler, ok := ct.handlers[kind]
	ct.Unlock()
	if !ok {
		ct.logger.Fatalf("Cant find the handler for %s", kind)
	}
	certificateHandler := handler.(CertificateHandler)

	opts := certificateHandler.GetCertificateWatchOptions()

	// if there is no API server to connect to, we are done
	if (ct.resolver == nil) || ct.apisrvURL == "" {
		return
	}

	// create context
	ctx, cancel := context.WithCancel(context.Background())
	ct.Lock()
	ct.watchCancel[kind] = cancel
	ct.Unlock()
	logger := ct.logger.WithContext("submodule", "CertificateWatcher")

	// create a grpc client
	apiclt, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
	if err == nil {
		ct.diffCertificate(apiclt)
	}

	// setup wait group
	ct.waitGrp.Add(1)

	// start a goroutine
	go func() {
		defer ct.waitGrp.Done()
		ct.stats.Counter("Certificate_Watch").Inc()
		defer ct.stats.Counter("Certificate_Watch").Dec()

		// loop forever
		for {
			// create a grpc client
			apicl, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
			if err != nil {
				logger.Warnf("Failed to connect to gRPC server [%s]\n", ct.apisrvURL)
				ct.stats.Counter("Certificate_ApiClientErr").Inc()
			} else {
				logger.Infof("API client connected {%+v}", apicl)

				// Certificate object watcher
				wt, werr := apicl.SecurityV1().Certificate().Watch(ctx, opts)
				if werr != nil {
					select {
					case <-ctx.Done():
						logger.Infof("watch %s cancelled", kind)
						return
					default:
					}
					logger.Errorf("Failed to start %s watch (%s)\n", kind, werr)
					// wait for a second and retry connecting to api server
					apicl.Close()
					time.Sleep(time.Second)
					continue
				}
				ct.Lock()
				ct.watchers[kind] = wt
				ct.Unlock()

				// perform a diff with API server and local cache
				time.Sleep(time.Millisecond * 100)
				ct.diffCertificate(apicl)

				// handle api server watch events
			innerLoop:
				for {
					// wait for events
					select {
					case evt, ok := <-wt.EventChan():
						if !ok {
							logger.Error("Error receiving from apisrv watcher")
							ct.stats.Counter("Certificate_WatchErrors").Inc()
							break innerLoop
						}

						// handle event in parallel
						ct.handleCertificateEventParallel(evt)
					}
				}
				apicl.Close()
			}

			// if stop flag is set, we are done
			if ct.stoped {
				logger.Infof("Exiting API server watcher")
				return
			}

			// wait for a second and retry connecting to api server
			time.Sleep(time.Second)
		}
	}()
}

// WatchCertificate starts watch on Certificate object
func (ct *ctrlerCtx) WatchCertificate(handler CertificateHandler) error {
	kind := "Certificate"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchers[kind]
	ct.Unlock()
	if ok {
		return fmt.Errorf("Certificate watcher already exists")
	}

	// save handler
	ct.Lock()
	ct.handlers[kind] = handler
	ct.Unlock()

	// run Certificate watcher in a go routine
	ct.runCertificateWatcher()

	return nil
}

// StopWatchCertificate stops watch on Certificate object
func (ct *ctrlerCtx) StopWatchCertificate(handler CertificateHandler) error {
	kind := "Certificate"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchers[kind]
	ct.Unlock()
	if !ok {
		return fmt.Errorf("Certificate watcher does not exist")
	}

	ct.Lock()
	cancel, _ := ct.watchCancel[kind]
	cancel()
	delete(ct.watchers, kind)
	delete(ct.watchCancel, kind)
	ct.Unlock()

	time.Sleep(100 * time.Millisecond)

	return nil
}

// CertificateAPI returns
type CertificateAPI interface {
	Create(obj *security.Certificate) error
	CreateEvent(obj *security.Certificate) error
	Update(obj *security.Certificate) error
	Delete(obj *security.Certificate) error
	Find(meta *api.ObjectMeta) (*Certificate, error)
	List(ctx context.Context, opts *api.ListWatchOptions) ([]*Certificate, error)
	Watch(handler CertificateHandler) error
	StopWatch(handler CertificateHandler) error
}

// dummy struct that implements CertificateAPI
type certificateAPI struct {
	ct *ctrlerCtx
}

// Create creates Certificate object
func (api *certificateAPI) Create(obj *security.Certificate) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.SecurityV1().Certificate().Create(context.Background(), obj)
		if err != nil && strings.Contains(err.Error(), "AlreadyExists") {
			_, err = apicl.SecurityV1().Certificate().Update(context.Background(), obj)
		}
		return err
	}

	api.ct.handleCertificateEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Created})
	return nil
}

// CreateEvent creates Certificate object and synchronously triggers local event
func (api *certificateAPI) CreateEvent(obj *security.Certificate) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.SecurityV1().Certificate().Create(context.Background(), obj)
		if err != nil && strings.Contains(err.Error(), "AlreadyExists") {
			_, err = apicl.SecurityV1().Certificate().Update(context.Background(), obj)
		}
		if err != nil {
			api.ct.logger.Errorf("Error creating object in api server. Err: %v", err)
			return err
		}
		return err
	}

	api.ct.handleCertificateEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Created})
	return nil
}

// Update triggers update on Certificate object
func (api *certificateAPI) Update(obj *security.Certificate) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.SecurityV1().Certificate().Update(context.Background(), obj)
		return err
	}

	api.ct.handleCertificateEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Updated})
	return nil
}

// Delete deletes Certificate object
func (api *certificateAPI) Delete(obj *security.Certificate) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.SecurityV1().Certificate().Delete(context.Background(), &obj.ObjectMeta)
		return err
	}

	api.ct.handleCertificateEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Deleted})
	return nil
}

// MakeKey generates a KV store key for the object
func (api *certificateAPI) getFullKey(tenant, name string) string {
	if tenant != "" {
		return fmt.Sprint(globals.ConfigRootPrefix, "/", "security", "/", "certificates", "/", tenant, "/", name)
	}
	return fmt.Sprint(globals.ConfigRootPrefix, "/", "security", "/", "certificates", "/", name)
}

// Find returns an object by meta
func (api *certificateAPI) Find(meta *api.ObjectMeta) (*Certificate, error) {
	// find the object
	obj, err := api.ct.FindObject("Certificate", meta)
	if err != nil {
		return nil, err
	}

	// asset type
	switch obj.(type) {
	case *Certificate:
		hobj := obj.(*Certificate)
		return hobj, nil
	default:
		return nil, errors.New("incorrect object type")
	}
}

// List returns a list of all Certificate objects
func (api *certificateAPI) List(ctx context.Context, opts *api.ListWatchOptions) ([]*Certificate, error) {
	var objlist []*Certificate
	objs, err := api.ct.List("Certificate", ctx, opts)

	if err != nil {
		return nil, err
	}

	for _, obj := range objs {
		switch tp := obj.(type) {
		case *Certificate:
			eobj := obj.(*Certificate)
			objlist = append(objlist, eobj)
		default:
			log.Fatalf("Got invalid object type %v while looking for Certificate", tp)
		}
	}

	return objlist, nil
}

// Watch sets up a event handlers for Certificate object
func (api *certificateAPI) Watch(handler CertificateHandler) error {
	api.ct.startWorkerPool("Certificate")
	return api.ct.WatchCertificate(handler)
}

// StopWatch stop watch for Tenant Certificate object
func (api *certificateAPI) StopWatch(handler CertificateHandler) error {
	api.ct.Lock()
	api.ct.workPools["Certificate"].Stop()
	api.ct.Unlock()
	return api.ct.StopWatchCertificate(handler)
}

// Certificate returns CertificateAPI
func (ct *ctrlerCtx) Certificate() CertificateAPI {
	return &certificateAPI{ct: ct}
}

// TrafficEncryptionPolicy is a wrapper object that implements additional functionality
type TrafficEncryptionPolicy struct {
	sync.Mutex
	security.TrafficEncryptionPolicy
	HandlerCtx interface{} // additional state handlers can store
	ctrler     *ctrlerCtx  // reference back to the controller instance
}

func (obj *TrafficEncryptionPolicy) Write() error {
	// if there is no API server to connect to, we are done
	if (obj.ctrler == nil) || (obj.ctrler.resolver == nil) || obj.ctrler.apisrvURL == "" {
		return nil
	}

	apicl, err := obj.ctrler.apiClient()
	if err != nil {
		obj.ctrler.logger.Errorf("Error creating API server clent. Err: %v", err)
		return err
	}

	obj.ctrler.stats.Counter("TrafficEncryptionPolicy_Writes").Inc()

	// write to api server
	if obj.ObjectMeta.ResourceVersion != "" {
		// update it
		for i := 0; i < maxApisrvWriteRetry; i++ {
			_, err = apicl.SecurityV1().TrafficEncryptionPolicy().UpdateStatus(context.Background(), &obj.TrafficEncryptionPolicy)
			if err == nil {
				break
			}
			time.Sleep(time.Millisecond * 100)
		}
	} else {
		//  create
		_, err = apicl.SecurityV1().TrafficEncryptionPolicy().Create(context.Background(), &obj.TrafficEncryptionPolicy)
	}

	return nil
}

// TrafficEncryptionPolicyHandler is the event handler for TrafficEncryptionPolicy object
type TrafficEncryptionPolicyHandler interface {
	OnTrafficEncryptionPolicyCreate(obj *TrafficEncryptionPolicy) error
	OnTrafficEncryptionPolicyUpdate(oldObj *TrafficEncryptionPolicy, newObj *security.TrafficEncryptionPolicy) error
	OnTrafficEncryptionPolicyDelete(obj *TrafficEncryptionPolicy) error
	GetTrafficEncryptionPolicyWatchOptions() *api.ListWatchOptions
}

// OnTrafficEncryptionPolicyCreate is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnTrafficEncryptionPolicyCreate(obj *TrafficEncryptionPolicy) error {
	log.Info("OnTrafficEncryptionPolicyCreate is not implemented")
	return nil
}

// OnTrafficEncryptionPolicyUpdate is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnTrafficEncryptionPolicyUpdate(oldObj *TrafficEncryptionPolicy, newObj *security.TrafficEncryptionPolicy) error {
	log.Info("OnTrafficEncryptionPolicyUpdate is not implemented")
	return nil
}

// OnTrafficEncryptionPolicyDelete is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnTrafficEncryptionPolicyDelete(obj *TrafficEncryptionPolicy) error {
	log.Info("OnTrafficEncryptionPolicyDelete is not implemented")
	return nil
}

// GetTrafficEncryptionPolicyWatchOptions is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) GetTrafficEncryptionPolicyWatchOptions() *api.ListWatchOptions {
	log.Info("GetTrafficEncryptionPolicyWatchOptions is not implemented")
	opts := &api.ListWatchOptions{}
	return opts
}

// handleTrafficEncryptionPolicyEvent handles TrafficEncryptionPolicy events from watcher
func (ct *ctrlerCtx) handleTrafficEncryptionPolicyEvent(evt *kvstore.WatchEvent) error {

	if ct.objResolver == nil {
		return ct.handleTrafficEncryptionPolicyEventNoResolver(evt)
	}

	switch tp := evt.Object.(type) {
	case *security.TrafficEncryptionPolicy:
		eobj := evt.Object.(*security.TrafficEncryptionPolicy)
		kind := "TrafficEncryptionPolicy"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ctx := &trafficencryptionpolicyCtx{event: evt.Type,
			obj: &TrafficEncryptionPolicy{TrafficEncryptionPolicy: *eobj, ctrler: ct}}

		var err error
		switch evt.Type {
		case kvstore.Created:
			err = ct.processAdd(ctx)
		case kvstore.Updated:
			err = ct.processUpdate(ctx)
		case kvstore.Deleted:
			err = ct.processDelete(ctx)
		}
		return err
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on TrafficEncryptionPolicy watch channel", tp)
	}

	return nil
}

// handleTrafficEncryptionPolicyEventNoResolver handles TrafficEncryptionPolicy events from watcher
func (ct *ctrlerCtx) handleTrafficEncryptionPolicyEventNoResolver(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *security.TrafficEncryptionPolicy:
		eobj := evt.Object.(*security.TrafficEncryptionPolicy)
		kind := "TrafficEncryptionPolicy"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		trafficencryptionpolicyHandler := handler.(TrafficEncryptionPolicyHandler)
		// handle based on event type
		ctrlCtx := &trafficencryptionpolicyCtx{event: evt.Type, obj: &TrafficEncryptionPolicy{TrafficEncryptionPolicy: *eobj, ctrler: ct}}
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			fobj, err := ct.getObject(kind, ctrlCtx.GetKey())
			if err != nil {
				ct.addObject(ctrlCtx)
				ct.stats.Counter("TrafficEncryptionPolicy_Created_Events").Inc()

				// call the event handler
				ctrlCtx.Lock()
				err = trafficencryptionpolicyHandler.OnTrafficEncryptionPolicyCreate(ctrlCtx.obj)
				ctrlCtx.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctrlCtx.obj, err)
					ct.delObject(kind, ctrlCtx.GetKey())
					return err
				}
			} else {
				ctrlCtx := fobj.(*trafficencryptionpolicyCtx)
				ct.stats.Counter("TrafficEncryptionPolicy_Updated_Events").Inc()
				ctrlCtx.Lock()
				p := security.TrafficEncryptionPolicy{Spec: eobj.Spec,
					ObjectMeta: eobj.ObjectMeta,
					TypeMeta:   eobj.TypeMeta,
					Status:     eobj.Status}

				err = trafficencryptionpolicyHandler.OnTrafficEncryptionPolicyUpdate(ctrlCtx.obj, &p)
				ctrlCtx.obj.TrafficEncryptionPolicy = *eobj
				ctrlCtx.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctrlCtx.obj, err)
					return err
				}

			}
		case kvstore.Deleted:
			ctrlCtx := &trafficencryptionpolicyCtx{event: evt.Type, obj: &TrafficEncryptionPolicy{TrafficEncryptionPolicy: *eobj, ctrler: ct}}
			fobj, err := ct.findObject(kind, ctrlCtx.GetKey())
			if err != nil {
				ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
				return err
			}

			obj := fobj.(*TrafficEncryptionPolicy)
			ct.stats.Counter("TrafficEncryptionPolicy_Deleted_Events").Inc()
			obj.Lock()
			err = trafficencryptionpolicyHandler.OnTrafficEncryptionPolicyDelete(obj)
			obj.Unlock()
			if err != nil {
				ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
			}
			ct.delObject(kind, ctrlCtx.GetKey())
			return nil

		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on TrafficEncryptionPolicy watch channel", tp)
	}

	return nil
}

type trafficencryptionpolicyCtx struct {
	ctkitBaseCtx
	event kvstore.WatchEventType
	obj   *TrafficEncryptionPolicy //
	//   newObj     *security.TrafficEncryptionPolicy //update
	newObj *trafficencryptionpolicyCtx //update
}

func (ctx *trafficencryptionpolicyCtx) References() map[string]apiintf.ReferenceObj {
	resp := make(map[string]apiintf.ReferenceObj)
	ctx.obj.References(ctx.obj.GetObjectMeta().Name, ctx.obj.GetObjectMeta().Namespace, resp)
	return resp
}

func (ctx *trafficencryptionpolicyCtx) GetKey() string {
	return ctx.obj.MakeKey("security")
}

func (ctx *trafficencryptionpolicyCtx) GetKind() string {
	return ctx.obj.GetKind()
}

func (ctx *trafficencryptionpolicyCtx) SetEvent(event kvstore.WatchEventType) {
	ctx.event = event
}

func (ctx *trafficencryptionpolicyCtx) SetNewObj(newObj apiintf.CtkitObject) {
	if newObj == nil {
		ctx.newObj = nil
	} else {
		ctx.newObj = newObj.(*trafficencryptionpolicyCtx)
		ctx.newObj.obj.HandlerCtx = ctx.obj.HandlerCtx
	}
}

func (ctx *trafficencryptionpolicyCtx) GetNewObj() apiintf.CtkitObject {
	return ctx.newObj
}

func (ctx *trafficencryptionpolicyCtx) Copy(obj apiintf.CtkitObject) {
	ctx.obj.TrafficEncryptionPolicy = obj.(*trafficencryptionpolicyCtx).obj.TrafficEncryptionPolicy
}

func (ctx *trafficencryptionpolicyCtx) Lock() {
	ctx.obj.Lock()
}

func (ctx *trafficencryptionpolicyCtx) Unlock() {
	ctx.obj.Unlock()
}

func (ctx *trafficencryptionpolicyCtx) GetObjectMeta() *api.ObjectMeta {
	return ctx.obj.GetObjectMeta()
}

func (ctx *trafficencryptionpolicyCtx) RuntimeObject() runtime.Object {
	var v interface{}
	v = ctx.obj
	return v.(runtime.Object)
}

func (ctx *trafficencryptionpolicyCtx) WorkFunc(context context.Context) error {
	var err error
	evt := ctx.event
	ct := ctx.obj.ctrler
	kind := "TrafficEncryptionPolicy"
	ct.Lock()
	handler, ok := ct.handlers[kind]
	ct.Unlock()
	if !ok {
		ct.logger.Fatalf("Cant find the handler for %s", kind)
	}
	trafficencryptionpolicyHandler := handler.(TrafficEncryptionPolicyHandler)
	switch evt {
	case kvstore.Created:
		ctx.obj.Lock()
		err = trafficencryptionpolicyHandler.OnTrafficEncryptionPolicyCreate(ctx.obj)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctx.obj, err)
			ctx.SetEvent(kvstore.Deleted)
		}
	case kvstore.Updated:
		ct.stats.Counter("TrafficEncryptionPolicy_Updated_Events").Inc()
		ctx.obj.Lock()
		p := security.TrafficEncryptionPolicy{Spec: ctx.newObj.obj.Spec,
			ObjectMeta: ctx.newObj.obj.ObjectMeta,
			TypeMeta:   ctx.newObj.obj.TypeMeta,
			Status:     ctx.newObj.obj.Status}
		err = trafficencryptionpolicyHandler.OnTrafficEncryptionPolicyUpdate(ctx.obj, &p)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctx.obj, err)
			ctx.SetEvent(kvstore.Deleted)
		}
	case kvstore.Deleted:
		ctx.obj.Lock()
		err = trafficencryptionpolicyHandler.OnTrafficEncryptionPolicyDelete(ctx.obj)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error deleting %s %+v. Err: %v", kind, ctx.obj, err)
		}
	}
	ct.resolveObject(ctx.event, ctx)
	return nil
}

// handleTrafficEncryptionPolicyEventParallel handles TrafficEncryptionPolicy events from watcher
func (ct *ctrlerCtx) handleTrafficEncryptionPolicyEventParallel(evt *kvstore.WatchEvent) error {

	if ct.objResolver == nil {
		return ct.handleTrafficEncryptionPolicyEventParallelWithNoResolver(evt)
	}

	switch tp := evt.Object.(type) {
	case *security.TrafficEncryptionPolicy:
		eobj := evt.Object.(*security.TrafficEncryptionPolicy)
		kind := "TrafficEncryptionPolicy"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ctx := &trafficencryptionpolicyCtx{event: evt.Type, obj: &TrafficEncryptionPolicy{TrafficEncryptionPolicy: *eobj, ctrler: ct}}

		var err error
		switch evt.Type {
		case kvstore.Created:
			err = ct.processAdd(ctx)
		case kvstore.Updated:
			err = ct.processUpdate(ctx)
		case kvstore.Deleted:
			err = ct.processDelete(ctx)
		}
		return err
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on TrafficEncryptionPolicy watch channel", tp)
	}

	return nil
}

// handleTrafficEncryptionPolicyEventParallel handles TrafficEncryptionPolicy events from watcher
func (ct *ctrlerCtx) handleTrafficEncryptionPolicyEventParallelWithNoResolver(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *security.TrafficEncryptionPolicy:
		eobj := evt.Object.(*security.TrafficEncryptionPolicy)
		kind := "TrafficEncryptionPolicy"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		trafficencryptionpolicyHandler := handler.(TrafficEncryptionPolicyHandler)
		// handle based on event type
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			workFunc := func(ctx context.Context, ctrlCtx shardworkers.WorkObj) error {
				var err error
				workCtx := ctrlCtx.(*trafficencryptionpolicyCtx)
				eobj := workCtx.obj
				fobj, err := ct.getObject(kind, workCtx.GetKey())
				if err != nil {
					ct.addObject(workCtx)
					ct.stats.Counter("TrafficEncryptionPolicy_Created_Events").Inc()
					eobj.Lock()
					err = trafficencryptionpolicyHandler.OnTrafficEncryptionPolicyCreate(eobj)
					eobj.Unlock()
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, eobj, err)
						ct.delObject(kind, workCtx.GetKey())
					}
				} else {
					workCtx := fobj.(*trafficencryptionpolicyCtx)
					obj := workCtx.obj
					ct.stats.Counter("TrafficEncryptionPolicy_Updated_Events").Inc()
					obj.Lock()
					p := security.TrafficEncryptionPolicy{Spec: eobj.Spec,
						ObjectMeta: eobj.ObjectMeta,
						TypeMeta:   eobj.TypeMeta,
						Status:     eobj.Status}

					err = trafficencryptionpolicyHandler.OnTrafficEncryptionPolicyUpdate(obj, &p)
					workCtx.obj.TrafficEncryptionPolicy = p
					obj.Unlock()
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					}
				}
				return err
			}
			ctrlCtx := &trafficencryptionpolicyCtx{event: evt.Type, obj: &TrafficEncryptionPolicy{TrafficEncryptionPolicy: *eobj, ctrler: ct}}
			ct.runFunction("TrafficEncryptionPolicy", ctrlCtx, workFunc)
		case kvstore.Deleted:
			workFunc := func(ctx context.Context, ctrlCtx shardworkers.WorkObj) error {
				var err error
				workCtx := ctrlCtx.(*trafficencryptionpolicyCtx)
				eobj := workCtx.obj
				fobj, err := ct.findObject(kind, workCtx.GetKey())
				if err != nil {
					ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
					return err
				}
				obj := fobj.(*TrafficEncryptionPolicy)
				ct.stats.Counter("TrafficEncryptionPolicy_Deleted_Events").Inc()
				obj.Lock()
				err = trafficencryptionpolicyHandler.OnTrafficEncryptionPolicyDelete(obj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
				}
				ct.delObject(kind, workCtx.GetKey())
				return nil
			}
			ctrlCtx := &trafficencryptionpolicyCtx{event: evt.Type, obj: &TrafficEncryptionPolicy{TrafficEncryptionPolicy: *eobj, ctrler: ct}}
			ct.runFunction("TrafficEncryptionPolicy", ctrlCtx, workFunc)
		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on TrafficEncryptionPolicy watch channel", tp)
	}

	return nil
}

// diffTrafficEncryptionPolicy does a diff of TrafficEncryptionPolicy objects between local cache and API server
func (ct *ctrlerCtx) diffTrafficEncryptionPolicy(apicl apiclient.Services) {
	opts := api.ListWatchOptions{}

	// get a list of all objects from API server
	objlist, err := apicl.SecurityV1().TrafficEncryptionPolicy().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Errorf("Error getting a list of objects. Err: %v", err)
		return
	}

	ct.logger.Infof("diffTrafficEncryptionPolicy(): TrafficEncryptionPolicyList returned %d objects", len(objlist))

	// build an object map
	objmap := make(map[string]*security.TrafficEncryptionPolicy)
	for _, obj := range objlist {
		objmap[obj.GetKey()] = obj
	}

	list, err := ct.TrafficEncryptionPolicy().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Infof("Failed to get a list of objects. Err: %s", err)
		return
	}

	// if an object is in our local cache and not in API server, trigger delete for it
	for _, obj := range list {
		_, ok := objmap[obj.GetKey()]
		if !ok {
			ct.logger.Infof("diffTrafficEncryptionPolicy(): Deleting existing object %#v since its not in apiserver", obj.GetKey())
			evt := kvstore.WatchEvent{
				Type:   kvstore.Deleted,
				Key:    obj.GetKey(),
				Object: &obj.TrafficEncryptionPolicy,
			}
			ct.handleTrafficEncryptionPolicyEvent(&evt)
		}
	}

	// trigger create event for all others
	for _, obj := range objlist {
		ct.logger.Infof("diffTrafficEncryptionPolicy(): Adding object %#v", obj.GetKey())
		evt := kvstore.WatchEvent{
			Type:   kvstore.Created,
			Key:    obj.GetKey(),
			Object: obj,
		}
		ct.handleTrafficEncryptionPolicyEvent(&evt)
	}
}

func (ct *ctrlerCtx) runTrafficEncryptionPolicyWatcher() {
	kind := "TrafficEncryptionPolicy"

	ct.Lock()
	handler, ok := ct.handlers[kind]
	ct.Unlock()
	if !ok {
		ct.logger.Fatalf("Cant find the handler for %s", kind)
	}
	trafficencryptionpolicyHandler := handler.(TrafficEncryptionPolicyHandler)

	opts := trafficencryptionpolicyHandler.GetTrafficEncryptionPolicyWatchOptions()

	// if there is no API server to connect to, we are done
	if (ct.resolver == nil) || ct.apisrvURL == "" {
		return
	}

	// create context
	ctx, cancel := context.WithCancel(context.Background())
	ct.Lock()
	ct.watchCancel[kind] = cancel
	ct.Unlock()
	logger := ct.logger.WithContext("submodule", "TrafficEncryptionPolicyWatcher")

	// create a grpc client
	apiclt, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
	if err == nil {
		ct.diffTrafficEncryptionPolicy(apiclt)
	}

	// setup wait group
	ct.waitGrp.Add(1)

	// start a goroutine
	go func() {
		defer ct.waitGrp.Done()
		ct.stats.Counter("TrafficEncryptionPolicy_Watch").Inc()
		defer ct.stats.Counter("TrafficEncryptionPolicy_Watch").Dec()

		// loop forever
		for {
			// create a grpc client
			apicl, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
			if err != nil {
				logger.Warnf("Failed to connect to gRPC server [%s]\n", ct.apisrvURL)
				ct.stats.Counter("TrafficEncryptionPolicy_ApiClientErr").Inc()
			} else {
				logger.Infof("API client connected {%+v}", apicl)

				// TrafficEncryptionPolicy object watcher
				wt, werr := apicl.SecurityV1().TrafficEncryptionPolicy().Watch(ctx, opts)
				if werr != nil {
					select {
					case <-ctx.Done():
						logger.Infof("watch %s cancelled", kind)
						return
					default:
					}
					logger.Errorf("Failed to start %s watch (%s)\n", kind, werr)
					// wait for a second and retry connecting to api server
					apicl.Close()
					time.Sleep(time.Second)
					continue
				}
				ct.Lock()
				ct.watchers[kind] = wt
				ct.Unlock()

				// perform a diff with API server and local cache
				time.Sleep(time.Millisecond * 100)
				ct.diffTrafficEncryptionPolicy(apicl)

				// handle api server watch events
			innerLoop:
				for {
					// wait for events
					select {
					case evt, ok := <-wt.EventChan():
						if !ok {
							logger.Error("Error receiving from apisrv watcher")
							ct.stats.Counter("TrafficEncryptionPolicy_WatchErrors").Inc()
							break innerLoop
						}

						// handle event in parallel
						ct.handleTrafficEncryptionPolicyEventParallel(evt)
					}
				}
				apicl.Close()
			}

			// if stop flag is set, we are done
			if ct.stoped {
				logger.Infof("Exiting API server watcher")
				return
			}

			// wait for a second and retry connecting to api server
			time.Sleep(time.Second)
		}
	}()
}

// WatchTrafficEncryptionPolicy starts watch on TrafficEncryptionPolicy object
func (ct *ctrlerCtx) WatchTrafficEncryptionPolicy(handler TrafficEncryptionPolicyHandler) error {
	kind := "TrafficEncryptionPolicy"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchers[kind]
	ct.Unlock()
	if ok {
		return fmt.Errorf("TrafficEncryptionPolicy watcher already exists")
	}

	// save handler
	ct.Lock()
	ct.handlers[kind] = handler
	ct.Unlock()

	// run TrafficEncryptionPolicy watcher in a go routine
	ct.runTrafficEncryptionPolicyWatcher()

	return nil
}

// StopWatchTrafficEncryptionPolicy stops watch on TrafficEncryptionPolicy object
func (ct *ctrlerCtx) StopWatchTrafficEncryptionPolicy(handler TrafficEncryptionPolicyHandler) error {
	kind := "TrafficEncryptionPolicy"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchers[kind]
	ct.Unlock()
	if !ok {
		return fmt.Errorf("TrafficEncryptionPolicy watcher does not exist")
	}

	ct.Lock()
	cancel, _ := ct.watchCancel[kind]
	cancel()
	delete(ct.watchers, kind)
	delete(ct.watchCancel, kind)
	ct.Unlock()

	time.Sleep(100 * time.Millisecond)

	return nil
}

// TrafficEncryptionPolicyAPI returns
type TrafficEncryptionPolicyAPI interface {
	Create(obj *security.TrafficEncryptionPolicy) error
	CreateEvent(obj *security.TrafficEncryptionPolicy) error
	Update(obj *security.TrafficEncryptionPolicy) error
	Delete(obj *security.TrafficEncryptionPolicy) error
	Find(meta *api.ObjectMeta) (*TrafficEncryptionPolicy, error)
	List(ctx context.Context, opts *api.ListWatchOptions) ([]*TrafficEncryptionPolicy, error)
	Watch(handler TrafficEncryptionPolicyHandler) error
	StopWatch(handler TrafficEncryptionPolicyHandler) error
}

// dummy struct that implements TrafficEncryptionPolicyAPI
type trafficencryptionpolicyAPI struct {
	ct *ctrlerCtx
}

// Create creates TrafficEncryptionPolicy object
func (api *trafficencryptionpolicyAPI) Create(obj *security.TrafficEncryptionPolicy) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.SecurityV1().TrafficEncryptionPolicy().Create(context.Background(), obj)
		if err != nil && strings.Contains(err.Error(), "AlreadyExists") {
			_, err = apicl.SecurityV1().TrafficEncryptionPolicy().Update(context.Background(), obj)
		}
		return err
	}

	api.ct.handleTrafficEncryptionPolicyEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Created})
	return nil
}

// CreateEvent creates TrafficEncryptionPolicy object and synchronously triggers local event
func (api *trafficencryptionpolicyAPI) CreateEvent(obj *security.TrafficEncryptionPolicy) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.SecurityV1().TrafficEncryptionPolicy().Create(context.Background(), obj)
		if err != nil && strings.Contains(err.Error(), "AlreadyExists") {
			_, err = apicl.SecurityV1().TrafficEncryptionPolicy().Update(context.Background(), obj)
		}
		if err != nil {
			api.ct.logger.Errorf("Error creating object in api server. Err: %v", err)
			return err
		}
		return err
	}

	api.ct.handleTrafficEncryptionPolicyEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Created})
	return nil
}

// Update triggers update on TrafficEncryptionPolicy object
func (api *trafficencryptionpolicyAPI) Update(obj *security.TrafficEncryptionPolicy) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.SecurityV1().TrafficEncryptionPolicy().Update(context.Background(), obj)
		return err
	}

	api.ct.handleTrafficEncryptionPolicyEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Updated})
	return nil
}

// Delete deletes TrafficEncryptionPolicy object
func (api *trafficencryptionpolicyAPI) Delete(obj *security.TrafficEncryptionPolicy) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.SecurityV1().TrafficEncryptionPolicy().Delete(context.Background(), &obj.ObjectMeta)
		return err
	}

	api.ct.handleTrafficEncryptionPolicyEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Deleted})
	return nil
}

// MakeKey generates a KV store key for the object
func (api *trafficencryptionpolicyAPI) getFullKey(tenant, name string) string {
	if tenant != "" {
		return fmt.Sprint(globals.ConfigRootPrefix, "/", "security", "/", "trafficEncryptionPolicy", "/", tenant, "/", name)
	}
	return fmt.Sprint(globals.ConfigRootPrefix, "/", "security", "/", "trafficEncryptionPolicy", "/", name)
}

// Find returns an object by meta
func (api *trafficencryptionpolicyAPI) Find(meta *api.ObjectMeta) (*TrafficEncryptionPolicy, error) {
	// find the object
	obj, err := api.ct.FindObject("TrafficEncryptionPolicy", meta)
	if err != nil {
		return nil, err
	}

	// asset type
	switch obj.(type) {
	case *TrafficEncryptionPolicy:
		hobj := obj.(*TrafficEncryptionPolicy)
		return hobj, nil
	default:
		return nil, errors.New("incorrect object type")
	}
}

// List returns a list of all TrafficEncryptionPolicy objects
func (api *trafficencryptionpolicyAPI) List(ctx context.Context, opts *api.ListWatchOptions) ([]*TrafficEncryptionPolicy, error) {
	var objlist []*TrafficEncryptionPolicy
	objs, err := api.ct.List("TrafficEncryptionPolicy", ctx, opts)

	if err != nil {
		return nil, err
	}

	for _, obj := range objs {
		switch tp := obj.(type) {
		case *TrafficEncryptionPolicy:
			eobj := obj.(*TrafficEncryptionPolicy)
			objlist = append(objlist, eobj)
		default:
			log.Fatalf("Got invalid object type %v while looking for TrafficEncryptionPolicy", tp)
		}
	}

	return objlist, nil
}

// Watch sets up a event handlers for TrafficEncryptionPolicy object
func (api *trafficencryptionpolicyAPI) Watch(handler TrafficEncryptionPolicyHandler) error {
	api.ct.startWorkerPool("TrafficEncryptionPolicy")
	return api.ct.WatchTrafficEncryptionPolicy(handler)
}

// StopWatch stop watch for Tenant TrafficEncryptionPolicy object
func (api *trafficencryptionpolicyAPI) StopWatch(handler TrafficEncryptionPolicyHandler) error {
	api.ct.Lock()
	api.ct.workPools["TrafficEncryptionPolicy"].Stop()
	api.ct.Unlock()
	return api.ct.StopWatchTrafficEncryptionPolicy(handler)
}

// TrafficEncryptionPolicy returns TrafficEncryptionPolicyAPI
func (ct *ctrlerCtx) TrafficEncryptionPolicy() TrafficEncryptionPolicyAPI {
	return &trafficencryptionpolicyAPI{ct: ct}
}
