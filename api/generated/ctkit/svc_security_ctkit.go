// Code generated by protoc-gen-grpc-pensando DO NOT EDIT.

/*
Package ctkit is a auto generated package.
Input file: svc_security.proto
*/
package ctkit

import (
	"context"
	"errors"
	"fmt"
	"strings"
	"sync"
	"time"

	"github.com/pensando/sw/api"
	"github.com/pensando/sw/api/generated/apiclient"
	"github.com/pensando/sw/api/generated/security"
	"github.com/pensando/sw/venice/utils/balancer"
	"github.com/pensando/sw/venice/utils/kvstore"
	"github.com/pensando/sw/venice/utils/log"
	"github.com/pensando/sw/venice/utils/rpckit"
	"github.com/pensando/sw/venice/utils/shardworkers"
)

// SecurityGroup is a wrapper object that implements additional functionality
type SecurityGroup struct {
	sync.Mutex
	security.SecurityGroup
	HandlerCtx interface{} // additional state handlers can store
	ctrler     *ctrlerCtx  // reference back to the controller instance
}

func (obj *SecurityGroup) Write() error {
	// if there is no API server to connect to, we are done
	if (obj.ctrler == nil) || (obj.ctrler.resolver == nil) || obj.ctrler.apisrvURL == "" {
		return nil
	}

	apicl, err := obj.ctrler.apiClient()
	if err != nil {
		obj.ctrler.logger.Errorf("Error creating API server clent. Err: %v", err)
		return err
	}

	obj.ctrler.stats.Counter("SecurityGroup_Writes").Inc()

	// write to api server
	if obj.ObjectMeta.ResourceVersion != "" {
		// update it
		for i := 0; i < maxApisrvWriteRetry; i++ {
			_, err = apicl.SecurityV1().SecurityGroup().UpdateStatus(context.Background(), &obj.SecurityGroup)
			if err == nil {
				break
			}
			time.Sleep(time.Millisecond * 100)
		}
	} else {
		//  create
		_, err = apicl.SecurityV1().SecurityGroup().Create(context.Background(), &obj.SecurityGroup)
	}

	return nil
}

// SecurityGroupHandler is the event handler for SecurityGroup object
type SecurityGroupHandler interface {
	OnSecurityGroupCreate(obj *SecurityGroup) error
	OnSecurityGroupUpdate(oldObj *SecurityGroup, newObj *security.SecurityGroup) error
	OnSecurityGroupDelete(obj *SecurityGroup) error
}

// handleSecurityGroupEvent handles SecurityGroup events from watcher
func (ct *ctrlerCtx) handleSecurityGroupEvent(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *security.SecurityGroup:
		eobj := evt.Object.(*security.SecurityGroup)
		kind := "SecurityGroup"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		handler, ok := ct.handlers[kind]
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		securitygroupHandler := handler.(SecurityGroupHandler)
		// handle based on event type
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			fobj, err := ct.findObject(kind, eobj.GetKey())
			if err != nil {
				obj := &SecurityGroup{
					SecurityGroup: *eobj,
					HandlerCtx:    nil,
					ctrler:        ct,
				}
				ct.addObject(kind, obj.GetKey(), obj)
				ct.stats.Counter("SecurityGroup_Created_Events").Inc()

				// call the event handler
				obj.Lock()
				err = securitygroupHandler.OnSecurityGroupCreate(obj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					ct.delObject(kind, eobj.GetKey())
					return err
				}
			} else {
				obj := fobj.(*SecurityGroup)

				ct.stats.Counter("SecurityGroup_Updated_Events").Inc()

				// call the event handler
				obj.Lock()
				err = securitygroupHandler.OnSecurityGroupUpdate(obj, eobj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					return err
				}
			}
		case kvstore.Deleted:
			fobj, err := ct.findObject(kind, eobj.GetKey())
			if err != nil {
				ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
				return err
			}

			obj := fobj.(*SecurityGroup)

			ct.stats.Counter("SecurityGroup_Deleted_Events").Inc()

			// Call the event reactor
			obj.Lock()
			err = securitygroupHandler.OnSecurityGroupDelete(obj)
			obj.Unlock()
			if err != nil {
				ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
			}

			ct.delObject(kind, eobj.GetKey())
		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on SecurityGroup watch channel", tp)
	}

	return nil
}

// handleSecurityGroupEventParallel handles SecurityGroup events from watcher
func (ct *ctrlerCtx) handleSecurityGroupEventParallel(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *security.SecurityGroup:
		eobj := evt.Object.(*security.SecurityGroup)
		kind := "SecurityGroup"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		handler, ok := ct.handlers[kind]
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		securitygroupHandler := handler.(SecurityGroupHandler)
		// handle based on event type
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			workFunc := func(ctx context.Context, userCtx shardworkers.WorkObj) error {
				var err error
				eobj := userCtx.(*security.SecurityGroup)
				fobj, err := ct.findObject(kind, eobj.GetKey())
				if err != nil {
					obj := &SecurityGroup{
						SecurityGroup: *eobj,
						HandlerCtx:    nil,
						ctrler:        ct,
					}
					ct.addObject(kind, obj.GetKey(), obj)
					ct.stats.Counter("SecurityGroup_Created_Events").Inc()
					obj.Lock()
					err = securitygroupHandler.OnSecurityGroupCreate(obj)
					obj.Unlock()
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
						ct.delObject(kind, obj.SecurityGroup.GetKey())
					}
				} else {
					obj := fobj.(*SecurityGroup)
					ct.stats.Counter("SecurityGroup_Updated_Events").Inc()
					obj.Lock()
					err = securitygroupHandler.OnSecurityGroupUpdate(obj, eobj)
					obj.Unlock()
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					}
				}
				return err
			}
			ct.runJob("SecurityGroup", eobj, workFunc)
		case kvstore.Deleted:
			workFunc := func(ctx context.Context, userCtx shardworkers.WorkObj) error {
				eobj := userCtx.(*security.SecurityGroup)
				fobj, err := ct.findObject(kind, eobj.GetKey())
				if err != nil {
					ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
					return err
				}
				obj := fobj.(*SecurityGroup)
				ct.stats.Counter("SecurityGroup_Deleted_Events").Inc()
				obj.Lock()
				err = securitygroupHandler.OnSecurityGroupDelete(obj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
				}
				ct.delObject(kind, obj.SecurityGroup.GetKey())
				return nil
			}
			ct.runJob("SecurityGroup", eobj, workFunc)
		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on SecurityGroup watch channel", tp)
	}

	return nil
}

// diffSecurityGroup does a diff of SecurityGroup objects between local cache and API server
func (ct *ctrlerCtx) diffSecurityGroup(apicl apiclient.Services) {
	opts := api.ListWatchOptions{}

	// get a list of all objects from API server
	objlist, err := apicl.SecurityV1().SecurityGroup().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Errorf("Error getting a list of objects. Err: %v", err)
		return
	}

	ct.logger.Infof("diffSecurityGroup(): SecurityGroupList returned %d objects", len(objlist))

	// build an object map
	objmap := make(map[string]*security.SecurityGroup)
	for _, obj := range objlist {
		objmap[obj.GetKey()] = obj
	}

	// if an object is in our local cache and not in API server, trigger delete for it
	for _, obj := range ct.SecurityGroup().List() {
		_, ok := objmap[obj.GetKey()]
		if !ok {
			ct.logger.Infof("diffSecurityGroup(): Deleting existing object %#v since its not in apiserver", obj.GetKey())
			evt := kvstore.WatchEvent{
				Type:   kvstore.Deleted,
				Key:    obj.GetKey(),
				Object: &obj.SecurityGroup,
			}
			ct.handleSecurityGroupEvent(&evt)
		}
	}

	// trigger create event for all others
	for _, obj := range objlist {
		ct.logger.Infof("diffSecurityGroup(): Adding object %#v", obj.GetKey())
		evt := kvstore.WatchEvent{
			Type:   kvstore.Created,
			Key:    obj.GetKey(),
			Object: obj,
		}
		ct.handleSecurityGroupEvent(&evt)
	}
}

func (ct *ctrlerCtx) runSecurityGroupWatcher() {
	kind := "SecurityGroup"

	// if there is no API server to connect to, we are done
	if (ct.resolver == nil) || ct.apisrvURL == "" {
		return
	}

	// create context
	ctx, cancel := context.WithCancel(context.Background())
	ct.Lock()
	ct.watchCancel[kind] = cancel
	ct.Unlock()
	opts := api.ListWatchOptions{}
	logger := ct.logger.WithContext("submodule", "SecurityGroupWatcher")

	// create a grpc client
	apiclt, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
	if err == nil {
		ct.diffSecurityGroup(apiclt)
	}

	// setup wait group
	ct.waitGrp.Add(1)

	// start a goroutine
	go func() {
		defer ct.waitGrp.Done()
		ct.stats.Counter("SecurityGroup_Watch").Inc()
		defer ct.stats.Counter("SecurityGroup_Watch").Dec()

		// loop forever
		for {
			// create a grpc client
			apicl, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
			if err != nil {
				logger.Warnf("Failed to connect to gRPC server [%s]\n", ct.apisrvURL)
				ct.stats.Counter("SecurityGroup_ApiClientErr").Inc()
			} else {
				logger.Infof("API client connected {%+v}", apicl)

				// SecurityGroup object watcher
				wt, werr := apicl.SecurityV1().SecurityGroup().Watch(ctx, &opts)
				if werr != nil {
					logger.Errorf("Failed to start %s watch (%s)\n", kind, werr)
					// wait for a second and retry connecting to api server
					apicl.Close()
					time.Sleep(time.Second)
					continue
				}
				ct.Lock()
				ct.watchers[kind] = wt
				ct.Unlock()

				// perform a diff with API server and local cache
				time.Sleep(time.Millisecond * 100)
				ct.diffSecurityGroup(apicl)

				// handle api server watch events
			innerLoop:
				for {
					// wait for events
					select {
					case evt, ok := <-wt.EventChan():
						if !ok {
							logger.Error("Error receiving from apisrv watcher")
							ct.stats.Counter("SecurityGroup_WatchErrors").Inc()
							break innerLoop
						}

						// handle event in parallel
						ct.handleSecurityGroupEventParallel(evt)
					}
				}
				apicl.Close()
			}

			// if stop flag is set, we are done
			if ct.stoped {
				logger.Infof("Exiting API server watcher")
				return
			}

			// wait for a second and retry connecting to api server
			time.Sleep(time.Second)
		}
	}()
}

// WatchSecurityGroup starts watch on SecurityGroup object
func (ct *ctrlerCtx) WatchSecurityGroup(handler SecurityGroupHandler) error {
	kind := "SecurityGroup"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchers[kind]
	ct.Unlock()
	if ok {
		return fmt.Errorf("SecurityGroup watcher already exists")
	}

	// save handler
	ct.Lock()
	ct.handlers[kind] = handler
	ct.Unlock()

	// run SecurityGroup watcher in a go routine
	ct.runSecurityGroupWatcher()

	return nil
}

// SecurityGroupAPI returns
type SecurityGroupAPI interface {
	Create(obj *security.SecurityGroup) error
	Update(obj *security.SecurityGroup) error
	Delete(obj *security.SecurityGroup) error
	Find(meta *api.ObjectMeta) (*SecurityGroup, error)
	List() []*SecurityGroup
	Watch(handler SecurityGroupHandler) error
}

// dummy struct that implements SecurityGroupAPI
type securitygroupAPI struct {
	ct *ctrlerCtx
}

// Create creates SecurityGroup object
func (api *securitygroupAPI) Create(obj *security.SecurityGroup) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.SecurityV1().SecurityGroup().Create(context.Background(), obj)
		if err != nil && strings.Contains(err.Error(), "AlreadyExists") {
			_, err = apicl.SecurityV1().SecurityGroup().Update(context.Background(), obj)
		}
		return err
	}

	return api.ct.handleSecurityGroupEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Created})
}

// Update triggers update on SecurityGroup object
func (api *securitygroupAPI) Update(obj *security.SecurityGroup) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.SecurityV1().SecurityGroup().Update(context.Background(), obj)
		return err
	}

	return api.ct.handleSecurityGroupEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Updated})
}

// Delete deletes SecurityGroup object
func (api *securitygroupAPI) Delete(obj *security.SecurityGroup) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.SecurityV1().SecurityGroup().Delete(context.Background(), &obj.ObjectMeta)
		return err
	}

	return api.ct.handleSecurityGroupEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Deleted})
}

// Find returns an object by meta
func (api *securitygroupAPI) Find(meta *api.ObjectMeta) (*SecurityGroup, error) {
	// find the object
	obj, err := api.ct.FindObject("SecurityGroup", meta)
	if err != nil {
		return nil, err
	}

	// asset type
	switch obj.(type) {
	case *SecurityGroup:
		hobj := obj.(*SecurityGroup)
		return hobj, nil
	default:
		return nil, errors.New("incorrect object type")
	}
}

// List returns a list of all SecurityGroup objects
func (api *securitygroupAPI) List() []*SecurityGroup {
	var objlist []*SecurityGroup

	objs := api.ct.ListObjects("SecurityGroup")
	for _, obj := range objs {
		switch tp := obj.(type) {
		case *SecurityGroup:
			eobj := obj.(*SecurityGroup)
			objlist = append(objlist, eobj)
		default:
			log.Fatalf("Got invalid object type %v while looking for SecurityGroup", tp)
		}
	}

	return objlist
}

// Watch sets up a event handlers for SecurityGroup object
func (api *securitygroupAPI) Watch(handler SecurityGroupHandler) error {
	api.ct.startWorkerPool("SecurityGroup")
	return api.ct.WatchSecurityGroup(handler)
}

// SecurityGroup returns SecurityGroupAPI
func (ct *ctrlerCtx) SecurityGroup() SecurityGroupAPI {
	return &securitygroupAPI{ct: ct}
}

// SGPolicy is a wrapper object that implements additional functionality
type SGPolicy struct {
	sync.Mutex
	security.SGPolicy
	HandlerCtx interface{} // additional state handlers can store
	ctrler     *ctrlerCtx  // reference back to the controller instance
}

func (obj *SGPolicy) Write() error {
	// if there is no API server to connect to, we are done
	if (obj.ctrler == nil) || (obj.ctrler.resolver == nil) || obj.ctrler.apisrvURL == "" {
		return nil
	}

	apicl, err := obj.ctrler.apiClient()
	if err != nil {
		obj.ctrler.logger.Errorf("Error creating API server clent. Err: %v", err)
		return err
	}

	obj.ctrler.stats.Counter("SGPolicy_Writes").Inc()

	// write to api server
	if obj.ObjectMeta.ResourceVersion != "" {
		// update it
		for i := 0; i < maxApisrvWriteRetry; i++ {
			_, err = apicl.SecurityV1().SGPolicy().UpdateStatus(context.Background(), &obj.SGPolicy)
			if err == nil {
				break
			}
			time.Sleep(time.Millisecond * 100)
		}
	} else {
		//  create
		_, err = apicl.SecurityV1().SGPolicy().Create(context.Background(), &obj.SGPolicy)
	}

	return nil
}

// SGPolicyHandler is the event handler for SGPolicy object
type SGPolicyHandler interface {
	OnSGPolicyCreate(obj *SGPolicy) error
	OnSGPolicyUpdate(oldObj *SGPolicy, newObj *security.SGPolicy) error
	OnSGPolicyDelete(obj *SGPolicy) error
}

// handleSGPolicyEvent handles SGPolicy events from watcher
func (ct *ctrlerCtx) handleSGPolicyEvent(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *security.SGPolicy:
		eobj := evt.Object.(*security.SGPolicy)
		kind := "SGPolicy"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		handler, ok := ct.handlers[kind]
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		sgpolicyHandler := handler.(SGPolicyHandler)
		// handle based on event type
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			fobj, err := ct.findObject(kind, eobj.GetKey())
			if err != nil {
				obj := &SGPolicy{
					SGPolicy:   *eobj,
					HandlerCtx: nil,
					ctrler:     ct,
				}
				ct.addObject(kind, obj.GetKey(), obj)
				ct.stats.Counter("SGPolicy_Created_Events").Inc()

				// call the event handler
				obj.Lock()
				err = sgpolicyHandler.OnSGPolicyCreate(obj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					ct.delObject(kind, eobj.GetKey())
					return err
				}
			} else {
				obj := fobj.(*SGPolicy)

				ct.stats.Counter("SGPolicy_Updated_Events").Inc()

				// call the event handler
				obj.Lock()
				err = sgpolicyHandler.OnSGPolicyUpdate(obj, eobj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					return err
				}
			}
		case kvstore.Deleted:
			fobj, err := ct.findObject(kind, eobj.GetKey())
			if err != nil {
				ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
				return err
			}

			obj := fobj.(*SGPolicy)

			ct.stats.Counter("SGPolicy_Deleted_Events").Inc()

			// Call the event reactor
			obj.Lock()
			err = sgpolicyHandler.OnSGPolicyDelete(obj)
			obj.Unlock()
			if err != nil {
				ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
			}

			ct.delObject(kind, eobj.GetKey())
		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on SGPolicy watch channel", tp)
	}

	return nil
}

// handleSGPolicyEventParallel handles SGPolicy events from watcher
func (ct *ctrlerCtx) handleSGPolicyEventParallel(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *security.SGPolicy:
		eobj := evt.Object.(*security.SGPolicy)
		kind := "SGPolicy"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		handler, ok := ct.handlers[kind]
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		sgpolicyHandler := handler.(SGPolicyHandler)
		// handle based on event type
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			workFunc := func(ctx context.Context, userCtx shardworkers.WorkObj) error {
				var err error
				eobj := userCtx.(*security.SGPolicy)
				fobj, err := ct.findObject(kind, eobj.GetKey())
				if err != nil {
					obj := &SGPolicy{
						SGPolicy:   *eobj,
						HandlerCtx: nil,
						ctrler:     ct,
					}
					ct.addObject(kind, obj.GetKey(), obj)
					ct.stats.Counter("SGPolicy_Created_Events").Inc()
					obj.Lock()
					err = sgpolicyHandler.OnSGPolicyCreate(obj)
					obj.Unlock()
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
						ct.delObject(kind, obj.SGPolicy.GetKey())
					}
				} else {
					obj := fobj.(*SGPolicy)
					ct.stats.Counter("SGPolicy_Updated_Events").Inc()
					obj.Lock()
					err = sgpolicyHandler.OnSGPolicyUpdate(obj, eobj)
					obj.Unlock()
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					}
				}
				return err
			}
			ct.runJob("SGPolicy", eobj, workFunc)
		case kvstore.Deleted:
			workFunc := func(ctx context.Context, userCtx shardworkers.WorkObj) error {
				eobj := userCtx.(*security.SGPolicy)
				fobj, err := ct.findObject(kind, eobj.GetKey())
				if err != nil {
					ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
					return err
				}
				obj := fobj.(*SGPolicy)
				ct.stats.Counter("SGPolicy_Deleted_Events").Inc()
				obj.Lock()
				err = sgpolicyHandler.OnSGPolicyDelete(obj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
				}
				ct.delObject(kind, obj.SGPolicy.GetKey())
				return nil
			}
			ct.runJob("SGPolicy", eobj, workFunc)
		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on SGPolicy watch channel", tp)
	}

	return nil
}

// diffSGPolicy does a diff of SGPolicy objects between local cache and API server
func (ct *ctrlerCtx) diffSGPolicy(apicl apiclient.Services) {
	opts := api.ListWatchOptions{}

	// get a list of all objects from API server
	objlist, err := apicl.SecurityV1().SGPolicy().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Errorf("Error getting a list of objects. Err: %v", err)
		return
	}

	ct.logger.Infof("diffSGPolicy(): SGPolicyList returned %d objects", len(objlist))

	// build an object map
	objmap := make(map[string]*security.SGPolicy)
	for _, obj := range objlist {
		objmap[obj.GetKey()] = obj
	}

	// if an object is in our local cache and not in API server, trigger delete for it
	for _, obj := range ct.SGPolicy().List() {
		_, ok := objmap[obj.GetKey()]
		if !ok {
			ct.logger.Infof("diffSGPolicy(): Deleting existing object %#v since its not in apiserver", obj.GetKey())
			evt := kvstore.WatchEvent{
				Type:   kvstore.Deleted,
				Key:    obj.GetKey(),
				Object: &obj.SGPolicy,
			}
			ct.handleSGPolicyEvent(&evt)
		}
	}

	// trigger create event for all others
	for _, obj := range objlist {
		ct.logger.Infof("diffSGPolicy(): Adding object %#v", obj.GetKey())
		evt := kvstore.WatchEvent{
			Type:   kvstore.Created,
			Key:    obj.GetKey(),
			Object: obj,
		}
		ct.handleSGPolicyEvent(&evt)
	}
}

func (ct *ctrlerCtx) runSGPolicyWatcher() {
	kind := "SGPolicy"

	// if there is no API server to connect to, we are done
	if (ct.resolver == nil) || ct.apisrvURL == "" {
		return
	}

	// create context
	ctx, cancel := context.WithCancel(context.Background())
	ct.Lock()
	ct.watchCancel[kind] = cancel
	ct.Unlock()
	opts := api.ListWatchOptions{}
	logger := ct.logger.WithContext("submodule", "SGPolicyWatcher")

	// create a grpc client
	apiclt, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
	if err == nil {
		ct.diffSGPolicy(apiclt)
	}

	// setup wait group
	ct.waitGrp.Add(1)

	// start a goroutine
	go func() {
		defer ct.waitGrp.Done()
		ct.stats.Counter("SGPolicy_Watch").Inc()
		defer ct.stats.Counter("SGPolicy_Watch").Dec()

		// loop forever
		for {
			// create a grpc client
			apicl, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
			if err != nil {
				logger.Warnf("Failed to connect to gRPC server [%s]\n", ct.apisrvURL)
				ct.stats.Counter("SGPolicy_ApiClientErr").Inc()
			} else {
				logger.Infof("API client connected {%+v}", apicl)

				// SGPolicy object watcher
				wt, werr := apicl.SecurityV1().SGPolicy().Watch(ctx, &opts)
				if werr != nil {
					logger.Errorf("Failed to start %s watch (%s)\n", kind, werr)
					// wait for a second and retry connecting to api server
					apicl.Close()
					time.Sleep(time.Second)
					continue
				}
				ct.Lock()
				ct.watchers[kind] = wt
				ct.Unlock()

				// perform a diff with API server and local cache
				time.Sleep(time.Millisecond * 100)
				ct.diffSGPolicy(apicl)

				// handle api server watch events
			innerLoop:
				for {
					// wait for events
					select {
					case evt, ok := <-wt.EventChan():
						if !ok {
							logger.Error("Error receiving from apisrv watcher")
							ct.stats.Counter("SGPolicy_WatchErrors").Inc()
							break innerLoop
						}

						// handle event in parallel
						ct.handleSGPolicyEventParallel(evt)
					}
				}
				apicl.Close()
			}

			// if stop flag is set, we are done
			if ct.stoped {
				logger.Infof("Exiting API server watcher")
				return
			}

			// wait for a second and retry connecting to api server
			time.Sleep(time.Second)
		}
	}()
}

// WatchSGPolicy starts watch on SGPolicy object
func (ct *ctrlerCtx) WatchSGPolicy(handler SGPolicyHandler) error {
	kind := "SGPolicy"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchers[kind]
	ct.Unlock()
	if ok {
		return fmt.Errorf("SGPolicy watcher already exists")
	}

	// save handler
	ct.Lock()
	ct.handlers[kind] = handler
	ct.Unlock()

	// run SGPolicy watcher in a go routine
	ct.runSGPolicyWatcher()

	return nil
}

// SGPolicyAPI returns
type SGPolicyAPI interface {
	Create(obj *security.SGPolicy) error
	Update(obj *security.SGPolicy) error
	Delete(obj *security.SGPolicy) error
	Find(meta *api.ObjectMeta) (*SGPolicy, error)
	List() []*SGPolicy
	Watch(handler SGPolicyHandler) error
}

// dummy struct that implements SGPolicyAPI
type sgpolicyAPI struct {
	ct *ctrlerCtx
}

// Create creates SGPolicy object
func (api *sgpolicyAPI) Create(obj *security.SGPolicy) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.SecurityV1().SGPolicy().Create(context.Background(), obj)
		if err != nil && strings.Contains(err.Error(), "AlreadyExists") {
			_, err = apicl.SecurityV1().SGPolicy().Update(context.Background(), obj)
		}
		return err
	}

	return api.ct.handleSGPolicyEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Created})
}

// Update triggers update on SGPolicy object
func (api *sgpolicyAPI) Update(obj *security.SGPolicy) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.SecurityV1().SGPolicy().Update(context.Background(), obj)
		return err
	}

	return api.ct.handleSGPolicyEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Updated})
}

// Delete deletes SGPolicy object
func (api *sgpolicyAPI) Delete(obj *security.SGPolicy) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.SecurityV1().SGPolicy().Delete(context.Background(), &obj.ObjectMeta)
		return err
	}

	return api.ct.handleSGPolicyEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Deleted})
}

// Find returns an object by meta
func (api *sgpolicyAPI) Find(meta *api.ObjectMeta) (*SGPolicy, error) {
	// find the object
	obj, err := api.ct.FindObject("SGPolicy", meta)
	if err != nil {
		return nil, err
	}

	// asset type
	switch obj.(type) {
	case *SGPolicy:
		hobj := obj.(*SGPolicy)
		return hobj, nil
	default:
		return nil, errors.New("incorrect object type")
	}
}

// List returns a list of all SGPolicy objects
func (api *sgpolicyAPI) List() []*SGPolicy {
	var objlist []*SGPolicy

	objs := api.ct.ListObjects("SGPolicy")
	for _, obj := range objs {
		switch tp := obj.(type) {
		case *SGPolicy:
			eobj := obj.(*SGPolicy)
			objlist = append(objlist, eobj)
		default:
			log.Fatalf("Got invalid object type %v while looking for SGPolicy", tp)
		}
	}

	return objlist
}

// Watch sets up a event handlers for SGPolicy object
func (api *sgpolicyAPI) Watch(handler SGPolicyHandler) error {
	api.ct.startWorkerPool("SGPolicy")
	return api.ct.WatchSGPolicy(handler)
}

// SGPolicy returns SGPolicyAPI
func (ct *ctrlerCtx) SGPolicy() SGPolicyAPI {
	return &sgpolicyAPI{ct: ct}
}

// App is a wrapper object that implements additional functionality
type App struct {
	sync.Mutex
	security.App
	HandlerCtx interface{} // additional state handlers can store
	ctrler     *ctrlerCtx  // reference back to the controller instance
}

func (obj *App) Write() error {
	// if there is no API server to connect to, we are done
	if (obj.ctrler == nil) || (obj.ctrler.resolver == nil) || obj.ctrler.apisrvURL == "" {
		return nil
	}

	apicl, err := obj.ctrler.apiClient()
	if err != nil {
		obj.ctrler.logger.Errorf("Error creating API server clent. Err: %v", err)
		return err
	}

	obj.ctrler.stats.Counter("App_Writes").Inc()

	// write to api server
	if obj.ObjectMeta.ResourceVersion != "" {
		// update it
		for i := 0; i < maxApisrvWriteRetry; i++ {
			_, err = apicl.SecurityV1().App().UpdateStatus(context.Background(), &obj.App)
			if err == nil {
				break
			}
			time.Sleep(time.Millisecond * 100)
		}
	} else {
		//  create
		_, err = apicl.SecurityV1().App().Create(context.Background(), &obj.App)
	}

	return nil
}

// AppHandler is the event handler for App object
type AppHandler interface {
	OnAppCreate(obj *App) error
	OnAppUpdate(oldObj *App, newObj *security.App) error
	OnAppDelete(obj *App) error
}

// handleAppEvent handles App events from watcher
func (ct *ctrlerCtx) handleAppEvent(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *security.App:
		eobj := evt.Object.(*security.App)
		kind := "App"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		handler, ok := ct.handlers[kind]
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		appHandler := handler.(AppHandler)
		// handle based on event type
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			fobj, err := ct.findObject(kind, eobj.GetKey())
			if err != nil {
				obj := &App{
					App:        *eobj,
					HandlerCtx: nil,
					ctrler:     ct,
				}
				ct.addObject(kind, obj.GetKey(), obj)
				ct.stats.Counter("App_Created_Events").Inc()

				// call the event handler
				obj.Lock()
				err = appHandler.OnAppCreate(obj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					ct.delObject(kind, eobj.GetKey())
					return err
				}
			} else {
				obj := fobj.(*App)

				ct.stats.Counter("App_Updated_Events").Inc()

				// call the event handler
				obj.Lock()
				err = appHandler.OnAppUpdate(obj, eobj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					return err
				}
			}
		case kvstore.Deleted:
			fobj, err := ct.findObject(kind, eobj.GetKey())
			if err != nil {
				ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
				return err
			}

			obj := fobj.(*App)

			ct.stats.Counter("App_Deleted_Events").Inc()

			// Call the event reactor
			obj.Lock()
			err = appHandler.OnAppDelete(obj)
			obj.Unlock()
			if err != nil {
				ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
			}

			ct.delObject(kind, eobj.GetKey())
		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on App watch channel", tp)
	}

	return nil
}

// handleAppEventParallel handles App events from watcher
func (ct *ctrlerCtx) handleAppEventParallel(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *security.App:
		eobj := evt.Object.(*security.App)
		kind := "App"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		handler, ok := ct.handlers[kind]
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		appHandler := handler.(AppHandler)
		// handle based on event type
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			workFunc := func(ctx context.Context, userCtx shardworkers.WorkObj) error {
				var err error
				eobj := userCtx.(*security.App)
				fobj, err := ct.findObject(kind, eobj.GetKey())
				if err != nil {
					obj := &App{
						App:        *eobj,
						HandlerCtx: nil,
						ctrler:     ct,
					}
					ct.addObject(kind, obj.GetKey(), obj)
					ct.stats.Counter("App_Created_Events").Inc()
					obj.Lock()
					err = appHandler.OnAppCreate(obj)
					obj.Unlock()
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
						ct.delObject(kind, obj.App.GetKey())
					}
				} else {
					obj := fobj.(*App)
					ct.stats.Counter("App_Updated_Events").Inc()
					obj.Lock()
					err = appHandler.OnAppUpdate(obj, eobj)
					obj.Unlock()
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					}
				}
				return err
			}
			ct.runJob("App", eobj, workFunc)
		case kvstore.Deleted:
			workFunc := func(ctx context.Context, userCtx shardworkers.WorkObj) error {
				eobj := userCtx.(*security.App)
				fobj, err := ct.findObject(kind, eobj.GetKey())
				if err != nil {
					ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
					return err
				}
				obj := fobj.(*App)
				ct.stats.Counter("App_Deleted_Events").Inc()
				obj.Lock()
				err = appHandler.OnAppDelete(obj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
				}
				ct.delObject(kind, obj.App.GetKey())
				return nil
			}
			ct.runJob("App", eobj, workFunc)
		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on App watch channel", tp)
	}

	return nil
}

// diffApp does a diff of App objects between local cache and API server
func (ct *ctrlerCtx) diffApp(apicl apiclient.Services) {
	opts := api.ListWatchOptions{}

	// get a list of all objects from API server
	objlist, err := apicl.SecurityV1().App().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Errorf("Error getting a list of objects. Err: %v", err)
		return
	}

	ct.logger.Infof("diffApp(): AppList returned %d objects", len(objlist))

	// build an object map
	objmap := make(map[string]*security.App)
	for _, obj := range objlist {
		objmap[obj.GetKey()] = obj
	}

	// if an object is in our local cache and not in API server, trigger delete for it
	for _, obj := range ct.App().List() {
		_, ok := objmap[obj.GetKey()]
		if !ok {
			ct.logger.Infof("diffApp(): Deleting existing object %#v since its not in apiserver", obj.GetKey())
			evt := kvstore.WatchEvent{
				Type:   kvstore.Deleted,
				Key:    obj.GetKey(),
				Object: &obj.App,
			}
			ct.handleAppEvent(&evt)
		}
	}

	// trigger create event for all others
	for _, obj := range objlist {
		ct.logger.Infof("diffApp(): Adding object %#v", obj.GetKey())
		evt := kvstore.WatchEvent{
			Type:   kvstore.Created,
			Key:    obj.GetKey(),
			Object: obj,
		}
		ct.handleAppEvent(&evt)
	}
}

func (ct *ctrlerCtx) runAppWatcher() {
	kind := "App"

	// if there is no API server to connect to, we are done
	if (ct.resolver == nil) || ct.apisrvURL == "" {
		return
	}

	// create context
	ctx, cancel := context.WithCancel(context.Background())
	ct.Lock()
	ct.watchCancel[kind] = cancel
	ct.Unlock()
	opts := api.ListWatchOptions{}
	logger := ct.logger.WithContext("submodule", "AppWatcher")

	// create a grpc client
	apiclt, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
	if err == nil {
		ct.diffApp(apiclt)
	}

	// setup wait group
	ct.waitGrp.Add(1)

	// start a goroutine
	go func() {
		defer ct.waitGrp.Done()
		ct.stats.Counter("App_Watch").Inc()
		defer ct.stats.Counter("App_Watch").Dec()

		// loop forever
		for {
			// create a grpc client
			apicl, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
			if err != nil {
				logger.Warnf("Failed to connect to gRPC server [%s]\n", ct.apisrvURL)
				ct.stats.Counter("App_ApiClientErr").Inc()
			} else {
				logger.Infof("API client connected {%+v}", apicl)

				// App object watcher
				wt, werr := apicl.SecurityV1().App().Watch(ctx, &opts)
				if werr != nil {
					logger.Errorf("Failed to start %s watch (%s)\n", kind, werr)
					// wait for a second and retry connecting to api server
					apicl.Close()
					time.Sleep(time.Second)
					continue
				}
				ct.Lock()
				ct.watchers[kind] = wt
				ct.Unlock()

				// perform a diff with API server and local cache
				time.Sleep(time.Millisecond * 100)
				ct.diffApp(apicl)

				// handle api server watch events
			innerLoop:
				for {
					// wait for events
					select {
					case evt, ok := <-wt.EventChan():
						if !ok {
							logger.Error("Error receiving from apisrv watcher")
							ct.stats.Counter("App_WatchErrors").Inc()
							break innerLoop
						}

						// handle event in parallel
						ct.handleAppEventParallel(evt)
					}
				}
				apicl.Close()
			}

			// if stop flag is set, we are done
			if ct.stoped {
				logger.Infof("Exiting API server watcher")
				return
			}

			// wait for a second and retry connecting to api server
			time.Sleep(time.Second)
		}
	}()
}

// WatchApp starts watch on App object
func (ct *ctrlerCtx) WatchApp(handler AppHandler) error {
	kind := "App"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchers[kind]
	ct.Unlock()
	if ok {
		return fmt.Errorf("App watcher already exists")
	}

	// save handler
	ct.Lock()
	ct.handlers[kind] = handler
	ct.Unlock()

	// run App watcher in a go routine
	ct.runAppWatcher()

	return nil
}

// AppAPI returns
type AppAPI interface {
	Create(obj *security.App) error
	Update(obj *security.App) error
	Delete(obj *security.App) error
	Find(meta *api.ObjectMeta) (*App, error)
	List() []*App
	Watch(handler AppHandler) error
}

// dummy struct that implements AppAPI
type appAPI struct {
	ct *ctrlerCtx
}

// Create creates App object
func (api *appAPI) Create(obj *security.App) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.SecurityV1().App().Create(context.Background(), obj)
		if err != nil && strings.Contains(err.Error(), "AlreadyExists") {
			_, err = apicl.SecurityV1().App().Update(context.Background(), obj)
		}
		return err
	}

	return api.ct.handleAppEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Created})
}

// Update triggers update on App object
func (api *appAPI) Update(obj *security.App) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.SecurityV1().App().Update(context.Background(), obj)
		return err
	}

	return api.ct.handleAppEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Updated})
}

// Delete deletes App object
func (api *appAPI) Delete(obj *security.App) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.SecurityV1().App().Delete(context.Background(), &obj.ObjectMeta)
		return err
	}

	return api.ct.handleAppEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Deleted})
}

// Find returns an object by meta
func (api *appAPI) Find(meta *api.ObjectMeta) (*App, error) {
	// find the object
	obj, err := api.ct.FindObject("App", meta)
	if err != nil {
		return nil, err
	}

	// asset type
	switch obj.(type) {
	case *App:
		hobj := obj.(*App)
		return hobj, nil
	default:
		return nil, errors.New("incorrect object type")
	}
}

// List returns a list of all App objects
func (api *appAPI) List() []*App {
	var objlist []*App

	objs := api.ct.ListObjects("App")
	for _, obj := range objs {
		switch tp := obj.(type) {
		case *App:
			eobj := obj.(*App)
			objlist = append(objlist, eobj)
		default:
			log.Fatalf("Got invalid object type %v while looking for App", tp)
		}
	}

	return objlist
}

// Watch sets up a event handlers for App object
func (api *appAPI) Watch(handler AppHandler) error {
	api.ct.startWorkerPool("App")
	return api.ct.WatchApp(handler)
}

// App returns AppAPI
func (ct *ctrlerCtx) App() AppAPI {
	return &appAPI{ct: ct}
}

// FirewallProfile is a wrapper object that implements additional functionality
type FirewallProfile struct {
	sync.Mutex
	security.FirewallProfile
	HandlerCtx interface{} // additional state handlers can store
	ctrler     *ctrlerCtx  // reference back to the controller instance
}

func (obj *FirewallProfile) Write() error {
	// if there is no API server to connect to, we are done
	if (obj.ctrler == nil) || (obj.ctrler.resolver == nil) || obj.ctrler.apisrvURL == "" {
		return nil
	}

	apicl, err := obj.ctrler.apiClient()
	if err != nil {
		obj.ctrler.logger.Errorf("Error creating API server clent. Err: %v", err)
		return err
	}

	obj.ctrler.stats.Counter("FirewallProfile_Writes").Inc()

	// write to api server
	if obj.ObjectMeta.ResourceVersion != "" {
		// update it
		for i := 0; i < maxApisrvWriteRetry; i++ {
			_, err = apicl.SecurityV1().FirewallProfile().UpdateStatus(context.Background(), &obj.FirewallProfile)
			if err == nil {
				break
			}
			time.Sleep(time.Millisecond * 100)
		}
	} else {
		//  create
		_, err = apicl.SecurityV1().FirewallProfile().Create(context.Background(), &obj.FirewallProfile)
	}

	return nil
}

// FirewallProfileHandler is the event handler for FirewallProfile object
type FirewallProfileHandler interface {
	OnFirewallProfileCreate(obj *FirewallProfile) error
	OnFirewallProfileUpdate(oldObj *FirewallProfile, newObj *security.FirewallProfile) error
	OnFirewallProfileDelete(obj *FirewallProfile) error
}

// handleFirewallProfileEvent handles FirewallProfile events from watcher
func (ct *ctrlerCtx) handleFirewallProfileEvent(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *security.FirewallProfile:
		eobj := evt.Object.(*security.FirewallProfile)
		kind := "FirewallProfile"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		handler, ok := ct.handlers[kind]
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		firewallprofileHandler := handler.(FirewallProfileHandler)
		// handle based on event type
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			fobj, err := ct.findObject(kind, eobj.GetKey())
			if err != nil {
				obj := &FirewallProfile{
					FirewallProfile: *eobj,
					HandlerCtx:      nil,
					ctrler:          ct,
				}
				ct.addObject(kind, obj.GetKey(), obj)
				ct.stats.Counter("FirewallProfile_Created_Events").Inc()

				// call the event handler
				obj.Lock()
				err = firewallprofileHandler.OnFirewallProfileCreate(obj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					ct.delObject(kind, eobj.GetKey())
					return err
				}
			} else {
				obj := fobj.(*FirewallProfile)

				ct.stats.Counter("FirewallProfile_Updated_Events").Inc()

				// call the event handler
				obj.Lock()
				err = firewallprofileHandler.OnFirewallProfileUpdate(obj, eobj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					return err
				}
			}
		case kvstore.Deleted:
			fobj, err := ct.findObject(kind, eobj.GetKey())
			if err != nil {
				ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
				return err
			}

			obj := fobj.(*FirewallProfile)

			ct.stats.Counter("FirewallProfile_Deleted_Events").Inc()

			// Call the event reactor
			obj.Lock()
			err = firewallprofileHandler.OnFirewallProfileDelete(obj)
			obj.Unlock()
			if err != nil {
				ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
			}

			ct.delObject(kind, eobj.GetKey())
		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on FirewallProfile watch channel", tp)
	}

	return nil
}

// handleFirewallProfileEventParallel handles FirewallProfile events from watcher
func (ct *ctrlerCtx) handleFirewallProfileEventParallel(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *security.FirewallProfile:
		eobj := evt.Object.(*security.FirewallProfile)
		kind := "FirewallProfile"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		handler, ok := ct.handlers[kind]
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		firewallprofileHandler := handler.(FirewallProfileHandler)
		// handle based on event type
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			workFunc := func(ctx context.Context, userCtx shardworkers.WorkObj) error {
				var err error
				eobj := userCtx.(*security.FirewallProfile)
				fobj, err := ct.findObject(kind, eobj.GetKey())
				if err != nil {
					obj := &FirewallProfile{
						FirewallProfile: *eobj,
						HandlerCtx:      nil,
						ctrler:          ct,
					}
					ct.addObject(kind, obj.GetKey(), obj)
					ct.stats.Counter("FirewallProfile_Created_Events").Inc()
					obj.Lock()
					err = firewallprofileHandler.OnFirewallProfileCreate(obj)
					obj.Unlock()
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
						ct.delObject(kind, obj.FirewallProfile.GetKey())
					}
				} else {
					obj := fobj.(*FirewallProfile)
					ct.stats.Counter("FirewallProfile_Updated_Events").Inc()
					obj.Lock()
					err = firewallprofileHandler.OnFirewallProfileUpdate(obj, eobj)
					obj.Unlock()
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					}
				}
				return err
			}
			ct.runJob("FirewallProfile", eobj, workFunc)
		case kvstore.Deleted:
			workFunc := func(ctx context.Context, userCtx shardworkers.WorkObj) error {
				eobj := userCtx.(*security.FirewallProfile)
				fobj, err := ct.findObject(kind, eobj.GetKey())
				if err != nil {
					ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
					return err
				}
				obj := fobj.(*FirewallProfile)
				ct.stats.Counter("FirewallProfile_Deleted_Events").Inc()
				obj.Lock()
				err = firewallprofileHandler.OnFirewallProfileDelete(obj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
				}
				ct.delObject(kind, obj.FirewallProfile.GetKey())
				return nil
			}
			ct.runJob("FirewallProfile", eobj, workFunc)
		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on FirewallProfile watch channel", tp)
	}

	return nil
}

// diffFirewallProfile does a diff of FirewallProfile objects between local cache and API server
func (ct *ctrlerCtx) diffFirewallProfile(apicl apiclient.Services) {
	opts := api.ListWatchOptions{}

	// get a list of all objects from API server
	objlist, err := apicl.SecurityV1().FirewallProfile().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Errorf("Error getting a list of objects. Err: %v", err)
		return
	}

	ct.logger.Infof("diffFirewallProfile(): FirewallProfileList returned %d objects", len(objlist))

	// build an object map
	objmap := make(map[string]*security.FirewallProfile)
	for _, obj := range objlist {
		objmap[obj.GetKey()] = obj
	}

	// if an object is in our local cache and not in API server, trigger delete for it
	for _, obj := range ct.FirewallProfile().List() {
		_, ok := objmap[obj.GetKey()]
		if !ok {
			ct.logger.Infof("diffFirewallProfile(): Deleting existing object %#v since its not in apiserver", obj.GetKey())
			evt := kvstore.WatchEvent{
				Type:   kvstore.Deleted,
				Key:    obj.GetKey(),
				Object: &obj.FirewallProfile,
			}
			ct.handleFirewallProfileEvent(&evt)
		}
	}

	// trigger create event for all others
	for _, obj := range objlist {
		ct.logger.Infof("diffFirewallProfile(): Adding object %#v", obj.GetKey())
		evt := kvstore.WatchEvent{
			Type:   kvstore.Created,
			Key:    obj.GetKey(),
			Object: obj,
		}
		ct.handleFirewallProfileEvent(&evt)
	}
}

func (ct *ctrlerCtx) runFirewallProfileWatcher() {
	kind := "FirewallProfile"

	// if there is no API server to connect to, we are done
	if (ct.resolver == nil) || ct.apisrvURL == "" {
		return
	}

	// create context
	ctx, cancel := context.WithCancel(context.Background())
	ct.Lock()
	ct.watchCancel[kind] = cancel
	ct.Unlock()
	opts := api.ListWatchOptions{}
	logger := ct.logger.WithContext("submodule", "FirewallProfileWatcher")

	// create a grpc client
	apiclt, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
	if err == nil {
		ct.diffFirewallProfile(apiclt)
	}

	// setup wait group
	ct.waitGrp.Add(1)

	// start a goroutine
	go func() {
		defer ct.waitGrp.Done()
		ct.stats.Counter("FirewallProfile_Watch").Inc()
		defer ct.stats.Counter("FirewallProfile_Watch").Dec()

		// loop forever
		for {
			// create a grpc client
			apicl, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
			if err != nil {
				logger.Warnf("Failed to connect to gRPC server [%s]\n", ct.apisrvURL)
				ct.stats.Counter("FirewallProfile_ApiClientErr").Inc()
			} else {
				logger.Infof("API client connected {%+v}", apicl)

				// FirewallProfile object watcher
				wt, werr := apicl.SecurityV1().FirewallProfile().Watch(ctx, &opts)
				if werr != nil {
					logger.Errorf("Failed to start %s watch (%s)\n", kind, werr)
					// wait for a second and retry connecting to api server
					apicl.Close()
					time.Sleep(time.Second)
					continue
				}
				ct.Lock()
				ct.watchers[kind] = wt
				ct.Unlock()

				// perform a diff with API server and local cache
				time.Sleep(time.Millisecond * 100)
				ct.diffFirewallProfile(apicl)

				// handle api server watch events
			innerLoop:
				for {
					// wait for events
					select {
					case evt, ok := <-wt.EventChan():
						if !ok {
							logger.Error("Error receiving from apisrv watcher")
							ct.stats.Counter("FirewallProfile_WatchErrors").Inc()
							break innerLoop
						}

						// handle event in parallel
						ct.handleFirewallProfileEventParallel(evt)
					}
				}
				apicl.Close()
			}

			// if stop flag is set, we are done
			if ct.stoped {
				logger.Infof("Exiting API server watcher")
				return
			}

			// wait for a second and retry connecting to api server
			time.Sleep(time.Second)
		}
	}()
}

// WatchFirewallProfile starts watch on FirewallProfile object
func (ct *ctrlerCtx) WatchFirewallProfile(handler FirewallProfileHandler) error {
	kind := "FirewallProfile"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchers[kind]
	ct.Unlock()
	if ok {
		return fmt.Errorf("FirewallProfile watcher already exists")
	}

	// save handler
	ct.Lock()
	ct.handlers[kind] = handler
	ct.Unlock()

	// run FirewallProfile watcher in a go routine
	ct.runFirewallProfileWatcher()

	return nil
}

// FirewallProfileAPI returns
type FirewallProfileAPI interface {
	Create(obj *security.FirewallProfile) error
	Update(obj *security.FirewallProfile) error
	Delete(obj *security.FirewallProfile) error
	Find(meta *api.ObjectMeta) (*FirewallProfile, error)
	List() []*FirewallProfile
	Watch(handler FirewallProfileHandler) error
}

// dummy struct that implements FirewallProfileAPI
type firewallprofileAPI struct {
	ct *ctrlerCtx
}

// Create creates FirewallProfile object
func (api *firewallprofileAPI) Create(obj *security.FirewallProfile) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.SecurityV1().FirewallProfile().Create(context.Background(), obj)
		if err != nil && strings.Contains(err.Error(), "AlreadyExists") {
			_, err = apicl.SecurityV1().FirewallProfile().Update(context.Background(), obj)
		}
		return err
	}

	return api.ct.handleFirewallProfileEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Created})
}

// Update triggers update on FirewallProfile object
func (api *firewallprofileAPI) Update(obj *security.FirewallProfile) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.SecurityV1().FirewallProfile().Update(context.Background(), obj)
		return err
	}

	return api.ct.handleFirewallProfileEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Updated})
}

// Delete deletes FirewallProfile object
func (api *firewallprofileAPI) Delete(obj *security.FirewallProfile) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.SecurityV1().FirewallProfile().Delete(context.Background(), &obj.ObjectMeta)
		return err
	}

	return api.ct.handleFirewallProfileEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Deleted})
}

// Find returns an object by meta
func (api *firewallprofileAPI) Find(meta *api.ObjectMeta) (*FirewallProfile, error) {
	// find the object
	obj, err := api.ct.FindObject("FirewallProfile", meta)
	if err != nil {
		return nil, err
	}

	// asset type
	switch obj.(type) {
	case *FirewallProfile:
		hobj := obj.(*FirewallProfile)
		return hobj, nil
	default:
		return nil, errors.New("incorrect object type")
	}
}

// List returns a list of all FirewallProfile objects
func (api *firewallprofileAPI) List() []*FirewallProfile {
	var objlist []*FirewallProfile

	objs := api.ct.ListObjects("FirewallProfile")
	for _, obj := range objs {
		switch tp := obj.(type) {
		case *FirewallProfile:
			eobj := obj.(*FirewallProfile)
			objlist = append(objlist, eobj)
		default:
			log.Fatalf("Got invalid object type %v while looking for FirewallProfile", tp)
		}
	}

	return objlist
}

// Watch sets up a event handlers for FirewallProfile object
func (api *firewallprofileAPI) Watch(handler FirewallProfileHandler) error {
	api.ct.startWorkerPool("FirewallProfile")
	return api.ct.WatchFirewallProfile(handler)
}

// FirewallProfile returns FirewallProfileAPI
func (ct *ctrlerCtx) FirewallProfile() FirewallProfileAPI {
	return &firewallprofileAPI{ct: ct}
}

// Certificate is a wrapper object that implements additional functionality
type Certificate struct {
	sync.Mutex
	security.Certificate
	HandlerCtx interface{} // additional state handlers can store
	ctrler     *ctrlerCtx  // reference back to the controller instance
}

func (obj *Certificate) Write() error {
	// if there is no API server to connect to, we are done
	if (obj.ctrler == nil) || (obj.ctrler.resolver == nil) || obj.ctrler.apisrvURL == "" {
		return nil
	}

	apicl, err := obj.ctrler.apiClient()
	if err != nil {
		obj.ctrler.logger.Errorf("Error creating API server clent. Err: %v", err)
		return err
	}

	obj.ctrler.stats.Counter("Certificate_Writes").Inc()

	// write to api server
	if obj.ObjectMeta.ResourceVersion != "" {
		// update it
		for i := 0; i < maxApisrvWriteRetry; i++ {
			_, err = apicl.SecurityV1().Certificate().UpdateStatus(context.Background(), &obj.Certificate)
			if err == nil {
				break
			}
			time.Sleep(time.Millisecond * 100)
		}
	} else {
		//  create
		_, err = apicl.SecurityV1().Certificate().Create(context.Background(), &obj.Certificate)
	}

	return nil
}

// CertificateHandler is the event handler for Certificate object
type CertificateHandler interface {
	OnCertificateCreate(obj *Certificate) error
	OnCertificateUpdate(oldObj *Certificate, newObj *security.Certificate) error
	OnCertificateDelete(obj *Certificate) error
}

// handleCertificateEvent handles Certificate events from watcher
func (ct *ctrlerCtx) handleCertificateEvent(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *security.Certificate:
		eobj := evt.Object.(*security.Certificate)
		kind := "Certificate"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		handler, ok := ct.handlers[kind]
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		certificateHandler := handler.(CertificateHandler)
		// handle based on event type
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			fobj, err := ct.findObject(kind, eobj.GetKey())
			if err != nil {
				obj := &Certificate{
					Certificate: *eobj,
					HandlerCtx:  nil,
					ctrler:      ct,
				}
				ct.addObject(kind, obj.GetKey(), obj)
				ct.stats.Counter("Certificate_Created_Events").Inc()

				// call the event handler
				obj.Lock()
				err = certificateHandler.OnCertificateCreate(obj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					ct.delObject(kind, eobj.GetKey())
					return err
				}
			} else {
				obj := fobj.(*Certificate)

				ct.stats.Counter("Certificate_Updated_Events").Inc()

				// call the event handler
				obj.Lock()
				err = certificateHandler.OnCertificateUpdate(obj, eobj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					return err
				}
			}
		case kvstore.Deleted:
			fobj, err := ct.findObject(kind, eobj.GetKey())
			if err != nil {
				ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
				return err
			}

			obj := fobj.(*Certificate)

			ct.stats.Counter("Certificate_Deleted_Events").Inc()

			// Call the event reactor
			obj.Lock()
			err = certificateHandler.OnCertificateDelete(obj)
			obj.Unlock()
			if err != nil {
				ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
			}

			ct.delObject(kind, eobj.GetKey())
		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on Certificate watch channel", tp)
	}

	return nil
}

// handleCertificateEventParallel handles Certificate events from watcher
func (ct *ctrlerCtx) handleCertificateEventParallel(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *security.Certificate:
		eobj := evt.Object.(*security.Certificate)
		kind := "Certificate"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		handler, ok := ct.handlers[kind]
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		certificateHandler := handler.(CertificateHandler)
		// handle based on event type
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			workFunc := func(ctx context.Context, userCtx shardworkers.WorkObj) error {
				var err error
				eobj := userCtx.(*security.Certificate)
				fobj, err := ct.findObject(kind, eobj.GetKey())
				if err != nil {
					obj := &Certificate{
						Certificate: *eobj,
						HandlerCtx:  nil,
						ctrler:      ct,
					}
					ct.addObject(kind, obj.GetKey(), obj)
					ct.stats.Counter("Certificate_Created_Events").Inc()
					obj.Lock()
					err = certificateHandler.OnCertificateCreate(obj)
					obj.Unlock()
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
						ct.delObject(kind, obj.Certificate.GetKey())
					}
				} else {
					obj := fobj.(*Certificate)
					ct.stats.Counter("Certificate_Updated_Events").Inc()
					obj.Lock()
					err = certificateHandler.OnCertificateUpdate(obj, eobj)
					obj.Unlock()
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					}
				}
				return err
			}
			ct.runJob("Certificate", eobj, workFunc)
		case kvstore.Deleted:
			workFunc := func(ctx context.Context, userCtx shardworkers.WorkObj) error {
				eobj := userCtx.(*security.Certificate)
				fobj, err := ct.findObject(kind, eobj.GetKey())
				if err != nil {
					ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
					return err
				}
				obj := fobj.(*Certificate)
				ct.stats.Counter("Certificate_Deleted_Events").Inc()
				obj.Lock()
				err = certificateHandler.OnCertificateDelete(obj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
				}
				ct.delObject(kind, obj.Certificate.GetKey())
				return nil
			}
			ct.runJob("Certificate", eobj, workFunc)
		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on Certificate watch channel", tp)
	}

	return nil
}

// diffCertificate does a diff of Certificate objects between local cache and API server
func (ct *ctrlerCtx) diffCertificate(apicl apiclient.Services) {
	opts := api.ListWatchOptions{}

	// get a list of all objects from API server
	objlist, err := apicl.SecurityV1().Certificate().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Errorf("Error getting a list of objects. Err: %v", err)
		return
	}

	ct.logger.Infof("diffCertificate(): CertificateList returned %d objects", len(objlist))

	// build an object map
	objmap := make(map[string]*security.Certificate)
	for _, obj := range objlist {
		objmap[obj.GetKey()] = obj
	}

	// if an object is in our local cache and not in API server, trigger delete for it
	for _, obj := range ct.Certificate().List() {
		_, ok := objmap[obj.GetKey()]
		if !ok {
			ct.logger.Infof("diffCertificate(): Deleting existing object %#v since its not in apiserver", obj.GetKey())
			evt := kvstore.WatchEvent{
				Type:   kvstore.Deleted,
				Key:    obj.GetKey(),
				Object: &obj.Certificate,
			}
			ct.handleCertificateEvent(&evt)
		}
	}

	// trigger create event for all others
	for _, obj := range objlist {
		ct.logger.Infof("diffCertificate(): Adding object %#v", obj.GetKey())
		evt := kvstore.WatchEvent{
			Type:   kvstore.Created,
			Key:    obj.GetKey(),
			Object: obj,
		}
		ct.handleCertificateEvent(&evt)
	}
}

func (ct *ctrlerCtx) runCertificateWatcher() {
	kind := "Certificate"

	// if there is no API server to connect to, we are done
	if (ct.resolver == nil) || ct.apisrvURL == "" {
		return
	}

	// create context
	ctx, cancel := context.WithCancel(context.Background())
	ct.Lock()
	ct.watchCancel[kind] = cancel
	ct.Unlock()
	opts := api.ListWatchOptions{}
	logger := ct.logger.WithContext("submodule", "CertificateWatcher")

	// create a grpc client
	apiclt, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
	if err == nil {
		ct.diffCertificate(apiclt)
	}

	// setup wait group
	ct.waitGrp.Add(1)

	// start a goroutine
	go func() {
		defer ct.waitGrp.Done()
		ct.stats.Counter("Certificate_Watch").Inc()
		defer ct.stats.Counter("Certificate_Watch").Dec()

		// loop forever
		for {
			// create a grpc client
			apicl, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
			if err != nil {
				logger.Warnf("Failed to connect to gRPC server [%s]\n", ct.apisrvURL)
				ct.stats.Counter("Certificate_ApiClientErr").Inc()
			} else {
				logger.Infof("API client connected {%+v}", apicl)

				// Certificate object watcher
				wt, werr := apicl.SecurityV1().Certificate().Watch(ctx, &opts)
				if werr != nil {
					logger.Errorf("Failed to start %s watch (%s)\n", kind, werr)
					// wait for a second and retry connecting to api server
					apicl.Close()
					time.Sleep(time.Second)
					continue
				}
				ct.Lock()
				ct.watchers[kind] = wt
				ct.Unlock()

				// perform a diff with API server and local cache
				time.Sleep(time.Millisecond * 100)
				ct.diffCertificate(apicl)

				// handle api server watch events
			innerLoop:
				for {
					// wait for events
					select {
					case evt, ok := <-wt.EventChan():
						if !ok {
							logger.Error("Error receiving from apisrv watcher")
							ct.stats.Counter("Certificate_WatchErrors").Inc()
							break innerLoop
						}

						// handle event in parallel
						ct.handleCertificateEventParallel(evt)
					}
				}
				apicl.Close()
			}

			// if stop flag is set, we are done
			if ct.stoped {
				logger.Infof("Exiting API server watcher")
				return
			}

			// wait for a second and retry connecting to api server
			time.Sleep(time.Second)
		}
	}()
}

// WatchCertificate starts watch on Certificate object
func (ct *ctrlerCtx) WatchCertificate(handler CertificateHandler) error {
	kind := "Certificate"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchers[kind]
	ct.Unlock()
	if ok {
		return fmt.Errorf("Certificate watcher already exists")
	}

	// save handler
	ct.Lock()
	ct.handlers[kind] = handler
	ct.Unlock()

	// run Certificate watcher in a go routine
	ct.runCertificateWatcher()

	return nil
}

// CertificateAPI returns
type CertificateAPI interface {
	Create(obj *security.Certificate) error
	Update(obj *security.Certificate) error
	Delete(obj *security.Certificate) error
	Find(meta *api.ObjectMeta) (*Certificate, error)
	List() []*Certificate
	Watch(handler CertificateHandler) error
}

// dummy struct that implements CertificateAPI
type certificateAPI struct {
	ct *ctrlerCtx
}

// Create creates Certificate object
func (api *certificateAPI) Create(obj *security.Certificate) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.SecurityV1().Certificate().Create(context.Background(), obj)
		if err != nil && strings.Contains(err.Error(), "AlreadyExists") {
			_, err = apicl.SecurityV1().Certificate().Update(context.Background(), obj)
		}
		return err
	}

	return api.ct.handleCertificateEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Created})
}

// Update triggers update on Certificate object
func (api *certificateAPI) Update(obj *security.Certificate) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.SecurityV1().Certificate().Update(context.Background(), obj)
		return err
	}

	return api.ct.handleCertificateEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Updated})
}

// Delete deletes Certificate object
func (api *certificateAPI) Delete(obj *security.Certificate) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.SecurityV1().Certificate().Delete(context.Background(), &obj.ObjectMeta)
		return err
	}

	return api.ct.handleCertificateEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Deleted})
}

// Find returns an object by meta
func (api *certificateAPI) Find(meta *api.ObjectMeta) (*Certificate, error) {
	// find the object
	obj, err := api.ct.FindObject("Certificate", meta)
	if err != nil {
		return nil, err
	}

	// asset type
	switch obj.(type) {
	case *Certificate:
		hobj := obj.(*Certificate)
		return hobj, nil
	default:
		return nil, errors.New("incorrect object type")
	}
}

// List returns a list of all Certificate objects
func (api *certificateAPI) List() []*Certificate {
	var objlist []*Certificate

	objs := api.ct.ListObjects("Certificate")
	for _, obj := range objs {
		switch tp := obj.(type) {
		case *Certificate:
			eobj := obj.(*Certificate)
			objlist = append(objlist, eobj)
		default:
			log.Fatalf("Got invalid object type %v while looking for Certificate", tp)
		}
	}

	return objlist
}

// Watch sets up a event handlers for Certificate object
func (api *certificateAPI) Watch(handler CertificateHandler) error {
	api.ct.startWorkerPool("Certificate")
	return api.ct.WatchCertificate(handler)
}

// Certificate returns CertificateAPI
func (ct *ctrlerCtx) Certificate() CertificateAPI {
	return &certificateAPI{ct: ct}
}

// TrafficEncryptionPolicy is a wrapper object that implements additional functionality
type TrafficEncryptionPolicy struct {
	sync.Mutex
	security.TrafficEncryptionPolicy
	HandlerCtx interface{} // additional state handlers can store
	ctrler     *ctrlerCtx  // reference back to the controller instance
}

func (obj *TrafficEncryptionPolicy) Write() error {
	// if there is no API server to connect to, we are done
	if (obj.ctrler == nil) || (obj.ctrler.resolver == nil) || obj.ctrler.apisrvURL == "" {
		return nil
	}

	apicl, err := obj.ctrler.apiClient()
	if err != nil {
		obj.ctrler.logger.Errorf("Error creating API server clent. Err: %v", err)
		return err
	}

	obj.ctrler.stats.Counter("TrafficEncryptionPolicy_Writes").Inc()

	// write to api server
	if obj.ObjectMeta.ResourceVersion != "" {
		// update it
		for i := 0; i < maxApisrvWriteRetry; i++ {
			_, err = apicl.SecurityV1().TrafficEncryptionPolicy().UpdateStatus(context.Background(), &obj.TrafficEncryptionPolicy)
			if err == nil {
				break
			}
			time.Sleep(time.Millisecond * 100)
		}
	} else {
		//  create
		_, err = apicl.SecurityV1().TrafficEncryptionPolicy().Create(context.Background(), &obj.TrafficEncryptionPolicy)
	}

	return nil
}

// TrafficEncryptionPolicyHandler is the event handler for TrafficEncryptionPolicy object
type TrafficEncryptionPolicyHandler interface {
	OnTrafficEncryptionPolicyCreate(obj *TrafficEncryptionPolicy) error
	OnTrafficEncryptionPolicyUpdate(oldObj *TrafficEncryptionPolicy, newObj *security.TrafficEncryptionPolicy) error
	OnTrafficEncryptionPolicyDelete(obj *TrafficEncryptionPolicy) error
}

// handleTrafficEncryptionPolicyEvent handles TrafficEncryptionPolicy events from watcher
func (ct *ctrlerCtx) handleTrafficEncryptionPolicyEvent(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *security.TrafficEncryptionPolicy:
		eobj := evt.Object.(*security.TrafficEncryptionPolicy)
		kind := "TrafficEncryptionPolicy"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		handler, ok := ct.handlers[kind]
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		trafficencryptionpolicyHandler := handler.(TrafficEncryptionPolicyHandler)
		// handle based on event type
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			fobj, err := ct.findObject(kind, eobj.GetKey())
			if err != nil {
				obj := &TrafficEncryptionPolicy{
					TrafficEncryptionPolicy: *eobj,
					HandlerCtx:              nil,
					ctrler:                  ct,
				}
				ct.addObject(kind, obj.GetKey(), obj)
				ct.stats.Counter("TrafficEncryptionPolicy_Created_Events").Inc()

				// call the event handler
				obj.Lock()
				err = trafficencryptionpolicyHandler.OnTrafficEncryptionPolicyCreate(obj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					ct.delObject(kind, eobj.GetKey())
					return err
				}
			} else {
				obj := fobj.(*TrafficEncryptionPolicy)

				ct.stats.Counter("TrafficEncryptionPolicy_Updated_Events").Inc()

				// call the event handler
				obj.Lock()
				err = trafficencryptionpolicyHandler.OnTrafficEncryptionPolicyUpdate(obj, eobj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					return err
				}
			}
		case kvstore.Deleted:
			fobj, err := ct.findObject(kind, eobj.GetKey())
			if err != nil {
				ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
				return err
			}

			obj := fobj.(*TrafficEncryptionPolicy)

			ct.stats.Counter("TrafficEncryptionPolicy_Deleted_Events").Inc()

			// Call the event reactor
			obj.Lock()
			err = trafficencryptionpolicyHandler.OnTrafficEncryptionPolicyDelete(obj)
			obj.Unlock()
			if err != nil {
				ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
			}

			ct.delObject(kind, eobj.GetKey())
		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on TrafficEncryptionPolicy watch channel", tp)
	}

	return nil
}

// handleTrafficEncryptionPolicyEventParallel handles TrafficEncryptionPolicy events from watcher
func (ct *ctrlerCtx) handleTrafficEncryptionPolicyEventParallel(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *security.TrafficEncryptionPolicy:
		eobj := evt.Object.(*security.TrafficEncryptionPolicy)
		kind := "TrafficEncryptionPolicy"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		handler, ok := ct.handlers[kind]
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		trafficencryptionpolicyHandler := handler.(TrafficEncryptionPolicyHandler)
		// handle based on event type
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			workFunc := func(ctx context.Context, userCtx shardworkers.WorkObj) error {
				var err error
				eobj := userCtx.(*security.TrafficEncryptionPolicy)
				fobj, err := ct.findObject(kind, eobj.GetKey())
				if err != nil {
					obj := &TrafficEncryptionPolicy{
						TrafficEncryptionPolicy: *eobj,
						HandlerCtx:              nil,
						ctrler:                  ct,
					}
					ct.addObject(kind, obj.GetKey(), obj)
					ct.stats.Counter("TrafficEncryptionPolicy_Created_Events").Inc()
					obj.Lock()
					err = trafficencryptionpolicyHandler.OnTrafficEncryptionPolicyCreate(obj)
					obj.Unlock()
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
						ct.delObject(kind, obj.TrafficEncryptionPolicy.GetKey())
					}
				} else {
					obj := fobj.(*TrafficEncryptionPolicy)
					ct.stats.Counter("TrafficEncryptionPolicy_Updated_Events").Inc()
					obj.Lock()
					err = trafficencryptionpolicyHandler.OnTrafficEncryptionPolicyUpdate(obj, eobj)
					obj.Unlock()
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					}
				}
				return err
			}
			ct.runJob("TrafficEncryptionPolicy", eobj, workFunc)
		case kvstore.Deleted:
			workFunc := func(ctx context.Context, userCtx shardworkers.WorkObj) error {
				eobj := userCtx.(*security.TrafficEncryptionPolicy)
				fobj, err := ct.findObject(kind, eobj.GetKey())
				if err != nil {
					ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
					return err
				}
				obj := fobj.(*TrafficEncryptionPolicy)
				ct.stats.Counter("TrafficEncryptionPolicy_Deleted_Events").Inc()
				obj.Lock()
				err = trafficencryptionpolicyHandler.OnTrafficEncryptionPolicyDelete(obj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
				}
				ct.delObject(kind, obj.TrafficEncryptionPolicy.GetKey())
				return nil
			}
			ct.runJob("TrafficEncryptionPolicy", eobj, workFunc)
		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on TrafficEncryptionPolicy watch channel", tp)
	}

	return nil
}

// diffTrafficEncryptionPolicy does a diff of TrafficEncryptionPolicy objects between local cache and API server
func (ct *ctrlerCtx) diffTrafficEncryptionPolicy(apicl apiclient.Services) {
	opts := api.ListWatchOptions{}

	// get a list of all objects from API server
	objlist, err := apicl.SecurityV1().TrafficEncryptionPolicy().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Errorf("Error getting a list of objects. Err: %v", err)
		return
	}

	ct.logger.Infof("diffTrafficEncryptionPolicy(): TrafficEncryptionPolicyList returned %d objects", len(objlist))

	// build an object map
	objmap := make(map[string]*security.TrafficEncryptionPolicy)
	for _, obj := range objlist {
		objmap[obj.GetKey()] = obj
	}

	// if an object is in our local cache and not in API server, trigger delete for it
	for _, obj := range ct.TrafficEncryptionPolicy().List() {
		_, ok := objmap[obj.GetKey()]
		if !ok {
			ct.logger.Infof("diffTrafficEncryptionPolicy(): Deleting existing object %#v since its not in apiserver", obj.GetKey())
			evt := kvstore.WatchEvent{
				Type:   kvstore.Deleted,
				Key:    obj.GetKey(),
				Object: &obj.TrafficEncryptionPolicy,
			}
			ct.handleTrafficEncryptionPolicyEvent(&evt)
		}
	}

	// trigger create event for all others
	for _, obj := range objlist {
		ct.logger.Infof("diffTrafficEncryptionPolicy(): Adding object %#v", obj.GetKey())
		evt := kvstore.WatchEvent{
			Type:   kvstore.Created,
			Key:    obj.GetKey(),
			Object: obj,
		}
		ct.handleTrafficEncryptionPolicyEvent(&evt)
	}
}

func (ct *ctrlerCtx) runTrafficEncryptionPolicyWatcher() {
	kind := "TrafficEncryptionPolicy"

	// if there is no API server to connect to, we are done
	if (ct.resolver == nil) || ct.apisrvURL == "" {
		return
	}

	// create context
	ctx, cancel := context.WithCancel(context.Background())
	ct.Lock()
	ct.watchCancel[kind] = cancel
	ct.Unlock()
	opts := api.ListWatchOptions{}
	logger := ct.logger.WithContext("submodule", "TrafficEncryptionPolicyWatcher")

	// create a grpc client
	apiclt, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
	if err == nil {
		ct.diffTrafficEncryptionPolicy(apiclt)
	}

	// setup wait group
	ct.waitGrp.Add(1)

	// start a goroutine
	go func() {
		defer ct.waitGrp.Done()
		ct.stats.Counter("TrafficEncryptionPolicy_Watch").Inc()
		defer ct.stats.Counter("TrafficEncryptionPolicy_Watch").Dec()

		// loop forever
		for {
			// create a grpc client
			apicl, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
			if err != nil {
				logger.Warnf("Failed to connect to gRPC server [%s]\n", ct.apisrvURL)
				ct.stats.Counter("TrafficEncryptionPolicy_ApiClientErr").Inc()
			} else {
				logger.Infof("API client connected {%+v}", apicl)

				// TrafficEncryptionPolicy object watcher
				wt, werr := apicl.SecurityV1().TrafficEncryptionPolicy().Watch(ctx, &opts)
				if werr != nil {
					logger.Errorf("Failed to start %s watch (%s)\n", kind, werr)
					// wait for a second and retry connecting to api server
					apicl.Close()
					time.Sleep(time.Second)
					continue
				}
				ct.Lock()
				ct.watchers[kind] = wt
				ct.Unlock()

				// perform a diff with API server and local cache
				time.Sleep(time.Millisecond * 100)
				ct.diffTrafficEncryptionPolicy(apicl)

				// handle api server watch events
			innerLoop:
				for {
					// wait for events
					select {
					case evt, ok := <-wt.EventChan():
						if !ok {
							logger.Error("Error receiving from apisrv watcher")
							ct.stats.Counter("TrafficEncryptionPolicy_WatchErrors").Inc()
							break innerLoop
						}

						// handle event in parallel
						ct.handleTrafficEncryptionPolicyEventParallel(evt)
					}
				}
				apicl.Close()
			}

			// if stop flag is set, we are done
			if ct.stoped {
				logger.Infof("Exiting API server watcher")
				return
			}

			// wait for a second and retry connecting to api server
			time.Sleep(time.Second)
		}
	}()
}

// WatchTrafficEncryptionPolicy starts watch on TrafficEncryptionPolicy object
func (ct *ctrlerCtx) WatchTrafficEncryptionPolicy(handler TrafficEncryptionPolicyHandler) error {
	kind := "TrafficEncryptionPolicy"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchers[kind]
	ct.Unlock()
	if ok {
		return fmt.Errorf("TrafficEncryptionPolicy watcher already exists")
	}

	// save handler
	ct.Lock()
	ct.handlers[kind] = handler
	ct.Unlock()

	// run TrafficEncryptionPolicy watcher in a go routine
	ct.runTrafficEncryptionPolicyWatcher()

	return nil
}

// TrafficEncryptionPolicyAPI returns
type TrafficEncryptionPolicyAPI interface {
	Create(obj *security.TrafficEncryptionPolicy) error
	Update(obj *security.TrafficEncryptionPolicy) error
	Delete(obj *security.TrafficEncryptionPolicy) error
	Find(meta *api.ObjectMeta) (*TrafficEncryptionPolicy, error)
	List() []*TrafficEncryptionPolicy
	Watch(handler TrafficEncryptionPolicyHandler) error
}

// dummy struct that implements TrafficEncryptionPolicyAPI
type trafficencryptionpolicyAPI struct {
	ct *ctrlerCtx
}

// Create creates TrafficEncryptionPolicy object
func (api *trafficencryptionpolicyAPI) Create(obj *security.TrafficEncryptionPolicy) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.SecurityV1().TrafficEncryptionPolicy().Create(context.Background(), obj)
		if err != nil && strings.Contains(err.Error(), "AlreadyExists") {
			_, err = apicl.SecurityV1().TrafficEncryptionPolicy().Update(context.Background(), obj)
		}
		return err
	}

	return api.ct.handleTrafficEncryptionPolicyEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Created})
}

// Update triggers update on TrafficEncryptionPolicy object
func (api *trafficencryptionpolicyAPI) Update(obj *security.TrafficEncryptionPolicy) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.SecurityV1().TrafficEncryptionPolicy().Update(context.Background(), obj)
		return err
	}

	return api.ct.handleTrafficEncryptionPolicyEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Updated})
}

// Delete deletes TrafficEncryptionPolicy object
func (api *trafficencryptionpolicyAPI) Delete(obj *security.TrafficEncryptionPolicy) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.SecurityV1().TrafficEncryptionPolicy().Delete(context.Background(), &obj.ObjectMeta)
		return err
	}

	return api.ct.handleTrafficEncryptionPolicyEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Deleted})
}

// Find returns an object by meta
func (api *trafficencryptionpolicyAPI) Find(meta *api.ObjectMeta) (*TrafficEncryptionPolicy, error) {
	// find the object
	obj, err := api.ct.FindObject("TrafficEncryptionPolicy", meta)
	if err != nil {
		return nil, err
	}

	// asset type
	switch obj.(type) {
	case *TrafficEncryptionPolicy:
		hobj := obj.(*TrafficEncryptionPolicy)
		return hobj, nil
	default:
		return nil, errors.New("incorrect object type")
	}
}

// List returns a list of all TrafficEncryptionPolicy objects
func (api *trafficencryptionpolicyAPI) List() []*TrafficEncryptionPolicy {
	var objlist []*TrafficEncryptionPolicy

	objs := api.ct.ListObjects("TrafficEncryptionPolicy")
	for _, obj := range objs {
		switch tp := obj.(type) {
		case *TrafficEncryptionPolicy:
			eobj := obj.(*TrafficEncryptionPolicy)
			objlist = append(objlist, eobj)
		default:
			log.Fatalf("Got invalid object type %v while looking for TrafficEncryptionPolicy", tp)
		}
	}

	return objlist
}

// Watch sets up a event handlers for TrafficEncryptionPolicy object
func (api *trafficencryptionpolicyAPI) Watch(handler TrafficEncryptionPolicyHandler) error {
	api.ct.startWorkerPool("TrafficEncryptionPolicy")
	return api.ct.WatchTrafficEncryptionPolicy(handler)
}

// TrafficEncryptionPolicy returns TrafficEncryptionPolicyAPI
func (ct *ctrlerCtx) TrafficEncryptionPolicy() TrafficEncryptionPolicyAPI {
	return &trafficencryptionpolicyAPI{ct: ct}
}
