// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: smartnic.proto

package cluster

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/pensando/grpc-gateway/third_party/googleapis/google/api"
import _ "github.com/pensando/sw/venice/utils/apigen/annotations"
import _ "github.com/gogo/protobuf/gogoproto"
import api "github.com/pensando/sw/api"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// These are valid conditions of a DistributedServiceCard
type DSCCondition_ConditionType int32

const (
	// ui-hint: Healthy
	DSCCondition_HEALTHY DSCCondition_ConditionType = 0
	// ui-hint: Not Reachable
	DSCCondition_NIC_HEALTH_UNKNOWN DSCCondition_ConditionType = 1
	// ui-hint: Reboot needed
	DSCCondition_REBOOT_NEEDED DSCCondition_ConditionType = 2
)

var DSCCondition_ConditionType_name = map[int32]string{
	0: "HEALTHY",
	1: "NIC_HEALTH_UNKNOWN",
	2: "REBOOT_NEEDED",
}
var DSCCondition_ConditionType_value = map[string]int32{
	"HEALTHY":            0,
	"NIC_HEALTH_UNKNOWN": 1,
	"REBOOT_NEEDED":      2,
}

func (DSCCondition_ConditionType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorSmartnic, []int{1, 0}
}

// MgmtModes defines the valid management modes
type DistributedServiceCardSpec_MgmtModes int32

const (
	// ui-hint: Host
	DistributedServiceCardSpec_HOST DistributedServiceCardSpec_MgmtModes = 0
	// ui-hint: Network
	DistributedServiceCardSpec_NETWORK DistributedServiceCardSpec_MgmtModes = 1
)

var DistributedServiceCardSpec_MgmtModes_name = map[int32]string{
	0: "HOST",
	1: "NETWORK",
}
var DistributedServiceCardSpec_MgmtModes_value = map[string]int32{
	"HOST":    0,
	"NETWORK": 1,
}

func (DistributedServiceCardSpec_MgmtModes) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorSmartnic, []int{5, 0}
}

// NetworkModes - is only applicable if the MgmtMode is NETWORK
type DistributedServiceCardSpec_NetworkModes int32

const (
	// ui-hint: Out of Band
	DistributedServiceCardSpec_OOB DistributedServiceCardSpec_NetworkModes = 0
	// ui-hint: Inband
	DistributedServiceCardSpec_INBAND DistributedServiceCardSpec_NetworkModes = 1
)

var DistributedServiceCardSpec_NetworkModes_name = map[int32]string{
	0: "OOB",
	1: "INBAND",
}
var DistributedServiceCardSpec_NetworkModes_value = map[string]int32{
	"OOB":    0,
	"INBAND": 1,
}

func (DistributedServiceCardSpec_NetworkModes) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorSmartnic, []int{5, 1}
}

// Various phases in lifecycle of a DistributedServiceCard
type DistributedServiceCardStatus_Phase int32

const (
	// ui-hint: Unknown
	DistributedServiceCardStatus_UNKNOWN DistributedServiceCardStatus_Phase = 0
	// ui-hint: Registering
	DistributedServiceCardStatus_REGISTERING DistributedServiceCardStatus_Phase = 1
	// ui-hint: Rejected
	DistributedServiceCardStatus_REJECTED DistributedServiceCardStatus_Phase = 2
	// ui-hint: Pending
	DistributedServiceCardStatus_PENDING DistributedServiceCardStatus_Phase = 3
	// ui-hint: Admitted
	DistributedServiceCardStatus_ADMITTED DistributedServiceCardStatus_Phase = 4
	// ui-hint: Decommissioned
	DistributedServiceCardStatus_DECOMMISSIONED DistributedServiceCardStatus_Phase = 5
)

var DistributedServiceCardStatus_Phase_name = map[int32]string{
	0: "UNKNOWN",
	1: "REGISTERING",
	2: "REJECTED",
	3: "PENDING",
	4: "ADMITTED",
	5: "DECOMMISSIONED",
}
var DistributedServiceCardStatus_Phase_value = map[string]int32{
	"UNKNOWN":        0,
	"REGISTERING":    1,
	"REJECTED":       2,
	"PENDING":        3,
	"ADMITTED":       4,
	"DECOMMISSIONED": 5,
}

func (DistributedServiceCardStatus_Phase) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorSmartnic, []int{6, 0}
}

// BIOS information
type BiosInfo struct {
	// Vendor name
	Vendor string `protobuf:"bytes,1,opt,name=Vendor,json=vendor,omitempty,proto3" json:"vendor,omitempty"`
	// BIOS version
	Version string `protobuf:"bytes,2,opt,name=Version,json=version,omitempty,proto3" json:"version,omitempty"`
	// Firmware major release info
	FwMajorVersion string `protobuf:"bytes,3,opt,name=FwMajorVersion,json=fw-major-ver,omitempty,proto3" json:"fw-major-ver,omitempty"`
	// Firmware minor release info
	FwMinorVersion string `protobuf:"bytes,4,opt,name=FwMinorVersion,json=fw-minor-ver,omitempty,proto3" json:"fw-minor-ver,omitempty"`
}

func (m *BiosInfo) Reset()                    { *m = BiosInfo{} }
func (m *BiosInfo) String() string            { return proto.CompactTextString(m) }
func (*BiosInfo) ProtoMessage()               {}
func (*BiosInfo) Descriptor() ([]byte, []int) { return fileDescriptorSmartnic, []int{0} }

func (m *BiosInfo) GetVendor() string {
	if m != nil {
		return m.Vendor
	}
	return ""
}

func (m *BiosInfo) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *BiosInfo) GetFwMajorVersion() string {
	if m != nil {
		return m.FwMajorVersion
	}
	return ""
}

func (m *BiosInfo) GetFwMinorVersion() string {
	if m != nil {
		return m.FwMinorVersion
	}
	return ""
}

// DSCCondition describes the state of a DistributedServiceCard at a certain point.
type DSCCondition struct {
	// Type indicates a certain NIC condition
	Type string `protobuf:"bytes,1,opt,name=Type,json=type,omitempty,proto3" json:"type,omitempty"`
	// Condition Status
	Status string `protobuf:"bytes,2,opt,name=Status,json=status,omitempty,proto3" json:"status,omitempty"`
	// The last time the condition transitioned
	LastTransitionTime string `protobuf:"bytes,3,opt,name=LastTransitionTime,json=last-transition-time,omitempty,proto3" json:"last-transition-time,omitempty"`
	// The reason for the condition's last transition
	Reason string `protobuf:"bytes,4,opt,name=Reason,json=reason,omitempty,proto3" json:"reason,omitempty"`
	// A detailed message indicating details about the transition.
	Message string `protobuf:"bytes,5,opt,name=Message,json=message,omitempty,proto3" json:"message,omitempty"`
}

func (m *DSCCondition) Reset()                    { *m = DSCCondition{} }
func (m *DSCCondition) String() string            { return proto.CompactTextString(m) }
func (*DSCCondition) ProtoMessage()               {}
func (*DSCCondition) Descriptor() ([]byte, []int) { return fileDescriptorSmartnic, []int{1} }

func (m *DSCCondition) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *DSCCondition) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *DSCCondition) GetLastTransitionTime() string {
	if m != nil {
		return m.LastTransitionTime
	}
	return ""
}

func (m *DSCCondition) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

func (m *DSCCondition) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

//
type DSCControlPlaneStatus struct {
	// BGPStatus contains the list of BGP peers and their status
	BGPStatus []*PeerStatus `protobuf:"bytes,1,rep,name=BGPStatus,json=bgp-status,omitempty" json:"bgp-status,omitempty"`
}

func (m *DSCControlPlaneStatus) Reset()                    { *m = DSCControlPlaneStatus{} }
func (m *DSCControlPlaneStatus) String() string            { return proto.CompactTextString(m) }
func (*DSCControlPlaneStatus) ProtoMessage()               {}
func (*DSCControlPlaneStatus) Descriptor() ([]byte, []int) { return fileDescriptorSmartnic, []int{2} }

func (m *DSCControlPlaneStatus) GetBGPStatus() []*PeerStatus {
	if m != nil {
		return m.BGPStatus
	}
	return nil
}

// Distributed service card (DSC) subsystem information
type DSCInfo struct {
	// BIOS details
	BiosInfo *BiosInfo `protobuf:"bytes,1,opt,name=BiosInfo,json=bios-info,omitempty" json:"bios-info,omitempty"`
	// OS details
	OsInfo *OsInfo `protobuf:"bytes,2,opt,name=OsInfo,json=os-info,omitempty" json:"os-info,omitempty"`
	// CPU details
	CpuInfo *CPUInfo `protobuf:"bytes,3,opt,name=CpuInfo,json=cpu-info,omitempty" json:"cpu-info,omitempty"`
	// RAM/Memory details
	MemoryInfo *MemInfo `protobuf:"bytes,4,opt,name=MemoryInfo,json=memory-info,omitempty" json:"memory-info,omitempty"`
	// Storage details
	StorageInfo *StorageInfo `protobuf:"bytes,5,opt,name=StorageInfo,json=storage-info,omitempty" json:"storage-info,omitempty"`
}

func (m *DSCInfo) Reset()                    { *m = DSCInfo{} }
func (m *DSCInfo) String() string            { return proto.CompactTextString(m) }
func (*DSCInfo) ProtoMessage()               {}
func (*DSCInfo) Descriptor() ([]byte, []int) { return fileDescriptorSmartnic, []int{3} }

func (m *DSCInfo) GetBiosInfo() *BiosInfo {
	if m != nil {
		return m.BiosInfo
	}
	return nil
}

func (m *DSCInfo) GetOsInfo() *OsInfo {
	if m != nil {
		return m.OsInfo
	}
	return nil
}

func (m *DSCInfo) GetCpuInfo() *CPUInfo {
	if m != nil {
		return m.CpuInfo
	}
	return nil
}

func (m *DSCInfo) GetMemoryInfo() *MemInfo {
	if m != nil {
		return m.MemoryInfo
	}
	return nil
}

func (m *DSCInfo) GetStorageInfo() *StorageInfo {
	if m != nil {
		return m.StorageInfo
	}
	return nil
}

// ------------------------------------ Distributed Service Card  -------------------------------------------
//
// DistributedServiceCard represents the Naples I/O subsystem
//
// Entity responsible & scenarios involved in managing this object:
//
//      Create:
//          o CMD
//              - created as part of NIC registration, Admittance
//      Modify:
//          o CMD
//              - update spec attributes
//              - update status attributes
//      Delete:
//          o CMD
//              - aging out stale or rejected NICs (TBD)
//          o NetOps, SecOps
//              - Decomission a NIC (TBD)
//
type DistributedServiceCard struct {
	//
	api.TypeMeta `protobuf:"bytes,1,opt,name=T,json=,inline,embedded=T" json:",inline"`
	// Object name is Serial-Number of the DistributedServiceCard
	api.ObjectMeta `protobuf:"bytes,2,opt,name=O,json=meta,omitempty,embedded=O" json:"meta,omitempty"`
	// DistributedServiceCardSpec contains the configuration of the network adapter.
	Spec DistributedServiceCardSpec `protobuf:"bytes,3,opt,name=Spec,json=spec,omitempty" json:"spec,omitempty"`
	// DistributedServiceCardStatus contains the current state of the network adapter.
	Status DistributedServiceCardStatus `protobuf:"bytes,4,opt,name=Status,json=status,omitempty" json:"status,omitempty"`
}

func (m *DistributedServiceCard) Reset()                    { *m = DistributedServiceCard{} }
func (m *DistributedServiceCard) String() string            { return proto.CompactTextString(m) }
func (*DistributedServiceCard) ProtoMessage()               {}
func (*DistributedServiceCard) Descriptor() ([]byte, []int) { return fileDescriptorSmartnic, []int{4} }

func (m *DistributedServiceCard) GetSpec() DistributedServiceCardSpec {
	if m != nil {
		return m.Spec
	}
	return DistributedServiceCardSpec{}
}

func (m *DistributedServiceCard) GetStatus() DistributedServiceCardStatus {
	if m != nil {
		return m.Status
	}
	return DistributedServiceCardStatus{}
}

// DistributedServiceCardSpec contains configuration of the DistributedServiceCard (Naples I/O subsystem)
type DistributedServiceCardSpec struct {
	// Admit allows a DistributedServiceCard to join the cluster
	Admit bool `protobuf:"varint,1,opt,name=Admit,json=admit,omitempty,proto3" json:"admit,omitempty"`
	// ID is used as a user friendly identifier in logs/events
	ID string `protobuf:"bytes,2,opt,name=ID,json=id,omitempty,proto3" json:"id,omitempty"`
	// IPConfig defines the static IP configuration. If not specified, DHCP will be attempted
	IPConfig *IPConfig `protobuf:"bytes,3,opt,name=IPConfig,json=ip-config,omitempty" json:"ip-config,omitempty"`
	// MgmtMode defines the management mode of the DistributedServiceCard
	MgmtMode string `protobuf:"bytes,4,opt,name=MgmtMode,json=mgmt-mode,omitempty,proto3" json:"mgmt-mode,omitempty"`
	// MgmtMode defines the management mode of the DistributedServiceCard
	NetworkMode string `protobuf:"bytes,5,opt,name=NetworkMode,json=network-mode,omitempty,proto3" json:"network-mode,omitempty"`
	// MgmtVlan defines the vlan to be used in network managed mode. The default of 0
	// means we use untagged-vlan for doing inband management
	MgmtVlan uint32 `protobuf:"varint,6,opt,name=MgmtVlan,json=mgmt-vlan,omitempty,proto3" json:"mgmt-vlan,omitempty"`
	// Controllers contains the list of remote controllers IP addresses or hostnames
	Controllers []string `protobuf:"bytes,7,rep,name=Controllers,json=controllers,omitempty" json:"controllers,omitempty"`
	// RoutingConfig is the routing configuration for the underlay routed network that this DSC participates in.
	RoutingConfig string `protobuf:"bytes,8,opt,name=RoutingConfig,json=routing-config,omitempty,proto3" json:"routing-config,omitempty"`
	//
	DSCProfile string `protobuf:"bytes,9,opt,name=DSCProfile,json=dscprofile, omitempty,proto3" json:"dscprofile, omitempty"`
}

func (m *DistributedServiceCardSpec) Reset()         { *m = DistributedServiceCardSpec{} }
func (m *DistributedServiceCardSpec) String() string { return proto.CompactTextString(m) }
func (*DistributedServiceCardSpec) ProtoMessage()    {}
func (*DistributedServiceCardSpec) Descriptor() ([]byte, []int) {
	return fileDescriptorSmartnic, []int{5}
}

func (m *DistributedServiceCardSpec) GetAdmit() bool {
	if m != nil {
		return m.Admit
	}
	return false
}

func (m *DistributedServiceCardSpec) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

func (m *DistributedServiceCardSpec) GetIPConfig() *IPConfig {
	if m != nil {
		return m.IPConfig
	}
	return nil
}

func (m *DistributedServiceCardSpec) GetMgmtMode() string {
	if m != nil {
		return m.MgmtMode
	}
	return ""
}

func (m *DistributedServiceCardSpec) GetNetworkMode() string {
	if m != nil {
		return m.NetworkMode
	}
	return ""
}

func (m *DistributedServiceCardSpec) GetMgmtVlan() uint32 {
	if m != nil {
		return m.MgmtVlan
	}
	return 0
}

func (m *DistributedServiceCardSpec) GetControllers() []string {
	if m != nil {
		return m.Controllers
	}
	return nil
}

func (m *DistributedServiceCardSpec) GetRoutingConfig() string {
	if m != nil {
		return m.RoutingConfig
	}
	return ""
}

func (m *DistributedServiceCardSpec) GetDSCProfile() string {
	if m != nil {
		return m.DSCProfile
	}
	return ""
}

// DistributedServiceCardStatus contains current status of a DistributedServiceCard
type DistributedServiceCardStatus struct {
	// Current admission phase of the DistributedServiceCard.
	// When auto-admission is enabled, AdmissionPhase will be set to NIC_ADMITTED
	// by CMD for validated NICs.
	// When auto-admission is not enabled, AdmissionPhase will be set to NIC_PENDING
	// by CMD for validated NICs since it requires manual approval.
	// To admit the NIC as a part of manual admission, user is expected to
	// set Spec.Admit to true for the NICs that are in NIC_PENDING
	// state. Note : Whitelist mode is not supported yet.
	AdmissionPhase string `protobuf:"bytes,1,opt,name=AdmissionPhase,json=admission-phase,omitempty,proto3" json:"admission-phase,omitempty"`
	// List of current NIC conditions
	Conditions []DSCCondition `protobuf:"bytes,2,rep,name=Conditions,json=conditions,omitempty" json:"conditions,omitempty"`
	// Serial number
	SerialNum string `protobuf:"bytes,3,opt,name=SerialNum,json=serial-num,omitempty,proto3" json:"serial-num,omitempty"`
	// PrimaryMAC is the MAC address of the primary PF exposed by DistributedServiceCard
	PrimaryMAC string `protobuf:"bytes,4,opt,name=PrimaryMAC,json=primary-mac,omitempty,proto3" json:"primary-mac,omitempty"`
	// IPConfig is the ip address related configuration obtained from DHCP
	IPConfig *IPConfig `protobuf:"bytes,5,opt,name=IPConfig,json=ip-config,omitempty" json:"ip-config,omitempty"`
	// Distributed service card system info
	SystemInfo *DSCInfo `protobuf:"bytes,6,opt,name=SystemInfo,json=system-info,omitempty" json:"system-info,omitempty"`
	// Network Interfaces
	Interfaces []string `protobuf:"bytes,7,rep,name=Interfaces,json=interfaces,omitempty" json:"interfaces,omitempty"`
	// DSC Version
	DSCVersion string `protobuf:"bytes,8,opt,name=DSCVersion,json=DSCVersion,omitempty,proto3" json:"DSCVersion,omitempty"`
	// DSC SKU
	DSCSku string `protobuf:"bytes,9,opt,name=DSCSku,json=DSCSku,omitempty,proto3" json:"DSCSku,omitempty"`
	// The name of the host this DistributedServiceCard is plugged into
	Host string `protobuf:"bytes,10,opt,name=Host,json=host,omitempty,proto3" json:"host,omitempty"`
	// The reason why the DistributedServiceCard is not in ADMITTED state
	AdmissionPhaseReason string `protobuf:"bytes,11,opt,name=AdmissionPhaseReason,json=adm-phase-reason,omitempty,proto3" json:"adm-phase-reason,omitempty"`
	// Set to true if venice and dsc versions are incompatible
	VersionMismatch bool `protobuf:"varint,12,opt,name=VersionMismatch,json=version-mismatch,omitempty,proto3" json:"version-mismatch,omitempty"`
	// DSC Control Plane Status
	ControlPlaneStatus *DSCControlPlaneStatus `protobuf:"bytes,13,opt,name=ControlPlaneStatus,json=control-plane-status,omitempty" json:"control-plane-status,omitempty"`
	// IsConnectedToVenice is set to true if connected to venice
	IsConnectedToVenice bool `protobuf:"varint,14,opt,name=IsConnectedToVenice,json=is-connected-to-venice,omitempty,proto3" json:"is-connected-to-venice,omitempty"`
	// Lists the unhealthy services of a distributed service card
	UnhealthyServices []string `protobuf:"bytes,15,rep,name=UnhealthyServices,json=unhealthy-services,omitempty" json:"unhealthy-services,omitempty"`
}

func (m *DistributedServiceCardStatus) Reset()         { *m = DistributedServiceCardStatus{} }
func (m *DistributedServiceCardStatus) String() string { return proto.CompactTextString(m) }
func (*DistributedServiceCardStatus) ProtoMessage()    {}
func (*DistributedServiceCardStatus) Descriptor() ([]byte, []int) {
	return fileDescriptorSmartnic, []int{6}
}

func (m *DistributedServiceCardStatus) GetAdmissionPhase() string {
	if m != nil {
		return m.AdmissionPhase
	}
	return ""
}

func (m *DistributedServiceCardStatus) GetConditions() []DSCCondition {
	if m != nil {
		return m.Conditions
	}
	return nil
}

func (m *DistributedServiceCardStatus) GetSerialNum() string {
	if m != nil {
		return m.SerialNum
	}
	return ""
}

func (m *DistributedServiceCardStatus) GetPrimaryMAC() string {
	if m != nil {
		return m.PrimaryMAC
	}
	return ""
}

func (m *DistributedServiceCardStatus) GetIPConfig() *IPConfig {
	if m != nil {
		return m.IPConfig
	}
	return nil
}

func (m *DistributedServiceCardStatus) GetSystemInfo() *DSCInfo {
	if m != nil {
		return m.SystemInfo
	}
	return nil
}

func (m *DistributedServiceCardStatus) GetInterfaces() []string {
	if m != nil {
		return m.Interfaces
	}
	return nil
}

func (m *DistributedServiceCardStatus) GetDSCVersion() string {
	if m != nil {
		return m.DSCVersion
	}
	return ""
}

func (m *DistributedServiceCardStatus) GetDSCSku() string {
	if m != nil {
		return m.DSCSku
	}
	return ""
}

func (m *DistributedServiceCardStatus) GetHost() string {
	if m != nil {
		return m.Host
	}
	return ""
}

func (m *DistributedServiceCardStatus) GetAdmissionPhaseReason() string {
	if m != nil {
		return m.AdmissionPhaseReason
	}
	return ""
}

func (m *DistributedServiceCardStatus) GetVersionMismatch() bool {
	if m != nil {
		return m.VersionMismatch
	}
	return false
}

func (m *DistributedServiceCardStatus) GetControlPlaneStatus() *DSCControlPlaneStatus {
	if m != nil {
		return m.ControlPlaneStatus
	}
	return nil
}

func (m *DistributedServiceCardStatus) GetIsConnectedToVenice() bool {
	if m != nil {
		return m.IsConnectedToVenice
	}
	return false
}

func (m *DistributedServiceCardStatus) GetUnhealthyServices() []string {
	if m != nil {
		return m.UnhealthyServices
	}
	return nil
}

// IPConfig defines the static IP configuration for a DistributedServiceCard
type IPConfig struct {
	// IPAddress contains the Management IP address of the DistributedServiceCard in CIDR format
	IPAddress string `protobuf:"bytes,1,opt,name=IPAddress,json=ip-address,omitempty,proto3" json:"ip-address,omitempty"`
	// DefaultGW contains the default gateway's IP address
	DefaultGW string `protobuf:"bytes,2,opt,name=DefaultGW,json=default-gw,omitempty,proto3" json:"default-gw,omitempty"`
	// DNSServers contains a list of DNS Servers that can be used on DistributedServiceCard
	DNSServers []string `protobuf:"bytes,3,rep,name=DNSServers,json=dns-servers,omitempty" json:"dns-servers,omitempty"`
}

func (m *IPConfig) Reset()                    { *m = IPConfig{} }
func (m *IPConfig) String() string            { return proto.CompactTextString(m) }
func (*IPConfig) ProtoMessage()               {}
func (*IPConfig) Descriptor() ([]byte, []int) { return fileDescriptorSmartnic, []int{7} }

func (m *IPConfig) GetIPAddress() string {
	if m != nil {
		return m.IPAddress
	}
	return ""
}

func (m *IPConfig) GetDefaultGW() string {
	if m != nil {
		return m.DefaultGW
	}
	return ""
}

func (m *IPConfig) GetDNSServers() []string {
	if m != nil {
		return m.DNSServers
	}
	return nil
}

// MAC address Range
type MacRange struct {
	//
	Start string `protobuf:"bytes,1,opt,name=Start,json=mac-start,omitempty,proto3" json:"mac-start,omitempty"`
	//
	End string `protobuf:"bytes,2,opt,name=End,json=mac-end,omitempty,proto3" json:"mac-end,omitempty"`
}

func (m *MacRange) Reset()                    { *m = MacRange{} }
func (m *MacRange) String() string            { return proto.CompactTextString(m) }
func (*MacRange) ProtoMessage()               {}
func (*MacRange) Descriptor() ([]byte, []int) { return fileDescriptorSmartnic, []int{8} }

func (m *MacRange) GetStart() string {
	if m != nil {
		return m.Start
	}
	return ""
}

func (m *MacRange) GetEnd() string {
	if m != nil {
		return m.End
	}
	return ""
}

//
type PeerStatus struct {
	// BGP peer IP address
	PeerAddress string `protobuf:"bytes,1,opt,name=PeerAddress,json=peer-address,omitempty,proto3" json:"peer-address,omitempty"`
	// BGP session status
	State string `protobuf:"bytes,2,opt,name=State,json=state,omitempty,proto3" json:"state,omitempty"`
	// Remote AS number
	RemoteASN uint32 `protobuf:"varint,3,opt,name=RemoteASN,json=remote-asn,omitempty,proto3" json:"remote-asn,omitempty"`
	// BGP Address families
	AddressFamilies []string `protobuf:"bytes,4,rep,name=AddressFamilies,json=address-families,omitempty" json:"address-families,omitempty"`
}

func (m *PeerStatus) Reset()                    { *m = PeerStatus{} }
func (m *PeerStatus) String() string            { return proto.CompactTextString(m) }
func (*PeerStatus) ProtoMessage()               {}
func (*PeerStatus) Descriptor() ([]byte, []int) { return fileDescriptorSmartnic, []int{9} }

func (m *PeerStatus) GetPeerAddress() string {
	if m != nil {
		return m.PeerAddress
	}
	return ""
}

func (m *PeerStatus) GetState() string {
	if m != nil {
		return m.State
	}
	return ""
}

func (m *PeerStatus) GetRemoteASN() uint32 {
	if m != nil {
		return m.RemoteASN
	}
	return 0
}

func (m *PeerStatus) GetAddressFamilies() []string {
	if m != nil {
		return m.AddressFamilies
	}
	return nil
}

func init() {
	proto.RegisterType((*BiosInfo)(nil), "cluster.BiosInfo")
	proto.RegisterType((*DSCCondition)(nil), "cluster.DSCCondition")
	proto.RegisterType((*DSCControlPlaneStatus)(nil), "cluster.DSCControlPlaneStatus")
	proto.RegisterType((*DSCInfo)(nil), "cluster.DSCInfo")
	proto.RegisterType((*DistributedServiceCard)(nil), "cluster.DistributedServiceCard")
	proto.RegisterType((*DistributedServiceCardSpec)(nil), "cluster.DistributedServiceCardSpec")
	proto.RegisterType((*DistributedServiceCardStatus)(nil), "cluster.DistributedServiceCardStatus")
	proto.RegisterType((*IPConfig)(nil), "cluster.IPConfig")
	proto.RegisterType((*MacRange)(nil), "cluster.MacRange")
	proto.RegisterType((*PeerStatus)(nil), "cluster.PeerStatus")
	proto.RegisterEnum("cluster.DSCCondition_ConditionType", DSCCondition_ConditionType_name, DSCCondition_ConditionType_value)
	proto.RegisterEnum("cluster.DistributedServiceCardSpec_MgmtModes", DistributedServiceCardSpec_MgmtModes_name, DistributedServiceCardSpec_MgmtModes_value)
	proto.RegisterEnum("cluster.DistributedServiceCardSpec_NetworkModes", DistributedServiceCardSpec_NetworkModes_name, DistributedServiceCardSpec_NetworkModes_value)
	proto.RegisterEnum("cluster.DistributedServiceCardStatus_Phase", DistributedServiceCardStatus_Phase_name, DistributedServiceCardStatus_Phase_value)
}
func (m *BiosInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BiosInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Vendor) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSmartnic(dAtA, i, uint64(len(m.Vendor)))
		i += copy(dAtA[i:], m.Vendor)
	}
	if len(m.Version) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSmartnic(dAtA, i, uint64(len(m.Version)))
		i += copy(dAtA[i:], m.Version)
	}
	if len(m.FwMajorVersion) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSmartnic(dAtA, i, uint64(len(m.FwMajorVersion)))
		i += copy(dAtA[i:], m.FwMajorVersion)
	}
	if len(m.FwMinorVersion) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintSmartnic(dAtA, i, uint64(len(m.FwMinorVersion)))
		i += copy(dAtA[i:], m.FwMinorVersion)
	}
	return i, nil
}

func (m *DSCCondition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DSCCondition) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSmartnic(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.Status) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSmartnic(dAtA, i, uint64(len(m.Status)))
		i += copy(dAtA[i:], m.Status)
	}
	if len(m.LastTransitionTime) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSmartnic(dAtA, i, uint64(len(m.LastTransitionTime)))
		i += copy(dAtA[i:], m.LastTransitionTime)
	}
	if len(m.Reason) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintSmartnic(dAtA, i, uint64(len(m.Reason)))
		i += copy(dAtA[i:], m.Reason)
	}
	if len(m.Message) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintSmartnic(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	return i, nil
}

func (m *DSCControlPlaneStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DSCControlPlaneStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.BGPStatus) > 0 {
		for _, msg := range m.BGPStatus {
			dAtA[i] = 0xa
			i++
			i = encodeVarintSmartnic(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *DSCInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DSCInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.BiosInfo != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSmartnic(dAtA, i, uint64(m.BiosInfo.Size()))
		n1, err := m.BiosInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.OsInfo != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSmartnic(dAtA, i, uint64(m.OsInfo.Size()))
		n2, err := m.OsInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.CpuInfo != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSmartnic(dAtA, i, uint64(m.CpuInfo.Size()))
		n3, err := m.CpuInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.MemoryInfo != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintSmartnic(dAtA, i, uint64(m.MemoryInfo.Size()))
		n4, err := m.MemoryInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.StorageInfo != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintSmartnic(dAtA, i, uint64(m.StorageInfo.Size()))
		n5, err := m.StorageInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	return i, nil
}

func (m *DistributedServiceCard) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DistributedServiceCard) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintSmartnic(dAtA, i, uint64(m.TypeMeta.Size()))
	n6, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n6
	dAtA[i] = 0x12
	i++
	i = encodeVarintSmartnic(dAtA, i, uint64(m.ObjectMeta.Size()))
	n7, err := m.ObjectMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n7
	dAtA[i] = 0x1a
	i++
	i = encodeVarintSmartnic(dAtA, i, uint64(m.Spec.Size()))
	n8, err := m.Spec.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n8
	dAtA[i] = 0x22
	i++
	i = encodeVarintSmartnic(dAtA, i, uint64(m.Status.Size()))
	n9, err := m.Status.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n9
	return i, nil
}

func (m *DistributedServiceCardSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DistributedServiceCardSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Admit {
		dAtA[i] = 0x8
		i++
		if m.Admit {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.ID) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSmartnic(dAtA, i, uint64(len(m.ID)))
		i += copy(dAtA[i:], m.ID)
	}
	if m.IPConfig != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSmartnic(dAtA, i, uint64(m.IPConfig.Size()))
		n10, err := m.IPConfig.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if len(m.MgmtMode) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintSmartnic(dAtA, i, uint64(len(m.MgmtMode)))
		i += copy(dAtA[i:], m.MgmtMode)
	}
	if len(m.NetworkMode) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintSmartnic(dAtA, i, uint64(len(m.NetworkMode)))
		i += copy(dAtA[i:], m.NetworkMode)
	}
	if m.MgmtVlan != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintSmartnic(dAtA, i, uint64(m.MgmtVlan))
	}
	if len(m.Controllers) > 0 {
		for _, s := range m.Controllers {
			dAtA[i] = 0x3a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.RoutingConfig) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintSmartnic(dAtA, i, uint64(len(m.RoutingConfig)))
		i += copy(dAtA[i:], m.RoutingConfig)
	}
	if len(m.DSCProfile) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintSmartnic(dAtA, i, uint64(len(m.DSCProfile)))
		i += copy(dAtA[i:], m.DSCProfile)
	}
	return i, nil
}

func (m *DistributedServiceCardStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DistributedServiceCardStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AdmissionPhase) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSmartnic(dAtA, i, uint64(len(m.AdmissionPhase)))
		i += copy(dAtA[i:], m.AdmissionPhase)
	}
	if len(m.Conditions) > 0 {
		for _, msg := range m.Conditions {
			dAtA[i] = 0x12
			i++
			i = encodeVarintSmartnic(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.SerialNum) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSmartnic(dAtA, i, uint64(len(m.SerialNum)))
		i += copy(dAtA[i:], m.SerialNum)
	}
	if len(m.PrimaryMAC) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintSmartnic(dAtA, i, uint64(len(m.PrimaryMAC)))
		i += copy(dAtA[i:], m.PrimaryMAC)
	}
	if m.IPConfig != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintSmartnic(dAtA, i, uint64(m.IPConfig.Size()))
		n11, err := m.IPConfig.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if m.SystemInfo != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintSmartnic(dAtA, i, uint64(m.SystemInfo.Size()))
		n12, err := m.SystemInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if len(m.Interfaces) > 0 {
		for _, s := range m.Interfaces {
			dAtA[i] = 0x3a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.DSCVersion) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintSmartnic(dAtA, i, uint64(len(m.DSCVersion)))
		i += copy(dAtA[i:], m.DSCVersion)
	}
	if len(m.DSCSku) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintSmartnic(dAtA, i, uint64(len(m.DSCSku)))
		i += copy(dAtA[i:], m.DSCSku)
	}
	if len(m.Host) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintSmartnic(dAtA, i, uint64(len(m.Host)))
		i += copy(dAtA[i:], m.Host)
	}
	if len(m.AdmissionPhaseReason) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintSmartnic(dAtA, i, uint64(len(m.AdmissionPhaseReason)))
		i += copy(dAtA[i:], m.AdmissionPhaseReason)
	}
	if m.VersionMismatch {
		dAtA[i] = 0x60
		i++
		if m.VersionMismatch {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ControlPlaneStatus != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintSmartnic(dAtA, i, uint64(m.ControlPlaneStatus.Size()))
		n13, err := m.ControlPlaneStatus.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if m.IsConnectedToVenice {
		dAtA[i] = 0x70
		i++
		if m.IsConnectedToVenice {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.UnhealthyServices) > 0 {
		for _, s := range m.UnhealthyServices {
			dAtA[i] = 0x7a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *IPConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IPConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.IPAddress) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSmartnic(dAtA, i, uint64(len(m.IPAddress)))
		i += copy(dAtA[i:], m.IPAddress)
	}
	if len(m.DefaultGW) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSmartnic(dAtA, i, uint64(len(m.DefaultGW)))
		i += copy(dAtA[i:], m.DefaultGW)
	}
	if len(m.DNSServers) > 0 {
		for _, s := range m.DNSServers {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *MacRange) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MacRange) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Start) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSmartnic(dAtA, i, uint64(len(m.Start)))
		i += copy(dAtA[i:], m.Start)
	}
	if len(m.End) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSmartnic(dAtA, i, uint64(len(m.End)))
		i += copy(dAtA[i:], m.End)
	}
	return i, nil
}

func (m *PeerStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PeerStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PeerAddress) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSmartnic(dAtA, i, uint64(len(m.PeerAddress)))
		i += copy(dAtA[i:], m.PeerAddress)
	}
	if len(m.State) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSmartnic(dAtA, i, uint64(len(m.State)))
		i += copy(dAtA[i:], m.State)
	}
	if m.RemoteASN != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintSmartnic(dAtA, i, uint64(m.RemoteASN))
	}
	if len(m.AddressFamilies) > 0 {
		for _, s := range m.AddressFamilies {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func encodeVarintSmartnic(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *BiosInfo) Size() (n int) {
	var l int
	_ = l
	l = len(m.Vendor)
	if l > 0 {
		n += 1 + l + sovSmartnic(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovSmartnic(uint64(l))
	}
	l = len(m.FwMajorVersion)
	if l > 0 {
		n += 1 + l + sovSmartnic(uint64(l))
	}
	l = len(m.FwMinorVersion)
	if l > 0 {
		n += 1 + l + sovSmartnic(uint64(l))
	}
	return n
}

func (m *DSCCondition) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovSmartnic(uint64(l))
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovSmartnic(uint64(l))
	}
	l = len(m.LastTransitionTime)
	if l > 0 {
		n += 1 + l + sovSmartnic(uint64(l))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovSmartnic(uint64(l))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovSmartnic(uint64(l))
	}
	return n
}

func (m *DSCControlPlaneStatus) Size() (n int) {
	var l int
	_ = l
	if len(m.BGPStatus) > 0 {
		for _, e := range m.BGPStatus {
			l = e.Size()
			n += 1 + l + sovSmartnic(uint64(l))
		}
	}
	return n
}

func (m *DSCInfo) Size() (n int) {
	var l int
	_ = l
	if m.BiosInfo != nil {
		l = m.BiosInfo.Size()
		n += 1 + l + sovSmartnic(uint64(l))
	}
	if m.OsInfo != nil {
		l = m.OsInfo.Size()
		n += 1 + l + sovSmartnic(uint64(l))
	}
	if m.CpuInfo != nil {
		l = m.CpuInfo.Size()
		n += 1 + l + sovSmartnic(uint64(l))
	}
	if m.MemoryInfo != nil {
		l = m.MemoryInfo.Size()
		n += 1 + l + sovSmartnic(uint64(l))
	}
	if m.StorageInfo != nil {
		l = m.StorageInfo.Size()
		n += 1 + l + sovSmartnic(uint64(l))
	}
	return n
}

func (m *DistributedServiceCard) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovSmartnic(uint64(l))
	l = m.ObjectMeta.Size()
	n += 1 + l + sovSmartnic(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovSmartnic(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovSmartnic(uint64(l))
	return n
}

func (m *DistributedServiceCardSpec) Size() (n int) {
	var l int
	_ = l
	if m.Admit {
		n += 2
	}
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovSmartnic(uint64(l))
	}
	if m.IPConfig != nil {
		l = m.IPConfig.Size()
		n += 1 + l + sovSmartnic(uint64(l))
	}
	l = len(m.MgmtMode)
	if l > 0 {
		n += 1 + l + sovSmartnic(uint64(l))
	}
	l = len(m.NetworkMode)
	if l > 0 {
		n += 1 + l + sovSmartnic(uint64(l))
	}
	if m.MgmtVlan != 0 {
		n += 1 + sovSmartnic(uint64(m.MgmtVlan))
	}
	if len(m.Controllers) > 0 {
		for _, s := range m.Controllers {
			l = len(s)
			n += 1 + l + sovSmartnic(uint64(l))
		}
	}
	l = len(m.RoutingConfig)
	if l > 0 {
		n += 1 + l + sovSmartnic(uint64(l))
	}
	l = len(m.DSCProfile)
	if l > 0 {
		n += 1 + l + sovSmartnic(uint64(l))
	}
	return n
}

func (m *DistributedServiceCardStatus) Size() (n int) {
	var l int
	_ = l
	l = len(m.AdmissionPhase)
	if l > 0 {
		n += 1 + l + sovSmartnic(uint64(l))
	}
	if len(m.Conditions) > 0 {
		for _, e := range m.Conditions {
			l = e.Size()
			n += 1 + l + sovSmartnic(uint64(l))
		}
	}
	l = len(m.SerialNum)
	if l > 0 {
		n += 1 + l + sovSmartnic(uint64(l))
	}
	l = len(m.PrimaryMAC)
	if l > 0 {
		n += 1 + l + sovSmartnic(uint64(l))
	}
	if m.IPConfig != nil {
		l = m.IPConfig.Size()
		n += 1 + l + sovSmartnic(uint64(l))
	}
	if m.SystemInfo != nil {
		l = m.SystemInfo.Size()
		n += 1 + l + sovSmartnic(uint64(l))
	}
	if len(m.Interfaces) > 0 {
		for _, s := range m.Interfaces {
			l = len(s)
			n += 1 + l + sovSmartnic(uint64(l))
		}
	}
	l = len(m.DSCVersion)
	if l > 0 {
		n += 1 + l + sovSmartnic(uint64(l))
	}
	l = len(m.DSCSku)
	if l > 0 {
		n += 1 + l + sovSmartnic(uint64(l))
	}
	l = len(m.Host)
	if l > 0 {
		n += 1 + l + sovSmartnic(uint64(l))
	}
	l = len(m.AdmissionPhaseReason)
	if l > 0 {
		n += 1 + l + sovSmartnic(uint64(l))
	}
	if m.VersionMismatch {
		n += 2
	}
	if m.ControlPlaneStatus != nil {
		l = m.ControlPlaneStatus.Size()
		n += 1 + l + sovSmartnic(uint64(l))
	}
	if m.IsConnectedToVenice {
		n += 2
	}
	if len(m.UnhealthyServices) > 0 {
		for _, s := range m.UnhealthyServices {
			l = len(s)
			n += 1 + l + sovSmartnic(uint64(l))
		}
	}
	return n
}

func (m *IPConfig) Size() (n int) {
	var l int
	_ = l
	l = len(m.IPAddress)
	if l > 0 {
		n += 1 + l + sovSmartnic(uint64(l))
	}
	l = len(m.DefaultGW)
	if l > 0 {
		n += 1 + l + sovSmartnic(uint64(l))
	}
	if len(m.DNSServers) > 0 {
		for _, s := range m.DNSServers {
			l = len(s)
			n += 1 + l + sovSmartnic(uint64(l))
		}
	}
	return n
}

func (m *MacRange) Size() (n int) {
	var l int
	_ = l
	l = len(m.Start)
	if l > 0 {
		n += 1 + l + sovSmartnic(uint64(l))
	}
	l = len(m.End)
	if l > 0 {
		n += 1 + l + sovSmartnic(uint64(l))
	}
	return n
}

func (m *PeerStatus) Size() (n int) {
	var l int
	_ = l
	l = len(m.PeerAddress)
	if l > 0 {
		n += 1 + l + sovSmartnic(uint64(l))
	}
	l = len(m.State)
	if l > 0 {
		n += 1 + l + sovSmartnic(uint64(l))
	}
	if m.RemoteASN != 0 {
		n += 1 + sovSmartnic(uint64(m.RemoteASN))
	}
	if len(m.AddressFamilies) > 0 {
		for _, s := range m.AddressFamilies {
			l = len(s)
			n += 1 + l + sovSmartnic(uint64(l))
		}
	}
	return n
}

func sovSmartnic(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozSmartnic(x uint64) (n int) {
	return sovSmartnic(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *BiosInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSmartnic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BiosInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BiosInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vendor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSmartnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSmartnic
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Vendor = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSmartnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSmartnic
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FwMajorVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSmartnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSmartnic
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FwMajorVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FwMinorVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSmartnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSmartnic
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FwMinorVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSmartnic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSmartnic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DSCCondition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSmartnic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DSCCondition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DSCCondition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSmartnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSmartnic
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSmartnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSmartnic
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastTransitionTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSmartnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSmartnic
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastTransitionTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSmartnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSmartnic
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSmartnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSmartnic
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSmartnic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSmartnic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DSCControlPlaneStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSmartnic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DSCControlPlaneStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DSCControlPlaneStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BGPStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSmartnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSmartnic
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BGPStatus = append(m.BGPStatus, &PeerStatus{})
			if err := m.BGPStatus[len(m.BGPStatus)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSmartnic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSmartnic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DSCInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSmartnic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DSCInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DSCInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BiosInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSmartnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSmartnic
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BiosInfo == nil {
				m.BiosInfo = &BiosInfo{}
			}
			if err := m.BiosInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OsInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSmartnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSmartnic
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OsInfo == nil {
				m.OsInfo = &OsInfo{}
			}
			if err := m.OsInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSmartnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSmartnic
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CpuInfo == nil {
				m.CpuInfo = &CPUInfo{}
			}
			if err := m.CpuInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemoryInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSmartnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSmartnic
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MemoryInfo == nil {
				m.MemoryInfo = &MemInfo{}
			}
			if err := m.MemoryInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSmartnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSmartnic
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StorageInfo == nil {
				m.StorageInfo = &StorageInfo{}
			}
			if err := m.StorageInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSmartnic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSmartnic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DistributedServiceCard) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSmartnic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DistributedServiceCard: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DistributedServiceCard: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSmartnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSmartnic
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSmartnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSmartnic
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSmartnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSmartnic
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSmartnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSmartnic
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSmartnic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSmartnic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DistributedServiceCardSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSmartnic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DistributedServiceCardSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DistributedServiceCardSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Admit", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSmartnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Admit = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSmartnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSmartnic
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IPConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSmartnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSmartnic
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IPConfig == nil {
				m.IPConfig = &IPConfig{}
			}
			if err := m.IPConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MgmtMode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSmartnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSmartnic
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MgmtMode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkMode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSmartnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSmartnic
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NetworkMode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MgmtVlan", wireType)
			}
			m.MgmtVlan = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSmartnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MgmtVlan |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Controllers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSmartnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSmartnic
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Controllers = append(m.Controllers, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoutingConfig", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSmartnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSmartnic
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RoutingConfig = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DSCProfile", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSmartnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSmartnic
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DSCProfile = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSmartnic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSmartnic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DistributedServiceCardStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSmartnic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DistributedServiceCardStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DistributedServiceCardStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdmissionPhase", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSmartnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSmartnic
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AdmissionPhase = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conditions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSmartnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSmartnic
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Conditions = append(m.Conditions, DSCCondition{})
			if err := m.Conditions[len(m.Conditions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SerialNum", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSmartnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSmartnic
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SerialNum = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrimaryMAC", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSmartnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSmartnic
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrimaryMAC = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IPConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSmartnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSmartnic
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IPConfig == nil {
				m.IPConfig = &IPConfig{}
			}
			if err := m.IPConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SystemInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSmartnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSmartnic
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SystemInfo == nil {
				m.SystemInfo = &DSCInfo{}
			}
			if err := m.SystemInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Interfaces", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSmartnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSmartnic
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Interfaces = append(m.Interfaces, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DSCVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSmartnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSmartnic
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DSCVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DSCSku", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSmartnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSmartnic
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DSCSku = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Host", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSmartnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSmartnic
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Host = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdmissionPhaseReason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSmartnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSmartnic
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AdmissionPhaseReason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VersionMismatch", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSmartnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.VersionMismatch = bool(v != 0)
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ControlPlaneStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSmartnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSmartnic
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ControlPlaneStatus == nil {
				m.ControlPlaneStatus = &DSCControlPlaneStatus{}
			}
			if err := m.ControlPlaneStatus.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsConnectedToVenice", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSmartnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsConnectedToVenice = bool(v != 0)
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnhealthyServices", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSmartnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSmartnic
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UnhealthyServices = append(m.UnhealthyServices, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSmartnic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSmartnic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IPConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSmartnic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IPConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IPConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IPAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSmartnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSmartnic
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IPAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultGW", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSmartnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSmartnic
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DefaultGW = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DNSServers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSmartnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSmartnic
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DNSServers = append(m.DNSServers, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSmartnic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSmartnic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MacRange) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSmartnic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MacRange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MacRange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSmartnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSmartnic
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Start = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSmartnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSmartnic
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.End = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSmartnic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSmartnic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PeerStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSmartnic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PeerStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PeerStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSmartnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSmartnic
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PeerAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSmartnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSmartnic
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoteASN", wireType)
			}
			m.RemoteASN = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSmartnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RemoteASN |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddressFamilies", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSmartnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSmartnic
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AddressFamilies = append(m.AddressFamilies, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSmartnic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSmartnic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipSmartnic(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowSmartnic
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSmartnic
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSmartnic
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthSmartnic
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowSmartnic
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipSmartnic(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthSmartnic = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowSmartnic   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("smartnic.proto", fileDescriptorSmartnic) }

var fileDescriptorSmartnic = []byte{
	// 1931 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x58, 0xcb, 0x6f, 0x1b, 0xc7,
	0x19, 0x17, 0x45, 0x3d, 0x87, 0x7a, 0x50, 0xa3, 0x47, 0x48, 0xc1, 0xd5, 0xaa, 0x74, 0x03, 0x28,
	0xb5, 0x57, 0x14, 0x92, 0x36, 0x80, 0xdb, 0x93, 0xf8, 0xb0, 0xc4, 0xd8, 0x7c, 0x84, 0x4b, 0xcb,
	0x75, 0x81, 0xd4, 0x18, 0xed, 0x0e, 0xa9, 0x4d, 0xb8, 0x3b, 0x8b, 0x9d, 0xa1, 0x04, 0xa1, 0x40,
	0x0b, 0x14, 0x28, 0x6f, 0x3d, 0xf6, 0x1f, 0xf0, 0x91, 0x40, 0x2f, 0xfd, 0x2b, 0x72, 0x0c, 0x7a,
	0xe9, 0x8d, 0x28, 0x7c, 0x2a, 0x78, 0xef, 0x35, 0x28, 0xe6, 0x41, 0x72, 0x48, 0x2e, 0x2d, 0x1f,
	0x72, 0xe3, 0xfc, 0xbe, 0x6f, 0x7e, 0xb3, 0xf3, 0xbd, 0x87, 0x60, 0x8b, 0x7a, 0x28, 0x64, 0xbe,
	0x6b, 0x9f, 0x06, 0x21, 0x61, 0x04, 0xae, 0xda, 0xed, 0x0e, 0x65, 0x38, 0x3c, 0x7c, 0xd4, 0x22,
	0xa4, 0xd5, 0xc6, 0x59, 0x14, 0xb8, 0x59, 0xe4, 0xfb, 0x84, 0x21, 0xe6, 0x12, 0x9f, 0x4a, 0xb5,
	0xc3, 0x62, 0xcb, 0x65, 0x37, 0x9d, 0xeb, 0x53, 0x9b, 0x78, 0xd9, 0x00, 0xfb, 0x14, 0xf9, 0x0e,
	0xc9, 0xd2, 0xbb, 0xec, 0x2d, 0xf6, 0x5d, 0x1b, 0x67, 0x3b, 0xcc, 0x6d, 0x53, 0xbe, 0xb5, 0x85,
	0x7d, 0x7d, 0x77, 0xd6, 0xf5, 0xed, 0x76, 0xc7, 0xc1, 0x43, 0x1a, 0x53, 0xa3, 0x69, 0x91, 0x16,
	0xc9, 0x0a, 0xf8, 0xba, 0xd3, 0x14, 0x2b, 0xb1, 0x10, 0xbf, 0x94, 0xfa, 0xa7, 0x73, 0x4e, 0xe5,
	0xdf, 0xe8, 0x61, 0x86, 0x94, 0xda, 0xa6, 0xba, 0x83, 0x5c, 0x66, 0xfe, 0xbe, 0x08, 0xd6, 0x72,
	0x2e, 0xa1, 0x25, 0xbf, 0x49, 0xe0, 0x97, 0x60, 0xe5, 0x0a, 0xfb, 0x0e, 0x09, 0x53, 0xb1, 0xe3,
	0xd8, 0xc9, 0x7a, 0x6e, 0x6f, 0xd0, 0x37, 0x92, 0xb7, 0x02, 0x79, 0x4a, 0x3c, 0x97, 0x61, 0x2f,
	0x60, 0xf7, 0xf5, 0x19, 0x04, 0x3e, 0x03, 0xab, 0x57, 0x38, 0xa4, 0x2e, 0xf1, 0x53, 0x8b, 0x62,
	0xe3, 0xfe, 0xa0, 0x6f, 0xec, 0xdc, 0x4a, 0x48, 0xdb, 0x39, 0x0b, 0xc1, 0xaf, 0xc0, 0xd6, 0xf3,
	0xbb, 0x32, 0xfa, 0x96, 0x84, 0x43, 0x86, 0xb8, 0x60, 0x38, 0x1c, 0xf4, 0x8d, 0x83, 0xe6, 0x9d,
	0xe9, 0x71, 0x91, 0x79, 0x8b, 0xf5, 0x0f, 0x98, 0x83, 0x2b, 0x2e, 0xd7, 0x1f, 0x73, 0x2d, 0x4d,
	0x72, 0x71, 0x51, 0x14, 0xd7, 0x2c, 0x9e, 0xf9, 0x77, 0x1c, 0x6c, 0x14, 0xac, 0x7c, 0x9e, 0xf8,
	0x8e, 0xcb, 0xbd, 0x03, 0x5f, 0x83, 0xa5, 0xc6, 0x7d, 0x80, 0x95, 0x65, 0x9e, 0xf5, 0xba, 0xe9,
	0xc7, 0x16, 0x0b, 0x8b, 0x7e, 0xc7, 0x3b, 0xd1, 0xf5, 0x4e, 0x47, 0xbf, 0xb8, 0xf6, 0x67, 0x83,
	0xbe, 0xb1, 0xc5, 0xee, 0x03, 0xac, 0x9d, 0x38, 0xb5, 0x86, 0x75, 0xb0, 0x62, 0x31, 0xc4, 0x3a,
	0x54, 0xd9, 0xee, 0xac, 0xd7, 0x4d, 0xa7, 0x86, 0xd4, 0x23, 0x36, 0xa9, 0xc2, 0xf9, 0x92, 0x54,
	0xfc, 0xd4, 0x1d, 0x32, 0x8d, 0xc0, 0x3f, 0x00, 0xf8, 0x12, 0x51, 0xd6, 0x08, 0x91, 0x4f, 0xe5,
	0xc7, 0xb8, 0x1e, 0x56, 0x96, 0xcd, 0x0c, 0xfa, 0xc6, 0x51, 0x1b, 0x51, 0x66, 0xb2, 0x91, 0xd8,
	0x64, 0xae, 0xa7, 0x7f, 0xe3, 0x03, 0x72, 0x1e, 0x28, 0x75, 0x8c, 0xe8, 0xc8, 0xc2, 0x22, 0x50,
	0x42, 0x81, 0xe8, 0xdf, 0x35, 0x8d, 0xf0, 0x40, 0x29, 0x63, 0x4a, 0x51, 0x0b, 0xa7, 0x96, 0xc7,
	0x81, 0xe2, 0x49, 0x48, 0x0f, 0x94, 0x19, 0x28, 0x73, 0x01, 0x36, 0x27, 0x4c, 0x0b, 0x13, 0x60,
	0xf5, 0xb2, 0x78, 0xfe, 0xb2, 0x71, 0xf9, 0x26, 0xb9, 0x00, 0x0f, 0x00, 0xac, 0x94, 0xf2, 0x6f,
	0x25, 0xf0, 0xf6, 0x55, 0xe5, 0x45, 0xa5, 0xfa, 0xba, 0x92, 0x8c, 0xc1, 0x1d, 0xb0, 0x59, 0x2f,
	0xe6, 0xaa, 0xd5, 0xc6, 0xdb, 0x4a, 0xb1, 0x58, 0x28, 0x16, 0x92, 0x8b, 0x19, 0x02, 0xf6, 0xa5,
	0xc3, 0x58, 0x48, 0xda, 0xb5, 0x36, 0xf2, 0xb1, 0xb4, 0x2d, 0xbc, 0x02, 0xeb, 0xb9, 0x8b, 0x9a,
	0xf2, 0x45, 0xec, 0x38, 0x7e, 0x92, 0xf8, 0x7c, 0xf7, 0x74, 0x98, 0x2d, 0x35, 0x8c, 0x43, 0x29,
	0xca, 0xa5, 0x06, 0x7d, 0x63, 0xef, 0xba, 0x15, 0x98, 0x33, 0x8e, 0x88, 0x44, 0x33, 0xff, 0x88,
	0x83, 0xd5, 0x82, 0x95, 0x17, 0x19, 0xf6, 0xf5, 0x38, 0xdb, 0x44, 0x24, 0x25, 0x3e, 0xdf, 0x19,
	0x1d, 0x31, 0x14, 0xe4, 0x3e, 0x19, 0xf4, 0x8d, 0xdd, 0x6b, 0x97, 0x50, 0xd3, 0xf5, 0x9b, 0x44,
	0xe3, 0x8f, 0x02, 0x61, 0x09, 0xac, 0x54, 0x25, 0xe1, 0xa2, 0x20, 0xdc, 0x1e, 0x11, 0x4a, 0x58,
	0xda, 0x78, 0x96, 0x6c, 0x16, 0x82, 0x65, 0xb0, 0x9a, 0x0f, 0x3a, 0x82, 0x2b, 0x2e, 0xb8, 0x92,
	0x23, 0xae, 0x7c, 0xed, 0x95, 0x20, 0x3b, 0x18, 0xf4, 0x0d, 0x68, 0x07, 0x9d, 0x69, 0xb6, 0x08,
	0x0c, 0x5e, 0x01, 0x50, 0xc6, 0x1e, 0x09, 0xef, 0x05, 0xe3, 0xd2, 0x14, 0x63, 0x19, 0x7b, 0x82,
	0x31, 0x3d, 0xe8, 0x1b, 0xfb, 0x9e, 0xd0, 0x9b, 0x26, 0x8d, 0x86, 0xe1, 0x37, 0x20, 0x61, 0x31,
	0x12, 0xa2, 0x16, 0x16, 0xc4, 0xcb, 0x82, 0x78, 0x6f, 0x44, 0xac, 0xc9, 0x64, 0xea, 0x53, 0x09,
	0x4c, 0xb3, 0xcf, 0xc1, 0x33, 0xff, 0x5b, 0x04, 0x07, 0x05, 0x97, 0xb2, 0xd0, 0xbd, 0xee, 0x30,
	0xec, 0x58, 0x38, 0xbc, 0x75, 0x6d, 0x9c, 0x47, 0xa1, 0x03, 0xbf, 0x04, 0xb1, 0x86, 0xf2, 0xdb,
	0xe6, 0x29, 0x0a, 0xdc, 0x53, 0x1e, 0x89, 0x65, 0xcc, 0x50, 0x6e, 0xf7, 0xfb, 0xbe, 0xb1, 0xf0,
	0x43, 0xdf, 0x88, 0x0d, 0xfa, 0xc6, 0xea, 0x53, 0xd7, 0x6f, 0xbb, 0x3e, 0xae, 0x0f, 0x7f, 0xc0,
	0xe7, 0x20, 0x56, 0x1d, 0xb9, 0x87, 0xef, 0xab, 0x5e, 0x7f, 0x8b, 0x6d, 0x26, 0x76, 0x1e, 0x6a,
	0x3b, 0xb7, 0x78, 0xa1, 0xd6, 0x6b, 0xc5, 0xe4, 0x1a, 0xbe, 0x01, 0x4b, 0x56, 0x80, 0x6d, 0xe5,
	0x9d, 0xc7, 0xa3, 0x2b, 0x47, 0x7f, 0x2e, 0x57, 0xcd, 0x1d, 0x70, 0x7a, 0x4e, 0x4d, 0x03, 0x6c,
	0xeb, 0xd4, 0x93, 0x6b, 0x88, 0x46, 0x65, 0x48, 0x3a, 0xea, 0xd3, 0x87, 0xc8, 0x55, 0x32, 0x28,
	0xfa, 0x8f, 0xa8, 0x4a, 0xbf, 0xf9, 0xd9, 0xbf, 0xfe, 0x9a, 0x4e, 0xc3, 0x4f, 0x9c, 0x31, 0x1f,
	0x95, 0x7c, 0x36, 0x0a, 0x1d, 0x9a, 0xf9, 0x71, 0x05, 0x1c, 0xce, 0xbf, 0x08, 0xfc, 0x02, 0x2c,
	0x9f, 0x3b, 0x9e, 0xcb, 0x84, 0xfd, 0xd7, 0x72, 0xbb, 0x83, 0xbe, 0xb1, 0x8d, 0x38, 0xa0, 0x9d,
	0x39, 0x0d, 0xc0, 0x5f, 0x82, 0xc5, 0x52, 0x41, 0x15, 0xd6, 0xe4, 0xa0, 0x6f, 0x6c, 0xb8, 0x8e,
	0xa6, 0x3e, 0xb1, 0xe2, 0xb9, 0x59, 0xaa, 0xe5, 0x89, 0xdf, 0x74, 0x5b, 0xca, 0xc0, 0xe3, 0xdc,
	0x1c, 0x0a, 0x64, 0x6e, 0xba, 0x81, 0x69, 0x8b, 0xa5, 0x9e, 0x9b, 0x11, 0x20, 0x24, 0x60, 0xad,
	0xdc, 0xf2, 0x58, 0x99, 0x38, 0x58, 0x55, 0xca, 0xcb, 0x5e, 0x37, 0x6d, 0x8e, 0x1a, 0xc7, 0xdc,
	0xdb, 0x9e, 0x0e, 0xb7, 0x89, 0x92, 0xbf, 0xeb, 0xb5, 0x3c, 0x66, 0x7a, 0xc4, 0xd1, 0x6b, 0x64,
	0x14, 0x08, 0xff, 0x08, 0x12, 0x15, 0xcc, 0xee, 0x48, 0xf8, 0x9d, 0x38, 0x53, 0x16, 0xd9, 0x4a,
	0xaf, 0x9b, 0x3e, 0xfb, 0x88, 0x33, 0xb5, 0x9d, 0xe2, 0xd8, 0x03, 0x5f, 0x02, 0xd3, 0x27, 0xcf,
	0xc1, 0x61, 0x5d, 0xde, 0xf6, 0xaa, 0x8d, 0xfc, 0xd4, 0xca, 0x71, 0xec, 0x64, 0x33, 0xf7, 0xa4,
	0xd7, 0x4d, 0x27, 0x4b, 0x3e, 0xab, 0x23, 0xbf, 0x85, 0x4f, 0xce, 0x9e, 0xfe, 0xea, 0xec, 0xd9,
	0xaf, 0xc7, 0x17, 0xba, 0x6d, 0x23, 0x7f, 0xe6, 0x42, 0x93, 0x20, 0x2c, 0x82, 0x84, 0x2a, 0xd5,
	0x6d, 0x1c, 0xd2, 0xd4, 0xea, 0x71, 0xfc, 0x64, 0x5d, 0x96, 0x0c, 0x7b, 0x0c, 0xeb, 0x25, 0x23,
	0x12, 0x86, 0x21, 0xd8, 0xac, 0x93, 0x0e, 0x73, 0xfd, 0x96, 0x72, 0xf0, 0x9a, 0xb0, 0xcc, 0xf9,
	0xbb, 0x6e, 0xfa, 0xe7, 0x60, 0xad, 0x82, 0x3c, 0xec, 0xd4, 0x71, 0x13, 0xee, 0xab, 0x9b, 0x65,
	0x27, 0x94, 0x07, 0x7d, 0x23, 0x15, 0x4a, 0x60, 0xd6, 0xef, 0x73, 0x25, 0xb0, 0x09, 0x40, 0xc1,
	0xca, 0xd7, 0x42, 0xd2, 0x74, 0xdb, 0x38, 0xb5, 0x2e, 0x0e, 0xfc, 0xed, 0xbb, 0x6e, 0xfa, 0x48,
	0x3b, 0x10, 0xaa, 0x00, 0xcb, 0x8e, 0x35, 0xf9, 0xdd, 0x1c, 0x6a, 0x07, 0x72, 0xf5, 0xf4, 0x58,
	0xbb, 0x5b, 0x24, 0x9c, 0xc9, 0x80, 0xf5, 0x51, 0xb4, 0xc0, 0x35, 0xb0, 0x74, 0x59, 0xb5, 0x1a,
	0xc9, 0x05, 0xde, 0x1f, 0x2b, 0xc5, 0xc6, 0xeb, 0x6a, 0xfd, 0x45, 0x32, 0x96, 0x79, 0x0c, 0x36,
	0x74, 0xef, 0xc2, 0x55, 0x10, 0xaf, 0x56, 0x73, 0xc9, 0x05, 0x08, 0xc0, 0x4a, 0xa9, 0x92, 0x3b,
	0xaf, 0x14, 0x92, 0xb1, 0xcc, 0xdf, 0x12, 0xe0, 0xd1, 0x87, 0x92, 0x1d, 0xfe, 0x19, 0x6c, 0xf1,
	0x14, 0xa4, 0x7c, 0xb6, 0xaa, 0xdd, 0x20, 0x3a, 0x9c, 0x86, 0x5e, 0xf6, 0xba, 0xe9, 0x27, 0x0f,
	0x04, 0x98, 0x60, 0x38, 0x15, 0xbb, 0x78, 0x04, 0xa4, 0xd1, 0x90, 0xc8, 0x0c, 0x38, 0xa6, 0x59,
	0x74, 0xbe, 0x08, 0x7e, 0x03, 0xc0, 0x68, 0x08, 0xe0, 0xf3, 0x12, 0xef, 0xd1, 0xfb, 0xe3, 0x42,
	0xa5, 0xcd, 0x61, 0xb9, 0x47, 0xaa, 0x30, 0xed, 0xd9, 0xa3, 0x0d, 0x7a, 0xa7, 0x8e, 0x42, 0xe1,
	0x39, 0x58, 0xb7, 0x70, 0xe8, 0xa2, 0x76, 0xa5, 0xe3, 0xa9, 0x69, 0x49, 0x34, 0x7b, 0x2a, 0x40,
	0xd3, 0xef, 0x78, 0x3a, 0x45, 0x14, 0x0a, 0x7f, 0x0f, 0x40, 0x2d, 0x74, 0x3d, 0x14, 0xde, 0x97,
	0xcf, 0xf3, 0x2a, 0xe7, 0xb3, 0xbd, 0x6e, 0x1a, 0x16, 0xb9, 0xb8, 0x1a, 0x9e, 0x94, 0x91, 0x7d,
	0xee, 0x38, 0xe1, 0xc9, 0x67, 0xdc, 0x0a, 0xfb, 0x81, 0xd4, 0x35, 0x3d, 0xa4, 0xd7, 0xe6, 0x68,
	0x78, 0xa2, 0x40, 0x2d, 0xff, 0x34, 0x05, 0xea, 0x0a, 0x00, 0xeb, 0x9e, 0x32, 0xd9, 0x8a, 0x45,
	0xd2, 0xea, 0x2d, 0x5a, 0x4d, 0x2d, 0x32, 0xdf, 0xa8, 0xd0, 0x9b, 0x69, 0xd1, 0x91, 0x30, 0xcc,
	0x01, 0x50, 0xf2, 0x19, 0x0e, 0x9b, 0xc8, 0xc6, 0xc3, 0xac, 0x15, 0xa6, 0x74, 0x47, 0xa8, 0x6e,
	0xca, 0x28, 0x94, 0x73, 0x14, 0xac, 0xfc, 0x70, 0x94, 0x5f, 0x1b, 0xbb, 0x63, 0x8c, 0xea, 0x1c,
	0x51, 0x28, 0x1f, 0x54, 0x0b, 0x56, 0xde, 0xfa, 0xae, 0xa3, 0xf2, 0x4f, 0x0c, 0xaa, 0x12, 0xd1,
	0x5b, 0xd5, 0x34, 0x02, 0xcf, 0xc0, 0xd2, 0x25, 0xa1, 0x2c, 0x05, 0xc4, 0x2e, 0xc8, 0xfb, 0xe7,
	0x0d, 0xa1, 0x7a, 0xab, 0x99, 0x5a, 0xc3, 0xdf, 0x81, 0xbd, 0xc9, 0xdc, 0x50, 0x03, 0x72, 0x42,
	0x30, 0x1c, 0x0d, 0xfa, 0xc6, 0x21, 0x72, 0x3c, 0x19, 0xd1, 0xe6, 0xcc, 0xa8, 0xfc, 0x01, 0x19,
	0xb4, 0xc0, 0xb6, 0xba, 0x58, 0xd9, 0xa5, 0x1e, 0x62, 0xf6, 0x4d, 0x6a, 0x43, 0xb4, 0x40, 0x41,
	0xaa, 0x9e, 0x54, 0xa6, 0xa7, 0x64, 0x3a, 0xe9, 0x7c, 0x19, 0xfc, 0x13, 0x80, 0xb3, 0x23, 0x70,
	0x6a, 0x53, 0x04, 0xc0, 0xd1, 0x54, 0x46, 0x4d, 0x69, 0xc9, 0x17, 0x84, 0xaa, 0xb3, 0x66, 0xc0,
	0x05, 0xb3, 0xa3, 0xf0, 0x03, 0x72, 0x68, 0x83, 0xdd, 0x12, 0xcd, 0x13, 0xdf, 0xc7, 0x36, 0xc3,
	0x4e, 0x83, 0x5c, 0x89, 0xb7, 0x71, 0x6a, 0x4b, 0x5c, 0xec, 0x17, 0x83, 0xbe, 0x71, 0xec, 0x52,
	0x1e, 0xae, 0x52, 0x6e, 0x32, 0x62, 0xca, 0xd7, 0xb3, 0x76, 0xc4, 0x83, 0x1a, 0xf0, 0x0d, 0xd8,
	0x79, 0xe5, 0xdf, 0x60, 0xd4, 0x66, 0x37, 0xf7, 0xaa, 0x16, 0xd1, 0xd4, 0xb6, 0x08, 0xc6, 0xe3,
	0x41, 0xdf, 0x78, 0xd4, 0x19, 0x0a, 0x4d, 0x35, 0x88, 0xe8, 0x37, 0xf8, 0xa0, 0x34, 0x73, 0x0d,
	0x96, 0x85, 0x97, 0x79, 0x99, 0x1d, 0x3e, 0x37, 0x16, 0xe0, 0x36, 0x48, 0xd4, 0x8b, 0x17, 0x25,
	0xab, 0x51, 0xac, 0x97, 0x2a, 0x17, 0xc9, 0x18, 0xdc, 0x00, 0x6b, 0xf5, 0xe2, 0x57, 0xc5, 0x7c,
	0x83, 0x3f, 0x3d, 0xb8, 0x6e, 0xad, 0x58, 0x29, 0x70, 0x51, 0x9c, 0x8b, 0xce, 0x0b, 0xe5, 0x52,
	0x83, 0x8b, 0x96, 0x20, 0x04, 0x5b, 0x85, 0x62, 0xbe, 0x5a, 0x2e, 0x97, 0x2c, 0xab, 0x54, 0xad,
	0x14, 0x0b, 0xc9, 0xe5, 0xcc, 0x8f, 0xb1, 0x71, 0xc2, 0xc3, 0x06, 0x58, 0x2f, 0xd5, 0x78, 0xe5,
	0xc0, 0x94, 0xaa, 0xb2, 0xcb, 0xbb, 0xeb, 0xf6, 0xb0, 0xae, 0xe4, 0x4b, 0x85, 0xba, 0x2c, 0x2a,
	0x7b, 0x6e, 0x60, 0x22, 0xa9, 0x38, 0x91, 0x63, 0x11, 0x28, 0x7f, 0xf3, 0x14, 0x70, 0x13, 0x75,
	0xda, 0xec, 0xe2, 0xb5, 0x1a, 0x93, 0xcc, 0x5e, 0x37, 0xbd, 0x33, 0x64, 0x95, 0x47, 0x2a, 0x5e,
	0x47, 0x6a, 0x9a, 0xad, 0x3b, 0x9d, 0x37, 0x0a, 0x85, 0x05, 0x00, 0x0a, 0x15, 0x8b, 0xdb, 0x9c,
	0x77, 0xed, 0xf8, 0xb8, 0x6b, 0x3b, 0x3e, 0x15, 0xe6, 0x9c, 0xea, 0xda, 0x91, 0x70, 0xa6, 0x17,
	0x03, 0x6b, 0x65, 0x64, 0x8b, 0xe9, 0x01, 0x7e, 0x0d, 0x96, 0x2d, 0x86, 0x42, 0xa6, 0x2e, 0x6f,
	0xce, 0x2d, 0xaa, 0xbb, 0x1e, 0xb2, 0x79, 0xc0, 0x85, 0x6c, 0x62, 0xb8, 0x98, 0x05, 0xe1, 0x0b,
	0x10, 0x2f, 0xfa, 0x8e, 0xba, 0xf7, 0x93, 0xb9, 0x84, 0x3b, 0x7c, 0x2f, 0xf6, 0x9d, 0x89, 0x07,
	0xea, 0x34, 0x94, 0x79, 0xb7, 0x08, 0xc0, 0xf8, 0x95, 0x08, 0x2f, 0x40, 0x82, 0xaf, 0x26, 0x3d,
	0x26, 0x9e, 0x23, 0x01, 0xc6, 0x61, 0x84, 0x83, 0xe6, 0xe0, 0x7c, 0xee, 0xe5, 0x94, 0x58, 0x7d,
	0xa6, 0x98, 0x7b, 0x79, 0x3a, 0xe9, 0xa9, 0x30, 0x0d, 0xf0, 0x4e, 0x56, 0xc7, 0x1e, 0x61, 0xf8,
	0xdc, 0xaa, 0x88, 0x4e, 0xb6, 0x29, 0x4b, 0x67, 0x28, 0x40, 0x13, 0xd1, 0x89, 0xd2, 0x19, 0x85,
	0xf2, 0xb2, 0xa3, 0x3e, 0xfe, 0x39, 0xf2, 0xdc, 0xb6, 0x8b, 0xf9, 0xcb, 0x20, 0x3e, 0xae, 0x65,
	0x42, 0x64, 0x36, 0x95, 0x6c, 0xb2, 0x96, 0xcd, 0x93, 0xe5, 0x8c, 0x7f, 0xfe, 0x25, 0x9d, 0xe0,
	0x13, 0x13, 0x96, 0xff, 0x3f, 0x7d, 0xff, 0xfe, 0x28, 0xf6, 0xc3, 0xfb, 0xa3, 0xd8, 0x7f, 0xde,
	0x1f, 0xc5, 0xfe, 0xfb, 0xfe, 0x68, 0xa1, 0x16, 0xbb, 0x5e, 0x11, 0x82, 0x2f, 0xfe, 0x1f, 0x00,
	0x00, 0xff, 0xff, 0xb2, 0x65, 0xe9, 0x9a, 0x7d, 0x13, 0x00, 0x00,
}
