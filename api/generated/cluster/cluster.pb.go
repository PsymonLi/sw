// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: cluster.proto

/*
	Package cluster is a generated protocol buffer package.

	Service name

	It is generated from these files:
		cluster.proto
		smartnic.proto
		svc_cluster.proto
		tenant.proto

	It has these top-level messages:
		CPUInfo
		Cluster
		ClusterAuthBootstrapRequest
		ClusterSpec
		ClusterStatus
		DockerInfo
		Host
		HostSpec
		HostStatus
		InterfaceInfo
		MemInfo
		NetworkInfo
		Node
		NodeCondition
		NodeInfo
		NodeSpec
		NodeStatus
		OsInfo
		SmartNICID
		StorageDeviceInfo
		StorageInfo
		UpdateTLSConfigRequest
		Version
		VersionSpec
		VersionStatus
		BiosInfo
		IPConfig
		MacRange
		SmartNIC
		SmartNICCondition
		SmartNICInfo
		SmartNICSpec
		SmartNICStatus
		AutoMsgClusterWatchHelper
		AutoMsgHostWatchHelper
		AutoMsgNodeWatchHelper
		AutoMsgSmartNICWatchHelper
		AutoMsgTenantWatchHelper
		AutoMsgVersionWatchHelper
		ClusterList
		HostList
		NodeList
		SmartNICList
		TenantList
		VersionList
		Tenant
		TenantSpec
		TenantStatus
*/
package cluster

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/pensando/grpc-gateway/third_party/googleapis/google/api"
import _ "github.com/pensando/sw/venice/utils/apigen/annotations"
import _ "github.com/gogo/protobuf/gogoproto"
import api "github.com/pensando/sw/api"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// These are valid condition statuses.
type ConditionStatus int32

const (
	// ui-hint: Unknown
	ConditionStatus_UNKNOWN ConditionStatus = 0
	// ui-hint: True
	ConditionStatus_TRUE ConditionStatus = 1
	// ui-hint: False
	ConditionStatus_FALSE ConditionStatus = 2
)

var ConditionStatus_name = map[int32]string{
	0: "UNKNOWN",
	1: "TRUE",
	2: "FALSE",
}
var ConditionStatus_value = map[string]int32{
	"UNKNOWN": 0,
	"TRUE":    1,
	"FALSE":   2,
}

func (x ConditionStatus) String() string {
	return proto.EnumName(ConditionStatus_name, int32(x))
}
func (ConditionStatus) EnumDescriptor() ([]byte, []int) { return fileDescriptorCluster, []int{0} }

// Type of Memory
type MemInfo_MemType int32

const (
	//
	MemInfo_UNKNOWN MemInfo_MemType = 0
	//
	MemInfo_HBM MemInfo_MemType = 1
	//
	MemInfo_DDR MemInfo_MemType = 2
)

var MemInfo_MemType_name = map[int32]string{
	0: "UNKNOWN",
	1: "HBM",
	2: "DDR",
}
var MemInfo_MemType_value = map[string]int32{
	"UNKNOWN": 0,
	"HBM":     1,
	"DDR":     2,
}

func (x MemInfo_MemType) String() string {
	return proto.EnumName(MemInfo_MemType_name, int32(x))
}
func (MemInfo_MemType) EnumDescriptor() ([]byte, []int) { return fileDescriptorCluster, []int{10, 0} }

// These are valid conditions of a Node
type NodeCondition_ConditionType int32

const (
	// ui-hint: Leader
	NodeCondition_LEADER NodeCondition_ConditionType = 0
	// ui-hint: Healthy
	NodeCondition_HEALTHY NodeCondition_ConditionType = 1
)

var NodeCondition_ConditionType_name = map[int32]string{
	0: "LEADER",
	1: "HEALTHY",
}
var NodeCondition_ConditionType_value = map[string]int32{
	"LEADER":  0,
	"HEALTHY": 1,
}

func (x NodeCondition_ConditionType) String() string {
	return proto.EnumName(NodeCondition_ConditionType_name, int32(x))
}
func (NodeCondition_ConditionType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorCluster, []int{13, 0}
}

// Various phases in lifecycle of a Node
type NodeStatus_NodePhase int32

const (
	// ui-hint: Unknown
	NodeStatus_UNKNOWN NodeStatus_NodePhase = 0
	// ui-hint: Pending
	NodeStatus_PENDING NodeStatus_NodePhase = 1
	// ui-hint: Joined
	NodeStatus_JOINED NodeStatus_NodePhase = 2
	// ui-hint: Failed
	NodeStatus_FAILED NodeStatus_NodePhase = 3
)

var NodeStatus_NodePhase_name = map[int32]string{
	0: "UNKNOWN",
	1: "PENDING",
	2: "JOINED",
	3: "FAILED",
}
var NodeStatus_NodePhase_value = map[string]int32{
	"UNKNOWN": 0,
	"PENDING": 1,
	"JOINED":  2,
	"FAILED":  3,
}

func (x NodeStatus_NodePhase) String() string {
	return proto.EnumName(NodeStatus_NodePhase_name, int32(x))
}
func (NodeStatus_NodePhase) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorCluster, []int{16, 0}
}

// CPU information
type CPUInfo struct {
	// CPU speed per core, eg: 2099998101
	Speed string `protobuf:"bytes,1,opt,name=Speed,json=speed,omitempty,proto3" json:"speed,omitempty"`
	// Number of CPU sockets, eg: 2, 4
	NumSockets int32 `protobuf:"varint,2,opt,name=NumSockets,json=num-sockets,omitempty,proto3" json:"num-sockets,omitempty"`
	// Number of physical CPU cores per socket, eg: 36
	NumCores int32 `protobuf:"varint,3,opt,name=NumCores,json=num-cores,omitempty,proto3" json:"num-cores,omitempty"`
	// Number of threads per core, eg: 2
	NumThreads int32 `protobuf:"varint,4,opt,name=NumThreads,json=num-threads,omitempty,proto3" json:"num-threads,omitempty"`
}

func (m *CPUInfo) Reset()                    { *m = CPUInfo{} }
func (m *CPUInfo) String() string            { return proto.CompactTextString(m) }
func (*CPUInfo) ProtoMessage()               {}
func (*CPUInfo) Descriptor() ([]byte, []int) { return fileDescriptorCluster, []int{0} }

func (m *CPUInfo) GetSpeed() string {
	if m != nil {
		return m.Speed
	}
	return ""
}

func (m *CPUInfo) GetNumSockets() int32 {
	if m != nil {
		return m.NumSockets
	}
	return 0
}

func (m *CPUInfo) GetNumCores() int32 {
	if m != nil {
		return m.NumCores
	}
	return 0
}

func (m *CPUInfo) GetNumThreads() int32 {
	if m != nil {
		return m.NumThreads
	}
	return 0
}

// --------------------------------- CLUSTER ---------------------------------------------
//
// Cluster represents a full cluster venice and workload nodes
//
// Entity responsible & scenarios involved in managing this object:
//
//      Create:
//          o NetOps-admin
//              - initial cluster creation
//      Modify:
//          o NetOps-admin
//              - update spec attributes
//          o CMD
//              - update status attributes
//      Delete:
//          o NetOps-admin
//              - TBD
//
type Cluster struct {
	//
	api.TypeMeta `protobuf:"bytes,1,opt,name=T,json=,inline,embedded=T" json:",inline"`
	//
	api.ObjectMeta `protobuf:"bytes,2,opt,name=O,json=meta,omitempty,embedded=O" json:"meta,omitempty"`
	// Spec contains the configuration of the cluster.
	Spec ClusterSpec `protobuf:"bytes,3,opt,name=Spec,json=spec,omitempty" json:"spec,omitempty"`
	// Status contains the current state of the cluster.
	Status ClusterStatus `protobuf:"bytes,4,opt,name=Status,json=status,omitempty" json:"status,omitempty"`
}

func (m *Cluster) Reset()                    { *m = Cluster{} }
func (m *Cluster) String() string            { return proto.CompactTextString(m) }
func (*Cluster) ProtoMessage()               {}
func (*Cluster) Descriptor() ([]byte, []int) { return fileDescriptorCluster, []int{1} }

func (m *Cluster) GetSpec() ClusterSpec {
	if m != nil {
		return m.Spec
	}
	return ClusterSpec{}
}

func (m *Cluster) GetStatus() ClusterStatus {
	if m != nil {
		return m.Status
	}
	return ClusterStatus{}
}

// ClusterAuthBootstrapRequest is to set auth bootstrap flag in cluster
type ClusterAuthBootstrapRequest struct {
	//
	api.TypeMeta `protobuf:"bytes,1,opt,name=T,json=,inline,embedded=T" json:",inline"`
	//
	api.ObjectMeta `protobuf:"bytes,2,opt,name=O,json=meta,omitempty,embedded=O" json:"meta,omitempty"`
}

func (m *ClusterAuthBootstrapRequest) Reset()         { *m = ClusterAuthBootstrapRequest{} }
func (m *ClusterAuthBootstrapRequest) String() string { return proto.CompactTextString(m) }
func (*ClusterAuthBootstrapRequest) ProtoMessage()    {}
func (*ClusterAuthBootstrapRequest) Descriptor() ([]byte, []int) {
	return fileDescriptorCluster, []int{2}
}

// ClusterSpec contains the configuration of the cluster.
type ClusterSpec struct {
	// QuorumNodes contains the list of hostnames for nodes configured to be quorum
	// nodes in the cluster.
	QuorumNodes []string `protobuf:"bytes,1,rep,name=QuorumNodes,json=quorum-nodes,omitempty" json:"quorum-nodes,omitempty"`
	// VirtualIP is the IP address for managing the cluster. It will be hosted by
	// the winner of election between quorum nodes.
	VirtualIP string `protobuf:"bytes,2,opt,name=VirtualIP,json=virtual-ip,omitempty,proto3" json:"virtual-ip,omitempty"`
	// NTPServers contains the list of NTP servers for the cluster.
	NTPServers []string `protobuf:"bytes,3,rep,name=NTPServers,json=ntp-servers,omitempty" json:"ntp-servers,omitempty"`
	// AutoAdmitNICs when enabled auto-admits NICs that are validated
	// into Venice Cluster. When it is disabled, NICs validated by CMD are
	// set to Pending state and it requires Manual approval to be admitted
	// into the cluster.
	AutoAdmitNICs bool `protobuf:"varint,4,opt,name=AutoAdmitNICs,json=auto-admit-nics,proto3" json:"auto-admit-nics"`
	// Certs is the pem encoded certificate bundle used for API Gateway TLS
	Certs string `protobuf:"bytes,5,opt,name=Certs,json=certs,omitempty,proto3" json:"certs,omitempty"`
	// Key is the pem encoded private key used for API Gateway TLS. We support RSA or ECDSA
	Key string `protobuf:"bytes,6,opt,name=Key,json=key,omitempty,proto3" json:"key,omitempty"`
}

func (m *ClusterSpec) Reset()                    { *m = ClusterSpec{} }
func (m *ClusterSpec) String() string            { return proto.CompactTextString(m) }
func (*ClusterSpec) ProtoMessage()               {}
func (*ClusterSpec) Descriptor() ([]byte, []int) { return fileDescriptorCluster, []int{3} }

func (m *ClusterSpec) GetQuorumNodes() []string {
	if m != nil {
		return m.QuorumNodes
	}
	return nil
}

func (m *ClusterSpec) GetVirtualIP() string {
	if m != nil {
		return m.VirtualIP
	}
	return ""
}

func (m *ClusterSpec) GetNTPServers() []string {
	if m != nil {
		return m.NTPServers
	}
	return nil
}

func (m *ClusterSpec) GetAutoAdmitNICs() bool {
	if m != nil {
		return m.AutoAdmitNICs
	}
	return false
}

func (m *ClusterSpec) GetCerts() string {
	if m != nil {
		return m.Certs
	}
	return ""
}

func (m *ClusterSpec) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

// ClusterStatus contains the current state of the Cluster.
type ClusterStatus struct {
	// Leader contains the node name of the cluster leader.
	Leader string `protobuf:"bytes,1,opt,name=Leader,json=leader,omitempty,proto3" json:"leader,omitempty"`
	// LastLeaderTransitionTime is when the leadership changed last time
	LastLeaderTransitionTime *api.Timestamp `protobuf:"bytes,2,opt,name=LastLeaderTransitionTime,json=last-leader-transition-time,omitempty" json:"last-leader-transition-time,omitempty"`
	// AuthBootstrapped indicates whether the Cluster has Completed BootStrap of Auth
	AuthBootstrapped bool `protobuf:"varint,3,opt,name=AuthBootstrapped,json=auth-bootstrapped,proto3" json:"auth-bootstrapped"`
}

func (m *ClusterStatus) Reset()                    { *m = ClusterStatus{} }
func (m *ClusterStatus) String() string            { return proto.CompactTextString(m) }
func (*ClusterStatus) ProtoMessage()               {}
func (*ClusterStatus) Descriptor() ([]byte, []int) { return fileDescriptorCluster, []int{4} }

func (m *ClusterStatus) GetLeader() string {
	if m != nil {
		return m.Leader
	}
	return ""
}

func (m *ClusterStatus) GetLastLeaderTransitionTime() *api.Timestamp {
	if m != nil {
		return m.LastLeaderTransitionTime
	}
	return nil
}

func (m *ClusterStatus) GetAuthBootstrapped() bool {
	if m != nil {
		return m.AuthBootstrapped
	}
	return false
}

// Docker information
type DockerInfo struct {
	// Docker version
	DockerVersion string `protobuf:"bytes,1,opt,name=DockerVersion,json=docker-version,omitempty,proto3" json:"docker-version,omitempty"`
}

func (m *DockerInfo) Reset()                    { *m = DockerInfo{} }
func (m *DockerInfo) String() string            { return proto.CompactTextString(m) }
func (*DockerInfo) ProtoMessage()               {}
func (*DockerInfo) Descriptor() ([]byte, []int) { return fileDescriptorCluster, []int{5} }

func (m *DockerInfo) GetDockerVersion() string {
	if m != nil {
		return m.DockerVersion
	}
	return ""
}

// ---------------------------------- HOST ------------------------------------
//
// Host represents a Baremetal or Hypervisor server.
//
type Host struct {
	//
	api.TypeMeta `protobuf:"bytes,1,opt,name=T,json=,inline,embedded=T" json:",inline"`
	//
	api.ObjectMeta `protobuf:"bytes,2,opt,name=O,json=meta,omitempty,embedded=O" json:"meta,omitempty"`
	// Spec contains the configuration of the host.
	Spec HostSpec `protobuf:"bytes,3,opt,name=Spec,json=spec,omitempty" json:"spec,omitempty"`
	// Status contains the current state of the host.
	Status HostStatus `protobuf:"bytes,4,opt,name=Status,json=status,omitempty" json:"status,omitempty"`
}

func (m *Host) Reset()                    { *m = Host{} }
func (m *Host) String() string            { return proto.CompactTextString(m) }
func (*Host) ProtoMessage()               {}
func (*Host) Descriptor() ([]byte, []int) { return fileDescriptorCluster, []int{6} }

func (m *Host) GetSpec() HostSpec {
	if m != nil {
		return m.Spec
	}
	return HostSpec{}
}

func (m *Host) GetStatus() HostStatus {
	if m != nil {
		return m.Status
	}
	return HostStatus{}
}

// HostSpec contains the configuration of the Host.
type HostSpec struct {
	// SmartNICs contains the information about all SmartNICs on a host
	SmartNICs []SmartNICID `protobuf:"bytes,1,rep,name=SmartNICs,json=smart-nics,omitempty" json:"smart-nics,omitempty"`
}

func (m *HostSpec) Reset()                    { *m = HostSpec{} }
func (m *HostSpec) String() string            { return proto.CompactTextString(m) }
func (*HostSpec) ProtoMessage()               {}
func (*HostSpec) Descriptor() ([]byte, []int) { return fileDescriptorCluster, []int{7} }

func (m *HostSpec) GetSmartNICs() []SmartNICID {
	if m != nil {
		return m.SmartNICs
	}
	return nil
}

// HostStatus contains the current state of the Host.
type HostStatus struct {
	// AdmittedSmartNICs contains a list of admitted SmartNICs that are on this host
	AdmittedSmartNICs []string `protobuf:"bytes,1,rep,name=AdmittedSmartNICs,json=admitted-smart-nics,omitempty" json:"admitted-smart-nics,omitempty"`
}

func (m *HostStatus) Reset()                    { *m = HostStatus{} }
func (m *HostStatus) String() string            { return proto.CompactTextString(m) }
func (*HostStatus) ProtoMessage()               {}
func (*HostStatus) Descriptor() ([]byte, []int) { return fileDescriptorCluster, []int{8} }

func (m *HostStatus) GetAdmittedSmartNICs() []string {
	if m != nil {
		return m.AdmittedSmartNICs
	}
	return nil
}

// Interface information
type InterfaceInfo struct {
	// Name, eg: vmnic0, eth0
	Name string `protobuf:"bytes,1,opt,name=Name,json=name,omitempty,proto3" json:"name,omitempty"`
	// Type
	Type string `protobuf:"bytes,2,opt,name=Type,json=type,omitempty,proto3" json:"type,omitempty"`
	// Vendor info
	Vendor string `protobuf:"bytes,3,opt,name=Vendor,json=vendor,omitempty,proto3" json:"vendor,omitempty"`
	// Link Speed in Bits per second
	LinkSpeed string `protobuf:"bytes,4,opt,name=LinkSpeed,json=link-speed,omitempty,proto3" json:"link-speed,omitempty"`
	// MAC address
	MacAddr string `protobuf:"bytes,5,opt,name=MacAddr,json=mac-addr,omitempty,proto3" json:"mac-addr,omitempty"`
	// List of Ip addresses
	IpAddrs []string `protobuf:"bytes,6,rep,name=IpAddrs,json=ip-addrs,omitempty" json:"ip-addrs,omitempty"`
}

func (m *InterfaceInfo) Reset()                    { *m = InterfaceInfo{} }
func (m *InterfaceInfo) String() string            { return proto.CompactTextString(m) }
func (*InterfaceInfo) ProtoMessage()               {}
func (*InterfaceInfo) Descriptor() ([]byte, []int) { return fileDescriptorCluster, []int{9} }

func (m *InterfaceInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *InterfaceInfo) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *InterfaceInfo) GetVendor() string {
	if m != nil {
		return m.Vendor
	}
	return ""
}

func (m *InterfaceInfo) GetLinkSpeed() string {
	if m != nil {
		return m.LinkSpeed
	}
	return ""
}

func (m *InterfaceInfo) GetMacAddr() string {
	if m != nil {
		return m.MacAddr
	}
	return ""
}

func (m *InterfaceInfo) GetIpAddrs() []string {
	if m != nil {
		return m.IpAddrs
	}
	return nil
}

// Memory/RAM information
type MemInfo struct {
	// Type
	Type string `protobuf:"bytes,1,opt,name=Type,json=type,omitempty,proto3" json:"type,omitempty"`
	// Memory size in bytes, eg: 274760318976
	Size_ string `protobuf:"bytes,2,opt,name=Size,json=size,omitempty,proto3" json:"size,omitempty"`
}

func (m *MemInfo) Reset()                    { *m = MemInfo{} }
func (m *MemInfo) String() string            { return proto.CompactTextString(m) }
func (*MemInfo) ProtoMessage()               {}
func (*MemInfo) Descriptor() ([]byte, []int) { return fileDescriptorCluster, []int{10} }

func (m *MemInfo) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *MemInfo) GetSize_() string {
	if m != nil {
		return m.Size_
	}
	return ""
}

// Network information
type NetworkInfo struct {
	// List of interfaces or ports
	Interfaces []InterfaceInfo `protobuf:"bytes,1,rep,name=Interfaces,json=interfaces,omitempty" json:"interfaces,omitempty"`
}

func (m *NetworkInfo) Reset()                    { *m = NetworkInfo{} }
func (m *NetworkInfo) String() string            { return proto.CompactTextString(m) }
func (*NetworkInfo) ProtoMessage()               {}
func (*NetworkInfo) Descriptor() ([]byte, []int) { return fileDescriptorCluster, []int{11} }

func (m *NetworkInfo) GetInterfaces() []InterfaceInfo {
	if m != nil {
		return m.Interfaces
	}
	return nil
}

// ---------------------------------- NODE -------------------------------------------
//
// Node is representation of a single Venice node in the system.
//
type Node struct {
	//
	api.TypeMeta `protobuf:"bytes,1,opt,name=T,json=,inline,embedded=T" json:",inline"`
	//
	api.ObjectMeta `protobuf:"bytes,2,opt,name=O,json=meta,omitempty,embedded=O" json:"meta,omitempty"`
	// Spec contains the configuration of the node.
	Spec NodeSpec `protobuf:"bytes,3,opt,name=Spec,json=spec,omitempty" json:"spec,omitempty"`
	// Status contains the current state of the node.
	Status NodeStatus `protobuf:"bytes,4,opt,name=Status,json=status,omitempty" json:"status,omitempty"`
}

func (m *Node) Reset()                    { *m = Node{} }
func (m *Node) String() string            { return proto.CompactTextString(m) }
func (*Node) ProtoMessage()               {}
func (*Node) Descriptor() ([]byte, []int) { return fileDescriptorCluster, []int{12} }

func (m *Node) GetSpec() NodeSpec {
	if m != nil {
		return m.Spec
	}
	return NodeSpec{}
}

func (m *Node) GetStatus() NodeStatus {
	if m != nil {
		return m.Status
	}
	return NodeStatus{}
}

// NodeCondition describes the state of a Node at a certain point.
type NodeCondition struct {
	// Type indicates a certain node condition
	Type string `protobuf:"bytes,1,opt,name=Type,json=type,omitempty,proto3" json:"type,omitempty"`
	// Condition Status
	Status string `protobuf:"bytes,2,opt,name=Status,json=status,omitempty,proto3" json:"status,omitempty"`
	// The last time the condition transitioned
	LastTransitionTime string `protobuf:"bytes,3,opt,name=LastTransitionTime,json=last-transition-time,omitempty,proto3" json:"last-transition-time,omitempty"`
	// The reason for the condition's last transition
	Reason string `protobuf:"bytes,4,opt,name=Reason,json=reason,omitempty,proto3" json:"reason,omitempty"`
	// A detailed message indicating details about the transition.
	Message string `protobuf:"bytes,5,opt,name=Message,json=message,omitempty,proto3" json:"message,omitempty"`
}

func (m *NodeCondition) Reset()                    { *m = NodeCondition{} }
func (m *NodeCondition) String() string            { return proto.CompactTextString(m) }
func (*NodeCondition) ProtoMessage()               {}
func (*NodeCondition) Descriptor() ([]byte, []int) { return fileDescriptorCluster, []int{13} }

func (m *NodeCondition) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *NodeCondition) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *NodeCondition) GetLastTransitionTime() string {
	if m != nil {
		return m.LastTransitionTime
	}
	return ""
}

func (m *NodeCondition) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

func (m *NodeCondition) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

// Venice Node system information
type NodeInfo struct {
	// OS details
	OsInfo *OsInfo `protobuf:"bytes,1,opt,name=OsInfo,json=os-info,omitempty" json:"os-info,omitempty"`
	// Docker (container runtime) details
	DockerInfo *DockerInfo `protobuf:"bytes,2,opt,name=DockerInfo,json=docker-info,omitempty" json:"docker-info,omitempty"`
	// CPU details
	CpuInfo *CPUInfo `protobuf:"bytes,3,opt,name=CpuInfo,json=cpu-info,omitempty" json:"cpu-info,omitempty"`
	// RAM/Memory details
	MemoryInfo *MemInfo `protobuf:"bytes,4,opt,name=MemoryInfo,json=memory-info,omitempty" json:"memory-info,omitempty"`
	// Storage details
	StorageInfo *StorageInfo `protobuf:"bytes,5,opt,name=StorageInfo,json=storage-info,omitempty" json:"storage-info,omitempty"`
	// Network details
	NetworkInfo *NetworkInfo `protobuf:"bytes,6,opt,name=NetworkInfo,json=network-info,omitempty" json:"network-info,omitempty"`
}

func (m *NodeInfo) Reset()                    { *m = NodeInfo{} }
func (m *NodeInfo) String() string            { return proto.CompactTextString(m) }
func (*NodeInfo) ProtoMessage()               {}
func (*NodeInfo) Descriptor() ([]byte, []int) { return fileDescriptorCluster, []int{14} }

func (m *NodeInfo) GetOsInfo() *OsInfo {
	if m != nil {
		return m.OsInfo
	}
	return nil
}

func (m *NodeInfo) GetDockerInfo() *DockerInfo {
	if m != nil {
		return m.DockerInfo
	}
	return nil
}

func (m *NodeInfo) GetCpuInfo() *CPUInfo {
	if m != nil {
		return m.CpuInfo
	}
	return nil
}

func (m *NodeInfo) GetMemoryInfo() *MemInfo {
	if m != nil {
		return m.MemoryInfo
	}
	return nil
}

func (m *NodeInfo) GetStorageInfo() *StorageInfo {
	if m != nil {
		return m.StorageInfo
	}
	return nil
}

func (m *NodeInfo) GetNetworkInfo() *NetworkInfo {
	if m != nil {
		return m.NetworkInfo
	}
	return nil
}

// NodeSpec contains the configuration of the node.
type NodeSpec struct {
}

func (m *NodeSpec) Reset()                    { *m = NodeSpec{} }
func (m *NodeSpec) String() string            { return proto.CompactTextString(m) }
func (*NodeSpec) ProtoMessage()               {}
func (*NodeSpec) Descriptor() ([]byte, []int) { return fileDescriptorCluster, []int{15} }

// NodeStatus contains the current state of the node.
type NodeStatus struct {
	// Current lifecycle phase of the node.
	Phase string `protobuf:"bytes,1,opt,name=Phase,json=phase,omitempty,proto3" json:"phase,omitempty"`
	// Quorum node or not.
	Quorum bool `protobuf:"varint,2,opt,name=Quorum,json=quorum,omitempty,proto3" json:"quorum,omitempty"`
	// List of current node conditions
	Conditions []NodeCondition `protobuf:"bytes,3,rep,name=Conditions,json=conditions,omitempty" json:"conditions,omitempty"`
}

func (m *NodeStatus) Reset()                    { *m = NodeStatus{} }
func (m *NodeStatus) String() string            { return proto.CompactTextString(m) }
func (*NodeStatus) ProtoMessage()               {}
func (*NodeStatus) Descriptor() ([]byte, []int) { return fileDescriptorCluster, []int{16} }

func (m *NodeStatus) GetPhase() string {
	if m != nil {
		return m.Phase
	}
	return ""
}

func (m *NodeStatus) GetQuorum() bool {
	if m != nil {
		return m.Quorum
	}
	return false
}

func (m *NodeStatus) GetConditions() []NodeCondition {
	if m != nil {
		return m.Conditions
	}
	return nil
}

// OS information
type OsInfo struct {
	// OS Name
	// Eg: GNU/Linux
	Name string `protobuf:"bytes,1,opt,name=Name,json=type,omitempty,proto3" json:"type,omitempty"`
	// Kernel release
	// Eg: 3.10.0-514.10.2.el7.x86_64
	KernelRelease string `protobuf:"bytes,2,opt,name=KernelRelease,json=kernel-relase,omitempty,proto3" json:"kernel-relase,omitempty"`
	// Kernel version
	// Eg: #1 SMP Fri Mar 3 00:04:05 UTC 2017
	Version string `protobuf:"bytes,3,opt,name=Version,json=kernel-version,omitempty,proto3" json:"kernel-version,omitempty"`
	// Processor Info
	// Eg: x86_64
	Processor string `protobuf:"bytes,4,opt,name=Processor,json=processor,omitempty,proto3" json:"processor,omitempty"`
}

func (m *OsInfo) Reset()                    { *m = OsInfo{} }
func (m *OsInfo) String() string            { return proto.CompactTextString(m) }
func (*OsInfo) ProtoMessage()               {}
func (*OsInfo) Descriptor() ([]byte, []int) { return fileDescriptorCluster, []int{17} }

func (m *OsInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *OsInfo) GetKernelRelease() string {
	if m != nil {
		return m.KernelRelease
	}
	return ""
}

func (m *OsInfo) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *OsInfo) GetProcessor() string {
	if m != nil {
		return m.Processor
	}
	return ""
}

// SmartNICID contains the identifying information of a SmartNIC
type SmartNICID struct {
	// Name contains the name of the SmartNIC on a host
	ID string `protobuf:"bytes,1,opt,name=ID,json=id,omitempty,proto3" json:"id,omitempty"`
	// MACAddress contains the primary MAC address of a SmartNIC
	MACAddress string `protobuf:"bytes,2,opt,name=MACAddress,json=mac-address,omitempty,proto3" json:"mac-address,omitempty"`
}

func (m *SmartNICID) Reset()                    { *m = SmartNICID{} }
func (m *SmartNICID) String() string            { return proto.CompactTextString(m) }
func (*SmartNICID) ProtoMessage()               {}
func (*SmartNICID) Descriptor() ([]byte, []int) { return fileDescriptorCluster, []int{18} }

func (m *SmartNICID) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

func (m *SmartNICID) GetMACAddress() string {
	if m != nil {
		return m.MACAddress
	}
	return ""
}

// Storage device information
type StorageDeviceInfo struct {
	// Serial Number
	SerialNumber string `protobuf:"bytes,1,opt,name=SerialNumber,json=serial-num,omitempty,proto3" json:"serial-num,omitempty"`
	// Storage Type (TBD for Naples)
	// Eg: SATA, SCSI, NVMe  or HDD, SSD, NVMe
	Type string `protobuf:"bytes,2,opt,name=Type,json=type,omitempty,proto3" json:"type,omitempty"`
	// Vendor info
	Vendor string `protobuf:"bytes,3,opt,name=Vendor,json=vendor,omitempty,proto3" json:"vendor,omitempty"`
	// Capacity in bytes
	Capacity string `protobuf:"bytes,4,opt,name=Capacity,json=capacity,omitempty,proto3" json:"capacity,omitempty"`
	// Used life in percentage
	TypeAPercentLifeUsed int32 `protobuf:"varint,5,opt,name=TypeAPercentLifeUsed,json=percent-life-used-A,omitempty,proto3" json:"percent-life-used-A,omitempty"`
	//
	TypeBPercentLifeUsed int32 `protobuf:"varint,6,opt,name=TypeBPercentLifeUsed,json=percent-life-used-B,omitempty,proto3" json:"percent-life-used-B,omitempty"`
}

func (m *StorageDeviceInfo) Reset()                    { *m = StorageDeviceInfo{} }
func (m *StorageDeviceInfo) String() string            { return proto.CompactTextString(m) }
func (*StorageDeviceInfo) ProtoMessage()               {}
func (*StorageDeviceInfo) Descriptor() ([]byte, []int) { return fileDescriptorCluster, []int{19} }

func (m *StorageDeviceInfo) GetSerialNumber() string {
	if m != nil {
		return m.SerialNumber
	}
	return ""
}

func (m *StorageDeviceInfo) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *StorageDeviceInfo) GetVendor() string {
	if m != nil {
		return m.Vendor
	}
	return ""
}

func (m *StorageDeviceInfo) GetCapacity() string {
	if m != nil {
		return m.Capacity
	}
	return ""
}

func (m *StorageDeviceInfo) GetTypeAPercentLifeUsed() int32 {
	if m != nil {
		return m.TypeAPercentLifeUsed
	}
	return 0
}

func (m *StorageDeviceInfo) GetTypeBPercentLifeUsed() int32 {
	if m != nil {
		return m.TypeBPercentLifeUsed
	}
	return 0
}

// Storage information
type StorageInfo struct {
	// List of storage devices
	Devices []StorageDeviceInfo `protobuf:"bytes,1,rep,name=Devices,json=devices,omitempty" json:"devices,omitempty"`
}

func (m *StorageInfo) Reset()                    { *m = StorageInfo{} }
func (m *StorageInfo) String() string            { return proto.CompactTextString(m) }
func (*StorageInfo) ProtoMessage()               {}
func (*StorageInfo) Descriptor() ([]byte, []int) { return fileDescriptorCluster, []int{20} }

func (m *StorageInfo) GetDevices() []StorageDeviceInfo {
	if m != nil {
		return m.Devices
	}
	return nil
}

// UpdateTLSConfigRequest is to update certs and key for API Gateway TLS
type UpdateTLSConfigRequest struct {
	//
	api.TypeMeta `protobuf:"bytes,1,opt,name=T,json=,inline,embedded=T" json:",inline"`
	//
	api.ObjectMeta `protobuf:"bytes,2,opt,name=O,json=meta,omitempty,embedded=O" json:"meta,omitempty"`
	// Certs is the pem encoded certificate bundle used for API Gateway TLS
	Certs string `protobuf:"bytes,3,opt,name=Certs,json=certs,omitempty,proto3" json:"certs,omitempty"`
	// Key is the pem encoded private key used for API Gateway TLS. We support RSA or ECDSA
	Key string `protobuf:"bytes,4,opt,name=Key,json=key,omitempty,proto3" json:"key,omitempty"`
}

func (m *UpdateTLSConfigRequest) Reset()                    { *m = UpdateTLSConfigRequest{} }
func (m *UpdateTLSConfigRequest) String() string            { return proto.CompactTextString(m) }
func (*UpdateTLSConfigRequest) ProtoMessage()               {}
func (*UpdateTLSConfigRequest) Descriptor() ([]byte, []int) { return fileDescriptorCluster, []int{21} }

func (m *UpdateTLSConfigRequest) GetCerts() string {
	if m != nil {
		return m.Certs
	}
	return ""
}

func (m *UpdateTLSConfigRequest) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

// Version is public accessible object that holds build information.
type Version struct {
	//
	api.TypeMeta `protobuf:"bytes,1,opt,name=T,json=,inline,embedded=T" json:",inline"`
	//
	api.ObjectMeta `protobuf:"bytes,2,opt,name=O,json=meta,omitempty,embedded=O" json:"meta,omitempty"`
	// Spec contains the configuration of the cluster.
	Spec VersionSpec `protobuf:"bytes,3,opt,name=Spec,json=spec,omitempty" json:"spec,omitempty"`
	// Status contains the current state of the Version.
	Status VersionStatus `protobuf:"bytes,4,opt,name=Status,json=status,omitempty" json:"status,omitempty"`
}

func (m *Version) Reset()                    { *m = Version{} }
func (m *Version) String() string            { return proto.CompactTextString(m) }
func (*Version) ProtoMessage()               {}
func (*Version) Descriptor() ([]byte, []int) { return fileDescriptorCluster, []int{22} }

func (m *Version) GetSpec() VersionSpec {
	if m != nil {
		return m.Spec
	}
	return VersionSpec{}
}

func (m *Version) GetStatus() VersionStatus {
	if m != nil {
		return m.Status
	}
	return VersionStatus{}
}

// VersionSpec contains the configuration of the Version.
type VersionSpec struct {
}

func (m *VersionSpec) Reset()                    { *m = VersionSpec{} }
func (m *VersionSpec) String() string            { return proto.CompactTextString(m) }
func (*VersionSpec) ProtoMessage()               {}
func (*VersionSpec) Descriptor() ([]byte, []int) { return fileDescriptorCluster, []int{23} }

// VersionStatus contains the current state of the Version.
type VersionStatus struct {
	// Human friendly build version
	BuildVersion string `protobuf:"bytes,1,opt,name=BuildVersion,json=build-version,omitempty,proto3" json:"build-version,omitempty"`
	// Representation of ommit in version control system - e.g: hash in git
	VCSCommit string `protobuf:"bytes,2,opt,name=VCSCommit,json=vcs-commit,omitempty,proto3" json:"vcs-commit,omitempty"`
	// Date and Time at which the source code was built
	BuildDate string `protobuf:"bytes,3,opt,name=BuildDate,json=build-date,omitempty,proto3" json:"build-date,omitempty"`
	// RolloutBuildVersion shows in progress rollout version
	RolloutBuildVersion string `protobuf:"bytes,4,opt,name=RolloutBuildVersion,json=rollout-build-version,proto3" json:"rollout-build-version"`
}

func (m *VersionStatus) Reset()                    { *m = VersionStatus{} }
func (m *VersionStatus) String() string            { return proto.CompactTextString(m) }
func (*VersionStatus) ProtoMessage()               {}
func (*VersionStatus) Descriptor() ([]byte, []int) { return fileDescriptorCluster, []int{24} }

func (m *VersionStatus) GetBuildVersion() string {
	if m != nil {
		return m.BuildVersion
	}
	return ""
}

func (m *VersionStatus) GetVCSCommit() string {
	if m != nil {
		return m.VCSCommit
	}
	return ""
}

func (m *VersionStatus) GetBuildDate() string {
	if m != nil {
		return m.BuildDate
	}
	return ""
}

func (m *VersionStatus) GetRolloutBuildVersion() string {
	if m != nil {
		return m.RolloutBuildVersion
	}
	return ""
}

func init() {
	proto.RegisterType((*CPUInfo)(nil), "cluster.CPUInfo")
	proto.RegisterType((*Cluster)(nil), "cluster.Cluster")
	proto.RegisterType((*ClusterAuthBootstrapRequest)(nil), "cluster.ClusterAuthBootstrapRequest")
	proto.RegisterType((*ClusterSpec)(nil), "cluster.ClusterSpec")
	proto.RegisterType((*ClusterStatus)(nil), "cluster.ClusterStatus")
	proto.RegisterType((*DockerInfo)(nil), "cluster.DockerInfo")
	proto.RegisterType((*Host)(nil), "cluster.Host")
	proto.RegisterType((*HostSpec)(nil), "cluster.HostSpec")
	proto.RegisterType((*HostStatus)(nil), "cluster.HostStatus")
	proto.RegisterType((*InterfaceInfo)(nil), "cluster.InterfaceInfo")
	proto.RegisterType((*MemInfo)(nil), "cluster.MemInfo")
	proto.RegisterType((*NetworkInfo)(nil), "cluster.NetworkInfo")
	proto.RegisterType((*Node)(nil), "cluster.Node")
	proto.RegisterType((*NodeCondition)(nil), "cluster.NodeCondition")
	proto.RegisterType((*NodeInfo)(nil), "cluster.NodeInfo")
	proto.RegisterType((*NodeSpec)(nil), "cluster.NodeSpec")
	proto.RegisterType((*NodeStatus)(nil), "cluster.NodeStatus")
	proto.RegisterType((*OsInfo)(nil), "cluster.OsInfo")
	proto.RegisterType((*SmartNICID)(nil), "cluster.SmartNICID")
	proto.RegisterType((*StorageDeviceInfo)(nil), "cluster.StorageDeviceInfo")
	proto.RegisterType((*StorageInfo)(nil), "cluster.StorageInfo")
	proto.RegisterType((*UpdateTLSConfigRequest)(nil), "cluster.UpdateTLSConfigRequest")
	proto.RegisterType((*Version)(nil), "cluster.Version")
	proto.RegisterType((*VersionSpec)(nil), "cluster.VersionSpec")
	proto.RegisterType((*VersionStatus)(nil), "cluster.VersionStatus")
	proto.RegisterEnum("cluster.ConditionStatus", ConditionStatus_name, ConditionStatus_value)
	proto.RegisterEnum("cluster.MemInfo_MemType", MemInfo_MemType_name, MemInfo_MemType_value)
	proto.RegisterEnum("cluster.NodeCondition_ConditionType", NodeCondition_ConditionType_name, NodeCondition_ConditionType_value)
	proto.RegisterEnum("cluster.NodeStatus_NodePhase", NodeStatus_NodePhase_name, NodeStatus_NodePhase_value)
}
func (m *CPUInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CPUInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Speed) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCluster(dAtA, i, uint64(len(m.Speed)))
		i += copy(dAtA[i:], m.Speed)
	}
	if m.NumSockets != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCluster(dAtA, i, uint64(m.NumSockets))
	}
	if m.NumCores != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCluster(dAtA, i, uint64(m.NumCores))
	}
	if m.NumThreads != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCluster(dAtA, i, uint64(m.NumThreads))
	}
	return i, nil
}

func (m *Cluster) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Cluster) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintCluster(dAtA, i, uint64(m.TypeMeta.Size()))
	n1, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n1
	dAtA[i] = 0x12
	i++
	i = encodeVarintCluster(dAtA, i, uint64(m.ObjectMeta.Size()))
	n2, err := m.ObjectMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n2
	dAtA[i] = 0x1a
	i++
	i = encodeVarintCluster(dAtA, i, uint64(m.Spec.Size()))
	n3, err := m.Spec.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n3
	dAtA[i] = 0x22
	i++
	i = encodeVarintCluster(dAtA, i, uint64(m.Status.Size()))
	n4, err := m.Status.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n4
	return i, nil
}

func (m *ClusterAuthBootstrapRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClusterAuthBootstrapRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintCluster(dAtA, i, uint64(m.TypeMeta.Size()))
	n5, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n5
	dAtA[i] = 0x12
	i++
	i = encodeVarintCluster(dAtA, i, uint64(m.ObjectMeta.Size()))
	n6, err := m.ObjectMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n6
	return i, nil
}

func (m *ClusterSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClusterSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.QuorumNodes) > 0 {
		for _, s := range m.QuorumNodes {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.VirtualIP) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCluster(dAtA, i, uint64(len(m.VirtualIP)))
		i += copy(dAtA[i:], m.VirtualIP)
	}
	if len(m.NTPServers) > 0 {
		for _, s := range m.NTPServers {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.AutoAdmitNICs {
		dAtA[i] = 0x20
		i++
		if m.AutoAdmitNICs {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Certs) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintCluster(dAtA, i, uint64(len(m.Certs)))
		i += copy(dAtA[i:], m.Certs)
	}
	if len(m.Key) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintCluster(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	return i, nil
}

func (m *ClusterStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClusterStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Leader) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCluster(dAtA, i, uint64(len(m.Leader)))
		i += copy(dAtA[i:], m.Leader)
	}
	if m.LastLeaderTransitionTime != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCluster(dAtA, i, uint64(m.LastLeaderTransitionTime.Size()))
		n7, err := m.LastLeaderTransitionTime.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.AuthBootstrapped {
		dAtA[i] = 0x18
		i++
		if m.AuthBootstrapped {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *DockerInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DockerInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.DockerVersion) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCluster(dAtA, i, uint64(len(m.DockerVersion)))
		i += copy(dAtA[i:], m.DockerVersion)
	}
	return i, nil
}

func (m *Host) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Host) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintCluster(dAtA, i, uint64(m.TypeMeta.Size()))
	n8, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n8
	dAtA[i] = 0x12
	i++
	i = encodeVarintCluster(dAtA, i, uint64(m.ObjectMeta.Size()))
	n9, err := m.ObjectMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n9
	dAtA[i] = 0x1a
	i++
	i = encodeVarintCluster(dAtA, i, uint64(m.Spec.Size()))
	n10, err := m.Spec.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n10
	dAtA[i] = 0x22
	i++
	i = encodeVarintCluster(dAtA, i, uint64(m.Status.Size()))
	n11, err := m.Status.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n11
	return i, nil
}

func (m *HostSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HostSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.SmartNICs) > 0 {
		for _, msg := range m.SmartNICs {
			dAtA[i] = 0xa
			i++
			i = encodeVarintCluster(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *HostStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HostStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AdmittedSmartNICs) > 0 {
		for _, s := range m.AdmittedSmartNICs {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *InterfaceInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InterfaceInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCluster(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Type) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCluster(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.Vendor) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCluster(dAtA, i, uint64(len(m.Vendor)))
		i += copy(dAtA[i:], m.Vendor)
	}
	if len(m.LinkSpeed) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCluster(dAtA, i, uint64(len(m.LinkSpeed)))
		i += copy(dAtA[i:], m.LinkSpeed)
	}
	if len(m.MacAddr) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintCluster(dAtA, i, uint64(len(m.MacAddr)))
		i += copy(dAtA[i:], m.MacAddr)
	}
	if len(m.IpAddrs) > 0 {
		for _, s := range m.IpAddrs {
			dAtA[i] = 0x32
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *MemInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MemInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCluster(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.Size_) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCluster(dAtA, i, uint64(len(m.Size_)))
		i += copy(dAtA[i:], m.Size_)
	}
	return i, nil
}

func (m *NetworkInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NetworkInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Interfaces) > 0 {
		for _, msg := range m.Interfaces {
			dAtA[i] = 0xa
			i++
			i = encodeVarintCluster(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Node) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Node) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintCluster(dAtA, i, uint64(m.TypeMeta.Size()))
	n12, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n12
	dAtA[i] = 0x12
	i++
	i = encodeVarintCluster(dAtA, i, uint64(m.ObjectMeta.Size()))
	n13, err := m.ObjectMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n13
	dAtA[i] = 0x1a
	i++
	i = encodeVarintCluster(dAtA, i, uint64(m.Spec.Size()))
	n14, err := m.Spec.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n14
	dAtA[i] = 0x22
	i++
	i = encodeVarintCluster(dAtA, i, uint64(m.Status.Size()))
	n15, err := m.Status.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n15
	return i, nil
}

func (m *NodeCondition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeCondition) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCluster(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.Status) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCluster(dAtA, i, uint64(len(m.Status)))
		i += copy(dAtA[i:], m.Status)
	}
	if len(m.LastTransitionTime) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCluster(dAtA, i, uint64(len(m.LastTransitionTime)))
		i += copy(dAtA[i:], m.LastTransitionTime)
	}
	if len(m.Reason) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCluster(dAtA, i, uint64(len(m.Reason)))
		i += copy(dAtA[i:], m.Reason)
	}
	if len(m.Message) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintCluster(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	return i, nil
}

func (m *NodeInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.OsInfo != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCluster(dAtA, i, uint64(m.OsInfo.Size()))
		n16, err := m.OsInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	if m.DockerInfo != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCluster(dAtA, i, uint64(m.DockerInfo.Size()))
		n17, err := m.DockerInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	if m.CpuInfo != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCluster(dAtA, i, uint64(m.CpuInfo.Size()))
		n18, err := m.CpuInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	if m.MemoryInfo != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCluster(dAtA, i, uint64(m.MemoryInfo.Size()))
		n19, err := m.MemoryInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	if m.StorageInfo != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintCluster(dAtA, i, uint64(m.StorageInfo.Size()))
		n20, err := m.StorageInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	if m.NetworkInfo != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintCluster(dAtA, i, uint64(m.NetworkInfo.Size()))
		n21, err := m.NetworkInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	return i, nil
}

func (m *NodeSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *NodeStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Phase) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCluster(dAtA, i, uint64(len(m.Phase)))
		i += copy(dAtA[i:], m.Phase)
	}
	if m.Quorum {
		dAtA[i] = 0x10
		i++
		if m.Quorum {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Conditions) > 0 {
		for _, msg := range m.Conditions {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintCluster(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *OsInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OsInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCluster(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.KernelRelease) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCluster(dAtA, i, uint64(len(m.KernelRelease)))
		i += copy(dAtA[i:], m.KernelRelease)
	}
	if len(m.Version) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCluster(dAtA, i, uint64(len(m.Version)))
		i += copy(dAtA[i:], m.Version)
	}
	if len(m.Processor) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCluster(dAtA, i, uint64(len(m.Processor)))
		i += copy(dAtA[i:], m.Processor)
	}
	return i, nil
}

func (m *SmartNICID) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SmartNICID) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCluster(dAtA, i, uint64(len(m.ID)))
		i += copy(dAtA[i:], m.ID)
	}
	if len(m.MACAddress) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCluster(dAtA, i, uint64(len(m.MACAddress)))
		i += copy(dAtA[i:], m.MACAddress)
	}
	return i, nil
}

func (m *StorageDeviceInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StorageDeviceInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.SerialNumber) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCluster(dAtA, i, uint64(len(m.SerialNumber)))
		i += copy(dAtA[i:], m.SerialNumber)
	}
	if len(m.Type) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCluster(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.Vendor) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCluster(dAtA, i, uint64(len(m.Vendor)))
		i += copy(dAtA[i:], m.Vendor)
	}
	if len(m.Capacity) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCluster(dAtA, i, uint64(len(m.Capacity)))
		i += copy(dAtA[i:], m.Capacity)
	}
	if m.TypeAPercentLifeUsed != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintCluster(dAtA, i, uint64(m.TypeAPercentLifeUsed))
	}
	if m.TypeBPercentLifeUsed != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintCluster(dAtA, i, uint64(m.TypeBPercentLifeUsed))
	}
	return i, nil
}

func (m *StorageInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StorageInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Devices) > 0 {
		for _, msg := range m.Devices {
			dAtA[i] = 0xa
			i++
			i = encodeVarintCluster(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *UpdateTLSConfigRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateTLSConfigRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintCluster(dAtA, i, uint64(m.TypeMeta.Size()))
	n22, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n22
	dAtA[i] = 0x12
	i++
	i = encodeVarintCluster(dAtA, i, uint64(m.ObjectMeta.Size()))
	n23, err := m.ObjectMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n23
	if len(m.Certs) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCluster(dAtA, i, uint64(len(m.Certs)))
		i += copy(dAtA[i:], m.Certs)
	}
	if len(m.Key) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCluster(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	return i, nil
}

func (m *Version) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Version) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintCluster(dAtA, i, uint64(m.TypeMeta.Size()))
	n24, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n24
	dAtA[i] = 0x12
	i++
	i = encodeVarintCluster(dAtA, i, uint64(m.ObjectMeta.Size()))
	n25, err := m.ObjectMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n25
	dAtA[i] = 0x1a
	i++
	i = encodeVarintCluster(dAtA, i, uint64(m.Spec.Size()))
	n26, err := m.Spec.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n26
	dAtA[i] = 0x22
	i++
	i = encodeVarintCluster(dAtA, i, uint64(m.Status.Size()))
	n27, err := m.Status.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n27
	return i, nil
}

func (m *VersionSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VersionSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *VersionStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VersionStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.BuildVersion) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCluster(dAtA, i, uint64(len(m.BuildVersion)))
		i += copy(dAtA[i:], m.BuildVersion)
	}
	if len(m.VCSCommit) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCluster(dAtA, i, uint64(len(m.VCSCommit)))
		i += copy(dAtA[i:], m.VCSCommit)
	}
	if len(m.BuildDate) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCluster(dAtA, i, uint64(len(m.BuildDate)))
		i += copy(dAtA[i:], m.BuildDate)
	}
	if len(m.RolloutBuildVersion) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCluster(dAtA, i, uint64(len(m.RolloutBuildVersion)))
		i += copy(dAtA[i:], m.RolloutBuildVersion)
	}
	return i, nil
}

func encodeVarintCluster(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *CPUInfo) Size() (n int) {
	var l int
	_ = l
	l = len(m.Speed)
	if l > 0 {
		n += 1 + l + sovCluster(uint64(l))
	}
	if m.NumSockets != 0 {
		n += 1 + sovCluster(uint64(m.NumSockets))
	}
	if m.NumCores != 0 {
		n += 1 + sovCluster(uint64(m.NumCores))
	}
	if m.NumThreads != 0 {
		n += 1 + sovCluster(uint64(m.NumThreads))
	}
	return n
}

func (m *Cluster) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovCluster(uint64(l))
	l = m.ObjectMeta.Size()
	n += 1 + l + sovCluster(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovCluster(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovCluster(uint64(l))
	return n
}

func (m *ClusterAuthBootstrapRequest) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovCluster(uint64(l))
	l = m.ObjectMeta.Size()
	n += 1 + l + sovCluster(uint64(l))
	return n
}

func (m *ClusterSpec) Size() (n int) {
	var l int
	_ = l
	if len(m.QuorumNodes) > 0 {
		for _, s := range m.QuorumNodes {
			l = len(s)
			n += 1 + l + sovCluster(uint64(l))
		}
	}
	l = len(m.VirtualIP)
	if l > 0 {
		n += 1 + l + sovCluster(uint64(l))
	}
	if len(m.NTPServers) > 0 {
		for _, s := range m.NTPServers {
			l = len(s)
			n += 1 + l + sovCluster(uint64(l))
		}
	}
	if m.AutoAdmitNICs {
		n += 2
	}
	l = len(m.Certs)
	if l > 0 {
		n += 1 + l + sovCluster(uint64(l))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovCluster(uint64(l))
	}
	return n
}

func (m *ClusterStatus) Size() (n int) {
	var l int
	_ = l
	l = len(m.Leader)
	if l > 0 {
		n += 1 + l + sovCluster(uint64(l))
	}
	if m.LastLeaderTransitionTime != nil {
		l = m.LastLeaderTransitionTime.Size()
		n += 1 + l + sovCluster(uint64(l))
	}
	if m.AuthBootstrapped {
		n += 2
	}
	return n
}

func (m *DockerInfo) Size() (n int) {
	var l int
	_ = l
	l = len(m.DockerVersion)
	if l > 0 {
		n += 1 + l + sovCluster(uint64(l))
	}
	return n
}

func (m *Host) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovCluster(uint64(l))
	l = m.ObjectMeta.Size()
	n += 1 + l + sovCluster(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovCluster(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovCluster(uint64(l))
	return n
}

func (m *HostSpec) Size() (n int) {
	var l int
	_ = l
	if len(m.SmartNICs) > 0 {
		for _, e := range m.SmartNICs {
			l = e.Size()
			n += 1 + l + sovCluster(uint64(l))
		}
	}
	return n
}

func (m *HostStatus) Size() (n int) {
	var l int
	_ = l
	if len(m.AdmittedSmartNICs) > 0 {
		for _, s := range m.AdmittedSmartNICs {
			l = len(s)
			n += 1 + l + sovCluster(uint64(l))
		}
	}
	return n
}

func (m *InterfaceInfo) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCluster(uint64(l))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovCluster(uint64(l))
	}
	l = len(m.Vendor)
	if l > 0 {
		n += 1 + l + sovCluster(uint64(l))
	}
	l = len(m.LinkSpeed)
	if l > 0 {
		n += 1 + l + sovCluster(uint64(l))
	}
	l = len(m.MacAddr)
	if l > 0 {
		n += 1 + l + sovCluster(uint64(l))
	}
	if len(m.IpAddrs) > 0 {
		for _, s := range m.IpAddrs {
			l = len(s)
			n += 1 + l + sovCluster(uint64(l))
		}
	}
	return n
}

func (m *MemInfo) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovCluster(uint64(l))
	}
	l = len(m.Size_)
	if l > 0 {
		n += 1 + l + sovCluster(uint64(l))
	}
	return n
}

func (m *NetworkInfo) Size() (n int) {
	var l int
	_ = l
	if len(m.Interfaces) > 0 {
		for _, e := range m.Interfaces {
			l = e.Size()
			n += 1 + l + sovCluster(uint64(l))
		}
	}
	return n
}

func (m *Node) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovCluster(uint64(l))
	l = m.ObjectMeta.Size()
	n += 1 + l + sovCluster(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovCluster(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovCluster(uint64(l))
	return n
}

func (m *NodeCondition) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovCluster(uint64(l))
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovCluster(uint64(l))
	}
	l = len(m.LastTransitionTime)
	if l > 0 {
		n += 1 + l + sovCluster(uint64(l))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovCluster(uint64(l))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovCluster(uint64(l))
	}
	return n
}

func (m *NodeInfo) Size() (n int) {
	var l int
	_ = l
	if m.OsInfo != nil {
		l = m.OsInfo.Size()
		n += 1 + l + sovCluster(uint64(l))
	}
	if m.DockerInfo != nil {
		l = m.DockerInfo.Size()
		n += 1 + l + sovCluster(uint64(l))
	}
	if m.CpuInfo != nil {
		l = m.CpuInfo.Size()
		n += 1 + l + sovCluster(uint64(l))
	}
	if m.MemoryInfo != nil {
		l = m.MemoryInfo.Size()
		n += 1 + l + sovCluster(uint64(l))
	}
	if m.StorageInfo != nil {
		l = m.StorageInfo.Size()
		n += 1 + l + sovCluster(uint64(l))
	}
	if m.NetworkInfo != nil {
		l = m.NetworkInfo.Size()
		n += 1 + l + sovCluster(uint64(l))
	}
	return n
}

func (m *NodeSpec) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *NodeStatus) Size() (n int) {
	var l int
	_ = l
	l = len(m.Phase)
	if l > 0 {
		n += 1 + l + sovCluster(uint64(l))
	}
	if m.Quorum {
		n += 2
	}
	if len(m.Conditions) > 0 {
		for _, e := range m.Conditions {
			l = e.Size()
			n += 1 + l + sovCluster(uint64(l))
		}
	}
	return n
}

func (m *OsInfo) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCluster(uint64(l))
	}
	l = len(m.KernelRelease)
	if l > 0 {
		n += 1 + l + sovCluster(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovCluster(uint64(l))
	}
	l = len(m.Processor)
	if l > 0 {
		n += 1 + l + sovCluster(uint64(l))
	}
	return n
}

func (m *SmartNICID) Size() (n int) {
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovCluster(uint64(l))
	}
	l = len(m.MACAddress)
	if l > 0 {
		n += 1 + l + sovCluster(uint64(l))
	}
	return n
}

func (m *StorageDeviceInfo) Size() (n int) {
	var l int
	_ = l
	l = len(m.SerialNumber)
	if l > 0 {
		n += 1 + l + sovCluster(uint64(l))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovCluster(uint64(l))
	}
	l = len(m.Vendor)
	if l > 0 {
		n += 1 + l + sovCluster(uint64(l))
	}
	l = len(m.Capacity)
	if l > 0 {
		n += 1 + l + sovCluster(uint64(l))
	}
	if m.TypeAPercentLifeUsed != 0 {
		n += 1 + sovCluster(uint64(m.TypeAPercentLifeUsed))
	}
	if m.TypeBPercentLifeUsed != 0 {
		n += 1 + sovCluster(uint64(m.TypeBPercentLifeUsed))
	}
	return n
}

func (m *StorageInfo) Size() (n int) {
	var l int
	_ = l
	if len(m.Devices) > 0 {
		for _, e := range m.Devices {
			l = e.Size()
			n += 1 + l + sovCluster(uint64(l))
		}
	}
	return n
}

func (m *UpdateTLSConfigRequest) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovCluster(uint64(l))
	l = m.ObjectMeta.Size()
	n += 1 + l + sovCluster(uint64(l))
	l = len(m.Certs)
	if l > 0 {
		n += 1 + l + sovCluster(uint64(l))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovCluster(uint64(l))
	}
	return n
}

func (m *Version) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovCluster(uint64(l))
	l = m.ObjectMeta.Size()
	n += 1 + l + sovCluster(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovCluster(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovCluster(uint64(l))
	return n
}

func (m *VersionSpec) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *VersionStatus) Size() (n int) {
	var l int
	_ = l
	l = len(m.BuildVersion)
	if l > 0 {
		n += 1 + l + sovCluster(uint64(l))
	}
	l = len(m.VCSCommit)
	if l > 0 {
		n += 1 + l + sovCluster(uint64(l))
	}
	l = len(m.BuildDate)
	if l > 0 {
		n += 1 + l + sovCluster(uint64(l))
	}
	l = len(m.RolloutBuildVersion)
	if l > 0 {
		n += 1 + l + sovCluster(uint64(l))
	}
	return n
}

func sovCluster(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozCluster(x uint64) (n int) {
	return sovCluster(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *CPUInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CPUInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CPUInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Speed", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Speed = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumSockets", wireType)
			}
			m.NumSockets = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumSockets |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumCores", wireType)
			}
			m.NumCores = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumCores |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumThreads", wireType)
			}
			m.NumThreads = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumThreads |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Cluster) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Cluster: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Cluster: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClusterAuthBootstrapRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClusterAuthBootstrapRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClusterAuthBootstrapRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClusterSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClusterSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClusterSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QuorumNodes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QuorumNodes = append(m.QuorumNodes, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VirtualIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VirtualIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NTPServers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NTPServers = append(m.NTPServers, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoAdmitNICs", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AutoAdmitNICs = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Certs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Certs = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClusterStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClusterStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClusterStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Leader", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Leader = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastLeaderTransitionTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastLeaderTransitionTime == nil {
				m.LastLeaderTransitionTime = &api.Timestamp{}
			}
			if err := m.LastLeaderTransitionTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthBootstrapped", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AuthBootstrapped = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DockerInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DockerInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DockerInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DockerVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DockerVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Host) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Host: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Host: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HostSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HostSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HostSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SmartNICs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SmartNICs = append(m.SmartNICs, SmartNICID{})
			if err := m.SmartNICs[len(m.SmartNICs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HostStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HostStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HostStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdmittedSmartNICs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AdmittedSmartNICs = append(m.AdmittedSmartNICs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InterfaceInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InterfaceInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InterfaceInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vendor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Vendor = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LinkSpeed", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LinkSpeed = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MacAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MacAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpAddrs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IpAddrs = append(m.IpAddrs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MemInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MemInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MemInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Size_ = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NetworkInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NetworkInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NetworkInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Interfaces", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Interfaces = append(m.Interfaces, InterfaceInfo{})
			if err := m.Interfaces[len(m.Interfaces)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Node) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Node: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Node: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeCondition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeCondition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeCondition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastTransitionTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastTransitionTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OsInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OsInfo == nil {
				m.OsInfo = &OsInfo{}
			}
			if err := m.OsInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DockerInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DockerInfo == nil {
				m.DockerInfo = &DockerInfo{}
			}
			if err := m.DockerInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CpuInfo == nil {
				m.CpuInfo = &CPUInfo{}
			}
			if err := m.CpuInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemoryInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MemoryInfo == nil {
				m.MemoryInfo = &MemInfo{}
			}
			if err := m.MemoryInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StorageInfo == nil {
				m.StorageInfo = &StorageInfo{}
			}
			if err := m.StorageInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NetworkInfo == nil {
				m.NetworkInfo = &NetworkInfo{}
			}
			if err := m.NetworkInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipCluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phase", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Phase = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quorum", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Quorum = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conditions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Conditions = append(m.Conditions, NodeCondition{})
			if err := m.Conditions[len(m.Conditions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OsInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OsInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OsInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KernelRelease", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KernelRelease = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Processor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Processor = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SmartNICID) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SmartNICID: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SmartNICID: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MACAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MACAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StorageDeviceInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StorageDeviceInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StorageDeviceInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SerialNumber", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SerialNumber = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vendor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Vendor = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Capacity", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Capacity = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeAPercentLifeUsed", wireType)
			}
			m.TypeAPercentLifeUsed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TypeAPercentLifeUsed |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeBPercentLifeUsed", wireType)
			}
			m.TypeBPercentLifeUsed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TypeBPercentLifeUsed |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StorageInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StorageInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StorageInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Devices", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Devices = append(m.Devices, StorageDeviceInfo{})
			if err := m.Devices[len(m.Devices)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateTLSConfigRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateTLSConfigRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateTLSConfigRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Certs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Certs = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Version) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Version: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Version: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VersionSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VersionSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VersionSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipCluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VersionStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VersionStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VersionStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BuildVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VCSCommit", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VCSCommit = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildDate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BuildDate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RolloutBuildVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RolloutBuildVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCluster(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCluster
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthCluster
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowCluster
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipCluster(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthCluster = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCluster   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("cluster.proto", fileDescriptorCluster) }

var fileDescriptorCluster = []byte{
	// 2067 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x59, 0x4f, 0x6f, 0x1b, 0xc7,
	0x15, 0x0f, 0x49, 0x49, 0x14, 0x1f, 0xcd, 0x88, 0x1a, 0xc9, 0x0a, 0xa9, 0xd8, 0xa2, 0xbb, 0x68,
	0x00, 0x39, 0xf0, 0x4a, 0x86, 0x5d, 0x04, 0x48, 0xd2, 0x3f, 0xe0, 0x92, 0xb4, 0x45, 0x8b, 0xa4,
	0x14, 0x92, 0x52, 0xeb, 0x04, 0x35, 0xb0, 0xda, 0x1d, 0x49, 0x5b, 0x71, 0xff, 0x64, 0x67, 0x56,
	0x81, 0x72, 0x2c, 0x10, 0x1d, 0xda, 0x4b, 0x0b, 0xb4, 0x40, 0x3f, 0x83, 0xd1, 0x02, 0x05, 0x7a,
	0x49, 0x73, 0x6a, 0x6f, 0x39, 0x06, 0xf9, 0x00, 0x44, 0xe1, 0x23, 0x3f, 0x44, 0x51, 0xcc, 0xcc,
	0x92, 0x9c, 0x5d, 0xae, 0xfc, 0x27, 0x08, 0x1a, 0xdf, 0x76, 0x7e, 0x6f, 0xde, 0x9b, 0xc7, 0x37,
	0xef, 0xfd, 0xe6, 0xcd, 0x10, 0x0a, 0xc6, 0x20, 0x20, 0x14, 0xfb, 0x5b, 0x9e, 0xef, 0x52, 0x17,
	0x65, 0xc3, 0xe1, 0xfa, 0x8d, 0x13, 0xd7, 0x3d, 0x19, 0xe0, 0x6d, 0xdd, 0xb3, 0xb6, 0x75, 0xc7,
	0x71, 0xa9, 0x4e, 0x2d, 0xd7, 0x21, 0x62, 0xda, 0x7a, 0xe3, 0xc4, 0xa2, 0xa7, 0xc1, 0xd1, 0x96,
	0xe1, 0xda, 0xdb, 0x1e, 0x76, 0x88, 0xee, 0x98, 0xee, 0x36, 0xf9, 0x6c, 0xfb, 0x1c, 0x3b, 0x96,
	0x81, 0xb7, 0x03, 0x6a, 0x0d, 0x08, 0x53, 0x3d, 0xc1, 0x8e, 0xac, 0xbd, 0x6d, 0x39, 0xc6, 0x20,
	0x30, 0xf1, 0xd8, 0x8c, 0x2a, 0x99, 0x39, 0x71, 0x4f, 0xdc, 0x6d, 0x0e, 0x1f, 0x05, 0xc7, 0x7c,
	0xc4, 0x07, 0xfc, 0x2b, 0x9c, 0xfe, 0xce, 0x15, 0xab, 0x32, 0x1f, 0x6d, 0x4c, 0x75, 0x31, 0x4d,
	0xf9, 0x5d, 0x1a, 0xb2, 0xb5, 0xfd, 0x83, 0xa6, 0x73, 0xec, 0xa2, 0xfb, 0x30, 0xdf, 0xf3, 0x30,
	0x36, 0x4b, 0xa9, 0x5b, 0xa9, 0xcd, 0x9c, 0xb6, 0x32, 0x1a, 0x56, 0x96, 0x08, 0x03, 0xee, 0xb8,
	0xb6, 0x45, 0xb1, 0xed, 0xd1, 0x8b, 0x6e, 0x1c, 0x40, 0x75, 0x80, 0x4e, 0x60, 0xf7, 0x5c, 0xe3,
	0x0c, 0x53, 0x52, 0x4a, 0xdf, 0x4a, 0x6d, 0xce, 0x6b, 0xe5, 0xd1, 0xb0, 0x72, 0xdd, 0x09, 0x6c,
	0x95, 0x08, 0x58, 0xd2, 0x4f, 0x86, 0xd1, 0xcf, 0x61, 0xb1, 0x13, 0xd8, 0x35, 0xd7, 0xc7, 0xa4,
	0x94, 0xe1, 0x36, 0xde, 0x1a, 0x0d, 0x2b, 0x2b, 0x6c, 0xb2, 0xc1, 0x40, 0xc9, 0x42, 0x12, 0x18,
	0x7a, 0xd1, 0x3f, 0xf5, 0xb1, 0x6e, 0x92, 0xd2, 0x5c, 0xd4, 0x0b, 0x2a, 0xe0, 0xb8, 0x17, 0x33,
	0xb0, 0xf2, 0x25, 0x0b, 0x86, 0xd8, 0x53, 0xf4, 0x1e, 0xa4, 0xfa, 0x3c, 0x10, 0xf9, 0x7b, 0x85,
	0x2d, 0xdd, 0xb3, 0xb6, 0xfa, 0x17, 0x1e, 0x6e, 0x63, 0xaa, 0x6b, 0x2b, 0x5f, 0x0f, 0x2b, 0x6f,
	0x7c, 0x33, 0xac, 0xa4, 0x46, 0xc3, 0x4a, 0xf6, 0x8e, 0xe5, 0x0c, 0x2c, 0x07, 0x77, 0xc7, 0x1f,
	0xe8, 0x01, 0xa4, 0xf6, 0x78, 0x18, 0xf2, 0xf7, 0x96, 0xb8, 0xde, 0xde, 0xd1, 0x6f, 0xb0, 0x41,
	0xb9, 0xe6, 0xba, 0xa4, 0xf9, 0x26, 0xdb, 0x04, 0xc9, 0xa5, 0xd8, 0x18, 0x3d, 0x82, 0xb9, 0x9e,
	0x87, 0x0d, 0x1e, 0x8d, 0xfc, 0xbd, 0xd5, 0xad, 0x71, 0xea, 0x85, 0xfe, 0x31, 0x99, 0xb6, 0xc6,
	0xec, 0x31, 0x5b, 0xc4, 0xc3, 0x86, 0x6c, 0x2b, 0x3a, 0x46, 0x5d, 0x58, 0xe8, 0x51, 0x9d, 0x06,
	0x22, 0x32, 0xf9, 0x7b, 0x6b, 0x33, 0xd6, 0xb8, 0x54, 0x2b, 0x85, 0xf6, 0x8a, 0x84, 0x8f, 0x25,
	0x8b, 0x33, 0xc8, 0x07, 0x85, 0x6f, 0xbf, 0x28, 0xe7, 0xd6, 0xc7, 0x25, 0xa0, 0xfc, 0x35, 0x05,
	0x6f, 0x87, 0xc6, 0xaa, 0x01, 0x3d, 0xd5, 0x5c, 0x97, 0x12, 0xea, 0xeb, 0x5e, 0x17, 0x7f, 0x1a,
	0x60, 0x42, 0x7f, 0xe8, 0x70, 0xc6, 0xdd, 0xfd, 0x4b, 0x06, 0xf2, 0x52, 0x24, 0xd1, 0x2e, 0xe4,
	0x3f, 0x0a, 0x5c, 0x3f, 0xb0, 0x3b, 0xae, 0x89, 0x49, 0x29, 0x75, 0x2b, 0xb3, 0x99, 0xd3, 0x36,
	0xfe, 0x75, 0x59, 0x66, 0xe1, 0x58, 0xfb, 0x94, 0x8b, 0x54, 0x87, 0xc9, 0xa4, 0x35, 0xae, 0xc0,
	0x51, 0x03, 0x72, 0x87, 0x96, 0x4f, 0x03, 0x7d, 0xd0, 0xdc, 0xe7, 0xbe, 0xe7, 0xb4, 0x1b, 0xa1,
	0xa9, 0xd5, 0x73, 0x21, 0x50, 0x2d, 0x4f, 0x32, 0x94, 0x88, 0xa2, 0x1d, 0x80, 0x4e, 0x7f, 0xbf,
	0x87, 0xfd, 0x73, 0xec, 0xb3, 0xaa, 0x60, 0x2e, 0xdd, 0x0c, 0xed, 0x5c, 0x77, 0xa8, 0xa7, 0x12,
	0x21, 0x8a, 0xe4, 0x75, 0x12, 0x8c, 0x3e, 0x84, 0x42, 0x35, 0xa0, 0x6e, 0xd5, 0xb4, 0x2d, 0xda,
	0x69, 0xd6, 0x44, 0x1a, 0x2c, 0x8a, 0x02, 0xd7, 0x03, 0xea, 0xaa, 0x3a, 0x93, 0xa8, 0x8e, 0x65,
	0x90, 0x6e, 0x1c, 0x60, 0xac, 0x50, 0xc3, 0x3e, 0x25, 0xa5, 0xf9, 0x29, 0x2b, 0x18, 0x0c, 0x90,
	0x59, 0x21, 0x06, 0xa0, 0xf7, 0x21, 0xb3, 0x8b, 0x2f, 0x4a, 0x0b, 0x5c, 0xe5, 0xe6, 0x57, 0x97,
	0xe5, 0xc5, 0x1e, 0x36, 0x7c, 0x4c, 0x37, 0x6f, 0x8f, 0x86, 0x95, 0xc2, 0x19, 0xbe, 0x90, 0x94,
	0xa3, 0x43, 0xe5, 0x0f, 0x69, 0x28, 0x44, 0xd2, 0x12, 0xbd, 0x07, 0x0b, 0x2d, 0xac, 0x9b, 0xd8,
	0x0f, 0x89, 0x69, 0x95, 0xa5, 0xe8, 0x80, 0x23, 0x72, 0x8a, 0xc6, 0x11, 0xf4, 0xdb, 0x14, 0x94,
	0x5a, 0x3a, 0xa1, 0x42, 0xb9, 0xef, 0xeb, 0x0e, 0xb1, 0x18, 0xb5, 0xf6, 0x2d, 0x1b, 0x87, 0x39,
	0xf5, 0xa6, 0xc8, 0x45, 0xcb, 0xc6, 0x84, 0xea, 0xb6, 0xa7, 0x31, 0xf7, 0xde, 0x19, 0xe8, 0x84,
	0xaa, 0xc2, 0x9a, 0x4a, 0x27, 0x5a, 0x2a, 0xb5, 0x6c, 0x2c, 0xad, 0xf7, 0x72, 0xd3, 0x90, 0x06,
	0xc5, 0x48, 0x41, 0x78, 0xd8, 0xe4, 0x35, 0xbd, 0xa8, 0x5d, 0x1f, 0x0d, 0x2b, 0xcb, 0x7a, 0x40,
	0x4f, 0xd5, 0x23, 0x49, 0xd8, 0x9d, 0x85, 0x94, 0x4f, 0x00, 0xea, 0x8c, 0x32, 0x7d, 0x4e, 0xd3,
	0x6d, 0x28, 0x88, 0xd1, 0x21, 0xf6, 0x89, 0xe5, 0x3a, 0x61, 0x54, 0x6e, 0x8c, 0x86, 0x95, 0x92,
	0xc9, 0x05, 0xea, 0xb9, 0x90, 0x48, 0xde, 0x5e, 0x29, 0x51, 0xfe, 0x96, 0x86, 0xb9, 0x1d, 0xf7,
	0x87, 0x2f, 0x51, 0xf4, 0x30, 0xc2, 0x78, 0xcb, 0x13, 0x8e, 0x62, 0xce, 0xbd, 0x12, 0xdd, 0xed,
	0xc5, 0xe8, 0x6e, 0x25, 0x6a, 0xea, 0xd5, 0xb9, 0x2e, 0xff, 0xed, 0x17, 0xe5, 0x2c, 0x9a, 0x3f,
	0x75, 0x09, 0x25, 0xca, 0x31, 0x2c, 0x8e, 0x3d, 0x42, 0x1f, 0x43, 0xae, 0x67, 0xeb, 0xbe, 0x28,
	0x2a, 0x46, 0x1a, 0xf2, 0x62, 0x63, 0x49, 0xb3, 0xae, 0xdd, 0x08, 0x17, 0x5b, 0x25, 0x0c, 0xe3,
	0x75, 0x25, 0x97, 0x7f, 0x12, 0xaa, 0x58, 0x00, 0x53, 0x77, 0xd1, 0x27, 0xb0, 0xcc, 0xcb, 0x97,
	0x62, 0x33, 0xba, 0x62, 0x4e, 0xfb, 0xd1, 0x68, 0x58, 0xb9, 0xa9, 0x87, 0x42, 0x35, 0x71, 0x85,
	0xe7, 0x8b, 0x95, 0xff, 0xa6, 0xa1, 0xd0, 0x74, 0x28, 0xf6, 0x8f, 0x75, 0x03, 0xf3, 0x1c, 0xbb,
	0x0b, 0x73, 0x1d, 0xdd, 0xc6, 0x61, 0x6a, 0x21, 0x16, 0x74, 0x47, 0x8f, 0xa4, 0x7f, 0x6c, 0xcc,
	0x34, 0x58, 0xbe, 0x84, 0x7c, 0xc7, 0x35, 0xe8, 0x85, 0x17, 0xd1, 0x88, 0x8e, 0x59, 0x59, 0x1f,
	0x62, 0xc7, 0x74, 0x7d, 0xbe, 0xe3, 0x61, 0x59, 0x9f, 0x73, 0x44, 0xde, 0x8d, 0x38, 0x82, 0xaa,
	0x90, 0x6b, 0x59, 0xce, 0x99, 0x68, 0x55, 0xe6, 0xb8, 0x6a, 0x89, 0xc5, 0x76, 0x60, 0x39, 0x67,
	0x6a, 0xbc, 0x5f, 0x49, 0x44, 0xd1, 0x47, 0x90, 0x6d, 0xeb, 0x46, 0xd5, 0x34, 0xfd, 0x90, 0xd5,
	0xee, 0x3c, 0xbd, 0x2c, 0xa3, 0x06, 0x93, 0xed, 0xf9, 0x9b, 0xa1, 0x68, 0xf3, 0x36, 0x63, 0x03,
	0x64, 0xeb, 0x86, 0xaa, 0x9b, 0xa6, 0xec, 0x53, 0x02, 0x86, 0x3e, 0x84, 0x6c, 0xd3, 0x63, 0x6a,
	0xa4, 0xb4, 0xc0, 0xb7, 0x65, 0x8d, 0x29, 0x5b, 0x1e, 0x9f, 0x27, 0xef, 0x45, 0x02, 0xa6, 0xfc,
	0x23, 0x05, 0xd9, 0x36, 0xb6, 0x79, 0xe8, 0x5b, 0x61, 0x20, 0x45, 0xe8, 0xb7, 0x9e, 0x5e, 0x96,
	0x4b, 0x3d, 0xea, 0x37, 0x9c, 0xc0, 0xde, 0x0c, 0xa7, 0x6c, 0xb5, 0xb1, 0xcd, 0xa6, 0xdc, 0x7e,
	0x89, 0x20, 0xdf, 0x85, 0xb9, 0x9e, 0xf5, 0x79, 0x64, 0x5b, 0x88, 0xf5, 0x79, 0x44, 0x23, 0x3a,
	0x56, 0x36, 0xb9, 0x2b, 0xcc, 0x3e, 0xca, 0x43, 0xf6, 0xa0, 0xb3, 0xdb, 0xd9, 0xfb, 0x65, 0xa7,
	0xf8, 0x06, 0xca, 0x42, 0x66, 0x47, 0x6b, 0x17, 0x53, 0xec, 0xa3, 0x5e, 0xef, 0x16, 0xd3, 0x8a,
	0x0d, 0xf9, 0x0e, 0xa6, 0x9f, 0xb9, 0xfe, 0x19, 0x77, 0xfc, 0x09, 0xc0, 0x24, 0x89, 0xc6, 0xd5,
	0x30, 0xed, 0x34, 0x22, 0xf9, 0x35, 0x2d, 0x08, 0x6b, 0xa2, 0x21, 0x6f, 0x5a, 0x12, 0xca, 0x89,
	0x8a, 0x1d, 0xcf, 0xaf, 0x2d, 0x51, 0x31, 0xe7, 0xbe, 0x27, 0xa2, 0xe2, 0xa6, 0xbe, 0x33, 0x51,
	0xf1, 0x86, 0x44, 0xf9, 0x2a, 0x03, 0x05, 0x66, 0xa7, 0xe6, 0x3a, 0x26, 0x3f, 0x9a, 0xd0, 0xaf,
	0x22, 0xa9, 0xf5, 0xc1, 0xd3, 0xcb, 0xf2, 0x8f, 0xc7, 0xa9, 0x15, 0x99, 0xb8, 0x35, 0xf9, 0x7a,
	0xd9, 0x34, 0x9b, 0x76, 0x98, 0x22, 0xd1, 0xee, 0xca, 0x69, 0x3b, 0xb1, 0x26, 0xa6, 0xdc, 0x7e,
	0xb9, 0x1f, 0x83, 0x9e, 0x00, 0x62, 0xa7, 0x77, 0xec, 0xdc, 0x16, 0x5c, 0xa1, 0x8c, 0x86, 0x95,
	0x0d, 0x7e, 0x00, 0x5f, 0x7d, 0x40, 0xbf, 0x40, 0xce, 0xf8, 0xa7, 0x8b, 0x75, 0xe2, 0x3a, 0x21,
	0x89, 0x70, 0xfe, 0xf1, 0x39, 0x22, 0xfb, 0x15, 0x47, 0xd0, 0xfb, 0xac, 0x40, 0x08, 0xd1, 0x4f,
	0x70, 0x48, 0x1e, 0xfc, 0x20, 0xb7, 0x05, 0x24, 0x69, 0xce, 0x42, 0xca, 0x26, 0x14, 0x22, 0xa1,
	0x45, 0x00, 0x0b, 0xad, 0x46, 0xb5, 0xde, 0xe8, 0x16, 0xdf, 0x60, 0xd5, 0xb6, 0xd3, 0xa8, 0xb6,
	0xfa, 0x3b, 0x8f, 0x8b, 0x29, 0xe5, 0xcf, 0x73, 0xb0, 0xc8, 0xf6, 0x84, 0x57, 0x56, 0x13, 0x16,
	0xf6, 0x08, 0xfb, 0x0a, 0xb3, 0x7e, 0x69, 0x92, 0x27, 0x02, 0x16, 0x1e, 0xb8, 0x44, 0xb5, 0x9c,
	0x63, 0x57, 0xf6, 0x60, 0x06, 0x42, 0x8f, 0xe5, 0x56, 0x22, 0x2c, 0x86, 0x69, 0xda, 0x4d, 0x45,
	0xe2, 0xf6, 0x14, 0x36, 0x0d, 0x31, 0xb3, 0xc9, 0x30, 0x6a, 0x43, 0xb6, 0xe6, 0x05, 0xdc, 0xae,
	0xa8, 0x8c, 0xe2, 0xf4, 0x9a, 0x21, 0x6e, 0x98, 0x82, 0x13, 0x0d, 0x2f, 0x88, 0x5b, 0x4c, 0xc0,
	0xd0, 0x21, 0x40, 0x1b, 0xdb, 0xae, 0x7f, 0xc1, 0x2d, 0xce, 0xc5, 0x2c, 0x86, 0x54, 0x28, 0xdc,
	0xb4, 0xf9, 0xbc, 0x19, 0x37, 0x13, 0x61, 0xf4, 0x6b, 0xc8, 0xf7, 0xa8, 0xeb, 0xeb, 0x27, 0x3c,
	0xb6, 0x7c, 0x0b, 0xe5, 0xfb, 0x95, 0x24, 0xd3, 0xd6, 0x59, 0xf3, 0x4f, 0x04, 0x10, 0xb7, 0x7e,
	0x05, 0xce, 0xcc, 0x4b, 0xa4, 0xc8, 0x3b, 0x60, 0xd9, 0xbc, 0x24, 0x13, 0xe6, 0x1d, 0x01, 0xcc,
	0x98, 0x4f, 0xc6, 0x15, 0x10, 0x69, 0xc1, 0x68, 0x46, 0xf9, 0x67, 0x1a, 0x60, 0x4a, 0x14, 0xa8,
	0x0f, 0xf3, 0xfb, 0xa7, 0x3a, 0x19, 0x97, 0xf7, 0x4f, 0x9e, 0x5e, 0x96, 0x6f, 0xca, 0xe5, 0x2d,
	0xa6, 0x71, 0x6a, 0xe1, 0xf3, 0x58, 0x1d, 0x2e, 0x79, 0xec, 0x4b, 0xee, 0xe4, 0x63, 0x00, 0xab,
	0x12, 0x71, 0x33, 0xe2, 0xc9, 0xb2, 0x28, 0xaa, 0x44, 0x5c, 0x7c, 0xe4, 0x2a, 0x89, 0x23, 0xec,
	0x34, 0x98, 0xa4, 0xba, 0xb8, 0xbd, 0xc8, 0xa7, 0x41, 0x84, 0x6e, 0xa6, 0xa7, 0x81, 0x31, 0xd1,
	0x90, 0x4f, 0x83, 0x24, 0x54, 0xf9, 0x19, 0xe4, 0x26, 0xbf, 0x24, 0x7a, 0x50, 0xe5, 0x21, 0xbb,
	0xdf, 0xe8, 0xd4, 0x9b, 0x9d, 0x87, 0xc5, 0x14, 0x2b, 0xb0, 0x47, 0x7b, 0xcd, 0x4e, 0xa3, 0x5e,
	0x4c, 0xb3, 0xef, 0x07, 0xd5, 0x66, 0xab, 0x51, 0x2f, 0x66, 0x94, 0x3f, 0xa6, 0xc7, 0x35, 0x95,
	0xd4, 0xeb, 0xbc, 0x80, 0xed, 0x76, 0xa1, 0xb0, 0x8b, 0x7d, 0x07, 0x0f, 0xba, 0x78, 0x80, 0x59,
	0xc4, 0x05, 0xe9, 0xbd, 0x3d, 0x1a, 0x56, 0xde, 0x3a, 0xe3, 0x02, 0xd5, 0xc7, 0x83, 0x68, 0x60,
	0xaf, 0x12, 0xa0, 0x87, 0x90, 0x1d, 0x37, 0xf2, 0x99, 0x69, 0x23, 0x1f, 0xce, 0x4e, 0x68, 0xe4,
	0xaf, 0x92, 0xa0, 0x5f, 0x40, 0x6e, 0xdf, 0x77, 0x0d, 0x4c, 0x88, 0xeb, 0x87, 0x94, 0xc6, 0x1f,
	0x51, 0xbc, 0x31, 0x28, 0x3f, 0xa2, 0x24, 0x80, 0xca, 0x9f, 0x52, 0x00, 0xd3, 0xa6, 0x15, 0xbd,
	0x0b, 0xe9, 0x66, 0x3d, 0x8c, 0x4a, 0x71, 0x34, 0xac, 0x5c, 0xb3, 0xe4, 0xc6, 0x2a, 0x32, 0x42,
	0x1f, 0x03, 0xb4, 0xab, 0x35, 0xd6, 0xfe, 0x60, 0x32, 0x3e, 0x03, 0xb6, 0xaf, 0xec, 0xa9, 0xae,
	0x8f, 0xfb, 0x27, 0x4c, 0x22, 0xb7, 0xd7, 0x44, 0x58, 0xf9, 0x77, 0x06, 0x96, 0xc3, 0xaa, 0xac,
	0xe3, 0x73, 0x2b, 0xec, 0x50, 0xeb, 0x70, 0xad, 0x87, 0x7d, 0x4b, 0x1f, 0x74, 0x02, 0xfb, 0x68,
	0x72, 0x35, 0xe4, 0x8d, 0x20, 0xe1, 0xb8, 0xea, 0x44, 0x32, 0x34, 0x11, 0xfd, 0x3f, 0x76, 0xad,
	0x3f, 0x85, 0xc5, 0x9a, 0xee, 0xe9, 0x86, 0x45, 0x2f, 0xc2, 0xcd, 0x11, 0x64, 0x18, 0x62, 0x11,
	0x32, 0x9c, 0xc1, 0xd0, 0x13, 0x58, 0x65, 0x7e, 0x56, 0xf7, 0xb1, 0x6f, 0x60, 0x87, 0xb6, 0xac,
	0x63, 0x7c, 0x40, 0xb0, 0xc9, 0xd9, 0x6b, 0x5e, 0xdc, 0x00, 0x3c, 0x21, 0x52, 0x07, 0xd6, 0x31,
	0x56, 0x03, 0x82, 0x4d, 0xb5, 0x2a, 0xdf, 0x00, 0x9e, 0x2b, 0x1e, 0xdb, 0xd7, 0xe2, 0xf6, 0x17,
	0x9e, 0x67, 0x5f, 0x7b, 0xbe, 0x7d, 0x49, 0xac, 0x9c, 0x46, 0x48, 0x17, 0x3d, 0x86, 0xac, 0xd8,
	0xca, 0x71, 0x9f, 0xb8, 0x1e, 0xe7, 0xdf, 0xe9, 0x4e, 0x6b, 0xe5, 0x90, 0x1d, 0x96, 0x4d, 0xa1,
	0x22, 0x1f, 0x70, 0x33, 0x90, 0xf2, 0xfb, 0x34, 0xac, 0x1d, 0x78, 0xa6, 0x4e, 0x71, 0xbf, 0xd5,
	0xab, 0xb9, 0xce, 0xb1, 0x75, 0xf2, 0x9a, 0xbc, 0x41, 0x4d, 0x5f, 0x52, 0x32, 0xaf, 0xf0, 0x92,
	0xa2, 0x8a, 0x97, 0x14, 0x91, 0x32, 0xcb, 0x2f, 0x7a, 0x3d, 0x89, 0xbf, 0x73, 0x7d, 0x99, 0x9e,
	0xb0, 0xcb, 0x6b, 0xfb, 0xa2, 0x19, 0xfa, 0xf7, 0x3d, 0xbd, 0x68, 0x8e, 0xad, 0x7d, 0xe7, 0x17,
	0xcd, 0x90, 0x58, 0x95, 0x02, 0xe4, 0x25, 0xcf, 0x94, 0xbf, 0xa7, 0xa1, 0x10, 0xb1, 0x8d, 0x1e,
	0xc1, 0x35, 0x2d, 0xb0, 0x06, 0x66, 0xf4, 0x19, 0x86, 0x1f, 0x02, 0x47, 0x0c, 0x4f, 0x20, 0xef,
	0xab, 0x04, 0xec, 0x4e, 0x7b, 0x58, 0xeb, 0xd5, 0x5c, 0xdb, 0xb6, 0x68, 0x48, 0x46, 0x9c, 0xca,
	0xce, 0x0d, 0xa2, 0x1a, 0x1c, 0x8d, 0x3c, 0x17, 0x26, 0xa0, 0xcc, 0x04, 0x77, 0xa7, 0xae, 0xd3,
	0x71, 0x97, 0xcc, 0x4d, 0x88, 0x25, 0x59, 0x41, 0xc8, 0x26, 0x92, 0x50, 0xd4, 0x86, 0x95, 0xae,
	0x3b, 0x18, 0xb8, 0x01, 0x8d, 0xfc, 0x30, 0x91, 0x7b, 0xbc, 0xd3, 0xf2, 0x85, 0x58, 0x8d, 0xfc,
	0x8e, 0x6e, 0x32, 0xfc, 0xee, 0x7d, 0x58, 0x8a, 0xb5, 0xfe, 0xd1, 0x83, 0x7a, 0x11, 0xe6, 0xfa,
	0xdd, 0x83, 0x46, 0x31, 0x85, 0x72, 0x30, 0xff, 0xa0, 0xda, 0xea, 0x35, 0x8a, 0x69, 0xed, 0xda,
	0xd7, 0xcf, 0x36, 0x52, 0xdf, 0x3c, 0xdb, 0x48, 0xfd, 0xe7, 0xd9, 0x46, 0x6a, 0x3f, 0x75, 0xb4,
	0xc0, 0xff, 0xa7, 0xb8, 0xff, 0xbf, 0x00, 0x00, 0x00, 0xff, 0xff, 0x0b, 0x15, 0x3d, 0x6b, 0x7c,
	0x19, 0x00, 0x00,
}
