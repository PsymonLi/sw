// Code generated by protoc-gen-grpc-pensando DO NOT EDIT.

package grpcclient

import (
	"context"
	"errors"
	oldlog "log"
	"net/http"

	"github.com/go-kit/kit/endpoint"
	grpctransport "github.com/go-kit/kit/transport/grpc"
	"google.golang.org/grpc"

	api "github.com/pensando/sw/api"
	cluster "github.com/pensando/sw/api/generated/cluster"
	"github.com/pensando/sw/api/interfaces"
	listerwatcher "github.com/pensando/sw/api/listerwatcher"
	"github.com/pensando/sw/venice/utils/kvstore"
	"github.com/pensando/sw/venice/utils/log"
	"github.com/pensando/sw/venice/utils/trace"
)

// Dummy vars to suppress import errors
var _ api.TypeMeta
var _ listerwatcher.WatcherClient
var _ kvstore.Interface

// NewClusterV1 sets up a new client for ClusterV1
func NewClusterV1(conn *grpc.ClientConn, logger log.Logger) cluster.ServiceClusterV1Client {

	var lAuthBootstrapCompleteEndpoint endpoint.Endpoint
	{
		lAuthBootstrapCompleteEndpoint = grpctransport.NewClient(
			conn,
			"cluster.ClusterV1",
			"AuthBootstrapComplete",
			cluster.EncodeGrpcReqClusterAuthBootstrapRequest,
			cluster.DecodeGrpcRespCluster,
			&cluster.Cluster{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAuthBootstrapCompleteEndpoint = trace.ClientEndPoint("ClusterV1:AuthBootstrapComplete")(lAuthBootstrapCompleteEndpoint)
	}
	var lAutoAddClusterEndpoint endpoint.Endpoint
	{
		lAutoAddClusterEndpoint = grpctransport.NewClient(
			conn,
			"cluster.ClusterV1",
			"AutoAddCluster",
			cluster.EncodeGrpcReqCluster,
			cluster.DecodeGrpcRespCluster,
			&cluster.Cluster{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoAddClusterEndpoint = trace.ClientEndPoint("ClusterV1:AutoAddCluster")(lAutoAddClusterEndpoint)
	}
	var lAutoAddDistributedServiceCardEndpoint endpoint.Endpoint
	{
		lAutoAddDistributedServiceCardEndpoint = grpctransport.NewClient(
			conn,
			"cluster.ClusterV1",
			"AutoAddDistributedServiceCard",
			cluster.EncodeGrpcReqDistributedServiceCard,
			cluster.DecodeGrpcRespDistributedServiceCard,
			&cluster.DistributedServiceCard{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoAddDistributedServiceCardEndpoint = trace.ClientEndPoint("ClusterV1:AutoAddDistributedServiceCard")(lAutoAddDistributedServiceCardEndpoint)
	}
	var lAutoAddHostEndpoint endpoint.Endpoint
	{
		lAutoAddHostEndpoint = grpctransport.NewClient(
			conn,
			"cluster.ClusterV1",
			"AutoAddHost",
			cluster.EncodeGrpcReqHost,
			cluster.DecodeGrpcRespHost,
			&cluster.Host{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoAddHostEndpoint = trace.ClientEndPoint("ClusterV1:AutoAddHost")(lAutoAddHostEndpoint)
	}
	var lAutoAddNodeEndpoint endpoint.Endpoint
	{
		lAutoAddNodeEndpoint = grpctransport.NewClient(
			conn,
			"cluster.ClusterV1",
			"AutoAddNode",
			cluster.EncodeGrpcReqNode,
			cluster.DecodeGrpcRespNode,
			&cluster.Node{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoAddNodeEndpoint = trace.ClientEndPoint("ClusterV1:AutoAddNode")(lAutoAddNodeEndpoint)
	}
	var lAutoAddTenantEndpoint endpoint.Endpoint
	{
		lAutoAddTenantEndpoint = grpctransport.NewClient(
			conn,
			"cluster.ClusterV1",
			"AutoAddTenant",
			cluster.EncodeGrpcReqTenant,
			cluster.DecodeGrpcRespTenant,
			&cluster.Tenant{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoAddTenantEndpoint = trace.ClientEndPoint("ClusterV1:AutoAddTenant")(lAutoAddTenantEndpoint)
	}
	var lAutoAddVersionEndpoint endpoint.Endpoint
	{
		lAutoAddVersionEndpoint = grpctransport.NewClient(
			conn,
			"cluster.ClusterV1",
			"AutoAddVersion",
			cluster.EncodeGrpcReqVersion,
			cluster.DecodeGrpcRespVersion,
			&cluster.Version{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoAddVersionEndpoint = trace.ClientEndPoint("ClusterV1:AutoAddVersion")(lAutoAddVersionEndpoint)
	}
	var lAutoDeleteClusterEndpoint endpoint.Endpoint
	{
		lAutoDeleteClusterEndpoint = grpctransport.NewClient(
			conn,
			"cluster.ClusterV1",
			"AutoDeleteCluster",
			cluster.EncodeGrpcReqCluster,
			cluster.DecodeGrpcRespCluster,
			&cluster.Cluster{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoDeleteClusterEndpoint = trace.ClientEndPoint("ClusterV1:AutoDeleteCluster")(lAutoDeleteClusterEndpoint)
	}
	var lAutoDeleteDistributedServiceCardEndpoint endpoint.Endpoint
	{
		lAutoDeleteDistributedServiceCardEndpoint = grpctransport.NewClient(
			conn,
			"cluster.ClusterV1",
			"AutoDeleteDistributedServiceCard",
			cluster.EncodeGrpcReqDistributedServiceCard,
			cluster.DecodeGrpcRespDistributedServiceCard,
			&cluster.DistributedServiceCard{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoDeleteDistributedServiceCardEndpoint = trace.ClientEndPoint("ClusterV1:AutoDeleteDistributedServiceCard")(lAutoDeleteDistributedServiceCardEndpoint)
	}
	var lAutoDeleteHostEndpoint endpoint.Endpoint
	{
		lAutoDeleteHostEndpoint = grpctransport.NewClient(
			conn,
			"cluster.ClusterV1",
			"AutoDeleteHost",
			cluster.EncodeGrpcReqHost,
			cluster.DecodeGrpcRespHost,
			&cluster.Host{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoDeleteHostEndpoint = trace.ClientEndPoint("ClusterV1:AutoDeleteHost")(lAutoDeleteHostEndpoint)
	}
	var lAutoDeleteNodeEndpoint endpoint.Endpoint
	{
		lAutoDeleteNodeEndpoint = grpctransport.NewClient(
			conn,
			"cluster.ClusterV1",
			"AutoDeleteNode",
			cluster.EncodeGrpcReqNode,
			cluster.DecodeGrpcRespNode,
			&cluster.Node{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoDeleteNodeEndpoint = trace.ClientEndPoint("ClusterV1:AutoDeleteNode")(lAutoDeleteNodeEndpoint)
	}
	var lAutoDeleteTenantEndpoint endpoint.Endpoint
	{
		lAutoDeleteTenantEndpoint = grpctransport.NewClient(
			conn,
			"cluster.ClusterV1",
			"AutoDeleteTenant",
			cluster.EncodeGrpcReqTenant,
			cluster.DecodeGrpcRespTenant,
			&cluster.Tenant{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoDeleteTenantEndpoint = trace.ClientEndPoint("ClusterV1:AutoDeleteTenant")(lAutoDeleteTenantEndpoint)
	}
	var lAutoDeleteVersionEndpoint endpoint.Endpoint
	{
		lAutoDeleteVersionEndpoint = grpctransport.NewClient(
			conn,
			"cluster.ClusterV1",
			"AutoDeleteVersion",
			cluster.EncodeGrpcReqVersion,
			cluster.DecodeGrpcRespVersion,
			&cluster.Version{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoDeleteVersionEndpoint = trace.ClientEndPoint("ClusterV1:AutoDeleteVersion")(lAutoDeleteVersionEndpoint)
	}
	var lAutoGetClusterEndpoint endpoint.Endpoint
	{
		lAutoGetClusterEndpoint = grpctransport.NewClient(
			conn,
			"cluster.ClusterV1",
			"AutoGetCluster",
			cluster.EncodeGrpcReqCluster,
			cluster.DecodeGrpcRespCluster,
			&cluster.Cluster{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoGetClusterEndpoint = trace.ClientEndPoint("ClusterV1:AutoGetCluster")(lAutoGetClusterEndpoint)
	}
	var lAutoGetDistributedServiceCardEndpoint endpoint.Endpoint
	{
		lAutoGetDistributedServiceCardEndpoint = grpctransport.NewClient(
			conn,
			"cluster.ClusterV1",
			"AutoGetDistributedServiceCard",
			cluster.EncodeGrpcReqDistributedServiceCard,
			cluster.DecodeGrpcRespDistributedServiceCard,
			&cluster.DistributedServiceCard{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoGetDistributedServiceCardEndpoint = trace.ClientEndPoint("ClusterV1:AutoGetDistributedServiceCard")(lAutoGetDistributedServiceCardEndpoint)
	}
	var lAutoGetHostEndpoint endpoint.Endpoint
	{
		lAutoGetHostEndpoint = grpctransport.NewClient(
			conn,
			"cluster.ClusterV1",
			"AutoGetHost",
			cluster.EncodeGrpcReqHost,
			cluster.DecodeGrpcRespHost,
			&cluster.Host{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoGetHostEndpoint = trace.ClientEndPoint("ClusterV1:AutoGetHost")(lAutoGetHostEndpoint)
	}
	var lAutoGetNodeEndpoint endpoint.Endpoint
	{
		lAutoGetNodeEndpoint = grpctransport.NewClient(
			conn,
			"cluster.ClusterV1",
			"AutoGetNode",
			cluster.EncodeGrpcReqNode,
			cluster.DecodeGrpcRespNode,
			&cluster.Node{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoGetNodeEndpoint = trace.ClientEndPoint("ClusterV1:AutoGetNode")(lAutoGetNodeEndpoint)
	}
	var lAutoGetTenantEndpoint endpoint.Endpoint
	{
		lAutoGetTenantEndpoint = grpctransport.NewClient(
			conn,
			"cluster.ClusterV1",
			"AutoGetTenant",
			cluster.EncodeGrpcReqTenant,
			cluster.DecodeGrpcRespTenant,
			&cluster.Tenant{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoGetTenantEndpoint = trace.ClientEndPoint("ClusterV1:AutoGetTenant")(lAutoGetTenantEndpoint)
	}
	var lAutoGetVersionEndpoint endpoint.Endpoint
	{
		lAutoGetVersionEndpoint = grpctransport.NewClient(
			conn,
			"cluster.ClusterV1",
			"AutoGetVersion",
			cluster.EncodeGrpcReqVersion,
			cluster.DecodeGrpcRespVersion,
			&cluster.Version{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoGetVersionEndpoint = trace.ClientEndPoint("ClusterV1:AutoGetVersion")(lAutoGetVersionEndpoint)
	}
	var lAutoListClusterEndpoint endpoint.Endpoint
	{
		lAutoListClusterEndpoint = grpctransport.NewClient(
			conn,
			"cluster.ClusterV1",
			"AutoListCluster",
			cluster.EncodeGrpcReqListWatchOptions,
			cluster.DecodeGrpcRespClusterList,
			&cluster.ClusterList{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoListClusterEndpoint = trace.ClientEndPoint("ClusterV1:AutoListCluster")(lAutoListClusterEndpoint)
	}
	var lAutoListDistributedServiceCardEndpoint endpoint.Endpoint
	{
		lAutoListDistributedServiceCardEndpoint = grpctransport.NewClient(
			conn,
			"cluster.ClusterV1",
			"AutoListDistributedServiceCard",
			cluster.EncodeGrpcReqListWatchOptions,
			cluster.DecodeGrpcRespDistributedServiceCardList,
			&cluster.DistributedServiceCardList{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoListDistributedServiceCardEndpoint = trace.ClientEndPoint("ClusterV1:AutoListDistributedServiceCard")(lAutoListDistributedServiceCardEndpoint)
	}
	var lAutoListHostEndpoint endpoint.Endpoint
	{
		lAutoListHostEndpoint = grpctransport.NewClient(
			conn,
			"cluster.ClusterV1",
			"AutoListHost",
			cluster.EncodeGrpcReqListWatchOptions,
			cluster.DecodeGrpcRespHostList,
			&cluster.HostList{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoListHostEndpoint = trace.ClientEndPoint("ClusterV1:AutoListHost")(lAutoListHostEndpoint)
	}
	var lAutoListNodeEndpoint endpoint.Endpoint
	{
		lAutoListNodeEndpoint = grpctransport.NewClient(
			conn,
			"cluster.ClusterV1",
			"AutoListNode",
			cluster.EncodeGrpcReqListWatchOptions,
			cluster.DecodeGrpcRespNodeList,
			&cluster.NodeList{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoListNodeEndpoint = trace.ClientEndPoint("ClusterV1:AutoListNode")(lAutoListNodeEndpoint)
	}
	var lAutoListTenantEndpoint endpoint.Endpoint
	{
		lAutoListTenantEndpoint = grpctransport.NewClient(
			conn,
			"cluster.ClusterV1",
			"AutoListTenant",
			cluster.EncodeGrpcReqListWatchOptions,
			cluster.DecodeGrpcRespTenantList,
			&cluster.TenantList{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoListTenantEndpoint = trace.ClientEndPoint("ClusterV1:AutoListTenant")(lAutoListTenantEndpoint)
	}
	var lAutoListVersionEndpoint endpoint.Endpoint
	{
		lAutoListVersionEndpoint = grpctransport.NewClient(
			conn,
			"cluster.ClusterV1",
			"AutoListVersion",
			cluster.EncodeGrpcReqListWatchOptions,
			cluster.DecodeGrpcRespVersionList,
			&cluster.VersionList{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoListVersionEndpoint = trace.ClientEndPoint("ClusterV1:AutoListVersion")(lAutoListVersionEndpoint)
	}
	var lAutoUpdateClusterEndpoint endpoint.Endpoint
	{
		lAutoUpdateClusterEndpoint = grpctransport.NewClient(
			conn,
			"cluster.ClusterV1",
			"AutoUpdateCluster",
			cluster.EncodeGrpcReqCluster,
			cluster.DecodeGrpcRespCluster,
			&cluster.Cluster{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoUpdateClusterEndpoint = trace.ClientEndPoint("ClusterV1:AutoUpdateCluster")(lAutoUpdateClusterEndpoint)
	}
	var lAutoUpdateDistributedServiceCardEndpoint endpoint.Endpoint
	{
		lAutoUpdateDistributedServiceCardEndpoint = grpctransport.NewClient(
			conn,
			"cluster.ClusterV1",
			"AutoUpdateDistributedServiceCard",
			cluster.EncodeGrpcReqDistributedServiceCard,
			cluster.DecodeGrpcRespDistributedServiceCard,
			&cluster.DistributedServiceCard{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoUpdateDistributedServiceCardEndpoint = trace.ClientEndPoint("ClusterV1:AutoUpdateDistributedServiceCard")(lAutoUpdateDistributedServiceCardEndpoint)
	}
	var lAutoUpdateHostEndpoint endpoint.Endpoint
	{
		lAutoUpdateHostEndpoint = grpctransport.NewClient(
			conn,
			"cluster.ClusterV1",
			"AutoUpdateHost",
			cluster.EncodeGrpcReqHost,
			cluster.DecodeGrpcRespHost,
			&cluster.Host{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoUpdateHostEndpoint = trace.ClientEndPoint("ClusterV1:AutoUpdateHost")(lAutoUpdateHostEndpoint)
	}
	var lAutoUpdateNodeEndpoint endpoint.Endpoint
	{
		lAutoUpdateNodeEndpoint = grpctransport.NewClient(
			conn,
			"cluster.ClusterV1",
			"AutoUpdateNode",
			cluster.EncodeGrpcReqNode,
			cluster.DecodeGrpcRespNode,
			&cluster.Node{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoUpdateNodeEndpoint = trace.ClientEndPoint("ClusterV1:AutoUpdateNode")(lAutoUpdateNodeEndpoint)
	}
	var lAutoUpdateTenantEndpoint endpoint.Endpoint
	{
		lAutoUpdateTenantEndpoint = grpctransport.NewClient(
			conn,
			"cluster.ClusterV1",
			"AutoUpdateTenant",
			cluster.EncodeGrpcReqTenant,
			cluster.DecodeGrpcRespTenant,
			&cluster.Tenant{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoUpdateTenantEndpoint = trace.ClientEndPoint("ClusterV1:AutoUpdateTenant")(lAutoUpdateTenantEndpoint)
	}
	var lAutoUpdateVersionEndpoint endpoint.Endpoint
	{
		lAutoUpdateVersionEndpoint = grpctransport.NewClient(
			conn,
			"cluster.ClusterV1",
			"AutoUpdateVersion",
			cluster.EncodeGrpcReqVersion,
			cluster.DecodeGrpcRespVersion,
			&cluster.Version{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoUpdateVersionEndpoint = trace.ClientEndPoint("ClusterV1:AutoUpdateVersion")(lAutoUpdateVersionEndpoint)
	}
	var lUpdateTLSConfigEndpoint endpoint.Endpoint
	{
		lUpdateTLSConfigEndpoint = grpctransport.NewClient(
			conn,
			"cluster.ClusterV1",
			"UpdateTLSConfig",
			cluster.EncodeGrpcReqUpdateTLSConfigRequest,
			cluster.DecodeGrpcRespCluster,
			&cluster.Cluster{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lUpdateTLSConfigEndpoint = trace.ClientEndPoint("ClusterV1:UpdateTLSConfig")(lUpdateTLSConfigEndpoint)
	}
	return cluster.EndpointsClusterV1Client{
		Client: cluster.NewClusterV1Client(conn),

		AuthBootstrapCompleteEndpoint:            lAuthBootstrapCompleteEndpoint,
		AutoAddClusterEndpoint:                   lAutoAddClusterEndpoint,
		AutoAddDistributedServiceCardEndpoint:    lAutoAddDistributedServiceCardEndpoint,
		AutoAddHostEndpoint:                      lAutoAddHostEndpoint,
		AutoAddNodeEndpoint:                      lAutoAddNodeEndpoint,
		AutoAddTenantEndpoint:                    lAutoAddTenantEndpoint,
		AutoAddVersionEndpoint:                   lAutoAddVersionEndpoint,
		AutoDeleteClusterEndpoint:                lAutoDeleteClusterEndpoint,
		AutoDeleteDistributedServiceCardEndpoint: lAutoDeleteDistributedServiceCardEndpoint,
		AutoDeleteHostEndpoint:                   lAutoDeleteHostEndpoint,
		AutoDeleteNodeEndpoint:                   lAutoDeleteNodeEndpoint,
		AutoDeleteTenantEndpoint:                 lAutoDeleteTenantEndpoint,
		AutoDeleteVersionEndpoint:                lAutoDeleteVersionEndpoint,
		AutoGetClusterEndpoint:                   lAutoGetClusterEndpoint,
		AutoGetDistributedServiceCardEndpoint:    lAutoGetDistributedServiceCardEndpoint,
		AutoGetHostEndpoint:                      lAutoGetHostEndpoint,
		AutoGetNodeEndpoint:                      lAutoGetNodeEndpoint,
		AutoGetTenantEndpoint:                    lAutoGetTenantEndpoint,
		AutoGetVersionEndpoint:                   lAutoGetVersionEndpoint,
		AutoListClusterEndpoint:                  lAutoListClusterEndpoint,
		AutoListDistributedServiceCardEndpoint:   lAutoListDistributedServiceCardEndpoint,
		AutoListHostEndpoint:                     lAutoListHostEndpoint,
		AutoListNodeEndpoint:                     lAutoListNodeEndpoint,
		AutoListTenantEndpoint:                   lAutoListTenantEndpoint,
		AutoListVersionEndpoint:                  lAutoListVersionEndpoint,
		AutoUpdateClusterEndpoint:                lAutoUpdateClusterEndpoint,
		AutoUpdateDistributedServiceCardEndpoint: lAutoUpdateDistributedServiceCardEndpoint,
		AutoUpdateHostEndpoint:                   lAutoUpdateHostEndpoint,
		AutoUpdateNodeEndpoint:                   lAutoUpdateNodeEndpoint,
		AutoUpdateTenantEndpoint:                 lAutoUpdateTenantEndpoint,
		AutoUpdateVersionEndpoint:                lAutoUpdateVersionEndpoint,
		UpdateTLSConfigEndpoint:                  lUpdateTLSConfigEndpoint,
	}
}

// NewClusterV1Backend creates an instrumented client with middleware
func NewClusterV1Backend(conn *grpc.ClientConn, logger log.Logger) cluster.ServiceClusterV1Client {
	cl := NewClusterV1(conn, logger)
	cl = cluster.LoggingClusterV1MiddlewareClient(logger)(cl)
	return cl
}

type grpcObjClusterV1Cluster struct {
	logger log.Logger
	client cluster.ServiceClusterV1Client
}

func (a *grpcObjClusterV1Cluster) Create(ctx context.Context, in *cluster.Cluster) (*cluster.Cluster, error) {
	a.logger.DebugLog("msg", "received call", "object", "Cluster", "oper", "create")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoAddCluster(nctx, in)
}

func (a *grpcObjClusterV1Cluster) Update(ctx context.Context, in *cluster.Cluster) (*cluster.Cluster, error) {
	a.logger.DebugLog("msg", "received call", "object", "Cluster", "oper", "update")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoUpdateCluster(nctx, in)
}

func (a *grpcObjClusterV1Cluster) UpdateStatus(ctx context.Context, in *cluster.Cluster) (*cluster.Cluster, error) {
	a.logger.DebugLog("msg", "received call", "object", "Cluster", "oper", "update")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	nctx = addStatusUpd(nctx)
	return a.client.AutoUpdateCluster(nctx, in)
}

func (a *grpcObjClusterV1Cluster) Get(ctx context.Context, objMeta *api.ObjectMeta) (*cluster.Cluster, error) {
	a.logger.DebugLog("msg", "received call", "object", "Cluster", "oper", "get")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := cluster.Cluster{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoGetCluster(nctx, &in)
}

func (a *grpcObjClusterV1Cluster) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*cluster.Cluster, error) {
	a.logger.DebugLog("msg", "received call", "object", "Cluster", "oper", "delete")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := cluster.Cluster{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoDeleteCluster(nctx, &in)
}

func (a *grpcObjClusterV1Cluster) List(ctx context.Context, options *api.ListWatchOptions) ([]*cluster.Cluster, error) {
	a.logger.DebugLog("msg", "received call", "object", "Cluster", "oper", "list")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	r, err := a.client.AutoListCluster(nctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *grpcObjClusterV1Cluster) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	a.logger.DebugLog("msg", "received call", "object", "Cluster", "oper", "WatchOper")
	nctx := addVersion(ctx, "v1")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	stream, err := a.client.AutoWatchCluster(nctx, options)
	if err != nil {
		return nil, err
	}
	wstream := stream.(cluster.ClusterV1_AutoWatchClusterClient)
	bridgefn := func(lw *listerwatcher.WatcherClient) {
		for {
			r, err := wstream.Recv()
			if err != nil {
				a.logger.ErrorLog("msg", "error on receive", "err", err)
				close(lw.OutCh)
				return
			}
			for _, e := range r.Events {
				ev := kvstore.WatchEvent{
					Type:   kvstore.WatchEventType(e.Type),
					Object: e.Object,
				}
				select {
				case lw.OutCh <- &ev:
				case <-wstream.Context().Done():
					close(lw.OutCh)
					return
				}
			}
		}
	}
	lw := listerwatcher.NewWatcherClient(wstream, bridgefn)
	lw.Run()
	return lw, nil
}

func (a *grpcObjClusterV1Cluster) AuthBootstrapComplete(ctx context.Context, in *cluster.ClusterAuthBootstrapRequest) (*cluster.Cluster, error) {
	a.logger.DebugLog("msg", "received call", "object", "{AuthBootstrapComplete ClusterAuthBootstrapRequest Cluster}", "oper", "AuthBootstrapComplete")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AuthBootstrapComplete(nctx, in)
}

func (a *grpcObjClusterV1Cluster) UpdateTLSConfig(ctx context.Context, in *cluster.UpdateTLSConfigRequest) (*cluster.Cluster, error) {
	a.logger.DebugLog("msg", "received call", "object", "{UpdateTLSConfig UpdateTLSConfigRequest Cluster}", "oper", "UpdateTLSConfig")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.UpdateTLSConfig(nctx, in)
}

func (a *grpcObjClusterV1Cluster) Allowed(oper apiintf.APIOperType) bool {
	return true
}

type restObjClusterV1Cluster struct {
	endpoints cluster.EndpointsClusterV1RestClient
	instance  string
}

func (a *restObjClusterV1Cluster) Create(ctx context.Context, in *cluster.Cluster) (*cluster.Cluster, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoAddCluster(ctx, in)
}

func (a *restObjClusterV1Cluster) Update(ctx context.Context, in *cluster.Cluster) (*cluster.Cluster, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoUpdateCluster(ctx, in)
}

func (a *restObjClusterV1Cluster) UpdateStatus(ctx context.Context, in *cluster.Cluster) (*cluster.Cluster, error) {
	return nil, errors.New("not supported for REST")
}

func (a *restObjClusterV1Cluster) Get(ctx context.Context, objMeta *api.ObjectMeta) (*cluster.Cluster, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := cluster.Cluster{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoGetCluster(ctx, &in)
}

func (a *restObjClusterV1Cluster) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*cluster.Cluster, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := cluster.Cluster{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoDeleteCluster(ctx, &in)
}

func (a *restObjClusterV1Cluster) List(ctx context.Context, options *api.ListWatchOptions) ([]*cluster.Cluster, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}

	r, err := a.endpoints.AutoListCluster(ctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *restObjClusterV1Cluster) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoWatchCluster(ctx, options)
}

func (a *restObjClusterV1Cluster) Allowed(oper apiintf.APIOperType) bool {
	switch oper {
	case apiintf.CreateOper:
		return false
	case apiintf.UpdateOper:
		return true
	case apiintf.GetOper:
		return true
	case apiintf.DeleteOper:
		return false
	case apiintf.ListOper:
		return false
	case apiintf.WatchOper:
		return true
	default:
		return false
	}
}

func (a *restObjClusterV1Cluster) AuthBootstrapComplete(ctx context.Context, in *cluster.ClusterAuthBootstrapRequest) (*cluster.Cluster, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AuthBootstrapCompleteCluster(ctx, in)
}
func (a *restObjClusterV1Cluster) UpdateTLSConfig(ctx context.Context, in *cluster.UpdateTLSConfigRequest) (*cluster.Cluster, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.UpdateTLSConfigCluster(ctx, in)
}

type grpcObjClusterV1Node struct {
	logger log.Logger
	client cluster.ServiceClusterV1Client
}

func (a *grpcObjClusterV1Node) Create(ctx context.Context, in *cluster.Node) (*cluster.Node, error) {
	a.logger.DebugLog("msg", "received call", "object", "Node", "oper", "create")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoAddNode(nctx, in)
}

func (a *grpcObjClusterV1Node) Update(ctx context.Context, in *cluster.Node) (*cluster.Node, error) {
	a.logger.DebugLog("msg", "received call", "object", "Node", "oper", "update")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoUpdateNode(nctx, in)
}

func (a *grpcObjClusterV1Node) UpdateStatus(ctx context.Context, in *cluster.Node) (*cluster.Node, error) {
	a.logger.DebugLog("msg", "received call", "object", "Node", "oper", "update")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	nctx = addStatusUpd(nctx)
	return a.client.AutoUpdateNode(nctx, in)
}

func (a *grpcObjClusterV1Node) Get(ctx context.Context, objMeta *api.ObjectMeta) (*cluster.Node, error) {
	a.logger.DebugLog("msg", "received call", "object", "Node", "oper", "get")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := cluster.Node{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoGetNode(nctx, &in)
}

func (a *grpcObjClusterV1Node) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*cluster.Node, error) {
	a.logger.DebugLog("msg", "received call", "object", "Node", "oper", "delete")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := cluster.Node{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoDeleteNode(nctx, &in)
}

func (a *grpcObjClusterV1Node) List(ctx context.Context, options *api.ListWatchOptions) ([]*cluster.Node, error) {
	a.logger.DebugLog("msg", "received call", "object", "Node", "oper", "list")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	r, err := a.client.AutoListNode(nctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *grpcObjClusterV1Node) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	a.logger.DebugLog("msg", "received call", "object", "Node", "oper", "WatchOper")
	nctx := addVersion(ctx, "v1")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	stream, err := a.client.AutoWatchNode(nctx, options)
	if err != nil {
		return nil, err
	}
	wstream := stream.(cluster.ClusterV1_AutoWatchNodeClient)
	bridgefn := func(lw *listerwatcher.WatcherClient) {
		for {
			r, err := wstream.Recv()
			if err != nil {
				a.logger.ErrorLog("msg", "error on receive", "err", err)
				close(lw.OutCh)
				return
			}
			for _, e := range r.Events {
				ev := kvstore.WatchEvent{
					Type:   kvstore.WatchEventType(e.Type),
					Object: e.Object,
				}
				select {
				case lw.OutCh <- &ev:
				case <-wstream.Context().Done():
					close(lw.OutCh)
					return
				}
			}
		}
	}
	lw := listerwatcher.NewWatcherClient(wstream, bridgefn)
	lw.Run()
	return lw, nil
}

func (a *grpcObjClusterV1Node) Allowed(oper apiintf.APIOperType) bool {
	return true
}

type restObjClusterV1Node struct {
	endpoints cluster.EndpointsClusterV1RestClient
	instance  string
}

func (a *restObjClusterV1Node) Create(ctx context.Context, in *cluster.Node) (*cluster.Node, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoAddNode(ctx, in)
}

func (a *restObjClusterV1Node) Update(ctx context.Context, in *cluster.Node) (*cluster.Node, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoUpdateNode(ctx, in)
}

func (a *restObjClusterV1Node) UpdateStatus(ctx context.Context, in *cluster.Node) (*cluster.Node, error) {
	return nil, errors.New("not supported for REST")
}

func (a *restObjClusterV1Node) Get(ctx context.Context, objMeta *api.ObjectMeta) (*cluster.Node, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := cluster.Node{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoGetNode(ctx, &in)
}

func (a *restObjClusterV1Node) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*cluster.Node, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := cluster.Node{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoDeleteNode(ctx, &in)
}

func (a *restObjClusterV1Node) List(ctx context.Context, options *api.ListWatchOptions) ([]*cluster.Node, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}

	r, err := a.endpoints.AutoListNode(ctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *restObjClusterV1Node) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoWatchNode(ctx, options)
}

func (a *restObjClusterV1Node) Allowed(oper apiintf.APIOperType) bool {
	switch oper {
	case apiintf.CreateOper:
		return true
	case apiintf.UpdateOper:
		return true
	case apiintf.GetOper:
		return true
	case apiintf.DeleteOper:
		return true
	case apiintf.ListOper:
		return true
	case apiintf.WatchOper:
		return true
	default:
		return false
	}
}

type grpcObjClusterV1Host struct {
	logger log.Logger
	client cluster.ServiceClusterV1Client
}

func (a *grpcObjClusterV1Host) Create(ctx context.Context, in *cluster.Host) (*cluster.Host, error) {
	a.logger.DebugLog("msg", "received call", "object", "Host", "oper", "create")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoAddHost(nctx, in)
}

func (a *grpcObjClusterV1Host) Update(ctx context.Context, in *cluster.Host) (*cluster.Host, error) {
	a.logger.DebugLog("msg", "received call", "object", "Host", "oper", "update")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoUpdateHost(nctx, in)
}

func (a *grpcObjClusterV1Host) UpdateStatus(ctx context.Context, in *cluster.Host) (*cluster.Host, error) {
	a.logger.DebugLog("msg", "received call", "object", "Host", "oper", "update")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	nctx = addStatusUpd(nctx)
	return a.client.AutoUpdateHost(nctx, in)
}

func (a *grpcObjClusterV1Host) Get(ctx context.Context, objMeta *api.ObjectMeta) (*cluster.Host, error) {
	a.logger.DebugLog("msg", "received call", "object", "Host", "oper", "get")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := cluster.Host{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoGetHost(nctx, &in)
}

func (a *grpcObjClusterV1Host) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*cluster.Host, error) {
	a.logger.DebugLog("msg", "received call", "object", "Host", "oper", "delete")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := cluster.Host{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoDeleteHost(nctx, &in)
}

func (a *grpcObjClusterV1Host) List(ctx context.Context, options *api.ListWatchOptions) ([]*cluster.Host, error) {
	a.logger.DebugLog("msg", "received call", "object", "Host", "oper", "list")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	r, err := a.client.AutoListHost(nctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *grpcObjClusterV1Host) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	a.logger.DebugLog("msg", "received call", "object", "Host", "oper", "WatchOper")
	nctx := addVersion(ctx, "v1")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	stream, err := a.client.AutoWatchHost(nctx, options)
	if err != nil {
		return nil, err
	}
	wstream := stream.(cluster.ClusterV1_AutoWatchHostClient)
	bridgefn := func(lw *listerwatcher.WatcherClient) {
		for {
			r, err := wstream.Recv()
			if err != nil {
				a.logger.ErrorLog("msg", "error on receive", "err", err)
				close(lw.OutCh)
				return
			}
			for _, e := range r.Events {
				ev := kvstore.WatchEvent{
					Type:   kvstore.WatchEventType(e.Type),
					Object: e.Object,
				}
				select {
				case lw.OutCh <- &ev:
				case <-wstream.Context().Done():
					close(lw.OutCh)
					return
				}
			}
		}
	}
	lw := listerwatcher.NewWatcherClient(wstream, bridgefn)
	lw.Run()
	return lw, nil
}

func (a *grpcObjClusterV1Host) Allowed(oper apiintf.APIOperType) bool {
	return true
}

type restObjClusterV1Host struct {
	endpoints cluster.EndpointsClusterV1RestClient
	instance  string
}

func (a *restObjClusterV1Host) Create(ctx context.Context, in *cluster.Host) (*cluster.Host, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoAddHost(ctx, in)
}

func (a *restObjClusterV1Host) Update(ctx context.Context, in *cluster.Host) (*cluster.Host, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoUpdateHost(ctx, in)
}

func (a *restObjClusterV1Host) UpdateStatus(ctx context.Context, in *cluster.Host) (*cluster.Host, error) {
	return nil, errors.New("not supported for REST")
}

func (a *restObjClusterV1Host) Get(ctx context.Context, objMeta *api.ObjectMeta) (*cluster.Host, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := cluster.Host{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoGetHost(ctx, &in)
}

func (a *restObjClusterV1Host) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*cluster.Host, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := cluster.Host{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoDeleteHost(ctx, &in)
}

func (a *restObjClusterV1Host) List(ctx context.Context, options *api.ListWatchOptions) ([]*cluster.Host, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}

	r, err := a.endpoints.AutoListHost(ctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *restObjClusterV1Host) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoWatchHost(ctx, options)
}

func (a *restObjClusterV1Host) Allowed(oper apiintf.APIOperType) bool {
	switch oper {
	case apiintf.CreateOper:
		return true
	case apiintf.UpdateOper:
		return true
	case apiintf.GetOper:
		return true
	case apiintf.DeleteOper:
		return true
	case apiintf.ListOper:
		return true
	case apiintf.WatchOper:
		return true
	default:
		return false
	}
}

type grpcObjClusterV1DistributedServiceCard struct {
	logger log.Logger
	client cluster.ServiceClusterV1Client
}

func (a *grpcObjClusterV1DistributedServiceCard) Create(ctx context.Context, in *cluster.DistributedServiceCard) (*cluster.DistributedServiceCard, error) {
	a.logger.DebugLog("msg", "received call", "object", "DistributedServiceCard", "oper", "create")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoAddDistributedServiceCard(nctx, in)
}

func (a *grpcObjClusterV1DistributedServiceCard) Update(ctx context.Context, in *cluster.DistributedServiceCard) (*cluster.DistributedServiceCard, error) {
	a.logger.DebugLog("msg", "received call", "object", "DistributedServiceCard", "oper", "update")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoUpdateDistributedServiceCard(nctx, in)
}

func (a *grpcObjClusterV1DistributedServiceCard) UpdateStatus(ctx context.Context, in *cluster.DistributedServiceCard) (*cluster.DistributedServiceCard, error) {
	a.logger.DebugLog("msg", "received call", "object", "DistributedServiceCard", "oper", "update")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	nctx = addStatusUpd(nctx)
	return a.client.AutoUpdateDistributedServiceCard(nctx, in)
}

func (a *grpcObjClusterV1DistributedServiceCard) Get(ctx context.Context, objMeta *api.ObjectMeta) (*cluster.DistributedServiceCard, error) {
	a.logger.DebugLog("msg", "received call", "object", "DistributedServiceCard", "oper", "get")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := cluster.DistributedServiceCard{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoGetDistributedServiceCard(nctx, &in)
}

func (a *grpcObjClusterV1DistributedServiceCard) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*cluster.DistributedServiceCard, error) {
	a.logger.DebugLog("msg", "received call", "object", "DistributedServiceCard", "oper", "delete")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := cluster.DistributedServiceCard{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoDeleteDistributedServiceCard(nctx, &in)
}

func (a *grpcObjClusterV1DistributedServiceCard) List(ctx context.Context, options *api.ListWatchOptions) ([]*cluster.DistributedServiceCard, error) {
	a.logger.DebugLog("msg", "received call", "object", "DistributedServiceCard", "oper", "list")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	r, err := a.client.AutoListDistributedServiceCard(nctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *grpcObjClusterV1DistributedServiceCard) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	a.logger.DebugLog("msg", "received call", "object", "DistributedServiceCard", "oper", "WatchOper")
	nctx := addVersion(ctx, "v1")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	stream, err := a.client.AutoWatchDistributedServiceCard(nctx, options)
	if err != nil {
		return nil, err
	}
	wstream := stream.(cluster.ClusterV1_AutoWatchDistributedServiceCardClient)
	bridgefn := func(lw *listerwatcher.WatcherClient) {
		for {
			r, err := wstream.Recv()
			if err != nil {
				a.logger.ErrorLog("msg", "error on receive", "err", err)
				close(lw.OutCh)
				return
			}
			for _, e := range r.Events {
				ev := kvstore.WatchEvent{
					Type:   kvstore.WatchEventType(e.Type),
					Object: e.Object,
				}
				select {
				case lw.OutCh <- &ev:
				case <-wstream.Context().Done():
					close(lw.OutCh)
					return
				}
			}
		}
	}
	lw := listerwatcher.NewWatcherClient(wstream, bridgefn)
	lw.Run()
	return lw, nil
}

func (a *grpcObjClusterV1DistributedServiceCard) Allowed(oper apiintf.APIOperType) bool {
	return true
}

type restObjClusterV1DistributedServiceCard struct {
	endpoints cluster.EndpointsClusterV1RestClient
	instance  string
}

func (a *restObjClusterV1DistributedServiceCard) Create(ctx context.Context, in *cluster.DistributedServiceCard) (*cluster.DistributedServiceCard, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoAddDistributedServiceCard(ctx, in)
}

func (a *restObjClusterV1DistributedServiceCard) Update(ctx context.Context, in *cluster.DistributedServiceCard) (*cluster.DistributedServiceCard, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoUpdateDistributedServiceCard(ctx, in)
}

func (a *restObjClusterV1DistributedServiceCard) UpdateStatus(ctx context.Context, in *cluster.DistributedServiceCard) (*cluster.DistributedServiceCard, error) {
	return nil, errors.New("not supported for REST")
}

func (a *restObjClusterV1DistributedServiceCard) Get(ctx context.Context, objMeta *api.ObjectMeta) (*cluster.DistributedServiceCard, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := cluster.DistributedServiceCard{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoGetDistributedServiceCard(ctx, &in)
}

func (a *restObjClusterV1DistributedServiceCard) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*cluster.DistributedServiceCard, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := cluster.DistributedServiceCard{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoDeleteDistributedServiceCard(ctx, &in)
}

func (a *restObjClusterV1DistributedServiceCard) List(ctx context.Context, options *api.ListWatchOptions) ([]*cluster.DistributedServiceCard, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}

	r, err := a.endpoints.AutoListDistributedServiceCard(ctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *restObjClusterV1DistributedServiceCard) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoWatchDistributedServiceCard(ctx, options)
}

func (a *restObjClusterV1DistributedServiceCard) Allowed(oper apiintf.APIOperType) bool {
	switch oper {
	case apiintf.CreateOper:
		return false
	case apiintf.UpdateOper:
		return true
	case apiintf.GetOper:
		return true
	case apiintf.DeleteOper:
		return true
	case apiintf.ListOper:
		return true
	case apiintf.WatchOper:
		return true
	default:
		return false
	}
}

type grpcObjClusterV1Tenant struct {
	logger log.Logger
	client cluster.ServiceClusterV1Client
}

func (a *grpcObjClusterV1Tenant) Create(ctx context.Context, in *cluster.Tenant) (*cluster.Tenant, error) {
	a.logger.DebugLog("msg", "received call", "object", "Tenant", "oper", "create")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoAddTenant(nctx, in)
}

func (a *grpcObjClusterV1Tenant) Update(ctx context.Context, in *cluster.Tenant) (*cluster.Tenant, error) {
	a.logger.DebugLog("msg", "received call", "object", "Tenant", "oper", "update")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoUpdateTenant(nctx, in)
}

func (a *grpcObjClusterV1Tenant) UpdateStatus(ctx context.Context, in *cluster.Tenant) (*cluster.Tenant, error) {
	a.logger.DebugLog("msg", "received call", "object", "Tenant", "oper", "update")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	nctx = addStatusUpd(nctx)
	return a.client.AutoUpdateTenant(nctx, in)
}

func (a *grpcObjClusterV1Tenant) Get(ctx context.Context, objMeta *api.ObjectMeta) (*cluster.Tenant, error) {
	a.logger.DebugLog("msg", "received call", "object", "Tenant", "oper", "get")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := cluster.Tenant{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoGetTenant(nctx, &in)
}

func (a *grpcObjClusterV1Tenant) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*cluster.Tenant, error) {
	a.logger.DebugLog("msg", "received call", "object", "Tenant", "oper", "delete")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := cluster.Tenant{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoDeleteTenant(nctx, &in)
}

func (a *grpcObjClusterV1Tenant) List(ctx context.Context, options *api.ListWatchOptions) ([]*cluster.Tenant, error) {
	a.logger.DebugLog("msg", "received call", "object", "Tenant", "oper", "list")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	r, err := a.client.AutoListTenant(nctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *grpcObjClusterV1Tenant) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	a.logger.DebugLog("msg", "received call", "object", "Tenant", "oper", "WatchOper")
	nctx := addVersion(ctx, "v1")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	stream, err := a.client.AutoWatchTenant(nctx, options)
	if err != nil {
		return nil, err
	}
	wstream := stream.(cluster.ClusterV1_AutoWatchTenantClient)
	bridgefn := func(lw *listerwatcher.WatcherClient) {
		for {
			r, err := wstream.Recv()
			if err != nil {
				a.logger.ErrorLog("msg", "error on receive", "err", err)
				close(lw.OutCh)
				return
			}
			for _, e := range r.Events {
				ev := kvstore.WatchEvent{
					Type:   kvstore.WatchEventType(e.Type),
					Object: e.Object,
				}
				select {
				case lw.OutCh <- &ev:
				case <-wstream.Context().Done():
					close(lw.OutCh)
					return
				}
			}
		}
	}
	lw := listerwatcher.NewWatcherClient(wstream, bridgefn)
	lw.Run()
	return lw, nil
}

func (a *grpcObjClusterV1Tenant) Allowed(oper apiintf.APIOperType) bool {
	return true
}

type restObjClusterV1Tenant struct {
	endpoints cluster.EndpointsClusterV1RestClient
	instance  string
}

func (a *restObjClusterV1Tenant) Create(ctx context.Context, in *cluster.Tenant) (*cluster.Tenant, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoAddTenant(ctx, in)
}

func (a *restObjClusterV1Tenant) Update(ctx context.Context, in *cluster.Tenant) (*cluster.Tenant, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoUpdateTenant(ctx, in)
}

func (a *restObjClusterV1Tenant) UpdateStatus(ctx context.Context, in *cluster.Tenant) (*cluster.Tenant, error) {
	return nil, errors.New("not supported for REST")
}

func (a *restObjClusterV1Tenant) Get(ctx context.Context, objMeta *api.ObjectMeta) (*cluster.Tenant, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := cluster.Tenant{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoGetTenant(ctx, &in)
}

func (a *restObjClusterV1Tenant) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*cluster.Tenant, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := cluster.Tenant{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoDeleteTenant(ctx, &in)
}

func (a *restObjClusterV1Tenant) List(ctx context.Context, options *api.ListWatchOptions) ([]*cluster.Tenant, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}

	r, err := a.endpoints.AutoListTenant(ctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *restObjClusterV1Tenant) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoWatchTenant(ctx, options)
}

func (a *restObjClusterV1Tenant) Allowed(oper apiintf.APIOperType) bool {
	switch oper {
	case apiintf.CreateOper:
		return true
	case apiintf.UpdateOper:
		return true
	case apiintf.GetOper:
		return true
	case apiintf.DeleteOper:
		return true
	case apiintf.ListOper:
		return true
	case apiintf.WatchOper:
		return true
	default:
		return false
	}
}

type grpcObjClusterV1Version struct {
	logger log.Logger
	client cluster.ServiceClusterV1Client
}

func (a *grpcObjClusterV1Version) Create(ctx context.Context, in *cluster.Version) (*cluster.Version, error) {
	a.logger.DebugLog("msg", "received call", "object", "Version", "oper", "create")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoAddVersion(nctx, in)
}

func (a *grpcObjClusterV1Version) Update(ctx context.Context, in *cluster.Version) (*cluster.Version, error) {
	a.logger.DebugLog("msg", "received call", "object", "Version", "oper", "update")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoUpdateVersion(nctx, in)
}

func (a *grpcObjClusterV1Version) UpdateStatus(ctx context.Context, in *cluster.Version) (*cluster.Version, error) {
	a.logger.DebugLog("msg", "received call", "object", "Version", "oper", "update")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	nctx = addStatusUpd(nctx)
	return a.client.AutoUpdateVersion(nctx, in)
}

func (a *grpcObjClusterV1Version) Get(ctx context.Context, objMeta *api.ObjectMeta) (*cluster.Version, error) {
	a.logger.DebugLog("msg", "received call", "object", "Version", "oper", "get")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := cluster.Version{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoGetVersion(nctx, &in)
}

func (a *grpcObjClusterV1Version) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*cluster.Version, error) {
	a.logger.DebugLog("msg", "received call", "object", "Version", "oper", "delete")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := cluster.Version{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoDeleteVersion(nctx, &in)
}

func (a *grpcObjClusterV1Version) List(ctx context.Context, options *api.ListWatchOptions) ([]*cluster.Version, error) {
	a.logger.DebugLog("msg", "received call", "object", "Version", "oper", "list")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	r, err := a.client.AutoListVersion(nctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *grpcObjClusterV1Version) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	a.logger.DebugLog("msg", "received call", "object", "Version", "oper", "WatchOper")
	nctx := addVersion(ctx, "v1")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	stream, err := a.client.AutoWatchVersion(nctx, options)
	if err != nil {
		return nil, err
	}
	wstream := stream.(cluster.ClusterV1_AutoWatchVersionClient)
	bridgefn := func(lw *listerwatcher.WatcherClient) {
		for {
			r, err := wstream.Recv()
			if err != nil {
				a.logger.ErrorLog("msg", "error on receive", "err", err)
				close(lw.OutCh)
				return
			}
			for _, e := range r.Events {
				ev := kvstore.WatchEvent{
					Type:   kvstore.WatchEventType(e.Type),
					Object: e.Object,
				}
				select {
				case lw.OutCh <- &ev:
				case <-wstream.Context().Done():
					close(lw.OutCh)
					return
				}
			}
		}
	}
	lw := listerwatcher.NewWatcherClient(wstream, bridgefn)
	lw.Run()
	return lw, nil
}

func (a *grpcObjClusterV1Version) Allowed(oper apiintf.APIOperType) bool {
	return true
}

type restObjClusterV1Version struct {
	endpoints cluster.EndpointsClusterV1RestClient
	instance  string
}

func (a *restObjClusterV1Version) Create(ctx context.Context, in *cluster.Version) (*cluster.Version, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoAddVersion(ctx, in)
}

func (a *restObjClusterV1Version) Update(ctx context.Context, in *cluster.Version) (*cluster.Version, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoUpdateVersion(ctx, in)
}

func (a *restObjClusterV1Version) UpdateStatus(ctx context.Context, in *cluster.Version) (*cluster.Version, error) {
	return nil, errors.New("not supported for REST")
}

func (a *restObjClusterV1Version) Get(ctx context.Context, objMeta *api.ObjectMeta) (*cluster.Version, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := cluster.Version{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoGetVersion(ctx, &in)
}

func (a *restObjClusterV1Version) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*cluster.Version, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := cluster.Version{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoDeleteVersion(ctx, &in)
}

func (a *restObjClusterV1Version) List(ctx context.Context, options *api.ListWatchOptions) ([]*cluster.Version, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}

	r, err := a.endpoints.AutoListVersion(ctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *restObjClusterV1Version) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoWatchVersion(ctx, options)
}

func (a *restObjClusterV1Version) Allowed(oper apiintf.APIOperType) bool {
	switch oper {
	case apiintf.CreateOper:
		return false
	case apiintf.UpdateOper:
		return false
	case apiintf.GetOper:
		return true
	case apiintf.DeleteOper:
		return false
	case apiintf.ListOper:
		return false
	case apiintf.WatchOper:
		return true
	default:
		return false
	}
}

type crudClientClusterV1 struct {
	logger log.Logger
	client cluster.ServiceClusterV1Client

	grpcCluster                cluster.ClusterV1ClusterInterface
	grpcNode                   cluster.ClusterV1NodeInterface
	grpcHost                   cluster.ClusterV1HostInterface
	grpcDistributedServiceCard cluster.ClusterV1DistributedServiceCardInterface
	grpcTenant                 cluster.ClusterV1TenantInterface
	grpcVersion                cluster.ClusterV1VersionInterface
}

// NewGrpcCrudClientClusterV1 creates a GRPC client for the service
func NewGrpcCrudClientClusterV1(conn *grpc.ClientConn, logger log.Logger) cluster.ClusterV1Interface {
	client := NewClusterV1Backend(conn, logger)
	return &crudClientClusterV1{
		logger: logger,
		client: client,

		grpcCluster:                &grpcObjClusterV1Cluster{client: client, logger: logger},
		grpcNode:                   &grpcObjClusterV1Node{client: client, logger: logger},
		grpcHost:                   &grpcObjClusterV1Host{client: client, logger: logger},
		grpcDistributedServiceCard: &grpcObjClusterV1DistributedServiceCard{client: client, logger: logger},
		grpcTenant:                 &grpcObjClusterV1Tenant{client: client, logger: logger},
		grpcVersion:                &grpcObjClusterV1Version{client: client, logger: logger},
	}
}

func (a *crudClientClusterV1) Cluster() cluster.ClusterV1ClusterInterface {
	return a.grpcCluster
}

func (a *crudClientClusterV1) Node() cluster.ClusterV1NodeInterface {
	return a.grpcNode
}

func (a *crudClientClusterV1) Host() cluster.ClusterV1HostInterface {
	return a.grpcHost
}

func (a *crudClientClusterV1) DistributedServiceCard() cluster.ClusterV1DistributedServiceCardInterface {
	return a.grpcDistributedServiceCard
}

func (a *crudClientClusterV1) Tenant() cluster.ClusterV1TenantInterface {
	return a.grpcTenant
}

func (a *crudClientClusterV1) Version() cluster.ClusterV1VersionInterface {
	return a.grpcVersion
}

func (a *crudClientClusterV1) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	a.logger.DebugLog("msg", "received call", "object", "ClusterV1", "oper", "WatchOper")
	nctx := addVersion(ctx, "v1")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	stream, err := a.client.AutoWatchSvcClusterV1(nctx, options)
	if err != nil {
		return nil, err
	}
	wstream := stream.(cluster.ClusterV1_AutoWatchSvcClusterV1Client)
	bridgefn := func(lw *listerwatcher.WatcherClient) {
		for {
			r, err := wstream.Recv()
			if err != nil {
				a.logger.ErrorLog("msg", "error on receive", "err", err)
				close(lw.OutCh)
				return
			}
			for _, e := range r.Events {
				ev := kvstore.WatchEvent{Type: kvstore.WatchEventType(e.Type)}
				robj, err := listerwatcher.GetObject(e)
				if err != nil {
					a.logger.ErrorLog("msg", "error on receive unmarshall", "err", err)
					close(lw.OutCh)
					return
				}
				ev.Object = robj
				select {
				case lw.OutCh <- &ev:
				case <-wstream.Context().Done():
					close(lw.OutCh)
					return
				}
			}
		}
	}
	lw := listerwatcher.NewWatcherClient(wstream, bridgefn)
	lw.Run()
	return lw, nil
}

type crudRestClientClusterV1 struct {
	restCluster                cluster.ClusterV1ClusterInterface
	restNode                   cluster.ClusterV1NodeInterface
	restHost                   cluster.ClusterV1HostInterface
	restDistributedServiceCard cluster.ClusterV1DistributedServiceCardInterface
	restTenant                 cluster.ClusterV1TenantInterface
	restVersion                cluster.ClusterV1VersionInterface
}

// NewRestCrudClientClusterV1 creates a REST client for the service.
func NewRestCrudClientClusterV1(url string, httpClient *http.Client) cluster.ClusterV1Interface {
	endpoints, err := cluster.MakeClusterV1RestClientEndpoints(url, httpClient)
	if err != nil {
		oldlog.Fatal("failed to create client")
	}
	return &crudRestClientClusterV1{

		restCluster:                &restObjClusterV1Cluster{endpoints: endpoints, instance: url},
		restNode:                   &restObjClusterV1Node{endpoints: endpoints, instance: url},
		restHost:                   &restObjClusterV1Host{endpoints: endpoints, instance: url},
		restDistributedServiceCard: &restObjClusterV1DistributedServiceCard{endpoints: endpoints, instance: url},
		restTenant:                 &restObjClusterV1Tenant{endpoints: endpoints, instance: url},
		restVersion:                &restObjClusterV1Version{endpoints: endpoints, instance: url},
	}
}

// NewStagedRestCrudClientClusterV1 creates a REST client for the service.
func NewStagedRestCrudClientClusterV1(url string, id string, httpClient *http.Client) cluster.ClusterV1Interface {
	endpoints, err := cluster.MakeClusterV1StagedRestClientEndpoints(url, id, httpClient)
	if err != nil {
		oldlog.Fatal("failed to create client")
	}
	return &crudRestClientClusterV1{

		restCluster:                &restObjClusterV1Cluster{endpoints: endpoints, instance: url},
		restNode:                   &restObjClusterV1Node{endpoints: endpoints, instance: url},
		restHost:                   &restObjClusterV1Host{endpoints: endpoints, instance: url},
		restDistributedServiceCard: &restObjClusterV1DistributedServiceCard{endpoints: endpoints, instance: url},
		restTenant:                 &restObjClusterV1Tenant{endpoints: endpoints, instance: url},
		restVersion:                &restObjClusterV1Version{endpoints: endpoints, instance: url},
	}
}

func (a *crudRestClientClusterV1) Cluster() cluster.ClusterV1ClusterInterface {
	return a.restCluster
}

func (a *crudRestClientClusterV1) Node() cluster.ClusterV1NodeInterface {
	return a.restNode
}

func (a *crudRestClientClusterV1) Host() cluster.ClusterV1HostInterface {
	return a.restHost
}

func (a *crudRestClientClusterV1) DistributedServiceCard() cluster.ClusterV1DistributedServiceCardInterface {
	return a.restDistributedServiceCard
}

func (a *crudRestClientClusterV1) Tenant() cluster.ClusterV1TenantInterface {
	return a.restTenant
}

func (a *crudRestClientClusterV1) Version() cluster.ClusterV1VersionInterface {
	return a.restVersion
}

func (a *crudRestClientClusterV1) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	return nil, errors.New("method unimplemented")
}
