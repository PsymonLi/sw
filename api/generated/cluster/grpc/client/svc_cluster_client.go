// Code generated by protoc-gen-grpc-pensando DO NOT EDIT.

package grpcclient

import (
	"context"
	"errors"
	oldlog "log"

	"github.com/go-kit/kit/endpoint"
	grpctransport "github.com/go-kit/kit/transport/grpc"
	"google.golang.org/grpc"

	api "github.com/pensando/sw/api"
	cluster "github.com/pensando/sw/api/generated/cluster"
	listerwatcher "github.com/pensando/sw/api/listerwatcher"
	apiserver "github.com/pensando/sw/venice/apiserver"
	"github.com/pensando/sw/venice/utils/kvstore"
	"github.com/pensando/sw/venice/utils/log"
	"github.com/pensando/sw/venice/utils/trace"
)

// Dummy vars to suppress import errors
var _ api.TypeMeta
var _ listerwatcher.WatcherClient
var _ kvstore.Interface

// NewClusterV1 sets up a new client for ClusterV1
func NewClusterV1(conn *grpc.ClientConn, logger log.Logger) cluster.ServiceClusterV1Client {

	var lAuthBootstrapCompleteEndpoint endpoint.Endpoint
	{
		lAuthBootstrapCompleteEndpoint = grpctransport.NewClient(
			conn,
			"cluster.ClusterV1",
			"AuthBootstrapComplete",
			cluster.EncodeGrpcReqClusterAuthBootstrapRequest,
			cluster.DecodeGrpcRespCluster,
			&cluster.Cluster{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAuthBootstrapCompleteEndpoint = trace.ClientEndPoint("ClusterV1:AuthBootstrapComplete")(lAuthBootstrapCompleteEndpoint)
	}
	var lAutoAddClusterEndpoint endpoint.Endpoint
	{
		lAutoAddClusterEndpoint = grpctransport.NewClient(
			conn,
			"cluster.ClusterV1",
			"AutoAddCluster",
			cluster.EncodeGrpcReqCluster,
			cluster.DecodeGrpcRespCluster,
			&cluster.Cluster{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoAddClusterEndpoint = trace.ClientEndPoint("ClusterV1:AutoAddCluster")(lAutoAddClusterEndpoint)
	}
	var lAutoAddHostEndpoint endpoint.Endpoint
	{
		lAutoAddHostEndpoint = grpctransport.NewClient(
			conn,
			"cluster.ClusterV1",
			"AutoAddHost",
			cluster.EncodeGrpcReqHost,
			cluster.DecodeGrpcRespHost,
			&cluster.Host{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoAddHostEndpoint = trace.ClientEndPoint("ClusterV1:AutoAddHost")(lAutoAddHostEndpoint)
	}
	var lAutoAddNodeEndpoint endpoint.Endpoint
	{
		lAutoAddNodeEndpoint = grpctransport.NewClient(
			conn,
			"cluster.ClusterV1",
			"AutoAddNode",
			cluster.EncodeGrpcReqNode,
			cluster.DecodeGrpcRespNode,
			&cluster.Node{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoAddNodeEndpoint = trace.ClientEndPoint("ClusterV1:AutoAddNode")(lAutoAddNodeEndpoint)
	}
	var lAutoAddSmartNICEndpoint endpoint.Endpoint
	{
		lAutoAddSmartNICEndpoint = grpctransport.NewClient(
			conn,
			"cluster.ClusterV1",
			"AutoAddSmartNIC",
			cluster.EncodeGrpcReqSmartNIC,
			cluster.DecodeGrpcRespSmartNIC,
			&cluster.SmartNIC{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoAddSmartNICEndpoint = trace.ClientEndPoint("ClusterV1:AutoAddSmartNIC")(lAutoAddSmartNICEndpoint)
	}
	var lAutoAddTenantEndpoint endpoint.Endpoint
	{
		lAutoAddTenantEndpoint = grpctransport.NewClient(
			conn,
			"cluster.ClusterV1",
			"AutoAddTenant",
			cluster.EncodeGrpcReqTenant,
			cluster.DecodeGrpcRespTenant,
			&cluster.Tenant{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoAddTenantEndpoint = trace.ClientEndPoint("ClusterV1:AutoAddTenant")(lAutoAddTenantEndpoint)
	}
	var lAutoDeleteClusterEndpoint endpoint.Endpoint
	{
		lAutoDeleteClusterEndpoint = grpctransport.NewClient(
			conn,
			"cluster.ClusterV1",
			"AutoDeleteCluster",
			cluster.EncodeGrpcReqCluster,
			cluster.DecodeGrpcRespCluster,
			&cluster.Cluster{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoDeleteClusterEndpoint = trace.ClientEndPoint("ClusterV1:AutoDeleteCluster")(lAutoDeleteClusterEndpoint)
	}
	var lAutoDeleteHostEndpoint endpoint.Endpoint
	{
		lAutoDeleteHostEndpoint = grpctransport.NewClient(
			conn,
			"cluster.ClusterV1",
			"AutoDeleteHost",
			cluster.EncodeGrpcReqHost,
			cluster.DecodeGrpcRespHost,
			&cluster.Host{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoDeleteHostEndpoint = trace.ClientEndPoint("ClusterV1:AutoDeleteHost")(lAutoDeleteHostEndpoint)
	}
	var lAutoDeleteNodeEndpoint endpoint.Endpoint
	{
		lAutoDeleteNodeEndpoint = grpctransport.NewClient(
			conn,
			"cluster.ClusterV1",
			"AutoDeleteNode",
			cluster.EncodeGrpcReqNode,
			cluster.DecodeGrpcRespNode,
			&cluster.Node{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoDeleteNodeEndpoint = trace.ClientEndPoint("ClusterV1:AutoDeleteNode")(lAutoDeleteNodeEndpoint)
	}
	var lAutoDeleteSmartNICEndpoint endpoint.Endpoint
	{
		lAutoDeleteSmartNICEndpoint = grpctransport.NewClient(
			conn,
			"cluster.ClusterV1",
			"AutoDeleteSmartNIC",
			cluster.EncodeGrpcReqSmartNIC,
			cluster.DecodeGrpcRespSmartNIC,
			&cluster.SmartNIC{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoDeleteSmartNICEndpoint = trace.ClientEndPoint("ClusterV1:AutoDeleteSmartNIC")(lAutoDeleteSmartNICEndpoint)
	}
	var lAutoDeleteTenantEndpoint endpoint.Endpoint
	{
		lAutoDeleteTenantEndpoint = grpctransport.NewClient(
			conn,
			"cluster.ClusterV1",
			"AutoDeleteTenant",
			cluster.EncodeGrpcReqTenant,
			cluster.DecodeGrpcRespTenant,
			&cluster.Tenant{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoDeleteTenantEndpoint = trace.ClientEndPoint("ClusterV1:AutoDeleteTenant")(lAutoDeleteTenantEndpoint)
	}
	var lAutoGetClusterEndpoint endpoint.Endpoint
	{
		lAutoGetClusterEndpoint = grpctransport.NewClient(
			conn,
			"cluster.ClusterV1",
			"AutoGetCluster",
			cluster.EncodeGrpcReqCluster,
			cluster.DecodeGrpcRespCluster,
			&cluster.Cluster{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoGetClusterEndpoint = trace.ClientEndPoint("ClusterV1:AutoGetCluster")(lAutoGetClusterEndpoint)
	}
	var lAutoGetHostEndpoint endpoint.Endpoint
	{
		lAutoGetHostEndpoint = grpctransport.NewClient(
			conn,
			"cluster.ClusterV1",
			"AutoGetHost",
			cluster.EncodeGrpcReqHost,
			cluster.DecodeGrpcRespHost,
			&cluster.Host{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoGetHostEndpoint = trace.ClientEndPoint("ClusterV1:AutoGetHost")(lAutoGetHostEndpoint)
	}
	var lAutoGetNodeEndpoint endpoint.Endpoint
	{
		lAutoGetNodeEndpoint = grpctransport.NewClient(
			conn,
			"cluster.ClusterV1",
			"AutoGetNode",
			cluster.EncodeGrpcReqNode,
			cluster.DecodeGrpcRespNode,
			&cluster.Node{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoGetNodeEndpoint = trace.ClientEndPoint("ClusterV1:AutoGetNode")(lAutoGetNodeEndpoint)
	}
	var lAutoGetSmartNICEndpoint endpoint.Endpoint
	{
		lAutoGetSmartNICEndpoint = grpctransport.NewClient(
			conn,
			"cluster.ClusterV1",
			"AutoGetSmartNIC",
			cluster.EncodeGrpcReqSmartNIC,
			cluster.DecodeGrpcRespSmartNIC,
			&cluster.SmartNIC{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoGetSmartNICEndpoint = trace.ClientEndPoint("ClusterV1:AutoGetSmartNIC")(lAutoGetSmartNICEndpoint)
	}
	var lAutoGetTenantEndpoint endpoint.Endpoint
	{
		lAutoGetTenantEndpoint = grpctransport.NewClient(
			conn,
			"cluster.ClusterV1",
			"AutoGetTenant",
			cluster.EncodeGrpcReqTenant,
			cluster.DecodeGrpcRespTenant,
			&cluster.Tenant{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoGetTenantEndpoint = trace.ClientEndPoint("ClusterV1:AutoGetTenant")(lAutoGetTenantEndpoint)
	}
	var lAutoListClusterEndpoint endpoint.Endpoint
	{
		lAutoListClusterEndpoint = grpctransport.NewClient(
			conn,
			"cluster.ClusterV1",
			"AutoListCluster",
			cluster.EncodeGrpcReqListWatchOptions,
			cluster.DecodeGrpcRespClusterList,
			&cluster.ClusterList{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoListClusterEndpoint = trace.ClientEndPoint("ClusterV1:AutoListCluster")(lAutoListClusterEndpoint)
	}
	var lAutoListHostEndpoint endpoint.Endpoint
	{
		lAutoListHostEndpoint = grpctransport.NewClient(
			conn,
			"cluster.ClusterV1",
			"AutoListHost",
			cluster.EncodeGrpcReqListWatchOptions,
			cluster.DecodeGrpcRespHostList,
			&cluster.HostList{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoListHostEndpoint = trace.ClientEndPoint("ClusterV1:AutoListHost")(lAutoListHostEndpoint)
	}
	var lAutoListNodeEndpoint endpoint.Endpoint
	{
		lAutoListNodeEndpoint = grpctransport.NewClient(
			conn,
			"cluster.ClusterV1",
			"AutoListNode",
			cluster.EncodeGrpcReqListWatchOptions,
			cluster.DecodeGrpcRespNodeList,
			&cluster.NodeList{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoListNodeEndpoint = trace.ClientEndPoint("ClusterV1:AutoListNode")(lAutoListNodeEndpoint)
	}
	var lAutoListSmartNICEndpoint endpoint.Endpoint
	{
		lAutoListSmartNICEndpoint = grpctransport.NewClient(
			conn,
			"cluster.ClusterV1",
			"AutoListSmartNIC",
			cluster.EncodeGrpcReqListWatchOptions,
			cluster.DecodeGrpcRespSmartNICList,
			&cluster.SmartNICList{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoListSmartNICEndpoint = trace.ClientEndPoint("ClusterV1:AutoListSmartNIC")(lAutoListSmartNICEndpoint)
	}
	var lAutoListTenantEndpoint endpoint.Endpoint
	{
		lAutoListTenantEndpoint = grpctransport.NewClient(
			conn,
			"cluster.ClusterV1",
			"AutoListTenant",
			cluster.EncodeGrpcReqListWatchOptions,
			cluster.DecodeGrpcRespTenantList,
			&cluster.TenantList{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoListTenantEndpoint = trace.ClientEndPoint("ClusterV1:AutoListTenant")(lAutoListTenantEndpoint)
	}
	var lAutoUpdateClusterEndpoint endpoint.Endpoint
	{
		lAutoUpdateClusterEndpoint = grpctransport.NewClient(
			conn,
			"cluster.ClusterV1",
			"AutoUpdateCluster",
			cluster.EncodeGrpcReqCluster,
			cluster.DecodeGrpcRespCluster,
			&cluster.Cluster{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoUpdateClusterEndpoint = trace.ClientEndPoint("ClusterV1:AutoUpdateCluster")(lAutoUpdateClusterEndpoint)
	}
	var lAutoUpdateHostEndpoint endpoint.Endpoint
	{
		lAutoUpdateHostEndpoint = grpctransport.NewClient(
			conn,
			"cluster.ClusterV1",
			"AutoUpdateHost",
			cluster.EncodeGrpcReqHost,
			cluster.DecodeGrpcRespHost,
			&cluster.Host{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoUpdateHostEndpoint = trace.ClientEndPoint("ClusterV1:AutoUpdateHost")(lAutoUpdateHostEndpoint)
	}
	var lAutoUpdateNodeEndpoint endpoint.Endpoint
	{
		lAutoUpdateNodeEndpoint = grpctransport.NewClient(
			conn,
			"cluster.ClusterV1",
			"AutoUpdateNode",
			cluster.EncodeGrpcReqNode,
			cluster.DecodeGrpcRespNode,
			&cluster.Node{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoUpdateNodeEndpoint = trace.ClientEndPoint("ClusterV1:AutoUpdateNode")(lAutoUpdateNodeEndpoint)
	}
	var lAutoUpdateSmartNICEndpoint endpoint.Endpoint
	{
		lAutoUpdateSmartNICEndpoint = grpctransport.NewClient(
			conn,
			"cluster.ClusterV1",
			"AutoUpdateSmartNIC",
			cluster.EncodeGrpcReqSmartNIC,
			cluster.DecodeGrpcRespSmartNIC,
			&cluster.SmartNIC{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoUpdateSmartNICEndpoint = trace.ClientEndPoint("ClusterV1:AutoUpdateSmartNIC")(lAutoUpdateSmartNICEndpoint)
	}
	var lAutoUpdateTenantEndpoint endpoint.Endpoint
	{
		lAutoUpdateTenantEndpoint = grpctransport.NewClient(
			conn,
			"cluster.ClusterV1",
			"AutoUpdateTenant",
			cluster.EncodeGrpcReqTenant,
			cluster.DecodeGrpcRespTenant,
			&cluster.Tenant{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoUpdateTenantEndpoint = trace.ClientEndPoint("ClusterV1:AutoUpdateTenant")(lAutoUpdateTenantEndpoint)
	}
	return cluster.EndpointsClusterV1Client{
		Client: cluster.NewClusterV1Client(conn),

		AuthBootstrapCompleteEndpoint: lAuthBootstrapCompleteEndpoint,
		AutoAddClusterEndpoint:        lAutoAddClusterEndpoint,
		AutoAddHostEndpoint:           lAutoAddHostEndpoint,
		AutoAddNodeEndpoint:           lAutoAddNodeEndpoint,
		AutoAddSmartNICEndpoint:       lAutoAddSmartNICEndpoint,
		AutoAddTenantEndpoint:         lAutoAddTenantEndpoint,
		AutoDeleteClusterEndpoint:     lAutoDeleteClusterEndpoint,
		AutoDeleteHostEndpoint:        lAutoDeleteHostEndpoint,
		AutoDeleteNodeEndpoint:        lAutoDeleteNodeEndpoint,
		AutoDeleteSmartNICEndpoint:    lAutoDeleteSmartNICEndpoint,
		AutoDeleteTenantEndpoint:      lAutoDeleteTenantEndpoint,
		AutoGetClusterEndpoint:        lAutoGetClusterEndpoint,
		AutoGetHostEndpoint:           lAutoGetHostEndpoint,
		AutoGetNodeEndpoint:           lAutoGetNodeEndpoint,
		AutoGetSmartNICEndpoint:       lAutoGetSmartNICEndpoint,
		AutoGetTenantEndpoint:         lAutoGetTenantEndpoint,
		AutoListClusterEndpoint:       lAutoListClusterEndpoint,
		AutoListHostEndpoint:          lAutoListHostEndpoint,
		AutoListNodeEndpoint:          lAutoListNodeEndpoint,
		AutoListSmartNICEndpoint:      lAutoListSmartNICEndpoint,
		AutoListTenantEndpoint:        lAutoListTenantEndpoint,
		AutoUpdateClusterEndpoint:     lAutoUpdateClusterEndpoint,
		AutoUpdateHostEndpoint:        lAutoUpdateHostEndpoint,
		AutoUpdateNodeEndpoint:        lAutoUpdateNodeEndpoint,
		AutoUpdateSmartNICEndpoint:    lAutoUpdateSmartNICEndpoint,
		AutoUpdateTenantEndpoint:      lAutoUpdateTenantEndpoint,
	}
}

// NewClusterV1Backend creates an instrumented client with middleware
func NewClusterV1Backend(conn *grpc.ClientConn, logger log.Logger) cluster.ServiceClusterV1Client {
	cl := NewClusterV1(conn, logger)
	cl = cluster.LoggingClusterV1MiddlewareClient(logger)(cl)
	return cl
}

type grpcObjClusterV1Cluster struct {
	logger log.Logger
	client cluster.ServiceClusterV1Client
}

func (a *grpcObjClusterV1Cluster) Create(ctx context.Context, in *cluster.Cluster) (*cluster.Cluster, error) {
	a.logger.DebugLog("msg", "received call", "object", "Cluster", "oper", "create")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoAddCluster(nctx, in)
}

func (a *grpcObjClusterV1Cluster) Update(ctx context.Context, in *cluster.Cluster) (*cluster.Cluster, error) {
	a.logger.DebugLog("msg", "received call", "object", "Cluster", "oper", "update")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoUpdateCluster(nctx, in)
}

func (a *grpcObjClusterV1Cluster) Get(ctx context.Context, objMeta *api.ObjectMeta) (*cluster.Cluster, error) {
	a.logger.DebugLog("msg", "received call", "object", "Cluster", "oper", "get")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := cluster.Cluster{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoGetCluster(nctx, &in)
}

func (a *grpcObjClusterV1Cluster) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*cluster.Cluster, error) {
	a.logger.DebugLog("msg", "received call", "object", "Cluster", "oper", "delete")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := cluster.Cluster{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoDeleteCluster(nctx, &in)
}

func (a *grpcObjClusterV1Cluster) List(ctx context.Context, options *api.ListWatchOptions) ([]*cluster.Cluster, error) {
	a.logger.DebugLog("msg", "received call", "object", "Cluster", "oper", "list")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	r, err := a.client.AutoListCluster(nctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *grpcObjClusterV1Cluster) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	a.logger.DebugLog("msg", "received call", "object", "Cluster", "oper", "WatchOper")
	nctx := addVersion(ctx, "v1")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	stream, err := a.client.AutoWatchCluster(nctx, options)
	if err != nil {
		return nil, err
	}
	wstream := stream.(cluster.ClusterV1_AutoWatchClusterClient)
	bridgefn := func(lw *listerwatcher.WatcherClient) {
		for {
			r, err := wstream.Recv()
			if err != nil {
				a.logger.ErrorLog("msg", "error on receive", "error", err)
				close(lw.OutCh)
				return
			}
			for _, e := range r.Events {
				ev := kvstore.WatchEvent{
					Type:   kvstore.WatchEventType(e.Type),
					Object: e.Object,
				}
				select {
				case lw.OutCh <- &ev:
				case <-wstream.Context().Done():
					close(lw.OutCh)
					return
				}
			}
		}
	}
	lw := listerwatcher.NewWatcherClient(wstream, bridgefn)
	lw.Run()
	return lw, nil
}

func (a *grpcObjClusterV1Cluster) AuthBootstrapComplete(ctx context.Context, in *cluster.ClusterAuthBootstrapRequest) (*cluster.Cluster, error) {
	a.logger.DebugLog("msg", "received call", "object", "{AuthBootstrapComplete ClusterAuthBootstrapRequest Cluster}", "oper", "AuthBootstrapComplete")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AuthBootstrapComplete(nctx, in)
}

func (a *grpcObjClusterV1Cluster) Allowed(oper apiserver.APIOperType) bool {
	return true
}

type restObjClusterV1Cluster struct {
	endpoints cluster.EndpointsClusterV1RestClient
	instance  string
}

func (a *restObjClusterV1Cluster) Create(ctx context.Context, in *cluster.Cluster) (*cluster.Cluster, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoAddCluster(ctx, in)
}

func (a *restObjClusterV1Cluster) Update(ctx context.Context, in *cluster.Cluster) (*cluster.Cluster, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoUpdateCluster(ctx, in)
}

func (a *restObjClusterV1Cluster) Get(ctx context.Context, objMeta *api.ObjectMeta) (*cluster.Cluster, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := cluster.Cluster{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoGetCluster(ctx, &in)
}

func (a *restObjClusterV1Cluster) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*cluster.Cluster, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := cluster.Cluster{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoDeleteCluster(ctx, &in)
}

func (a *restObjClusterV1Cluster) List(ctx context.Context, options *api.ListWatchOptions) ([]*cluster.Cluster, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}

	r, err := a.endpoints.AutoListCluster(ctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *restObjClusterV1Cluster) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}
	// XXX-TODO(sanjayt): add rest client handler for chunked stream
	return nil, nil
}

func (a *restObjClusterV1Cluster) Allowed(oper apiserver.APIOperType) bool {
	switch oper {
	case apiserver.CreateOper:
		return false
	case apiserver.UpdateOper:
		return true
	case apiserver.GetOper:
		return true
	case apiserver.DeleteOper:
		return true
	case apiserver.ListOper:
		return false
	case apiserver.WatchOper:
		return true
	default:
		return false
	}
}

func (a *restObjClusterV1Cluster) AuthBootstrapComplete(ctx context.Context, in *cluster.ClusterAuthBootstrapRequest) (*cluster.Cluster, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AuthBootstrapCompleteCluster(ctx, in)
}

type grpcObjClusterV1Node struct {
	logger log.Logger
	client cluster.ServiceClusterV1Client
}

func (a *grpcObjClusterV1Node) Create(ctx context.Context, in *cluster.Node) (*cluster.Node, error) {
	a.logger.DebugLog("msg", "received call", "object", "Node", "oper", "create")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoAddNode(nctx, in)
}

func (a *grpcObjClusterV1Node) Update(ctx context.Context, in *cluster.Node) (*cluster.Node, error) {
	a.logger.DebugLog("msg", "received call", "object", "Node", "oper", "update")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoUpdateNode(nctx, in)
}

func (a *grpcObjClusterV1Node) Get(ctx context.Context, objMeta *api.ObjectMeta) (*cluster.Node, error) {
	a.logger.DebugLog("msg", "received call", "object", "Node", "oper", "get")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := cluster.Node{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoGetNode(nctx, &in)
}

func (a *grpcObjClusterV1Node) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*cluster.Node, error) {
	a.logger.DebugLog("msg", "received call", "object", "Node", "oper", "delete")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := cluster.Node{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoDeleteNode(nctx, &in)
}

func (a *grpcObjClusterV1Node) List(ctx context.Context, options *api.ListWatchOptions) ([]*cluster.Node, error) {
	a.logger.DebugLog("msg", "received call", "object", "Node", "oper", "list")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	r, err := a.client.AutoListNode(nctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *grpcObjClusterV1Node) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	a.logger.DebugLog("msg", "received call", "object", "Node", "oper", "WatchOper")
	nctx := addVersion(ctx, "v1")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	stream, err := a.client.AutoWatchNode(nctx, options)
	if err != nil {
		return nil, err
	}
	wstream := stream.(cluster.ClusterV1_AutoWatchNodeClient)
	bridgefn := func(lw *listerwatcher.WatcherClient) {
		for {
			r, err := wstream.Recv()
			if err != nil {
				a.logger.ErrorLog("msg", "error on receive", "error", err)
				close(lw.OutCh)
				return
			}
			for _, e := range r.Events {
				ev := kvstore.WatchEvent{
					Type:   kvstore.WatchEventType(e.Type),
					Object: e.Object,
				}
				select {
				case lw.OutCh <- &ev:
				case <-wstream.Context().Done():
					close(lw.OutCh)
					return
				}
			}
		}
	}
	lw := listerwatcher.NewWatcherClient(wstream, bridgefn)
	lw.Run()
	return lw, nil
}

func (a *grpcObjClusterV1Node) Allowed(oper apiserver.APIOperType) bool {
	return true
}

type restObjClusterV1Node struct {
	endpoints cluster.EndpointsClusterV1RestClient
	instance  string
}

func (a *restObjClusterV1Node) Create(ctx context.Context, in *cluster.Node) (*cluster.Node, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoAddNode(ctx, in)
}

func (a *restObjClusterV1Node) Update(ctx context.Context, in *cluster.Node) (*cluster.Node, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoUpdateNode(ctx, in)
}

func (a *restObjClusterV1Node) Get(ctx context.Context, objMeta *api.ObjectMeta) (*cluster.Node, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := cluster.Node{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoGetNode(ctx, &in)
}

func (a *restObjClusterV1Node) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*cluster.Node, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := cluster.Node{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoDeleteNode(ctx, &in)
}

func (a *restObjClusterV1Node) List(ctx context.Context, options *api.ListWatchOptions) ([]*cluster.Node, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}

	r, err := a.endpoints.AutoListNode(ctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *restObjClusterV1Node) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}
	// XXX-TODO(sanjayt): add rest client handler for chunked stream
	return nil, nil
}

func (a *restObjClusterV1Node) Allowed(oper apiserver.APIOperType) bool {
	switch oper {
	case apiserver.CreateOper:
		return true
	case apiserver.UpdateOper:
		return true
	case apiserver.GetOper:
		return true
	case apiserver.DeleteOper:
		return true
	case apiserver.ListOper:
		return true
	case apiserver.WatchOper:
		return true
	default:
		return false
	}
}

type grpcObjClusterV1Host struct {
	logger log.Logger
	client cluster.ServiceClusterV1Client
}

func (a *grpcObjClusterV1Host) Create(ctx context.Context, in *cluster.Host) (*cluster.Host, error) {
	a.logger.DebugLog("msg", "received call", "object", "Host", "oper", "create")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoAddHost(nctx, in)
}

func (a *grpcObjClusterV1Host) Update(ctx context.Context, in *cluster.Host) (*cluster.Host, error) {
	a.logger.DebugLog("msg", "received call", "object", "Host", "oper", "update")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoUpdateHost(nctx, in)
}

func (a *grpcObjClusterV1Host) Get(ctx context.Context, objMeta *api.ObjectMeta) (*cluster.Host, error) {
	a.logger.DebugLog("msg", "received call", "object", "Host", "oper", "get")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := cluster.Host{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoGetHost(nctx, &in)
}

func (a *grpcObjClusterV1Host) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*cluster.Host, error) {
	a.logger.DebugLog("msg", "received call", "object", "Host", "oper", "delete")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := cluster.Host{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoDeleteHost(nctx, &in)
}

func (a *grpcObjClusterV1Host) List(ctx context.Context, options *api.ListWatchOptions) ([]*cluster.Host, error) {
	a.logger.DebugLog("msg", "received call", "object", "Host", "oper", "list")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	r, err := a.client.AutoListHost(nctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *grpcObjClusterV1Host) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	a.logger.DebugLog("msg", "received call", "object", "Host", "oper", "WatchOper")
	nctx := addVersion(ctx, "v1")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	stream, err := a.client.AutoWatchHost(nctx, options)
	if err != nil {
		return nil, err
	}
	wstream := stream.(cluster.ClusterV1_AutoWatchHostClient)
	bridgefn := func(lw *listerwatcher.WatcherClient) {
		for {
			r, err := wstream.Recv()
			if err != nil {
				a.logger.ErrorLog("msg", "error on receive", "error", err)
				close(lw.OutCh)
				return
			}
			for _, e := range r.Events {
				ev := kvstore.WatchEvent{
					Type:   kvstore.WatchEventType(e.Type),
					Object: e.Object,
				}
				select {
				case lw.OutCh <- &ev:
				case <-wstream.Context().Done():
					close(lw.OutCh)
					return
				}
			}
		}
	}
	lw := listerwatcher.NewWatcherClient(wstream, bridgefn)
	lw.Run()
	return lw, nil
}

func (a *grpcObjClusterV1Host) Allowed(oper apiserver.APIOperType) bool {
	return true
}

type restObjClusterV1Host struct {
	endpoints cluster.EndpointsClusterV1RestClient
	instance  string
}

func (a *restObjClusterV1Host) Create(ctx context.Context, in *cluster.Host) (*cluster.Host, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoAddHost(ctx, in)
}

func (a *restObjClusterV1Host) Update(ctx context.Context, in *cluster.Host) (*cluster.Host, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoUpdateHost(ctx, in)
}

func (a *restObjClusterV1Host) Get(ctx context.Context, objMeta *api.ObjectMeta) (*cluster.Host, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := cluster.Host{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoGetHost(ctx, &in)
}

func (a *restObjClusterV1Host) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*cluster.Host, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := cluster.Host{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoDeleteHost(ctx, &in)
}

func (a *restObjClusterV1Host) List(ctx context.Context, options *api.ListWatchOptions) ([]*cluster.Host, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}

	r, err := a.endpoints.AutoListHost(ctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *restObjClusterV1Host) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}
	// XXX-TODO(sanjayt): add rest client handler for chunked stream
	return nil, nil
}

func (a *restObjClusterV1Host) Allowed(oper apiserver.APIOperType) bool {
	switch oper {
	case apiserver.CreateOper:
		return true
	case apiserver.UpdateOper:
		return true
	case apiserver.GetOper:
		return true
	case apiserver.DeleteOper:
		return true
	case apiserver.ListOper:
		return true
	case apiserver.WatchOper:
		return true
	default:
		return false
	}
}

type grpcObjClusterV1SmartNIC struct {
	logger log.Logger
	client cluster.ServiceClusterV1Client
}

func (a *grpcObjClusterV1SmartNIC) Create(ctx context.Context, in *cluster.SmartNIC) (*cluster.SmartNIC, error) {
	a.logger.DebugLog("msg", "received call", "object", "SmartNIC", "oper", "create")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoAddSmartNIC(nctx, in)
}

func (a *grpcObjClusterV1SmartNIC) Update(ctx context.Context, in *cluster.SmartNIC) (*cluster.SmartNIC, error) {
	a.logger.DebugLog("msg", "received call", "object", "SmartNIC", "oper", "update")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoUpdateSmartNIC(nctx, in)
}

func (a *grpcObjClusterV1SmartNIC) Get(ctx context.Context, objMeta *api.ObjectMeta) (*cluster.SmartNIC, error) {
	a.logger.DebugLog("msg", "received call", "object", "SmartNIC", "oper", "get")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := cluster.SmartNIC{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoGetSmartNIC(nctx, &in)
}

func (a *grpcObjClusterV1SmartNIC) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*cluster.SmartNIC, error) {
	a.logger.DebugLog("msg", "received call", "object", "SmartNIC", "oper", "delete")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := cluster.SmartNIC{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoDeleteSmartNIC(nctx, &in)
}

func (a *grpcObjClusterV1SmartNIC) List(ctx context.Context, options *api.ListWatchOptions) ([]*cluster.SmartNIC, error) {
	a.logger.DebugLog("msg", "received call", "object", "SmartNIC", "oper", "list")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	r, err := a.client.AutoListSmartNIC(nctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *grpcObjClusterV1SmartNIC) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	a.logger.DebugLog("msg", "received call", "object", "SmartNIC", "oper", "WatchOper")
	nctx := addVersion(ctx, "v1")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	stream, err := a.client.AutoWatchSmartNIC(nctx, options)
	if err != nil {
		return nil, err
	}
	wstream := stream.(cluster.ClusterV1_AutoWatchSmartNICClient)
	bridgefn := func(lw *listerwatcher.WatcherClient) {
		for {
			r, err := wstream.Recv()
			if err != nil {
				a.logger.ErrorLog("msg", "error on receive", "error", err)
				close(lw.OutCh)
				return
			}
			for _, e := range r.Events {
				ev := kvstore.WatchEvent{
					Type:   kvstore.WatchEventType(e.Type),
					Object: e.Object,
				}
				select {
				case lw.OutCh <- &ev:
				case <-wstream.Context().Done():
					close(lw.OutCh)
					return
				}
			}
		}
	}
	lw := listerwatcher.NewWatcherClient(wstream, bridgefn)
	lw.Run()
	return lw, nil
}

func (a *grpcObjClusterV1SmartNIC) Allowed(oper apiserver.APIOperType) bool {
	return true
}

type restObjClusterV1SmartNIC struct {
	endpoints cluster.EndpointsClusterV1RestClient
	instance  string
}

func (a *restObjClusterV1SmartNIC) Create(ctx context.Context, in *cluster.SmartNIC) (*cluster.SmartNIC, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoAddSmartNIC(ctx, in)
}

func (a *restObjClusterV1SmartNIC) Update(ctx context.Context, in *cluster.SmartNIC) (*cluster.SmartNIC, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoUpdateSmartNIC(ctx, in)
}

func (a *restObjClusterV1SmartNIC) Get(ctx context.Context, objMeta *api.ObjectMeta) (*cluster.SmartNIC, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := cluster.SmartNIC{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoGetSmartNIC(ctx, &in)
}

func (a *restObjClusterV1SmartNIC) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*cluster.SmartNIC, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := cluster.SmartNIC{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoDeleteSmartNIC(ctx, &in)
}

func (a *restObjClusterV1SmartNIC) List(ctx context.Context, options *api.ListWatchOptions) ([]*cluster.SmartNIC, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}

	r, err := a.endpoints.AutoListSmartNIC(ctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *restObjClusterV1SmartNIC) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}
	// XXX-TODO(sanjayt): add rest client handler for chunked stream
	return nil, nil
}

func (a *restObjClusterV1SmartNIC) Allowed(oper apiserver.APIOperType) bool {
	switch oper {
	case apiserver.CreateOper:
		return false
	case apiserver.UpdateOper:
		return true
	case apiserver.GetOper:
		return true
	case apiserver.DeleteOper:
		return true
	case apiserver.ListOper:
		return true
	case apiserver.WatchOper:
		return true
	default:
		return false
	}
}

type grpcObjClusterV1Tenant struct {
	logger log.Logger
	client cluster.ServiceClusterV1Client
}

func (a *grpcObjClusterV1Tenant) Create(ctx context.Context, in *cluster.Tenant) (*cluster.Tenant, error) {
	a.logger.DebugLog("msg", "received call", "object", "Tenant", "oper", "create")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoAddTenant(nctx, in)
}

func (a *grpcObjClusterV1Tenant) Update(ctx context.Context, in *cluster.Tenant) (*cluster.Tenant, error) {
	a.logger.DebugLog("msg", "received call", "object", "Tenant", "oper", "update")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoUpdateTenant(nctx, in)
}

func (a *grpcObjClusterV1Tenant) Get(ctx context.Context, objMeta *api.ObjectMeta) (*cluster.Tenant, error) {
	a.logger.DebugLog("msg", "received call", "object", "Tenant", "oper", "get")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := cluster.Tenant{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoGetTenant(nctx, &in)
}

func (a *grpcObjClusterV1Tenant) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*cluster.Tenant, error) {
	a.logger.DebugLog("msg", "received call", "object", "Tenant", "oper", "delete")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := cluster.Tenant{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoDeleteTenant(nctx, &in)
}

func (a *grpcObjClusterV1Tenant) List(ctx context.Context, options *api.ListWatchOptions) ([]*cluster.Tenant, error) {
	a.logger.DebugLog("msg", "received call", "object", "Tenant", "oper", "list")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	r, err := a.client.AutoListTenant(nctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *grpcObjClusterV1Tenant) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	a.logger.DebugLog("msg", "received call", "object", "Tenant", "oper", "WatchOper")
	nctx := addVersion(ctx, "v1")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	stream, err := a.client.AutoWatchTenant(nctx, options)
	if err != nil {
		return nil, err
	}
	wstream := stream.(cluster.ClusterV1_AutoWatchTenantClient)
	bridgefn := func(lw *listerwatcher.WatcherClient) {
		for {
			r, err := wstream.Recv()
			if err != nil {
				a.logger.ErrorLog("msg", "error on receive", "error", err)
				close(lw.OutCh)
				return
			}
			for _, e := range r.Events {
				ev := kvstore.WatchEvent{
					Type:   kvstore.WatchEventType(e.Type),
					Object: e.Object,
				}
				select {
				case lw.OutCh <- &ev:
				case <-wstream.Context().Done():
					close(lw.OutCh)
					return
				}
			}
		}
	}
	lw := listerwatcher.NewWatcherClient(wstream, bridgefn)
	lw.Run()
	return lw, nil
}

func (a *grpcObjClusterV1Tenant) Allowed(oper apiserver.APIOperType) bool {
	return true
}

type restObjClusterV1Tenant struct {
	endpoints cluster.EndpointsClusterV1RestClient
	instance  string
}

func (a *restObjClusterV1Tenant) Create(ctx context.Context, in *cluster.Tenant) (*cluster.Tenant, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoAddTenant(ctx, in)
}

func (a *restObjClusterV1Tenant) Update(ctx context.Context, in *cluster.Tenant) (*cluster.Tenant, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoUpdateTenant(ctx, in)
}

func (a *restObjClusterV1Tenant) Get(ctx context.Context, objMeta *api.ObjectMeta) (*cluster.Tenant, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := cluster.Tenant{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoGetTenant(ctx, &in)
}

func (a *restObjClusterV1Tenant) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*cluster.Tenant, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := cluster.Tenant{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoDeleteTenant(ctx, &in)
}

func (a *restObjClusterV1Tenant) List(ctx context.Context, options *api.ListWatchOptions) ([]*cluster.Tenant, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}

	r, err := a.endpoints.AutoListTenant(ctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *restObjClusterV1Tenant) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}
	// XXX-TODO(sanjayt): add rest client handler for chunked stream
	return nil, nil
}

func (a *restObjClusterV1Tenant) Allowed(oper apiserver.APIOperType) bool {
	switch oper {
	case apiserver.CreateOper:
		return true
	case apiserver.UpdateOper:
		return true
	case apiserver.GetOper:
		return true
	case apiserver.DeleteOper:
		return true
	case apiserver.ListOper:
		return true
	case apiserver.WatchOper:
		return true
	default:
		return false
	}
}

type crudClientClusterV1 struct {
	logger log.Logger
	client cluster.ServiceClusterV1Client

	grpcCluster  cluster.ClusterV1ClusterInterface
	grpcNode     cluster.ClusterV1NodeInterface
	grpcHost     cluster.ClusterV1HostInterface
	grpcSmartNIC cluster.ClusterV1SmartNICInterface
	grpcTenant   cluster.ClusterV1TenantInterface
}

// NewGrpcCrudClientClusterV1 creates a GRPC client for the service
func NewGrpcCrudClientClusterV1(conn *grpc.ClientConn, logger log.Logger) cluster.ClusterV1Interface {
	client := NewClusterV1Backend(conn, logger)
	return &crudClientClusterV1{
		logger: logger,
		client: client,

		grpcCluster:  &grpcObjClusterV1Cluster{client: client, logger: logger},
		grpcNode:     &grpcObjClusterV1Node{client: client, logger: logger},
		grpcHost:     &grpcObjClusterV1Host{client: client, logger: logger},
		grpcSmartNIC: &grpcObjClusterV1SmartNIC{client: client, logger: logger},
		grpcTenant:   &grpcObjClusterV1Tenant{client: client, logger: logger},
	}
}

func (a *crudClientClusterV1) Cluster() cluster.ClusterV1ClusterInterface {
	return a.grpcCluster
}

func (a *crudClientClusterV1) Node() cluster.ClusterV1NodeInterface {
	return a.grpcNode
}

func (a *crudClientClusterV1) Host() cluster.ClusterV1HostInterface {
	return a.grpcHost
}

func (a *crudClientClusterV1) SmartNIC() cluster.ClusterV1SmartNICInterface {
	return a.grpcSmartNIC
}

func (a *crudClientClusterV1) Tenant() cluster.ClusterV1TenantInterface {
	return a.grpcTenant
}

func (a *crudClientClusterV1) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	a.logger.DebugLog("msg", "received call", "object", "ClusterV1", "oper", "WatchOper")
	nctx := addVersion(ctx, "v1")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	stream, err := a.client.AutoWatchSvcClusterV1(nctx, options)
	if err != nil {
		return nil, err
	}
	wstream := stream.(cluster.ClusterV1_AutoWatchSvcClusterV1Client)
	bridgefn := func(lw *listerwatcher.WatcherClient) {
		for {
			r, err := wstream.Recv()
			if err != nil {
				a.logger.ErrorLog("msg", "error on receive", "error", err)
				close(lw.OutCh)
				return
			}
			for _, e := range r.Events {
				ev := kvstore.WatchEvent{Type: kvstore.WatchEventType(e.Type)}
				robj, err := listerwatcher.GetObject(e)
				if err != nil {
					a.logger.ErrorLog("msg", "error on receive unmarshall", "error", err)
					close(lw.OutCh)
					return
				}
				ev.Object = robj
				select {
				case lw.OutCh <- &ev:
				case <-wstream.Context().Done():
					close(lw.OutCh)
					return
				}
			}
		}
	}
	lw := listerwatcher.NewWatcherClient(wstream, bridgefn)
	lw.Run()
	return lw, nil
}

type crudRestClientClusterV1 struct {
	restCluster  cluster.ClusterV1ClusterInterface
	restNode     cluster.ClusterV1NodeInterface
	restHost     cluster.ClusterV1HostInterface
	restSmartNIC cluster.ClusterV1SmartNICInterface
	restTenant   cluster.ClusterV1TenantInterface
}

// NewRestCrudClientClusterV1 creates a REST client for the service.
func NewRestCrudClientClusterV1(url string) cluster.ClusterV1Interface {
	endpoints, err := cluster.MakeClusterV1RestClientEndpoints(url)
	if err != nil {
		oldlog.Fatal("failed to create client")
	}
	return &crudRestClientClusterV1{

		restCluster:  &restObjClusterV1Cluster{endpoints: endpoints, instance: url},
		restNode:     &restObjClusterV1Node{endpoints: endpoints, instance: url},
		restHost:     &restObjClusterV1Host{endpoints: endpoints, instance: url},
		restSmartNIC: &restObjClusterV1SmartNIC{endpoints: endpoints, instance: url},
		restTenant:   &restObjClusterV1Tenant{endpoints: endpoints, instance: url},
	}
}

// NewStagedRestCrudClientClusterV1 creates a REST client for the service.
func NewStagedRestCrudClientClusterV1(url string, id string) cluster.ClusterV1Interface {
	endpoints, err := cluster.MakeClusterV1StagedRestClientEndpoints(url, id)
	if err != nil {
		oldlog.Fatal("failed to create client")
	}
	return &crudRestClientClusterV1{

		restCluster:  &restObjClusterV1Cluster{endpoints: endpoints, instance: url},
		restNode:     &restObjClusterV1Node{endpoints: endpoints, instance: url},
		restHost:     &restObjClusterV1Host{endpoints: endpoints, instance: url},
		restSmartNIC: &restObjClusterV1SmartNIC{endpoints: endpoints, instance: url},
		restTenant:   &restObjClusterV1Tenant{endpoints: endpoints, instance: url},
	}
}

func (a *crudRestClientClusterV1) Cluster() cluster.ClusterV1ClusterInterface {
	return a.restCluster
}

func (a *crudRestClientClusterV1) Node() cluster.ClusterV1NodeInterface {
	return a.restNode
}

func (a *crudRestClientClusterV1) Host() cluster.ClusterV1HostInterface {
	return a.restHost
}

func (a *crudRestClientClusterV1) SmartNIC() cluster.ClusterV1SmartNICInterface {
	return a.restSmartNIC
}

func (a *crudRestClientClusterV1) Tenant() cluster.ClusterV1TenantInterface {
	return a.restTenant
}

func (a *crudRestClientClusterV1) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	return nil, errors.New("method unimplemented")
}
