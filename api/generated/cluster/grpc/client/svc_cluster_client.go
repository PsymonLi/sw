// Code generated by protoc-gen-grpc-pensando DO NOT EDIT.

package grpcclient

import (
	"context"
	"errors"
	oldlog "log"
	"net/http"

	"github.com/go-kit/kit/endpoint"
	grpctransport "github.com/go-kit/kit/transport/grpc"
	"google.golang.org/grpc"

	api "github.com/pensando/sw/api"
	cluster "github.com/pensando/sw/api/generated/cluster"
	"github.com/pensando/sw/api/interfaces"
	listerwatcher "github.com/pensando/sw/api/listerwatcher"
	"github.com/pensando/sw/venice/utils/kvstore"
	"github.com/pensando/sw/venice/utils/log"
	"github.com/pensando/sw/venice/utils/trace"
)

// Dummy vars to suppress import errors
var _ api.TypeMeta
var _ listerwatcher.WatcherClient
var _ kvstore.Interface

// NewClusterV1 sets up a new client for ClusterV1
func NewClusterV1(conn *grpc.ClientConn, logger log.Logger) cluster.ServiceClusterV1Client {

	var lAuthBootstrapCompleteEndpoint endpoint.Endpoint
	{
		lAuthBootstrapCompleteEndpoint = grpctransport.NewClient(
			conn,
			"cluster.ClusterV1",
			"AuthBootstrapComplete",
			cluster.EncodeGrpcReqClusterAuthBootstrapRequest,
			cluster.DecodeGrpcRespCluster,
			&cluster.Cluster{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAuthBootstrapCompleteEndpoint = trace.ClientEndPoint("ClusterV1:AuthBootstrapComplete")(lAuthBootstrapCompleteEndpoint)
	}
	var lAutoAddClusterEndpoint endpoint.Endpoint
	{
		lAutoAddClusterEndpoint = grpctransport.NewClient(
			conn,
			"cluster.ClusterV1",
			"AutoAddCluster",
			cluster.EncodeGrpcReqCluster,
			cluster.DecodeGrpcRespCluster,
			&cluster.Cluster{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoAddClusterEndpoint = trace.ClientEndPoint("ClusterV1:AutoAddCluster")(lAutoAddClusterEndpoint)
	}
	var lAutoAddConfigurationSnapshotEndpoint endpoint.Endpoint
	{
		lAutoAddConfigurationSnapshotEndpoint = grpctransport.NewClient(
			conn,
			"cluster.ClusterV1",
			"AutoAddConfigurationSnapshot",
			cluster.EncodeGrpcReqConfigurationSnapshot,
			cluster.DecodeGrpcRespConfigurationSnapshot,
			&cluster.ConfigurationSnapshot{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoAddConfigurationSnapshotEndpoint = trace.ClientEndPoint("ClusterV1:AutoAddConfigurationSnapshot")(lAutoAddConfigurationSnapshotEndpoint)
	}
	var lAutoAddDSCProfileEndpoint endpoint.Endpoint
	{
		lAutoAddDSCProfileEndpoint = grpctransport.NewClient(
			conn,
			"cluster.ClusterV1",
			"AutoAddDSCProfile",
			cluster.EncodeGrpcReqDSCProfile,
			cluster.DecodeGrpcRespDSCProfile,
			&cluster.DSCProfile{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoAddDSCProfileEndpoint = trace.ClientEndPoint("ClusterV1:AutoAddDSCProfile")(lAutoAddDSCProfileEndpoint)
	}
	var lAutoAddDistributedServiceCardEndpoint endpoint.Endpoint
	{
		lAutoAddDistributedServiceCardEndpoint = grpctransport.NewClient(
			conn,
			"cluster.ClusterV1",
			"AutoAddDistributedServiceCard",
			cluster.EncodeGrpcReqDistributedServiceCard,
			cluster.DecodeGrpcRespDistributedServiceCard,
			&cluster.DistributedServiceCard{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoAddDistributedServiceCardEndpoint = trace.ClientEndPoint("ClusterV1:AutoAddDistributedServiceCard")(lAutoAddDistributedServiceCardEndpoint)
	}
	var lAutoAddHostEndpoint endpoint.Endpoint
	{
		lAutoAddHostEndpoint = grpctransport.NewClient(
			conn,
			"cluster.ClusterV1",
			"AutoAddHost",
			cluster.EncodeGrpcReqHost,
			cluster.DecodeGrpcRespHost,
			&cluster.Host{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoAddHostEndpoint = trace.ClientEndPoint("ClusterV1:AutoAddHost")(lAutoAddHostEndpoint)
	}
	var lAutoAddLicenseEndpoint endpoint.Endpoint
	{
		lAutoAddLicenseEndpoint = grpctransport.NewClient(
			conn,
			"cluster.ClusterV1",
			"AutoAddLicense",
			cluster.EncodeGrpcReqLicense,
			cluster.DecodeGrpcRespLicense,
			&cluster.License{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoAddLicenseEndpoint = trace.ClientEndPoint("ClusterV1:AutoAddLicense")(lAutoAddLicenseEndpoint)
	}
	var lAutoAddNodeEndpoint endpoint.Endpoint
	{
		lAutoAddNodeEndpoint = grpctransport.NewClient(
			conn,
			"cluster.ClusterV1",
			"AutoAddNode",
			cluster.EncodeGrpcReqNode,
			cluster.DecodeGrpcRespNode,
			&cluster.Node{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoAddNodeEndpoint = trace.ClientEndPoint("ClusterV1:AutoAddNode")(lAutoAddNodeEndpoint)
	}
	var lAutoAddSnapshotRestoreEndpoint endpoint.Endpoint
	{
		lAutoAddSnapshotRestoreEndpoint = grpctransport.NewClient(
			conn,
			"cluster.ClusterV1",
			"AutoAddSnapshotRestore",
			cluster.EncodeGrpcReqSnapshotRestore,
			cluster.DecodeGrpcRespSnapshotRestore,
			&cluster.SnapshotRestore{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoAddSnapshotRestoreEndpoint = trace.ClientEndPoint("ClusterV1:AutoAddSnapshotRestore")(lAutoAddSnapshotRestoreEndpoint)
	}
	var lAutoAddTenantEndpoint endpoint.Endpoint
	{
		lAutoAddTenantEndpoint = grpctransport.NewClient(
			conn,
			"cluster.ClusterV1",
			"AutoAddTenant",
			cluster.EncodeGrpcReqTenant,
			cluster.DecodeGrpcRespTenant,
			&cluster.Tenant{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoAddTenantEndpoint = trace.ClientEndPoint("ClusterV1:AutoAddTenant")(lAutoAddTenantEndpoint)
	}
	var lAutoAddVersionEndpoint endpoint.Endpoint
	{
		lAutoAddVersionEndpoint = grpctransport.NewClient(
			conn,
			"cluster.ClusterV1",
			"AutoAddVersion",
			cluster.EncodeGrpcReqVersion,
			cluster.DecodeGrpcRespVersion,
			&cluster.Version{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoAddVersionEndpoint = trace.ClientEndPoint("ClusterV1:AutoAddVersion")(lAutoAddVersionEndpoint)
	}
	var lAutoDeleteClusterEndpoint endpoint.Endpoint
	{
		lAutoDeleteClusterEndpoint = grpctransport.NewClient(
			conn,
			"cluster.ClusterV1",
			"AutoDeleteCluster",
			cluster.EncodeGrpcReqCluster,
			cluster.DecodeGrpcRespCluster,
			&cluster.Cluster{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoDeleteClusterEndpoint = trace.ClientEndPoint("ClusterV1:AutoDeleteCluster")(lAutoDeleteClusterEndpoint)
	}
	var lAutoDeleteConfigurationSnapshotEndpoint endpoint.Endpoint
	{
		lAutoDeleteConfigurationSnapshotEndpoint = grpctransport.NewClient(
			conn,
			"cluster.ClusterV1",
			"AutoDeleteConfigurationSnapshot",
			cluster.EncodeGrpcReqConfigurationSnapshot,
			cluster.DecodeGrpcRespConfigurationSnapshot,
			&cluster.ConfigurationSnapshot{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoDeleteConfigurationSnapshotEndpoint = trace.ClientEndPoint("ClusterV1:AutoDeleteConfigurationSnapshot")(lAutoDeleteConfigurationSnapshotEndpoint)
	}
	var lAutoDeleteDSCProfileEndpoint endpoint.Endpoint
	{
		lAutoDeleteDSCProfileEndpoint = grpctransport.NewClient(
			conn,
			"cluster.ClusterV1",
			"AutoDeleteDSCProfile",
			cluster.EncodeGrpcReqDSCProfile,
			cluster.DecodeGrpcRespDSCProfile,
			&cluster.DSCProfile{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoDeleteDSCProfileEndpoint = trace.ClientEndPoint("ClusterV1:AutoDeleteDSCProfile")(lAutoDeleteDSCProfileEndpoint)
	}
	var lAutoDeleteDistributedServiceCardEndpoint endpoint.Endpoint
	{
		lAutoDeleteDistributedServiceCardEndpoint = grpctransport.NewClient(
			conn,
			"cluster.ClusterV1",
			"AutoDeleteDistributedServiceCard",
			cluster.EncodeGrpcReqDistributedServiceCard,
			cluster.DecodeGrpcRespDistributedServiceCard,
			&cluster.DistributedServiceCard{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoDeleteDistributedServiceCardEndpoint = trace.ClientEndPoint("ClusterV1:AutoDeleteDistributedServiceCard")(lAutoDeleteDistributedServiceCardEndpoint)
	}
	var lAutoDeleteHostEndpoint endpoint.Endpoint
	{
		lAutoDeleteHostEndpoint = grpctransport.NewClient(
			conn,
			"cluster.ClusterV1",
			"AutoDeleteHost",
			cluster.EncodeGrpcReqHost,
			cluster.DecodeGrpcRespHost,
			&cluster.Host{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoDeleteHostEndpoint = trace.ClientEndPoint("ClusterV1:AutoDeleteHost")(lAutoDeleteHostEndpoint)
	}
	var lAutoDeleteLicenseEndpoint endpoint.Endpoint
	{
		lAutoDeleteLicenseEndpoint = grpctransport.NewClient(
			conn,
			"cluster.ClusterV1",
			"AutoDeleteLicense",
			cluster.EncodeGrpcReqLicense,
			cluster.DecodeGrpcRespLicense,
			&cluster.License{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoDeleteLicenseEndpoint = trace.ClientEndPoint("ClusterV1:AutoDeleteLicense")(lAutoDeleteLicenseEndpoint)
	}
	var lAutoDeleteNodeEndpoint endpoint.Endpoint
	{
		lAutoDeleteNodeEndpoint = grpctransport.NewClient(
			conn,
			"cluster.ClusterV1",
			"AutoDeleteNode",
			cluster.EncodeGrpcReqNode,
			cluster.DecodeGrpcRespNode,
			&cluster.Node{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoDeleteNodeEndpoint = trace.ClientEndPoint("ClusterV1:AutoDeleteNode")(lAutoDeleteNodeEndpoint)
	}
	var lAutoDeleteSnapshotRestoreEndpoint endpoint.Endpoint
	{
		lAutoDeleteSnapshotRestoreEndpoint = grpctransport.NewClient(
			conn,
			"cluster.ClusterV1",
			"AutoDeleteSnapshotRestore",
			cluster.EncodeGrpcReqSnapshotRestore,
			cluster.DecodeGrpcRespSnapshotRestore,
			&cluster.SnapshotRestore{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoDeleteSnapshotRestoreEndpoint = trace.ClientEndPoint("ClusterV1:AutoDeleteSnapshotRestore")(lAutoDeleteSnapshotRestoreEndpoint)
	}
	var lAutoDeleteTenantEndpoint endpoint.Endpoint
	{
		lAutoDeleteTenantEndpoint = grpctransport.NewClient(
			conn,
			"cluster.ClusterV1",
			"AutoDeleteTenant",
			cluster.EncodeGrpcReqTenant,
			cluster.DecodeGrpcRespTenant,
			&cluster.Tenant{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoDeleteTenantEndpoint = trace.ClientEndPoint("ClusterV1:AutoDeleteTenant")(lAutoDeleteTenantEndpoint)
	}
	var lAutoDeleteVersionEndpoint endpoint.Endpoint
	{
		lAutoDeleteVersionEndpoint = grpctransport.NewClient(
			conn,
			"cluster.ClusterV1",
			"AutoDeleteVersion",
			cluster.EncodeGrpcReqVersion,
			cluster.DecodeGrpcRespVersion,
			&cluster.Version{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoDeleteVersionEndpoint = trace.ClientEndPoint("ClusterV1:AutoDeleteVersion")(lAutoDeleteVersionEndpoint)
	}
	var lAutoGetClusterEndpoint endpoint.Endpoint
	{
		lAutoGetClusterEndpoint = grpctransport.NewClient(
			conn,
			"cluster.ClusterV1",
			"AutoGetCluster",
			cluster.EncodeGrpcReqCluster,
			cluster.DecodeGrpcRespCluster,
			&cluster.Cluster{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoGetClusterEndpoint = trace.ClientEndPoint("ClusterV1:AutoGetCluster")(lAutoGetClusterEndpoint)
	}
	var lAutoGetConfigurationSnapshotEndpoint endpoint.Endpoint
	{
		lAutoGetConfigurationSnapshotEndpoint = grpctransport.NewClient(
			conn,
			"cluster.ClusterV1",
			"AutoGetConfigurationSnapshot",
			cluster.EncodeGrpcReqConfigurationSnapshot,
			cluster.DecodeGrpcRespConfigurationSnapshot,
			&cluster.ConfigurationSnapshot{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoGetConfigurationSnapshotEndpoint = trace.ClientEndPoint("ClusterV1:AutoGetConfigurationSnapshot")(lAutoGetConfigurationSnapshotEndpoint)
	}
	var lAutoGetDSCProfileEndpoint endpoint.Endpoint
	{
		lAutoGetDSCProfileEndpoint = grpctransport.NewClient(
			conn,
			"cluster.ClusterV1",
			"AutoGetDSCProfile",
			cluster.EncodeGrpcReqDSCProfile,
			cluster.DecodeGrpcRespDSCProfile,
			&cluster.DSCProfile{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoGetDSCProfileEndpoint = trace.ClientEndPoint("ClusterV1:AutoGetDSCProfile")(lAutoGetDSCProfileEndpoint)
	}
	var lAutoGetDistributedServiceCardEndpoint endpoint.Endpoint
	{
		lAutoGetDistributedServiceCardEndpoint = grpctransport.NewClient(
			conn,
			"cluster.ClusterV1",
			"AutoGetDistributedServiceCard",
			cluster.EncodeGrpcReqDistributedServiceCard,
			cluster.DecodeGrpcRespDistributedServiceCard,
			&cluster.DistributedServiceCard{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoGetDistributedServiceCardEndpoint = trace.ClientEndPoint("ClusterV1:AutoGetDistributedServiceCard")(lAutoGetDistributedServiceCardEndpoint)
	}
	var lAutoGetHostEndpoint endpoint.Endpoint
	{
		lAutoGetHostEndpoint = grpctransport.NewClient(
			conn,
			"cluster.ClusterV1",
			"AutoGetHost",
			cluster.EncodeGrpcReqHost,
			cluster.DecodeGrpcRespHost,
			&cluster.Host{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoGetHostEndpoint = trace.ClientEndPoint("ClusterV1:AutoGetHost")(lAutoGetHostEndpoint)
	}
	var lAutoGetLicenseEndpoint endpoint.Endpoint
	{
		lAutoGetLicenseEndpoint = grpctransport.NewClient(
			conn,
			"cluster.ClusterV1",
			"AutoGetLicense",
			cluster.EncodeGrpcReqLicense,
			cluster.DecodeGrpcRespLicense,
			&cluster.License{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoGetLicenseEndpoint = trace.ClientEndPoint("ClusterV1:AutoGetLicense")(lAutoGetLicenseEndpoint)
	}
	var lAutoGetNodeEndpoint endpoint.Endpoint
	{
		lAutoGetNodeEndpoint = grpctransport.NewClient(
			conn,
			"cluster.ClusterV1",
			"AutoGetNode",
			cluster.EncodeGrpcReqNode,
			cluster.DecodeGrpcRespNode,
			&cluster.Node{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoGetNodeEndpoint = trace.ClientEndPoint("ClusterV1:AutoGetNode")(lAutoGetNodeEndpoint)
	}
	var lAutoGetSnapshotRestoreEndpoint endpoint.Endpoint
	{
		lAutoGetSnapshotRestoreEndpoint = grpctransport.NewClient(
			conn,
			"cluster.ClusterV1",
			"AutoGetSnapshotRestore",
			cluster.EncodeGrpcReqSnapshotRestore,
			cluster.DecodeGrpcRespSnapshotRestore,
			&cluster.SnapshotRestore{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoGetSnapshotRestoreEndpoint = trace.ClientEndPoint("ClusterV1:AutoGetSnapshotRestore")(lAutoGetSnapshotRestoreEndpoint)
	}
	var lAutoGetTenantEndpoint endpoint.Endpoint
	{
		lAutoGetTenantEndpoint = grpctransport.NewClient(
			conn,
			"cluster.ClusterV1",
			"AutoGetTenant",
			cluster.EncodeGrpcReqTenant,
			cluster.DecodeGrpcRespTenant,
			&cluster.Tenant{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoGetTenantEndpoint = trace.ClientEndPoint("ClusterV1:AutoGetTenant")(lAutoGetTenantEndpoint)
	}
	var lAutoGetVersionEndpoint endpoint.Endpoint
	{
		lAutoGetVersionEndpoint = grpctransport.NewClient(
			conn,
			"cluster.ClusterV1",
			"AutoGetVersion",
			cluster.EncodeGrpcReqVersion,
			cluster.DecodeGrpcRespVersion,
			&cluster.Version{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoGetVersionEndpoint = trace.ClientEndPoint("ClusterV1:AutoGetVersion")(lAutoGetVersionEndpoint)
	}
	var lAutoLabelClusterEndpoint endpoint.Endpoint
	{
		lAutoLabelClusterEndpoint = grpctransport.NewClient(
			conn,
			"cluster.ClusterV1",
			"AutoLabelCluster",
			cluster.EncodeGrpcReqLabel,
			cluster.DecodeGrpcRespCluster,
			&cluster.Cluster{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoLabelClusterEndpoint = trace.ClientEndPoint("ClusterV1:AutoLabelCluster")(lAutoLabelClusterEndpoint)
	}
	var lAutoLabelConfigurationSnapshotEndpoint endpoint.Endpoint
	{
		lAutoLabelConfigurationSnapshotEndpoint = grpctransport.NewClient(
			conn,
			"cluster.ClusterV1",
			"AutoLabelConfigurationSnapshot",
			cluster.EncodeGrpcReqLabel,
			cluster.DecodeGrpcRespConfigurationSnapshot,
			&cluster.ConfigurationSnapshot{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoLabelConfigurationSnapshotEndpoint = trace.ClientEndPoint("ClusterV1:AutoLabelConfigurationSnapshot")(lAutoLabelConfigurationSnapshotEndpoint)
	}
	var lAutoLabelDSCProfileEndpoint endpoint.Endpoint
	{
		lAutoLabelDSCProfileEndpoint = grpctransport.NewClient(
			conn,
			"cluster.ClusterV1",
			"AutoLabelDSCProfile",
			cluster.EncodeGrpcReqLabel,
			cluster.DecodeGrpcRespDSCProfile,
			&cluster.DSCProfile{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoLabelDSCProfileEndpoint = trace.ClientEndPoint("ClusterV1:AutoLabelDSCProfile")(lAutoLabelDSCProfileEndpoint)
	}
	var lAutoLabelDistributedServiceCardEndpoint endpoint.Endpoint
	{
		lAutoLabelDistributedServiceCardEndpoint = grpctransport.NewClient(
			conn,
			"cluster.ClusterV1",
			"AutoLabelDistributedServiceCard",
			cluster.EncodeGrpcReqLabel,
			cluster.DecodeGrpcRespDistributedServiceCard,
			&cluster.DistributedServiceCard{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoLabelDistributedServiceCardEndpoint = trace.ClientEndPoint("ClusterV1:AutoLabelDistributedServiceCard")(lAutoLabelDistributedServiceCardEndpoint)
	}
	var lAutoLabelHostEndpoint endpoint.Endpoint
	{
		lAutoLabelHostEndpoint = grpctransport.NewClient(
			conn,
			"cluster.ClusterV1",
			"AutoLabelHost",
			cluster.EncodeGrpcReqLabel,
			cluster.DecodeGrpcRespHost,
			&cluster.Host{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoLabelHostEndpoint = trace.ClientEndPoint("ClusterV1:AutoLabelHost")(lAutoLabelHostEndpoint)
	}
	var lAutoLabelLicenseEndpoint endpoint.Endpoint
	{
		lAutoLabelLicenseEndpoint = grpctransport.NewClient(
			conn,
			"cluster.ClusterV1",
			"AutoLabelLicense",
			cluster.EncodeGrpcReqLabel,
			cluster.DecodeGrpcRespLicense,
			&cluster.License{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoLabelLicenseEndpoint = trace.ClientEndPoint("ClusterV1:AutoLabelLicense")(lAutoLabelLicenseEndpoint)
	}
	var lAutoLabelNodeEndpoint endpoint.Endpoint
	{
		lAutoLabelNodeEndpoint = grpctransport.NewClient(
			conn,
			"cluster.ClusterV1",
			"AutoLabelNode",
			cluster.EncodeGrpcReqLabel,
			cluster.DecodeGrpcRespNode,
			&cluster.Node{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoLabelNodeEndpoint = trace.ClientEndPoint("ClusterV1:AutoLabelNode")(lAutoLabelNodeEndpoint)
	}
	var lAutoLabelSnapshotRestoreEndpoint endpoint.Endpoint
	{
		lAutoLabelSnapshotRestoreEndpoint = grpctransport.NewClient(
			conn,
			"cluster.ClusterV1",
			"AutoLabelSnapshotRestore",
			cluster.EncodeGrpcReqLabel,
			cluster.DecodeGrpcRespSnapshotRestore,
			&cluster.SnapshotRestore{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoLabelSnapshotRestoreEndpoint = trace.ClientEndPoint("ClusterV1:AutoLabelSnapshotRestore")(lAutoLabelSnapshotRestoreEndpoint)
	}
	var lAutoLabelTenantEndpoint endpoint.Endpoint
	{
		lAutoLabelTenantEndpoint = grpctransport.NewClient(
			conn,
			"cluster.ClusterV1",
			"AutoLabelTenant",
			cluster.EncodeGrpcReqLabel,
			cluster.DecodeGrpcRespTenant,
			&cluster.Tenant{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoLabelTenantEndpoint = trace.ClientEndPoint("ClusterV1:AutoLabelTenant")(lAutoLabelTenantEndpoint)
	}
	var lAutoLabelVersionEndpoint endpoint.Endpoint
	{
		lAutoLabelVersionEndpoint = grpctransport.NewClient(
			conn,
			"cluster.ClusterV1",
			"AutoLabelVersion",
			cluster.EncodeGrpcReqLabel,
			cluster.DecodeGrpcRespVersion,
			&cluster.Version{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoLabelVersionEndpoint = trace.ClientEndPoint("ClusterV1:AutoLabelVersion")(lAutoLabelVersionEndpoint)
	}
	var lAutoListClusterEndpoint endpoint.Endpoint
	{
		lAutoListClusterEndpoint = grpctransport.NewClient(
			conn,
			"cluster.ClusterV1",
			"AutoListCluster",
			cluster.EncodeGrpcReqListWatchOptions,
			cluster.DecodeGrpcRespClusterList,
			&cluster.ClusterList{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoListClusterEndpoint = trace.ClientEndPoint("ClusterV1:AutoListCluster")(lAutoListClusterEndpoint)
	}
	var lAutoListConfigurationSnapshotEndpoint endpoint.Endpoint
	{
		lAutoListConfigurationSnapshotEndpoint = grpctransport.NewClient(
			conn,
			"cluster.ClusterV1",
			"AutoListConfigurationSnapshot",
			cluster.EncodeGrpcReqListWatchOptions,
			cluster.DecodeGrpcRespConfigurationSnapshotList,
			&cluster.ConfigurationSnapshotList{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoListConfigurationSnapshotEndpoint = trace.ClientEndPoint("ClusterV1:AutoListConfigurationSnapshot")(lAutoListConfigurationSnapshotEndpoint)
	}
	var lAutoListDSCProfileEndpoint endpoint.Endpoint
	{
		lAutoListDSCProfileEndpoint = grpctransport.NewClient(
			conn,
			"cluster.ClusterV1",
			"AutoListDSCProfile",
			cluster.EncodeGrpcReqListWatchOptions,
			cluster.DecodeGrpcRespDSCProfileList,
			&cluster.DSCProfileList{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoListDSCProfileEndpoint = trace.ClientEndPoint("ClusterV1:AutoListDSCProfile")(lAutoListDSCProfileEndpoint)
	}
	var lAutoListDistributedServiceCardEndpoint endpoint.Endpoint
	{
		lAutoListDistributedServiceCardEndpoint = grpctransport.NewClient(
			conn,
			"cluster.ClusterV1",
			"AutoListDistributedServiceCard",
			cluster.EncodeGrpcReqListWatchOptions,
			cluster.DecodeGrpcRespDistributedServiceCardList,
			&cluster.DistributedServiceCardList{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoListDistributedServiceCardEndpoint = trace.ClientEndPoint("ClusterV1:AutoListDistributedServiceCard")(lAutoListDistributedServiceCardEndpoint)
	}
	var lAutoListHostEndpoint endpoint.Endpoint
	{
		lAutoListHostEndpoint = grpctransport.NewClient(
			conn,
			"cluster.ClusterV1",
			"AutoListHost",
			cluster.EncodeGrpcReqListWatchOptions,
			cluster.DecodeGrpcRespHostList,
			&cluster.HostList{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoListHostEndpoint = trace.ClientEndPoint("ClusterV1:AutoListHost")(lAutoListHostEndpoint)
	}
	var lAutoListLicenseEndpoint endpoint.Endpoint
	{
		lAutoListLicenseEndpoint = grpctransport.NewClient(
			conn,
			"cluster.ClusterV1",
			"AutoListLicense",
			cluster.EncodeGrpcReqListWatchOptions,
			cluster.DecodeGrpcRespLicenseList,
			&cluster.LicenseList{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoListLicenseEndpoint = trace.ClientEndPoint("ClusterV1:AutoListLicense")(lAutoListLicenseEndpoint)
	}
	var lAutoListNodeEndpoint endpoint.Endpoint
	{
		lAutoListNodeEndpoint = grpctransport.NewClient(
			conn,
			"cluster.ClusterV1",
			"AutoListNode",
			cluster.EncodeGrpcReqListWatchOptions,
			cluster.DecodeGrpcRespNodeList,
			&cluster.NodeList{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoListNodeEndpoint = trace.ClientEndPoint("ClusterV1:AutoListNode")(lAutoListNodeEndpoint)
	}
	var lAutoListSnapshotRestoreEndpoint endpoint.Endpoint
	{
		lAutoListSnapshotRestoreEndpoint = grpctransport.NewClient(
			conn,
			"cluster.ClusterV1",
			"AutoListSnapshotRestore",
			cluster.EncodeGrpcReqListWatchOptions,
			cluster.DecodeGrpcRespSnapshotRestoreList,
			&cluster.SnapshotRestoreList{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoListSnapshotRestoreEndpoint = trace.ClientEndPoint("ClusterV1:AutoListSnapshotRestore")(lAutoListSnapshotRestoreEndpoint)
	}
	var lAutoListTenantEndpoint endpoint.Endpoint
	{
		lAutoListTenantEndpoint = grpctransport.NewClient(
			conn,
			"cluster.ClusterV1",
			"AutoListTenant",
			cluster.EncodeGrpcReqListWatchOptions,
			cluster.DecodeGrpcRespTenantList,
			&cluster.TenantList{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoListTenantEndpoint = trace.ClientEndPoint("ClusterV1:AutoListTenant")(lAutoListTenantEndpoint)
	}
	var lAutoListVersionEndpoint endpoint.Endpoint
	{
		lAutoListVersionEndpoint = grpctransport.NewClient(
			conn,
			"cluster.ClusterV1",
			"AutoListVersion",
			cluster.EncodeGrpcReqListWatchOptions,
			cluster.DecodeGrpcRespVersionList,
			&cluster.VersionList{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoListVersionEndpoint = trace.ClientEndPoint("ClusterV1:AutoListVersion")(lAutoListVersionEndpoint)
	}
	var lAutoUpdateClusterEndpoint endpoint.Endpoint
	{
		lAutoUpdateClusterEndpoint = grpctransport.NewClient(
			conn,
			"cluster.ClusterV1",
			"AutoUpdateCluster",
			cluster.EncodeGrpcReqCluster,
			cluster.DecodeGrpcRespCluster,
			&cluster.Cluster{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoUpdateClusterEndpoint = trace.ClientEndPoint("ClusterV1:AutoUpdateCluster")(lAutoUpdateClusterEndpoint)
	}
	var lAutoUpdateConfigurationSnapshotEndpoint endpoint.Endpoint
	{
		lAutoUpdateConfigurationSnapshotEndpoint = grpctransport.NewClient(
			conn,
			"cluster.ClusterV1",
			"AutoUpdateConfigurationSnapshot",
			cluster.EncodeGrpcReqConfigurationSnapshot,
			cluster.DecodeGrpcRespConfigurationSnapshot,
			&cluster.ConfigurationSnapshot{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoUpdateConfigurationSnapshotEndpoint = trace.ClientEndPoint("ClusterV1:AutoUpdateConfigurationSnapshot")(lAutoUpdateConfigurationSnapshotEndpoint)
	}
	var lAutoUpdateDSCProfileEndpoint endpoint.Endpoint
	{
		lAutoUpdateDSCProfileEndpoint = grpctransport.NewClient(
			conn,
			"cluster.ClusterV1",
			"AutoUpdateDSCProfile",
			cluster.EncodeGrpcReqDSCProfile,
			cluster.DecodeGrpcRespDSCProfile,
			&cluster.DSCProfile{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoUpdateDSCProfileEndpoint = trace.ClientEndPoint("ClusterV1:AutoUpdateDSCProfile")(lAutoUpdateDSCProfileEndpoint)
	}
	var lAutoUpdateDistributedServiceCardEndpoint endpoint.Endpoint
	{
		lAutoUpdateDistributedServiceCardEndpoint = grpctransport.NewClient(
			conn,
			"cluster.ClusterV1",
			"AutoUpdateDistributedServiceCard",
			cluster.EncodeGrpcReqDistributedServiceCard,
			cluster.DecodeGrpcRespDistributedServiceCard,
			&cluster.DistributedServiceCard{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoUpdateDistributedServiceCardEndpoint = trace.ClientEndPoint("ClusterV1:AutoUpdateDistributedServiceCard")(lAutoUpdateDistributedServiceCardEndpoint)
	}
	var lAutoUpdateHostEndpoint endpoint.Endpoint
	{
		lAutoUpdateHostEndpoint = grpctransport.NewClient(
			conn,
			"cluster.ClusterV1",
			"AutoUpdateHost",
			cluster.EncodeGrpcReqHost,
			cluster.DecodeGrpcRespHost,
			&cluster.Host{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoUpdateHostEndpoint = trace.ClientEndPoint("ClusterV1:AutoUpdateHost")(lAutoUpdateHostEndpoint)
	}
	var lAutoUpdateLicenseEndpoint endpoint.Endpoint
	{
		lAutoUpdateLicenseEndpoint = grpctransport.NewClient(
			conn,
			"cluster.ClusterV1",
			"AutoUpdateLicense",
			cluster.EncodeGrpcReqLicense,
			cluster.DecodeGrpcRespLicense,
			&cluster.License{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoUpdateLicenseEndpoint = trace.ClientEndPoint("ClusterV1:AutoUpdateLicense")(lAutoUpdateLicenseEndpoint)
	}
	var lAutoUpdateNodeEndpoint endpoint.Endpoint
	{
		lAutoUpdateNodeEndpoint = grpctransport.NewClient(
			conn,
			"cluster.ClusterV1",
			"AutoUpdateNode",
			cluster.EncodeGrpcReqNode,
			cluster.DecodeGrpcRespNode,
			&cluster.Node{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoUpdateNodeEndpoint = trace.ClientEndPoint("ClusterV1:AutoUpdateNode")(lAutoUpdateNodeEndpoint)
	}
	var lAutoUpdateSnapshotRestoreEndpoint endpoint.Endpoint
	{
		lAutoUpdateSnapshotRestoreEndpoint = grpctransport.NewClient(
			conn,
			"cluster.ClusterV1",
			"AutoUpdateSnapshotRestore",
			cluster.EncodeGrpcReqSnapshotRestore,
			cluster.DecodeGrpcRespSnapshotRestore,
			&cluster.SnapshotRestore{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoUpdateSnapshotRestoreEndpoint = trace.ClientEndPoint("ClusterV1:AutoUpdateSnapshotRestore")(lAutoUpdateSnapshotRestoreEndpoint)
	}
	var lAutoUpdateTenantEndpoint endpoint.Endpoint
	{
		lAutoUpdateTenantEndpoint = grpctransport.NewClient(
			conn,
			"cluster.ClusterV1",
			"AutoUpdateTenant",
			cluster.EncodeGrpcReqTenant,
			cluster.DecodeGrpcRespTenant,
			&cluster.Tenant{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoUpdateTenantEndpoint = trace.ClientEndPoint("ClusterV1:AutoUpdateTenant")(lAutoUpdateTenantEndpoint)
	}
	var lAutoUpdateVersionEndpoint endpoint.Endpoint
	{
		lAutoUpdateVersionEndpoint = grpctransport.NewClient(
			conn,
			"cluster.ClusterV1",
			"AutoUpdateVersion",
			cluster.EncodeGrpcReqVersion,
			cluster.DecodeGrpcRespVersion,
			&cluster.Version{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoUpdateVersionEndpoint = trace.ClientEndPoint("ClusterV1:AutoUpdateVersion")(lAutoUpdateVersionEndpoint)
	}
	var lRestoreEndpoint endpoint.Endpoint
	{
		lRestoreEndpoint = grpctransport.NewClient(
			conn,
			"cluster.ClusterV1",
			"Restore",
			cluster.EncodeGrpcReqSnapshotRestore,
			cluster.DecodeGrpcRespSnapshotRestore,
			&cluster.SnapshotRestore{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lRestoreEndpoint = trace.ClientEndPoint("ClusterV1:Restore")(lRestoreEndpoint)
	}
	var lSaveEndpoint endpoint.Endpoint
	{
		lSaveEndpoint = grpctransport.NewClient(
			conn,
			"cluster.ClusterV1",
			"Save",
			cluster.EncodeGrpcReqConfigurationSnapshotRequest,
			cluster.DecodeGrpcRespConfigurationSnapshot,
			&cluster.ConfigurationSnapshot{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lSaveEndpoint = trace.ClientEndPoint("ClusterV1:Save")(lSaveEndpoint)
	}
	var lUpdateTLSConfigEndpoint endpoint.Endpoint
	{
		lUpdateTLSConfigEndpoint = grpctransport.NewClient(
			conn,
			"cluster.ClusterV1",
			"UpdateTLSConfig",
			cluster.EncodeGrpcReqUpdateTLSConfigRequest,
			cluster.DecodeGrpcRespCluster,
			&cluster.Cluster{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lUpdateTLSConfigEndpoint = trace.ClientEndPoint("ClusterV1:UpdateTLSConfig")(lUpdateTLSConfigEndpoint)
	}
	return cluster.EndpointsClusterV1Client{
		Client: cluster.NewClusterV1Client(conn),

		AuthBootstrapCompleteEndpoint:            lAuthBootstrapCompleteEndpoint,
		AutoAddClusterEndpoint:                   lAutoAddClusterEndpoint,
		AutoAddConfigurationSnapshotEndpoint:     lAutoAddConfigurationSnapshotEndpoint,
		AutoAddDSCProfileEndpoint:                lAutoAddDSCProfileEndpoint,
		AutoAddDistributedServiceCardEndpoint:    lAutoAddDistributedServiceCardEndpoint,
		AutoAddHostEndpoint:                      lAutoAddHostEndpoint,
		AutoAddLicenseEndpoint:                   lAutoAddLicenseEndpoint,
		AutoAddNodeEndpoint:                      lAutoAddNodeEndpoint,
		AutoAddSnapshotRestoreEndpoint:           lAutoAddSnapshotRestoreEndpoint,
		AutoAddTenantEndpoint:                    lAutoAddTenantEndpoint,
		AutoAddVersionEndpoint:                   lAutoAddVersionEndpoint,
		AutoDeleteClusterEndpoint:                lAutoDeleteClusterEndpoint,
		AutoDeleteConfigurationSnapshotEndpoint:  lAutoDeleteConfigurationSnapshotEndpoint,
		AutoDeleteDSCProfileEndpoint:             lAutoDeleteDSCProfileEndpoint,
		AutoDeleteDistributedServiceCardEndpoint: lAutoDeleteDistributedServiceCardEndpoint,
		AutoDeleteHostEndpoint:                   lAutoDeleteHostEndpoint,
		AutoDeleteLicenseEndpoint:                lAutoDeleteLicenseEndpoint,
		AutoDeleteNodeEndpoint:                   lAutoDeleteNodeEndpoint,
		AutoDeleteSnapshotRestoreEndpoint:        lAutoDeleteSnapshotRestoreEndpoint,
		AutoDeleteTenantEndpoint:                 lAutoDeleteTenantEndpoint,
		AutoDeleteVersionEndpoint:                lAutoDeleteVersionEndpoint,
		AutoGetClusterEndpoint:                   lAutoGetClusterEndpoint,
		AutoGetConfigurationSnapshotEndpoint:     lAutoGetConfigurationSnapshotEndpoint,
		AutoGetDSCProfileEndpoint:                lAutoGetDSCProfileEndpoint,
		AutoGetDistributedServiceCardEndpoint:    lAutoGetDistributedServiceCardEndpoint,
		AutoGetHostEndpoint:                      lAutoGetHostEndpoint,
		AutoGetLicenseEndpoint:                   lAutoGetLicenseEndpoint,
		AutoGetNodeEndpoint:                      lAutoGetNodeEndpoint,
		AutoGetSnapshotRestoreEndpoint:           lAutoGetSnapshotRestoreEndpoint,
		AutoGetTenantEndpoint:                    lAutoGetTenantEndpoint,
		AutoGetVersionEndpoint:                   lAutoGetVersionEndpoint,
		AutoLabelClusterEndpoint:                 lAutoLabelClusterEndpoint,
		AutoLabelConfigurationSnapshotEndpoint:   lAutoLabelConfigurationSnapshotEndpoint,
		AutoLabelDSCProfileEndpoint:              lAutoLabelDSCProfileEndpoint,
		AutoLabelDistributedServiceCardEndpoint:  lAutoLabelDistributedServiceCardEndpoint,
		AutoLabelHostEndpoint:                    lAutoLabelHostEndpoint,
		AutoLabelLicenseEndpoint:                 lAutoLabelLicenseEndpoint,
		AutoLabelNodeEndpoint:                    lAutoLabelNodeEndpoint,
		AutoLabelSnapshotRestoreEndpoint:         lAutoLabelSnapshotRestoreEndpoint,
		AutoLabelTenantEndpoint:                  lAutoLabelTenantEndpoint,
		AutoLabelVersionEndpoint:                 lAutoLabelVersionEndpoint,
		AutoListClusterEndpoint:                  lAutoListClusterEndpoint,
		AutoListConfigurationSnapshotEndpoint:    lAutoListConfigurationSnapshotEndpoint,
		AutoListDSCProfileEndpoint:               lAutoListDSCProfileEndpoint,
		AutoListDistributedServiceCardEndpoint:   lAutoListDistributedServiceCardEndpoint,
		AutoListHostEndpoint:                     lAutoListHostEndpoint,
		AutoListLicenseEndpoint:                  lAutoListLicenseEndpoint,
		AutoListNodeEndpoint:                     lAutoListNodeEndpoint,
		AutoListSnapshotRestoreEndpoint:          lAutoListSnapshotRestoreEndpoint,
		AutoListTenantEndpoint:                   lAutoListTenantEndpoint,
		AutoListVersionEndpoint:                  lAutoListVersionEndpoint,
		AutoUpdateClusterEndpoint:                lAutoUpdateClusterEndpoint,
		AutoUpdateConfigurationSnapshotEndpoint:  lAutoUpdateConfigurationSnapshotEndpoint,
		AutoUpdateDSCProfileEndpoint:             lAutoUpdateDSCProfileEndpoint,
		AutoUpdateDistributedServiceCardEndpoint: lAutoUpdateDistributedServiceCardEndpoint,
		AutoUpdateHostEndpoint:                   lAutoUpdateHostEndpoint,
		AutoUpdateLicenseEndpoint:                lAutoUpdateLicenseEndpoint,
		AutoUpdateNodeEndpoint:                   lAutoUpdateNodeEndpoint,
		AutoUpdateSnapshotRestoreEndpoint:        lAutoUpdateSnapshotRestoreEndpoint,
		AutoUpdateTenantEndpoint:                 lAutoUpdateTenantEndpoint,
		AutoUpdateVersionEndpoint:                lAutoUpdateVersionEndpoint,
		RestoreEndpoint:                          lRestoreEndpoint,
		SaveEndpoint:                             lSaveEndpoint,
		UpdateTLSConfigEndpoint:                  lUpdateTLSConfigEndpoint,
	}
}

// NewClusterV1Backend creates an instrumented client with middleware
func NewClusterV1Backend(conn *grpc.ClientConn, logger log.Logger) cluster.ServiceClusterV1Client {
	cl := NewClusterV1(conn, logger)
	cl = cluster.LoggingClusterV1MiddlewareClient(logger)(cl)
	return cl
}

type grpcObjClusterV1Cluster struct {
	logger log.Logger
	client cluster.ServiceClusterV1Client
}

func (a *grpcObjClusterV1Cluster) Create(ctx context.Context, in *cluster.Cluster) (*cluster.Cluster, error) {
	a.logger.DebugLog("msg", "received call", "object", "Cluster", "oper", "create")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoAddCluster(nctx, in)
}

func (a *grpcObjClusterV1Cluster) Update(ctx context.Context, in *cluster.Cluster) (*cluster.Cluster, error) {
	a.logger.DebugLog("msg", "received call", "object", "Cluster", "oper", "update")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoUpdateCluster(nctx, in)
}

func (a *grpcObjClusterV1Cluster) UpdateStatus(ctx context.Context, in *cluster.Cluster) (*cluster.Cluster, error) {
	a.logger.DebugLog("msg", "received call", "object", "Cluster", "oper", "update")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	nctx = addStatusUpd(nctx)
	return a.client.AutoUpdateCluster(nctx, in)
}

func (a *grpcObjClusterV1Cluster) Label(ctx context.Context, in *api.Label) (*cluster.Cluster, error) {
	a.logger.DebugLog("msg", "received call", "object", "Cluster", "oper", "label")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoLabelCluster(nctx, in)
}

func (a *grpcObjClusterV1Cluster) Get(ctx context.Context, objMeta *api.ObjectMeta) (*cluster.Cluster, error) {
	a.logger.DebugLog("msg", "received call", "object", "Cluster", "oper", "get")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := cluster.Cluster{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoGetCluster(nctx, &in)
}

func (a *grpcObjClusterV1Cluster) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*cluster.Cluster, error) {
	a.logger.DebugLog("msg", "received call", "object", "Cluster", "oper", "delete")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := cluster.Cluster{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoDeleteCluster(nctx, &in)
}

func (a *grpcObjClusterV1Cluster) List(ctx context.Context, options *api.ListWatchOptions) ([]*cluster.Cluster, error) {
	a.logger.DebugLog("msg", "received call", "object", "Cluster", "oper", "list")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	r, err := a.client.AutoListCluster(nctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *grpcObjClusterV1Cluster) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	a.logger.DebugLog("msg", "received call", "object", "Cluster", "oper", "WatchOper")
	nctx := addVersion(ctx, "v1")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	stream, err := a.client.AutoWatchCluster(nctx, options)
	if err != nil {
		return nil, err
	}
	wstream := stream.(cluster.ClusterV1_AutoWatchClusterClient)
	bridgefn := func(lw *listerwatcher.WatcherClient) {
		for {
			r, err := wstream.Recv()
			if err != nil {
				a.logger.ErrorLog("msg", "error on receive", "err", err)
				close(lw.OutCh)
				return
			}
			for _, e := range r.Events {
				ev := kvstore.WatchEvent{
					Type:   kvstore.WatchEventType(e.Type),
					Object: e.Object,
				}
				select {
				case lw.OutCh <- &ev:
				case <-wstream.Context().Done():
					close(lw.OutCh)
					return
				}
			}
		}
	}
	lw := listerwatcher.NewWatcherClient(wstream, bridgefn)
	lw.Run()
	return lw, nil
}

func (a *grpcObjClusterV1Cluster) AuthBootstrapComplete(ctx context.Context, in *cluster.ClusterAuthBootstrapRequest) (*cluster.Cluster, error) {
	a.logger.DebugLog("msg", "received call", "object", "{AuthBootstrapComplete ClusterAuthBootstrapRequest Cluster}", "oper", "AuthBootstrapComplete")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AuthBootstrapComplete(nctx, in)
}

func (a *grpcObjClusterV1Cluster) UpdateTLSConfig(ctx context.Context, in *cluster.UpdateTLSConfigRequest) (*cluster.Cluster, error) {
	a.logger.DebugLog("msg", "received call", "object", "{UpdateTLSConfig UpdateTLSConfigRequest Cluster}", "oper", "UpdateTLSConfig")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.UpdateTLSConfig(nctx, in)
}

func (a *grpcObjClusterV1Cluster) Allowed(oper apiintf.APIOperType) bool {
	return true
}

type restObjClusterV1Cluster struct {
	endpoints cluster.EndpointsClusterV1RestClient
	instance  string
}

func (a *restObjClusterV1Cluster) Create(ctx context.Context, in *cluster.Cluster) (*cluster.Cluster, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoAddCluster(ctx, in)
}

func (a *restObjClusterV1Cluster) Update(ctx context.Context, in *cluster.Cluster) (*cluster.Cluster, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoUpdateCluster(ctx, in)
}

func (a *restObjClusterV1Cluster) UpdateStatus(ctx context.Context, in *cluster.Cluster) (*cluster.Cluster, error) {
	return nil, errors.New("not supported for REST")
}

func (a *restObjClusterV1Cluster) Label(ctx context.Context, in *api.Label) (*cluster.Cluster, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoLabelCluster(ctx, in)
}

func (a *restObjClusterV1Cluster) Get(ctx context.Context, objMeta *api.ObjectMeta) (*cluster.Cluster, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := cluster.Cluster{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoGetCluster(ctx, &in)
}

func (a *restObjClusterV1Cluster) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*cluster.Cluster, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := cluster.Cluster{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoDeleteCluster(ctx, &in)
}

func (a *restObjClusterV1Cluster) List(ctx context.Context, options *api.ListWatchOptions) ([]*cluster.Cluster, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}

	r, err := a.endpoints.AutoListCluster(ctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *restObjClusterV1Cluster) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoWatchCluster(ctx, options)
}

func (a *restObjClusterV1Cluster) Allowed(oper apiintf.APIOperType) bool {
	switch oper {
	case apiintf.CreateOper:
		return false
	case apiintf.UpdateOper:
		return true
	case apiintf.GetOper:
		return true
	case apiintf.DeleteOper:
		return false
	case apiintf.ListOper:
		return false
	case apiintf.WatchOper:
		return true
	default:
		return false
	}
}

func (a *restObjClusterV1Cluster) AuthBootstrapComplete(ctx context.Context, in *cluster.ClusterAuthBootstrapRequest) (*cluster.Cluster, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AuthBootstrapCompleteCluster(ctx, in)
}
func (a *restObjClusterV1Cluster) UpdateTLSConfig(ctx context.Context, in *cluster.UpdateTLSConfigRequest) (*cluster.Cluster, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.UpdateTLSConfigCluster(ctx, in)
}

type grpcObjClusterV1Node struct {
	logger log.Logger
	client cluster.ServiceClusterV1Client
}

func (a *grpcObjClusterV1Node) Create(ctx context.Context, in *cluster.Node) (*cluster.Node, error) {
	a.logger.DebugLog("msg", "received call", "object", "Node", "oper", "create")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoAddNode(nctx, in)
}

func (a *grpcObjClusterV1Node) Update(ctx context.Context, in *cluster.Node) (*cluster.Node, error) {
	a.logger.DebugLog("msg", "received call", "object", "Node", "oper", "update")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoUpdateNode(nctx, in)
}

func (a *grpcObjClusterV1Node) UpdateStatus(ctx context.Context, in *cluster.Node) (*cluster.Node, error) {
	a.logger.DebugLog("msg", "received call", "object", "Node", "oper", "update")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	nctx = addStatusUpd(nctx)
	return a.client.AutoUpdateNode(nctx, in)
}

func (a *grpcObjClusterV1Node) Label(ctx context.Context, in *api.Label) (*cluster.Node, error) {
	a.logger.DebugLog("msg", "received call", "object", "Node", "oper", "label")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoLabelNode(nctx, in)
}

func (a *grpcObjClusterV1Node) Get(ctx context.Context, objMeta *api.ObjectMeta) (*cluster.Node, error) {
	a.logger.DebugLog("msg", "received call", "object", "Node", "oper", "get")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := cluster.Node{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoGetNode(nctx, &in)
}

func (a *grpcObjClusterV1Node) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*cluster.Node, error) {
	a.logger.DebugLog("msg", "received call", "object", "Node", "oper", "delete")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := cluster.Node{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoDeleteNode(nctx, &in)
}

func (a *grpcObjClusterV1Node) List(ctx context.Context, options *api.ListWatchOptions) ([]*cluster.Node, error) {
	a.logger.DebugLog("msg", "received call", "object", "Node", "oper", "list")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	r, err := a.client.AutoListNode(nctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *grpcObjClusterV1Node) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	a.logger.DebugLog("msg", "received call", "object", "Node", "oper", "WatchOper")
	nctx := addVersion(ctx, "v1")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	stream, err := a.client.AutoWatchNode(nctx, options)
	if err != nil {
		return nil, err
	}
	wstream := stream.(cluster.ClusterV1_AutoWatchNodeClient)
	bridgefn := func(lw *listerwatcher.WatcherClient) {
		for {
			r, err := wstream.Recv()
			if err != nil {
				a.logger.ErrorLog("msg", "error on receive", "err", err)
				close(lw.OutCh)
				return
			}
			for _, e := range r.Events {
				ev := kvstore.WatchEvent{
					Type:   kvstore.WatchEventType(e.Type),
					Object: e.Object,
				}
				select {
				case lw.OutCh <- &ev:
				case <-wstream.Context().Done():
					close(lw.OutCh)
					return
				}
			}
		}
	}
	lw := listerwatcher.NewWatcherClient(wstream, bridgefn)
	lw.Run()
	return lw, nil
}

func (a *grpcObjClusterV1Node) Allowed(oper apiintf.APIOperType) bool {
	return true
}

type restObjClusterV1Node struct {
	endpoints cluster.EndpointsClusterV1RestClient
	instance  string
}

func (a *restObjClusterV1Node) Create(ctx context.Context, in *cluster.Node) (*cluster.Node, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoAddNode(ctx, in)
}

func (a *restObjClusterV1Node) Update(ctx context.Context, in *cluster.Node) (*cluster.Node, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoUpdateNode(ctx, in)
}

func (a *restObjClusterV1Node) UpdateStatus(ctx context.Context, in *cluster.Node) (*cluster.Node, error) {
	return nil, errors.New("not supported for REST")
}

func (a *restObjClusterV1Node) Label(ctx context.Context, in *api.Label) (*cluster.Node, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoLabelNode(ctx, in)
}

func (a *restObjClusterV1Node) Get(ctx context.Context, objMeta *api.ObjectMeta) (*cluster.Node, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := cluster.Node{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoGetNode(ctx, &in)
}

func (a *restObjClusterV1Node) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*cluster.Node, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := cluster.Node{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoDeleteNode(ctx, &in)
}

func (a *restObjClusterV1Node) List(ctx context.Context, options *api.ListWatchOptions) ([]*cluster.Node, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}

	r, err := a.endpoints.AutoListNode(ctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *restObjClusterV1Node) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoWatchNode(ctx, options)
}

func (a *restObjClusterV1Node) Allowed(oper apiintf.APIOperType) bool {
	switch oper {
	case apiintf.CreateOper:
		return true
	case apiintf.UpdateOper:
		return true
	case apiintf.GetOper:
		return true
	case apiintf.DeleteOper:
		return true
	case apiintf.ListOper:
		return true
	case apiintf.WatchOper:
		return true
	default:
		return false
	}
}

type grpcObjClusterV1Host struct {
	logger log.Logger
	client cluster.ServiceClusterV1Client
}

func (a *grpcObjClusterV1Host) Create(ctx context.Context, in *cluster.Host) (*cluster.Host, error) {
	a.logger.DebugLog("msg", "received call", "object", "Host", "oper", "create")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoAddHost(nctx, in)
}

func (a *grpcObjClusterV1Host) Update(ctx context.Context, in *cluster.Host) (*cluster.Host, error) {
	a.logger.DebugLog("msg", "received call", "object", "Host", "oper", "update")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoUpdateHost(nctx, in)
}

func (a *grpcObjClusterV1Host) UpdateStatus(ctx context.Context, in *cluster.Host) (*cluster.Host, error) {
	a.logger.DebugLog("msg", "received call", "object", "Host", "oper", "update")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	nctx = addStatusUpd(nctx)
	return a.client.AutoUpdateHost(nctx, in)
}

func (a *grpcObjClusterV1Host) Label(ctx context.Context, in *api.Label) (*cluster.Host, error) {
	a.logger.DebugLog("msg", "received call", "object", "Host", "oper", "label")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoLabelHost(nctx, in)
}

func (a *grpcObjClusterV1Host) Get(ctx context.Context, objMeta *api.ObjectMeta) (*cluster.Host, error) {
	a.logger.DebugLog("msg", "received call", "object", "Host", "oper", "get")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := cluster.Host{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoGetHost(nctx, &in)
}

func (a *grpcObjClusterV1Host) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*cluster.Host, error) {
	a.logger.DebugLog("msg", "received call", "object", "Host", "oper", "delete")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := cluster.Host{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoDeleteHost(nctx, &in)
}

func (a *grpcObjClusterV1Host) List(ctx context.Context, options *api.ListWatchOptions) ([]*cluster.Host, error) {
	a.logger.DebugLog("msg", "received call", "object", "Host", "oper", "list")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	r, err := a.client.AutoListHost(nctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *grpcObjClusterV1Host) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	a.logger.DebugLog("msg", "received call", "object", "Host", "oper", "WatchOper")
	nctx := addVersion(ctx, "v1")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	stream, err := a.client.AutoWatchHost(nctx, options)
	if err != nil {
		return nil, err
	}
	wstream := stream.(cluster.ClusterV1_AutoWatchHostClient)
	bridgefn := func(lw *listerwatcher.WatcherClient) {
		for {
			r, err := wstream.Recv()
			if err != nil {
				a.logger.ErrorLog("msg", "error on receive", "err", err)
				close(lw.OutCh)
				return
			}
			for _, e := range r.Events {
				ev := kvstore.WatchEvent{
					Type:   kvstore.WatchEventType(e.Type),
					Object: e.Object,
				}
				select {
				case lw.OutCh <- &ev:
				case <-wstream.Context().Done():
					close(lw.OutCh)
					return
				}
			}
		}
	}
	lw := listerwatcher.NewWatcherClient(wstream, bridgefn)
	lw.Run()
	return lw, nil
}

func (a *grpcObjClusterV1Host) Allowed(oper apiintf.APIOperType) bool {
	return true
}

type restObjClusterV1Host struct {
	endpoints cluster.EndpointsClusterV1RestClient
	instance  string
}

func (a *restObjClusterV1Host) Create(ctx context.Context, in *cluster.Host) (*cluster.Host, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoAddHost(ctx, in)
}

func (a *restObjClusterV1Host) Update(ctx context.Context, in *cluster.Host) (*cluster.Host, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoUpdateHost(ctx, in)
}

func (a *restObjClusterV1Host) UpdateStatus(ctx context.Context, in *cluster.Host) (*cluster.Host, error) {
	return nil, errors.New("not supported for REST")
}

func (a *restObjClusterV1Host) Label(ctx context.Context, in *api.Label) (*cluster.Host, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoLabelHost(ctx, in)
}

func (a *restObjClusterV1Host) Get(ctx context.Context, objMeta *api.ObjectMeta) (*cluster.Host, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := cluster.Host{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoGetHost(ctx, &in)
}

func (a *restObjClusterV1Host) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*cluster.Host, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := cluster.Host{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoDeleteHost(ctx, &in)
}

func (a *restObjClusterV1Host) List(ctx context.Context, options *api.ListWatchOptions) ([]*cluster.Host, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}

	r, err := a.endpoints.AutoListHost(ctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *restObjClusterV1Host) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoWatchHost(ctx, options)
}

func (a *restObjClusterV1Host) Allowed(oper apiintf.APIOperType) bool {
	switch oper {
	case apiintf.CreateOper:
		return true
	case apiintf.UpdateOper:
		return true
	case apiintf.GetOper:
		return true
	case apiintf.DeleteOper:
		return true
	case apiintf.ListOper:
		return true
	case apiintf.WatchOper:
		return true
	default:
		return false
	}
}

type grpcObjClusterV1DistributedServiceCard struct {
	logger log.Logger
	client cluster.ServiceClusterV1Client
}

func (a *grpcObjClusterV1DistributedServiceCard) Create(ctx context.Context, in *cluster.DistributedServiceCard) (*cluster.DistributedServiceCard, error) {
	a.logger.DebugLog("msg", "received call", "object", "DistributedServiceCard", "oper", "create")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoAddDistributedServiceCard(nctx, in)
}

func (a *grpcObjClusterV1DistributedServiceCard) Update(ctx context.Context, in *cluster.DistributedServiceCard) (*cluster.DistributedServiceCard, error) {
	a.logger.DebugLog("msg", "received call", "object", "DistributedServiceCard", "oper", "update")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoUpdateDistributedServiceCard(nctx, in)
}

func (a *grpcObjClusterV1DistributedServiceCard) UpdateStatus(ctx context.Context, in *cluster.DistributedServiceCard) (*cluster.DistributedServiceCard, error) {
	a.logger.DebugLog("msg", "received call", "object", "DistributedServiceCard", "oper", "update")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	nctx = addStatusUpd(nctx)
	return a.client.AutoUpdateDistributedServiceCard(nctx, in)
}

func (a *grpcObjClusterV1DistributedServiceCard) Label(ctx context.Context, in *api.Label) (*cluster.DistributedServiceCard, error) {
	a.logger.DebugLog("msg", "received call", "object", "DistributedServiceCard", "oper", "label")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoLabelDistributedServiceCard(nctx, in)
}

func (a *grpcObjClusterV1DistributedServiceCard) Get(ctx context.Context, objMeta *api.ObjectMeta) (*cluster.DistributedServiceCard, error) {
	a.logger.DebugLog("msg", "received call", "object", "DistributedServiceCard", "oper", "get")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := cluster.DistributedServiceCard{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoGetDistributedServiceCard(nctx, &in)
}

func (a *grpcObjClusterV1DistributedServiceCard) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*cluster.DistributedServiceCard, error) {
	a.logger.DebugLog("msg", "received call", "object", "DistributedServiceCard", "oper", "delete")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := cluster.DistributedServiceCard{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoDeleteDistributedServiceCard(nctx, &in)
}

func (a *grpcObjClusterV1DistributedServiceCard) List(ctx context.Context, options *api.ListWatchOptions) ([]*cluster.DistributedServiceCard, error) {
	a.logger.DebugLog("msg", "received call", "object", "DistributedServiceCard", "oper", "list")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	r, err := a.client.AutoListDistributedServiceCard(nctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *grpcObjClusterV1DistributedServiceCard) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	a.logger.DebugLog("msg", "received call", "object", "DistributedServiceCard", "oper", "WatchOper")
	nctx := addVersion(ctx, "v1")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	stream, err := a.client.AutoWatchDistributedServiceCard(nctx, options)
	if err != nil {
		return nil, err
	}
	wstream := stream.(cluster.ClusterV1_AutoWatchDistributedServiceCardClient)
	bridgefn := func(lw *listerwatcher.WatcherClient) {
		for {
			r, err := wstream.Recv()
			if err != nil {
				a.logger.ErrorLog("msg", "error on receive", "err", err)
				close(lw.OutCh)
				return
			}
			for _, e := range r.Events {
				ev := kvstore.WatchEvent{
					Type:   kvstore.WatchEventType(e.Type),
					Object: e.Object,
				}
				select {
				case lw.OutCh <- &ev:
				case <-wstream.Context().Done():
					close(lw.OutCh)
					return
				}
			}
		}
	}
	lw := listerwatcher.NewWatcherClient(wstream, bridgefn)
	lw.Run()
	return lw, nil
}

func (a *grpcObjClusterV1DistributedServiceCard) Allowed(oper apiintf.APIOperType) bool {
	return true
}

type restObjClusterV1DistributedServiceCard struct {
	endpoints cluster.EndpointsClusterV1RestClient
	instance  string
}

func (a *restObjClusterV1DistributedServiceCard) Create(ctx context.Context, in *cluster.DistributedServiceCard) (*cluster.DistributedServiceCard, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoAddDistributedServiceCard(ctx, in)
}

func (a *restObjClusterV1DistributedServiceCard) Update(ctx context.Context, in *cluster.DistributedServiceCard) (*cluster.DistributedServiceCard, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoUpdateDistributedServiceCard(ctx, in)
}

func (a *restObjClusterV1DistributedServiceCard) UpdateStatus(ctx context.Context, in *cluster.DistributedServiceCard) (*cluster.DistributedServiceCard, error) {
	return nil, errors.New("not supported for REST")
}

func (a *restObjClusterV1DistributedServiceCard) Label(ctx context.Context, in *api.Label) (*cluster.DistributedServiceCard, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoLabelDistributedServiceCard(ctx, in)
}

func (a *restObjClusterV1DistributedServiceCard) Get(ctx context.Context, objMeta *api.ObjectMeta) (*cluster.DistributedServiceCard, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := cluster.DistributedServiceCard{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoGetDistributedServiceCard(ctx, &in)
}

func (a *restObjClusterV1DistributedServiceCard) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*cluster.DistributedServiceCard, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := cluster.DistributedServiceCard{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoDeleteDistributedServiceCard(ctx, &in)
}

func (a *restObjClusterV1DistributedServiceCard) List(ctx context.Context, options *api.ListWatchOptions) ([]*cluster.DistributedServiceCard, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}

	r, err := a.endpoints.AutoListDistributedServiceCard(ctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *restObjClusterV1DistributedServiceCard) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoWatchDistributedServiceCard(ctx, options)
}

func (a *restObjClusterV1DistributedServiceCard) Allowed(oper apiintf.APIOperType) bool {
	switch oper {
	case apiintf.CreateOper:
		return false
	case apiintf.UpdateOper:
		return true
	case apiintf.GetOper:
		return true
	case apiintf.DeleteOper:
		return true
	case apiintf.ListOper:
		return true
	case apiintf.WatchOper:
		return true
	default:
		return false
	}
}

type grpcObjClusterV1Tenant struct {
	logger log.Logger
	client cluster.ServiceClusterV1Client
}

func (a *grpcObjClusterV1Tenant) Create(ctx context.Context, in *cluster.Tenant) (*cluster.Tenant, error) {
	a.logger.DebugLog("msg", "received call", "object", "Tenant", "oper", "create")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoAddTenant(nctx, in)
}

func (a *grpcObjClusterV1Tenant) Update(ctx context.Context, in *cluster.Tenant) (*cluster.Tenant, error) {
	a.logger.DebugLog("msg", "received call", "object", "Tenant", "oper", "update")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoUpdateTenant(nctx, in)
}

func (a *grpcObjClusterV1Tenant) UpdateStatus(ctx context.Context, in *cluster.Tenant) (*cluster.Tenant, error) {
	a.logger.DebugLog("msg", "received call", "object", "Tenant", "oper", "update")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	nctx = addStatusUpd(nctx)
	return a.client.AutoUpdateTenant(nctx, in)
}

func (a *grpcObjClusterV1Tenant) Label(ctx context.Context, in *api.Label) (*cluster.Tenant, error) {
	a.logger.DebugLog("msg", "received call", "object", "Tenant", "oper", "label")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoLabelTenant(nctx, in)
}

func (a *grpcObjClusterV1Tenant) Get(ctx context.Context, objMeta *api.ObjectMeta) (*cluster.Tenant, error) {
	a.logger.DebugLog("msg", "received call", "object", "Tenant", "oper", "get")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := cluster.Tenant{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoGetTenant(nctx, &in)
}

func (a *grpcObjClusterV1Tenant) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*cluster.Tenant, error) {
	a.logger.DebugLog("msg", "received call", "object", "Tenant", "oper", "delete")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := cluster.Tenant{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoDeleteTenant(nctx, &in)
}

func (a *grpcObjClusterV1Tenant) List(ctx context.Context, options *api.ListWatchOptions) ([]*cluster.Tenant, error) {
	a.logger.DebugLog("msg", "received call", "object", "Tenant", "oper", "list")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	r, err := a.client.AutoListTenant(nctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *grpcObjClusterV1Tenant) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	a.logger.DebugLog("msg", "received call", "object", "Tenant", "oper", "WatchOper")
	nctx := addVersion(ctx, "v1")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	stream, err := a.client.AutoWatchTenant(nctx, options)
	if err != nil {
		return nil, err
	}
	wstream := stream.(cluster.ClusterV1_AutoWatchTenantClient)
	bridgefn := func(lw *listerwatcher.WatcherClient) {
		for {
			r, err := wstream.Recv()
			if err != nil {
				a.logger.ErrorLog("msg", "error on receive", "err", err)
				close(lw.OutCh)
				return
			}
			for _, e := range r.Events {
				ev := kvstore.WatchEvent{
					Type:   kvstore.WatchEventType(e.Type),
					Object: e.Object,
				}
				select {
				case lw.OutCh <- &ev:
				case <-wstream.Context().Done():
					close(lw.OutCh)
					return
				}
			}
		}
	}
	lw := listerwatcher.NewWatcherClient(wstream, bridgefn)
	lw.Run()
	return lw, nil
}

func (a *grpcObjClusterV1Tenant) Allowed(oper apiintf.APIOperType) bool {
	return true
}

type restObjClusterV1Tenant struct {
	endpoints cluster.EndpointsClusterV1RestClient
	instance  string
}

func (a *restObjClusterV1Tenant) Create(ctx context.Context, in *cluster.Tenant) (*cluster.Tenant, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoAddTenant(ctx, in)
}

func (a *restObjClusterV1Tenant) Update(ctx context.Context, in *cluster.Tenant) (*cluster.Tenant, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoUpdateTenant(ctx, in)
}

func (a *restObjClusterV1Tenant) UpdateStatus(ctx context.Context, in *cluster.Tenant) (*cluster.Tenant, error) {
	return nil, errors.New("not supported for REST")
}

func (a *restObjClusterV1Tenant) Label(ctx context.Context, in *api.Label) (*cluster.Tenant, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoLabelTenant(ctx, in)
}

func (a *restObjClusterV1Tenant) Get(ctx context.Context, objMeta *api.ObjectMeta) (*cluster.Tenant, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := cluster.Tenant{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoGetTenant(ctx, &in)
}

func (a *restObjClusterV1Tenant) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*cluster.Tenant, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := cluster.Tenant{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoDeleteTenant(ctx, &in)
}

func (a *restObjClusterV1Tenant) List(ctx context.Context, options *api.ListWatchOptions) ([]*cluster.Tenant, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}

	r, err := a.endpoints.AutoListTenant(ctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *restObjClusterV1Tenant) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoWatchTenant(ctx, options)
}

func (a *restObjClusterV1Tenant) Allowed(oper apiintf.APIOperType) bool {
	switch oper {
	case apiintf.CreateOper:
		return true
	case apiintf.UpdateOper:
		return true
	case apiintf.GetOper:
		return true
	case apiintf.DeleteOper:
		return true
	case apiintf.ListOper:
		return true
	case apiintf.WatchOper:
		return true
	default:
		return false
	}
}

type grpcObjClusterV1Version struct {
	logger log.Logger
	client cluster.ServiceClusterV1Client
}

func (a *grpcObjClusterV1Version) Create(ctx context.Context, in *cluster.Version) (*cluster.Version, error) {
	a.logger.DebugLog("msg", "received call", "object", "Version", "oper", "create")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoAddVersion(nctx, in)
}

func (a *grpcObjClusterV1Version) Update(ctx context.Context, in *cluster.Version) (*cluster.Version, error) {
	a.logger.DebugLog("msg", "received call", "object", "Version", "oper", "update")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoUpdateVersion(nctx, in)
}

func (a *grpcObjClusterV1Version) UpdateStatus(ctx context.Context, in *cluster.Version) (*cluster.Version, error) {
	a.logger.DebugLog("msg", "received call", "object", "Version", "oper", "update")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	nctx = addStatusUpd(nctx)
	return a.client.AutoUpdateVersion(nctx, in)
}

func (a *grpcObjClusterV1Version) Label(ctx context.Context, in *api.Label) (*cluster.Version, error) {
	a.logger.DebugLog("msg", "received call", "object", "Version", "oper", "label")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoLabelVersion(nctx, in)
}

func (a *grpcObjClusterV1Version) Get(ctx context.Context, objMeta *api.ObjectMeta) (*cluster.Version, error) {
	a.logger.DebugLog("msg", "received call", "object", "Version", "oper", "get")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := cluster.Version{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoGetVersion(nctx, &in)
}

func (a *grpcObjClusterV1Version) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*cluster.Version, error) {
	a.logger.DebugLog("msg", "received call", "object", "Version", "oper", "delete")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := cluster.Version{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoDeleteVersion(nctx, &in)
}

func (a *grpcObjClusterV1Version) List(ctx context.Context, options *api.ListWatchOptions) ([]*cluster.Version, error) {
	a.logger.DebugLog("msg", "received call", "object", "Version", "oper", "list")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	r, err := a.client.AutoListVersion(nctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *grpcObjClusterV1Version) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	a.logger.DebugLog("msg", "received call", "object", "Version", "oper", "WatchOper")
	nctx := addVersion(ctx, "v1")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	stream, err := a.client.AutoWatchVersion(nctx, options)
	if err != nil {
		return nil, err
	}
	wstream := stream.(cluster.ClusterV1_AutoWatchVersionClient)
	bridgefn := func(lw *listerwatcher.WatcherClient) {
		for {
			r, err := wstream.Recv()
			if err != nil {
				a.logger.ErrorLog("msg", "error on receive", "err", err)
				close(lw.OutCh)
				return
			}
			for _, e := range r.Events {
				ev := kvstore.WatchEvent{
					Type:   kvstore.WatchEventType(e.Type),
					Object: e.Object,
				}
				select {
				case lw.OutCh <- &ev:
				case <-wstream.Context().Done():
					close(lw.OutCh)
					return
				}
			}
		}
	}
	lw := listerwatcher.NewWatcherClient(wstream, bridgefn)
	lw.Run()
	return lw, nil
}

func (a *grpcObjClusterV1Version) Allowed(oper apiintf.APIOperType) bool {
	return true
}

type restObjClusterV1Version struct {
	endpoints cluster.EndpointsClusterV1RestClient
	instance  string
}

func (a *restObjClusterV1Version) Create(ctx context.Context, in *cluster.Version) (*cluster.Version, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoAddVersion(ctx, in)
}

func (a *restObjClusterV1Version) Update(ctx context.Context, in *cluster.Version) (*cluster.Version, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoUpdateVersion(ctx, in)
}

func (a *restObjClusterV1Version) UpdateStatus(ctx context.Context, in *cluster.Version) (*cluster.Version, error) {
	return nil, errors.New("not supported for REST")
}

func (a *restObjClusterV1Version) Label(ctx context.Context, in *api.Label) (*cluster.Version, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoLabelVersion(ctx, in)
}

func (a *restObjClusterV1Version) Get(ctx context.Context, objMeta *api.ObjectMeta) (*cluster.Version, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := cluster.Version{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoGetVersion(ctx, &in)
}

func (a *restObjClusterV1Version) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*cluster.Version, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := cluster.Version{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoDeleteVersion(ctx, &in)
}

func (a *restObjClusterV1Version) List(ctx context.Context, options *api.ListWatchOptions) ([]*cluster.Version, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}

	r, err := a.endpoints.AutoListVersion(ctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *restObjClusterV1Version) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoWatchVersion(ctx, options)
}

func (a *restObjClusterV1Version) Allowed(oper apiintf.APIOperType) bool {
	switch oper {
	case apiintf.CreateOper:
		return false
	case apiintf.UpdateOper:
		return false
	case apiintf.GetOper:
		return true
	case apiintf.DeleteOper:
		return false
	case apiintf.ListOper:
		return false
	case apiintf.WatchOper:
		return true
	default:
		return false
	}
}

type grpcObjClusterV1ConfigurationSnapshot struct {
	logger log.Logger
	client cluster.ServiceClusterV1Client
}

func (a *grpcObjClusterV1ConfigurationSnapshot) Create(ctx context.Context, in *cluster.ConfigurationSnapshot) (*cluster.ConfigurationSnapshot, error) {
	a.logger.DebugLog("msg", "received call", "object", "ConfigurationSnapshot", "oper", "create")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoAddConfigurationSnapshot(nctx, in)
}

func (a *grpcObjClusterV1ConfigurationSnapshot) Update(ctx context.Context, in *cluster.ConfigurationSnapshot) (*cluster.ConfigurationSnapshot, error) {
	a.logger.DebugLog("msg", "received call", "object", "ConfigurationSnapshot", "oper", "update")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoUpdateConfigurationSnapshot(nctx, in)
}

func (a *grpcObjClusterV1ConfigurationSnapshot) UpdateStatus(ctx context.Context, in *cluster.ConfigurationSnapshot) (*cluster.ConfigurationSnapshot, error) {
	a.logger.DebugLog("msg", "received call", "object", "ConfigurationSnapshot", "oper", "update")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	nctx = addStatusUpd(nctx)
	return a.client.AutoUpdateConfigurationSnapshot(nctx, in)
}

func (a *grpcObjClusterV1ConfigurationSnapshot) Label(ctx context.Context, in *api.Label) (*cluster.ConfigurationSnapshot, error) {
	a.logger.DebugLog("msg", "received call", "object", "ConfigurationSnapshot", "oper", "label")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoLabelConfigurationSnapshot(nctx, in)
}

func (a *grpcObjClusterV1ConfigurationSnapshot) Get(ctx context.Context, objMeta *api.ObjectMeta) (*cluster.ConfigurationSnapshot, error) {
	a.logger.DebugLog("msg", "received call", "object", "ConfigurationSnapshot", "oper", "get")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := cluster.ConfigurationSnapshot{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoGetConfigurationSnapshot(nctx, &in)
}

func (a *grpcObjClusterV1ConfigurationSnapshot) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*cluster.ConfigurationSnapshot, error) {
	a.logger.DebugLog("msg", "received call", "object", "ConfigurationSnapshot", "oper", "delete")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := cluster.ConfigurationSnapshot{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoDeleteConfigurationSnapshot(nctx, &in)
}

func (a *grpcObjClusterV1ConfigurationSnapshot) List(ctx context.Context, options *api.ListWatchOptions) ([]*cluster.ConfigurationSnapshot, error) {
	a.logger.DebugLog("msg", "received call", "object", "ConfigurationSnapshot", "oper", "list")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	r, err := a.client.AutoListConfigurationSnapshot(nctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *grpcObjClusterV1ConfigurationSnapshot) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	a.logger.DebugLog("msg", "received call", "object", "ConfigurationSnapshot", "oper", "WatchOper")
	nctx := addVersion(ctx, "v1")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	stream, err := a.client.AutoWatchConfigurationSnapshot(nctx, options)
	if err != nil {
		return nil, err
	}
	wstream := stream.(cluster.ClusterV1_AutoWatchConfigurationSnapshotClient)
	bridgefn := func(lw *listerwatcher.WatcherClient) {
		for {
			r, err := wstream.Recv()
			if err != nil {
				a.logger.ErrorLog("msg", "error on receive", "err", err)
				close(lw.OutCh)
				return
			}
			for _, e := range r.Events {
				ev := kvstore.WatchEvent{
					Type:   kvstore.WatchEventType(e.Type),
					Object: e.Object,
				}
				select {
				case lw.OutCh <- &ev:
				case <-wstream.Context().Done():
					close(lw.OutCh)
					return
				}
			}
		}
	}
	lw := listerwatcher.NewWatcherClient(wstream, bridgefn)
	lw.Run()
	return lw, nil
}

func (a *grpcObjClusterV1ConfigurationSnapshot) Save(ctx context.Context, in *cluster.ConfigurationSnapshotRequest) (*cluster.ConfigurationSnapshot, error) {
	a.logger.DebugLog("msg", "received call", "object", "{Save ConfigurationSnapshotRequest ConfigurationSnapshot}", "oper", "Save")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.Save(nctx, in)
}

func (a *grpcObjClusterV1ConfigurationSnapshot) Allowed(oper apiintf.APIOperType) bool {
	return true
}

type restObjClusterV1ConfigurationSnapshot struct {
	endpoints cluster.EndpointsClusterV1RestClient
	instance  string
}

func (a *restObjClusterV1ConfigurationSnapshot) Create(ctx context.Context, in *cluster.ConfigurationSnapshot) (*cluster.ConfigurationSnapshot, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoAddConfigurationSnapshot(ctx, in)
}

func (a *restObjClusterV1ConfigurationSnapshot) Update(ctx context.Context, in *cluster.ConfigurationSnapshot) (*cluster.ConfigurationSnapshot, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoUpdateConfigurationSnapshot(ctx, in)
}

func (a *restObjClusterV1ConfigurationSnapshot) UpdateStatus(ctx context.Context, in *cluster.ConfigurationSnapshot) (*cluster.ConfigurationSnapshot, error) {
	return nil, errors.New("not supported for REST")
}

func (a *restObjClusterV1ConfigurationSnapshot) Label(ctx context.Context, in *api.Label) (*cluster.ConfigurationSnapshot, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoLabelConfigurationSnapshot(ctx, in)
}

func (a *restObjClusterV1ConfigurationSnapshot) Get(ctx context.Context, objMeta *api.ObjectMeta) (*cluster.ConfigurationSnapshot, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := cluster.ConfigurationSnapshot{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoGetConfigurationSnapshot(ctx, &in)
}

func (a *restObjClusterV1ConfigurationSnapshot) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*cluster.ConfigurationSnapshot, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := cluster.ConfigurationSnapshot{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoDeleteConfigurationSnapshot(ctx, &in)
}

func (a *restObjClusterV1ConfigurationSnapshot) List(ctx context.Context, options *api.ListWatchOptions) ([]*cluster.ConfigurationSnapshot, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}

	r, err := a.endpoints.AutoListConfigurationSnapshot(ctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *restObjClusterV1ConfigurationSnapshot) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoWatchConfigurationSnapshot(ctx, options)
}

func (a *restObjClusterV1ConfigurationSnapshot) Allowed(oper apiintf.APIOperType) bool {
	switch oper {
	case apiintf.CreateOper:
		return true
	case apiintf.UpdateOper:
		return true
	case apiintf.GetOper:
		return true
	case apiintf.DeleteOper:
		return true
	case apiintf.ListOper:
		return false
	case apiintf.WatchOper:
		return true
	default:
		return false
	}
}

func (a *restObjClusterV1ConfigurationSnapshot) Save(ctx context.Context, in *cluster.ConfigurationSnapshotRequest) (*cluster.ConfigurationSnapshot, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.SaveConfigurationSnapshot(ctx, in)
}

type grpcObjClusterV1SnapshotRestore struct {
	logger log.Logger
	client cluster.ServiceClusterV1Client
}

func (a *grpcObjClusterV1SnapshotRestore) Create(ctx context.Context, in *cluster.SnapshotRestore) (*cluster.SnapshotRestore, error) {
	a.logger.DebugLog("msg", "received call", "object", "SnapshotRestore", "oper", "create")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoAddSnapshotRestore(nctx, in)
}

func (a *grpcObjClusterV1SnapshotRestore) Update(ctx context.Context, in *cluster.SnapshotRestore) (*cluster.SnapshotRestore, error) {
	a.logger.DebugLog("msg", "received call", "object", "SnapshotRestore", "oper", "update")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoUpdateSnapshotRestore(nctx, in)
}

func (a *grpcObjClusterV1SnapshotRestore) UpdateStatus(ctx context.Context, in *cluster.SnapshotRestore) (*cluster.SnapshotRestore, error) {
	a.logger.DebugLog("msg", "received call", "object", "SnapshotRestore", "oper", "update")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	nctx = addStatusUpd(nctx)
	return a.client.AutoUpdateSnapshotRestore(nctx, in)
}

func (a *grpcObjClusterV1SnapshotRestore) Label(ctx context.Context, in *api.Label) (*cluster.SnapshotRestore, error) {
	a.logger.DebugLog("msg", "received call", "object", "SnapshotRestore", "oper", "label")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoLabelSnapshotRestore(nctx, in)
}

func (a *grpcObjClusterV1SnapshotRestore) Get(ctx context.Context, objMeta *api.ObjectMeta) (*cluster.SnapshotRestore, error) {
	a.logger.DebugLog("msg", "received call", "object", "SnapshotRestore", "oper", "get")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := cluster.SnapshotRestore{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoGetSnapshotRestore(nctx, &in)
}

func (a *grpcObjClusterV1SnapshotRestore) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*cluster.SnapshotRestore, error) {
	a.logger.DebugLog("msg", "received call", "object", "SnapshotRestore", "oper", "delete")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := cluster.SnapshotRestore{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoDeleteSnapshotRestore(nctx, &in)
}

func (a *grpcObjClusterV1SnapshotRestore) List(ctx context.Context, options *api.ListWatchOptions) ([]*cluster.SnapshotRestore, error) {
	a.logger.DebugLog("msg", "received call", "object", "SnapshotRestore", "oper", "list")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	r, err := a.client.AutoListSnapshotRestore(nctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *grpcObjClusterV1SnapshotRestore) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	a.logger.DebugLog("msg", "received call", "object", "SnapshotRestore", "oper", "WatchOper")
	nctx := addVersion(ctx, "v1")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	stream, err := a.client.AutoWatchSnapshotRestore(nctx, options)
	if err != nil {
		return nil, err
	}
	wstream := stream.(cluster.ClusterV1_AutoWatchSnapshotRestoreClient)
	bridgefn := func(lw *listerwatcher.WatcherClient) {
		for {
			r, err := wstream.Recv()
			if err != nil {
				a.logger.ErrorLog("msg", "error on receive", "err", err)
				close(lw.OutCh)
				return
			}
			for _, e := range r.Events {
				ev := kvstore.WatchEvent{
					Type:   kvstore.WatchEventType(e.Type),
					Object: e.Object,
				}
				select {
				case lw.OutCh <- &ev:
				case <-wstream.Context().Done():
					close(lw.OutCh)
					return
				}
			}
		}
	}
	lw := listerwatcher.NewWatcherClient(wstream, bridgefn)
	lw.Run()
	return lw, nil
}

func (a *grpcObjClusterV1SnapshotRestore) Restore(ctx context.Context, in *cluster.SnapshotRestore) (*cluster.SnapshotRestore, error) {
	a.logger.DebugLog("msg", "received call", "object", "{Restore SnapshotRestore SnapshotRestore}", "oper", "Restore")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.Restore(nctx, in)
}

func (a *grpcObjClusterV1SnapshotRestore) Allowed(oper apiintf.APIOperType) bool {
	return true
}

type restObjClusterV1SnapshotRestore struct {
	endpoints cluster.EndpointsClusterV1RestClient
	instance  string
}

func (a *restObjClusterV1SnapshotRestore) Create(ctx context.Context, in *cluster.SnapshotRestore) (*cluster.SnapshotRestore, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoAddSnapshotRestore(ctx, in)
}

func (a *restObjClusterV1SnapshotRestore) Update(ctx context.Context, in *cluster.SnapshotRestore) (*cluster.SnapshotRestore, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoUpdateSnapshotRestore(ctx, in)
}

func (a *restObjClusterV1SnapshotRestore) UpdateStatus(ctx context.Context, in *cluster.SnapshotRestore) (*cluster.SnapshotRestore, error) {
	return nil, errors.New("not supported for REST")
}

func (a *restObjClusterV1SnapshotRestore) Label(ctx context.Context, in *api.Label) (*cluster.SnapshotRestore, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoLabelSnapshotRestore(ctx, in)
}

func (a *restObjClusterV1SnapshotRestore) Get(ctx context.Context, objMeta *api.ObjectMeta) (*cluster.SnapshotRestore, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := cluster.SnapshotRestore{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoGetSnapshotRestore(ctx, &in)
}

func (a *restObjClusterV1SnapshotRestore) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*cluster.SnapshotRestore, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := cluster.SnapshotRestore{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoDeleteSnapshotRestore(ctx, &in)
}

func (a *restObjClusterV1SnapshotRestore) List(ctx context.Context, options *api.ListWatchOptions) ([]*cluster.SnapshotRestore, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}

	r, err := a.endpoints.AutoListSnapshotRestore(ctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *restObjClusterV1SnapshotRestore) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoWatchSnapshotRestore(ctx, options)
}

func (a *restObjClusterV1SnapshotRestore) Allowed(oper apiintf.APIOperType) bool {
	switch oper {
	case apiintf.CreateOper:
		return false
	case apiintf.UpdateOper:
		return false
	case apiintf.GetOper:
		return true
	case apiintf.DeleteOper:
		return false
	case apiintf.ListOper:
		return false
	case apiintf.WatchOper:
		return false
	default:
		return false
	}
}

func (a *restObjClusterV1SnapshotRestore) Restore(ctx context.Context, in *cluster.SnapshotRestore) (*cluster.SnapshotRestore, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.RestoreSnapshotRestore(ctx, in)
}

type grpcObjClusterV1License struct {
	logger log.Logger
	client cluster.ServiceClusterV1Client
}

func (a *grpcObjClusterV1License) Create(ctx context.Context, in *cluster.License) (*cluster.License, error) {
	a.logger.DebugLog("msg", "received call", "object", "License", "oper", "create")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoAddLicense(nctx, in)
}

func (a *grpcObjClusterV1License) Update(ctx context.Context, in *cluster.License) (*cluster.License, error) {
	a.logger.DebugLog("msg", "received call", "object", "License", "oper", "update")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoUpdateLicense(nctx, in)
}

func (a *grpcObjClusterV1License) UpdateStatus(ctx context.Context, in *cluster.License) (*cluster.License, error) {
	a.logger.DebugLog("msg", "received call", "object", "License", "oper", "update")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	nctx = addStatusUpd(nctx)
	return a.client.AutoUpdateLicense(nctx, in)
}

func (a *grpcObjClusterV1License) Label(ctx context.Context, in *api.Label) (*cluster.License, error) {
	a.logger.DebugLog("msg", "received call", "object", "License", "oper", "label")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoLabelLicense(nctx, in)
}

func (a *grpcObjClusterV1License) Get(ctx context.Context, objMeta *api.ObjectMeta) (*cluster.License, error) {
	a.logger.DebugLog("msg", "received call", "object", "License", "oper", "get")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := cluster.License{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoGetLicense(nctx, &in)
}

func (a *grpcObjClusterV1License) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*cluster.License, error) {
	a.logger.DebugLog("msg", "received call", "object", "License", "oper", "delete")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := cluster.License{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoDeleteLicense(nctx, &in)
}

func (a *grpcObjClusterV1License) List(ctx context.Context, options *api.ListWatchOptions) ([]*cluster.License, error) {
	a.logger.DebugLog("msg", "received call", "object", "License", "oper", "list")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	r, err := a.client.AutoListLicense(nctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *grpcObjClusterV1License) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	a.logger.DebugLog("msg", "received call", "object", "License", "oper", "WatchOper")
	nctx := addVersion(ctx, "v1")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	stream, err := a.client.AutoWatchLicense(nctx, options)
	if err != nil {
		return nil, err
	}
	wstream := stream.(cluster.ClusterV1_AutoWatchLicenseClient)
	bridgefn := func(lw *listerwatcher.WatcherClient) {
		for {
			r, err := wstream.Recv()
			if err != nil {
				a.logger.ErrorLog("msg", "error on receive", "err", err)
				close(lw.OutCh)
				return
			}
			for _, e := range r.Events {
				ev := kvstore.WatchEvent{
					Type:   kvstore.WatchEventType(e.Type),
					Object: e.Object,
				}
				select {
				case lw.OutCh <- &ev:
				case <-wstream.Context().Done():
					close(lw.OutCh)
					return
				}
			}
		}
	}
	lw := listerwatcher.NewWatcherClient(wstream, bridgefn)
	lw.Run()
	return lw, nil
}

func (a *grpcObjClusterV1License) Allowed(oper apiintf.APIOperType) bool {
	return true
}

type restObjClusterV1License struct {
	endpoints cluster.EndpointsClusterV1RestClient
	instance  string
}

func (a *restObjClusterV1License) Create(ctx context.Context, in *cluster.License) (*cluster.License, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoAddLicense(ctx, in)
}

func (a *restObjClusterV1License) Update(ctx context.Context, in *cluster.License) (*cluster.License, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoUpdateLicense(ctx, in)
}

func (a *restObjClusterV1License) UpdateStatus(ctx context.Context, in *cluster.License) (*cluster.License, error) {
	return nil, errors.New("not supported for REST")
}

func (a *restObjClusterV1License) Label(ctx context.Context, in *api.Label) (*cluster.License, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoLabelLicense(ctx, in)
}

func (a *restObjClusterV1License) Get(ctx context.Context, objMeta *api.ObjectMeta) (*cluster.License, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := cluster.License{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoGetLicense(ctx, &in)
}

func (a *restObjClusterV1License) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*cluster.License, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := cluster.License{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoDeleteLicense(ctx, &in)
}

func (a *restObjClusterV1License) List(ctx context.Context, options *api.ListWatchOptions) ([]*cluster.License, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}

	r, err := a.endpoints.AutoListLicense(ctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *restObjClusterV1License) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoWatchLicense(ctx, options)
}

func (a *restObjClusterV1License) Allowed(oper apiintf.APIOperType) bool {
	switch oper {
	case apiintf.CreateOper:
		return true
	case apiintf.UpdateOper:
		return true
	case apiintf.GetOper:
		return true
	case apiintf.DeleteOper:
		return false
	case apiintf.ListOper:
		return false
	case apiintf.WatchOper:
		return false
	default:
		return false
	}
}

type grpcObjClusterV1DSCProfile struct {
	logger log.Logger
	client cluster.ServiceClusterV1Client
}

func (a *grpcObjClusterV1DSCProfile) Create(ctx context.Context, in *cluster.DSCProfile) (*cluster.DSCProfile, error) {
	a.logger.DebugLog("msg", "received call", "object", "DSCProfile", "oper", "create")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoAddDSCProfile(nctx, in)
}

func (a *grpcObjClusterV1DSCProfile) Update(ctx context.Context, in *cluster.DSCProfile) (*cluster.DSCProfile, error) {
	a.logger.DebugLog("msg", "received call", "object", "DSCProfile", "oper", "update")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoUpdateDSCProfile(nctx, in)
}

func (a *grpcObjClusterV1DSCProfile) UpdateStatus(ctx context.Context, in *cluster.DSCProfile) (*cluster.DSCProfile, error) {
	a.logger.DebugLog("msg", "received call", "object", "DSCProfile", "oper", "update")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	nctx = addStatusUpd(nctx)
	return a.client.AutoUpdateDSCProfile(nctx, in)
}

func (a *grpcObjClusterV1DSCProfile) Label(ctx context.Context, in *api.Label) (*cluster.DSCProfile, error) {
	a.logger.DebugLog("msg", "received call", "object", "DSCProfile", "oper", "label")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoLabelDSCProfile(nctx, in)
}

func (a *grpcObjClusterV1DSCProfile) Get(ctx context.Context, objMeta *api.ObjectMeta) (*cluster.DSCProfile, error) {
	a.logger.DebugLog("msg", "received call", "object", "DSCProfile", "oper", "get")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := cluster.DSCProfile{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoGetDSCProfile(nctx, &in)
}

func (a *grpcObjClusterV1DSCProfile) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*cluster.DSCProfile, error) {
	a.logger.DebugLog("msg", "received call", "object", "DSCProfile", "oper", "delete")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := cluster.DSCProfile{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoDeleteDSCProfile(nctx, &in)
}

func (a *grpcObjClusterV1DSCProfile) List(ctx context.Context, options *api.ListWatchOptions) ([]*cluster.DSCProfile, error) {
	a.logger.DebugLog("msg", "received call", "object", "DSCProfile", "oper", "list")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	r, err := a.client.AutoListDSCProfile(nctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *grpcObjClusterV1DSCProfile) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	a.logger.DebugLog("msg", "received call", "object", "DSCProfile", "oper", "WatchOper")
	nctx := addVersion(ctx, "v1")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	stream, err := a.client.AutoWatchDSCProfile(nctx, options)
	if err != nil {
		return nil, err
	}
	wstream := stream.(cluster.ClusterV1_AutoWatchDSCProfileClient)
	bridgefn := func(lw *listerwatcher.WatcherClient) {
		for {
			r, err := wstream.Recv()
			if err != nil {
				a.logger.ErrorLog("msg", "error on receive", "err", err)
				close(lw.OutCh)
				return
			}
			for _, e := range r.Events {
				ev := kvstore.WatchEvent{
					Type:   kvstore.WatchEventType(e.Type),
					Object: e.Object,
				}
				select {
				case lw.OutCh <- &ev:
				case <-wstream.Context().Done():
					close(lw.OutCh)
					return
				}
			}
		}
	}
	lw := listerwatcher.NewWatcherClient(wstream, bridgefn)
	lw.Run()
	return lw, nil
}

func (a *grpcObjClusterV1DSCProfile) Allowed(oper apiintf.APIOperType) bool {
	return true
}

type restObjClusterV1DSCProfile struct {
	endpoints cluster.EndpointsClusterV1RestClient
	instance  string
}

func (a *restObjClusterV1DSCProfile) Create(ctx context.Context, in *cluster.DSCProfile) (*cluster.DSCProfile, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoAddDSCProfile(ctx, in)
}

func (a *restObjClusterV1DSCProfile) Update(ctx context.Context, in *cluster.DSCProfile) (*cluster.DSCProfile, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoUpdateDSCProfile(ctx, in)
}

func (a *restObjClusterV1DSCProfile) UpdateStatus(ctx context.Context, in *cluster.DSCProfile) (*cluster.DSCProfile, error) {
	return nil, errors.New("not supported for REST")
}

func (a *restObjClusterV1DSCProfile) Label(ctx context.Context, in *api.Label) (*cluster.DSCProfile, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoLabelDSCProfile(ctx, in)
}

func (a *restObjClusterV1DSCProfile) Get(ctx context.Context, objMeta *api.ObjectMeta) (*cluster.DSCProfile, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := cluster.DSCProfile{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoGetDSCProfile(ctx, &in)
}

func (a *restObjClusterV1DSCProfile) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*cluster.DSCProfile, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := cluster.DSCProfile{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoDeleteDSCProfile(ctx, &in)
}

func (a *restObjClusterV1DSCProfile) List(ctx context.Context, options *api.ListWatchOptions) ([]*cluster.DSCProfile, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}

	r, err := a.endpoints.AutoListDSCProfile(ctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *restObjClusterV1DSCProfile) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoWatchDSCProfile(ctx, options)
}

func (a *restObjClusterV1DSCProfile) Allowed(oper apiintf.APIOperType) bool {
	switch oper {
	case apiintf.CreateOper:
		return true
	case apiintf.UpdateOper:
		return true
	case apiintf.GetOper:
		return true
	case apiintf.DeleteOper:
		return true
	case apiintf.ListOper:
		return true
	case apiintf.WatchOper:
		return true
	default:
		return false
	}
}

type crudClientClusterV1 struct {
	logger log.Logger
	client cluster.ServiceClusterV1Client

	grpcCluster                cluster.ClusterV1ClusterInterface
	grpcNode                   cluster.ClusterV1NodeInterface
	grpcHost                   cluster.ClusterV1HostInterface
	grpcDistributedServiceCard cluster.ClusterV1DistributedServiceCardInterface
	grpcTenant                 cluster.ClusterV1TenantInterface
	grpcVersion                cluster.ClusterV1VersionInterface
	grpcConfigurationSnapshot  cluster.ClusterV1ConfigurationSnapshotInterface
	grpcSnapshotRestore        cluster.ClusterV1SnapshotRestoreInterface
	grpcLicense                cluster.ClusterV1LicenseInterface
	grpcDSCProfile             cluster.ClusterV1DSCProfileInterface
}

// NewGrpcCrudClientClusterV1 creates a GRPC client for the service
func NewGrpcCrudClientClusterV1(conn *grpc.ClientConn, logger log.Logger) cluster.ClusterV1Interface {
	client := NewClusterV1Backend(conn, logger)
	return &crudClientClusterV1{
		logger: logger,
		client: client,

		grpcCluster:                &grpcObjClusterV1Cluster{client: client, logger: logger},
		grpcNode:                   &grpcObjClusterV1Node{client: client, logger: logger},
		grpcHost:                   &grpcObjClusterV1Host{client: client, logger: logger},
		grpcDistributedServiceCard: &grpcObjClusterV1DistributedServiceCard{client: client, logger: logger},
		grpcTenant:                 &grpcObjClusterV1Tenant{client: client, logger: logger},
		grpcVersion:                &grpcObjClusterV1Version{client: client, logger: logger},
		grpcConfigurationSnapshot:  &grpcObjClusterV1ConfigurationSnapshot{client: client, logger: logger},
		grpcSnapshotRestore:        &grpcObjClusterV1SnapshotRestore{client: client, logger: logger},
		grpcLicense:                &grpcObjClusterV1License{client: client, logger: logger},
		grpcDSCProfile:             &grpcObjClusterV1DSCProfile{client: client, logger: logger},
	}
}

func (a *crudClientClusterV1) Cluster() cluster.ClusterV1ClusterInterface {
	return a.grpcCluster
}

func (a *crudClientClusterV1) Node() cluster.ClusterV1NodeInterface {
	return a.grpcNode
}

func (a *crudClientClusterV1) Host() cluster.ClusterV1HostInterface {
	return a.grpcHost
}

func (a *crudClientClusterV1) DistributedServiceCard() cluster.ClusterV1DistributedServiceCardInterface {
	return a.grpcDistributedServiceCard
}

func (a *crudClientClusterV1) Tenant() cluster.ClusterV1TenantInterface {
	return a.grpcTenant
}

func (a *crudClientClusterV1) Version() cluster.ClusterV1VersionInterface {
	return a.grpcVersion
}

func (a *crudClientClusterV1) ConfigurationSnapshot() cluster.ClusterV1ConfigurationSnapshotInterface {
	return a.grpcConfigurationSnapshot
}

func (a *crudClientClusterV1) SnapshotRestore() cluster.ClusterV1SnapshotRestoreInterface {
	return a.grpcSnapshotRestore
}

func (a *crudClientClusterV1) License() cluster.ClusterV1LicenseInterface {
	return a.grpcLicense
}

func (a *crudClientClusterV1) DSCProfile() cluster.ClusterV1DSCProfileInterface {
	return a.grpcDSCProfile
}

func (a *crudClientClusterV1) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	a.logger.DebugLog("msg", "received call", "object", "ClusterV1", "oper", "WatchOper")
	nctx := addVersion(ctx, "v1")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	stream, err := a.client.AutoWatchSvcClusterV1(nctx, options)
	if err != nil {
		return nil, err
	}
	wstream := stream.(cluster.ClusterV1_AutoWatchSvcClusterV1Client)
	bridgefn := func(lw *listerwatcher.WatcherClient) {
		for {
			r, err := wstream.Recv()
			if err != nil {
				a.logger.ErrorLog("msg", "error on receive", "err", err)
				close(lw.OutCh)
				return
			}
			for _, e := range r.Events {
				ev := kvstore.WatchEvent{Type: kvstore.WatchEventType(e.Type)}
				robj, err := listerwatcher.GetObject(e)
				if err != nil {
					a.logger.ErrorLog("msg", "error on receive unmarshall", "err", err)
					close(lw.OutCh)
					return
				}
				ev.Object = robj
				select {
				case lw.OutCh <- &ev:
				case <-wstream.Context().Done():
					close(lw.OutCh)
					return
				}
			}
		}
	}
	lw := listerwatcher.NewWatcherClient(wstream, bridgefn)
	lw.Run()
	return lw, nil
}

type crudRestClientClusterV1 struct {
	restCluster                cluster.ClusterV1ClusterInterface
	restNode                   cluster.ClusterV1NodeInterface
	restHost                   cluster.ClusterV1HostInterface
	restDistributedServiceCard cluster.ClusterV1DistributedServiceCardInterface
	restTenant                 cluster.ClusterV1TenantInterface
	restVersion                cluster.ClusterV1VersionInterface
	restConfigurationSnapshot  cluster.ClusterV1ConfigurationSnapshotInterface
	restSnapshotRestore        cluster.ClusterV1SnapshotRestoreInterface
	restLicense                cluster.ClusterV1LicenseInterface
	restDSCProfile             cluster.ClusterV1DSCProfileInterface
}

// NewRestCrudClientClusterV1 creates a REST client for the service.
func NewRestCrudClientClusterV1(url string, httpClient *http.Client) cluster.ClusterV1Interface {
	endpoints, err := cluster.MakeClusterV1RestClientEndpoints(url, httpClient)
	if err != nil {
		oldlog.Fatal("failed to create client")
	}
	return &crudRestClientClusterV1{

		restCluster:                &restObjClusterV1Cluster{endpoints: endpoints, instance: url},
		restNode:                   &restObjClusterV1Node{endpoints: endpoints, instance: url},
		restHost:                   &restObjClusterV1Host{endpoints: endpoints, instance: url},
		restDistributedServiceCard: &restObjClusterV1DistributedServiceCard{endpoints: endpoints, instance: url},
		restTenant:                 &restObjClusterV1Tenant{endpoints: endpoints, instance: url},
		restVersion:                &restObjClusterV1Version{endpoints: endpoints, instance: url},
		restConfigurationSnapshot:  &restObjClusterV1ConfigurationSnapshot{endpoints: endpoints, instance: url},
		restSnapshotRestore:        &restObjClusterV1SnapshotRestore{endpoints: endpoints, instance: url},
		restLicense:                &restObjClusterV1License{endpoints: endpoints, instance: url},
		restDSCProfile:             &restObjClusterV1DSCProfile{endpoints: endpoints, instance: url},
	}
}

// NewStagedRestCrudClientClusterV1 creates a REST client for the service.
func NewStagedRestCrudClientClusterV1(url string, id string, httpClient *http.Client) cluster.ClusterV1Interface {
	endpoints, err := cluster.MakeClusterV1StagedRestClientEndpoints(url, id, httpClient)
	if err != nil {
		oldlog.Fatal("failed to create client")
	}
	return &crudRestClientClusterV1{

		restCluster:                &restObjClusterV1Cluster{endpoints: endpoints, instance: url},
		restNode:                   &restObjClusterV1Node{endpoints: endpoints, instance: url},
		restHost:                   &restObjClusterV1Host{endpoints: endpoints, instance: url},
		restDistributedServiceCard: &restObjClusterV1DistributedServiceCard{endpoints: endpoints, instance: url},
		restTenant:                 &restObjClusterV1Tenant{endpoints: endpoints, instance: url},
		restVersion:                &restObjClusterV1Version{endpoints: endpoints, instance: url},
		restConfigurationSnapshot:  &restObjClusterV1ConfigurationSnapshot{endpoints: endpoints, instance: url},
		restSnapshotRestore:        &restObjClusterV1SnapshotRestore{endpoints: endpoints, instance: url},
		restLicense:                &restObjClusterV1License{endpoints: endpoints, instance: url},
		restDSCProfile:             &restObjClusterV1DSCProfile{endpoints: endpoints, instance: url},
	}
}

func (a *crudRestClientClusterV1) Cluster() cluster.ClusterV1ClusterInterface {
	return a.restCluster
}

func (a *crudRestClientClusterV1) Node() cluster.ClusterV1NodeInterface {
	return a.restNode
}

func (a *crudRestClientClusterV1) Host() cluster.ClusterV1HostInterface {
	return a.restHost
}

func (a *crudRestClientClusterV1) DistributedServiceCard() cluster.ClusterV1DistributedServiceCardInterface {
	return a.restDistributedServiceCard
}

func (a *crudRestClientClusterV1) Tenant() cluster.ClusterV1TenantInterface {
	return a.restTenant
}

func (a *crudRestClientClusterV1) Version() cluster.ClusterV1VersionInterface {
	return a.restVersion
}

func (a *crudRestClientClusterV1) ConfigurationSnapshot() cluster.ClusterV1ConfigurationSnapshotInterface {
	return a.restConfigurationSnapshot
}

func (a *crudRestClientClusterV1) SnapshotRestore() cluster.ClusterV1SnapshotRestoreInterface {
	return a.restSnapshotRestore
}

func (a *crudRestClientClusterV1) License() cluster.ClusterV1LicenseInterface {
	return a.restLicense
}

func (a *crudRestClientClusterV1) DSCProfile() cluster.ClusterV1DSCProfileInterface {
	return a.restDSCProfile
}

func (a *crudRestClientClusterV1) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	return nil, errors.New("method unimplemented")
}
