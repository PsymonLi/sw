// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: cmd.proto

/*
	Package cluster is a generated protocol buffer package.

	Service name

	It is generated from these files:
		cmd.proto
		svc_cluster.proto
		tenant.proto

	It has these top-level messages:
		Cluster
		ClusterSpec
		ClusterStatus
		Node
		NodeCondition
		NodeSpec
		NodeStatus
		PortCondition
		PortSpec
		PortStatus
		SmartNIC
		SmartNICCondition
		SmartNICSpec
		SmartNICStatus
		AutoMsgClusterWatchHelper
		AutoMsgNodeWatchHelper
		AutoMsgSmartNICWatchHelper
		AutoMsgTenantWatchHelper
		ClusterList
		NodeList
		SmartNICList
		TenantList
		Tenant
		TenantSpec
		TenantStatus
*/
package cluster

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/pensando/grpc-gateway/third_party/googleapis/google/api"
import _ "github.com/pensando/sw/venice/utils/apigen/annotations"
import _ "github.com/gogo/protobuf/gogoproto"
import api "github.com/pensando/sw/api"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// These are valid condition statuses.
type ConditionStatus int32

const (
	ConditionStatus_UNKNOWN ConditionStatus = 0
	ConditionStatus_TRUE    ConditionStatus = 1
	ConditionStatus_FALSE   ConditionStatus = 2
)

var ConditionStatus_name = map[int32]string{
	0: "UNKNOWN",
	1: "TRUE",
	2: "FALSE",
}
var ConditionStatus_value = map[string]int32{
	"UNKNOWN": 0,
	"TRUE":    1,
	"FALSE":   2,
}

func (x ConditionStatus) String() string {
	return proto.EnumName(ConditionStatus_name, int32(x))
}
func (ConditionStatus) EnumDescriptor() ([]byte, []int) { return fileDescriptorCmd, []int{0} }

// NodeRole Type
type NodeCondition_ConditionType int32

const (
	NodeCondition_LEADER NodeCondition_ConditionType = 0
)

var NodeCondition_ConditionType_name = map[int32]string{
	0: "LEADER",
}
var NodeCondition_ConditionType_value = map[string]int32{
	"LEADER": 0,
}

func (x NodeCondition_ConditionType) String() string {
	return proto.EnumName(NodeCondition_ConditionType_name, int32(x))
}
func (NodeCondition_ConditionType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorCmd, []int{4, 0}
}

// Various phases in lifecycle of a Node
type NodeSpec_NodeRole int32

const (
	NodeSpec_CONTROLLER NodeSpec_NodeRole = 0
	NodeSpec_WORKLOAD   NodeSpec_NodeRole = 1
	NodeSpec_QUORUM     NodeSpec_NodeRole = 2
)

var NodeSpec_NodeRole_name = map[int32]string{
	0: "CONTROLLER",
	1: "WORKLOAD",
	2: "QUORUM",
}
var NodeSpec_NodeRole_value = map[string]int32{
	"CONTROLLER": 0,
	"WORKLOAD":   1,
	"QUORUM":     2,
}

func (x NodeSpec_NodeRole) String() string {
	return proto.EnumName(NodeSpec_NodeRole_name, int32(x))
}
func (NodeSpec_NodeRole) EnumDescriptor() ([]byte, []int) { return fileDescriptorCmd, []int{5, 0} }

// These are valid conditions of a Node
type NodeStatus_NodePhase int32

const (
	NodeStatus_UNKNOWN NodeStatus_NodePhase = 0
	NodeStatus_PENDING NodeStatus_NodePhase = 1
	NodeStatus_JOINED  NodeStatus_NodePhase = 2
	NodeStatus_FAILED  NodeStatus_NodePhase = 3
)

var NodeStatus_NodePhase_name = map[int32]string{
	0: "UNKNOWN",
	1: "PENDING",
	2: "JOINED",
	3: "FAILED",
}
var NodeStatus_NodePhase_value = map[string]int32{
	"UNKNOWN": 0,
	"PENDING": 1,
	"JOINED":  2,
	"FAILED":  3,
}

func (x NodeStatus_NodePhase) String() string {
	return proto.EnumName(NodeStatus_NodePhase_name, int32(x))
}
func (NodeStatus_NodePhase) EnumDescriptor() ([]byte, []int) { return fileDescriptorCmd, []int{6, 0} }

type PortCondition_ConditionType int32

const (
	PortCondition_PORT_UP PortCondition_ConditionType = 0
)

var PortCondition_ConditionType_name = map[int32]string{
	0: "PORT_UP",
}
var PortCondition_ConditionType_value = map[string]int32{
	"PORT_UP": 0,
}

func (x PortCondition_ConditionType) String() string {
	return proto.EnumName(PortCondition_ConditionType_name, int32(x))
}
func (PortCondition_ConditionType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorCmd, []int{7, 0}
}

type SmartNICCondition_ConditionType int32

const (
	SmartNICCondition_HEALTHY     SmartNICCondition_ConditionType = 0
	SmartNICCondition_UNREACHABLE SmartNICCondition_ConditionType = 1
)

var SmartNICCondition_ConditionType_name = map[int32]string{
	0: "HEALTHY",
	1: "UNREACHABLE",
}
var SmartNICCondition_ConditionType_value = map[string]int32{
	"HEALTHY":     0,
	"UNREACHABLE": 1,
}

func (x SmartNICCondition_ConditionType) String() string {
	return proto.EnumName(SmartNICCondition_ConditionType_name, int32(x))
}
func (SmartNICCondition_ConditionType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorCmd, []int{11, 0}
}

type SmartNICSpec_SmartNICPhase int32

const (
	SmartNICSpec_UNKNOWN     SmartNICSpec_SmartNICPhase = 0
	SmartNICSpec_REGISTERING SmartNICSpec_SmartNICPhase = 1
	SmartNICSpec_REJECTED    SmartNICSpec_SmartNICPhase = 2
	SmartNICSpec_PENDING     SmartNICSpec_SmartNICPhase = 3
	SmartNICSpec_ADMITTED    SmartNICSpec_SmartNICPhase = 4
)

var SmartNICSpec_SmartNICPhase_name = map[int32]string{
	0: "UNKNOWN",
	1: "REGISTERING",
	2: "REJECTED",
	3: "PENDING",
	4: "ADMITTED",
}
var SmartNICSpec_SmartNICPhase_value = map[string]int32{
	"UNKNOWN":     0,
	"REGISTERING": 1,
	"REJECTED":    2,
	"PENDING":     3,
	"ADMITTED":    4,
}

func (x SmartNICSpec_SmartNICPhase) String() string {
	return proto.EnumName(SmartNICSpec_SmartNICPhase_name, int32(x))
}
func (SmartNICSpec_SmartNICPhase) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorCmd, []int{12, 0}
}

// --------------------------------- CLUSTER ---------------------------------------------
//
// Cluster represents a full cluster venice and workload nodes
//
// Entity responsible & scenarios involved in managing this object:
//
//      Create:
//          o NetOps-admin
//              - initial cluster creation
//      Modify:
//          o NetOps-admin
//              - update spec attributes
//          o CMD
//              - update status attributes
//      Delete:
//          o NetOps-admin
//              - TBD
//
type Cluster struct {
	api.TypeMeta   `protobuf:"bytes,1,opt,name=T,embedded=T" json:",inline"`
	api.ObjectMeta `protobuf:"bytes,2,opt,name=O,embedded=O" json:"meta,omitempty"`
	// Spec contains the configuration of the cluster.
	Spec ClusterSpec `protobuf:"bytes,3,opt,name=Spec" json:"spec,omitempty"`
	// Status contains the current state of the cluster.
	Status ClusterStatus `protobuf:"bytes,4,opt,name=Status" json:"status,omitempty"`
}

func (m *Cluster) Reset()                    { *m = Cluster{} }
func (m *Cluster) String() string            { return proto.CompactTextString(m) }
func (*Cluster) ProtoMessage()               {}
func (*Cluster) Descriptor() ([]byte, []int) { return fileDescriptorCmd, []int{0} }

func (m *Cluster) GetSpec() ClusterSpec {
	if m != nil {
		return m.Spec
	}
	return ClusterSpec{}
}

func (m *Cluster) GetStatus() ClusterStatus {
	if m != nil {
		return m.Status
	}
	return ClusterStatus{}
}

// ClusterSpec contains the configuration of the cluster.
type ClusterSpec struct {
	// QuorumNodes contains the list of hostnames for nodes configured to be quorum
	// nodes in the cluster.
	QuorumNodes []string `protobuf:"bytes,1,rep,name=QuorumNodes" json:"quorum-nodes,omitempty"`
	// VirtualIP is the IP address for managing the cluster. It will be hosted by
	// the winner of election between quorum nodes.
	VirtualIP string `protobuf:"bytes,2,opt,name=VirtualIP,proto3" json:"virtual-ip,omitempty"`
	// NTPServers contains the list of NTP servers for the cluster.
	NTPServers []string `protobuf:"bytes,3,rep,name=NTPServers" json:"ntp-servers,omitempty"`
	// DNSSubDomain is the DNS subdomain for the default tenant.
	DNSSubDomain string `protobuf:"bytes,4,opt,name=DNSSubDomain,proto3" json:"dns-subdomain,omitempty"`
	// AutoAdmitNICs when enabled auto-admits NICs that are validated
	// into Venice Cluster. When it is disabled, NICs validated by CMD are
	// set to Pending state and it requires Manual approval to be admitted
	// into the cluster.
	AutoAdmitNICs bool `protobuf:"varint,5,opt,name=AutoAdmitNICs,proto3" json:"auto-admit-nics,omitempty"`
}

func (m *ClusterSpec) Reset()                    { *m = ClusterSpec{} }
func (m *ClusterSpec) String() string            { return proto.CompactTextString(m) }
func (*ClusterSpec) ProtoMessage()               {}
func (*ClusterSpec) Descriptor() ([]byte, []int) { return fileDescriptorCmd, []int{1} }

func (m *ClusterSpec) GetQuorumNodes() []string {
	if m != nil {
		return m.QuorumNodes
	}
	return nil
}

func (m *ClusterSpec) GetVirtualIP() string {
	if m != nil {
		return m.VirtualIP
	}
	return ""
}

func (m *ClusterSpec) GetNTPServers() []string {
	if m != nil {
		return m.NTPServers
	}
	return nil
}

func (m *ClusterSpec) GetDNSSubDomain() string {
	if m != nil {
		return m.DNSSubDomain
	}
	return ""
}

func (m *ClusterSpec) GetAutoAdmitNICs() bool {
	if m != nil {
		return m.AutoAdmitNICs
	}
	return false
}

// ClusterStatus contains the current state of the Cluster.
type ClusterStatus struct {
	// Leader contains the node name of the cluster leader.
	Leader string `protobuf:"bytes,1,opt,name=Leader,proto3" json:"leader,omitempty"`
	// LastLeaderTransitionTime is when the leadership changed last time
	LastLeaderTransitionTime *api.Timestamp `protobuf:"bytes,2,opt,name=LastLeaderTransitionTime" json:"last-leader-transition-time,omitempty"`
}

func (m *ClusterStatus) Reset()                    { *m = ClusterStatus{} }
func (m *ClusterStatus) String() string            { return proto.CompactTextString(m) }
func (*ClusterStatus) ProtoMessage()               {}
func (*ClusterStatus) Descriptor() ([]byte, []int) { return fileDescriptorCmd, []int{2} }

func (m *ClusterStatus) GetLeader() string {
	if m != nil {
		return m.Leader
	}
	return ""
}

func (m *ClusterStatus) GetLastLeaderTransitionTime() *api.Timestamp {
	if m != nil {
		return m.LastLeaderTransitionTime
	}
	return nil
}

// ---------------------------------- NODE -------------------------------------------
//
// Node is representation of a single node in the system.
//
// Entity responsible & scenarios involved in managing this object:
//
//      Create:
//          o NetOps-admin
//              - initial node creation for Baremetal node
//          o CMD
//              - auto created when Hypervisor Node and NIC are
//                discovered via Orchestrator interface, NIC registration
//      Modify:
//          o NetOps-admin
//              - update spec for Baremetal node
//          o CMD
//              - update spec attributes for Hypervisor node
//              - update status attributes
//      Delete:
//          o NetOps-admin
//              - when Baremetal node is decommissioned
//          o CMD
//              - TBD
//
type Node struct {
	api.TypeMeta   `protobuf:"bytes,1,opt,name=T,embedded=T" json:",inline"`
	api.ObjectMeta `protobuf:"bytes,2,opt,name=O,embedded=O" json:"meta,omitempty"`
	// Spec contains the configuration of the node.
	Spec NodeSpec `protobuf:"bytes,3,opt,name=Spec" json:"spec,omitempty"`
	// Status contains the current state of the node.
	Status NodeStatus `protobuf:"bytes,4,opt,name=Status" json:"status,omitempty"`
}

func (m *Node) Reset()                    { *m = Node{} }
func (m *Node) String() string            { return proto.CompactTextString(m) }
func (*Node) ProtoMessage()               {}
func (*Node) Descriptor() ([]byte, []int) { return fileDescriptorCmd, []int{3} }

func (m *Node) GetSpec() NodeSpec {
	if m != nil {
		return m.Spec
	}
	return NodeSpec{}
}

func (m *Node) GetStatus() NodeStatus {
	if m != nil {
		return m.Status
	}
	return NodeStatus{}
}

// NodeSpec contains the configuration of the node.
type NodeCondition struct {
	// Roles is of list of roles a node can be configured with.
	Type               string `protobuf:"bytes,1,opt,name=Type,proto3" json:"type,omitempty"`
	Status             string `protobuf:"bytes,2,opt,name=Status,proto3" json:"status,omitempty"`
	LastTransitionTime string `protobuf:"bytes,3,opt,name=LastTransitionTime,proto3" json:"last-transition-time,omitempty"`
	Reason             string `protobuf:"bytes,4,opt,name=Reason,proto3" json:"reason,omitempty"`
	Message            string `protobuf:"bytes,5,opt,name=Message,proto3" json:"message,omitempty"`
}

func (m *NodeCondition) Reset()                    { *m = NodeCondition{} }
func (m *NodeCondition) String() string            { return proto.CompactTextString(m) }
func (*NodeCondition) ProtoMessage()               {}
func (*NodeCondition) Descriptor() ([]byte, []int) { return fileDescriptorCmd, []int{4} }

func (m *NodeCondition) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *NodeCondition) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *NodeCondition) GetLastTransitionTime() string {
	if m != nil {
		return m.LastTransitionTime
	}
	return ""
}

func (m *NodeCondition) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

func (m *NodeCondition) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

// NodeStatus contains the current state of the node.
type NodeSpec struct {
	// Current lifecycle phase of the node.
	Roles []string `protobuf:"bytes,1,rep,name=Roles" json:"roles,omitempty"`
}

func (m *NodeSpec) Reset()                    { *m = NodeSpec{} }
func (m *NodeSpec) String() string            { return proto.CompactTextString(m) }
func (*NodeSpec) ProtoMessage()               {}
func (*NodeSpec) Descriptor() ([]byte, []int) { return fileDescriptorCmd, []int{5} }

func (m *NodeSpec) GetRoles() []string {
	if m != nil {
		return m.Roles
	}
	return nil
}

// NodeCondition describes the state of a Node at a certain point.
type NodeStatus struct {
	// Type indicates a certain node condition
	Phase string `protobuf:"bytes,1,opt,name=Phase,proto3" json:"phase,omitempty"`
	// Condition Status
	Conditions []*NodeCondition `protobuf:"bytes,2,rep,name=Conditions" json:"conditions,omitempty"`
	// The last time the condition transitioned
	Nics []string `protobuf:"bytes,3,rep,name=Nics" json:"nics,omitempty"`
}

func (m *NodeStatus) Reset()                    { *m = NodeStatus{} }
func (m *NodeStatus) String() string            { return proto.CompactTextString(m) }
func (*NodeStatus) ProtoMessage()               {}
func (*NodeStatus) Descriptor() ([]byte, []int) { return fileDescriptorCmd, []int{6} }

func (m *NodeStatus) GetPhase() string {
	if m != nil {
		return m.Phase
	}
	return ""
}

func (m *NodeStatus) GetConditions() []*NodeCondition {
	if m != nil {
		return m.Conditions
	}
	return nil
}

func (m *NodeStatus) GetNics() []string {
	if m != nil {
		return m.Nics
	}
	return nil
}

// ------------------------------------ SMART NIC  -------------------------------------------
//
// SmartNIC represents the Naples I/O subsystem
//
// Entity responsible & scenarios involved in managing this object:
//
//      Create:
//          o CMD
//              - created as part of NIC registration, Admittance
//      Modify:
//          o CMD
//              - update spec attributes
//              - update status attributes
//      Delete:
//          o CMD
//              - aging out stale or rejected NICs (TBD)
//          o NetOps, SecOps
//              - Decomission a NIC (TBD)
//
type PortCondition struct {
	Type string `protobuf:"bytes,1,opt,name=Type,proto3" json:"type,omitempty"`
	// Object name is Serial-Number of the SmartNIC
	Status string `protobuf:"bytes,2,opt,name=Status,proto3" json:"status,omitempty"`
	// SmartNICSpec contains the configuration of the network adapter.
	LastTransitionTime string `protobuf:"bytes,3,opt,name=LastTransitionTime,proto3" json:"last-transition-time,omitempty"`
	// SmartNICStatus contains the current state of the network adapter.
	Reason  string `protobuf:"bytes,4,opt,name=Reason,proto3" json:"reason,omitempty"`
	Message string `protobuf:"bytes,5,opt,name=Message,proto3" json:"message,omitempty"`
}

func (m *PortCondition) Reset()                    { *m = PortCondition{} }
func (m *PortCondition) String() string            { return proto.CompactTextString(m) }
func (*PortCondition) ProtoMessage()               {}
func (*PortCondition) Descriptor() ([]byte, []int) { return fileDescriptorCmd, []int{7} }

func (m *PortCondition) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *PortCondition) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *PortCondition) GetLastTransitionTime() string {
	if m != nil {
		return m.LastTransitionTime
	}
	return ""
}

func (m *PortCondition) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

func (m *PortCondition) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

// SmartNICSpec contains configuration of the SmartNIC (Naples I/O subsystem)
type PortSpec struct {
	// Current phase of the SmartNIC.
	// When auto-admission is enabled, Phase will be set to NIC_ADMITTED
	// by CMD for validated NICs.
	// When auto-admission is not enabled, Phase will be set to NIC_PENDING
	// by CMD for validated NICs since it requires manual approval.
	// To admit the NIC as a part of manual admission, user is expected to
	// set the Phase to NIC_ADMITTED for the NICs that are in NIC_PENDING
	// state. Note : Whitelist mode is not supported yet.
	MacAddress string `protobuf:"bytes,1,opt,name=MacAddress,proto3" json:"mac-address,omitempty"`
}

func (m *PortSpec) Reset()                    { *m = PortSpec{} }
func (m *PortSpec) String() string            { return proto.CompactTextString(m) }
func (*PortSpec) ProtoMessage()               {}
func (*PortSpec) Descriptor() ([]byte, []int) { return fileDescriptorCmd, []int{8} }

func (m *PortSpec) GetMacAddress() string {
	if m != nil {
		return m.MacAddress
	}
	return ""
}

// SmartNICStatus contains current status of a SmartNIC
type PortStatus struct {
	// List of current NIC conditions
	MacAddress string `protobuf:"bytes,1,opt,name=MacAddress,proto3" json:"mac-address,omitempty"`
	// Serial number
	LinkSpeed string `protobuf:"bytes,2,opt,name=LinkSpeed,proto3" json:"link-speed,omitempty"`
	// Primary MAC address, which is MAC address of the primary PF exposed by SmartNIC
	Conditions []*PortCondition `protobuf:"bytes,3,rep,name=Conditions" json:"conditions,omitempty"`
}

func (m *PortStatus) Reset()                    { *m = PortStatus{} }
func (m *PortStatus) String() string            { return proto.CompactTextString(m) }
func (*PortStatus) ProtoMessage()               {}
func (*PortStatus) Descriptor() ([]byte, []int) { return fileDescriptorCmd, []int{9} }

func (m *PortStatus) GetMacAddress() string {
	if m != nil {
		return m.MacAddress
	}
	return ""
}

func (m *PortStatus) GetLinkSpeed() string {
	if m != nil {
		return m.LinkSpeed
	}
	return ""
}

func (m *PortStatus) GetConditions() []*PortCondition {
	if m != nil {
		return m.Conditions
	}
	return nil
}

// SmartNICCondition describes the state of a SmartNIC at a certain point.
type SmartNIC struct {
	// Type indicates a certain NIC condition
	api.TypeMeta `protobuf:"bytes,1,opt,name=T,embedded=T" json:",inline"`
	// Condition Status
	api.ObjectMeta `protobuf:"bytes,2,opt,name=O,embedded=O" json:"meta,omitempty"`
	// The last time the condition transitioned
	Spec SmartNICSpec `protobuf:"bytes,3,opt,name=Spec" json:"spec,omitempty"`
	// The reason for the condition's last transition
	Status SmartNICStatus `protobuf:"bytes,4,opt,name=Status" json:"status,omitempty"`
}

func (m *SmartNIC) Reset()                    { *m = SmartNIC{} }
func (m *SmartNIC) String() string            { return proto.CompactTextString(m) }
func (*SmartNIC) ProtoMessage()               {}
func (*SmartNIC) Descriptor() ([]byte, []int) { return fileDescriptorCmd, []int{10} }

func (m *SmartNIC) GetSpec() SmartNICSpec {
	if m != nil {
		return m.Spec
	}
	return SmartNICSpec{}
}

func (m *SmartNIC) GetStatus() SmartNICStatus {
	if m != nil {
		return m.Status
	}
	return SmartNICStatus{}
}

// PortSpec contains configuration of a port in SmartNIC
type SmartNICCondition struct {
	// Mac address of the Port, which is key identifier of the port
	Type               string `protobuf:"bytes,1,opt,name=Type,proto3" json:"type,omitempty"`
	Status             string `protobuf:"bytes,2,opt,name=Status,proto3" json:"status,omitempty"`
	LastTransitionTime string `protobuf:"bytes,3,opt,name=LastTransitionTime,proto3" json:"last-transition-time,omitempty"`
	Reason             string `protobuf:"bytes,4,opt,name=Reason,proto3" json:"reason,omitempty"`
	Message            string `protobuf:"bytes,5,opt,name=Message,proto3" json:"message,omitempty"`
}

func (m *SmartNICCondition) Reset()                    { *m = SmartNICCondition{} }
func (m *SmartNICCondition) String() string            { return proto.CompactTextString(m) }
func (*SmartNICCondition) ProtoMessage()               {}
func (*SmartNICCondition) Descriptor() ([]byte, []int) { return fileDescriptorCmd, []int{11} }

func (m *SmartNICCondition) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *SmartNICCondition) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *SmartNICCondition) GetLastTransitionTime() string {
	if m != nil {
		return m.LastTransitionTime
	}
	return ""
}

func (m *SmartNICCondition) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

func (m *SmartNICCondition) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

// PortStatus contains current status of a Port
type SmartNICSpec struct {
	// Mac address of the Port, which is key identifier of the port
	Phase string `protobuf:"bytes,1,opt,name=Phase,proto3" json:"phase,omitempty"`
	// LinkSpeed of the Port
	MgmtIp string `protobuf:"bytes,2,opt,name=MgmtIp,proto3" json:"mgmt-ip,omitempty"`
	// List of current Port conditions
	NodeName string     `protobuf:"bytes,3,opt,name=NodeName,proto3" json:"node-name,omitempty"`
	Ports    []PortSpec `protobuf:"bytes,4,rep,name=Ports" json:"ports,omitempty"`
}

func (m *SmartNICSpec) Reset()                    { *m = SmartNICSpec{} }
func (m *SmartNICSpec) String() string            { return proto.CompactTextString(m) }
func (*SmartNICSpec) ProtoMessage()               {}
func (*SmartNICSpec) Descriptor() ([]byte, []int) { return fileDescriptorCmd, []int{12} }

func (m *SmartNICSpec) GetPhase() string {
	if m != nil {
		return m.Phase
	}
	return ""
}

func (m *SmartNICSpec) GetMgmtIp() string {
	if m != nil {
		return m.MgmtIp
	}
	return ""
}

func (m *SmartNICSpec) GetNodeName() string {
	if m != nil {
		return m.NodeName
	}
	return ""
}

func (m *SmartNICSpec) GetPorts() []PortSpec {
	if m != nil {
		return m.Ports
	}
	return nil
}

// PortCondition describes the state of a Port at a certain point.
type SmartNICStatus struct {
	// Type indicates a certain Port condition
	Conditions []*SmartNICCondition `protobuf:"bytes,1,rep,name=Conditions" json:"conditions,omitempty"`
	// Condition Status
	SerialNum string `protobuf:"bytes,2,opt,name=SerialNum,proto3" json:"serial-num,omitempty"`
	// The last time the condition transitioned
	PrimaryMacAddress string `protobuf:"bytes,3,opt,name=PrimaryMacAddress,proto3" json:"primary-mac-address,omitempty"`
	// The reason for the condition's last transition
	Ports []*PortStatus `protobuf:"bytes,5,rep,name=Ports" json:"ports,omitempty"`
}

func (m *SmartNICStatus) Reset()                    { *m = SmartNICStatus{} }
func (m *SmartNICStatus) String() string            { return proto.CompactTextString(m) }
func (*SmartNICStatus) ProtoMessage()               {}
func (*SmartNICStatus) Descriptor() ([]byte, []int) { return fileDescriptorCmd, []int{13} }

func (m *SmartNICStatus) GetConditions() []*SmartNICCondition {
	if m != nil {
		return m.Conditions
	}
	return nil
}

func (m *SmartNICStatus) GetSerialNum() string {
	if m != nil {
		return m.SerialNum
	}
	return ""
}

func (m *SmartNICStatus) GetPrimaryMacAddress() string {
	if m != nil {
		return m.PrimaryMacAddress
	}
	return ""
}

func (m *SmartNICStatus) GetPorts() []*PortStatus {
	if m != nil {
		return m.Ports
	}
	return nil
}

func init() {
	proto.RegisterType((*Cluster)(nil), "cluster.Cluster")
	proto.RegisterType((*ClusterSpec)(nil), "cluster.ClusterSpec")
	proto.RegisterType((*ClusterStatus)(nil), "cluster.ClusterStatus")
	proto.RegisterType((*Node)(nil), "cluster.Node")
	proto.RegisterType((*NodeCondition)(nil), "cluster.NodeCondition")
	proto.RegisterType((*NodeSpec)(nil), "cluster.NodeSpec")
	proto.RegisterType((*NodeStatus)(nil), "cluster.NodeStatus")
	proto.RegisterType((*PortCondition)(nil), "cluster.PortCondition")
	proto.RegisterType((*PortSpec)(nil), "cluster.PortSpec")
	proto.RegisterType((*PortStatus)(nil), "cluster.PortStatus")
	proto.RegisterType((*SmartNIC)(nil), "cluster.SmartNIC")
	proto.RegisterType((*SmartNICCondition)(nil), "cluster.SmartNICCondition")
	proto.RegisterType((*SmartNICSpec)(nil), "cluster.SmartNICSpec")
	proto.RegisterType((*SmartNICStatus)(nil), "cluster.SmartNICStatus")
	proto.RegisterEnum("cluster.ConditionStatus", ConditionStatus_name, ConditionStatus_value)
	proto.RegisterEnum("cluster.NodeCondition_ConditionType", NodeCondition_ConditionType_name, NodeCondition_ConditionType_value)
	proto.RegisterEnum("cluster.NodeSpec_NodeRole", NodeSpec_NodeRole_name, NodeSpec_NodeRole_value)
	proto.RegisterEnum("cluster.NodeStatus_NodePhase", NodeStatus_NodePhase_name, NodeStatus_NodePhase_value)
	proto.RegisterEnum("cluster.PortCondition_ConditionType", PortCondition_ConditionType_name, PortCondition_ConditionType_value)
	proto.RegisterEnum("cluster.SmartNICCondition_ConditionType", SmartNICCondition_ConditionType_name, SmartNICCondition_ConditionType_value)
	proto.RegisterEnum("cluster.SmartNICSpec_SmartNICPhase", SmartNICSpec_SmartNICPhase_name, SmartNICSpec_SmartNICPhase_value)
}
func (m *Cluster) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Cluster) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintCmd(dAtA, i, uint64(m.TypeMeta.Size()))
	n1, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n1
	dAtA[i] = 0x12
	i++
	i = encodeVarintCmd(dAtA, i, uint64(m.ObjectMeta.Size()))
	n2, err := m.ObjectMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n2
	dAtA[i] = 0x1a
	i++
	i = encodeVarintCmd(dAtA, i, uint64(m.Spec.Size()))
	n3, err := m.Spec.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n3
	dAtA[i] = 0x22
	i++
	i = encodeVarintCmd(dAtA, i, uint64(m.Status.Size()))
	n4, err := m.Status.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n4
	return i, nil
}

func (m *ClusterSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClusterSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.QuorumNodes) > 0 {
		for _, s := range m.QuorumNodes {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.VirtualIP) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCmd(dAtA, i, uint64(len(m.VirtualIP)))
		i += copy(dAtA[i:], m.VirtualIP)
	}
	if len(m.NTPServers) > 0 {
		for _, s := range m.NTPServers {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.DNSSubDomain) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCmd(dAtA, i, uint64(len(m.DNSSubDomain)))
		i += copy(dAtA[i:], m.DNSSubDomain)
	}
	if m.AutoAdmitNICs {
		dAtA[i] = 0x28
		i++
		if m.AutoAdmitNICs {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *ClusterStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClusterStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Leader) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCmd(dAtA, i, uint64(len(m.Leader)))
		i += copy(dAtA[i:], m.Leader)
	}
	if m.LastLeaderTransitionTime != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCmd(dAtA, i, uint64(m.LastLeaderTransitionTime.Size()))
		n5, err := m.LastLeaderTransitionTime.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	return i, nil
}

func (m *Node) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Node) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintCmd(dAtA, i, uint64(m.TypeMeta.Size()))
	n6, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n6
	dAtA[i] = 0x12
	i++
	i = encodeVarintCmd(dAtA, i, uint64(m.ObjectMeta.Size()))
	n7, err := m.ObjectMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n7
	dAtA[i] = 0x1a
	i++
	i = encodeVarintCmd(dAtA, i, uint64(m.Spec.Size()))
	n8, err := m.Spec.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n8
	dAtA[i] = 0x22
	i++
	i = encodeVarintCmd(dAtA, i, uint64(m.Status.Size()))
	n9, err := m.Status.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n9
	return i, nil
}

func (m *NodeCondition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeCondition) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCmd(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.Status) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCmd(dAtA, i, uint64(len(m.Status)))
		i += copy(dAtA[i:], m.Status)
	}
	if len(m.LastTransitionTime) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCmd(dAtA, i, uint64(len(m.LastTransitionTime)))
		i += copy(dAtA[i:], m.LastTransitionTime)
	}
	if len(m.Reason) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCmd(dAtA, i, uint64(len(m.Reason)))
		i += copy(dAtA[i:], m.Reason)
	}
	if len(m.Message) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintCmd(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	return i, nil
}

func (m *NodeSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Roles) > 0 {
		for _, s := range m.Roles {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *NodeStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Phase) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCmd(dAtA, i, uint64(len(m.Phase)))
		i += copy(dAtA[i:], m.Phase)
	}
	if len(m.Conditions) > 0 {
		for _, msg := range m.Conditions {
			dAtA[i] = 0x12
			i++
			i = encodeVarintCmd(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Nics) > 0 {
		for _, s := range m.Nics {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *PortCondition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PortCondition) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCmd(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.Status) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCmd(dAtA, i, uint64(len(m.Status)))
		i += copy(dAtA[i:], m.Status)
	}
	if len(m.LastTransitionTime) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCmd(dAtA, i, uint64(len(m.LastTransitionTime)))
		i += copy(dAtA[i:], m.LastTransitionTime)
	}
	if len(m.Reason) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCmd(dAtA, i, uint64(len(m.Reason)))
		i += copy(dAtA[i:], m.Reason)
	}
	if len(m.Message) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintCmd(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	return i, nil
}

func (m *PortSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PortSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.MacAddress) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCmd(dAtA, i, uint64(len(m.MacAddress)))
		i += copy(dAtA[i:], m.MacAddress)
	}
	return i, nil
}

func (m *PortStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PortStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.MacAddress) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCmd(dAtA, i, uint64(len(m.MacAddress)))
		i += copy(dAtA[i:], m.MacAddress)
	}
	if len(m.LinkSpeed) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCmd(dAtA, i, uint64(len(m.LinkSpeed)))
		i += copy(dAtA[i:], m.LinkSpeed)
	}
	if len(m.Conditions) > 0 {
		for _, msg := range m.Conditions {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintCmd(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SmartNIC) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SmartNIC) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintCmd(dAtA, i, uint64(m.TypeMeta.Size()))
	n10, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n10
	dAtA[i] = 0x12
	i++
	i = encodeVarintCmd(dAtA, i, uint64(m.ObjectMeta.Size()))
	n11, err := m.ObjectMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n11
	dAtA[i] = 0x1a
	i++
	i = encodeVarintCmd(dAtA, i, uint64(m.Spec.Size()))
	n12, err := m.Spec.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n12
	dAtA[i] = 0x22
	i++
	i = encodeVarintCmd(dAtA, i, uint64(m.Status.Size()))
	n13, err := m.Status.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n13
	return i, nil
}

func (m *SmartNICCondition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SmartNICCondition) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCmd(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.Status) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCmd(dAtA, i, uint64(len(m.Status)))
		i += copy(dAtA[i:], m.Status)
	}
	if len(m.LastTransitionTime) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCmd(dAtA, i, uint64(len(m.LastTransitionTime)))
		i += copy(dAtA[i:], m.LastTransitionTime)
	}
	if len(m.Reason) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCmd(dAtA, i, uint64(len(m.Reason)))
		i += copy(dAtA[i:], m.Reason)
	}
	if len(m.Message) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintCmd(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	return i, nil
}

func (m *SmartNICSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SmartNICSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Phase) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCmd(dAtA, i, uint64(len(m.Phase)))
		i += copy(dAtA[i:], m.Phase)
	}
	if len(m.MgmtIp) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCmd(dAtA, i, uint64(len(m.MgmtIp)))
		i += copy(dAtA[i:], m.MgmtIp)
	}
	if len(m.NodeName) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCmd(dAtA, i, uint64(len(m.NodeName)))
		i += copy(dAtA[i:], m.NodeName)
	}
	if len(m.Ports) > 0 {
		for _, msg := range m.Ports {
			dAtA[i] = 0x22
			i++
			i = encodeVarintCmd(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SmartNICStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SmartNICStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Conditions) > 0 {
		for _, msg := range m.Conditions {
			dAtA[i] = 0xa
			i++
			i = encodeVarintCmd(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.SerialNum) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCmd(dAtA, i, uint64(len(m.SerialNum)))
		i += copy(dAtA[i:], m.SerialNum)
	}
	if len(m.PrimaryMacAddress) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCmd(dAtA, i, uint64(len(m.PrimaryMacAddress)))
		i += copy(dAtA[i:], m.PrimaryMacAddress)
	}
	if len(m.Ports) > 0 {
		for _, msg := range m.Ports {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintCmd(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func encodeVarintCmd(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Cluster) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovCmd(uint64(l))
	l = m.ObjectMeta.Size()
	n += 1 + l + sovCmd(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovCmd(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovCmd(uint64(l))
	return n
}

func (m *ClusterSpec) Size() (n int) {
	var l int
	_ = l
	if len(m.QuorumNodes) > 0 {
		for _, s := range m.QuorumNodes {
			l = len(s)
			n += 1 + l + sovCmd(uint64(l))
		}
	}
	l = len(m.VirtualIP)
	if l > 0 {
		n += 1 + l + sovCmd(uint64(l))
	}
	if len(m.NTPServers) > 0 {
		for _, s := range m.NTPServers {
			l = len(s)
			n += 1 + l + sovCmd(uint64(l))
		}
	}
	l = len(m.DNSSubDomain)
	if l > 0 {
		n += 1 + l + sovCmd(uint64(l))
	}
	if m.AutoAdmitNICs {
		n += 2
	}
	return n
}

func (m *ClusterStatus) Size() (n int) {
	var l int
	_ = l
	l = len(m.Leader)
	if l > 0 {
		n += 1 + l + sovCmd(uint64(l))
	}
	if m.LastLeaderTransitionTime != nil {
		l = m.LastLeaderTransitionTime.Size()
		n += 1 + l + sovCmd(uint64(l))
	}
	return n
}

func (m *Node) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovCmd(uint64(l))
	l = m.ObjectMeta.Size()
	n += 1 + l + sovCmd(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovCmd(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovCmd(uint64(l))
	return n
}

func (m *NodeCondition) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovCmd(uint64(l))
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovCmd(uint64(l))
	}
	l = len(m.LastTransitionTime)
	if l > 0 {
		n += 1 + l + sovCmd(uint64(l))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovCmd(uint64(l))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovCmd(uint64(l))
	}
	return n
}

func (m *NodeSpec) Size() (n int) {
	var l int
	_ = l
	if len(m.Roles) > 0 {
		for _, s := range m.Roles {
			l = len(s)
			n += 1 + l + sovCmd(uint64(l))
		}
	}
	return n
}

func (m *NodeStatus) Size() (n int) {
	var l int
	_ = l
	l = len(m.Phase)
	if l > 0 {
		n += 1 + l + sovCmd(uint64(l))
	}
	if len(m.Conditions) > 0 {
		for _, e := range m.Conditions {
			l = e.Size()
			n += 1 + l + sovCmd(uint64(l))
		}
	}
	if len(m.Nics) > 0 {
		for _, s := range m.Nics {
			l = len(s)
			n += 1 + l + sovCmd(uint64(l))
		}
	}
	return n
}

func (m *PortCondition) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovCmd(uint64(l))
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovCmd(uint64(l))
	}
	l = len(m.LastTransitionTime)
	if l > 0 {
		n += 1 + l + sovCmd(uint64(l))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovCmd(uint64(l))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovCmd(uint64(l))
	}
	return n
}

func (m *PortSpec) Size() (n int) {
	var l int
	_ = l
	l = len(m.MacAddress)
	if l > 0 {
		n += 1 + l + sovCmd(uint64(l))
	}
	return n
}

func (m *PortStatus) Size() (n int) {
	var l int
	_ = l
	l = len(m.MacAddress)
	if l > 0 {
		n += 1 + l + sovCmd(uint64(l))
	}
	l = len(m.LinkSpeed)
	if l > 0 {
		n += 1 + l + sovCmd(uint64(l))
	}
	if len(m.Conditions) > 0 {
		for _, e := range m.Conditions {
			l = e.Size()
			n += 1 + l + sovCmd(uint64(l))
		}
	}
	return n
}

func (m *SmartNIC) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovCmd(uint64(l))
	l = m.ObjectMeta.Size()
	n += 1 + l + sovCmd(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovCmd(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovCmd(uint64(l))
	return n
}

func (m *SmartNICCondition) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovCmd(uint64(l))
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovCmd(uint64(l))
	}
	l = len(m.LastTransitionTime)
	if l > 0 {
		n += 1 + l + sovCmd(uint64(l))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovCmd(uint64(l))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovCmd(uint64(l))
	}
	return n
}

func (m *SmartNICSpec) Size() (n int) {
	var l int
	_ = l
	l = len(m.Phase)
	if l > 0 {
		n += 1 + l + sovCmd(uint64(l))
	}
	l = len(m.MgmtIp)
	if l > 0 {
		n += 1 + l + sovCmd(uint64(l))
	}
	l = len(m.NodeName)
	if l > 0 {
		n += 1 + l + sovCmd(uint64(l))
	}
	if len(m.Ports) > 0 {
		for _, e := range m.Ports {
			l = e.Size()
			n += 1 + l + sovCmd(uint64(l))
		}
	}
	return n
}

func (m *SmartNICStatus) Size() (n int) {
	var l int
	_ = l
	if len(m.Conditions) > 0 {
		for _, e := range m.Conditions {
			l = e.Size()
			n += 1 + l + sovCmd(uint64(l))
		}
	}
	l = len(m.SerialNum)
	if l > 0 {
		n += 1 + l + sovCmd(uint64(l))
	}
	l = len(m.PrimaryMacAddress)
	if l > 0 {
		n += 1 + l + sovCmd(uint64(l))
	}
	if len(m.Ports) > 0 {
		for _, e := range m.Ports {
			l = e.Size()
			n += 1 + l + sovCmd(uint64(l))
		}
	}
	return n
}

func sovCmd(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozCmd(x uint64) (n int) {
	return sovCmd(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Cluster) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Cluster: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Cluster: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmd(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClusterSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClusterSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClusterSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QuorumNodes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QuorumNodes = append(m.QuorumNodes, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VirtualIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VirtualIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NTPServers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NTPServers = append(m.NTPServers, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DNSSubDomain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DNSSubDomain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoAdmitNICs", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AutoAdmitNICs = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCmd(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClusterStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClusterStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClusterStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Leader", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Leader = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastLeaderTransitionTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastLeaderTransitionTime == nil {
				m.LastLeaderTransitionTime = &api.Timestamp{}
			}
			if err := m.LastLeaderTransitionTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmd(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Node) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Node: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Node: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmd(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeCondition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeCondition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeCondition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastTransitionTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastTransitionTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmd(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Roles", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Roles = append(m.Roles, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmd(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phase", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Phase = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conditions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Conditions = append(m.Conditions, &NodeCondition{})
			if err := m.Conditions[len(m.Conditions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nics", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nics = append(m.Nics, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmd(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PortCondition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PortCondition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PortCondition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastTransitionTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastTransitionTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmd(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PortSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PortSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PortSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MacAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MacAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmd(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PortStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PortStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PortStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MacAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MacAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LinkSpeed", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LinkSpeed = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conditions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Conditions = append(m.Conditions, &PortCondition{})
			if err := m.Conditions[len(m.Conditions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmd(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SmartNIC) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SmartNIC: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SmartNIC: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmd(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SmartNICCondition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SmartNICCondition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SmartNICCondition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastTransitionTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastTransitionTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmd(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SmartNICSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SmartNICSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SmartNICSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phase", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Phase = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MgmtIp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MgmtIp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ports", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ports = append(m.Ports, PortSpec{})
			if err := m.Ports[len(m.Ports)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmd(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SmartNICStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SmartNICStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SmartNICStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conditions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Conditions = append(m.Conditions, &SmartNICCondition{})
			if err := m.Conditions[len(m.Conditions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SerialNum", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SerialNum = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrimaryMacAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrimaryMacAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ports", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ports = append(m.Ports, &PortStatus{})
			if err := m.Ports[len(m.Ports)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmd(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCmd(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCmd
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthCmd
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowCmd
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipCmd(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthCmd = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCmd   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("cmd.proto", fileDescriptorCmd) }

var fileDescriptorCmd = []byte{
	// 1467 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x57, 0x4d, 0x6f, 0xdb, 0xc6,
	0x16, 0x35, 0x25, 0x7f, 0xe9, 0xca, 0xb2, 0xe5, 0xb1, 0x63, 0x4b, 0x4e, 0x6c, 0x05, 0x7c, 0x2f,
	0xef, 0x39, 0x41, 0x68, 0x05, 0x2f, 0x79, 0x6d, 0x13, 0x34, 0x4d, 0x44, 0x8b, 0x89, 0x95, 0xc8,
	0x94, 0x42, 0xd1, 0x4e, 0xbb, 0x2a, 0x68, 0x69, 0xaa, 0xb0, 0x11, 0x3f, 0x4a, 0x0e, 0x53, 0xf8,
	0x07, 0xc4, 0xbb, 0x14, 0xe8, 0xa6, 0xbb, 0xae, 0x0b, 0xf8, 0x17, 0x74, 0xd7, 0x4d, 0x17, 0x59,
	0x06, 0xd9, 0x57, 0x28, 0xb2, 0xf4, 0x2f, 0xe8, 0xb2, 0x98, 0xe1, 0x87, 0x87, 0xb2, 0x0d, 0x18,
	0x29, 0x90, 0x55, 0x76, 0x9a, 0x99, 0x73, 0x0e, 0x2f, 0xe7, 0xde, 0x73, 0x2f, 0x05, 0xb9, 0xae,
	0xd5, 0xdb, 0x70, 0x3d, 0x87, 0x38, 0x68, 0xaa, 0x3b, 0x08, 0x7c, 0x82, 0xbd, 0x95, 0x4b, 0x7d,
	0xc7, 0xe9, 0x0f, 0x70, 0xd5, 0x70, 0xcd, 0xaa, 0x61, 0xdb, 0x0e, 0x31, 0x88, 0xe9, 0xd8, 0x7e,
	0x08, 0x5b, 0x51, 0xfa, 0x26, 0x79, 0x16, 0xec, 0x6d, 0x74, 0x1d, 0xab, 0xea, 0x62, 0xdb, 0x37,
	0xec, 0x9e, 0x53, 0xf5, 0xbf, 0xaf, 0xbe, 0xc0, 0xb6, 0xd9, 0xc5, 0xd5, 0x80, 0x98, 0x03, 0x9f,
	0x52, 0xfb, 0xd8, 0xe6, 0xd9, 0x55, 0xd3, 0xee, 0x0e, 0x82, 0x1e, 0x8e, 0x65, 0x24, 0x4e, 0xa6,
	0xef, 0xf4, 0x9d, 0x2a, 0xdb, 0xde, 0x0b, 0xbe, 0x61, 0x2b, 0xb6, 0x60, 0xbf, 0x22, 0xf8, 0x95,
	0x33, 0x9e, 0x4a, 0x63, 0xb4, 0x30, 0x31, 0x42, 0x98, 0xf8, 0x63, 0x06, 0xa6, 0x36, 0xc3, 0xd7,
	0x40, 0x37, 0x40, 0xd0, 0x4b, 0xc2, 0x65, 0x61, 0x3d, 0xff, 0xbf, 0xc2, 0x86, 0xe1, 0x9a, 0x1b,
	0xfa, 0xbe, 0x8b, 0xb7, 0x31, 0x31, 0xe4, 0x85, 0xd7, 0xc3, 0xca, 0xd8, 0x9b, 0x61, 0x45, 0x38,
	0x1a, 0x56, 0xa6, 0xae, 0x9b, 0xf6, 0xc0, 0xb4, 0xb1, 0x26, 0xe8, 0xe8, 0x36, 0x08, 0xad, 0x52,
	0x86, 0x31, 0xe6, 0x18, 0xa3, 0xb5, 0xf7, 0x2d, 0xee, 0x12, 0xc6, 0x59, 0xe1, 0x38, 0xb3, 0xf4,
	0x89, 0xd7, 0x1d, 0xcb, 0x24, 0xd8, 0x72, 0xc9, 0xbe, 0x26, 0xb4, 0xd0, 0x7d, 0x18, 0xef, 0xb8,
	0xb8, 0x5b, 0xca, 0x32, 0xf6, 0xe2, 0x46, 0x74, 0x97, 0x1b, 0x51, 0x30, 0xf4, 0x4c, 0x5e, 0xa2,
	0x12, 0x94, 0xee, 0xbb, 0xb8, 0xcb, 0xd1, 0x19, 0x13, 0x6d, 0xc1, 0x64, 0x87, 0x18, 0x24, 0xf0,
	0x4b, 0xe3, 0x4c, 0x63, 0xe9, 0x84, 0x06, 0x3b, 0x95, 0x4b, 0x91, 0x4a, 0xd1, 0x67, 0x6b, 0x4e,
	0x27, 0xe2, 0xdf, 0x29, 0xbc, 0x7d, 0x59, 0xce, 0x25, 0xe9, 0x14, 0x7f, 0xcf, 0x40, 0x9e, 0x0b,
	0x03, 0x7d, 0x0e, 0xf9, 0x27, 0x81, 0xe3, 0x05, 0x96, 0xea, 0xf4, 0xb0, 0x5f, 0x12, 0x2e, 0x67,
	0xd7, 0x73, 0xf2, 0xca, 0xd1, 0xb0, 0xb2, 0xf4, 0x1d, 0xdb, 0x96, 0x6c, 0xba, 0xcf, 0xe9, 0xf2,
	0x70, 0xf4, 0x09, 0xe4, 0x76, 0x4d, 0x8f, 0x04, 0xc6, 0xa0, 0xd1, 0x66, 0x77, 0x95, 0x93, 0x4b,
	0x47, 0xc3, 0xca, 0xe2, 0x8b, 0x70, 0x53, 0x32, 0x5d, 0x8e, 0x79, 0x0c, 0x45, 0xb7, 0x01, 0x54,
	0xbd, 0xdd, 0xc1, 0xde, 0x0b, 0xec, 0xf9, 0xa5, 0x2c, 0x7b, 0x68, 0xf9, 0x68, 0x58, 0xb9, 0x60,
	0x13, 0x57, 0xf2, 0xc3, 0x6d, 0x8e, 0xc9, 0x81, 0xd1, 0x3d, 0x98, 0xa9, 0xab, 0x9d, 0x4e, 0xb0,
	0x57, 0x77, 0x2c, 0xc3, 0xb4, 0xd9, 0xfd, 0xe4, 0xe4, 0x8b, 0x47, 0xc3, 0xca, 0x72, 0xcf, 0xf6,
	0x25, 0x3f, 0xd8, 0xeb, 0xb1, 0x03, 0x8e, 0x9e, 0x22, 0xa0, 0x4d, 0x28, 0xd4, 0x02, 0xe2, 0xd4,
	0x7a, 0x96, 0x49, 0xd4, 0xc6, 0xa6, 0x5f, 0x9a, 0xb8, 0x2c, 0xac, 0x4f, 0xcb, 0xab, 0x47, 0xc3,
	0x4a, 0xd9, 0x08, 0x88, 0x23, 0x19, 0xf4, 0x44, 0xb2, 0xcd, 0x2e, 0x1f, 0x42, 0x9a, 0x23, 0xfe,
	0x2a, 0x40, 0x21, 0x95, 0x09, 0x74, 0x1d, 0x26, 0x9b, 0xd8, 0xe8, 0x61, 0x8f, 0x55, 0x59, 0x4e,
	0x5e, 0xa4, 0x59, 0x19, 0xb0, 0x1d, 0x3e, 0x2b, 0x21, 0x06, 0xed, 0x43, 0xa9, 0x69, 0xf8, 0x24,
	0x5c, 0xe9, 0x9e, 0x61, 0xfb, 0x26, 0x35, 0x86, 0x6e, 0x5a, 0x38, 0xaa, 0xb9, 0xd9, 0xb0, 0x4a,
	0x4d, 0x0b, 0xfb, 0xc4, 0xb0, 0x5c, 0x59, 0x7a, 0x1d, 0x96, 0xdb, 0x95, 0x81, 0xe1, 0x13, 0x29,
	0x14, 0x96, 0x48, 0xc2, 0x94, 0x88, 0x69, 0x61, 0xee, 0x41, 0x67, 0xca, 0x8b, 0x07, 0x19, 0x18,
	0xa7, 0xd9, 0xfb, 0xb0, 0x96, 0xb8, 0x9b, 0xb2, 0xc4, 0x7c, 0x52, 0xce, 0x34, 0x92, 0x73, 0xf8,
	0x41, 0x19, 0xf1, 0xc3, 0x42, 0x5a, 0xe0, 0xbc, 0x66, 0xc8, 0xbf, 0x7d, 0x59, 0x9e, 0x42, 0x13,
	0xac, 0xa6, 0xc5, 0x57, 0x59, 0x28, 0x50, 0xf6, 0xa6, 0x63, 0xf7, 0xd8, 0xf5, 0x20, 0x0d, 0xc6,
	0xe9, 0x1d, 0x44, 0x19, 0xfc, 0xe2, 0xf0, 0xa0, 0xfc, 0xef, 0x0e, 0xf1, 0x14, 0x3b, 0xb0, 0xd6,
	0x53, 0xc0, 0x8d, 0xe4, 0x17, 0x85, 0x5f, 0x8d, 0x32, 0x33, 0x4b, 0xf6, 0x5d, 0x3e, 0x05, 0x4c,
	0x0b, 0x35, 0x93, 0xc8, 0x43, 0x7f, 0xdc, 0x3a, 0x3c, 0x28, 0x97, 0x62, 0xd5, 0x44, 0x27, 0x84,
	0xc4, 0x4a, 0x67, 0xbe, 0x00, 0xda, 0x05, 0x44, 0x13, 0x3b, 0x52, 0x31, 0x59, 0xa6, 0xfc, 0x9f,
	0x88, 0xbd, 0xc6, 0x2a, 0xe4, 0xec, 0xd2, 0x38, 0x45, 0x01, 0xdd, 0x80, 0x49, 0x0d, 0x1b, 0xbe,
	0x13, 0xfb, 0xa9, 0x14, 0x47, 0xe2, 0xb1, 0x5d, 0x3e, 0x92, 0x10, 0x87, 0x6e, 0xc2, 0xd4, 0x36,
	0xf6, 0x7d, 0xa3, 0x8f, 0x99, 0x81, 0x72, 0x72, 0x39, 0xa2, 0xcc, 0x5b, 0xe1, 0x36, 0xc7, 0x89,
	0x91, 0xe2, 0x45, 0x28, 0xa4, 0xae, 0x0e, 0x01, 0x4c, 0x36, 0x95, 0x5a, 0x5d, 0xd1, 0x8a, 0x63,
	0xe2, 0x2b, 0x01, 0xa6, 0xe3, 0x72, 0x40, 0x8f, 0x61, 0x42, 0x73, 0x06, 0x49, 0x47, 0xfa, 0xff,
	0xe1, 0x41, 0x79, 0x85, 0xcf, 0x05, 0x05, 0xb1, 0xdc, 0x53, 0x54, 0x7c, 0x6f, 0x73, 0x1e, 0xa5,
	0x70, 0x0f, 0x0e, 0x35, 0xc4, 0x5b, 0xa1, 0x30, 0x5d, 0xa0, 0x59, 0x80, 0xcd, 0x96, 0xaa, 0x6b,
	0xad, 0x66, 0x93, 0x3e, 0x15, 0xcd, 0xc0, 0xf4, 0xd3, 0x96, 0xf6, 0xb8, 0xd9, 0xaa, 0xd5, 0x8b,
	0x02, 0x8d, 0xe7, 0xc9, 0x4e, 0x4b, 0xdb, 0xd9, 0x2e, 0x66, 0xc4, 0x9f, 0x33, 0x00, 0xc7, 0xd5,
	0x85, 0x54, 0x98, 0x68, 0x3f, 0x33, 0xfc, 0xb8, 0x3a, 0x3e, 0x3b, 0x3c, 0x28, 0xaf, 0xa6, 0x22,
	0x62, 0x30, 0x16, 0x13, 0xc3, 0x25, 0x41, 0xb9, 0x74, 0xc5, 0x07, 0xc5, 0x8e, 0x91, 0x0e, 0x90,
	0xdc, 0x05, 0x2d, 0x8e, 0x6c, 0xaa, 0xcd, 0xa7, 0xea, 0x4d, 0xbe, 0x14, 0x69, 0x2d, 0x76, 0x13,
	0x06, 0xdf, 0x1e, 0x8f, 0x75, 0xd0, 0x35, 0x18, 0x57, 0xcd, 0x6e, 0xdc, 0x53, 0x97, 0xe2, 0xd2,
	0x1c, 0xe9, 0x66, 0x0c, 0x23, 0xde, 0x85, 0x5c, 0x12, 0x2d, 0xca, 0xc3, 0xd4, 0x8e, 0xfa, 0x58,
	0x6d, 0x3d, 0x55, 0x8b, 0x63, 0x74, 0xd1, 0x56, 0xd4, 0x7a, 0x43, 0x7d, 0x18, 0xde, 0xc9, 0xa3,
	0x56, 0x43, 0x55, 0xea, 0xc5, 0x0c, 0xfd, 0xfd, 0xa0, 0xd6, 0x68, 0x2a, 0xf5, 0x62, 0x56, 0xfc,
	0x21, 0x0b, 0x85, 0xb6, 0xe3, 0x91, 0x73, 0xf9, 0x27, 0x05, 0xfc, 0xe8, 0x9f, 0xf7, 0xf4, 0xcf,
	0xa5, 0x51, 0xff, 0xd0, 0x44, 0xb5, 0x34, 0xfd, 0xeb, 0x9d, 0x76, 0x71, 0x4c, 0x6c, 0xc0, 0x34,
	0xbd, 0x66, 0xe6, 0x9f, 0xbb, 0x00, 0xdb, 0x46, 0xb7, 0xd6, 0xeb, 0x79, 0xd8, 0xf7, 0xa3, 0x84,
	0xac, 0x46, 0x4f, 0xb8, 0x60, 0x19, 0x5d, 0xc9, 0x08, 0x8f, 0xf8, 0x32, 0x3a, 0x26, 0x88, 0x7f,
	0x08, 0x00, 0x4c, 0x2b, 0xbc, 0xb6, 0x7f, 0xa6, 0x86, 0xee, 0x40, 0xae, 0x69, 0xda, 0xcf, 0x3b,
	0x2e, 0xc6, 0xbd, 0x28, 0x8d, 0x49, 0x45, 0x0f, 0x4c, 0xfb, 0xb9, 0xe4, 0xd3, 0x13, 0xfe, 0x53,
	0x21, 0x81, 0x8f, 0xd8, 0x24, 0x3b, 0x62, 0x93, 0x54, 0x59, 0x9d, 0xdf, 0x26, 0xe2, 0x4f, 0x19,
	0x98, 0xee, 0x58, 0x86, 0x47, 0xa7, 0xf9, 0x87, 0x1d, 0x84, 0xb5, 0xd4, 0x20, 0xbc, 0x90, 0xbc,
	0x49, 0x1c, 0xcd, 0x39, 0x86, 0x61, 0x63, 0x64, 0x18, 0x2e, 0x9f, 0x14, 0x39, 0xef, 0x40, 0x9c,
	0x7b, 0xfb, 0xb2, 0x9c, 0x47, 0x39, 0x9f, 0xf2, 0x68, 0x8f, 0x10, 0x7f, 0xc9, 0xc2, 0x7c, 0xac,
	0x72, 0x6c, 0xec, 0xdd, 0x94, 0xb1, 0xe5, 0xc3, 0x83, 0xf2, 0x7a, 0x6c, 0xc1, 0x13, 0xe0, 0x8f,
	0xe6, 0x7e, 0x4f, 0x73, 0x4b, 0xa7, 0x98, 0x7b, 0x4b, 0xa9, 0x35, 0xf5, 0xad, 0xaf, 0x8a, 0x63,
	0x68, 0x0e, 0xf2, 0x3b, 0xaa, 0xa6, 0xd4, 0x36, 0xb7, 0x6a, 0x72, 0x53, 0x29, 0x0a, 0xe2, 0x5f,
	0x19, 0x98, 0xe1, 0x8b, 0x06, 0xe9, 0xe9, 0x01, 0x45, 0xdb, 0xef, 0xbf, 0x46, 0xb3, 0xc4, 0xc6,
	0x66, 0xbc, 0x38, 0xd7, 0x98, 0xba, 0x07, 0x93, 0xdb, 0x7d, 0x8b, 0x34, 0xdc, 0x28, 0x45, 0xff,
	0x3d, 0x3c, 0x28, 0xc3, 0x96, 0xe3, 0x13, 0x6a, 0xee, 0xf5, 0xab, 0xc9, 0x7b, 0xf5, 0x2d, 0x92,
	0xfe, 0xdc, 0x8f, 0x68, 0xe8, 0xd3, 0x70, 0xf8, 0xaa, 0x46, 0x92, 0x8b, 0x8b, 0x11, 0x69, 0x81,
	0x7e, 0x87, 0x49, 0xb6, 0x91, 0x4a, 0x40, 0x02, 0x46, 0xf7, 0x61, 0x82, 0xda, 0x9b, 0x56, 0x79,
	0x36, 0xf5, 0xcd, 0x18, 0x37, 0x39, 0x79, 0x39, 0xaa, 0xef, 0x39, 0x97, 0xe2, 0x52, 0xb1, 0xd3,
	0x0d, 0x71, 0x17, 0x0a, 0xa9, 0x77, 0x4d, 0x0f, 0xb9, 0x39, 0xc8, 0x6b, 0xca, 0xc3, 0x46, 0x47,
	0x57, 0xb4, 0x70, 0xd0, 0xcd, 0xc0, 0xb4, 0xa6, 0x3c, 0x52, 0x36, 0x75, 0x36, 0xea, 0xb8, 0x19,
	0x98, 0xa5, 0x47, 0xb5, 0xfa, 0x76, 0x43, 0xa7, 0x47, 0xe3, 0xe2, 0x6f, 0x19, 0x98, 0x4d, 0x5b,
	0x0d, 0x7d, 0x99, 0x6a, 0x53, 0x02, 0x8b, 0x78, 0xe5, 0x84, 0x2f, 0xdf, 0x67, 0xa2, 0xdf, 0x81,
	0x5c, 0x07, 0x7b, 0xa6, 0x31, 0x50, 0x03, 0x6b, 0xb4, 0x79, 0xfa, 0xec, 0x40, 0xb2, 0x03, 0x8b,
	0x6f, 0x9e, 0x09, 0x1c, 0x75, 0x60, 0xbe, 0xed, 0x99, 0x96, 0xe1, 0xed, 0x73, 0xed, 0x3b, 0x4c,
	0xc2, 0x95, 0x48, 0x63, 0xd5, 0x0d, 0x01, 0xd2, 0xe9, 0x6d, 0xfc, 0x24, 0x1f, 0xc9, 0x71, 0x5e,
	0x26, 0xd8, 0x5b, 0x2e, 0xa4, 0xf3, 0x12, 0x76, 0x9e, 0xe5, 0xa4, 0xaa, 0x4e, 0xcd, 0xcc, 0xb5,
	0x9b, 0x30, 0x37, 0x62, 0xef, 0x74, 0x6e, 0xa6, 0x61, 0x5c, 0xd7, 0x76, 0x94, 0xa2, 0x80, 0x72,
	0x30, 0xf1, 0xa0, 0xd6, 0xec, 0x28, 0xc5, 0x8c, 0x3c, 0xf3, 0xfa, 0xdd, 0x9a, 0xf0, 0xe6, 0xdd,
	0x9a, 0xf0, 0xe7, 0xbb, 0x35, 0xa1, 0x2d, 0xec, 0x4d, 0xb2, 0xbf, 0xf9, 0x37, 0xff, 0x0e, 0x00,
	0x00, 0xff, 0xff, 0x86, 0xfc, 0x80, 0x32, 0xb7, 0x10, 0x00, 0x00,
}
