// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: cmd.proto

/*
	Package cluster is a generated protocol buffer package.

	Service name

	It is generated from these files:
		cmd.proto
		svc_cluster.proto
		tenant.proto

	It has these top-level messages:
		Cluster
		ClusterAuthBootstrapRequest
		ClusterSpec
		ClusterStatus
		Host
		HostIntfSpec
		HostIntfStatus
		HostSpec
		HostStatus
		Node
		NodeCondition
		NodeSpec
		NodeStatus
		PortCondition
		PortSpec
		PortStatus
		SmartNIC
		SmartNICCondition
		SmartNICSpec
		SmartNICStatus
		AutoMsgClusterWatchHelper
		AutoMsgHostWatchHelper
		AutoMsgNodeWatchHelper
		AutoMsgSmartNICWatchHelper
		AutoMsgTenantWatchHelper
		ClusterList
		HostList
		NodeList
		SmartNICList
		TenantList
		Tenant
		TenantSpec
		TenantStatus
*/
package cluster

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/pensando/grpc-gateway/third_party/googleapis/google/api"
import _ "github.com/pensando/sw/venice/utils/apigen/annotations"
import _ "github.com/gogo/protobuf/gogoproto"
import api "github.com/pensando/sw/api"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// These are valid condition statuses.
type ConditionStatus int32

const (
	// ui-hint: Unknown
	ConditionStatus_UNKNOWN ConditionStatus = 0
	// ui-hint: True
	ConditionStatus_TRUE ConditionStatus = 1
	// ui-hint: False
	ConditionStatus_FALSE ConditionStatus = 2
)

var ConditionStatus_name = map[int32]string{
	0: "UNKNOWN",
	1: "TRUE",
	2: "FALSE",
}
var ConditionStatus_value = map[string]int32{
	"UNKNOWN": 0,
	"TRUE":    1,
	"FALSE":   2,
}

func (x ConditionStatus) String() string {
	return proto.EnumName(ConditionStatus_name, int32(x))
}
func (ConditionStatus) EnumDescriptor() ([]byte, []int) { return fileDescriptorCmd, []int{0} }

// Type of Host
type HostStatus_HostType int32

const (
	//
	HostStatus_UNKNOWN HostStatus_HostType = 0
	//
	HostStatus_BAREMETAL HostStatus_HostType = 1
	//
	HostStatus_HYPERVISOR HostStatus_HostType = 2
)

var HostStatus_HostType_name = map[int32]string{
	0: "UNKNOWN",
	1: "BAREMETAL",
	2: "HYPERVISOR",
}
var HostStatus_HostType_value = map[string]int32{
	"UNKNOWN":    0,
	"BAREMETAL":  1,
	"HYPERVISOR": 2,
}

func (x HostStatus_HostType) String() string {
	return proto.EnumName(HostStatus_HostType_name, int32(x))
}
func (HostStatus_HostType) EnumDescriptor() ([]byte, []int) { return fileDescriptorCmd, []int{8, 0} }

// These are valid conditions of a Node
type NodeCondition_ConditionType int32

const (
	// ui-hint: Leader
	NodeCondition_LEADER NodeCondition_ConditionType = 0
)

var NodeCondition_ConditionType_name = map[int32]string{
	0: "LEADER",
}
var NodeCondition_ConditionType_value = map[string]int32{
	"LEADER": 0,
}

func (x NodeCondition_ConditionType) String() string {
	return proto.EnumName(NodeCondition_ConditionType_name, int32(x))
}
func (NodeCondition_ConditionType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorCmd, []int{10, 0}
}

// Various phases in lifecycle of a Node
type NodeStatus_NodePhase int32

const (
	// ui-hint: Unknown
	NodeStatus_UNKNOWN NodeStatus_NodePhase = 0
	// ui-hint: Pending
	NodeStatus_PENDING NodeStatus_NodePhase = 1
	// ui-hint: Joined
	NodeStatus_JOINED NodeStatus_NodePhase = 2
	// ui-hint: Failed
	NodeStatus_FAILED NodeStatus_NodePhase = 3
)

var NodeStatus_NodePhase_name = map[int32]string{
	0: "UNKNOWN",
	1: "PENDING",
	2: "JOINED",
	3: "FAILED",
}
var NodeStatus_NodePhase_value = map[string]int32{
	"UNKNOWN": 0,
	"PENDING": 1,
	"JOINED":  2,
	"FAILED":  3,
}

func (x NodeStatus_NodePhase) String() string {
	return proto.EnumName(NodeStatus_NodePhase_name, int32(x))
}
func (NodeStatus_NodePhase) EnumDescriptor() ([]byte, []int) { return fileDescriptorCmd, []int{12, 0} }

// These are valid conditions of a Port
type PortCondition_ConditionType int32

const (
	// ui-hint: Up
	PortCondition_PORT_UP PortCondition_ConditionType = 0
)

var PortCondition_ConditionType_name = map[int32]string{
	0: "PORT_UP",
}
var PortCondition_ConditionType_value = map[string]int32{
	"PORT_UP": 0,
}

func (x PortCondition_ConditionType) String() string {
	return proto.EnumName(PortCondition_ConditionType_name, int32(x))
}
func (PortCondition_ConditionType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorCmd, []int{13, 0}
}

// These are valid conditions of a SmartNIC
type SmartNICCondition_ConditionType int32

const (
	// ui-hint: Healthy
	SmartNICCondition_HEALTHY SmartNICCondition_ConditionType = 0
	// ui-hint: Not Reachable
	SmartNICCondition_UNREACHABLE SmartNICCondition_ConditionType = 1
)

var SmartNICCondition_ConditionType_name = map[int32]string{
	0: "HEALTHY",
	1: "UNREACHABLE",
}
var SmartNICCondition_ConditionType_value = map[string]int32{
	"HEALTHY":     0,
	"UNREACHABLE": 1,
}

func (x SmartNICCondition_ConditionType) String() string {
	return proto.EnumName(SmartNICCondition_ConditionType_name, int32(x))
}
func (SmartNICCondition_ConditionType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorCmd, []int{17, 0}
}

// Various phases in lifecycle of a SmartNIC
type SmartNICSpec_SmartNICPhase int32

const (
	// ui-hint: Unknown
	SmartNICSpec_UNKNOWN SmartNICSpec_SmartNICPhase = 0
	// ui-hint: Registering
	SmartNICSpec_REGISTERING SmartNICSpec_SmartNICPhase = 1
	// ui-hint: Rejected
	SmartNICSpec_REJECTED SmartNICSpec_SmartNICPhase = 2
	// ui-hint: Pending
	SmartNICSpec_PENDING SmartNICSpec_SmartNICPhase = 3
	// ui-hint: Admitted
	SmartNICSpec_ADMITTED SmartNICSpec_SmartNICPhase = 4
)

var SmartNICSpec_SmartNICPhase_name = map[int32]string{
	0: "UNKNOWN",
	1: "REGISTERING",
	2: "REJECTED",
	3: "PENDING",
	4: "ADMITTED",
}
var SmartNICSpec_SmartNICPhase_value = map[string]int32{
	"UNKNOWN":     0,
	"REGISTERING": 1,
	"REJECTED":    2,
	"PENDING":     3,
	"ADMITTED":    4,
}

func (x SmartNICSpec_SmartNICPhase) String() string {
	return proto.EnumName(SmartNICSpec_SmartNICPhase_name, int32(x))
}
func (SmartNICSpec_SmartNICPhase) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorCmd, []int{18, 0}
}

// --------------------------------- CLUSTER ---------------------------------------------
//
// Cluster represents a full cluster venice and workload nodes
//
// Entity responsible & scenarios involved in managing this object:
//
//      Create:
//          o NetOps-admin
//              - initial cluster creation
//      Modify:
//          o NetOps-admin
//              - update spec attributes
//          o CMD
//              - update status attributes
//      Delete:
//          o NetOps-admin
//              - TBD
//
type Cluster struct {
	//
	api.TypeMeta `protobuf:"bytes,1,opt,name=T,json=,inline,embedded=T" json:",inline"`
	//
	api.ObjectMeta `protobuf:"bytes,2,opt,name=O,json=meta,omitempty,embedded=O" json:"meta,omitempty"`
	// Spec contains the configuration of the cluster.
	Spec ClusterSpec `protobuf:"bytes,3,opt,name=Spec,json=spec,omitempty" json:"spec,omitempty"`
	// Status contains the current state of the cluster.
	Status ClusterStatus `protobuf:"bytes,4,opt,name=Status,json=status,omitempty" json:"status,omitempty"`
}

func (m *Cluster) Reset()                    { *m = Cluster{} }
func (m *Cluster) String() string            { return proto.CompactTextString(m) }
func (*Cluster) ProtoMessage()               {}
func (*Cluster) Descriptor() ([]byte, []int) { return fileDescriptorCmd, []int{0} }

func (m *Cluster) GetSpec() ClusterSpec {
	if m != nil {
		return m.Spec
	}
	return ClusterSpec{}
}

func (m *Cluster) GetStatus() ClusterStatus {
	if m != nil {
		return m.Status
	}
	return ClusterStatus{}
}

// ClusterAuthBootstrapRequest is to set auth bootstrap flag in cluster
type ClusterAuthBootstrapRequest struct {
	//
	api.TypeMeta `protobuf:"bytes,1,opt,name=T,json=,inline,embedded=T" json:",inline"`
	//
	api.ObjectMeta `protobuf:"bytes,2,opt,name=O,json=meta,omitempty,embedded=O" json:"meta,omitempty"`
}

func (m *ClusterAuthBootstrapRequest) Reset()                    { *m = ClusterAuthBootstrapRequest{} }
func (m *ClusterAuthBootstrapRequest) String() string            { return proto.CompactTextString(m) }
func (*ClusterAuthBootstrapRequest) ProtoMessage()               {}
func (*ClusterAuthBootstrapRequest) Descriptor() ([]byte, []int) { return fileDescriptorCmd, []int{1} }

// ClusterSpec contains the configuration of the cluster.
type ClusterSpec struct {
	// QuorumNodes contains the list of hostnames for nodes configured to be quorum
	// nodes in the cluster.
	QuorumNodes []string `protobuf:"bytes,1,rep,name=QuorumNodes,json=quorum-nodes,omitempty" json:"quorum-nodes,omitempty"`
	// VirtualIP is the IP address for managing the cluster. It will be hosted by
	// the winner of election between quorum nodes.
	VirtualIP string `protobuf:"bytes,2,opt,name=VirtualIP,json=virtual-ip,omitempty,proto3" json:"virtual-ip,omitempty"`
	// NTPServers contains the list of NTP servers for the cluster.
	NTPServers []string `protobuf:"bytes,3,rep,name=NTPServers,json=ntp-servers,omitempty" json:"ntp-servers,omitempty"`
	// AutoAdmitNICs when enabled auto-admits NICs that are validated
	// into Venice Cluster. When it is disabled, NICs validated by CMD are
	// set to Pending state and it requires Manual approval to be admitted
	// into the cluster.
	AutoAdmitNICs bool `protobuf:"varint,4,opt,name=AutoAdmitNICs,json=auto-admit-nics,omitempty,proto3" json:"auto-admit-nics,omitempty"`
}

func (m *ClusterSpec) Reset()                    { *m = ClusterSpec{} }
func (m *ClusterSpec) String() string            { return proto.CompactTextString(m) }
func (*ClusterSpec) ProtoMessage()               {}
func (*ClusterSpec) Descriptor() ([]byte, []int) { return fileDescriptorCmd, []int{2} }

func (m *ClusterSpec) GetQuorumNodes() []string {
	if m != nil {
		return m.QuorumNodes
	}
	return nil
}

func (m *ClusterSpec) GetVirtualIP() string {
	if m != nil {
		return m.VirtualIP
	}
	return ""
}

func (m *ClusterSpec) GetNTPServers() []string {
	if m != nil {
		return m.NTPServers
	}
	return nil
}

func (m *ClusterSpec) GetAutoAdmitNICs() bool {
	if m != nil {
		return m.AutoAdmitNICs
	}
	return false
}

// ClusterStatus contains the current state of the Cluster.
type ClusterStatus struct {
	// Leader contains the node name of the cluster leader.
	Leader string `protobuf:"bytes,1,opt,name=Leader,json=leader,omitempty,proto3" json:"leader,omitempty"`
	// LastLeaderTransitionTime is when the leadership changed last time
	LastLeaderTransitionTime *api.Timestamp `protobuf:"bytes,2,opt,name=LastLeaderTransitionTime,json=last-leader-transition-time,omitempty" json:"last-leader-transition-time,omitempty"`
	// Human friendly build version
	BuildVersion string `protobuf:"bytes,3,opt,name=BuildVersion,json=build-version,omitempty,proto3" json:"build-version,omitempty"`
	// Representation of ommit in version control system - e.g: hash in git
	VCSCommit string `protobuf:"bytes,4,opt,name=VCSCommit,json=vcs-commit,omitempty,proto3" json:"vcs-commit,omitempty"`
	// Date and Time at which the source code was built
	BuildDate string `protobuf:"bytes,5,opt,name=BuildDate,json=build-date,omitempty,proto3" json:"build-date,omitempty"`
	// AuthBootstrapped when set to true indicates that auth has been bootstrapped in cluster
	AuthBootstrapped bool `protobuf:"varint,6,opt,name=AuthBootstrapped,json=auth-bootstrapped,omitempty,proto3" json:"auth-bootstrapped,omitempty"`
}

func (m *ClusterStatus) Reset()                    { *m = ClusterStatus{} }
func (m *ClusterStatus) String() string            { return proto.CompactTextString(m) }
func (*ClusterStatus) ProtoMessage()               {}
func (*ClusterStatus) Descriptor() ([]byte, []int) { return fileDescriptorCmd, []int{3} }

func (m *ClusterStatus) GetLeader() string {
	if m != nil {
		return m.Leader
	}
	return ""
}

func (m *ClusterStatus) GetLastLeaderTransitionTime() *api.Timestamp {
	if m != nil {
		return m.LastLeaderTransitionTime
	}
	return nil
}

func (m *ClusterStatus) GetBuildVersion() string {
	if m != nil {
		return m.BuildVersion
	}
	return ""
}

func (m *ClusterStatus) GetVCSCommit() string {
	if m != nil {
		return m.VCSCommit
	}
	return ""
}

func (m *ClusterStatus) GetBuildDate() string {
	if m != nil {
		return m.BuildDate
	}
	return ""
}

func (m *ClusterStatus) GetAuthBootstrapped() bool {
	if m != nil {
		return m.AuthBootstrapped
	}
	return false
}

// ---------------------------------- HOST ------------------------------------
//
// Host represents a Baremetal or Hypervisor server.
//
type Host struct {
	//
	api.TypeMeta `protobuf:"bytes,1,opt,name=T,json=,inline,embedded=T" json:",inline"`
	//
	api.ObjectMeta `protobuf:"bytes,2,opt,name=O,json=meta,omitempty,embedded=O" json:"meta,omitempty"`
	// Spec contains the configuration of the host.
	Spec HostSpec `protobuf:"bytes,3,opt,name=Spec,json=spec,omitempty" json:"spec,omitempty"`
	// Status contains the current state of the host.
	Status HostStatus `protobuf:"bytes,4,opt,name=Status,json=status,omitempty" json:"status,omitempty"`
}

func (m *Host) Reset()                    { *m = Host{} }
func (m *Host) String() string            { return proto.CompactTextString(m) }
func (*Host) ProtoMessage()               {}
func (*Host) Descriptor() ([]byte, []int) { return fileDescriptorCmd, []int{4} }

func (m *Host) GetSpec() HostSpec {
	if m != nil {
		return m.Spec
	}
	return HostSpec{}
}

func (m *Host) GetStatus() HostStatus {
	if m != nil {
		return m.Status
	}
	return HostStatus{}
}

// Spec of a Host interface
type HostIntfSpec struct {
	// List of all MAC addresses configured and discovered on a Host Interface
	MacAddrs []string `protobuf:"bytes,1,rep,name=MacAddrs,json=mac-addrs,omitempty" json:"mac-addrs,omitempty"`
}

func (m *HostIntfSpec) Reset()                    { *m = HostIntfSpec{} }
func (m *HostIntfSpec) String() string            { return proto.CompactTextString(m) }
func (*HostIntfSpec) ProtoMessage()               {}
func (*HostIntfSpec) Descriptor() ([]byte, []int) { return fileDescriptorCmd, []int{5} }

func (m *HostIntfSpec) GetMacAddrs() []string {
	if m != nil {
		return m.MacAddrs
	}
	return nil
}

// Status of a Host interface
type HostIntfStatus struct {
	// List of all IP addresses configured on a Host Interface
	IpAddrs []string `protobuf:"bytes,1,rep,name=IpAddrs,json=ip-addrs,omitempty" json:"ip-addrs,omitempty"`
}

func (m *HostIntfStatus) Reset()                    { *m = HostIntfStatus{} }
func (m *HostIntfStatus) String() string            { return proto.CompactTextString(m) }
func (*HostIntfStatus) ProtoMessage()               {}
func (*HostIntfStatus) Descriptor() ([]byte, []int) { return fileDescriptorCmd, []int{6} }

func (m *HostIntfStatus) GetIpAddrs() []string {
	if m != nil {
		return m.IpAddrs
	}
	return nil
}

// HostSpec contains the configuration of the Host.
type HostSpec struct {
	// Spec of all interfaces in the Host identified by Primary MAC
	Interfaces map[string]HostIntfSpec `protobuf:"bytes,1,rep,name=Interfaces,json=interfaces,omitempty" json:"interfaces,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *HostSpec) Reset()                    { *m = HostSpec{} }
func (m *HostSpec) String() string            { return proto.CompactTextString(m) }
func (*HostSpec) ProtoMessage()               {}
func (*HostSpec) Descriptor() ([]byte, []int) { return fileDescriptorCmd, []int{7} }

func (m *HostSpec) GetInterfaces() map[string]HostIntfSpec {
	if m != nil {
		return m.Interfaces
	}
	return nil
}

// HostStatus contains the current state of the Host.
type HostStatus struct {
	// Type of the host
	Type string `protobuf:"bytes,1,opt,name=Type,json=type,omitempty,proto3" json:"type,omitempty"`
	// Operating system info - name of OS with version, eg: "Linux 3.10.0.xyz"
	OperatingSystem string `protobuf:"bytes,2,opt,name=OperatingSystem,json=operating-system,omitempty,proto3" json:"operating-system,omitempty"`
	// Orchestrator is the name of associated Compute controller
	// (like VCenter) managing this host.
	Orchestrator string `protobuf:"bytes,3,opt,name=Orchestrator,json=orchestrator,omitempty,proto3" json:"orchestrator,omitempty"`
	// Status of all interfaces in the Host identified by Primary MAC
	Interfaces map[string]HostIntfStatus `protobuf:"bytes,4,rep,name=Interfaces,json=interfaces,omitempty" json:"interfaces,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *HostStatus) Reset()                    { *m = HostStatus{} }
func (m *HostStatus) String() string            { return proto.CompactTextString(m) }
func (*HostStatus) ProtoMessage()               {}
func (*HostStatus) Descriptor() ([]byte, []int) { return fileDescriptorCmd, []int{8} }

func (m *HostStatus) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *HostStatus) GetOperatingSystem() string {
	if m != nil {
		return m.OperatingSystem
	}
	return ""
}

func (m *HostStatus) GetOrchestrator() string {
	if m != nil {
		return m.Orchestrator
	}
	return ""
}

func (m *HostStatus) GetInterfaces() map[string]HostIntfStatus {
	if m != nil {
		return m.Interfaces
	}
	return nil
}

// ---------------------------------- NODE -------------------------------------------
//
// Node is representation of a single Venice node in the system.
//
type Node struct {
	//
	api.TypeMeta `protobuf:"bytes,1,opt,name=T,json=,inline,embedded=T" json:",inline"`
	//
	api.ObjectMeta `protobuf:"bytes,2,opt,name=O,json=meta,omitempty,embedded=O" json:"meta,omitempty"`
	// Spec contains the configuration of the node.
	Spec NodeSpec `protobuf:"bytes,3,opt,name=Spec,json=spec,omitempty" json:"spec,omitempty"`
	// Status contains the current state of the node.
	Status NodeStatus `protobuf:"bytes,4,opt,name=Status,json=status,omitempty" json:"status,omitempty"`
}

func (m *Node) Reset()                    { *m = Node{} }
func (m *Node) String() string            { return proto.CompactTextString(m) }
func (*Node) ProtoMessage()               {}
func (*Node) Descriptor() ([]byte, []int) { return fileDescriptorCmd, []int{9} }

func (m *Node) GetSpec() NodeSpec {
	if m != nil {
		return m.Spec
	}
	return NodeSpec{}
}

func (m *Node) GetStatus() NodeStatus {
	if m != nil {
		return m.Status
	}
	return NodeStatus{}
}

// NodeCondition describes the state of a Node at a certain point.
type NodeCondition struct {
	// Type indicates a certain node condition
	Type string `protobuf:"bytes,1,opt,name=Type,json=type,omitempty,proto3" json:"type,omitempty"`
	// Condition Status
	Status string `protobuf:"bytes,2,opt,name=Status,json=status,omitempty,proto3" json:"status,omitempty"`
	// The last time the condition transitioned
	LastTransitionTime string `protobuf:"bytes,3,opt,name=LastTransitionTime,json=last-transition-time,omitempty,proto3" json:"last-transition-time,omitempty"`
	// The reason for the condition's last transition
	Reason string `protobuf:"bytes,4,opt,name=Reason,json=reason,omitempty,proto3" json:"reason,omitempty"`
	// A detailed message indicating details about the transition.
	Message string `protobuf:"bytes,5,opt,name=Message,json=message,omitempty,proto3" json:"message,omitempty"`
}

func (m *NodeCondition) Reset()                    { *m = NodeCondition{} }
func (m *NodeCondition) String() string            { return proto.CompactTextString(m) }
func (*NodeCondition) ProtoMessage()               {}
func (*NodeCondition) Descriptor() ([]byte, []int) { return fileDescriptorCmd, []int{10} }

func (m *NodeCondition) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *NodeCondition) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *NodeCondition) GetLastTransitionTime() string {
	if m != nil {
		return m.LastTransitionTime
	}
	return ""
}

func (m *NodeCondition) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

func (m *NodeCondition) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

// NodeSpec contains the configuration of the node.
type NodeSpec struct {
}

func (m *NodeSpec) Reset()                    { *m = NodeSpec{} }
func (m *NodeSpec) String() string            { return proto.CompactTextString(m) }
func (*NodeSpec) ProtoMessage()               {}
func (*NodeSpec) Descriptor() ([]byte, []int) { return fileDescriptorCmd, []int{11} }

// NodeStatus contains the current state of the node.
type NodeStatus struct {
	// Current lifecycle phase of the node.
	Phase string `protobuf:"bytes,1,opt,name=Phase,json=phase,omitempty,proto3" json:"phase,omitempty"`
	// Quorum node or not.
	Quorum bool `protobuf:"varint,2,opt,name=Quorum,json=quorum,omitempty,proto3" json:"quorum,omitempty"`
	// List of current node conditions
	Conditions []*NodeCondition `protobuf:"bytes,3,rep,name=Conditions,json=conditions,omitempty" json:"conditions,omitempty"`
}

func (m *NodeStatus) Reset()                    { *m = NodeStatus{} }
func (m *NodeStatus) String() string            { return proto.CompactTextString(m) }
func (*NodeStatus) ProtoMessage()               {}
func (*NodeStatus) Descriptor() ([]byte, []int) { return fileDescriptorCmd, []int{12} }

func (m *NodeStatus) GetPhase() string {
	if m != nil {
		return m.Phase
	}
	return ""
}

func (m *NodeStatus) GetQuorum() bool {
	if m != nil {
		return m.Quorum
	}
	return false
}

func (m *NodeStatus) GetConditions() []*NodeCondition {
	if m != nil {
		return m.Conditions
	}
	return nil
}

// PortCondition describes the state of a Port at a certain point.
type PortCondition struct {
	// Type indicates a certain Port condition
	Type string `protobuf:"bytes,1,opt,name=Type,json=type,omitempty,proto3" json:"type,omitempty"`
	// Condition Status
	Status string `protobuf:"bytes,2,opt,name=Status,json=status,omitempty,proto3" json:"status,omitempty"`
	// The last time the condition transitioned
	LastTransitionTime string `protobuf:"bytes,3,opt,name=LastTransitionTime,json=last-transition-time,omitempty,proto3" json:"last-transition-time,omitempty"`
	// The reason for the condition's last transition
	Reason string `protobuf:"bytes,4,opt,name=Reason,json=reason,omitempty,proto3" json:"reason,omitempty"`
	// A detailed message indicating details about the transition.
	Message string `protobuf:"bytes,5,opt,name=Message,json=message,omitempty,proto3" json:"message,omitempty"`
}

func (m *PortCondition) Reset()                    { *m = PortCondition{} }
func (m *PortCondition) String() string            { return proto.CompactTextString(m) }
func (*PortCondition) ProtoMessage()               {}
func (*PortCondition) Descriptor() ([]byte, []int) { return fileDescriptorCmd, []int{13} }

func (m *PortCondition) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *PortCondition) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *PortCondition) GetLastTransitionTime() string {
	if m != nil {
		return m.LastTransitionTime
	}
	return ""
}

func (m *PortCondition) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

func (m *PortCondition) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

// PortSpec contains configuration of a port in SmartNIC
type PortSpec struct {
	// Primary Mac address of the Port, which is key identifier of the port
	MacAddress string `protobuf:"bytes,1,opt,name=MacAddress,json=mac-address,omitempty,proto3" json:"mac-address,omitempty"`
}

func (m *PortSpec) Reset()                    { *m = PortSpec{} }
func (m *PortSpec) String() string            { return proto.CompactTextString(m) }
func (*PortSpec) ProtoMessage()               {}
func (*PortSpec) Descriptor() ([]byte, []int) { return fileDescriptorCmd, []int{14} }

func (m *PortSpec) GetMacAddress() string {
	if m != nil {
		return m.MacAddress
	}
	return ""
}

// PortStatus contains current status of a Port
type PortStatus struct {
	// List of all Mac addresses of the Port
	MacAddrs []string `protobuf:"bytes,1,rep,name=MacAddrs,json=mac-addrs,omitempty" json:"mac-addrs,omitempty"`
	// LinkSpeed of the Port
	LinkSpeed string `protobuf:"bytes,2,opt,name=LinkSpeed,json=link-speed,omitempty,proto3" json:"link-speed,omitempty"`
	// List of current Port conditions
	Conditions []*PortCondition `protobuf:"bytes,3,rep,name=Conditions,json=conditions,omitempty" json:"conditions,omitempty"`
}

func (m *PortStatus) Reset()                    { *m = PortStatus{} }
func (m *PortStatus) String() string            { return proto.CompactTextString(m) }
func (*PortStatus) ProtoMessage()               {}
func (*PortStatus) Descriptor() ([]byte, []int) { return fileDescriptorCmd, []int{15} }

func (m *PortStatus) GetMacAddrs() []string {
	if m != nil {
		return m.MacAddrs
	}
	return nil
}

func (m *PortStatus) GetLinkSpeed() string {
	if m != nil {
		return m.LinkSpeed
	}
	return ""
}

func (m *PortStatus) GetConditions() []*PortCondition {
	if m != nil {
		return m.Conditions
	}
	return nil
}

// ------------------------------------ SMART NIC  -------------------------------------------
//
// SmartNIC represents the Naples I/O subsystem
//
// Entity responsible & scenarios involved in managing this object:
//
//      Create:
//          o CMD
//              - created as part of NIC registration, Admittance
//      Modify:
//          o CMD
//              - update spec attributes
//              - update status attributes
//      Delete:
//          o CMD
//              - aging out stale or rejected NICs (TBD)
//          o NetOps, SecOps
//              - Decomission a NIC (TBD)
//
type SmartNIC struct {
	//
	api.TypeMeta `protobuf:"bytes,1,opt,name=T,json=,inline,embedded=T" json:",inline"`
	// Object name is Serial-Number of the SmartNIC
	api.ObjectMeta `protobuf:"bytes,2,opt,name=O,json=meta,omitempty,embedded=O" json:"meta,omitempty"`
	// SmartNICSpec contains the configuration of the network adapter.
	Spec SmartNICSpec `protobuf:"bytes,3,opt,name=Spec,json=spec,omitempty" json:"spec,omitempty"`
	// SmartNICStatus contains the current state of the network adapter.
	Status SmartNICStatus `protobuf:"bytes,4,opt,name=Status,json=status,omitempty" json:"status,omitempty"`
}

func (m *SmartNIC) Reset()                    { *m = SmartNIC{} }
func (m *SmartNIC) String() string            { return proto.CompactTextString(m) }
func (*SmartNIC) ProtoMessage()               {}
func (*SmartNIC) Descriptor() ([]byte, []int) { return fileDescriptorCmd, []int{16} }

func (m *SmartNIC) GetSpec() SmartNICSpec {
	if m != nil {
		return m.Spec
	}
	return SmartNICSpec{}
}

func (m *SmartNIC) GetStatus() SmartNICStatus {
	if m != nil {
		return m.Status
	}
	return SmartNICStatus{}
}

// SmartNICCondition describes the state of a SmartNIC at a certain point.
type SmartNICCondition struct {
	// Type indicates a certain NIC condition
	Type string `protobuf:"bytes,1,opt,name=Type,json=type,omitempty,proto3" json:"type,omitempty"`
	// Condition Status
	Status string `protobuf:"bytes,2,opt,name=Status,json=status,omitempty,proto3" json:"status,omitempty"`
	// The last time the condition transitioned
	LastTransitionTime string `protobuf:"bytes,3,opt,name=LastTransitionTime,json=last-transition-time,omitempty,proto3" json:"last-transition-time,omitempty"`
	// The reason for the condition's last transition
	Reason string `protobuf:"bytes,4,opt,name=Reason,json=reason,omitempty,proto3" json:"reason,omitempty"`
	// A detailed message indicating details about the transition.
	Message string `protobuf:"bytes,5,opt,name=Message,json=message,omitempty,proto3" json:"message,omitempty"`
}

func (m *SmartNICCondition) Reset()                    { *m = SmartNICCondition{} }
func (m *SmartNICCondition) String() string            { return proto.CompactTextString(m) }
func (*SmartNICCondition) ProtoMessage()               {}
func (*SmartNICCondition) Descriptor() ([]byte, []int) { return fileDescriptorCmd, []int{17} }

func (m *SmartNICCondition) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *SmartNICCondition) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *SmartNICCondition) GetLastTransitionTime() string {
	if m != nil {
		return m.LastTransitionTime
	}
	return ""
}

func (m *SmartNICCondition) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

func (m *SmartNICCondition) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

// SmartNICSpec contains configuration of the SmartNIC (Naples I/O subsystem)
type SmartNICSpec struct {
	// Current phase of the SmartNIC.
	// When auto-admission is enabled, Phase will be set to NIC_ADMITTED
	// by CMD for validated NICs.
	// When auto-admission is not enabled, Phase will be set to NIC_PENDING
	// by CMD for validated NICs since it requires manual approval.
	// To admit the NIC as a part of manual admission, user is expected to
	// set the Phase to NIC_ADMITTED for the NICs that are in NIC_PENDING
	// state. Note : Whitelist mode is not supported yet.
	Phase string `protobuf:"bytes,1,opt,name=Phase,json=phase,omitempty,proto3" json:"phase,omitempty"`
	// Management IP address of the naples node
	MgmtIp string `protobuf:"bytes,2,opt,name=MgmtIp,json=mgmt-ip,omitempty,proto3" json:"mgmt-ip,omitempty"`
	// Host name
	HostName string `protobuf:"bytes,3,opt,name=HostName,json=host-name,omitempty,proto3" json:"host-name,omitempty"`
	// Ports holds a list of Port Specs
	Ports []PortSpec `protobuf:"bytes,4,rep,name=Ports,json=ports,omitempty" json:"ports,omitempty"`
}

func (m *SmartNICSpec) Reset()                    { *m = SmartNICSpec{} }
func (m *SmartNICSpec) String() string            { return proto.CompactTextString(m) }
func (*SmartNICSpec) ProtoMessage()               {}
func (*SmartNICSpec) Descriptor() ([]byte, []int) { return fileDescriptorCmd, []int{18} }

func (m *SmartNICSpec) GetPhase() string {
	if m != nil {
		return m.Phase
	}
	return ""
}

func (m *SmartNICSpec) GetMgmtIp() string {
	if m != nil {
		return m.MgmtIp
	}
	return ""
}

func (m *SmartNICSpec) GetHostName() string {
	if m != nil {
		return m.HostName
	}
	return ""
}

func (m *SmartNICSpec) GetPorts() []PortSpec {
	if m != nil {
		return m.Ports
	}
	return nil
}

// SmartNICStatus contains current status of a SmartNIC
type SmartNICStatus struct {
	// List of current NIC conditions
	Conditions []*SmartNICCondition `protobuf:"bytes,1,rep,name=Conditions,json=conditions,omitempty" json:"conditions,omitempty"`
	// Serial number
	SerialNum string `protobuf:"bytes,2,opt,name=SerialNum,json=serial-num,omitempty,proto3" json:"serial-num,omitempty"`
	// Primary MAC address, which is MAC address of the primary PF exposed by SmartNIC
	PrimaryMacAddress string `protobuf:"bytes,3,opt,name=PrimaryMacAddress,json=primary-mac-address,omitempty,proto3" json:"primary-mac-address,omitempty"`
	// Ports holds a list of PortStatus
	Ports []*PortStatus `protobuf:"bytes,4,rep,name=Ports,json=ports,omitempty" json:"ports,omitempty"`
}

func (m *SmartNICStatus) Reset()                    { *m = SmartNICStatus{} }
func (m *SmartNICStatus) String() string            { return proto.CompactTextString(m) }
func (*SmartNICStatus) ProtoMessage()               {}
func (*SmartNICStatus) Descriptor() ([]byte, []int) { return fileDescriptorCmd, []int{19} }

func (m *SmartNICStatus) GetConditions() []*SmartNICCondition {
	if m != nil {
		return m.Conditions
	}
	return nil
}

func (m *SmartNICStatus) GetSerialNum() string {
	if m != nil {
		return m.SerialNum
	}
	return ""
}

func (m *SmartNICStatus) GetPrimaryMacAddress() string {
	if m != nil {
		return m.PrimaryMacAddress
	}
	return ""
}

func (m *SmartNICStatus) GetPorts() []*PortStatus {
	if m != nil {
		return m.Ports
	}
	return nil
}

func init() {
	proto.RegisterType((*Cluster)(nil), "cluster.Cluster")
	proto.RegisterType((*ClusterAuthBootstrapRequest)(nil), "cluster.ClusterAuthBootstrapRequest")
	proto.RegisterType((*ClusterSpec)(nil), "cluster.ClusterSpec")
	proto.RegisterType((*ClusterStatus)(nil), "cluster.ClusterStatus")
	proto.RegisterType((*Host)(nil), "cluster.Host")
	proto.RegisterType((*HostIntfSpec)(nil), "cluster.HostIntfSpec")
	proto.RegisterType((*HostIntfStatus)(nil), "cluster.HostIntfStatus")
	proto.RegisterType((*HostSpec)(nil), "cluster.HostSpec")
	proto.RegisterType((*HostStatus)(nil), "cluster.HostStatus")
	proto.RegisterType((*Node)(nil), "cluster.Node")
	proto.RegisterType((*NodeCondition)(nil), "cluster.NodeCondition")
	proto.RegisterType((*NodeSpec)(nil), "cluster.NodeSpec")
	proto.RegisterType((*NodeStatus)(nil), "cluster.NodeStatus")
	proto.RegisterType((*PortCondition)(nil), "cluster.PortCondition")
	proto.RegisterType((*PortSpec)(nil), "cluster.PortSpec")
	proto.RegisterType((*PortStatus)(nil), "cluster.PortStatus")
	proto.RegisterType((*SmartNIC)(nil), "cluster.SmartNIC")
	proto.RegisterType((*SmartNICCondition)(nil), "cluster.SmartNICCondition")
	proto.RegisterType((*SmartNICSpec)(nil), "cluster.SmartNICSpec")
	proto.RegisterType((*SmartNICStatus)(nil), "cluster.SmartNICStatus")
	proto.RegisterEnum("cluster.ConditionStatus", ConditionStatus_name, ConditionStatus_value)
	proto.RegisterEnum("cluster.HostStatus_HostType", HostStatus_HostType_name, HostStatus_HostType_value)
	proto.RegisterEnum("cluster.NodeCondition_ConditionType", NodeCondition_ConditionType_name, NodeCondition_ConditionType_value)
	proto.RegisterEnum("cluster.NodeStatus_NodePhase", NodeStatus_NodePhase_name, NodeStatus_NodePhase_value)
	proto.RegisterEnum("cluster.PortCondition_ConditionType", PortCondition_ConditionType_name, PortCondition_ConditionType_value)
	proto.RegisterEnum("cluster.SmartNICCondition_ConditionType", SmartNICCondition_ConditionType_name, SmartNICCondition_ConditionType_value)
	proto.RegisterEnum("cluster.SmartNICSpec_SmartNICPhase", SmartNICSpec_SmartNICPhase_name, SmartNICSpec_SmartNICPhase_value)
}
func (m *Cluster) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Cluster) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintCmd(dAtA, i, uint64(m.TypeMeta.Size()))
	n1, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n1
	dAtA[i] = 0x12
	i++
	i = encodeVarintCmd(dAtA, i, uint64(m.ObjectMeta.Size()))
	n2, err := m.ObjectMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n2
	dAtA[i] = 0x1a
	i++
	i = encodeVarintCmd(dAtA, i, uint64(m.Spec.Size()))
	n3, err := m.Spec.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n3
	dAtA[i] = 0x22
	i++
	i = encodeVarintCmd(dAtA, i, uint64(m.Status.Size()))
	n4, err := m.Status.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n4
	return i, nil
}

func (m *ClusterAuthBootstrapRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClusterAuthBootstrapRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintCmd(dAtA, i, uint64(m.TypeMeta.Size()))
	n5, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n5
	dAtA[i] = 0x12
	i++
	i = encodeVarintCmd(dAtA, i, uint64(m.ObjectMeta.Size()))
	n6, err := m.ObjectMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n6
	return i, nil
}

func (m *ClusterSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClusterSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.QuorumNodes) > 0 {
		for _, s := range m.QuorumNodes {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.VirtualIP) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCmd(dAtA, i, uint64(len(m.VirtualIP)))
		i += copy(dAtA[i:], m.VirtualIP)
	}
	if len(m.NTPServers) > 0 {
		for _, s := range m.NTPServers {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.AutoAdmitNICs {
		dAtA[i] = 0x20
		i++
		if m.AutoAdmitNICs {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *ClusterStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClusterStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Leader) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCmd(dAtA, i, uint64(len(m.Leader)))
		i += copy(dAtA[i:], m.Leader)
	}
	if m.LastLeaderTransitionTime != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCmd(dAtA, i, uint64(m.LastLeaderTransitionTime.Size()))
		n7, err := m.LastLeaderTransitionTime.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if len(m.BuildVersion) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCmd(dAtA, i, uint64(len(m.BuildVersion)))
		i += copy(dAtA[i:], m.BuildVersion)
	}
	if len(m.VCSCommit) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCmd(dAtA, i, uint64(len(m.VCSCommit)))
		i += copy(dAtA[i:], m.VCSCommit)
	}
	if len(m.BuildDate) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintCmd(dAtA, i, uint64(len(m.BuildDate)))
		i += copy(dAtA[i:], m.BuildDate)
	}
	if m.AuthBootstrapped {
		dAtA[i] = 0x30
		i++
		if m.AuthBootstrapped {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *Host) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Host) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintCmd(dAtA, i, uint64(m.TypeMeta.Size()))
	n8, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n8
	dAtA[i] = 0x12
	i++
	i = encodeVarintCmd(dAtA, i, uint64(m.ObjectMeta.Size()))
	n9, err := m.ObjectMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n9
	dAtA[i] = 0x1a
	i++
	i = encodeVarintCmd(dAtA, i, uint64(m.Spec.Size()))
	n10, err := m.Spec.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n10
	dAtA[i] = 0x22
	i++
	i = encodeVarintCmd(dAtA, i, uint64(m.Status.Size()))
	n11, err := m.Status.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n11
	return i, nil
}

func (m *HostIntfSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HostIntfSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.MacAddrs) > 0 {
		for _, s := range m.MacAddrs {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *HostIntfStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HostIntfStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.IpAddrs) > 0 {
		for _, s := range m.IpAddrs {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *HostSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HostSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Interfaces) > 0 {
		for k, _ := range m.Interfaces {
			dAtA[i] = 0xa
			i++
			v := m.Interfaces[k]
			msgSize := 0
			if (&v) != nil {
				msgSize = (&v).Size()
				msgSize += 1 + sovCmd(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovCmd(uint64(len(k))) + msgSize
			i = encodeVarintCmd(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintCmd(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintCmd(dAtA, i, uint64((&v).Size()))
			n12, err := (&v).MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n12
		}
	}
	return i, nil
}

func (m *HostStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HostStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCmd(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.OperatingSystem) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCmd(dAtA, i, uint64(len(m.OperatingSystem)))
		i += copy(dAtA[i:], m.OperatingSystem)
	}
	if len(m.Orchestrator) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCmd(dAtA, i, uint64(len(m.Orchestrator)))
		i += copy(dAtA[i:], m.Orchestrator)
	}
	if len(m.Interfaces) > 0 {
		for k, _ := range m.Interfaces {
			dAtA[i] = 0x22
			i++
			v := m.Interfaces[k]
			msgSize := 0
			if (&v) != nil {
				msgSize = (&v).Size()
				msgSize += 1 + sovCmd(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovCmd(uint64(len(k))) + msgSize
			i = encodeVarintCmd(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintCmd(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintCmd(dAtA, i, uint64((&v).Size()))
			n13, err := (&v).MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n13
		}
	}
	return i, nil
}

func (m *Node) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Node) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintCmd(dAtA, i, uint64(m.TypeMeta.Size()))
	n14, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n14
	dAtA[i] = 0x12
	i++
	i = encodeVarintCmd(dAtA, i, uint64(m.ObjectMeta.Size()))
	n15, err := m.ObjectMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n15
	dAtA[i] = 0x1a
	i++
	i = encodeVarintCmd(dAtA, i, uint64(m.Spec.Size()))
	n16, err := m.Spec.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n16
	dAtA[i] = 0x22
	i++
	i = encodeVarintCmd(dAtA, i, uint64(m.Status.Size()))
	n17, err := m.Status.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n17
	return i, nil
}

func (m *NodeCondition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeCondition) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCmd(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.Status) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCmd(dAtA, i, uint64(len(m.Status)))
		i += copy(dAtA[i:], m.Status)
	}
	if len(m.LastTransitionTime) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCmd(dAtA, i, uint64(len(m.LastTransitionTime)))
		i += copy(dAtA[i:], m.LastTransitionTime)
	}
	if len(m.Reason) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCmd(dAtA, i, uint64(len(m.Reason)))
		i += copy(dAtA[i:], m.Reason)
	}
	if len(m.Message) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintCmd(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	return i, nil
}

func (m *NodeSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *NodeStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Phase) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCmd(dAtA, i, uint64(len(m.Phase)))
		i += copy(dAtA[i:], m.Phase)
	}
	if m.Quorum {
		dAtA[i] = 0x10
		i++
		if m.Quorum {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Conditions) > 0 {
		for _, msg := range m.Conditions {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintCmd(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *PortCondition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PortCondition) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCmd(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.Status) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCmd(dAtA, i, uint64(len(m.Status)))
		i += copy(dAtA[i:], m.Status)
	}
	if len(m.LastTransitionTime) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCmd(dAtA, i, uint64(len(m.LastTransitionTime)))
		i += copy(dAtA[i:], m.LastTransitionTime)
	}
	if len(m.Reason) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCmd(dAtA, i, uint64(len(m.Reason)))
		i += copy(dAtA[i:], m.Reason)
	}
	if len(m.Message) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintCmd(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	return i, nil
}

func (m *PortSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PortSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.MacAddress) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCmd(dAtA, i, uint64(len(m.MacAddress)))
		i += copy(dAtA[i:], m.MacAddress)
	}
	return i, nil
}

func (m *PortStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PortStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.MacAddrs) > 0 {
		for _, s := range m.MacAddrs {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.LinkSpeed) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCmd(dAtA, i, uint64(len(m.LinkSpeed)))
		i += copy(dAtA[i:], m.LinkSpeed)
	}
	if len(m.Conditions) > 0 {
		for _, msg := range m.Conditions {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintCmd(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SmartNIC) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SmartNIC) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintCmd(dAtA, i, uint64(m.TypeMeta.Size()))
	n18, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n18
	dAtA[i] = 0x12
	i++
	i = encodeVarintCmd(dAtA, i, uint64(m.ObjectMeta.Size()))
	n19, err := m.ObjectMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n19
	dAtA[i] = 0x1a
	i++
	i = encodeVarintCmd(dAtA, i, uint64(m.Spec.Size()))
	n20, err := m.Spec.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n20
	dAtA[i] = 0x22
	i++
	i = encodeVarintCmd(dAtA, i, uint64(m.Status.Size()))
	n21, err := m.Status.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n21
	return i, nil
}

func (m *SmartNICCondition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SmartNICCondition) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCmd(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.Status) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCmd(dAtA, i, uint64(len(m.Status)))
		i += copy(dAtA[i:], m.Status)
	}
	if len(m.LastTransitionTime) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCmd(dAtA, i, uint64(len(m.LastTransitionTime)))
		i += copy(dAtA[i:], m.LastTransitionTime)
	}
	if len(m.Reason) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCmd(dAtA, i, uint64(len(m.Reason)))
		i += copy(dAtA[i:], m.Reason)
	}
	if len(m.Message) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintCmd(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	return i, nil
}

func (m *SmartNICSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SmartNICSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Phase) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCmd(dAtA, i, uint64(len(m.Phase)))
		i += copy(dAtA[i:], m.Phase)
	}
	if len(m.MgmtIp) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCmd(dAtA, i, uint64(len(m.MgmtIp)))
		i += copy(dAtA[i:], m.MgmtIp)
	}
	if len(m.HostName) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCmd(dAtA, i, uint64(len(m.HostName)))
		i += copy(dAtA[i:], m.HostName)
	}
	if len(m.Ports) > 0 {
		for _, msg := range m.Ports {
			dAtA[i] = 0x22
			i++
			i = encodeVarintCmd(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SmartNICStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SmartNICStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Conditions) > 0 {
		for _, msg := range m.Conditions {
			dAtA[i] = 0xa
			i++
			i = encodeVarintCmd(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.SerialNum) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCmd(dAtA, i, uint64(len(m.SerialNum)))
		i += copy(dAtA[i:], m.SerialNum)
	}
	if len(m.PrimaryMacAddress) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCmd(dAtA, i, uint64(len(m.PrimaryMacAddress)))
		i += copy(dAtA[i:], m.PrimaryMacAddress)
	}
	if len(m.Ports) > 0 {
		for _, msg := range m.Ports {
			dAtA[i] = 0x22
			i++
			i = encodeVarintCmd(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func encodeVarintCmd(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Cluster) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovCmd(uint64(l))
	l = m.ObjectMeta.Size()
	n += 1 + l + sovCmd(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovCmd(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovCmd(uint64(l))
	return n
}

func (m *ClusterAuthBootstrapRequest) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovCmd(uint64(l))
	l = m.ObjectMeta.Size()
	n += 1 + l + sovCmd(uint64(l))
	return n
}

func (m *ClusterSpec) Size() (n int) {
	var l int
	_ = l
	if len(m.QuorumNodes) > 0 {
		for _, s := range m.QuorumNodes {
			l = len(s)
			n += 1 + l + sovCmd(uint64(l))
		}
	}
	l = len(m.VirtualIP)
	if l > 0 {
		n += 1 + l + sovCmd(uint64(l))
	}
	if len(m.NTPServers) > 0 {
		for _, s := range m.NTPServers {
			l = len(s)
			n += 1 + l + sovCmd(uint64(l))
		}
	}
	if m.AutoAdmitNICs {
		n += 2
	}
	return n
}

func (m *ClusterStatus) Size() (n int) {
	var l int
	_ = l
	l = len(m.Leader)
	if l > 0 {
		n += 1 + l + sovCmd(uint64(l))
	}
	if m.LastLeaderTransitionTime != nil {
		l = m.LastLeaderTransitionTime.Size()
		n += 1 + l + sovCmd(uint64(l))
	}
	l = len(m.BuildVersion)
	if l > 0 {
		n += 1 + l + sovCmd(uint64(l))
	}
	l = len(m.VCSCommit)
	if l > 0 {
		n += 1 + l + sovCmd(uint64(l))
	}
	l = len(m.BuildDate)
	if l > 0 {
		n += 1 + l + sovCmd(uint64(l))
	}
	if m.AuthBootstrapped {
		n += 2
	}
	return n
}

func (m *Host) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovCmd(uint64(l))
	l = m.ObjectMeta.Size()
	n += 1 + l + sovCmd(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovCmd(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovCmd(uint64(l))
	return n
}

func (m *HostIntfSpec) Size() (n int) {
	var l int
	_ = l
	if len(m.MacAddrs) > 0 {
		for _, s := range m.MacAddrs {
			l = len(s)
			n += 1 + l + sovCmd(uint64(l))
		}
	}
	return n
}

func (m *HostIntfStatus) Size() (n int) {
	var l int
	_ = l
	if len(m.IpAddrs) > 0 {
		for _, s := range m.IpAddrs {
			l = len(s)
			n += 1 + l + sovCmd(uint64(l))
		}
	}
	return n
}

func (m *HostSpec) Size() (n int) {
	var l int
	_ = l
	if len(m.Interfaces) > 0 {
		for k, v := range m.Interfaces {
			_ = k
			_ = v
			l = v.Size()
			mapEntrySize := 1 + len(k) + sovCmd(uint64(len(k))) + 1 + l + sovCmd(uint64(l))
			n += mapEntrySize + 1 + sovCmd(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *HostStatus) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovCmd(uint64(l))
	}
	l = len(m.OperatingSystem)
	if l > 0 {
		n += 1 + l + sovCmd(uint64(l))
	}
	l = len(m.Orchestrator)
	if l > 0 {
		n += 1 + l + sovCmd(uint64(l))
	}
	if len(m.Interfaces) > 0 {
		for k, v := range m.Interfaces {
			_ = k
			_ = v
			l = v.Size()
			mapEntrySize := 1 + len(k) + sovCmd(uint64(len(k))) + 1 + l + sovCmd(uint64(l))
			n += mapEntrySize + 1 + sovCmd(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *Node) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovCmd(uint64(l))
	l = m.ObjectMeta.Size()
	n += 1 + l + sovCmd(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovCmd(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovCmd(uint64(l))
	return n
}

func (m *NodeCondition) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovCmd(uint64(l))
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovCmd(uint64(l))
	}
	l = len(m.LastTransitionTime)
	if l > 0 {
		n += 1 + l + sovCmd(uint64(l))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovCmd(uint64(l))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovCmd(uint64(l))
	}
	return n
}

func (m *NodeSpec) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *NodeStatus) Size() (n int) {
	var l int
	_ = l
	l = len(m.Phase)
	if l > 0 {
		n += 1 + l + sovCmd(uint64(l))
	}
	if m.Quorum {
		n += 2
	}
	if len(m.Conditions) > 0 {
		for _, e := range m.Conditions {
			l = e.Size()
			n += 1 + l + sovCmd(uint64(l))
		}
	}
	return n
}

func (m *PortCondition) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovCmd(uint64(l))
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovCmd(uint64(l))
	}
	l = len(m.LastTransitionTime)
	if l > 0 {
		n += 1 + l + sovCmd(uint64(l))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovCmd(uint64(l))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovCmd(uint64(l))
	}
	return n
}

func (m *PortSpec) Size() (n int) {
	var l int
	_ = l
	l = len(m.MacAddress)
	if l > 0 {
		n += 1 + l + sovCmd(uint64(l))
	}
	return n
}

func (m *PortStatus) Size() (n int) {
	var l int
	_ = l
	if len(m.MacAddrs) > 0 {
		for _, s := range m.MacAddrs {
			l = len(s)
			n += 1 + l + sovCmd(uint64(l))
		}
	}
	l = len(m.LinkSpeed)
	if l > 0 {
		n += 1 + l + sovCmd(uint64(l))
	}
	if len(m.Conditions) > 0 {
		for _, e := range m.Conditions {
			l = e.Size()
			n += 1 + l + sovCmd(uint64(l))
		}
	}
	return n
}

func (m *SmartNIC) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovCmd(uint64(l))
	l = m.ObjectMeta.Size()
	n += 1 + l + sovCmd(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovCmd(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovCmd(uint64(l))
	return n
}

func (m *SmartNICCondition) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovCmd(uint64(l))
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovCmd(uint64(l))
	}
	l = len(m.LastTransitionTime)
	if l > 0 {
		n += 1 + l + sovCmd(uint64(l))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovCmd(uint64(l))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovCmd(uint64(l))
	}
	return n
}

func (m *SmartNICSpec) Size() (n int) {
	var l int
	_ = l
	l = len(m.Phase)
	if l > 0 {
		n += 1 + l + sovCmd(uint64(l))
	}
	l = len(m.MgmtIp)
	if l > 0 {
		n += 1 + l + sovCmd(uint64(l))
	}
	l = len(m.HostName)
	if l > 0 {
		n += 1 + l + sovCmd(uint64(l))
	}
	if len(m.Ports) > 0 {
		for _, e := range m.Ports {
			l = e.Size()
			n += 1 + l + sovCmd(uint64(l))
		}
	}
	return n
}

func (m *SmartNICStatus) Size() (n int) {
	var l int
	_ = l
	if len(m.Conditions) > 0 {
		for _, e := range m.Conditions {
			l = e.Size()
			n += 1 + l + sovCmd(uint64(l))
		}
	}
	l = len(m.SerialNum)
	if l > 0 {
		n += 1 + l + sovCmd(uint64(l))
	}
	l = len(m.PrimaryMacAddress)
	if l > 0 {
		n += 1 + l + sovCmd(uint64(l))
	}
	if len(m.Ports) > 0 {
		for _, e := range m.Ports {
			l = e.Size()
			n += 1 + l + sovCmd(uint64(l))
		}
	}
	return n
}

func sovCmd(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozCmd(x uint64) (n int) {
	return sovCmd(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Cluster) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Cluster: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Cluster: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmd(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClusterAuthBootstrapRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClusterAuthBootstrapRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClusterAuthBootstrapRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmd(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClusterSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClusterSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClusterSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QuorumNodes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QuorumNodes = append(m.QuorumNodes, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VirtualIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VirtualIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NTPServers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NTPServers = append(m.NTPServers, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoAdmitNICs", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AutoAdmitNICs = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCmd(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClusterStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClusterStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClusterStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Leader", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Leader = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastLeaderTransitionTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastLeaderTransitionTime == nil {
				m.LastLeaderTransitionTime = &api.Timestamp{}
			}
			if err := m.LastLeaderTransitionTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BuildVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VCSCommit", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VCSCommit = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildDate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BuildDate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthBootstrapped", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AuthBootstrapped = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCmd(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Host) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Host: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Host: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmd(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HostIntfSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HostIntfSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HostIntfSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MacAddrs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MacAddrs = append(m.MacAddrs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmd(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HostIntfStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HostIntfStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HostIntfStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpAddrs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IpAddrs = append(m.IpAddrs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmd(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HostSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HostSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HostSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Interfaces", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Interfaces == nil {
				m.Interfaces = make(map[string]HostIntfSpec)
			}
			var mapkey string
			mapvalue := &HostIntfSpec{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCmd
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCmd
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthCmd
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCmd
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthCmd
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthCmd
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &HostIntfSpec{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCmd(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCmd
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Interfaces[mapkey] = *mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmd(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HostStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HostStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HostStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperatingSystem", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OperatingSystem = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Orchestrator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Orchestrator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Interfaces", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Interfaces == nil {
				m.Interfaces = make(map[string]HostIntfStatus)
			}
			var mapkey string
			mapvalue := &HostIntfStatus{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCmd
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCmd
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthCmd
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCmd
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthCmd
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthCmd
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &HostIntfStatus{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCmd(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCmd
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Interfaces[mapkey] = *mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmd(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Node) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Node: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Node: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmd(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeCondition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeCondition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeCondition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastTransitionTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastTransitionTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmd(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipCmd(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phase", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Phase = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quorum", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Quorum = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conditions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Conditions = append(m.Conditions, &NodeCondition{})
			if err := m.Conditions[len(m.Conditions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmd(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PortCondition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PortCondition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PortCondition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastTransitionTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastTransitionTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmd(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PortSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PortSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PortSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MacAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MacAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmd(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PortStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PortStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PortStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MacAddrs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MacAddrs = append(m.MacAddrs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LinkSpeed", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LinkSpeed = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conditions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Conditions = append(m.Conditions, &PortCondition{})
			if err := m.Conditions[len(m.Conditions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmd(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SmartNIC) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SmartNIC: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SmartNIC: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmd(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SmartNICCondition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SmartNICCondition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SmartNICCondition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastTransitionTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastTransitionTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmd(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SmartNICSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SmartNICSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SmartNICSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phase", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Phase = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MgmtIp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MgmtIp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ports", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ports = append(m.Ports, PortSpec{})
			if err := m.Ports[len(m.Ports)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmd(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SmartNICStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SmartNICStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SmartNICStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conditions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Conditions = append(m.Conditions, &SmartNICCondition{})
			if err := m.Conditions[len(m.Conditions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SerialNum", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SerialNum = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrimaryMacAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrimaryMacAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ports", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ports = append(m.Ports, &PortStatus{})
			if err := m.Ports[len(m.Ports)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmd(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCmd(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCmd
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthCmd
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowCmd
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipCmd(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthCmd = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCmd   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("cmd.proto", fileDescriptorCmd) }

var fileDescriptorCmd = []byte{
	// 1789 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x58, 0x4d, 0x6f, 0x1b, 0xc7,
	0x19, 0xd6, 0x92, 0xfa, 0x20, 0x5f, 0x8a, 0x22, 0x35, 0x96, 0x25, 0x52, 0xb2, 0xc5, 0x74, 0x53,
	0x17, 0x6e, 0x9b, 0x95, 0x80, 0xa4, 0x30, 0x02, 0xb7, 0x09, 0x40, 0x4a, 0x6b, 0x8b, 0x0a, 0x45,
	0xb2, 0x4b, 0x5a, 0x69, 0x80, 0x22, 0xe9, 0x88, 0x1c, 0x53, 0x5b, 0x73, 0x3f, 0xb2, 0x3b, 0xab,
	0x42, 0x3f, 0xc0, 0xfa, 0x05, 0xfd, 0x15, 0x42, 0x0b, 0xf4, 0xd8, 0x4b, 0x0f, 0xe9, 0xc9, 0x40,
	0x2f, 0x81, 0xaf, 0x05, 0x88, 0xc2, 0x47, 0xfe, 0x81, 0x02, 0x3d, 0x15, 0x33, 0xbb, 0x4b, 0xce,
	0x90, 0x94, 0x2d, 0xa5, 0x41, 0xdc, 0x83, 0x6f, 0xbb, 0xcf, 0x3b, 0xf3, 0x70, 0x76, 0x9e, 0xf7,
	0x7d, 0xde, 0x19, 0x42, 0xba, 0x63, 0x75, 0x77, 0x5c, 0xcf, 0xa1, 0x0e, 0x5a, 0xea, 0xf4, 0x03,
	0x9f, 0x12, 0x6f, 0xf3, 0x4e, 0xcf, 0x71, 0x7a, 0x7d, 0xb2, 0x8b, 0x5d, 0x73, 0x17, 0xdb, 0xb6,
	0x43, 0x31, 0x35, 0x1d, 0xdb, 0x0f, 0x87, 0x6d, 0xea, 0x3d, 0x93, 0x9e, 0x06, 0x27, 0x3b, 0x1d,
	0xc7, 0xda, 0x75, 0x89, 0xed, 0x63, 0xbb, 0xeb, 0xec, 0xfa, 0x7f, 0xd8, 0x3d, 0x23, 0xb6, 0xd9,
	0x21, 0xbb, 0x01, 0x35, 0xfb, 0x3e, 0x9b, 0xda, 0x23, 0xb6, 0x38, 0x7b, 0xd7, 0xb4, 0x3b, 0xfd,
	0xa0, 0x4b, 0x62, 0x1a, 0x4d, 0xa0, 0xe9, 0x39, 0x3d, 0x67, 0x97, 0xc3, 0x27, 0xc1, 0x53, 0xfe,
	0xc6, 0x5f, 0xf8, 0x53, 0x34, 0xfc, 0xde, 0x15, 0xbf, 0xca, 0xd6, 0x68, 0x11, 0x8a, 0xc3, 0x61,
	0xea, 0x5f, 0x13, 0xb0, 0xb4, 0x17, 0x7e, 0x06, 0x7a, 0x00, 0x4a, 0xbb, 0xa0, 0xbc, 0xa7, 0xdc,
	0xcf, 0x7c, 0x98, 0xdd, 0xc1, 0xae, 0xb9, 0xd3, 0x3e, 0x77, 0xc9, 0x11, 0xa1, 0xb8, 0x72, 0xeb,
	0xc5, 0xa0, 0x34, 0xf7, 0xed, 0xa0, 0xa4, 0x0c, 0x07, 0xa5, 0xa5, 0x0f, 0x4c, 0xbb, 0x6f, 0xda,
	0xc4, 0x88, 0x1f, 0xd0, 0x23, 0x50, 0x1a, 0x85, 0x04, 0x9f, 0x97, 0xe3, 0xf3, 0x1a, 0x27, 0xbf,
	0x27, 0x1d, 0xca, 0x67, 0x6e, 0x0a, 0x33, 0x57, 0xd8, 0xef, 0x7e, 0xe0, 0x58, 0x26, 0x25, 0x96,
	0x4b, 0xcf, 0x8d, 0x89, 0x77, 0x74, 0x08, 0xf3, 0x2d, 0x97, 0x74, 0x0a, 0x49, 0x4e, 0xb5, 0xb6,
	0x13, 0x6d, 0xef, 0x4e, 0xb4, 0x3e, 0x16, 0xab, 0xac, 0x33, 0x3e, 0xc6, 0xe5, 0xbb, 0xa4, 0x23,
	0x72, 0xc9, 0xef, 0xc8, 0x80, 0xc5, 0x16, 0xc5, 0x34, 0xf0, 0x0b, 0xf3, 0x9c, 0x6d, 0x7d, 0x8a,
	0x8d, 0x47, 0x2b, 0x85, 0x88, 0x2f, 0xef, 0xf3, 0x77, 0x81, 0x71, 0x0a, 0x79, 0x98, 0x7d, 0xf9,
	0xbc, 0x98, 0xde, 0x8c, 0x55, 0x57, 0xff, 0xa4, 0xc0, 0x56, 0x44, 0x56, 0x0e, 0xe8, 0x69, 0xc5,
	0x71, 0xa8, 0x4f, 0x3d, 0xec, 0x1a, 0xe4, 0xeb, 0x80, 0xf8, 0xf4, 0x6d, 0x6f, 0xe7, 0xe4, 0x72,
	0xff, 0x92, 0x80, 0x8c, 0xb0, 0x93, 0xe8, 0x31, 0x64, 0x7e, 0x1d, 0x38, 0x5e, 0x60, 0xd5, 0x9d,
	0x2e, 0xf1, 0x0b, 0xca, 0x7b, 0xc9, 0xfb, 0xe9, 0xca, 0xe6, 0x70, 0x50, 0x5a, 0xff, 0x9a, 0xc3,
	0x9a, 0xcd, 0x70, 0x81, 0xff, 0x0a, 0x1c, 0x95, 0x21, 0x7d, 0x6c, 0x7a, 0x34, 0xc0, 0xfd, 0x6a,
	0x93, 0xaf, 0x3b, 0x5d, 0x29, 0x0c, 0x07, 0xa5, 0xb5, 0xb3, 0x10, 0xd4, 0x4c, 0x57, 0x20, 0x99,
	0x89, 0xa2, 0x7d, 0x80, 0x7a, 0xbb, 0xd9, 0x22, 0xde, 0x19, 0xf1, 0xfc, 0x42, 0x92, 0x2f, 0xa5,
	0x38, 0x1c, 0x94, 0x6e, 0xdb, 0xd4, 0xd5, 0xfc, 0x10, 0x16, 0x48, 0x66, 0xc3, 0xa8, 0x01, 0xd9,
	0x72, 0x40, 0x9d, 0x72, 0xd7, 0x32, 0x69, 0xbd, 0xba, 0x17, 0x4a, 0x9f, 0xaa, 0xdc, 0x1d, 0x0e,
	0x4a, 0x45, 0x1c, 0x50, 0x47, 0xc3, 0x2c, 0xa2, 0xd9, 0x66, 0x47, 0x24, 0xbb, 0x3a, 0xa4, 0xfe,
	0x27, 0x09, 0x59, 0x29, 0x5d, 0xd0, 0x03, 0x58, 0xac, 0x11, 0xdc, 0x25, 0x1e, 0x17, 0x36, 0x5d,
	0x59, 0x63, 0xa9, 0xd3, 0xe7, 0x88, 0x98, 0x3a, 0x93, 0x08, 0xba, 0x50, 0xa0, 0x50, 0xc3, 0x3e,
	0x0d, 0x27, 0xb7, 0x3d, 0x6c, 0xfb, 0x26, 0xab, 0xf2, 0xb6, 0x69, 0x91, 0x48, 0xeb, 0x95, 0x30,
	0x47, 0x4c, 0x8b, 0xf8, 0x14, 0x5b, 0x6e, 0x45, 0x7b, 0x11, 0xca, 0x7c, 0xaf, 0x8f, 0x7d, 0xaa,
	0x85, 0x8c, 0x1a, 0x1d, 0xcd, 0xd4, 0xa8, 0x69, 0x11, 0xe1, 0x37, 0xaf, 0x37, 0x0c, 0x1d, 0xc2,
	0x72, 0x25, 0x30, 0xfb, 0xdd, 0x63, 0xe2, 0xf9, 0xa6, 0x63, 0xf3, 0x5a, 0x4b, 0x57, 0xb6, 0x86,
	0x83, 0xd2, 0xc6, 0x09, 0xc3, 0xb5, 0xb3, 0x30, 0x20, 0x30, 0x5f, 0x15, 0xe0, 0xc2, 0xef, 0xb5,
	0xf6, 0x1c, 0xcb, 0x32, 0x29, 0xdf, 0xeb, 0x58, 0xf8, 0x8e, 0xaf, 0x75, 0x38, 0x2a, 0x09, 0x3f,
	0x03, 0x65, 0x14, 0x7c, 0x39, 0xfb, 0x98, 0x92, 0xc2, 0xc2, 0x98, 0x22, 0xfc, 0xc9, 0x2e, 0xa6,
	0xe2, 0x27, 0xce, 0x44, 0xd1, 0x31, 0xe4, 0xa5, 0xf2, 0x73, 0x49, 0xb7, 0xb0, 0xc8, 0x85, 0x2f,
	0x0d, 0x07, 0xa5, 0x2d, 0x1c, 0xd0, 0x53, 0xed, 0x44, 0x08, 0x0a, 0x84, 0xaf, 0x0b, 0xaa, 0x7f,
	0x4e, 0xc0, 0xfc, 0x81, 0xf3, 0xf6, 0xeb, 0x18, 0x3d, 0x96, 0x6c, 0x71, 0x75, 0x64, 0x64, 0x6c,
	0x71, 0x37, 0xf2, 0xc4, 0xc6, 0x84, 0x27, 0xde, 0x92, 0xa9, 0x6e, 0x6e, 0x88, 0x99, 0x97, 0xcf,
	0x8b, 0x4b, 0x68, 0xe1, 0xd4, 0xf1, 0xa9, 0xaf, 0xd6, 0x61, 0x99, 0xd1, 0x54, 0x6d, 0xfa, 0x94,
	0xfb, 0xcb, 0xa7, 0x90, 0x3a, 0xc2, 0x9d, 0x72, 0xb7, 0xeb, 0xc5, 0xe6, 0xb2, 0x31, 0x1c, 0x94,
	0x6e, 0x59, 0xb8, 0xa3, 0x61, 0x06, 0x0a, 0xcc, 0xb3, 0x40, 0xf5, 0x08, 0x56, 0x46, 0x7c, 0x61,
	0xf1, 0xfd, 0x12, 0x96, 0xaa, 0xae, 0x48, 0xb8, 0x3e, 0x1c, 0x94, 0x90, 0xe9, 0x4e, 0xf1, 0xcd,
	0xc0, 0xd4, 0x7f, 0x28, 0x90, 0x8a, 0x77, 0x0c, 0x99, 0x00, 0x55, 0x9b, 0x12, 0xef, 0x29, 0xee,
	0x44, 0xd6, 0x97, 0xf9, 0xf0, 0x47, 0x53, 0x1b, 0xbb, 0x33, 0x1e, 0xa3, 0xdb, 0xd4, 0x3b, 0xaf,
	0xdc, 0x89, 0xf6, 0x66, 0xcd, 0x1c, 0x05, 0xc4, 0xf4, 0x9c, 0x85, 0x6e, 0xb6, 0x21, 0x37, 0x41,
	0x83, 0xf2, 0x90, 0x7c, 0x46, 0xce, 0x43, 0x07, 0x31, 0xd8, 0x23, 0xfa, 0x39, 0x2c, 0x9c, 0xe1,
	0x7e, 0x10, 0x5b, 0xc1, 0x6d, 0x69, 0x29, 0xf1, 0x8e, 0x1a, 0xe1, 0x98, 0x87, 0x89, 0x8f, 0x15,
	0xf5, 0x62, 0x1e, 0x60, 0x2c, 0x1a, 0x6a, 0xc3, 0x3c, 0x4b, 0xca, 0xc8, 0x94, 0x1e, 0x5c, 0x5e,
	0x14, 0xef, 0xb4, 0xa8, 0xa7, 0xdb, 0x81, 0x75, 0x7f, 0x3c, 0x8a, 0x93, 0xb1, 0x61, 0x3f, 0x8d,
	0x9c, 0x65, 0x85, 0x9e, 0xbb, 0x62, 0x7d, 0x4d, 0xbc, 0xa3, 0xcf, 0x21, 0xd7, 0x70, 0x89, 0x87,
	0xa9, 0x69, 0xf7, 0x5a, 0xe7, 0x3e, 0x25, 0x56, 0x64, 0xef, 0x6a, 0x44, 0xb0, 0xe9, 0xc4, 0x61,
	0xcd, 0xe7, 0x71, 0x81, 0xec, 0x35, 0x31, 0x54, 0x83, 0xe5, 0x86, 0xd7, 0x39, 0x25, 0xac, 0xea,
	0xa8, 0xe3, 0x45, 0x26, 0xb4, 0x1d, 0xb1, 0xae, 0x3b, 0x42, 0x4c, 0xec, 0x3f, 0xb3, 0x71, 0xf4,
	0x4c, 0x12, 0x73, 0x9e, 0x8b, 0xf9, 0xfe, 0x8c, 0xd4, 0xfe, 0x5e, 0xe4, 0x3c, 0xbe, 0x8e, 0x9c,
	0x9a, 0x2c, 0xe7, 0xc6, 0xb4, 0x9c, 0x7c, 0x41, 0xa2, 0xa0, 0x0f, 0xc2, 0xec, 0x64, 0xf2, 0xa0,
	0x0c, 0x2c, 0x3d, 0xa9, 0x7f, 0x56, 0x6f, 0x7c, 0x5e, 0xcf, 0xcf, 0xa1, 0x2c, 0xa4, 0x2b, 0x65,
	0x43, 0x3f, 0xd2, 0xdb, 0xe5, 0x5a, 0x5e, 0x41, 0x2b, 0x00, 0x07, 0x5f, 0x34, 0x75, 0xe3, 0xb8,
	0xda, 0x6a, 0x18, 0xf9, 0x04, 0x77, 0x29, 0xd6, 0xc0, 0xff, 0x6f, 0x5d, 0x8a, 0x2d, 0xee, 0x7b,
	0x72, 0x29, 0x4e, 0xf5, 0x9d, 0x5d, 0x8a, 0x1f, 0x5b, 0xd4, 0x6f, 0x92, 0x90, 0x65, 0x3c, 0x7b,
	0x8e, 0xdd, 0xe5, 0x0d, 0x12, 0xfd, 0x56, 0xaa, 0x9d, 0x4f, 0x2f, 0x2f, 0x8a, 0x3f, 0x8e, 0x6b,
	0x47, 0x1a, 0xb8, 0x33, 0x7a, 0xba, 0x49, 0x0d, 0x1d, 0x8f, 0xbe, 0x26, 0x2c, 0x9d, 0x5f, 0x5c,
	0x5e, 0x14, 0x0b, 0x31, 0xff, 0x88, 0x31, 0x1c, 0x12, 0x73, 0x5e, 0xe3, 0xa3, 0xd0, 0x09, 0x20,
	0x76, 0x9e, 0x98, 0x38, 0x49, 0x84, 0x85, 0xf4, 0x93, 0x88, 0x67, 0x9b, 0x1f, 0x09, 0xae, 0x3e,
	0x32, 0xbc, 0x21, 0x8e, 0x1e, 0xc2, 0xa2, 0x41, 0xb0, 0xef, 0xd8, 0x71, 0x73, 0x8f, 0xd7, 0xe7,
	0x71, 0x54, 0x5c, 0xdf, 0x24, 0x82, 0x3e, 0x81, 0xa5, 0x23, 0xe2, 0xfb, 0xb8, 0x17, 0xb7, 0xf5,
	0x62, 0x34, 0x79, 0xd5, 0x0a, 0x61, 0x61, 0xf6, 0x34, 0xa4, 0x6e, 0x41, 0x56, 0xda, 0x6e, 0x04,
	0xb0, 0x58, 0xd3, 0xcb, 0xfb, 0xba, 0x91, 0x9f, 0x53, 0x01, 0x52, 0x71, 0x56, 0xa9, 0xdf, 0x24,
	0x00, 0xc6, 0x79, 0x81, 0x7e, 0x03, 0x0b, 0xcd, 0x53, 0xec, 0xc7, 0x6a, 0x7e, 0x7c, 0x79, 0x51,
	0xbc, 0x2b, 0xaa, 0x19, 0x39, 0x01, 0x7b, 0xe4, 0xe3, 0xe2, 0x2d, 0xcf, 0xb9, 0xec, 0x4d, 0x58,
	0xd3, 0x24, 0xc0, 0x36, 0x23, 0x3c, 0x2e, 0x73, 0x21, 0x53, 0xe3, 0xcd, 0x08, 0x4f, 0xc5, 0xe2,
	0x66, 0x4c, 0x22, 0xe8, 0x4b, 0x80, 0xd1, 0xd7, 0x84, 0xc7, 0x5b, 0xf1, 0x42, 0x22, 0x65, 0x19,
	0x37, 0x25, 0xc6, 0xbb, 0xd6, 0x19, 0xcd, 0x10, 0x4d, 0x69, 0x16, 0xaa, 0x7e, 0x02, 0xe9, 0xd1,
	0x17, 0xc9, 0xee, 0x91, 0x81, 0xa5, 0xa6, 0x5e, 0xdf, 0xaf, 0xd6, 0x1f, 0xe7, 0x15, 0xb6, 0x87,
	0x87, 0x8d, 0x6a, 0x5d, 0xdf, 0xcf, 0x27, 0xd8, 0xf3, 0xa3, 0x72, 0xb5, 0xa6, 0xef, 0xe7, 0x93,
	0xea, 0xdf, 0x93, 0x90, 0x6d, 0x3a, 0x1e, 0xbd, 0x56, 0x4d, 0x48, 0x03, 0xdf, 0xd5, 0xc4, 0x0f,
	0x58, 0x13, 0x77, 0x26, 0x6b, 0x82, 0x89, 0xdb, 0x30, 0xda, 0x5f, 0x3d, 0x69, 0xe6, 0xe7, 0xd4,
	0x36, 0xa4, 0x98, 0x34, 0xfc, 0x78, 0x73, 0x00, 0x10, 0x1d, 0xbd, 0x88, 0xef, 0x47, 0x22, 0xde,
	0x8d, 0x7e, 0xeb, 0x76, 0x7c, 0xd6, 0x22, 0xbe, 0x74, 0xa5, 0x9a, 0x09, 0xab, 0xff, 0x56, 0x00,
	0x38, 0x6d, 0x58, 0x5e, 0x95, 0xa9, 0x33, 0xdd, 0x56, 0x44, 0x7b, 0xed, 0x73, 0x1d, 0xd2, 0x21,
	0x5d, 0x33, 0xed, 0x67, 0x2d, 0x97, 0x90, 0x6e, 0x94, 0x00, 0xa3, 0x9c, 0xef, 0x9b, 0xf6, 0x33,
	0xcd, 0x67, 0x11, 0x31, 0xe7, 0x67, 0xa1, 0x6f, 0xa8, 0x29, 0x29, 0x4b, 0xbf, 0x53, 0x4d, 0xfd,
	0x2d, 0x01, 0xa9, 0x96, 0x85, 0x3d, 0x76, 0x93, 0x7c, 0xeb, 0xcd, 0xf5, 0x33, 0xa9, 0xb9, 0x8e,
	0x8f, 0x87, 0xf1, 0x02, 0x6f, 0xd4, 0x60, 0x5b, 0x13, 0x0d, 0x76, 0x63, 0x9a, 0xee, 0xe6, 0x4d,
	0x36, 0xf7, 0xf2, 0x79, 0x31, 0x83, 0xd2, 0x3e, 0x63, 0x60, 0xb7, 0x68, 0xf5, 0x9f, 0x49, 0x58,
	0x8d, 0xf9, 0xc6, 0xc6, 0xf2, 0x3b, 0xc9, 0x58, 0x2a, 0x97, 0x17, 0xc5, 0xfb, 0x71, 0xe1, 0x4f,
	0x0d, 0x7e, 0x67, 0x2e, 0x3f, 0xa0, 0xb9, 0x68, 0x33, 0xcc, 0xe5, 0x40, 0x2f, 0xd7, 0xda, 0x07,
	0x5f, 0xe4, 0xe7, 0x50, 0x0e, 0x32, 0x4f, 0xea, 0x86, 0x5e, 0xde, 0x3b, 0x28, 0x57, 0x6a, 0x7a,
	0x5e, 0x51, 0xff, 0x98, 0x84, 0x65, 0x31, 0xf9, 0xd0, 0x97, 0x72, 0xe3, 0x65, 0x2d, 0xe3, 0xfd,
	0x49, 0x65, 0xf9, 0x9d, 0x2a, 0x7e, 0xb9, 0x61, 0xfb, 0xfd, 0x15, 0x2c, 0x1e, 0xf5, 0x2c, 0x5a,
	0x75, 0x23, 0x59, 0xc7, 0x5f, 0xd7, 0xb3, 0xa8, 0xfc, 0x17, 0xd3, 0x34, 0xc4, 0x7c, 0x8b, 0x9d,
	0xae, 0xeb, 0x78, 0x24, 0xd9, 0xc8, 0xb7, 0xd8, 0xe5, 0x55, 0xb3, 0xb1, 0xa4, 0xd3, 0x2c, 0x10,
	0x1d, 0xc2, 0x02, 0x73, 0x95, 0xf8, 0x86, 0xb1, 0x2a, 0x79, 0x0d, 0x2f, 0xc0, 0x8d, 0xa8, 0x5e,
	0x72, 0x2e, 0x1b, 0x27, 0x7d, 0x8d, 0x0c, 0xa8, 0xc7, 0x90, 0x95, 0xf6, 0x41, 0x6e, 0xda, 0x39,
	0xc8, 0x18, 0xfa, 0xe3, 0x6a, 0xab, 0xad, 0x1b, 0x61, 0xe3, 0x5e, 0x86, 0x94, 0xa1, 0x1f, 0xea,
	0x7b, 0x6d, 0xde, 0xba, 0x85, 0x9e, 0x9e, 0x64, 0xa1, 0xf2, 0xfe, 0x51, 0xb5, 0xcd, 0x42, 0xf3,
	0xea, 0x30, 0x01, 0x2b, 0x72, 0x11, 0xa3, 0x13, 0xc9, 0x27, 0xc3, 0xab, 0xee, 0xe6, 0x54, 0xc5,
	0xff, 0x4f, 0x5e, 0xc9, 0x2c, 0xbd, 0x45, 0x3c, 0x13, 0xf7, 0xeb, 0x81, 0x35, 0x69, 0xe9, 0x3e,
	0x0f, 0x68, 0xb6, 0x74, 0x44, 0x9a, 0x89, 0xa2, 0xaf, 0x60, 0xb5, 0xe9, 0x99, 0x16, 0xf6, 0xce,
	0x85, 0xee, 0x15, 0xca, 0x75, 0x2f, 0xa2, 0xbb, 0xeb, 0x86, 0x03, 0xb4, 0xd9, 0x5d, 0xec, 0xf5,
	0x61, 0x54, 0x93, 0x25, 0xbc, 0x25, 0x4b, 0x18, 0x9a, 0xde, 0xc6, 0x28, 0x25, 0xdf, 0x20, 0xe2,
	0xcf, 0x3e, 0x82, 0xdc, 0x84, 0x9f, 0xc8, 0x32, 0xa6, 0x60, 0xbe, 0x6d, 0x3c, 0xd1, 0xf3, 0x0a,
	0x4a, 0xc3, 0xc2, 0xa3, 0x72, 0xad, 0xa5, 0xe7, 0x13, 0x95, 0xe5, 0x17, 0xaf, 0xb6, 0x95, 0x6f,
	0x5f, 0x6d, 0x2b, 0xff, 0x7a, 0xb5, 0xad, 0x34, 0x95, 0x93, 0x45, 0xfe, 0x37, 0xfc, 0x47, 0xff,
	0x0d, 0x00, 0x00, 0xff, 0xff, 0xd0, 0x19, 0x86, 0x22, 0x57, 0x18, 0x00, 0x00,
}
