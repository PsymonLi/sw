// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: cmd.proto

/*
	Package cluster is a generated protocol buffer package.

	Service name

	It is generated from these files:
		cmd.proto
		svc_cluster.proto
		tenant.proto

	It has these top-level messages:
		Cluster
		ClusterSpec
		ClusterStatus
		Host
		HostIntfSpec
		HostIntfStatus
		HostSpec
		HostStatus
		Node
		NodeCondition
		NodeSpec
		NodeStatus
		PortCondition
		PortSpec
		PortStatus
		SmartNIC
		SmartNICCondition
		SmartNICSpec
		SmartNICStatus
		AutoMsgClusterWatchHelper
		AutoMsgHostWatchHelper
		AutoMsgNodeWatchHelper
		AutoMsgSmartNICWatchHelper
		AutoMsgTenantWatchHelper
		ClusterList
		HostList
		NodeList
		SmartNICList
		TenantList
		Tenant
		TenantSpec
		TenantStatus
*/
package cluster

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/pensando/grpc-gateway/third_party/googleapis/google/api"
import _ "github.com/pensando/sw/venice/utils/apigen/annotations"
import _ "github.com/gogo/protobuf/gogoproto"
import api "github.com/pensando/sw/api"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// These are valid condition statuses.
type ConditionStatus int32

const (
	ConditionStatus_UNKNOWN ConditionStatus = 0
	ConditionStatus_TRUE    ConditionStatus = 1
	ConditionStatus_FALSE   ConditionStatus = 2
)

var ConditionStatus_name = map[int32]string{
	0: "UNKNOWN",
	1: "TRUE",
	2: "FALSE",
}
var ConditionStatus_value = map[string]int32{
	"UNKNOWN": 0,
	"TRUE":    1,
	"FALSE":   2,
}

func (x ConditionStatus) String() string {
	return proto.EnumName(ConditionStatus_name, int32(x))
}
func (ConditionStatus) EnumDescriptor() ([]byte, []int) { return fileDescriptorCmd, []int{0} }

type HostStatus_HostType int32

const (
	HostStatus_UNKNOWN    HostStatus_HostType = 0
	HostStatus_BAREMETAL  HostStatus_HostType = 1
	HostStatus_HYPERVISOR HostStatus_HostType = 2
)

var HostStatus_HostType_name = map[int32]string{
	0: "UNKNOWN",
	1: "BAREMETAL",
	2: "HYPERVISOR",
}
var HostStatus_HostType_value = map[string]int32{
	"UNKNOWN":    0,
	"BAREMETAL":  1,
	"HYPERVISOR": 2,
}

func (x HostStatus_HostType) String() string {
	return proto.EnumName(HostStatus_HostType_name, int32(x))
}
func (HostStatus_HostType) EnumDescriptor() ([]byte, []int) { return fileDescriptorCmd, []int{7, 0} }

// Type of Host
type NodeCondition_ConditionType int32

const (
	NodeCondition_LEADER NodeCondition_ConditionType = 0
)

var NodeCondition_ConditionType_name = map[int32]string{
	0: "LEADER",
}
var NodeCondition_ConditionType_value = map[string]int32{
	"LEADER": 0,
}

func (x NodeCondition_ConditionType) String() string {
	return proto.EnumName(NodeCondition_ConditionType_name, int32(x))
}
func (NodeCondition_ConditionType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorCmd, []int{9, 0}
}

type NodeSpec_NodeRole int32

const (
	NodeSpec_CONTROLLER NodeSpec_NodeRole = 0
	NodeSpec_QUORUM     NodeSpec_NodeRole = 1
)

var NodeSpec_NodeRole_name = map[int32]string{
	0: "CONTROLLER",
	1: "QUORUM",
}
var NodeSpec_NodeRole_value = map[string]int32{
	"CONTROLLER": 0,
	"QUORUM":     1,
}

func (x NodeSpec_NodeRole) String() string {
	return proto.EnumName(NodeSpec_NodeRole_name, int32(x))
}
func (NodeSpec_NodeRole) EnumDescriptor() ([]byte, []int) { return fileDescriptorCmd, []int{10, 0} }

type NodeStatus_NodePhase int32

const (
	NodeStatus_UNKNOWN NodeStatus_NodePhase = 0
	NodeStatus_PENDING NodeStatus_NodePhase = 1
	NodeStatus_JOINED  NodeStatus_NodePhase = 2
	NodeStatus_FAILED  NodeStatus_NodePhase = 3
)

var NodeStatus_NodePhase_name = map[int32]string{
	0: "UNKNOWN",
	1: "PENDING",
	2: "JOINED",
	3: "FAILED",
}
var NodeStatus_NodePhase_value = map[string]int32{
	"UNKNOWN": 0,
	"PENDING": 1,
	"JOINED":  2,
	"FAILED":  3,
}

func (x NodeStatus_NodePhase) String() string {
	return proto.EnumName(NodeStatus_NodePhase_name, int32(x))
}
func (NodeStatus_NodePhase) EnumDescriptor() ([]byte, []int) { return fileDescriptorCmd, []int{11, 0} }

type PortCondition_ConditionType int32

const (
	PortCondition_PORT_UP PortCondition_ConditionType = 0
)

var PortCondition_ConditionType_name = map[int32]string{
	0: "PORT_UP",
}
var PortCondition_ConditionType_value = map[string]int32{
	"PORT_UP": 0,
}

func (x PortCondition_ConditionType) String() string {
	return proto.EnumName(PortCondition_ConditionType_name, int32(x))
}
func (PortCondition_ConditionType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorCmd, []int{12, 0}
}

type SmartNICCondition_ConditionType int32

const (
	SmartNICCondition_HEALTHY     SmartNICCondition_ConditionType = 0
	SmartNICCondition_UNREACHABLE SmartNICCondition_ConditionType = 1
)

var SmartNICCondition_ConditionType_name = map[int32]string{
	0: "HEALTHY",
	1: "UNREACHABLE",
}
var SmartNICCondition_ConditionType_value = map[string]int32{
	"HEALTHY":     0,
	"UNREACHABLE": 1,
}

func (x SmartNICCondition_ConditionType) String() string {
	return proto.EnumName(SmartNICCondition_ConditionType_name, int32(x))
}
func (SmartNICCondition_ConditionType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorCmd, []int{16, 0}
}

type SmartNICSpec_SmartNICPhase int32

const (
	SmartNICSpec_UNKNOWN     SmartNICSpec_SmartNICPhase = 0
	SmartNICSpec_REGISTERING SmartNICSpec_SmartNICPhase = 1
	SmartNICSpec_REJECTED    SmartNICSpec_SmartNICPhase = 2
	SmartNICSpec_PENDING     SmartNICSpec_SmartNICPhase = 3
	SmartNICSpec_ADMITTED    SmartNICSpec_SmartNICPhase = 4
)

var SmartNICSpec_SmartNICPhase_name = map[int32]string{
	0: "UNKNOWN",
	1: "REGISTERING",
	2: "REJECTED",
	3: "PENDING",
	4: "ADMITTED",
}
var SmartNICSpec_SmartNICPhase_value = map[string]int32{
	"UNKNOWN":     0,
	"REGISTERING": 1,
	"REJECTED":    2,
	"PENDING":     3,
	"ADMITTED":    4,
}

func (x SmartNICSpec_SmartNICPhase) String() string {
	return proto.EnumName(SmartNICSpec_SmartNICPhase_name, int32(x))
}
func (SmartNICSpec_SmartNICPhase) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorCmd, []int{17, 0}
}

// --------------------------------- CLUSTER ---------------------------------------------
//
// Cluster represents a full cluster venice and workload nodes
//
// Entity responsible & scenarios involved in managing this object:
//
//      Create:
//          o NetOps-admin
//              - initial cluster creation
//      Modify:
//          o NetOps-admin
//              - update spec attributes
//          o CMD
//              - update status attributes
//      Delete:
//          o NetOps-admin
//              - TBD
//
type Cluster struct {
	api.TypeMeta   `protobuf:"bytes,1,opt,name=T,embedded=T" json:",inline"`
	api.ObjectMeta `protobuf:"bytes,2,opt,name=O,embedded=O" json:"meta,omitempty"`
	// Spec contains the configuration of the cluster.
	Spec ClusterSpec `protobuf:"bytes,3,opt,name=Spec" json:"spec,omitempty"`
	// Status contains the current state of the cluster.
	Status ClusterStatus `protobuf:"bytes,4,opt,name=Status" json:"status,omitempty"`
}

func (m *Cluster) Reset()                    { *m = Cluster{} }
func (m *Cluster) String() string            { return proto.CompactTextString(m) }
func (*Cluster) ProtoMessage()               {}
func (*Cluster) Descriptor() ([]byte, []int) { return fileDescriptorCmd, []int{0} }

func (m *Cluster) GetSpec() ClusterSpec {
	if m != nil {
		return m.Spec
	}
	return ClusterSpec{}
}

func (m *Cluster) GetStatus() ClusterStatus {
	if m != nil {
		return m.Status
	}
	return ClusterStatus{}
}

// ClusterSpec contains the configuration of the cluster.
type ClusterSpec struct {
	// QuorumNodes contains the list of hostnames for nodes configured to be quorum
	// nodes in the cluster.
	QuorumNodes []string `protobuf:"bytes,1,rep,name=QuorumNodes" json:"quorum-nodes,omitempty"`
	// VirtualIP is the IP address for managing the cluster. It will be hosted by
	// the winner of election between quorum nodes.
	VirtualIP string `protobuf:"bytes,2,opt,name=VirtualIP,proto3" json:"virtual-ip,omitempty"`
	// NTPServers contains the list of NTP servers for the cluster.
	NTPServers []string `protobuf:"bytes,3,rep,name=NTPServers" json:"ntp-servers,omitempty"`
	// DNSSubDomain is the DNS subdomain for the default tenant.
	DNSSubDomain string `protobuf:"bytes,4,opt,name=DNSSubDomain,proto3" json:"dns-subdomain,omitempty"`
	// AutoAdmitNICs when enabled auto-admits NICs that are validated
	// into Venice Cluster. When it is disabled, NICs validated by CMD are
	// set to Pending state and it requires Manual approval to be admitted
	// into the cluster.
	AutoAdmitNICs bool `protobuf:"varint,5,opt,name=AutoAdmitNICs,proto3" json:"auto-admit-nics,omitempty"`
}

func (m *ClusterSpec) Reset()                    { *m = ClusterSpec{} }
func (m *ClusterSpec) String() string            { return proto.CompactTextString(m) }
func (*ClusterSpec) ProtoMessage()               {}
func (*ClusterSpec) Descriptor() ([]byte, []int) { return fileDescriptorCmd, []int{1} }

func (m *ClusterSpec) GetQuorumNodes() []string {
	if m != nil {
		return m.QuorumNodes
	}
	return nil
}

func (m *ClusterSpec) GetVirtualIP() string {
	if m != nil {
		return m.VirtualIP
	}
	return ""
}

func (m *ClusterSpec) GetNTPServers() []string {
	if m != nil {
		return m.NTPServers
	}
	return nil
}

func (m *ClusterSpec) GetDNSSubDomain() string {
	if m != nil {
		return m.DNSSubDomain
	}
	return ""
}

func (m *ClusterSpec) GetAutoAdmitNICs() bool {
	if m != nil {
		return m.AutoAdmitNICs
	}
	return false
}

// ClusterStatus contains the current state of the Cluster.
type ClusterStatus struct {
	// Leader contains the node name of the cluster leader.
	Leader string `protobuf:"bytes,1,opt,name=Leader,proto3" json:"leader,omitempty"`
	// LastLeaderTransitionTime is when the leadership changed last time
	LastLeaderTransitionTime *api.Timestamp `protobuf:"bytes,2,opt,name=LastLeaderTransitionTime" json:"last-leader-transition-time,omitempty"`
}

func (m *ClusterStatus) Reset()                    { *m = ClusterStatus{} }
func (m *ClusterStatus) String() string            { return proto.CompactTextString(m) }
func (*ClusterStatus) ProtoMessage()               {}
func (*ClusterStatus) Descriptor() ([]byte, []int) { return fileDescriptorCmd, []int{2} }

func (m *ClusterStatus) GetLeader() string {
	if m != nil {
		return m.Leader
	}
	return ""
}

func (m *ClusterStatus) GetLastLeaderTransitionTime() *api.Timestamp {
	if m != nil {
		return m.LastLeaderTransitionTime
	}
	return nil
}

// ---------------------------------- NODE -------------------------------------------
//
// Node is representation of a single Venice node in the system.
//
type Host struct {
	api.TypeMeta   `protobuf:"bytes,1,opt,name=T,embedded=T" json:",inline"`
	api.ObjectMeta `protobuf:"bytes,2,opt,name=O,embedded=O" json:"meta,omitempty"`
	// Spec contains the configuration of the node.
	Spec HostSpec `protobuf:"bytes,3,opt,name=Spec" json:"spec,omitempty"`
	// Status contains the current state of the node.
	Status HostStatus `protobuf:"bytes,4,opt,name=Status" json:"status,omitempty"`
}

func (m *Host) Reset()                    { *m = Host{} }
func (m *Host) String() string            { return proto.CompactTextString(m) }
func (*Host) ProtoMessage()               {}
func (*Host) Descriptor() ([]byte, []int) { return fileDescriptorCmd, []int{3} }

func (m *Host) GetSpec() HostSpec {
	if m != nil {
		return m.Spec
	}
	return HostSpec{}
}

func (m *Host) GetStatus() HostStatus {
	if m != nil {
		return m.Status
	}
	return HostStatus{}
}

// NodeSpec contains the configuration of the node.
type HostIntfSpec struct {
	// Roles is of list of roles a node can be configured with.
	MacAddrs []string `protobuf:"bytes,1,rep,name=MacAddrs" json:"mac-addrs,omitempty"`
}

func (m *HostIntfSpec) Reset()                    { *m = HostIntfSpec{} }
func (m *HostIntfSpec) String() string            { return proto.CompactTextString(m) }
func (*HostIntfSpec) ProtoMessage()               {}
func (*HostIntfSpec) Descriptor() ([]byte, []int) { return fileDescriptorCmd, []int{4} }

func (m *HostIntfSpec) GetMacAddrs() []string {
	if m != nil {
		return m.MacAddrs
	}
	return nil
}

// NodeStatus contains the current state of the node.
type HostIntfStatus struct {
	// Current lifecycle phase of the node.
	IpAddrs []string `protobuf:"bytes,1,rep,name=IpAddrs" json:"ip-addrs,omitempty"`
}

func (m *HostIntfStatus) Reset()                    { *m = HostIntfStatus{} }
func (m *HostIntfStatus) String() string            { return proto.CompactTextString(m) }
func (*HostIntfStatus) ProtoMessage()               {}
func (*HostIntfStatus) Descriptor() ([]byte, []int) { return fileDescriptorCmd, []int{5} }

func (m *HostIntfStatus) GetIpAddrs() []string {
	if m != nil {
		return m.IpAddrs
	}
	return nil
}

// NodeCondition describes the state of a Node at a certain point.
type HostSpec struct {
	// Type indicates a certain node condition
	Interfaces map[string]HostIntfSpec `protobuf:"bytes,1,rep,name=Interfaces" json:"interfaces,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *HostSpec) Reset()                    { *m = HostSpec{} }
func (m *HostSpec) String() string            { return proto.CompactTextString(m) }
func (*HostSpec) ProtoMessage()               {}
func (*HostSpec) Descriptor() ([]byte, []int) { return fileDescriptorCmd, []int{6} }

func (m *HostSpec) GetInterfaces() map[string]HostIntfSpec {
	if m != nil {
		return m.Interfaces
	}
	return nil
}

// ---------------------------------- HOST ------------------------------------
//
// Host represents a Baremetal or Hypervisor server.
//
type HostStatus struct {
	Type            string `protobuf:"bytes,1,opt,name=Type,proto3" json:"type,omitempty"`
	OperatingSystem string `protobuf:"bytes,2,opt,name=OperatingSystem,proto3" json:"operating-system,omitempty"`
	// Spec contains the configuration of the host.
	Orchestrator string `protobuf:"bytes,3,opt,name=Orchestrator,proto3" json:"orchestrator,omitempty"`
	// Status contains the current state of the host.
	Interfaces map[string]HostIntfStatus `protobuf:"bytes,4,rep,name=Interfaces" json:"interfaces,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *HostStatus) Reset()                    { *m = HostStatus{} }
func (m *HostStatus) String() string            { return proto.CompactTextString(m) }
func (*HostStatus) ProtoMessage()               {}
func (*HostStatus) Descriptor() ([]byte, []int) { return fileDescriptorCmd, []int{7} }

func (m *HostStatus) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *HostStatus) GetOperatingSystem() string {
	if m != nil {
		return m.OperatingSystem
	}
	return ""
}

func (m *HostStatus) GetOrchestrator() string {
	if m != nil {
		return m.Orchestrator
	}
	return ""
}

func (m *HostStatus) GetInterfaces() map[string]HostIntfStatus {
	if m != nil {
		return m.Interfaces
	}
	return nil
}

// HostSpec contains the configuration of the Host.
type Node struct {
	// Spec of all interfaces in the Host identified by Primary MAC
	api.TypeMeta   `protobuf:"bytes,1,opt,name=T,embedded=T" json:",inline"`
	api.ObjectMeta `protobuf:"bytes,2,opt,name=O,embedded=O" json:"meta,omitempty"`
	Spec           NodeSpec   `protobuf:"bytes,3,opt,name=Spec" json:"spec,omitempty"`
	Status         NodeStatus `protobuf:"bytes,4,opt,name=Status" json:"status,omitempty"`
}

func (m *Node) Reset()                    { *m = Node{} }
func (m *Node) String() string            { return proto.CompactTextString(m) }
func (*Node) ProtoMessage()               {}
func (*Node) Descriptor() ([]byte, []int) { return fileDescriptorCmd, []int{8} }

func (m *Node) GetSpec() NodeSpec {
	if m != nil {
		return m.Spec
	}
	return NodeSpec{}
}

func (m *Node) GetStatus() NodeStatus {
	if m != nil {
		return m.Status
	}
	return NodeStatus{}
}

// HostStatus contains the current state of the Host.
type NodeCondition struct {
	// Type of the host
	Type string `protobuf:"bytes,1,opt,name=Type,proto3" json:"type,omitempty"`
	// Operating system info - name of OS with version, eg: "Linux 3.10.0.xyz"
	Status string `protobuf:"bytes,2,opt,name=Status,proto3" json:"status,omitempty"`
	// Orchestrator is the name of associated Compute controller
	// (like VCenter) managing this host.
	LastTransitionTime string `protobuf:"bytes,3,opt,name=LastTransitionTime,proto3" json:"last-transition-time,omitempty"`
	// Status of all interfaces in the Host identified by Primary MAC
	Reason  string `protobuf:"bytes,4,opt,name=Reason,proto3" json:"reason,omitempty"`
	Message string `protobuf:"bytes,5,opt,name=Message,proto3" json:"message,omitempty"`
}

func (m *NodeCondition) Reset()                    { *m = NodeCondition{} }
func (m *NodeCondition) String() string            { return proto.CompactTextString(m) }
func (*NodeCondition) ProtoMessage()               {}
func (*NodeCondition) Descriptor() ([]byte, []int) { return fileDescriptorCmd, []int{9} }

func (m *NodeCondition) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *NodeCondition) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *NodeCondition) GetLastTransitionTime() string {
	if m != nil {
		return m.LastTransitionTime
	}
	return ""
}

func (m *NodeCondition) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

func (m *NodeCondition) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

// Spec of a Host interface
type NodeSpec struct {
	// List of all MAC addresses configured and discovered on a Host Interface
	Roles []string `protobuf:"bytes,1,rep,name=Roles" json:"roles,omitempty"`
}

func (m *NodeSpec) Reset()                    { *m = NodeSpec{} }
func (m *NodeSpec) String() string            { return proto.CompactTextString(m) }
func (*NodeSpec) ProtoMessage()               {}
func (*NodeSpec) Descriptor() ([]byte, []int) { return fileDescriptorCmd, []int{10} }

func (m *NodeSpec) GetRoles() []string {
	if m != nil {
		return m.Roles
	}
	return nil
}

// Status of a Host interface
type NodeStatus struct {
	// List of all IP addresses configured on a Host Interface
	Phase      string           `protobuf:"bytes,1,opt,name=Phase,proto3" json:"phase,omitempty"`
	Conditions []*NodeCondition `protobuf:"bytes,2,rep,name=Conditions" json:"conditions,omitempty"`
}

func (m *NodeStatus) Reset()                    { *m = NodeStatus{} }
func (m *NodeStatus) String() string            { return proto.CompactTextString(m) }
func (*NodeStatus) ProtoMessage()               {}
func (*NodeStatus) Descriptor() ([]byte, []int) { return fileDescriptorCmd, []int{11} }

func (m *NodeStatus) GetPhase() string {
	if m != nil {
		return m.Phase
	}
	return ""
}

func (m *NodeStatus) GetConditions() []*NodeCondition {
	if m != nil {
		return m.Conditions
	}
	return nil
}

// ------------------------------------ SMART NIC  -------------------------------------------
//
// SmartNIC represents the Naples I/O subsystem
//
// Entity responsible & scenarios involved in managing this object:
//
//      Create:
//          o CMD
//              - created as part of NIC registration, Admittance
//      Modify:
//          o CMD
//              - update spec attributes
//              - update status attributes
//      Delete:
//          o CMD
//              - aging out stale or rejected NICs (TBD)
//          o NetOps, SecOps
//              - Decomission a NIC (TBD)
//
type PortCondition struct {
	Type string `protobuf:"bytes,1,opt,name=Type,proto3" json:"type,omitempty"`
	// Object name is Serial-Number of the SmartNIC
	Status string `protobuf:"bytes,2,opt,name=Status,proto3" json:"status,omitempty"`
	// SmartNICSpec contains the configuration of the network adapter.
	LastTransitionTime string `protobuf:"bytes,3,opt,name=LastTransitionTime,proto3" json:"last-transition-time,omitempty"`
	// SmartNICStatus contains the current state of the network adapter.
	Reason  string `protobuf:"bytes,4,opt,name=Reason,proto3" json:"reason,omitempty"`
	Message string `protobuf:"bytes,5,opt,name=Message,proto3" json:"message,omitempty"`
}

func (m *PortCondition) Reset()                    { *m = PortCondition{} }
func (m *PortCondition) String() string            { return proto.CompactTextString(m) }
func (*PortCondition) ProtoMessage()               {}
func (*PortCondition) Descriptor() ([]byte, []int) { return fileDescriptorCmd, []int{12} }

func (m *PortCondition) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *PortCondition) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *PortCondition) GetLastTransitionTime() string {
	if m != nil {
		return m.LastTransitionTime
	}
	return ""
}

func (m *PortCondition) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

func (m *PortCondition) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

// SmartNICSpec contains configuration of the SmartNIC (Naples I/O subsystem)
type PortSpec struct {
	// Current phase of the SmartNIC.
	// When auto-admission is enabled, Phase will be set to NIC_ADMITTED
	// by CMD for validated NICs.
	// When auto-admission is not enabled, Phase will be set to NIC_PENDING
	// by CMD for validated NICs since it requires manual approval.
	// To admit the NIC as a part of manual admission, user is expected to
	// set the Phase to NIC_ADMITTED for the NICs that are in NIC_PENDING
	// state. Note : Whitelist mode is not supported yet.
	MacAddress string `protobuf:"bytes,1,opt,name=MacAddress,proto3" json:"mac-address,omitempty"`
}

func (m *PortSpec) Reset()                    { *m = PortSpec{} }
func (m *PortSpec) String() string            { return proto.CompactTextString(m) }
func (*PortSpec) ProtoMessage()               {}
func (*PortSpec) Descriptor() ([]byte, []int) { return fileDescriptorCmd, []int{13} }

func (m *PortSpec) GetMacAddress() string {
	if m != nil {
		return m.MacAddress
	}
	return ""
}

// SmartNICStatus contains current status of a SmartNIC
type PortStatus struct {
	// List of current NIC conditions
	MacAddrs []string `protobuf:"bytes,1,rep,name=MacAddrs" json:"mac-addrs,omitempty"`
	// Serial number
	LinkSpeed string `protobuf:"bytes,2,opt,name=LinkSpeed,proto3" json:"link-speed,omitempty"`
	// Primary MAC address, which is MAC address of the primary PF exposed by SmartNIC
	Conditions []*PortCondition `protobuf:"bytes,3,rep,name=Conditions" json:"conditions,omitempty"`
}

func (m *PortStatus) Reset()                    { *m = PortStatus{} }
func (m *PortStatus) String() string            { return proto.CompactTextString(m) }
func (*PortStatus) ProtoMessage()               {}
func (*PortStatus) Descriptor() ([]byte, []int) { return fileDescriptorCmd, []int{14} }

func (m *PortStatus) GetMacAddrs() []string {
	if m != nil {
		return m.MacAddrs
	}
	return nil
}

func (m *PortStatus) GetLinkSpeed() string {
	if m != nil {
		return m.LinkSpeed
	}
	return ""
}

func (m *PortStatus) GetConditions() []*PortCondition {
	if m != nil {
		return m.Conditions
	}
	return nil
}

// SmartNICCondition describes the state of a SmartNIC at a certain point.
type SmartNIC struct {
	// Type indicates a certain NIC condition
	api.TypeMeta `protobuf:"bytes,1,opt,name=T,embedded=T" json:",inline"`
	// Condition Status
	api.ObjectMeta `protobuf:"bytes,2,opt,name=O,embedded=O" json:"meta,omitempty"`
	// The last time the condition transitioned
	Spec SmartNICSpec `protobuf:"bytes,3,opt,name=Spec" json:"spec,omitempty"`
	// The reason for the condition's last transition
	Status SmartNICStatus `protobuf:"bytes,4,opt,name=Status" json:"status,omitempty"`
}

func (m *SmartNIC) Reset()                    { *m = SmartNIC{} }
func (m *SmartNIC) String() string            { return proto.CompactTextString(m) }
func (*SmartNIC) ProtoMessage()               {}
func (*SmartNIC) Descriptor() ([]byte, []int) { return fileDescriptorCmd, []int{15} }

func (m *SmartNIC) GetSpec() SmartNICSpec {
	if m != nil {
		return m.Spec
	}
	return SmartNICSpec{}
}

func (m *SmartNIC) GetStatus() SmartNICStatus {
	if m != nil {
		return m.Status
	}
	return SmartNICStatus{}
}

// PortSpec contains configuration of a port in SmartNIC
type SmartNICCondition struct {
	// Primary Mac address of the Port, which is key identifier of the port
	Type               string `protobuf:"bytes,1,opt,name=Type,proto3" json:"type,omitempty"`
	Status             string `protobuf:"bytes,2,opt,name=Status,proto3" json:"status,omitempty"`
	LastTransitionTime string `protobuf:"bytes,3,opt,name=LastTransitionTime,proto3" json:"last-transition-time,omitempty"`
	Reason             string `protobuf:"bytes,4,opt,name=Reason,proto3" json:"reason,omitempty"`
	Message            string `protobuf:"bytes,5,opt,name=Message,proto3" json:"message,omitempty"`
}

func (m *SmartNICCondition) Reset()                    { *m = SmartNICCondition{} }
func (m *SmartNICCondition) String() string            { return proto.CompactTextString(m) }
func (*SmartNICCondition) ProtoMessage()               {}
func (*SmartNICCondition) Descriptor() ([]byte, []int) { return fileDescriptorCmd, []int{16} }

func (m *SmartNICCondition) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *SmartNICCondition) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *SmartNICCondition) GetLastTransitionTime() string {
	if m != nil {
		return m.LastTransitionTime
	}
	return ""
}

func (m *SmartNICCondition) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

func (m *SmartNICCondition) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

// PortStatus contains current status of a Port
type SmartNICSpec struct {
	// List of all Mac addresses of the Port
	Phase string `protobuf:"bytes,1,opt,name=Phase,proto3" json:"phase,omitempty"`
	// LinkSpeed of the Port
	MgmtIp string `protobuf:"bytes,2,opt,name=MgmtIp,proto3" json:"mgmt-ip,omitempty"`
	// List of current Port conditions
	HostName string     `protobuf:"bytes,3,opt,name=HostName,proto3" json:"host-name,omitempty"`
	Ports    []PortSpec `protobuf:"bytes,4,rep,name=Ports" json:"ports,omitempty"`
}

func (m *SmartNICSpec) Reset()                    { *m = SmartNICSpec{} }
func (m *SmartNICSpec) String() string            { return proto.CompactTextString(m) }
func (*SmartNICSpec) ProtoMessage()               {}
func (*SmartNICSpec) Descriptor() ([]byte, []int) { return fileDescriptorCmd, []int{17} }

func (m *SmartNICSpec) GetPhase() string {
	if m != nil {
		return m.Phase
	}
	return ""
}

func (m *SmartNICSpec) GetMgmtIp() string {
	if m != nil {
		return m.MgmtIp
	}
	return ""
}

func (m *SmartNICSpec) GetHostName() string {
	if m != nil {
		return m.HostName
	}
	return ""
}

func (m *SmartNICSpec) GetPorts() []PortSpec {
	if m != nil {
		return m.Ports
	}
	return nil
}

// PortCondition describes the state of a Port at a certain point.
type SmartNICStatus struct {
	// Type indicates a certain Port condition
	Conditions []*SmartNICCondition `protobuf:"bytes,1,rep,name=Conditions" json:"conditions,omitempty"`
	// Condition Status
	SerialNum string `protobuf:"bytes,2,opt,name=SerialNum,proto3" json:"serial-num,omitempty"`
	// The last time the condition transitioned
	PrimaryMacAddress string `protobuf:"bytes,3,opt,name=PrimaryMacAddress,proto3" json:"primary-mac-address,omitempty"`
	// The reason for the condition's last transition
	Ports []*PortStatus `protobuf:"bytes,4,rep,name=Ports" json:"ports,omitempty"`
}

func (m *SmartNICStatus) Reset()                    { *m = SmartNICStatus{} }
func (m *SmartNICStatus) String() string            { return proto.CompactTextString(m) }
func (*SmartNICStatus) ProtoMessage()               {}
func (*SmartNICStatus) Descriptor() ([]byte, []int) { return fileDescriptorCmd, []int{18} }

func (m *SmartNICStatus) GetConditions() []*SmartNICCondition {
	if m != nil {
		return m.Conditions
	}
	return nil
}

func (m *SmartNICStatus) GetSerialNum() string {
	if m != nil {
		return m.SerialNum
	}
	return ""
}

func (m *SmartNICStatus) GetPrimaryMacAddress() string {
	if m != nil {
		return m.PrimaryMacAddress
	}
	return ""
}

func (m *SmartNICStatus) GetPorts() []*PortStatus {
	if m != nil {
		return m.Ports
	}
	return nil
}

func init() {
	proto.RegisterType((*Cluster)(nil), "cluster.Cluster")
	proto.RegisterType((*ClusterSpec)(nil), "cluster.ClusterSpec")
	proto.RegisterType((*ClusterStatus)(nil), "cluster.ClusterStatus")
	proto.RegisterType((*Host)(nil), "cluster.Host")
	proto.RegisterType((*HostIntfSpec)(nil), "cluster.HostIntfSpec")
	proto.RegisterType((*HostIntfStatus)(nil), "cluster.HostIntfStatus")
	proto.RegisterType((*HostSpec)(nil), "cluster.HostSpec")
	proto.RegisterType((*HostStatus)(nil), "cluster.HostStatus")
	proto.RegisterType((*Node)(nil), "cluster.Node")
	proto.RegisterType((*NodeCondition)(nil), "cluster.NodeCondition")
	proto.RegisterType((*NodeSpec)(nil), "cluster.NodeSpec")
	proto.RegisterType((*NodeStatus)(nil), "cluster.NodeStatus")
	proto.RegisterType((*PortCondition)(nil), "cluster.PortCondition")
	proto.RegisterType((*PortSpec)(nil), "cluster.PortSpec")
	proto.RegisterType((*PortStatus)(nil), "cluster.PortStatus")
	proto.RegisterType((*SmartNIC)(nil), "cluster.SmartNIC")
	proto.RegisterType((*SmartNICCondition)(nil), "cluster.SmartNICCondition")
	proto.RegisterType((*SmartNICSpec)(nil), "cluster.SmartNICSpec")
	proto.RegisterType((*SmartNICStatus)(nil), "cluster.SmartNICStatus")
	proto.RegisterEnum("cluster.ConditionStatus", ConditionStatus_name, ConditionStatus_value)
	proto.RegisterEnum("cluster.HostStatus_HostType", HostStatus_HostType_name, HostStatus_HostType_value)
	proto.RegisterEnum("cluster.NodeCondition_ConditionType", NodeCondition_ConditionType_name, NodeCondition_ConditionType_value)
	proto.RegisterEnum("cluster.NodeSpec_NodeRole", NodeSpec_NodeRole_name, NodeSpec_NodeRole_value)
	proto.RegisterEnum("cluster.NodeStatus_NodePhase", NodeStatus_NodePhase_name, NodeStatus_NodePhase_value)
	proto.RegisterEnum("cluster.PortCondition_ConditionType", PortCondition_ConditionType_name, PortCondition_ConditionType_value)
	proto.RegisterEnum("cluster.SmartNICCondition_ConditionType", SmartNICCondition_ConditionType_name, SmartNICCondition_ConditionType_value)
	proto.RegisterEnum("cluster.SmartNICSpec_SmartNICPhase", SmartNICSpec_SmartNICPhase_name, SmartNICSpec_SmartNICPhase_value)
}
func (m *Cluster) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Cluster) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintCmd(dAtA, i, uint64(m.TypeMeta.Size()))
	n1, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n1
	dAtA[i] = 0x12
	i++
	i = encodeVarintCmd(dAtA, i, uint64(m.ObjectMeta.Size()))
	n2, err := m.ObjectMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n2
	dAtA[i] = 0x1a
	i++
	i = encodeVarintCmd(dAtA, i, uint64(m.Spec.Size()))
	n3, err := m.Spec.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n3
	dAtA[i] = 0x22
	i++
	i = encodeVarintCmd(dAtA, i, uint64(m.Status.Size()))
	n4, err := m.Status.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n4
	return i, nil
}

func (m *ClusterSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClusterSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.QuorumNodes) > 0 {
		for _, s := range m.QuorumNodes {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.VirtualIP) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCmd(dAtA, i, uint64(len(m.VirtualIP)))
		i += copy(dAtA[i:], m.VirtualIP)
	}
	if len(m.NTPServers) > 0 {
		for _, s := range m.NTPServers {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.DNSSubDomain) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCmd(dAtA, i, uint64(len(m.DNSSubDomain)))
		i += copy(dAtA[i:], m.DNSSubDomain)
	}
	if m.AutoAdmitNICs {
		dAtA[i] = 0x28
		i++
		if m.AutoAdmitNICs {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *ClusterStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClusterStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Leader) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCmd(dAtA, i, uint64(len(m.Leader)))
		i += copy(dAtA[i:], m.Leader)
	}
	if m.LastLeaderTransitionTime != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCmd(dAtA, i, uint64(m.LastLeaderTransitionTime.Size()))
		n5, err := m.LastLeaderTransitionTime.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	return i, nil
}

func (m *Host) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Host) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintCmd(dAtA, i, uint64(m.TypeMeta.Size()))
	n6, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n6
	dAtA[i] = 0x12
	i++
	i = encodeVarintCmd(dAtA, i, uint64(m.ObjectMeta.Size()))
	n7, err := m.ObjectMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n7
	dAtA[i] = 0x1a
	i++
	i = encodeVarintCmd(dAtA, i, uint64(m.Spec.Size()))
	n8, err := m.Spec.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n8
	dAtA[i] = 0x22
	i++
	i = encodeVarintCmd(dAtA, i, uint64(m.Status.Size()))
	n9, err := m.Status.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n9
	return i, nil
}

func (m *HostIntfSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HostIntfSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.MacAddrs) > 0 {
		for _, s := range m.MacAddrs {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *HostIntfStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HostIntfStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.IpAddrs) > 0 {
		for _, s := range m.IpAddrs {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *HostSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HostSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Interfaces) > 0 {
		for k, _ := range m.Interfaces {
			dAtA[i] = 0xa
			i++
			v := m.Interfaces[k]
			msgSize := 0
			if (&v) != nil {
				msgSize = (&v).Size()
				msgSize += 1 + sovCmd(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovCmd(uint64(len(k))) + msgSize
			i = encodeVarintCmd(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintCmd(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintCmd(dAtA, i, uint64((&v).Size()))
			n10, err := (&v).MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n10
		}
	}
	return i, nil
}

func (m *HostStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HostStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCmd(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.OperatingSystem) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCmd(dAtA, i, uint64(len(m.OperatingSystem)))
		i += copy(dAtA[i:], m.OperatingSystem)
	}
	if len(m.Orchestrator) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCmd(dAtA, i, uint64(len(m.Orchestrator)))
		i += copy(dAtA[i:], m.Orchestrator)
	}
	if len(m.Interfaces) > 0 {
		for k, _ := range m.Interfaces {
			dAtA[i] = 0x22
			i++
			v := m.Interfaces[k]
			msgSize := 0
			if (&v) != nil {
				msgSize = (&v).Size()
				msgSize += 1 + sovCmd(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovCmd(uint64(len(k))) + msgSize
			i = encodeVarintCmd(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintCmd(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintCmd(dAtA, i, uint64((&v).Size()))
			n11, err := (&v).MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n11
		}
	}
	return i, nil
}

func (m *Node) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Node) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintCmd(dAtA, i, uint64(m.TypeMeta.Size()))
	n12, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n12
	dAtA[i] = 0x12
	i++
	i = encodeVarintCmd(dAtA, i, uint64(m.ObjectMeta.Size()))
	n13, err := m.ObjectMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n13
	dAtA[i] = 0x1a
	i++
	i = encodeVarintCmd(dAtA, i, uint64(m.Spec.Size()))
	n14, err := m.Spec.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n14
	dAtA[i] = 0x22
	i++
	i = encodeVarintCmd(dAtA, i, uint64(m.Status.Size()))
	n15, err := m.Status.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n15
	return i, nil
}

func (m *NodeCondition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeCondition) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCmd(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.Status) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCmd(dAtA, i, uint64(len(m.Status)))
		i += copy(dAtA[i:], m.Status)
	}
	if len(m.LastTransitionTime) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCmd(dAtA, i, uint64(len(m.LastTransitionTime)))
		i += copy(dAtA[i:], m.LastTransitionTime)
	}
	if len(m.Reason) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCmd(dAtA, i, uint64(len(m.Reason)))
		i += copy(dAtA[i:], m.Reason)
	}
	if len(m.Message) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintCmd(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	return i, nil
}

func (m *NodeSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Roles) > 0 {
		for _, s := range m.Roles {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *NodeStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Phase) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCmd(dAtA, i, uint64(len(m.Phase)))
		i += copy(dAtA[i:], m.Phase)
	}
	if len(m.Conditions) > 0 {
		for _, msg := range m.Conditions {
			dAtA[i] = 0x12
			i++
			i = encodeVarintCmd(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *PortCondition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PortCondition) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCmd(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.Status) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCmd(dAtA, i, uint64(len(m.Status)))
		i += copy(dAtA[i:], m.Status)
	}
	if len(m.LastTransitionTime) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCmd(dAtA, i, uint64(len(m.LastTransitionTime)))
		i += copy(dAtA[i:], m.LastTransitionTime)
	}
	if len(m.Reason) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCmd(dAtA, i, uint64(len(m.Reason)))
		i += copy(dAtA[i:], m.Reason)
	}
	if len(m.Message) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintCmd(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	return i, nil
}

func (m *PortSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PortSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.MacAddress) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCmd(dAtA, i, uint64(len(m.MacAddress)))
		i += copy(dAtA[i:], m.MacAddress)
	}
	return i, nil
}

func (m *PortStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PortStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.MacAddrs) > 0 {
		for _, s := range m.MacAddrs {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.LinkSpeed) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCmd(dAtA, i, uint64(len(m.LinkSpeed)))
		i += copy(dAtA[i:], m.LinkSpeed)
	}
	if len(m.Conditions) > 0 {
		for _, msg := range m.Conditions {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintCmd(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SmartNIC) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SmartNIC) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintCmd(dAtA, i, uint64(m.TypeMeta.Size()))
	n16, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n16
	dAtA[i] = 0x12
	i++
	i = encodeVarintCmd(dAtA, i, uint64(m.ObjectMeta.Size()))
	n17, err := m.ObjectMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n17
	dAtA[i] = 0x1a
	i++
	i = encodeVarintCmd(dAtA, i, uint64(m.Spec.Size()))
	n18, err := m.Spec.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n18
	dAtA[i] = 0x22
	i++
	i = encodeVarintCmd(dAtA, i, uint64(m.Status.Size()))
	n19, err := m.Status.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n19
	return i, nil
}

func (m *SmartNICCondition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SmartNICCondition) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCmd(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.Status) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCmd(dAtA, i, uint64(len(m.Status)))
		i += copy(dAtA[i:], m.Status)
	}
	if len(m.LastTransitionTime) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCmd(dAtA, i, uint64(len(m.LastTransitionTime)))
		i += copy(dAtA[i:], m.LastTransitionTime)
	}
	if len(m.Reason) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCmd(dAtA, i, uint64(len(m.Reason)))
		i += copy(dAtA[i:], m.Reason)
	}
	if len(m.Message) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintCmd(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	return i, nil
}

func (m *SmartNICSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SmartNICSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Phase) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCmd(dAtA, i, uint64(len(m.Phase)))
		i += copy(dAtA[i:], m.Phase)
	}
	if len(m.MgmtIp) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCmd(dAtA, i, uint64(len(m.MgmtIp)))
		i += copy(dAtA[i:], m.MgmtIp)
	}
	if len(m.HostName) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCmd(dAtA, i, uint64(len(m.HostName)))
		i += copy(dAtA[i:], m.HostName)
	}
	if len(m.Ports) > 0 {
		for _, msg := range m.Ports {
			dAtA[i] = 0x22
			i++
			i = encodeVarintCmd(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SmartNICStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SmartNICStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Conditions) > 0 {
		for _, msg := range m.Conditions {
			dAtA[i] = 0xa
			i++
			i = encodeVarintCmd(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.SerialNum) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCmd(dAtA, i, uint64(len(m.SerialNum)))
		i += copy(dAtA[i:], m.SerialNum)
	}
	if len(m.PrimaryMacAddress) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCmd(dAtA, i, uint64(len(m.PrimaryMacAddress)))
		i += copy(dAtA[i:], m.PrimaryMacAddress)
	}
	if len(m.Ports) > 0 {
		for _, msg := range m.Ports {
			dAtA[i] = 0x22
			i++
			i = encodeVarintCmd(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func encodeVarintCmd(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Cluster) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovCmd(uint64(l))
	l = m.ObjectMeta.Size()
	n += 1 + l + sovCmd(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovCmd(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovCmd(uint64(l))
	return n
}

func (m *ClusterSpec) Size() (n int) {
	var l int
	_ = l
	if len(m.QuorumNodes) > 0 {
		for _, s := range m.QuorumNodes {
			l = len(s)
			n += 1 + l + sovCmd(uint64(l))
		}
	}
	l = len(m.VirtualIP)
	if l > 0 {
		n += 1 + l + sovCmd(uint64(l))
	}
	if len(m.NTPServers) > 0 {
		for _, s := range m.NTPServers {
			l = len(s)
			n += 1 + l + sovCmd(uint64(l))
		}
	}
	l = len(m.DNSSubDomain)
	if l > 0 {
		n += 1 + l + sovCmd(uint64(l))
	}
	if m.AutoAdmitNICs {
		n += 2
	}
	return n
}

func (m *ClusterStatus) Size() (n int) {
	var l int
	_ = l
	l = len(m.Leader)
	if l > 0 {
		n += 1 + l + sovCmd(uint64(l))
	}
	if m.LastLeaderTransitionTime != nil {
		l = m.LastLeaderTransitionTime.Size()
		n += 1 + l + sovCmd(uint64(l))
	}
	return n
}

func (m *Host) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovCmd(uint64(l))
	l = m.ObjectMeta.Size()
	n += 1 + l + sovCmd(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovCmd(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovCmd(uint64(l))
	return n
}

func (m *HostIntfSpec) Size() (n int) {
	var l int
	_ = l
	if len(m.MacAddrs) > 0 {
		for _, s := range m.MacAddrs {
			l = len(s)
			n += 1 + l + sovCmd(uint64(l))
		}
	}
	return n
}

func (m *HostIntfStatus) Size() (n int) {
	var l int
	_ = l
	if len(m.IpAddrs) > 0 {
		for _, s := range m.IpAddrs {
			l = len(s)
			n += 1 + l + sovCmd(uint64(l))
		}
	}
	return n
}

func (m *HostSpec) Size() (n int) {
	var l int
	_ = l
	if len(m.Interfaces) > 0 {
		for k, v := range m.Interfaces {
			_ = k
			_ = v
			l = v.Size()
			mapEntrySize := 1 + len(k) + sovCmd(uint64(len(k))) + 1 + l + sovCmd(uint64(l))
			n += mapEntrySize + 1 + sovCmd(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *HostStatus) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovCmd(uint64(l))
	}
	l = len(m.OperatingSystem)
	if l > 0 {
		n += 1 + l + sovCmd(uint64(l))
	}
	l = len(m.Orchestrator)
	if l > 0 {
		n += 1 + l + sovCmd(uint64(l))
	}
	if len(m.Interfaces) > 0 {
		for k, v := range m.Interfaces {
			_ = k
			_ = v
			l = v.Size()
			mapEntrySize := 1 + len(k) + sovCmd(uint64(len(k))) + 1 + l + sovCmd(uint64(l))
			n += mapEntrySize + 1 + sovCmd(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *Node) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovCmd(uint64(l))
	l = m.ObjectMeta.Size()
	n += 1 + l + sovCmd(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovCmd(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovCmd(uint64(l))
	return n
}

func (m *NodeCondition) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovCmd(uint64(l))
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovCmd(uint64(l))
	}
	l = len(m.LastTransitionTime)
	if l > 0 {
		n += 1 + l + sovCmd(uint64(l))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovCmd(uint64(l))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovCmd(uint64(l))
	}
	return n
}

func (m *NodeSpec) Size() (n int) {
	var l int
	_ = l
	if len(m.Roles) > 0 {
		for _, s := range m.Roles {
			l = len(s)
			n += 1 + l + sovCmd(uint64(l))
		}
	}
	return n
}

func (m *NodeStatus) Size() (n int) {
	var l int
	_ = l
	l = len(m.Phase)
	if l > 0 {
		n += 1 + l + sovCmd(uint64(l))
	}
	if len(m.Conditions) > 0 {
		for _, e := range m.Conditions {
			l = e.Size()
			n += 1 + l + sovCmd(uint64(l))
		}
	}
	return n
}

func (m *PortCondition) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovCmd(uint64(l))
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovCmd(uint64(l))
	}
	l = len(m.LastTransitionTime)
	if l > 0 {
		n += 1 + l + sovCmd(uint64(l))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovCmd(uint64(l))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovCmd(uint64(l))
	}
	return n
}

func (m *PortSpec) Size() (n int) {
	var l int
	_ = l
	l = len(m.MacAddress)
	if l > 0 {
		n += 1 + l + sovCmd(uint64(l))
	}
	return n
}

func (m *PortStatus) Size() (n int) {
	var l int
	_ = l
	if len(m.MacAddrs) > 0 {
		for _, s := range m.MacAddrs {
			l = len(s)
			n += 1 + l + sovCmd(uint64(l))
		}
	}
	l = len(m.LinkSpeed)
	if l > 0 {
		n += 1 + l + sovCmd(uint64(l))
	}
	if len(m.Conditions) > 0 {
		for _, e := range m.Conditions {
			l = e.Size()
			n += 1 + l + sovCmd(uint64(l))
		}
	}
	return n
}

func (m *SmartNIC) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovCmd(uint64(l))
	l = m.ObjectMeta.Size()
	n += 1 + l + sovCmd(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovCmd(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovCmd(uint64(l))
	return n
}

func (m *SmartNICCondition) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovCmd(uint64(l))
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovCmd(uint64(l))
	}
	l = len(m.LastTransitionTime)
	if l > 0 {
		n += 1 + l + sovCmd(uint64(l))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovCmd(uint64(l))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovCmd(uint64(l))
	}
	return n
}

func (m *SmartNICSpec) Size() (n int) {
	var l int
	_ = l
	l = len(m.Phase)
	if l > 0 {
		n += 1 + l + sovCmd(uint64(l))
	}
	l = len(m.MgmtIp)
	if l > 0 {
		n += 1 + l + sovCmd(uint64(l))
	}
	l = len(m.HostName)
	if l > 0 {
		n += 1 + l + sovCmd(uint64(l))
	}
	if len(m.Ports) > 0 {
		for _, e := range m.Ports {
			l = e.Size()
			n += 1 + l + sovCmd(uint64(l))
		}
	}
	return n
}

func (m *SmartNICStatus) Size() (n int) {
	var l int
	_ = l
	if len(m.Conditions) > 0 {
		for _, e := range m.Conditions {
			l = e.Size()
			n += 1 + l + sovCmd(uint64(l))
		}
	}
	l = len(m.SerialNum)
	if l > 0 {
		n += 1 + l + sovCmd(uint64(l))
	}
	l = len(m.PrimaryMacAddress)
	if l > 0 {
		n += 1 + l + sovCmd(uint64(l))
	}
	if len(m.Ports) > 0 {
		for _, e := range m.Ports {
			l = e.Size()
			n += 1 + l + sovCmd(uint64(l))
		}
	}
	return n
}

func sovCmd(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozCmd(x uint64) (n int) {
	return sovCmd(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Cluster) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Cluster: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Cluster: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmd(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClusterSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClusterSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClusterSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QuorumNodes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QuorumNodes = append(m.QuorumNodes, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VirtualIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VirtualIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NTPServers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NTPServers = append(m.NTPServers, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DNSSubDomain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DNSSubDomain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoAdmitNICs", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AutoAdmitNICs = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCmd(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClusterStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClusterStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClusterStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Leader", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Leader = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastLeaderTransitionTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastLeaderTransitionTime == nil {
				m.LastLeaderTransitionTime = &api.Timestamp{}
			}
			if err := m.LastLeaderTransitionTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmd(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Host) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Host: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Host: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmd(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HostIntfSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HostIntfSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HostIntfSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MacAddrs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MacAddrs = append(m.MacAddrs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmd(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HostIntfStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HostIntfStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HostIntfStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpAddrs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IpAddrs = append(m.IpAddrs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmd(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HostSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HostSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HostSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Interfaces", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Interfaces == nil {
				m.Interfaces = make(map[string]HostIntfSpec)
			}
			var mapkey string
			mapvalue := &HostIntfSpec{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCmd
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCmd
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthCmd
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCmd
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthCmd
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthCmd
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &HostIntfSpec{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCmd(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCmd
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Interfaces[mapkey] = *mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmd(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HostStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HostStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HostStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperatingSystem", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OperatingSystem = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Orchestrator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Orchestrator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Interfaces", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Interfaces == nil {
				m.Interfaces = make(map[string]HostIntfStatus)
			}
			var mapkey string
			mapvalue := &HostIntfStatus{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCmd
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCmd
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthCmd
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCmd
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthCmd
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthCmd
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &HostIntfStatus{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCmd(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCmd
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Interfaces[mapkey] = *mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmd(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Node) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Node: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Node: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmd(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeCondition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeCondition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeCondition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastTransitionTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastTransitionTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmd(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Roles", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Roles = append(m.Roles, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmd(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phase", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Phase = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conditions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Conditions = append(m.Conditions, &NodeCondition{})
			if err := m.Conditions[len(m.Conditions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmd(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PortCondition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PortCondition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PortCondition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastTransitionTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastTransitionTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmd(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PortSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PortSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PortSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MacAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MacAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmd(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PortStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PortStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PortStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MacAddrs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MacAddrs = append(m.MacAddrs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LinkSpeed", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LinkSpeed = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conditions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Conditions = append(m.Conditions, &PortCondition{})
			if err := m.Conditions[len(m.Conditions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmd(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SmartNIC) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SmartNIC: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SmartNIC: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmd(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SmartNICCondition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SmartNICCondition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SmartNICCondition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastTransitionTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastTransitionTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmd(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SmartNICSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SmartNICSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SmartNICSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phase", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Phase = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MgmtIp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MgmtIp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ports", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ports = append(m.Ports, PortSpec{})
			if err := m.Ports[len(m.Ports)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmd(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SmartNICStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SmartNICStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SmartNICStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conditions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Conditions = append(m.Conditions, &SmartNICCondition{})
			if err := m.Conditions[len(m.Conditions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SerialNum", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SerialNum = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrimaryMacAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrimaryMacAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ports", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ports = append(m.Ports, &PortStatus{})
			if err := m.Ports[len(m.Ports)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmd(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCmd(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCmd
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCmd
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthCmd
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowCmd
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipCmd(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthCmd = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCmd   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("cmd.proto", fileDescriptorCmd) }

var fileDescriptorCmd = []byte{
	// 1727 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x58, 0xcd, 0x6e, 0x1b, 0xc9,
	0x11, 0xd6, 0x90, 0xfa, 0x63, 0x51, 0x14, 0xa9, 0xb6, 0x6c, 0x91, 0xb4, 0x2d, 0x39, 0xb3, 0xf1,
	0x42, 0x49, 0x3c, 0xd2, 0x66, 0xbd, 0x71, 0x76, 0x8d, 0x38, 0x59, 0x8e, 0x34, 0xb6, 0xe8, 0xa5,
	0x48, 0xee, 0x70, 0xa4, 0x64, 0x4f, 0x8b, 0x16, 0xd9, 0xa6, 0x27, 0xe6, 0xfc, 0x64, 0xba, 0xc7,
	0x81, 0x4e, 0x39, 0x59, 0xb7, 0x04, 0xc8, 0x25, 0xaf, 0x10, 0x40, 0x4f, 0x90, 0x5b, 0x10, 0x20,
	0x07, 0x1f, 0x17, 0xbe, 0xe4, 0x14, 0x21, 0xf0, 0x51, 0xb7, 0xbc, 0x41, 0xd0, 0x3d, 0x3f, 0xec,
	0xa1, 0x64, 0x80, 0xab, 0x05, 0x16, 0x39, 0xf8, 0xc6, 0xe9, 0xae, 0xef, 0xeb, 0x9a, 0xaa, 0xaf,
	0xaa, 0x7a, 0x08, 0x85, 0xbe, 0x33, 0xd8, 0xf2, 0x03, 0x8f, 0x79, 0x68, 0xa1, 0x3f, 0x0a, 0x29,
	0x23, 0x41, 0xfd, 0xd6, 0xd0, 0xf3, 0x86, 0x23, 0xb2, 0x8d, 0x7d, 0x7b, 0x1b, 0xbb, 0xae, 0xc7,
	0x30, 0xb3, 0x3d, 0x97, 0x46, 0x66, 0x75, 0x63, 0x68, 0xb3, 0xe7, 0xe1, 0xd1, 0x56, 0xdf, 0x73,
	0xb6, 0x7d, 0xe2, 0x52, 0xec, 0x0e, 0xbc, 0x6d, 0xfa, 0xfb, 0xed, 0x97, 0xc4, 0xb5, 0xfb, 0x64,
	0x3b, 0x64, 0xf6, 0x88, 0x72, 0xe8, 0x90, 0xb8, 0x32, 0x7a, 0xdb, 0x76, 0xfb, 0xa3, 0x70, 0x40,
	0x12, 0x1a, 0x4d, 0xa2, 0x19, 0x7a, 0x43, 0x6f, 0x5b, 0x2c, 0x1f, 0x85, 0xcf, 0xc4, 0x93, 0x78,
	0x10, 0xbf, 0x62, 0xf3, 0xbb, 0xef, 0x38, 0x95, 0xfb, 0xe8, 0x10, 0x86, 0x23, 0x33, 0xf5, 0xcf,
	0x39, 0x58, 0xd8, 0x89, 0x5e, 0x03, 0x7d, 0x04, 0x8a, 0x55, 0x55, 0xee, 0x28, 0x9b, 0xc5, 0x8f,
	0x4b, 0x5b, 0xd8, 0xb7, 0xb7, 0xac, 0x63, 0x9f, 0xec, 0x13, 0x86, 0xf5, 0x6b, 0xaf, 0xcf, 0x36,
	0x66, 0xbe, 0x39, 0xdb, 0x50, 0xce, 0xcf, 0x36, 0x16, 0xee, 0xd9, 0xee, 0xc8, 0x76, 0x89, 0xa9,
	0x58, 0xe8, 0x33, 0x50, 0x3a, 0xd5, 0x9c, 0x40, 0x94, 0x05, 0xa2, 0x73, 0xf4, 0x5b, 0xd2, 0x67,
	0x02, 0x53, 0x97, 0x30, 0xcb, 0xfc, 0xc4, 0x7b, 0x9e, 0x63, 0x33, 0xe2, 0xf8, 0xec, 0xd8, 0x54,
	0x3a, 0xe8, 0x73, 0x98, 0xed, 0xf9, 0xa4, 0x5f, 0xcd, 0x0b, 0xf4, 0xea, 0x56, 0x1c, 0xcb, 0xad,
	0xd8, 0x19, 0xbe, 0xa7, 0xdf, 0xe0, 0x14, 0x1c, 0x4e, 0x7d, 0xd2, 0x97, 0xe0, 0x02, 0x89, 0xf6,
	0x60, 0xbe, 0xc7, 0x30, 0x0b, 0x69, 0x75, 0x56, 0x70, 0xdc, 0xb8, 0xc0, 0x21, 0x76, 0xf5, 0x6a,
	0xcc, 0x52, 0xa1, 0xe2, 0x59, 0xe2, 0x89, 0xf1, 0x0f, 0x4b, 0x6f, 0x5e, 0xd5, 0x0a, 0x69, 0x3a,
	0xd5, 0x7f, 0xe6, 0xa0, 0x28, 0xb9, 0x81, 0x7e, 0x01, 0xc5, 0x2f, 0x43, 0x2f, 0x08, 0x9d, 0xb6,
	0x37, 0x20, 0xb4, 0xaa, 0xdc, 0xc9, 0x6f, 0x16, 0xf4, 0xfa, 0xf9, 0xd9, 0xc6, 0x8d, 0xdf, 0x89,
	0x65, 0xcd, 0xe5, 0xeb, 0x12, 0xaf, 0x6c, 0x8e, 0x1e, 0x40, 0xe1, 0xd0, 0x0e, 0x58, 0x88, 0x47,
	0xcd, 0xae, 0x88, 0x55, 0x41, 0xaf, 0x9e, 0x9f, 0x6d, 0xac, 0xbe, 0x8c, 0x16, 0x35, 0xdb, 0x97,
	0x90, 0x63, 0x53, 0xf4, 0x19, 0x40, 0xdb, 0xea, 0xf6, 0x48, 0xf0, 0x92, 0x04, 0xb4, 0x9a, 0x17,
	0x87, 0xd6, 0xce, 0xcf, 0x36, 0xae, 0xbb, 0xcc, 0xd7, 0x68, 0xb4, 0x2c, 0x21, 0x25, 0x63, 0xf4,
	0x2b, 0x58, 0xda, 0x6d, 0xf7, 0x7a, 0xe1, 0xd1, 0xae, 0xe7, 0x60, 0xdb, 0x15, 0xf1, 0x29, 0xe8,
	0x37, 0xcf, 0xcf, 0x36, 0xd6, 0x06, 0x2e, 0xd5, 0x68, 0x78, 0x34, 0x10, 0x1b, 0x12, 0x3c, 0x03,
	0x40, 0x3b, 0x50, 0x6a, 0x84, 0xcc, 0x6b, 0x0c, 0x1c, 0x9b, 0xb5, 0x9b, 0x3b, 0xb4, 0x3a, 0x77,
	0x47, 0xd9, 0x5c, 0xd4, 0x6f, 0x9f, 0x9f, 0x6d, 0xd4, 0x70, 0xc8, 0x3c, 0x0d, 0xf3, 0x1d, 0xcd,
	0xb5, 0xfb, 0xb2, 0x0b, 0x59, 0x8c, 0xfa, 0x37, 0x05, 0x4a, 0x99, 0x4c, 0xa0, 0x7b, 0x30, 0xdf,
	0x22, 0x78, 0x40, 0x02, 0xa1, 0xb2, 0x82, 0xbe, 0xca, 0xb3, 0x32, 0x12, 0x2b, 0x72, 0x56, 0x22,
	0x1b, 0x74, 0x0c, 0xd5, 0x16, 0xa6, 0x2c, 0x7a, 0xb2, 0x02, 0xec, 0x52, 0x9b, 0x17, 0x86, 0x65,
	0x3b, 0x24, 0xd6, 0xdc, 0x72, 0xa4, 0x52, 0xdb, 0x21, 0x94, 0x61, 0xc7, 0xd7, 0xb5, 0xd7, 0x91,
	0xdc, 0xee, 0x8e, 0x30, 0x65, 0x5a, 0x44, 0xac, 0xb1, 0x14, 0xa9, 0x31, 0xdb, 0x21, 0xd2, 0x41,
	0xef, 0xa4, 0x57, 0x4f, 0x72, 0x30, 0xbb, 0xe7, 0x51, 0xf6, 0xfd, 0x96, 0xc4, 0xa3, 0x4c, 0x49,
	0xac, 0xa4, 0x72, 0xe6, 0x9e, 0x4c, 0x51, 0x0f, 0xc6, 0x44, 0x3d, 0x5c, 0xcb, 0x12, 0x4c, 0x5b,
	0x0c, 0xc5, 0x37, 0xaf, 0x6a, 0x0b, 0x68, 0xee, 0xb9, 0x47, 0x19, 0x55, 0x9f, 0xc0, 0x12, 0x07,
	0x37, 0x5d, 0xf6, 0x4c, 0x9c, 0xf1, 0x73, 0x58, 0xdc, 0xc7, 0xfd, 0xc6, 0x60, 0x10, 0x24, 0x75,
	0x70, 0x33, 0x8e, 0xf9, 0x35, 0x07, 0xf7, 0x35, 0xcc, 0x37, 0x24, 0xce, 0xd4, 0x58, 0x7d, 0x0c,
	0xcb, 0x29, 0x51, 0x24, 0x86, 0x4f, 0x60, 0xa1, 0xe9, 0xcb, 0x4c, 0xf5, 0x98, 0x09, 0xd9, 0xfe,
	0x05, 0xa2, 0xc4, 0x54, 0xfd, 0x87, 0x02, 0x8b, 0x49, 0x3c, 0xd0, 0xd7, 0x00, 0x4d, 0x97, 0x91,
	0xe0, 0x19, 0xee, 0xc7, 0x75, 0x59, 0xfc, 0xf8, 0x07, 0x17, 0xc2, 0xb6, 0x35, 0xb6, 0x31, 0x5c,
	0x16, 0x1c, 0xeb, 0xb7, 0xe2, 0x18, 0xac, 0xda, 0xe9, 0x86, 0x5c, 0x48, 0x63, 0xf3, 0xba, 0x05,
	0xe5, 0x09, 0x30, 0xaa, 0x40, 0xfe, 0x05, 0x39, 0x8e, 0x04, 0x6c, 0xf2, 0x9f, 0xe8, 0x27, 0x30,
	0xf7, 0x12, 0x8f, 0xc2, 0x44, 0x94, 0xd7, 0x33, 0x0e, 0x24, 0x91, 0x33, 0x23, 0x9b, 0x87, 0xb9,
	0x4f, 0x15, 0xf5, 0xdf, 0x79, 0x80, 0x71, 0x4a, 0xd0, 0x53, 0x98, 0xe5, 0xaa, 0x8a, 0x6b, 0xe2,
	0xc1, 0xe9, 0x49, 0xed, 0x56, 0x8f, 0x05, 0x86, 0x1b, 0x3a, 0x9b, 0x63, 0x2b, 0x41, 0xc6, 0xcd,
	0x7e, 0x14, 0x47, 0x69, 0x99, 0x1d, 0xfb, 0xb2, 0x98, 0x05, 0x07, 0x6a, 0x41, 0xb9, 0xe3, 0x93,
	0x00, 0x33, 0xdb, 0x1d, 0xf6, 0x8e, 0x29, 0x23, 0x4e, 0xdc, 0x72, 0xd4, 0x18, 0x56, 0xf7, 0x92,
	0x6d, 0x8d, 0x8a, 0x7d, 0x89, 0x62, 0x12, 0x8a, 0x74, 0x58, 0xea, 0x04, 0xfd, 0xe7, 0x84, 0xb2,
	0x00, 0x33, 0x2f, 0x10, 0xc2, 0x2c, 0xe8, 0xeb, 0x31, 0xd5, 0x0d, 0x4f, 0xda, 0x93, 0x5b, 0x89,
	0x8c, 0x41, 0x38, 0x93, 0xa3, 0x59, 0x91, 0xa3, 0x0f, 0x2e, 0x51, 0xe6, 0x77, 0xc8, 0xd2, 0xe1,
	0x34, 0x59, 0xd2, 0xb2, 0x59, 0x5a, 0xbb, 0x98, 0x25, 0xe1, 0x86, 0x9c, 0xa7, 0x07, 0x91, 0xd4,
	0x44, 0x60, 0x8b, 0xb0, 0x70, 0xd0, 0xfe, 0xa2, 0xdd, 0xf9, 0x75, 0xbb, 0x32, 0x83, 0x4a, 0x50,
	0xd0, 0x1b, 0xa6, 0xb1, 0x6f, 0x58, 0x8d, 0x56, 0x45, 0x41, 0xcb, 0x00, 0x7b, 0x5f, 0x75, 0x0d,
	0xf3, 0xb0, 0xd9, 0xeb, 0x98, 0x95, 0x9c, 0xe8, 0x1e, 0xbc, 0xf7, 0xff, 0x7f, 0x74, 0x0f, 0xee,
	0xc9, 0x77, 0xea, 0x1e, 0x82, 0xe0, 0x5b, 0x76, 0x0f, 0x31, 0x11, 0xd5, 0x3f, 0xe6, 0xa1, 0xc4,
	0xd1, 0x3b, 0x9e, 0x3b, 0x10, 0xcd, 0x15, 0x99, 0x19, 0xad, 0xff, 0xf2, 0xf4, 0xa4, 0xf6, 0xc3,
	0x44, 0xeb, 0x19, 0xc3, 0xad, 0xf4, 0xd7, 0x34, 0x9a, 0x4f, 0x3c, 0x8f, 0xa4, 0xfe, 0xc9, 0xe9,
	0x49, 0xad, 0x9a, 0xb0, 0xa6, 0x3c, 0x91, 0x49, 0xc2, 0xf4, 0xce, 0x17, 0x40, 0x87, 0x80, 0xf8,
	0x58, 0x98, 0x98, 0x37, 0x91, 0xf2, 0x3f, 0x8c, 0xd1, 0xeb, 0x62, 0xbe, 0xbc, 0x7b, 0xb0, 0x5c,
	0xc2, 0x80, 0x3e, 0x82, 0x79, 0x93, 0x60, 0xea, 0x25, 0xd3, 0xb8, 0x9a, 0x78, 0x12, 0x88, 0x55,
	0xd9, 0x93, 0xc8, 0x0e, 0xdd, 0x87, 0x85, 0x7d, 0x42, 0x29, 0x1e, 0x12, 0x31, 0x7e, 0x0b, 0x7a,
	0x2d, 0x86, 0xac, 0x38, 0xd1, 0xb2, 0xdc, 0x1f, 0x63, 0x4b, 0xf5, 0x26, 0x94, 0x32, 0xa1, 0x43,
	0x00, 0xf3, 0x2d, 0xa3, 0xb1, 0x6b, 0x98, 0x95, 0x19, 0xf5, 0x0f, 0xb0, 0x98, 0xa8, 0x01, 0x7d,
	0x01, 0x73, 0xa6, 0x37, 0x4a, 0xaf, 0x33, 0x3f, 0x3b, 0x3d, 0xa9, 0xd5, 0xe5, 0x54, 0x88, 0xce,
	0xc9, 0x7f, 0x70, 0xab, 0x24, 0x6c, 0xe5, 0x80, 0x43, 0xa4, 0x73, 0x23, 0x0e, 0xf5, 0xc3, 0x88,
	0x98, 0x3f, 0xf0, 0x6a, 0xd8, 0xe9, 0xb4, 0x2d, 0xb3, 0xd3, 0x6a, 0xf1, 0x43, 0xb9, 0x03, 0x5f,
	0x1e, 0x74, 0xcc, 0x83, 0xfd, 0x8a, 0xa2, 0xfe, 0x57, 0x01, 0x18, 0xcb, 0x09, 0xb5, 0x61, 0xae,
	0xfb, 0x1c, 0xd3, 0x44, 0x0e, 0x9f, 0x9e, 0x9e, 0xd4, 0x6e, 0x67, 0x7c, 0x88, 0x3a, 0x03, 0xff,
	0x29, 0xec, 0x52, 0x37, 0x7c, 0xfe, 0x24, 0xbb, 0x21, 0xb6, 0x91, 0x05, 0x90, 0xbe, 0x3c, 0x57,
	0x43, 0x3e, 0x73, 0x2b, 0xcc, 0x08, 0x4c, 0xb4, 0x17, 0xce, 0xb5, 0xda, 0x4f, 0x11, 0x72, 0x7b,
	0x19, 0xf3, 0xa8, 0x8f, 0xa0, 0x90, 0x7a, 0x90, 0xed, 0x03, 0x45, 0x58, 0xe8, 0x1a, 0xed, 0xdd,
	0x66, 0xfb, 0x49, 0x45, 0xe1, 0xef, 0xf9, 0xb4, 0xd3, 0x6c, 0x1b, 0xbb, 0x95, 0x1c, 0xff, 0xfd,
	0xb8, 0xd1, 0x6c, 0x19, 0xbb, 0x95, 0xbc, 0xfa, 0xa7, 0x3c, 0x94, 0xba, 0x5e, 0xc0, 0xa6, 0x2a,
	0x82, 0x8c, 0xe1, 0xfb, 0x22, 0xb8, 0x62, 0x11, 0xdc, 0x9a, 0x2c, 0x02, 0x9e, 0xa8, 0x8e, 0x69,
	0x7d, 0x7d, 0xd0, 0xad, 0xcc, 0xa8, 0x4d, 0x58, 0xe4, 0x61, 0x16, 0x55, 0xf0, 0x08, 0x20, 0xbe,
	0xa2, 0x10, 0x4a, 0xe3, 0x84, 0xdc, 0x8e, 0x4f, 0xb8, 0x9e, 0xdc, 0x68, 0x08, 0xcd, 0x48, 0x63,
	0x0c, 0x50, 0xff, 0xa5, 0x00, 0x08, 0xae, 0x28, 0x6c, 0x57, 0xbd, 0x1d, 0xa1, 0x87, 0x50, 0x68,
	0xd9, 0xee, 0x8b, 0x9e, 0x4f, 0xc8, 0x20, 0x4e, 0x60, 0xaa, 0xcf, 0x91, 0xed, 0xbe, 0xd0, 0x28,
	0xdf, 0x91, 0xbf, 0x13, 0x52, 0xf3, 0x09, 0xd1, 0xe7, 0x27, 0x44, 0x9f, 0x11, 0xd4, 0xb7, 0x10,
	0xfd, 0x5f, 0x72, 0xb0, 0xd8, 0x73, 0x70, 0xc0, 0xaf, 0xf2, 0xdf, 0xef, 0x1c, 0x6b, 0x64, 0xe6,
	0xd8, 0xf8, 0x36, 0x95, 0x78, 0x33, 0xc5, 0x2c, 0x6b, 0x4e, 0xcc, 0xb2, 0xb5, 0x8b, 0x24, 0xd3,
	0xce, 0xb3, 0xf2, 0x9b, 0x57, 0xb5, 0x22, 0x2a, 0x50, 0x8e, 0xe3, 0x9f, 0x3b, 0xea, 0x5f, 0xf3,
	0xb0, 0x92, 0xb0, 0x8c, 0x4b, 0xfa, 0x30, 0x53, 0xd2, 0xfa, 0xe9, 0x49, 0x6d, 0x33, 0x29, 0xbe,
	0x0b, 0xc6, 0xef, 0xcb, 0xfa, 0x8a, 0x65, 0xad, 0x5d, 0x52, 0xd6, 0x7b, 0x46, 0xa3, 0x65, 0xed,
	0x7d, 0x55, 0x99, 0x41, 0x65, 0x28, 0x1e, 0xb4, 0x4d, 0xa3, 0xb1, 0xb3, 0xd7, 0xd0, 0x5b, 0x46,
	0x45, 0x51, 0xcf, 0x73, 0xb0, 0x24, 0x8b, 0x06, 0x59, 0xd9, 0x71, 0xc3, 0x1b, 0xef, 0x07, 0x93,
	0x59, 0x12, 0x63, 0x2f, 0x79, 0x98, 0x6a, 0xe8, 0xfc, 0x14, 0xe6, 0xf7, 0x87, 0x0e, 0x6b, 0xfa,
	0x71, 0x8a, 0xc6, 0x6f, 0x32, 0x74, 0x58, 0xf6, 0xeb, 0x3e, 0x36, 0xe4, 0x7d, 0x82, 0x5f, 0x2c,
	0xdb, 0x38, 0x8d, 0x7e, 0xda, 0x27, 0xf8, 0x67, 0x97, 0xe6, 0xe2, 0x4c, 0xc8, 0x53, 0x63, 0xf4,
	0x39, 0xcc, 0xf1, 0x82, 0x4e, 0xee, 0xd1, 0x2b, 0x99, 0x32, 0x17, 0x85, 0xb1, 0x16, 0x2b, 0xba,
	0xec, 0x73, 0xbb, 0x8c, 0xb7, 0x7c, 0x41, 0x3d, 0x84, 0x52, 0xe6, 0xed, 0xb2, 0x03, 0xad, 0x0c,
	0x45, 0xd3, 0x78, 0xd2, 0xec, 0x59, 0x86, 0x19, 0x0d, 0xb5, 0x25, 0x58, 0x34, 0x8d, 0xa7, 0xc6,
	0x8e, 0x25, 0xc6, 0x9a, 0x34, 0xef, 0xf2, 0x7c, 0xab, 0xb1, 0xbb, 0xdf, 0xb4, 0xf8, 0xd6, 0xac,
	0xfa, 0xf7, 0x1c, 0x2c, 0x67, 0x8b, 0x0b, 0xfd, 0x26, 0xd3, 0x98, 0xa2, 0xaf, 0xb3, 0xfa, 0x85,
	0x4a, 0xbc, 0x42, 0x73, 0xe2, 0xed, 0xb2, 0x47, 0x02, 0x1b, 0x8f, 0xda, 0xa1, 0x33, 0xd9, 0x2e,
	0xa9, 0xd8, 0xd0, 0xdc, 0x50, 0xfe, 0xb2, 0x19, 0x9b, 0xa3, 0x1e, 0xac, 0x74, 0x03, 0xdb, 0xc1,
	0xc1, 0xb1, 0xd4, 0xf8, 0xa3, 0x24, 0xdc, 0x8d, 0x39, 0x6e, 0xfb, 0x91, 0x81, 0x76, 0xf9, 0x00,
	0xb8, 0x88, 0x47, 0x7a, 0x36, 0x2f, 0xd7, 0xb2, 0x79, 0x89, 0x7a, 0xcd, 0x5a, 0xaa, 0xa3, 0x4b,
	0x33, 0xf3, 0xe3, 0xfb, 0x50, 0x9e, 0x28, 0xe8, 0x6c, 0x6e, 0x16, 0x61, 0xd6, 0x32, 0x0f, 0x8c,
	0x8a, 0x82, 0x0a, 0x30, 0xf7, 0xb8, 0xd1, 0xea, 0x19, 0x95, 0x9c, 0xbe, 0xf4, 0xfa, 0xed, 0xba,
	0xf2, 0xcd, 0xdb, 0x75, 0xe5, 0x3f, 0x6f, 0xd7, 0x95, 0xae, 0x72, 0x34, 0x2f, 0xfe, 0xd5, 0xbb,
	0xff, 0xbf, 0x00, 0x00, 0x00, 0xff, 0xff, 0xd9, 0xb2, 0x1e, 0xe2, 0xa6, 0x14, 0x00, 0x00,
}
