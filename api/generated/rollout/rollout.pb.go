// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: rollout.proto

/*
	Package rollout is a generated protocol buffer package.

	Service name

	It is generated from these files:
		rollout.proto
		svc_rollout.proto

	It has these top-level messages:
		Rollout
		RolloutPhase
		RolloutSpec
		RolloutStatus
		AutoMsgRolloutWatchHelper
		RolloutList
*/
package rollout

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/pensando/grpc-gateway/third_party/googleapis/google/api"
import _ "github.com/pensando/sw/venice/utils/apigen/annotations"
import _ "github.com/gogo/protobuf/gogoproto"
import api "github.com/pensando/sw/api"
import labels "github.com/pensando/sw/api/labels"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// These are valid conditions of rollout component (node or service)
type RolloutPhase_Phases int32

const (
	// Pre rollout check (enough disk space, image download, validation,)
	// ui-hint: PreCheck
	RolloutPhase_PRE_CHECK RolloutPhase_Phases = 0
	// The dependencies are met (dependent nodes/services are at needed versions)
	// ui-hint: DependenciesCheck
	RolloutPhase_DEPENDENCIES_CHECK RolloutPhase_Phases = 1
	// Among the various nodes getting upgraded in parallel, waiting for this node's turn.
	// ui-hint: WaitingForTurn
	RolloutPhase_WAITING_FOR_TURN RolloutPhase_Phases = 2
	// Component is undergoing rollout - Either node is rebooting or service is restarting
	// ui-hint: Processing
	RolloutPhase_PROGRESSING RolloutPhase_Phases = 3
	// new revision is ready and available for service
	// ui-hint: Complete
	RolloutPhase_COMPLETE RolloutPhase_Phases = 4
	// Node/Component is in failure state
	// ui-hint: Fail
	RolloutPhase_FAIL RolloutPhase_Phases = 5
)

var RolloutPhase_Phases_name = map[int32]string{
	0: "PRE_CHECK",
	1: "DEPENDENCIES_CHECK",
	2: "WAITING_FOR_TURN",
	3: "PROGRESSING",
	4: "COMPLETE",
	5: "FAIL",
}
var RolloutPhase_Phases_value = map[string]int32{
	"PRE_CHECK":          0,
	"DEPENDENCIES_CHECK": 1,
	"WAITING_FOR_TURN":   2,
	"PROGRESSING":        3,
	"COMPLETE":           4,
	"FAIL":               5,
}

func (x RolloutPhase_Phases) String() string {
	return proto.EnumName(RolloutPhase_Phases_name, int32(x))
}
func (RolloutPhase_Phases) EnumDescriptor() ([]byte, []int) { return fileDescriptorRollout, []int{1, 0} }

// Strategy in which the nodes are upgraded - subject to other constraints below
type RolloutSpec_StrategyType int32

const (
	// fixed number of Nodes are upgraded in parallel
	// ui-hint: Linear
	RolloutSpec_LINEAR RolloutSpec_StrategyType = 0
	// Start off with small number of node upgrade. As upgrades progress, increase the
	// number of nodes getting upgraded exponentially still maintaining the maximum number
	// of nodes that are getting updated within limits below
	// ui-hint: Exponential
	RolloutSpec_EXPONENTIAL RolloutSpec_StrategyType = 1
)

var RolloutSpec_StrategyType_name = map[int32]string{
	0: "LINEAR",
	1: "EXPONENTIAL",
}
var RolloutSpec_StrategyType_value = map[string]int32{
	"LINEAR":      0,
	"EXPONENTIAL": 1,
}

func (x RolloutSpec_StrategyType) String() string {
	return proto.EnumName(RolloutSpec_StrategyType_name, int32(x))
}
func (RolloutSpec_StrategyType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorRollout, []int{2, 0}
}

// By default the upgrade is Disruptive. However the API can specify the type of upgrade
type RolloutSpec_SmartNICUpgradeType int32

const (
	// ui-hint: Disruptive
	RolloutSpec_Disruptive RolloutSpec_SmartNICUpgradeType = 0
	// ui-hint: OnNextHostReboot
	RolloutSpec_OnNextHostReboot RolloutSpec_SmartNICUpgradeType = 1
)

var RolloutSpec_SmartNICUpgradeType_name = map[int32]string{
	0: "Disruptive",
	1: "OnNextHostReboot",
}
var RolloutSpec_SmartNICUpgradeType_value = map[string]int32{
	"Disruptive":       0,
	"OnNextHostReboot": 1,
}

func (x RolloutSpec_SmartNICUpgradeType) String() string {
	return proto.EnumName(RolloutSpec_SmartNICUpgradeType_name, int32(x))
}
func (RolloutSpec_SmartNICUpgradeType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorRollout, []int{2, 1}
}

// Current overall state of rollout
type RolloutStatus_RolloutOperationalState int32

const (
	//
	RolloutStatus_PROGRESSING RolloutStatus_RolloutOperationalState = 0
	//
	RolloutStatus_FAILURE RolloutStatus_RolloutOperationalState = 1
	//
	RolloutStatus_SUCCESS RolloutStatus_RolloutOperationalState = 2
	//
	RolloutStatus_SCHEDULED RolloutStatus_RolloutOperationalState = 3
	//
	RolloutStatus_SUSPENDED RolloutStatus_RolloutOperationalState = 4
	//
	RolloutStatus_SUSPEND_IN_PROGRESS RolloutStatus_RolloutOperationalState = 5
	//
	RolloutStatus_DEADLINE_EXCEEDED RolloutStatus_RolloutOperationalState = 6
)

var RolloutStatus_RolloutOperationalState_name = map[int32]string{
	0: "PROGRESSING",
	1: "FAILURE",
	2: "SUCCESS",
	3: "SCHEDULED",
	4: "SUSPENDED",
	5: "SUSPEND_IN_PROGRESS",
	6: "DEADLINE_EXCEEDED",
}
var RolloutStatus_RolloutOperationalState_value = map[string]int32{
	"PROGRESSING":         0,
	"FAILURE":             1,
	"SUCCESS":             2,
	"SCHEDULED":           3,
	"SUSPENDED":           4,
	"SUSPEND_IN_PROGRESS": 5,
	"DEADLINE_EXCEEDED":   6,
}

func (x RolloutStatus_RolloutOperationalState) String() string {
	return proto.EnumName(RolloutStatus_RolloutOperationalState_name, int32(x))
}
func (RolloutStatus_RolloutOperationalState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorRollout, []int{3, 0}
}

// Rollout object captures the admin's intent and status of the software version running on the cluster
//  It is incorrect to have two different Rollouts active at the same time
type Rollout struct {
	//
	api.TypeMeta `protobuf:"bytes,1,opt,name=T,json=,inline,embedded=T" json:",inline"`
	//
	api.ObjectMeta `protobuf:"bytes,2,opt,name=O,json=meta,omitempty,embedded=O" json:"meta,omitempty"`
	//
	Spec RolloutSpec `protobuf:"bytes,3,opt,name=Spec,json=spec,omitempty" json:"spec,omitempty"`
	//
	Status RolloutStatus `protobuf:"bytes,4,opt,name=Status,json=status,omitempty" json:"status,omitempty"`
}

func (m *Rollout) Reset()                    { *m = Rollout{} }
func (m *Rollout) String() string            { return proto.CompactTextString(m) }
func (*Rollout) ProtoMessage()               {}
func (*Rollout) Descriptor() ([]byte, []int) { return fileDescriptorRollout, []int{0} }

func (m *Rollout) GetSpec() RolloutSpec {
	if m != nil {
		return m.Spec
	}
	return RolloutSpec{}
}

func (m *Rollout) GetStatus() RolloutStatus {
	if m != nil {
		return m.Status
	}
	return RolloutStatus{}
}

// RolloutPhase gives details of status of Rollout on each Node/Service/SmartNIC
type RolloutPhase struct {
	// Name of the Node, Service or SmartNIC
	Name string `protobuf:"bytes,1,opt,name=Name,json=name,inline,proto3" json:"name,inline"`
	// Phase indicates a certain rollout phase/condition
	Phase string `protobuf:"bytes,2,opt,name=Phase,json=phase,omitempty,proto3" json:"phase,omitempty"`
	// The time of starting the rollout for this node/service.
	// This does not include the pre-check which can happen way before the actual rollout.
	StartTime *api.Timestamp `protobuf:"bytes,3,opt,name=StartTime,json=start-time,omitempty" json:"start-time,omitempty"`
	// Time at which rollout completed for this node/service
	EndTime *api.Timestamp `protobuf:"bytes,4,opt,name=EndTime,json=end-time,omitempty" json:"end-time,omitempty"`
	// The reason for the Phase last transition, if any
	Reason string `protobuf:"bytes,5,opt,name=Reason,json=reason,omitempty,proto3" json:"reason,omitempty"`
	// A detailed message indicating details about the transition.
	Message string `protobuf:"bytes,6,opt,name=Message,json=message,omitempty,proto3" json:"message,omitempty"`
}

func (m *RolloutPhase) Reset()                    { *m = RolloutPhase{} }
func (m *RolloutPhase) String() string            { return proto.CompactTextString(m) }
func (*RolloutPhase) ProtoMessage()               {}
func (*RolloutPhase) Descriptor() ([]byte, []int) { return fileDescriptorRollout, []int{1} }

func (m *RolloutPhase) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *RolloutPhase) GetPhase() string {
	if m != nil {
		return m.Phase
	}
	return ""
}

func (m *RolloutPhase) GetStartTime() *api.Timestamp {
	if m != nil {
		return m.StartTime
	}
	return nil
}

func (m *RolloutPhase) GetEndTime() *api.Timestamp {
	if m != nil {
		return m.EndTime
	}
	return nil
}

func (m *RolloutPhase) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

func (m *RolloutPhase) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

// RolloutSpec is the Spec of a Rollout
type RolloutSpec struct {
	//  New Version of the image to rollout to
	Version string `protobuf:"bytes,1,opt,name=Version,json=version,inline,proto3" json:"version,inline"`
	// Time, if specified, at which the rollout is supposed to start
	ScheduledStartTime *api.Timestamp `protobuf:"bytes,2,opt,name=ScheduledStartTime,json=scheduled-start-time,omitempty" json:"scheduled-start-time,omitempty"`
	// Duration, if specified, after which the rollout is supposed to stop, if not completed by that time
	// Typically represents the end of Maintenance window
	Duration string `protobuf:"bytes,3,opt,name=Duration,json=duration,omitempty,proto3" json:"duration,omitempty"`
	//
	Strategy string `protobuf:"bytes,4,opt,name=Strategy,json=strategy,proto3" json:"strategy"`
	// MaxParallel is the maximum number of nodes getting updated at any time
	// This setting is applicable only to SmartNICs.
	// Controller nodes are always upgraded one after another.
	MaxParallel uint32 `protobuf:"varint,5,opt,name=MaxParallel,json=max-parallel,proto3" json:"max-parallel"`
	// After these many failures are observed during NIC upgrade, the rollout process stops
	// This setting applies to smartNICs only.
	// The controller nodes are rollout first and any failure there stops the rollout of SmartNICs
	MaxNICFailuresBeforeAbort uint32 `protobuf:"varint,6,opt,name=MaxNICFailuresBeforeAbort,json=max-nic-failures-before-abort,proto3" json:"max-nic-failures-before-abort"`
	// If specified, this is the sequence in which the SmartNICs are upgraded based on their labels.
	// if a SmartNIC matches multiple constraints, the first one is used.
	//  Any SmartNIC which does not match the constraints is upgraded at the end.
	// This order is mainly for the smartNICs on Hosts
	// Controller nodes are always rollout one after other
	OrderConstraints []*labels.Selector `protobuf:"bytes,7,rep,name=OrderConstraints,json=order-constraints,omitempty" json:"order-constraints,omitempty"`
	// When Set to true, the current rollout is suspended. Existing Nodes/Services/SmartNICs in the middle of rollout continue
	//  rollout execution but any Nodes/Services/SmartNICs which has not started Rollout will not be scheduled one.
	Suspend bool `protobuf:"varint,8,opt,name=Suspend,json=suspend,omitempty,proto3" json:"suspend,omitempty"`
	// Dont upgrade Controller but only upgrade SmartNICs
	SmartNICsOnly bool `protobuf:"varint,9,opt,name=SmartNICsOnly,json=smartnics-only,omitempty,proto3" json:"smartnics-only,omitempty"`
	// When SmartNICMustMatchConstraint is true, Any smartNIC which does not match OrderConstraints does not go through rollout
	SmartNICMustMatchConstraint bool `protobuf:"varint,10,opt,name=SmartNICMustMatchConstraint,json=smartnic-must-match-constraint,omitempty,proto3" json:"smartnic-must-match-constraint,omitempty"`
	//
	UpgradeType string `protobuf:"bytes,11,opt,name=UpgradeType,json=upgrade-type,proto3" json:"upgrade-type"`
}

func (m *RolloutSpec) Reset()                    { *m = RolloutSpec{} }
func (m *RolloutSpec) String() string            { return proto.CompactTextString(m) }
func (*RolloutSpec) ProtoMessage()               {}
func (*RolloutSpec) Descriptor() ([]byte, []int) { return fileDescriptorRollout, []int{2} }

func (m *RolloutSpec) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *RolloutSpec) GetScheduledStartTime() *api.Timestamp {
	if m != nil {
		return m.ScheduledStartTime
	}
	return nil
}

func (m *RolloutSpec) GetDuration() string {
	if m != nil {
		return m.Duration
	}
	return ""
}

func (m *RolloutSpec) GetStrategy() string {
	if m != nil {
		return m.Strategy
	}
	return ""
}

func (m *RolloutSpec) GetMaxParallel() uint32 {
	if m != nil {
		return m.MaxParallel
	}
	return 0
}

func (m *RolloutSpec) GetMaxNICFailuresBeforeAbort() uint32 {
	if m != nil {
		return m.MaxNICFailuresBeforeAbort
	}
	return 0
}

func (m *RolloutSpec) GetOrderConstraints() []*labels.Selector {
	if m != nil {
		return m.OrderConstraints
	}
	return nil
}

func (m *RolloutSpec) GetSuspend() bool {
	if m != nil {
		return m.Suspend
	}
	return false
}

func (m *RolloutSpec) GetSmartNICsOnly() bool {
	if m != nil {
		return m.SmartNICsOnly
	}
	return false
}

func (m *RolloutSpec) GetSmartNICMustMatchConstraint() bool {
	if m != nil {
		return m.SmartNICMustMatchConstraint
	}
	return false
}

func (m *RolloutSpec) GetUpgradeType() string {
	if m != nil {
		return m.UpgradeType
	}
	return ""
}

// Rollout Status gives the status of the rollout at the top level as well as details of
//  individual components
type RolloutStatus struct {
	// Rollout status of Controller Node
	ControllerNodesStatus []*RolloutPhase `protobuf:"bytes,1,rep,name=ControllerNodesStatus,json=controller-nodes-status,omitempty" json:"controller-nodes-status,omitempty"`
	// Rollout status of Various Controller Services
	ControllerServicesStatus []*RolloutPhase `protobuf:"bytes,2,rep,name=ControllerServicesStatus,json=controller-services-status,omitempty" json:"controller-services-status,omitempty"`
	// Rollout status of SmartNICs in the cluster. Has entries for SmartNICs on Controller nodes as well as workload nodes
	// The entries are group by parallelism based on the order-constraints and max-parallel specified by the user.
	SmartNICsStatus []*RolloutPhase `protobuf:"bytes,3,rep,name=SmartNICsStatus,json=smartnics-status,omitempty" json:"smartnics-status,omitempty"`
	//
	OperationalState string `protobuf:"bytes,4,opt,name=OperationalState,json=state,omitempty,proto3" json:"state,omitempty"`
	// Heuristic value of percentage completion of the rollout
	CompletionPercentage uint32 `protobuf:"varint,5,opt,name=CompletionPercentage,json=completion-percent,omitempty,proto3" json:"completion-percent,omitempty"`
	// Start time of Rollout
	StartTime *api.Timestamp `protobuf:"bytes,6,opt,name=StartTime,json=start-time,omitempty" json:"start-time,omitempty"`
	// End time of Rollout
	EndTime *api.Timestamp `protobuf:"bytes,7,opt,name=EndTime,json=end-time,omitempty" json:"end-time,omitempty"`
	// Version of the cluster before the start of rollout
	PreviousVersion string `protobuf:"bytes,8,opt,name=PreviousVersion,json=prev-version,omitempty,proto3" json:"prev-version,omitempty"`
}

func (m *RolloutStatus) Reset()                    { *m = RolloutStatus{} }
func (m *RolloutStatus) String() string            { return proto.CompactTextString(m) }
func (*RolloutStatus) ProtoMessage()               {}
func (*RolloutStatus) Descriptor() ([]byte, []int) { return fileDescriptorRollout, []int{3} }

func (m *RolloutStatus) GetControllerNodesStatus() []*RolloutPhase {
	if m != nil {
		return m.ControllerNodesStatus
	}
	return nil
}

func (m *RolloutStatus) GetControllerServicesStatus() []*RolloutPhase {
	if m != nil {
		return m.ControllerServicesStatus
	}
	return nil
}

func (m *RolloutStatus) GetSmartNICsStatus() []*RolloutPhase {
	if m != nil {
		return m.SmartNICsStatus
	}
	return nil
}

func (m *RolloutStatus) GetOperationalState() string {
	if m != nil {
		return m.OperationalState
	}
	return ""
}

func (m *RolloutStatus) GetCompletionPercentage() uint32 {
	if m != nil {
		return m.CompletionPercentage
	}
	return 0
}

func (m *RolloutStatus) GetStartTime() *api.Timestamp {
	if m != nil {
		return m.StartTime
	}
	return nil
}

func (m *RolloutStatus) GetEndTime() *api.Timestamp {
	if m != nil {
		return m.EndTime
	}
	return nil
}

func (m *RolloutStatus) GetPreviousVersion() string {
	if m != nil {
		return m.PreviousVersion
	}
	return ""
}

func init() {
	proto.RegisterType((*Rollout)(nil), "rollout.Rollout")
	proto.RegisterType((*RolloutPhase)(nil), "rollout.RolloutPhase")
	proto.RegisterType((*RolloutSpec)(nil), "rollout.RolloutSpec")
	proto.RegisterType((*RolloutStatus)(nil), "rollout.RolloutStatus")
	proto.RegisterEnum("rollout.RolloutPhase_Phases", RolloutPhase_Phases_name, RolloutPhase_Phases_value)
	proto.RegisterEnum("rollout.RolloutSpec_StrategyType", RolloutSpec_StrategyType_name, RolloutSpec_StrategyType_value)
	proto.RegisterEnum("rollout.RolloutSpec_SmartNICUpgradeType", RolloutSpec_SmartNICUpgradeType_name, RolloutSpec_SmartNICUpgradeType_value)
	proto.RegisterEnum("rollout.RolloutStatus_RolloutOperationalState", RolloutStatus_RolloutOperationalState_name, RolloutStatus_RolloutOperationalState_value)
}
func (m *Rollout) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Rollout) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintRollout(dAtA, i, uint64(m.TypeMeta.Size()))
	n1, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n1
	dAtA[i] = 0x12
	i++
	i = encodeVarintRollout(dAtA, i, uint64(m.ObjectMeta.Size()))
	n2, err := m.ObjectMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n2
	dAtA[i] = 0x1a
	i++
	i = encodeVarintRollout(dAtA, i, uint64(m.Spec.Size()))
	n3, err := m.Spec.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n3
	dAtA[i] = 0x22
	i++
	i = encodeVarintRollout(dAtA, i, uint64(m.Status.Size()))
	n4, err := m.Status.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n4
	return i, nil
}

func (m *RolloutPhase) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RolloutPhase) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRollout(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Phase) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRollout(dAtA, i, uint64(len(m.Phase)))
		i += copy(dAtA[i:], m.Phase)
	}
	if m.StartTime != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintRollout(dAtA, i, uint64(m.StartTime.Size()))
		n5, err := m.StartTime.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.EndTime != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintRollout(dAtA, i, uint64(m.EndTime.Size()))
		n6, err := m.EndTime.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if len(m.Reason) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintRollout(dAtA, i, uint64(len(m.Reason)))
		i += copy(dAtA[i:], m.Reason)
	}
	if len(m.Message) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintRollout(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	return i, nil
}

func (m *RolloutSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RolloutSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Version) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRollout(dAtA, i, uint64(len(m.Version)))
		i += copy(dAtA[i:], m.Version)
	}
	if m.ScheduledStartTime != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRollout(dAtA, i, uint64(m.ScheduledStartTime.Size()))
		n7, err := m.ScheduledStartTime.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if len(m.Duration) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintRollout(dAtA, i, uint64(len(m.Duration)))
		i += copy(dAtA[i:], m.Duration)
	}
	if len(m.Strategy) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintRollout(dAtA, i, uint64(len(m.Strategy)))
		i += copy(dAtA[i:], m.Strategy)
	}
	if m.MaxParallel != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintRollout(dAtA, i, uint64(m.MaxParallel))
	}
	if m.MaxNICFailuresBeforeAbort != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintRollout(dAtA, i, uint64(m.MaxNICFailuresBeforeAbort))
	}
	if len(m.OrderConstraints) > 0 {
		for _, msg := range m.OrderConstraints {
			dAtA[i] = 0x3a
			i++
			i = encodeVarintRollout(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Suspend {
		dAtA[i] = 0x40
		i++
		if m.Suspend {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.SmartNICsOnly {
		dAtA[i] = 0x48
		i++
		if m.SmartNICsOnly {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.SmartNICMustMatchConstraint {
		dAtA[i] = 0x50
		i++
		if m.SmartNICMustMatchConstraint {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.UpgradeType) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintRollout(dAtA, i, uint64(len(m.UpgradeType)))
		i += copy(dAtA[i:], m.UpgradeType)
	}
	return i, nil
}

func (m *RolloutStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RolloutStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ControllerNodesStatus) > 0 {
		for _, msg := range m.ControllerNodesStatus {
			dAtA[i] = 0xa
			i++
			i = encodeVarintRollout(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.ControllerServicesStatus) > 0 {
		for _, msg := range m.ControllerServicesStatus {
			dAtA[i] = 0x12
			i++
			i = encodeVarintRollout(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.SmartNICsStatus) > 0 {
		for _, msg := range m.SmartNICsStatus {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintRollout(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.OperationalState) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintRollout(dAtA, i, uint64(len(m.OperationalState)))
		i += copy(dAtA[i:], m.OperationalState)
	}
	if m.CompletionPercentage != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintRollout(dAtA, i, uint64(m.CompletionPercentage))
	}
	if m.StartTime != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintRollout(dAtA, i, uint64(m.StartTime.Size()))
		n8, err := m.StartTime.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.EndTime != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintRollout(dAtA, i, uint64(m.EndTime.Size()))
		n9, err := m.EndTime.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if len(m.PreviousVersion) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintRollout(dAtA, i, uint64(len(m.PreviousVersion)))
		i += copy(dAtA[i:], m.PreviousVersion)
	}
	return i, nil
}

func encodeVarintRollout(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Rollout) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovRollout(uint64(l))
	l = m.ObjectMeta.Size()
	n += 1 + l + sovRollout(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovRollout(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovRollout(uint64(l))
	return n
}

func (m *RolloutPhase) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovRollout(uint64(l))
	}
	l = len(m.Phase)
	if l > 0 {
		n += 1 + l + sovRollout(uint64(l))
	}
	if m.StartTime != nil {
		l = m.StartTime.Size()
		n += 1 + l + sovRollout(uint64(l))
	}
	if m.EndTime != nil {
		l = m.EndTime.Size()
		n += 1 + l + sovRollout(uint64(l))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovRollout(uint64(l))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovRollout(uint64(l))
	}
	return n
}

func (m *RolloutSpec) Size() (n int) {
	var l int
	_ = l
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovRollout(uint64(l))
	}
	if m.ScheduledStartTime != nil {
		l = m.ScheduledStartTime.Size()
		n += 1 + l + sovRollout(uint64(l))
	}
	l = len(m.Duration)
	if l > 0 {
		n += 1 + l + sovRollout(uint64(l))
	}
	l = len(m.Strategy)
	if l > 0 {
		n += 1 + l + sovRollout(uint64(l))
	}
	if m.MaxParallel != 0 {
		n += 1 + sovRollout(uint64(m.MaxParallel))
	}
	if m.MaxNICFailuresBeforeAbort != 0 {
		n += 1 + sovRollout(uint64(m.MaxNICFailuresBeforeAbort))
	}
	if len(m.OrderConstraints) > 0 {
		for _, e := range m.OrderConstraints {
			l = e.Size()
			n += 1 + l + sovRollout(uint64(l))
		}
	}
	if m.Suspend {
		n += 2
	}
	if m.SmartNICsOnly {
		n += 2
	}
	if m.SmartNICMustMatchConstraint {
		n += 2
	}
	l = len(m.UpgradeType)
	if l > 0 {
		n += 1 + l + sovRollout(uint64(l))
	}
	return n
}

func (m *RolloutStatus) Size() (n int) {
	var l int
	_ = l
	if len(m.ControllerNodesStatus) > 0 {
		for _, e := range m.ControllerNodesStatus {
			l = e.Size()
			n += 1 + l + sovRollout(uint64(l))
		}
	}
	if len(m.ControllerServicesStatus) > 0 {
		for _, e := range m.ControllerServicesStatus {
			l = e.Size()
			n += 1 + l + sovRollout(uint64(l))
		}
	}
	if len(m.SmartNICsStatus) > 0 {
		for _, e := range m.SmartNICsStatus {
			l = e.Size()
			n += 1 + l + sovRollout(uint64(l))
		}
	}
	l = len(m.OperationalState)
	if l > 0 {
		n += 1 + l + sovRollout(uint64(l))
	}
	if m.CompletionPercentage != 0 {
		n += 1 + sovRollout(uint64(m.CompletionPercentage))
	}
	if m.StartTime != nil {
		l = m.StartTime.Size()
		n += 1 + l + sovRollout(uint64(l))
	}
	if m.EndTime != nil {
		l = m.EndTime.Size()
		n += 1 + l + sovRollout(uint64(l))
	}
	l = len(m.PreviousVersion)
	if l > 0 {
		n += 1 + l + sovRollout(uint64(l))
	}
	return n
}

func sovRollout(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozRollout(x uint64) (n int) {
	return sovRollout(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Rollout) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRollout
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Rollout: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Rollout: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRollout
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRollout
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRollout
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRollout
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRollout
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRollout
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRollout
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRollout
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRollout(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRollout
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RolloutPhase) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRollout
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RolloutPhase: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RolloutPhase: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRollout
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRollout
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phase", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRollout
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRollout
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Phase = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRollout
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRollout
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StartTime == nil {
				m.StartTime = &api.Timestamp{}
			}
			if err := m.StartTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRollout
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRollout
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EndTime == nil {
				m.EndTime = &api.Timestamp{}
			}
			if err := m.EndTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRollout
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRollout
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRollout
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRollout
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRollout(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRollout
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RolloutSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRollout
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RolloutSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RolloutSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRollout
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRollout
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScheduledStartTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRollout
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRollout
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ScheduledStartTime == nil {
				m.ScheduledStartTime = &api.Timestamp{}
			}
			if err := m.ScheduledStartTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRollout
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRollout
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Duration = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Strategy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRollout
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRollout
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Strategy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxParallel", wireType)
			}
			m.MaxParallel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRollout
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxParallel |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxNICFailuresBeforeAbort", wireType)
			}
			m.MaxNICFailuresBeforeAbort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRollout
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxNICFailuresBeforeAbort |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderConstraints", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRollout
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRollout
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderConstraints = append(m.OrderConstraints, &labels.Selector{})
			if err := m.OrderConstraints[len(m.OrderConstraints)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Suspend", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRollout
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Suspend = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SmartNICsOnly", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRollout
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SmartNICsOnly = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SmartNICMustMatchConstraint", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRollout
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SmartNICMustMatchConstraint = bool(v != 0)
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpgradeType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRollout
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRollout
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpgradeType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRollout(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRollout
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RolloutStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRollout
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RolloutStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RolloutStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ControllerNodesStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRollout
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRollout
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ControllerNodesStatus = append(m.ControllerNodesStatus, &RolloutPhase{})
			if err := m.ControllerNodesStatus[len(m.ControllerNodesStatus)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ControllerServicesStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRollout
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRollout
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ControllerServicesStatus = append(m.ControllerServicesStatus, &RolloutPhase{})
			if err := m.ControllerServicesStatus[len(m.ControllerServicesStatus)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SmartNICsStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRollout
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRollout
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SmartNICsStatus = append(m.SmartNICsStatus, &RolloutPhase{})
			if err := m.SmartNICsStatus[len(m.SmartNICsStatus)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperationalState", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRollout
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRollout
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OperationalState = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompletionPercentage", wireType)
			}
			m.CompletionPercentage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRollout
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CompletionPercentage |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRollout
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRollout
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StartTime == nil {
				m.StartTime = &api.Timestamp{}
			}
			if err := m.StartTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRollout
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRollout
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EndTime == nil {
				m.EndTime = &api.Timestamp{}
			}
			if err := m.EndTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreviousVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRollout
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRollout
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PreviousVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRollout(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRollout
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipRollout(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowRollout
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRollout
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRollout
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthRollout
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowRollout
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipRollout(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthRollout = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowRollout   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("rollout.proto", fileDescriptorRollout) }

var fileDescriptorRollout = []byte{
	// 1392 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x56, 0xcb, 0x6e, 0xdb, 0x46,
	0x14, 0x35, 0x6d, 0x59, 0x8f, 0x91, 0x15, 0x33, 0x13, 0xdb, 0xa1, 0x1c, 0xd7, 0x72, 0x84, 0x16,
	0x70, 0x5a, 0x53, 0x4a, 0x13, 0xa0, 0x45, 0xd3, 0x76, 0x61, 0x4a, 0x74, 0xa2, 0xc6, 0x7a, 0x94,
	0x94, 0x9b, 0x2c, 0x0a, 0x18, 0x14, 0x35, 0x91, 0x59, 0x90, 0x33, 0x04, 0x67, 0xe8, 0xda, 0xe8,
	0xae, 0x40, 0xbd, 0xe9, 0xae, 0x1f, 0xd1, 0x85, 0x81, 0xee, 0xfb, 0x09, 0x59, 0x06, 0xfd, 0x00,
	0xa1, 0x08, 0xba, 0xd2, 0x57, 0x14, 0x33, 0x22, 0x6d, 0x5a, 0x92, 0x9d, 0x64, 0x63, 0xe8, 0x3e,
	0xce, 0x99, 0xcb, 0x3b, 0xc7, 0xf7, 0x0e, 0x28, 0x04, 0xc4, 0x75, 0x49, 0xc8, 0x2a, 0x7e, 0x40,
	0x18, 0x81, 0x99, 0xc8, 0x5c, 0xdf, 0x18, 0x10, 0x32, 0x70, 0x51, 0xd5, 0xf2, 0x9d, 0xaa, 0x85,
	0x31, 0x61, 0x16, 0x73, 0x08, 0xa6, 0xe3, 0xb4, 0x75, 0x7d, 0xe0, 0xb0, 0xa3, 0xb0, 0x57, 0xb1,
	0x89, 0x57, 0xf5, 0x11, 0xa6, 0x16, 0xee, 0x93, 0x2a, 0xfd, 0xb9, 0x7a, 0x8c, 0xb0, 0x63, 0xa3,
	0x6a, 0xc8, 0x1c, 0x97, 0x72, 0xe8, 0x00, 0xe1, 0x24, 0xba, 0xea, 0x60, 0xdb, 0x0d, 0xfb, 0x28,
	0xa6, 0x51, 0x13, 0x34, 0x03, 0x32, 0x20, 0x55, 0xe1, 0xee, 0x85, 0xaf, 0x84, 0x25, 0x0c, 0xf1,
	0x2b, 0x4a, 0xff, 0xe4, 0x9a, 0x53, 0x79, 0x8d, 0x1e, 0x62, 0x56, 0x94, 0xf6, 0xf0, 0x86, 0x34,
	0xd7, 0xea, 0x21, 0x97, 0x56, 0x29, 0x72, 0x91, 0xcd, 0x48, 0x30, 0x46, 0x94, 0xff, 0x9e, 0x07,
	0x19, 0x63, 0xfc, 0xe1, 0xf0, 0x0b, 0x20, 0x75, 0x15, 0x69, 0x4b, 0xda, 0xce, 0x3f, 0x2a, 0x54,
	0x2c, 0xdf, 0xa9, 0x74, 0x4f, 0x7d, 0xd4, 0x44, 0xcc, 0xd2, 0xee, 0xbc, 0x1e, 0x96, 0xe6, 0xde,
	0x0c, 0x4b, 0xd2, 0x68, 0x58, 0xca, 0xec, 0x38, 0xd8, 0x75, 0x30, 0x32, 0xe2, 0x1f, 0x70, 0x0f,
	0x48, 0x6d, 0x65, 0x5e, 0xe0, 0x96, 0x05, 0xae, 0xdd, 0xfb, 0x09, 0xd9, 0x4c, 0x20, 0xd7, 0x13,
	0xc8, 0x5b, 0xbc, 0xd2, 0x1d, 0xe2, 0x39, 0x0c, 0x79, 0x3e, 0x3b, 0x35, 0x26, 0x6c, 0xf8, 0x1d,
	0x48, 0x99, 0x3e, 0xb2, 0x95, 0x05, 0x41, 0xb5, 0x52, 0x89, 0xef, 0x27, 0xaa, 0x8f, 0xc7, 0xb4,
	0x35, 0xce, 0xc7, 0xb9, 0xa8, 0x8f, 0xec, 0x24, 0xd7, 0x55, 0x1b, 0x1a, 0x20, 0x6d, 0x32, 0x8b,
	0x85, 0x54, 0x49, 0x09, 0xb6, 0xb5, 0x29, 0x36, 0x11, 0xd5, 0x94, 0x88, 0x4f, 0xa6, 0xc2, 0x4e,
	0x30, 0x4e, 0x79, 0x9e, 0x14, 0xfe, 0xf9, 0xad, 0x98, 0xbb, 0xd0, 0x49, 0xf9, 0xcf, 0x14, 0x58,
	0x8a, 0xc8, 0x3a, 0x47, 0x16, 0x45, 0xf0, 0x53, 0x90, 0x6a, 0x59, 0x1e, 0x12, 0x2d, 0xcc, 0x69,
	0xcb, 0xa3, 0x61, 0x29, 0x8f, 0x2d, 0x0f, 0xc5, 0xfd, 0x4a, 0x1a, 0xf0, 0x05, 0x58, 0x14, 0x20,
	0xd1, 0xb7, 0x9c, 0xf6, 0xe5, 0xf9, 0x59, 0x71, 0xc3, 0x64, 0x81, 0x8e, 0x43, 0x6f, 0x3b, 0x49,
	0x5a, 0x11, 0x7f, 0xe9, 0x83, 0xd7, 0xe3, 0x16, 0x2e, 0xfb, 0xdc, 0x4c, 0x54, 0x39, 0xe9, 0x80,
	0x07, 0x20, 0x67, 0x32, 0x2b, 0x60, 0x5d, 0xc7, 0x43, 0x51, 0x27, 0x6f, 0x8d, 0x2f, 0xd3, 0xf1,
	0x10, 0x65, 0x96, 0xe7, 0x6b, 0x1b, 0x11, 0xd9, 0x0a, 0xe5, 0x89, 0x2a, 0x73, 0xbc, 0x24, 0xe3,
	0x4c, 0x2f, 0x6c, 0x83, 0x8c, 0x8e, 0xfb, 0x82, 0x34, 0x35, 0x93, 0x74, 0x3d, 0x22, 0x85, 0x08,
	0xf7, 0x27, 0x29, 0x67, 0xf8, 0xe0, 0x13, 0x90, 0x36, 0x90, 0x45, 0x09, 0x56, 0x16, 0x45, 0x07,
	0x94, 0x08, 0x2f, 0x07, 0xc2, 0x9b, 0xbc, 0x88, 0x49, 0x0f, 0xfc, 0x16, 0x64, 0x9a, 0x88, 0x52,
	0x6b, 0x80, 0x94, 0xb4, 0x00, 0x17, 0x23, 0xf0, 0x6d, 0x6f, 0xec, 0x4e, 0xa0, 0xa7, 0x5d, 0x65,
	0x0c, 0xd2, 0xe3, 0xae, 0xc2, 0x02, 0xc8, 0x75, 0x0c, 0xfd, 0xb0, 0xf6, 0x4c, 0xaf, 0x3d, 0x97,
	0xe7, 0xe0, 0x1a, 0x80, 0x75, 0xbd, 0xa3, 0xb7, 0xea, 0x7a, 0xab, 0xd6, 0xd0, 0xcd, 0xc8, 0x2f,
	0xc1, 0x15, 0x20, 0xbf, 0xd8, 0x6d, 0x74, 0x1b, 0xad, 0xa7, 0x87, 0x7b, 0x6d, 0xe3, 0xb0, 0x7b,
	0x60, 0xb4, 0xe4, 0x79, 0xb8, 0x0c, 0xf2, 0x1d, 0xa3, 0xfd, 0xd4, 0xd0, 0x4d, 0xb3, 0xd1, 0x7a,
	0x2a, 0x2f, 0xc0, 0x25, 0x90, 0xad, 0xb5, 0x9b, 0x9d, 0x7d, 0xbd, 0xab, 0xcb, 0x29, 0x98, 0x05,
	0xa9, 0xbd, 0xdd, 0xc6, 0xbe, 0xbc, 0x58, 0xfe, 0x2b, 0x0b, 0xf2, 0x09, 0x0d, 0xc3, 0xc7, 0x20,
	0xf3, 0x03, 0x0a, 0xa8, 0x43, 0x70, 0x24, 0x15, 0xc8, 0x05, 0x7d, 0x3c, 0x76, 0xc5, 0x6a, 0x99,
	0xb0, 0x21, 0x06, 0xd0, 0xb4, 0x8f, 0x50, 0x3f, 0x74, 0x51, 0xff, 0xf2, 0x82, 0xe7, 0x67, 0xde,
	0x45, 0x79, 0x34, 0x2c, 0x6d, 0xd2, 0x38, 0x5b, 0x9d, 0x79, 0xcd, 0xef, 0x88, 0xc3, 0x2e, 0xc8,
	0xd6, 0xc3, 0x40, 0x0c, 0x2f, 0x21, 0xa3, 0x9c, 0x56, 0x39, 0x3f, 0x2b, 0xae, 0xe8, 0x3c, 0xd8,
	0x0e, 0xe2, 0xd0, 0xf6, 0xc3, 0x9d, 0x87, 0x0f, 0xf8, 0xad, 0xf7, 0x23, 0x47, 0xf2, 0xd6, 0xa7,
	0x7d, 0xb0, 0x09, 0xb2, 0x26, 0x0b, 0x2c, 0x86, 0x06, 0xa7, 0x42, 0x47, 0x39, 0xed, 0xf3, 0xf3,
	0xb3, 0xe2, 0xfd, 0x09, 0xe5, 0xf3, 0x2e, 0x55, 0xe2, 0x3c, 0x3e, 0x84, 0xf8, 0x11, 0x59, 0x1a,
	0x39, 0x8c, 0x8b, 0x5f, 0xf0, 0x31, 0xc8, 0x37, 0xad, 0x93, 0x8e, 0x15, 0x58, 0xae, 0x8b, 0x5c,
	0xa1, 0xa4, 0x82, 0x26, 0x8f, 0x86, 0xa5, 0x25, 0xcf, 0x3a, 0x51, 0xfd, 0xc8, 0x6f, 0x5c, 0xb1,
	0xa0, 0x0d, 0x8a, 0x4d, 0xeb, 0xa4, 0xd5, 0xa8, 0xed, 0x59, 0x8e, 0x1b, 0x06, 0x88, 0x6a, 0xe8,
	0x15, 0x09, 0xd0, 0x6e, 0x8f, 0x04, 0x4c, 0xe8, 0xa9, 0xa0, 0xdd, 0x1f, 0x0d, 0x4b, 0x1f, 0x71,
	0x10, 0x76, 0x6c, 0xf5, 0x55, 0x94, 0xa6, 0xf6, 0x44, 0x9e, 0x6a, 0xf1, 0x44, 0xe3, 0xe6, 0x30,
	0x3c, 0x02, 0x72, 0x3b, 0xe8, 0xa3, 0xa0, 0x46, 0x30, 0xaf, 0xd6, 0xc1, 0x8c, 0x2a, 0x99, 0xad,
	0x85, 0xed, 0xfc, 0x23, 0xb9, 0x32, 0x9e, 0xc4, 0x15, 0x33, 0x9a, 0xc4, 0x5a, 0x69, 0x34, 0x2c,
	0xdd, 0x23, 0x3c, 0x5b, 0xb5, 0x2f, 0xd3, 0x13, 0x9d, 0xbc, 0x29, 0x08, 0xbf, 0x02, 0x19, 0x33,
	0xa4, 0x3e, 0xc2, 0x7d, 0x25, 0xbb, 0x25, 0x6d, 0x67, 0xb5, 0x55, 0xfe, 0x8f, 0x40, 0xc7, 0xae,
	0xe4, 0x3f, 0xc2, 0x94, 0x0b, 0x36, 0x41, 0xc1, 0xf4, 0xac, 0x80, 0xb5, 0x1a, 0x35, 0xda, 0xc6,
	0xee, 0xa9, 0x92, 0x13, 0x04, 0x1b, 0xa3, 0x61, 0x49, 0xa1, 0x3c, 0x80, 0x1d, 0x9b, 0xaa, 0x04,
	0xbb, 0xa7, 0x09, 0x9e, 0x6b, 0x23, 0xf0, 0x17, 0x70, 0x2f, 0xa6, 0x6b, 0x86, 0x94, 0x35, 0x2d,
	0x66, 0x1f, 0x5d, 0x7e, 0xbf, 0x02, 0x04, 0xf9, 0xce, 0x68, 0x58, 0xda, 0x8e, 0x29, 0x54, 0x2f,
	0xa4, 0x4c, 0xf5, 0x78, 0x62, 0xe2, 0xeb, 0x12, 0x87, 0xbd, 0x77, 0x26, 0x3c, 0x04, 0xf9, 0x03,
	0x7f, 0x10, 0x58, 0x7d, 0xc4, 0x05, 0xa3, 0xe4, 0x85, 0xb8, 0xbe, 0x39, 0x3f, 0x2b, 0x6e, 0xcf,
	0x14, 0x57, 0x54, 0x67, 0x02, 0xc2, 0x35, 0xb6, 0x14, 0x8e, 0x6d, 0x95, 0x9d, 0xfa, 0xc8, 0xb8,
	0x62, 0x95, 0x3f, 0x03, 0x4b, 0x49, 0x49, 0x42, 0x00, 0xd2, 0xfb, 0x8d, 0x96, 0xbe, 0x6b, 0xc8,
	0x73, 0x7c, 0x14, 0xe8, 0x2f, 0x3b, 0xed, 0x96, 0xde, 0xea, 0x36, 0x76, 0xf7, 0x65, 0xa9, 0xfc,
	0x35, 0xb8, 0x33, 0xe3, 0x08, 0x78, 0x0b, 0x80, 0xba, 0x43, 0x83, 0xd0, 0x67, 0xce, 0x31, 0x92,
	0xe7, 0xf8, 0x60, 0x69, 0xe3, 0x16, 0x3a, 0x61, 0xcf, 0x08, 0x65, 0x06, 0xea, 0x11, 0xc2, 0x64,
	0xa9, 0xfc, 0x5f, 0x06, 0x14, 0xae, 0x6c, 0x29, 0xf8, 0xab, 0x04, 0x56, 0x6b, 0x04, 0x33, 0xbe,
	0x7a, 0x50, 0xd0, 0x22, 0x7d, 0x44, 0xa3, 0xed, 0x26, 0x09, 0x4d, 0xad, 0x4e, 0x6e, 0x37, 0x31,
	0xdf, 0xb4, 0x78, 0x6b, 0xdc, 0xb7, 0x2f, 0xb0, 0x2a, 0xe6, 0x60, 0x75, 0x6a, 0xdb, 0xbd, 0x3b,
	0x05, 0xfe, 0x2e, 0x01, 0xe5, 0xb2, 0x08, 0x13, 0x05, 0xc7, 0x8e, 0x7d, 0x51, 0xc7, 0xfc, 0x4d,
	0x75, 0xec, 0x44, 0x75, 0x7c, 0x9c, 0x38, 0x84, 0x46, 0xf8, 0xe9, 0x52, 0xde, 0x2b, 0x0b, 0x62,
	0xb0, 0x7c, 0xa1, 0xdd, 0xa8, 0x86, 0x85, 0x9b, 0x6a, 0x28, 0x47, 0x35, 0xac, 0x5f, 0xca, 0x77,
	0xea, 0xe4, 0x1b, 0x62, 0xd0, 0x07, 0x72, 0xdb, 0x47, 0xe3, 0x81, 0x66, 0xb9, 0xfc, 0x44, 0x14,
	0x4d, 0x30, 0xfd, 0xfc, 0xac, 0x58, 0x99, 0x14, 0x99, 0x80, 0xc7, 0x15, 0x4c, 0x02, 0xb9, 0xd4,
	0x96, 0xf9, 0x09, 0x57, 0x36, 0xf9, 0x84, 0x03, 0xfe, 0x08, 0x56, 0x6a, 0xc4, 0xf3, 0x5d, 0xc4,
	0x91, 0x1d, 0x14, 0xd8, 0x08, 0x33, 0xbe, 0xf2, 0xc6, 0x53, 0x6e, 0x6b, 0x34, 0x2c, 0x6d, 0xd8,
	0x17, 0x71, 0xd5, 0x1f, 0x27, 0x24, 0x08, 0x6f, 0x8c, 0xc2, 0xef, 0x93, 0xef, 0x84, 0xf4, 0xcc,
	0x35, 0xa2, 0x7c, 0xe0, 0x1b, 0xe1, 0xf9, 0xe5, 0x1b, 0x21, 0x33, 0x93, 0x70, 0xed, 0x03, 0xde,
	0x07, 0xcf, 0xc1, 0x72, 0x27, 0x40, 0xc7, 0x0e, 0x09, 0x69, 0xbc, 0x2c, 0xb3, 0xa2, 0xdd, 0xeb,
	0xa3, 0x61, 0x69, 0xcd, 0x0f, 0xd0, 0xb1, 0x1a, 0x6f, 0xc8, 0x4b, 0xa2, 0x6b, 0xfc, 0xe5, 0x3f,
	0x24, 0x70, 0xf7, 0x9a, 0xbb, 0x98, 0x5c, 0xe3, 0x73, 0x30, 0x0f, 0x32, 0x7c, 0x71, 0x1f, 0x18,
	0xba, 0x2c, 0x71, 0xc3, 0x3c, 0xa8, 0xd5, 0x74, 0xd3, 0x94, 0xe7, 0xf9, 0x73, 0xc1, 0xac, 0x3d,
	0xd3, 0xeb, 0x07, 0xfb, 0x7a, 0x5d, 0x5e, 0x10, 0xe6, 0x81, 0x29, 0xde, 0x0b, 0x75, 0x39, 0x05,
	0xef, 0x82, 0x3b, 0x91, 0x79, 0xd8, 0x68, 0x1d, 0xc6, 0x9c, 0xf2, 0x22, 0x5c, 0x05, 0xb7, 0xeb,
	0xfa, 0x6e, 0x9d, 0x4f, 0x8b, 0x43, 0xfd, 0x65, 0x4d, 0xd7, 0x79, 0x7e, 0x5a, 0x5b, 0x7a, 0xfd,
	0x76, 0x53, 0x7a, 0xf3, 0x76, 0x53, 0xfa, 0xf7, 0xed, 0xa6, 0xd4, 0x91, 0x7a, 0x69, 0xf1, 0x22,
	0x7f, 0xfc, 0x7f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x1f, 0x03, 0x9b, 0x82, 0x98, 0x0c, 0x00, 0x00,
}
