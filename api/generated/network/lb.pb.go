// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: lb.proto

/*
	Package network is a generated protocol buffer package.

	Service name

	It is generated from these files:
		lb.proto
		network.proto
		service.proto
		svc_network.proto

	It has these top-level messages:
		HealthCheckSpec
		LbPolicy
		LbPolicySpec
		LbPolicyStatus
		Network
		NetworkSpec
		NetworkStatus
		Service
		ServiceSpec
		ServiceStatus
		TLSClientPolicySpec
		TLSServerPolicySpec
		AutoMsgLbPolicyWatchHelper
		AutoMsgNetworkWatchHelper
		AutoMsgServiceWatchHelper
		LbPolicyList
		NetworkList
		ServiceList
*/
package network

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/pensando/grpc-gateway/third_party/googleapis/google/api"
import _ "github.com/pensando/sw/venice/utils/apigen/annotations"
import _ "github.com/gogo/protobuf/gogoproto"
import api "github.com/pensando/sw/api"
import _ "github.com/pensando/sw/api/labels"
import _ "github.com/pensando/sw/api/generated/cluster"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type HealthCheckSpec struct {
	// Health check interval
	Interval uint32 `protobuf:"varint,1,opt,name=Interval,proto3" json:"interval,omitempty"`
	// # of probes per interval
	ProbesPerInterval uint32 `protobuf:"varint,2,opt,name=ProbesPerInterval,proto3" json:"probes-per-interval,omitempty"`
	// probe URL
	ProbePortOrUrl string `protobuf:"bytes,3,opt,name=ProbePortOrUrl,proto3" json:"probe-port-or-url,omitempty"`
	// timeout for declaring backend down
	MaxTimeouts uint32 `protobuf:"varint,4,opt,name=MaxTimeouts,proto3" json:"max-timeouts,omitempty"`
	// # of successful probes before we declare the backend back up
	DeclareHealthyCount uint32 `protobuf:"varint,5,opt,name=DeclareHealthyCount,proto3" json:"declare-healthy-count,omitempty"`
}

func (m *HealthCheckSpec) Reset()                    { *m = HealthCheckSpec{} }
func (m *HealthCheckSpec) String() string            { return proto.CompactTextString(m) }
func (*HealthCheckSpec) ProtoMessage()               {}
func (*HealthCheckSpec) Descriptor() ([]byte, []int) { return fileDescriptorLb, []int{0} }

func (m *HealthCheckSpec) GetInterval() uint32 {
	if m != nil {
		return m.Interval
	}
	return 0
}

func (m *HealthCheckSpec) GetProbesPerInterval() uint32 {
	if m != nil {
		return m.ProbesPerInterval
	}
	return 0
}

func (m *HealthCheckSpec) GetProbePortOrUrl() string {
	if m != nil {
		return m.ProbePortOrUrl
	}
	return ""
}

func (m *HealthCheckSpec) GetMaxTimeouts() uint32 {
	if m != nil {
		return m.MaxTimeouts
	}
	return 0
}

func (m *HealthCheckSpec) GetDeclareHealthyCount() uint32 {
	if m != nil {
		return m.DeclareHealthyCount
	}
	return 0
}

type LbPolicy struct {
	// load balancing type
	api.TypeMeta `protobuf:"bytes,1,opt,name=T,embedded=T" json:",inline"`
	// load balancing algorithm
	api.ObjectMeta `protobuf:"bytes,2,opt,name=O,embedded=O" json:"meta,omitempty"`
	// session affinity
	Spec LbPolicySpec `protobuf:"bytes,3,opt,name=Spec" json:"spec,omitempty"`
	// health check policy
	Status LbPolicyStatus `protobuf:"bytes,4,opt,name=Status" json:"status,omitempty"`
}

func (m *LbPolicy) Reset()                    { *m = LbPolicy{} }
func (m *LbPolicy) String() string            { return proto.CompactTextString(m) }
func (*LbPolicy) ProtoMessage()               {}
func (*LbPolicy) Descriptor() ([]byte, []int) { return fileDescriptorLb, []int{1} }

func (m *LbPolicy) GetSpec() LbPolicySpec {
	if m != nil {
		return m.Spec
	}
	return LbPolicySpec{}
}

func (m *LbPolicy) GetStatus() LbPolicyStatus {
	if m != nil {
		return m.Status
	}
	return LbPolicyStatus{}
}

type LbPolicySpec struct {
	// list of service objects referring this lb-policy
	Type            string           `protobuf:"bytes,1,opt,name=Type,proto3" json:"type,omitempty"`
	Algorithm       string           `protobuf:"bytes,2,opt,name=Algorithm,proto3" json:"algorithm,omitempty"`
	SessionAffinity string           `protobuf:"bytes,3,opt,name=SessionAffinity,proto3" json:"session-affinity,omitempty"`
	HealthCheck     *HealthCheckSpec `protobuf:"bytes,4,opt,name=HealthCheck" json:"health-check,omitempty"`
}

func (m *LbPolicySpec) Reset()                    { *m = LbPolicySpec{} }
func (m *LbPolicySpec) String() string            { return proto.CompactTextString(m) }
func (*LbPolicySpec) ProtoMessage()               {}
func (*LbPolicySpec) Descriptor() ([]byte, []int) { return fileDescriptorLb, []int{2} }

func (m *LbPolicySpec) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *LbPolicySpec) GetAlgorithm() string {
	if m != nil {
		return m.Algorithm
	}
	return ""
}

func (m *LbPolicySpec) GetSessionAffinity() string {
	if m != nil {
		return m.SessionAffinity
	}
	return ""
}

func (m *LbPolicySpec) GetHealthCheck() *HealthCheckSpec {
	if m != nil {
		return m.HealthCheck
	}
	return nil
}

// LbPolicy represents a load balancer policy
type LbPolicyStatus struct {
	Services []string `protobuf:"bytes,1,rep,name=Services" json:"type,omitempty"`
}

func (m *LbPolicyStatus) Reset()                    { *m = LbPolicyStatus{} }
func (m *LbPolicyStatus) String() string            { return proto.CompactTextString(m) }
func (*LbPolicyStatus) ProtoMessage()               {}
func (*LbPolicyStatus) Descriptor() ([]byte, []int) { return fileDescriptorLb, []int{3} }

func (m *LbPolicyStatus) GetServices() []string {
	if m != nil {
		return m.Services
	}
	return nil
}

func init() {
	proto.RegisterType((*HealthCheckSpec)(nil), "network.HealthCheckSpec")
	proto.RegisterType((*LbPolicy)(nil), "network.LbPolicy")
	proto.RegisterType((*LbPolicySpec)(nil), "network.LbPolicySpec")
	proto.RegisterType((*LbPolicyStatus)(nil), "network.LbPolicyStatus")
}
func (m *HealthCheckSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HealthCheckSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Interval != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintLb(dAtA, i, uint64(m.Interval))
	}
	if m.ProbesPerInterval != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintLb(dAtA, i, uint64(m.ProbesPerInterval))
	}
	if len(m.ProbePortOrUrl) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintLb(dAtA, i, uint64(len(m.ProbePortOrUrl)))
		i += copy(dAtA[i:], m.ProbePortOrUrl)
	}
	if m.MaxTimeouts != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintLb(dAtA, i, uint64(m.MaxTimeouts))
	}
	if m.DeclareHealthyCount != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintLb(dAtA, i, uint64(m.DeclareHealthyCount))
	}
	return i, nil
}

func (m *LbPolicy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LbPolicy) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintLb(dAtA, i, uint64(m.TypeMeta.Size()))
	n1, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n1
	dAtA[i] = 0x12
	i++
	i = encodeVarintLb(dAtA, i, uint64(m.ObjectMeta.Size()))
	n2, err := m.ObjectMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n2
	dAtA[i] = 0x1a
	i++
	i = encodeVarintLb(dAtA, i, uint64(m.Spec.Size()))
	n3, err := m.Spec.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n3
	dAtA[i] = 0x22
	i++
	i = encodeVarintLb(dAtA, i, uint64(m.Status.Size()))
	n4, err := m.Status.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n4
	return i, nil
}

func (m *LbPolicySpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LbPolicySpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintLb(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.Algorithm) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintLb(dAtA, i, uint64(len(m.Algorithm)))
		i += copy(dAtA[i:], m.Algorithm)
	}
	if len(m.SessionAffinity) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintLb(dAtA, i, uint64(len(m.SessionAffinity)))
		i += copy(dAtA[i:], m.SessionAffinity)
	}
	if m.HealthCheck != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintLb(dAtA, i, uint64(m.HealthCheck.Size()))
		n5, err := m.HealthCheck.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	return i, nil
}

func (m *LbPolicyStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LbPolicyStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Services) > 0 {
		for _, s := range m.Services {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func encodeVarintLb(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *HealthCheckSpec) Size() (n int) {
	var l int
	_ = l
	if m.Interval != 0 {
		n += 1 + sovLb(uint64(m.Interval))
	}
	if m.ProbesPerInterval != 0 {
		n += 1 + sovLb(uint64(m.ProbesPerInterval))
	}
	l = len(m.ProbePortOrUrl)
	if l > 0 {
		n += 1 + l + sovLb(uint64(l))
	}
	if m.MaxTimeouts != 0 {
		n += 1 + sovLb(uint64(m.MaxTimeouts))
	}
	if m.DeclareHealthyCount != 0 {
		n += 1 + sovLb(uint64(m.DeclareHealthyCount))
	}
	return n
}

func (m *LbPolicy) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovLb(uint64(l))
	l = m.ObjectMeta.Size()
	n += 1 + l + sovLb(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovLb(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovLb(uint64(l))
	return n
}

func (m *LbPolicySpec) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovLb(uint64(l))
	}
	l = len(m.Algorithm)
	if l > 0 {
		n += 1 + l + sovLb(uint64(l))
	}
	l = len(m.SessionAffinity)
	if l > 0 {
		n += 1 + l + sovLb(uint64(l))
	}
	if m.HealthCheck != nil {
		l = m.HealthCheck.Size()
		n += 1 + l + sovLb(uint64(l))
	}
	return n
}

func (m *LbPolicyStatus) Size() (n int) {
	var l int
	_ = l
	if len(m.Services) > 0 {
		for _, s := range m.Services {
			l = len(s)
			n += 1 + l + sovLb(uint64(l))
		}
	}
	return n
}

func sovLb(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozLb(x uint64) (n int) {
	return sovLb(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *HealthCheckSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HealthCheckSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HealthCheckSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Interval", wireType)
			}
			m.Interval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Interval |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProbesPerInterval", wireType)
			}
			m.ProbesPerInterval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProbesPerInterval |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProbePortOrUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProbePortOrUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxTimeouts", wireType)
			}
			m.MaxTimeouts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxTimeouts |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeclareHealthyCount", wireType)
			}
			m.DeclareHealthyCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeclareHealthyCount |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipLb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LbPolicy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LbPolicy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LbPolicy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LbPolicySpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LbPolicySpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LbPolicySpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Algorithm", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Algorithm = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionAffinity", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionAffinity = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HealthCheck", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HealthCheck == nil {
				m.HealthCheck = &HealthCheckSpec{}
			}
			if err := m.HealthCheck.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LbPolicyStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LbPolicyStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LbPolicyStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Services", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Services = append(m.Services, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipLb(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowLb
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowLb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowLb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthLb
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowLb
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipLb(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthLb = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowLb   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("lb.proto", fileDescriptorLb) }

var fileDescriptorLb = []byte{
	// 693 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x7c, 0x94, 0x4f, 0x4f, 0x1b, 0x39,
	0x18, 0xc6, 0x77, 0x80, 0x85, 0xc4, 0xe1, 0xcf, 0xae, 0xd1, 0xb2, 0xb3, 0x81, 0x4d, 0x50, 0x56,
	0x68, 0xd1, 0x8a, 0x99, 0x41, 0x59, 0xa9, 0x12, 0x3d, 0x95, 0x40, 0xa5, 0xa2, 0x82, 0x12, 0x91,
	0xf4, 0xd0, 0xde, 0x3c, 0xc3, 0x4b, 0xe2, 0xe2, 0xd8, 0x23, 0xdb, 0x03, 0x44, 0x55, 0x8f, 0x95,
	0xfa, 0x2d, 0x7a, 0xe8, 0x97, 0xe1, 0x88, 0xfa, 0x01, 0x50, 0xc5, 0xb1, 0x9f, 0xa2, 0x1a, 0x8f,
	0x09, 0x2e, 0x50, 0x6e, 0x63, 0xbf, 0xcf, 0xf3, 0xf3, 0x3b, 0xcf, 0xbc, 0x1e, 0x54, 0x62, 0x71,
	0x98, 0x4a, 0xa1, 0x05, 0x9e, 0xe1, 0xa0, 0xcf, 0x84, 0x3c, 0xa9, 0xae, 0xf4, 0x85, 0xe8, 0x33,
	0x88, 0x48, 0x4a, 0x23, 0xc2, 0xb9, 0xd0, 0x44, 0x53, 0xc1, 0x55, 0x21, 0xab, 0x3e, 0xef, 0x53,
	0x3d, 0xc8, 0xe2, 0x30, 0x11, 0xc3, 0x28, 0x05, 0xae, 0x08, 0x3f, 0x12, 0x91, 0x3a, 0x8b, 0x4e,
	0x81, 0xd3, 0x04, 0xa2, 0x4c, 0x53, 0xa6, 0x72, 0x6b, 0x1f, 0xb8, 0xeb, 0x8e, 0x28, 0x4f, 0x58,
	0x76, 0x04, 0x37, 0x98, 0xc0, 0xc1, 0xf4, 0x45, 0x5f, 0x44, 0x66, 0x3b, 0xce, 0x8e, 0xcd, 0xca,
	0x2c, 0xcc, 0x93, 0x95, 0xaf, 0xfd, 0xe4, 0xd4, 0xbc, 0xc7, 0x21, 0x68, 0x62, 0x65, 0x9b, 0x8f,
	0xc8, 0x18, 0x89, 0x81, 0xa9, 0x48, 0x01, 0x83, 0x44, 0x0b, 0x69, 0x1d, 0xe1, 0x23, 0x0e, 0xa3,
	0x50, 0x91, 0x06, 0x4e, 0xb8, 0x2e, 0xf4, 0x8d, 0x8f, 0x93, 0x68, 0xe1, 0x05, 0x10, 0xa6, 0x07,
	0x3b, 0x03, 0x48, 0x4e, 0xba, 0x29, 0x24, 0xf8, 0x09, 0x2a, 0xed, 0x71, 0x0d, 0xf2, 0x94, 0x30,
	0xdf, 0x5b, 0xf5, 0xd6, 0xe7, 0x5a, 0xd5, 0x8b, 0xab, 0xba, 0xf7, 0xed, 0xaa, 0x8e, 0xa9, 0xdd,
	0xdf, 0x10, 0x43, 0xaa, 0x61, 0x98, 0xea, 0xd1, 0xe1, 0x58, 0x8b, 0xbb, 0xe8, 0xf7, 0x8e, 0x14,
	0x31, 0xa8, 0x0e, 0xc8, 0x31, 0x60, 0xc2, 0x00, 0xd6, 0x2c, 0xe0, 0xef, 0xd4, 0x08, 0x82, 0x14,
	0x64, 0xf0, 0x00, 0xeb, 0xbe, 0x1f, 0xbf, 0x44, 0xf3, 0x66, 0xb3, 0x23, 0xa4, 0x6e, 0xcb, 0x57,
	0x92, 0xf9, 0x93, 0xab, 0xde, 0x7a, 0xb9, 0xf5, 0x8f, 0x25, 0x2e, 0x1b, 0x62, 0x90, 0x0a, 0xa9,
	0x03, 0x21, 0x83, 0x4c, 0xba, 0xbc, 0x3b, 0x56, 0xfc, 0x0c, 0x55, 0x0e, 0xc8, 0x79, 0x8f, 0x0e,
	0x41, 0x64, 0x5a, 0xf9, 0x53, 0xa6, 0xb7, 0x9a, 0x25, 0x2d, 0x0d, 0xc9, 0x79, 0xa0, 0x6d, 0xcd,
	0x81, 0xb8, 0x16, 0xfc, 0x1a, 0x2d, 0xee, 0x42, 0xc2, 0x88, 0x84, 0x22, 0xb5, 0xd1, 0x8e, 0xc8,
	0xb8, 0xf6, 0x7f, 0x35, 0xa4, 0x7f, 0x2d, 0xa9, 0x7e, 0x54, 0x48, 0x82, 0x41, 0xa1, 0x09, 0x92,
	0x5c, 0xe4, 0x20, 0x1f, 0x62, 0x34, 0x3e, 0x4f, 0xa0, 0xd2, 0x7e, 0xdc, 0x11, 0x8c, 0x26, 0x23,
	0xbc, 0x89, 0xbc, 0x9e, 0x09, 0xbf, 0xd2, 0x9c, 0x0b, 0x49, 0x4a, 0xc3, 0xde, 0x28, 0x85, 0x03,
	0xd0, 0xa4, 0xb5, 0x78, 0x71, 0x55, 0xff, 0xe5, 0xb2, 0x38, 0x68, 0x66, 0x83, 0x72, 0x46, 0x39,
	0x1c, 0x7a, 0x3d, 0xbc, 0x85, 0xbc, 0xb6, 0x49, 0xbb, 0xd2, 0x5c, 0x30, 0x8e, 0x76, 0xfc, 0x16,
	0x12, 0x6d, 0x3c, 0x55, 0xc7, 0x33, 0x9f, 0xcf, 0x97, 0xd3, 0x8b, 0xd7, 0xc6, 0xdb, 0x68, 0x2a,
	0xff, 0xf0, 0x26, 0xd9, 0x4a, 0xf3, 0x8f, 0xd0, 0xde, 0x9c, 0xf0, 0xa6, 0x9b, 0xbc, 0xd8, 0x5a,
	0xca, 0x19, 0xb9, 0x5f, 0xa5, 0x90, 0x38, 0x7e, 0x63, 0xc5, 0x7b, 0x68, 0xba, 0xab, 0x89, 0xce,
	0x8a, 0x50, 0x2b, 0xcd, 0x3f, 0xef, 0x43, 0x4c, 0xb9, 0xe5, 0x5b, 0xcc, 0x6f, 0xca, 0xac, 0x1d,
	0x90, 0x05, 0x3c, 0x5d, 0xf9, 0xf2, 0xe1, 0x2f, 0x1f, 0x55, 0xa2, 0x77, 0xed, 0xb0, 0x67, 0x46,
	0xf5, 0x3d, 0x2e, 0xb3, 0x38, 0x48, 0x0d, 0xa5, 0xf1, 0x69, 0x02, 0xcd, 0xba, 0x7d, 0xe1, 0xff,
	0xd0, 0x54, 0x9e, 0x8d, 0x09, 0xab, 0x6c, 0xba, 0x34, 0x6f, 0xa9, 0x47, 0x29, 0xb8, 0x5d, 0xe6,
	0x1a, 0xbc, 0x85, 0xca, 0xdb, 0xac, 0x2f, 0x24, 0xd5, 0x83, 0xa1, 0xc9, 0xaa, 0xdc, 0x5a, 0xb6,
	0x86, 0x45, 0x72, 0x53, 0x70, 0x5c, 0xb7, 0x6a, 0xbc, 0x8f, 0x16, 0xba, 0xa0, 0x14, 0x15, 0x7c,
	0xfb, 0xf8, 0x98, 0x72, 0xaa, 0x47, 0x76, 0x10, 0x1b, 0x16, 0x50, 0x55, 0x45, 0x39, 0x20, 0xb6,
	0xee, 0x70, 0xee, 0x5a, 0xf1, 0x1b, 0x54, 0x71, 0x6e, 0x9d, 0xcd, 0xcc, 0x1f, 0x67, 0x76, 0xe7,
	0x46, 0xde, 0x8e, 0x68, 0x31, 0x50, 0x41, 0x92, 0x57, 0xdc, 0x11, 0x75, 0x0c, 0x8d, 0x5d, 0x34,
	0xff, 0x63, 0xe6, 0xb8, 0x89, 0x4a, 0x5d, 0x90, 0xa7, 0x34, 0x01, 0xe5, 0x7b, 0xab, 0x93, 0x8f,
	0xc4, 0x34, 0xd6, 0xb5, 0x66, 0x2f, 0xae, 0x6b, 0xde, 0xe5, 0x75, 0xcd, 0xfb, 0x7a, 0x5d, 0xf3,
	0x3a, 0x5e, 0x3c, 0x6d, 0xfe, 0x17, 0xff, 0x7f, 0x0f, 0x00, 0x00, 0xff, 0xff, 0x6e, 0xe1, 0x52,
	0xaa, 0x61, 0x05, 0x00, 0x00,
}
