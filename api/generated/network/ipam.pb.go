// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ipam.proto

/*
	Package network is a generated protocol buffer package.

	It is generated from these files:
		ipam.proto
		lb.proto
		network.proto
		networkinterface.proto
		service.proto
		svc_network.proto
		vrf.proto

	It has these top-level messages:
		DHCPRelayPolicy
		DHCPServer
		IPAMPolicy
		IPAMPolicySpec
		IPAMPolicyStatus
		HealthCheckSpec
		LbPolicy
		LbPolicySpec
		LbPolicyStatus
		Network
		NetworkSpec
		NetworkStatus
		NetworkInterface
		NetworkInterfaceHostStatus
		NetworkInterfaceSpec
		NetworkInterfaceStatus
		NetworkInterfaceUplinkStatus
		Service
		ServiceSpec
		ServiceStatus
		TLSClientPolicySpec
		TLSServerPolicySpec
		AutoMsgIPAMPolicyWatchHelper
		AutoMsgLbPolicyWatchHelper
		AutoMsgNetworkInterfaceWatchHelper
		AutoMsgNetworkWatchHelper
		AutoMsgServiceWatchHelper
		AutoMsgVirtualRouterWatchHelper
		IPAMPolicyList
		LbPolicyList
		NetworkInterfaceList
		NetworkList
		ServiceList
		VirtualRouterList
		VirtualRouter
		VirtualRouterSpec
		VirtualRouterStatus
*/
package network

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/pensando/grpc-gateway/third_party/googleapis/google/api"
import _ "github.com/pensando/sw/venice/utils/apigen/annotations"
import _ "github.com/gogo/protobuf/gogoproto"
import api "github.com/pensando/sw/api"
import _ "github.com/pensando/sw/api/labels"
import _ "github.com/pensando/sw/api/generated/cluster"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

//
type IPAMPolicySpec_IPAMType int32

const (
	//
	IPAMPolicySpec_DHCP_Relay IPAMPolicySpec_IPAMType = 0
)

var IPAMPolicySpec_IPAMType_name = map[int32]string{
	0: "DHCP_Relay",
}
var IPAMPolicySpec_IPAMType_value = map[string]int32{
	"DHCP_Relay": 0,
}

func (IPAMPolicySpec_IPAMType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorIpam, []int{3, 0}
}

//
type DHCPRelayPolicy struct {
	//
	Servers []*DHCPServer `protobuf:"bytes,1,rep,name=Servers,json=relay-servers,omitempty" json:"relay-servers,omitempty"`
}

func (m *DHCPRelayPolicy) Reset()                    { *m = DHCPRelayPolicy{} }
func (m *DHCPRelayPolicy) String() string            { return proto.CompactTextString(m) }
func (*DHCPRelayPolicy) ProtoMessage()               {}
func (*DHCPRelayPolicy) Descriptor() ([]byte, []int) { return fileDescriptorIpam, []int{0} }

func (m *DHCPRelayPolicy) GetServers() []*DHCPServer {
	if m != nil {
		return m.Servers
	}
	return nil
}

// DHCPServer specifies details about each server.
type DHCPServer struct {
	// IP Address of the server.
	IPAddress string `protobuf:"bytes,1,opt,name=IPAddress,json=ip-address,omitempty,proto3" json:"ip-address,omitempty"`
	// Destination VRF where the server is connected. An empty value specifies that the server is reachable in the same vrf as the one where the policy is attached.
	VirtualRouter string `protobuf:"bytes,2,opt,name=VirtualRouter,json=virtual-router,omitempty,proto3" json:"virtual-router,omitempty"`
}

func (m *DHCPServer) Reset()                    { *m = DHCPServer{} }
func (m *DHCPServer) String() string            { return proto.CompactTextString(m) }
func (*DHCPServer) ProtoMessage()               {}
func (*DHCPServer) Descriptor() ([]byte, []int) { return fileDescriptorIpam, []int{1} }

func (m *DHCPServer) GetIPAddress() string {
	if m != nil {
		return m.IPAddress
	}
	return ""
}

func (m *DHCPServer) GetVirtualRouter() string {
	if m != nil {
		return m.VirtualRouter
	}
	return ""
}

//
type IPAMPolicy struct {
	//
	api.TypeMeta `protobuf:"bytes,1,opt,name=T,json=,inline,embedded=T" json:",inline"`
	//
	api.ObjectMeta `protobuf:"bytes,2,opt,name=O,json=meta,omitempty,embedded=O" json:"meta,omitempty"`
	// Spec contains the configuration for the IPAM service.
	Spec IPAMPolicySpec `protobuf:"bytes,3,opt,name=Spec,json=spec,omitempty" json:"spec,omitempty"`
	// Status contains the current state of the IPAM service.
	Status IPAMPolicyStatus `protobuf:"bytes,4,opt,name=Status,json=status,omitempty" json:"status,omitempty"`
}

func (m *IPAMPolicy) Reset()                    { *m = IPAMPolicy{} }
func (m *IPAMPolicy) String() string            { return proto.CompactTextString(m) }
func (*IPAMPolicy) ProtoMessage()               {}
func (*IPAMPolicy) Descriptor() ([]byte, []int) { return fileDescriptorIpam, []int{2} }

func (m *IPAMPolicy) GetSpec() IPAMPolicySpec {
	if m != nil {
		return m.Spec
	}
	return IPAMPolicySpec{}
}

func (m *IPAMPolicy) GetStatus() IPAMPolicyStatus {
	if m != nil {
		return m.Status
	}
	return IPAMPolicyStatus{}
}

//
type IPAMPolicySpec struct {
	//
	Type string `protobuf:"bytes,1,opt,name=Type,json=type,omitempty,proto3" json:"type,omitempty"`
	//
	DHCPRelay *DHCPRelayPolicy `protobuf:"bytes,2,opt,name=DHCPRelay,json=dhcp-relay,omitempty" json:"dhcp-relay,omitempty"`
}

func (m *IPAMPolicySpec) Reset()                    { *m = IPAMPolicySpec{} }
func (m *IPAMPolicySpec) String() string            { return proto.CompactTextString(m) }
func (*IPAMPolicySpec) ProtoMessage()               {}
func (*IPAMPolicySpec) Descriptor() ([]byte, []int) { return fileDescriptorIpam, []int{3} }

func (m *IPAMPolicySpec) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *IPAMPolicySpec) GetDHCPRelay() *DHCPRelayPolicy {
	if m != nil {
		return m.DHCPRelay
	}
	return nil
}

//
type IPAMPolicyStatus struct {
}

func (m *IPAMPolicyStatus) Reset()                    { *m = IPAMPolicyStatus{} }
func (m *IPAMPolicyStatus) String() string            { return proto.CompactTextString(m) }
func (*IPAMPolicyStatus) ProtoMessage()               {}
func (*IPAMPolicyStatus) Descriptor() ([]byte, []int) { return fileDescriptorIpam, []int{4} }

func init() {
	proto.RegisterType((*DHCPRelayPolicy)(nil), "network.DHCPRelayPolicy")
	proto.RegisterType((*DHCPServer)(nil), "network.DHCPServer")
	proto.RegisterType((*IPAMPolicy)(nil), "network.IPAMPolicy")
	proto.RegisterType((*IPAMPolicySpec)(nil), "network.IPAMPolicySpec")
	proto.RegisterType((*IPAMPolicyStatus)(nil), "network.IPAMPolicyStatus")
	proto.RegisterEnum("network.IPAMPolicySpec_IPAMType", IPAMPolicySpec_IPAMType_name, IPAMPolicySpec_IPAMType_value)
}
func (m *DHCPRelayPolicy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DHCPRelayPolicy) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Servers) > 0 {
		for _, msg := range m.Servers {
			dAtA[i] = 0xa
			i++
			i = encodeVarintIpam(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *DHCPServer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DHCPServer) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.IPAddress) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintIpam(dAtA, i, uint64(len(m.IPAddress)))
		i += copy(dAtA[i:], m.IPAddress)
	}
	if len(m.VirtualRouter) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintIpam(dAtA, i, uint64(len(m.VirtualRouter)))
		i += copy(dAtA[i:], m.VirtualRouter)
	}
	return i, nil
}

func (m *IPAMPolicy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IPAMPolicy) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintIpam(dAtA, i, uint64(m.TypeMeta.Size()))
	n1, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n1
	dAtA[i] = 0x12
	i++
	i = encodeVarintIpam(dAtA, i, uint64(m.ObjectMeta.Size()))
	n2, err := m.ObjectMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n2
	dAtA[i] = 0x1a
	i++
	i = encodeVarintIpam(dAtA, i, uint64(m.Spec.Size()))
	n3, err := m.Spec.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n3
	dAtA[i] = 0x22
	i++
	i = encodeVarintIpam(dAtA, i, uint64(m.Status.Size()))
	n4, err := m.Status.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n4
	return i, nil
}

func (m *IPAMPolicySpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IPAMPolicySpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintIpam(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if m.DHCPRelay != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintIpam(dAtA, i, uint64(m.DHCPRelay.Size()))
		n5, err := m.DHCPRelay.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	return i, nil
}

func (m *IPAMPolicyStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IPAMPolicyStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func encodeVarintIpam(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *DHCPRelayPolicy) Size() (n int) {
	var l int
	_ = l
	if len(m.Servers) > 0 {
		for _, e := range m.Servers {
			l = e.Size()
			n += 1 + l + sovIpam(uint64(l))
		}
	}
	return n
}

func (m *DHCPServer) Size() (n int) {
	var l int
	_ = l
	l = len(m.IPAddress)
	if l > 0 {
		n += 1 + l + sovIpam(uint64(l))
	}
	l = len(m.VirtualRouter)
	if l > 0 {
		n += 1 + l + sovIpam(uint64(l))
	}
	return n
}

func (m *IPAMPolicy) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovIpam(uint64(l))
	l = m.ObjectMeta.Size()
	n += 1 + l + sovIpam(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovIpam(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovIpam(uint64(l))
	return n
}

func (m *IPAMPolicySpec) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovIpam(uint64(l))
	}
	if m.DHCPRelay != nil {
		l = m.DHCPRelay.Size()
		n += 1 + l + sovIpam(uint64(l))
	}
	return n
}

func (m *IPAMPolicyStatus) Size() (n int) {
	var l int
	_ = l
	return n
}

func sovIpam(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozIpam(x uint64) (n int) {
	return sovIpam(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *DHCPRelayPolicy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIpam
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DHCPRelayPolicy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DHCPRelayPolicy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Servers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpam
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIpam
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Servers = append(m.Servers, &DHCPServer{})
			if err := m.Servers[len(m.Servers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIpam(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIpam
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DHCPServer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIpam
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DHCPServer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DHCPServer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IPAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpam
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIpam
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IPAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VirtualRouter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpam
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIpam
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VirtualRouter = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIpam(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIpam
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IPAMPolicy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIpam
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IPAMPolicy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IPAMPolicy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpam
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIpam
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpam
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIpam
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpam
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIpam
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpam
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIpam
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIpam(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIpam
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IPAMPolicySpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIpam
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IPAMPolicySpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IPAMPolicySpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpam
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIpam
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DHCPRelay", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpam
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIpam
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DHCPRelay == nil {
				m.DHCPRelay = &DHCPRelayPolicy{}
			}
			if err := m.DHCPRelay.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIpam(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIpam
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IPAMPolicyStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIpam
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IPAMPolicyStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IPAMPolicyStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipIpam(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIpam
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipIpam(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowIpam
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowIpam
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowIpam
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthIpam
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowIpam
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipIpam(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthIpam = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowIpam   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("ipam.proto", fileDescriptorIpam) }

var fileDescriptorIpam = []byte{
	// 648 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x7c, 0x53, 0x4f, 0x6f, 0xd3, 0x4e,
	0x10, 0xad, 0xdb, 0xaa, 0x7f, 0x36, 0x6a, 0x1a, 0x6d, 0x7f, 0x3f, 0xea, 0x84, 0x2a, 0x29, 0x11,
	0x48, 0x01, 0x35, 0x36, 0x2a, 0x52, 0x0f, 0xdc, 0x1a, 0x28, 0xa2, 0x87, 0xd0, 0x28, 0x09, 0x1c,
	0xe0, 0x80, 0x36, 0xce, 0x34, 0x5d, 0xb0, 0x77, 0x57, 0xde, 0x75, 0xab, 0x08, 0x71, 0xa4, 0xe2,
	0x73, 0x70, 0xec, 0x27, 0xe9, 0x8d, 0x0a, 0x71, 0x8e, 0x50, 0x4e, 0x28, 0x17, 0xbe, 0x02, 0xda,
	0xb5, 0xdb, 0xda, 0xf4, 0xcf, 0xcd, 0x33, 0xf3, 0xde, 0x9b, 0xd9, 0xf1, 0x1b, 0x84, 0xa8, 0x20,
	0x81, 0x23, 0x42, 0xae, 0x38, 0x9e, 0x67, 0xa0, 0x8e, 0x78, 0xf8, 0xb1, 0xb4, 0x36, 0xe0, 0x7c,
	0xe0, 0x83, 0x4b, 0x04, 0x75, 0x09, 0x63, 0x5c, 0x11, 0x45, 0x39, 0x93, 0x31, 0xac, 0xb4, 0x33,
	0xa0, 0xea, 0x20, 0xea, 0x39, 0x1e, 0x0f, 0x5c, 0x01, 0x4c, 0x12, 0xd6, 0xe7, 0xae, 0x3c, 0x72,
	0x0f, 0x81, 0x51, 0x0f, 0xdc, 0x48, 0x51, 0x5f, 0x6a, 0xea, 0x00, 0x58, 0x9a, 0xed, 0x52, 0xe6,
	0xf9, 0x51, 0x1f, 0xce, 0x65, 0xea, 0x29, 0x99, 0x01, 0x1f, 0x70, 0xd7, 0xa4, 0x7b, 0xd1, 0xbe,
	0x89, 0x4c, 0x60, 0xbe, 0x12, 0xf8, 0x83, 0x1b, 0xba, 0xea, 0x19, 0x03, 0x50, 0x24, 0x81, 0x3d,
	0xbe, 0x05, 0xe6, 0x93, 0x1e, 0xf8, 0xd2, 0x95, 0xe0, 0x83, 0xa7, 0x78, 0x98, 0x30, 0x9c, 0x5b,
	0x18, 0x06, 0x21, 0x5d, 0x05, 0x8c, 0x30, 0x15, 0xe3, 0xab, 0x01, 0x5a, 0x7e, 0xfe, 0xf2, 0x59,
	0xab, 0x0d, 0x3e, 0x19, 0xb6, 0xb8, 0x4f, 0xbd, 0x21, 0x7e, 0x8b, 0xe6, 0x3b, 0x10, 0x1e, 0x42,
	0x28, 0x6d, 0x6b, 0x7d, 0xa6, 0x96, 0xdb, 0x5c, 0x71, 0x92, 0x55, 0x3a, 0x1a, 0x1a, 0xd7, 0x1a,
	0x77, 0x27, 0xa3, 0xca, 0x6a, 0xa8, 0x69, 0x75, 0x19, 0xa3, 0x37, 0x78, 0x40, 0x15, 0x04, 0x42,
	0x0d, 0xdb, 0x37, 0x15, 0xaa, 0xdf, 0x2d, 0x84, 0x2e, 0x45, 0x70, 0x13, 0x2d, 0xee, 0xb6, 0xb6,
	0xfb, 0xfd, 0x10, 0xa4, 0x6e, 0x66, 0xd5, 0x16, 0x1b, 0xf7, 0x4f, 0x8e, 0x8b, 0x0b, 0x71, 0xb2,
	0xf6, 0x70, 0x32, 0xaa, 0xfc, 0x47, 0x45, 0x9d, 0xc4, 0x88, 0x54, 0x83, 0x6b, 0xb3, 0x38, 0x44,
	0x4b, 0x6f, 0x68, 0xa8, 0x22, 0xe2, 0xb7, 0x79, 0xa4, 0x20, 0xb4, 0xa7, 0x8d, 0xe4, 0xf6, 0xb7,
	0xe3, 0xe2, 0x3d, 0xb4, 0xf0, 0x8a, 0x04, 0xd0, 0x6f, 0xc3, 0x3e, 0xfe, 0x3f, 0x79, 0x8e, 0x9b,
	0x01, 0x4f, 0x46, 0x15, 0xfb, 0x30, 0x4e, 0xd4, 0x43, 0x93, 0x49, 0xf5, 0xbb, 0xb1, 0x52, 0xfd,
	0x39, 0x8d, 0xd0, 0x6e, 0x6b, 0xbb, 0x99, 0x2c, 0x6f, 0x0b, 0x59, 0x5d, 0xf3, 0x92, 0xdc, 0xe6,
	0x92, 0x43, 0x04, 0x75, 0xba, 0x43, 0x01, 0x4d, 0x50, 0xa4, 0xb1, 0x72, 0x3a, 0xaa, 0x4c, 0x9d,
	0x8d, 0x2a, 0xd6, 0x64, 0x54, 0x99, 0xdf, 0xa0, 0xcc, 0xa7, 0x0c, 0xda, 0xe7, 0x1f, 0xf8, 0x05,
	0xb2, 0xf6, 0xcc, 0xb8, 0xb9, 0xcd, 0x65, 0xc3, 0xdb, 0xeb, 0x7d, 0x00, 0x4f, 0x19, 0x66, 0x29,
	0xc5, 0xcc, 0x6b, 0x77, 0xa4, 0x06, 0xfb, 0x27, 0xc6, 0x4d, 0x34, 0xdb, 0x11, 0xe0, 0xd9, 0x33,
	0x46, 0x6a, 0xf5, 0xe2, 0xcf, 0x5d, 0x8e, 0xa8, 0xcb, 0x8d, 0x3b, 0x5a, 0x52, 0xcb, 0x49, 0x01,
	0x5e, 0x5a, 0x2e, 0x1b, 0xe3, 0xd7, 0x68, 0xae, 0xa3, 0x88, 0x8a, 0xa4, 0x3d, 0x6b, 0x04, 0x8b,
	0xd7, 0x09, 0x1a, 0x40, 0xc3, 0x4e, 0x24, 0x0b, 0xd2, 0xc4, 0x29, 0xd1, 0x2b, 0x99, 0xa7, 0xeb,
	0x3f, 0xbe, 0x14, 0xd7, 0x50, 0xce, 0xfd, 0xb4, 0xe7, 0x74, 0x8d, 0x1b, 0x3f, 0xe3, 0x25, 0x7d,
	0xba, 0x75, 0xa1, 0x15, 0x29, 0xc8, 0xea, 0x1f, 0x0b, 0xe5, 0xb3, 0x33, 0xe3, 0x2e, 0x9a, 0xd5,
	0xcb, 0x4c, 0x7c, 0xb2, 0x75, 0x72, 0x5c, 0x5c, 0xef, 0xa8, 0x70, 0x87, 0x45, 0x41, 0x2d, 0x8b,
	0x34, 0xb3, 0x69, 0xa8, 0xf6, 0x4f, 0x5e, 0x0d, 0x05, 0xa4, 0x5f, 0x98, 0x8d, 0xf1, 0x3b, 0xb4,
	0x78, 0x71, 0x00, 0xc9, 0x0f, 0xb0, 0x33, 0x7e, 0x4f, 0x9d, 0x46, 0xc3, 0xd6, 0x86, 0xec, 0x1f,
	0x78, 0xa2, 0x6e, 0x0c, 0x9e, 0x36, 0xe4, 0x75, 0xd9, 0xea, 0x23, 0xb4, 0x70, 0x3e, 0x0b, 0x2e,
	0xc7, 0xce, 0x7f, 0x6f, 0xf4, 0x0a, 0x53, 0xa5, 0xfc, 0xf8, 0x6b, 0x11, 0x5d, 0xb2, 0xaa, 0x18,
	0x15, 0xae, 0xec, 0xb4, 0x70, 0x3a, 0x2e, 0x5b, 0x67, 0xe3, 0xb2, 0xf5, 0x6b, 0x5c, 0xb6, 0x7e,
	0x8f, 0xcb, 0x53, 0x2d, 0xab, 0x37, 0x67, 0x0e, 0xf7, 0xc9, 0xdf, 0x00, 0x00, 0x00, 0xff, 0xff,
	0x38, 0xfb, 0xeb, 0x8b, 0xec, 0x04, 0x00, 0x00,
}
