// Code generated by protoc-gen-grpc-pensando DO NOT EDIT.

/*
Package network is a auto generated package.
Input file: route.proto
*/
package network

import (
	"context"
	"errors"
	fmt "fmt"
	"strings"

	listerwatcher "github.com/pensando/sw/api/listerwatcher"
	"github.com/pensando/sw/venice/utils/kvstore"
	"github.com/pensando/sw/venice/utils/log"
	"github.com/pensando/sw/venice/utils/ref"

	"github.com/pensando/sw/api/interfaces"
	"github.com/pensando/sw/venice/globals"
	validators "github.com/pensando/sw/venice/utils/apigen/validators"
	"github.com/pensando/sw/venice/utils/runtime"
	"github.com/pensando/sw/venice/utils/transformers/storage"
)

// Dummy definitions to suppress nonused warnings
var _ kvstore.Interface
var _ log.Logger
var _ listerwatcher.WatcherClient

// BGPAuthStatus_AuthStatus_normal is a map of normalized values for the enum
var BGPAuthStatus_AuthStatus_normal = map[string]string{
	"disabled": "disabled",
	"enabled":  "enabled",
}

var BGPAuthStatus_AuthStatus_vname = map[int32]string{
	0: "disabled",
	1: "enabled",
}

var BGPAuthStatus_AuthStatus_vvalue = map[string]int32{
	"disabled": 0,
	"enabled":  1,
}

func (x BGPAuthStatus_AuthStatus) String() string {
	return BGPAuthStatus_AuthStatus_vname[int32(x)]
}

// RouteDistinguisher_RDType_normal is a map of normalized values for the enum
var RouteDistinguisher_RDType_normal = map[string]string{
	"type0": "type0",
	"type1": "type1",
	"type2": "type2",
}

var RouteDistinguisher_RDType_vname = map[int32]string{
	0: "type0",
	1: "type1",
	2: "type2",
}

var RouteDistinguisher_RDType_vvalue = map[string]int32{
	"type0": 0,
	"type1": 1,
	"type2": 2,
}

func (x RouteDistinguisher_RDType) String() string {
	return RouteDistinguisher_RDType_vname[int32(x)]
}

// BGPAddressFamily_normal is a map of normalized values for the enum
var BGPAddressFamily_normal = map[string]string{
	"ipv4-unicast": "ipv4-unicast",
	"l2vpn-evpn":   "l2vpn-evpn",
}

var BGPAddressFamily_vname = map[int32]string{
	0: "ipv4-unicast",
	1: "l2vpn-evpn",
}

var BGPAddressFamily_vvalue = map[string]int32{
	"ipv4-unicast": 0,
	"l2vpn-evpn":   1,
}

func (x BGPAddressFamily) String() string {
	return BGPAddressFamily_vname[int32(x)]
}

var _ validators.DummyVar
var validatorMapRoute = make(map[string]map[string][]func(string, interface{}) error)

var storageTransformersMapRoute = make(map[string][]func(ctx context.Context, i interface{}, toStorage bool) error)
var eraseSecretsMapRoute = make(map[string]func(i interface{}))

// MakeKey generates a KV store key for the object
func (m *RouteTable) MakeKey(prefix string) string {
	return fmt.Sprint(globals.ConfigRootPrefix, "/", prefix, "/", "route-tables/", m.Tenant, "/", m.Name)
}

func (m *RouteTable) MakeURI(cat, ver, prefix string) string {
	in := m
	return fmt.Sprint("/", cat, "/", prefix, "/", ver, "/tenant/", in.Tenant, "/route-tables/", in.Name)
}

// MakeKey generates a KV store key for the object
func (m *RoutingConfig) MakeKey(prefix string) string {
	return fmt.Sprint(globals.ConfigRootPrefix, "/", prefix, "/", "routing-config/", m.Name)
}

func (m *RoutingConfig) MakeURI(cat, ver, prefix string) string {
	in := m
	return fmt.Sprint("/", cat, "/", prefix, "/", ver, "/routing-config/", in.Name)
}

// Clone clones the object into into or creates one of into is nil
func (m *BGPAuthStatus) Clone(into interface{}) (interface{}, error) {
	var out *BGPAuthStatus
	var ok bool
	if into == nil {
		out = &BGPAuthStatus{}
	} else {
		out, ok = into.(*BGPAuthStatus)
		if !ok {
			return nil, fmt.Errorf("mismatched object types")
		}
	}
	*out = *(ref.DeepCopy(m).(*BGPAuthStatus))
	return out, nil
}

// Default sets up the defaults for the object
func (m *BGPAuthStatus) Defaults(ver string) bool {
	var ret bool
	ret = true
	switch ver {
	default:
		m.Status = "disabled"
	}
	return ret
}

// Clone clones the object into into or creates one of into is nil
func (m *BGPConfig) Clone(into interface{}) (interface{}, error) {
	var out *BGPConfig
	var ok bool
	if into == nil {
		out = &BGPConfig{}
	} else {
		out, ok = into.(*BGPConfig)
		if !ok {
			return nil, fmt.Errorf("mismatched object types")
		}
	}
	*out = *(ref.DeepCopy(m).(*BGPConfig))
	return out, nil
}

// Default sets up the defaults for the object
func (m *BGPConfig) Defaults(ver string) bool {
	var ret bool
	for k := range m.Neighbors {
		if m.Neighbors[k] != nil {
			i := m.Neighbors[k]
			ret = i.Defaults(ver) || ret
		}
	}
	ret = true
	switch ver {
	default:
		m.Holdtime = 180
		m.KeepaliveInterval = 60
	}
	return ret
}

// Clone clones the object into into or creates one of into is nil
func (m *BGPNeighbor) Clone(into interface{}) (interface{}, error) {
	var out *BGPNeighbor
	var ok bool
	if into == nil {
		out = &BGPNeighbor{}
	} else {
		out, ok = into.(*BGPNeighbor)
		if !ok {
			return nil, fmt.Errorf("mismatched object types")
		}
	}
	*out = *(ref.DeepCopy(m).(*BGPNeighbor))
	return out, nil
}

// Default sets up the defaults for the object
func (m *BGPNeighbor) Defaults(ver string) bool {
	var ret bool
	ret = true
	switch ver {
	default:
		for k := range m.EnableAddressFamilies {
			m.EnableAddressFamilies[k] = "ipv4-unicast"
		}
		m.MultiHop = 64
	}
	return ret
}

// Clone clones the object into into or creates one of into is nil
func (m *EVPNConfig) Clone(into interface{}) (interface{}, error) {
	var out *EVPNConfig
	var ok bool
	if into == nil {
		out = &EVPNConfig{}
	} else {
		out, ok = into.(*EVPNConfig)
		if !ok {
			return nil, fmt.Errorf("mismatched object types")
		}
	}
	*out = *(ref.DeepCopy(m).(*EVPNConfig))
	return out, nil
}

// Default sets up the defaults for the object
func (m *EVPNConfig) Defaults(ver string) bool {
	return false
}

// Clone clones the object into into or creates one of into is nil
func (m *RDSpec) Clone(into interface{}) (interface{}, error) {
	var out *RDSpec
	var ok bool
	if into == nil {
		out = &RDSpec{}
	} else {
		out, ok = into.(*RDSpec)
		if !ok {
			return nil, fmt.Errorf("mismatched object types")
		}
	}
	*out = *(ref.DeepCopy(m).(*RDSpec))
	return out, nil
}

// Default sets up the defaults for the object
func (m *RDSpec) Defaults(ver string) bool {
	var ret bool
	for k := range m.ExportRTs {
		if m.ExportRTs[k] != nil {
			i := m.ExportRTs[k]
			ret = i.Defaults(ver) || ret
		}
	}
	for k := range m.ImportRTs {
		if m.ImportRTs[k] != nil {
			i := m.ImportRTs[k]
			ret = i.Defaults(ver) || ret
		}
	}
	if m.RD != nil {
		ret = m.RD.Defaults(ver) || ret
	}
	ret = true
	switch ver {
	default:
		m.AddressFamily = "ipv4-unicast"
	}
	return ret
}

// Clone clones the object into into or creates one of into is nil
func (m *Route) Clone(into interface{}) (interface{}, error) {
	var out *Route
	var ok bool
	if into == nil {
		out = &Route{}
	} else {
		out, ok = into.(*Route)
		if !ok {
			return nil, fmt.Errorf("mismatched object types")
		}
	}
	*out = *(ref.DeepCopy(m).(*Route))
	return out, nil
}

// Default sets up the defaults for the object
func (m *Route) Defaults(ver string) bool {
	var ret bool
	return ret
}

// Clone clones the object into into or creates one of into is nil
func (m *RouteDistinguisher) Clone(into interface{}) (interface{}, error) {
	var out *RouteDistinguisher
	var ok bool
	if into == nil {
		out = &RouteDistinguisher{}
	} else {
		out, ok = into.(*RouteDistinguisher)
		if !ok {
			return nil, fmt.Errorf("mismatched object types")
		}
	}
	*out = *(ref.DeepCopy(m).(*RouteDistinguisher))
	return out, nil
}

// Default sets up the defaults for the object
func (m *RouteDistinguisher) Defaults(ver string) bool {
	var ret bool
	ret = true
	switch ver {
	default:
		m.Type = "type0"
	}
	return ret
}

// Clone clones the object into into or creates one of into is nil
func (m *RouteTable) Clone(into interface{}) (interface{}, error) {
	var out *RouteTable
	var ok bool
	if into == nil {
		out = &RouteTable{}
	} else {
		out, ok = into.(*RouteTable)
		if !ok {
			return nil, fmt.Errorf("mismatched object types")
		}
	}
	*out = *(ref.DeepCopy(m).(*RouteTable))
	return out, nil
}

// Default sets up the defaults for the object
func (m *RouteTable) Defaults(ver string) bool {
	var ret bool
	m.Kind = "RouteTable"
	ret = m.Tenant != "default" || m.Namespace != "default"
	if ret {
		m.Tenant, m.Namespace = "default", "default"
	}
	ret = m.Status.Defaults(ver) || ret
	return ret
}

// Clone clones the object into into or creates one of into is nil
func (m *RouteTableSpec) Clone(into interface{}) (interface{}, error) {
	var out *RouteTableSpec
	var ok bool
	if into == nil {
		out = &RouteTableSpec{}
	} else {
		out, ok = into.(*RouteTableSpec)
		if !ok {
			return nil, fmt.Errorf("mismatched object types")
		}
	}
	*out = *(ref.DeepCopy(m).(*RouteTableSpec))
	return out, nil
}

// Default sets up the defaults for the object
func (m *RouteTableSpec) Defaults(ver string) bool {
	return false
}

// Clone clones the object into into or creates one of into is nil
func (m *RouteTableStatus) Clone(into interface{}) (interface{}, error) {
	var out *RouteTableStatus
	var ok bool
	if into == nil {
		out = &RouteTableStatus{}
	} else {
		out, ok = into.(*RouteTableStatus)
		if !ok {
			return nil, fmt.Errorf("mismatched object types")
		}
	}
	*out = *(ref.DeepCopy(m).(*RouteTableStatus))
	return out, nil
}

// Default sets up the defaults for the object
func (m *RouteTableStatus) Defaults(ver string) bool {
	var ret bool
	for k := range m.Routes {
		if m.Routes[k] != nil {
			i := m.Routes[k]
			ret = i.Defaults(ver) || ret
		}
	}
	return ret
}

// Clone clones the object into into or creates one of into is nil
func (m *RoutingConfig) Clone(into interface{}) (interface{}, error) {
	var out *RoutingConfig
	var ok bool
	if into == nil {
		out = &RoutingConfig{}
	} else {
		out, ok = into.(*RoutingConfig)
		if !ok {
			return nil, fmt.Errorf("mismatched object types")
		}
	}
	*out = *(ref.DeepCopy(m).(*RoutingConfig))
	return out, nil
}

// Default sets up the defaults for the object
func (m *RoutingConfig) Defaults(ver string) bool {
	var ret bool
	m.Kind = "RoutingConfig"
	ret = m.Tenant != "" || m.Namespace != ""
	if ret {
		m.Tenant, m.Namespace = "", ""
	}
	ret = m.Spec.Defaults(ver) || ret
	ret = m.Status.Defaults(ver) || ret
	return ret
}

// Clone clones the object into into or creates one of into is nil
func (m *RoutingConfigSpec) Clone(into interface{}) (interface{}, error) {
	var out *RoutingConfigSpec
	var ok bool
	if into == nil {
		out = &RoutingConfigSpec{}
	} else {
		out, ok = into.(*RoutingConfigSpec)
		if !ok {
			return nil, fmt.Errorf("mismatched object types")
		}
	}
	*out = *(ref.DeepCopy(m).(*RoutingConfigSpec))
	return out, nil
}

// Default sets up the defaults for the object
func (m *RoutingConfigSpec) Defaults(ver string) bool {
	var ret bool
	if m.BGPConfig != nil {
		ret = m.BGPConfig.Defaults(ver) || ret
	}
	return ret
}

// Clone clones the object into into or creates one of into is nil
func (m *RoutingConfigStatus) Clone(into interface{}) (interface{}, error) {
	var out *RoutingConfigStatus
	var ok bool
	if into == nil {
		out = &RoutingConfigStatus{}
	} else {
		out, ok = into.(*RoutingConfigStatus)
		if !ok {
			return nil, fmt.Errorf("mismatched object types")
		}
	}
	*out = *(ref.DeepCopy(m).(*RoutingConfigStatus))
	return out, nil
}

// Default sets up the defaults for the object
func (m *RoutingConfigStatus) Defaults(ver string) bool {
	var ret bool
	for k := range m.AuthConfigStatus {
		if m.AuthConfigStatus[k] != nil {
			i := m.AuthConfigStatus[k]
			ret = i.Defaults(ver) || ret
		}
	}
	return ret
}

// Validators and Requirements

func (m *BGPAuthStatus) References(tenant string, path string, resp map[string]apiintf.ReferenceObj) {

}

func (m *BGPAuthStatus) Validate(ver, path string, ignoreStatus bool, ignoreSpec bool) []error {
	var ret []error
	if vs, ok := validatorMapRoute["BGPAuthStatus"][ver]; ok {
		for _, v := range vs {
			if err := v(path, m); err != nil {
				ret = append(ret, err)
			}
		}
	} else if vs, ok := validatorMapRoute["BGPAuthStatus"]["all"]; ok {
		for _, v := range vs {
			if err := v(path, m); err != nil {
				ret = append(ret, err)
			}
		}
	}
	return ret
}

func (m *BGPAuthStatus) Normalize() {

	m.Status = BGPAuthStatus_AuthStatus_normal[strings.ToLower(m.Status)]

}

func (m *BGPConfig) References(tenant string, path string, resp map[string]apiintf.ReferenceObj) {

}

func (m *BGPConfig) Validate(ver, path string, ignoreStatus bool, ignoreSpec bool) []error {
	var ret []error
	for k, v := range m.Neighbors {
		dlmtr := "."
		if path == "" {
			dlmtr = ""
		}
		npath := fmt.Sprintf("%s%sNeighbors[%v]", path, dlmtr, k)
		if errs := v.Validate(ver, npath, ignoreStatus, ignoreSpec); errs != nil {
			ret = append(ret, errs...)
		}
	}
	if vs, ok := validatorMapRoute["BGPConfig"][ver]; ok {
		for _, v := range vs {
			if err := v(path, m); err != nil {
				ret = append(ret, err)
			}
		}
	} else if vs, ok := validatorMapRoute["BGPConfig"]["all"]; ok {
		for _, v := range vs {
			if err := v(path, m); err != nil {
				ret = append(ret, err)
			}
		}
	}
	return ret
}

func (m *BGPConfig) Normalize() {

	for k, v := range m.Neighbors {
		if v != nil {
			v.Normalize()
			m.Neighbors[k] = v
		}
	}

}

func (m *BGPNeighbor) References(tenant string, path string, resp map[string]apiintf.ReferenceObj) {

}

func (m *BGPNeighbor) Validate(ver, path string, ignoreStatus bool, ignoreSpec bool) []error {
	var ret []error
	if vs, ok := validatorMapRoute["BGPNeighbor"][ver]; ok {
		for _, v := range vs {
			if err := v(path, m); err != nil {
				ret = append(ret, err)
			}
		}
	} else if vs, ok := validatorMapRoute["BGPNeighbor"]["all"]; ok {
		for _, v := range vs {
			if err := v(path, m); err != nil {
				ret = append(ret, err)
			}
		}
	}
	return ret
}

func (m *BGPNeighbor) Normalize() {

	for k, v := range m.EnableAddressFamilies {
		m.EnableAddressFamilies[k] = BGPAddressFamily_normal[strings.ToLower(v)]
	}

}

func (m *EVPNConfig) References(tenant string, path string, resp map[string]apiintf.ReferenceObj) {

}

func (m *EVPNConfig) Validate(ver, path string, ignoreStatus bool, ignoreSpec bool) []error {
	var ret []error
	return ret
}

func (m *EVPNConfig) Normalize() {

}

func (m *RDSpec) References(tenant string, path string, resp map[string]apiintf.ReferenceObj) {

}

func (m *RDSpec) Validate(ver, path string, ignoreStatus bool, ignoreSpec bool) []error {
	var ret []error
	for k, v := range m.ExportRTs {
		dlmtr := "."
		if path == "" {
			dlmtr = ""
		}
		npath := fmt.Sprintf("%s%sExportRTs[%v]", path, dlmtr, k)
		if errs := v.Validate(ver, npath, ignoreStatus, ignoreSpec); errs != nil {
			ret = append(ret, errs...)
		}
	}
	for k, v := range m.ImportRTs {
		dlmtr := "."
		if path == "" {
			dlmtr = ""
		}
		npath := fmt.Sprintf("%s%sImportRTs[%v]", path, dlmtr, k)
		if errs := v.Validate(ver, npath, ignoreStatus, ignoreSpec); errs != nil {
			ret = append(ret, errs...)
		}
	}

	if m.RD != nil {
		{
			dlmtr := "."
			if path == "" {
				dlmtr = ""
			}
			npath := path + dlmtr + "RD"
			if errs := m.RD.Validate(ver, npath, ignoreStatus, ignoreSpec); errs != nil {
				ret = append(ret, errs...)
			}
		}
	}
	if vs, ok := validatorMapRoute["RDSpec"][ver]; ok {
		for _, v := range vs {
			if err := v(path, m); err != nil {
				ret = append(ret, err)
			}
		}
	} else if vs, ok := validatorMapRoute["RDSpec"]["all"]; ok {
		for _, v := range vs {
			if err := v(path, m); err != nil {
				ret = append(ret, err)
			}
		}
	}
	return ret
}

func (m *RDSpec) Normalize() {

	m.AddressFamily = BGPAddressFamily_normal[strings.ToLower(m.AddressFamily)]

	for k, v := range m.ExportRTs {
		if v != nil {
			v.Normalize()
			m.ExportRTs[k] = v
		}
	}

	for k, v := range m.ImportRTs {
		if v != nil {
			v.Normalize()
			m.ImportRTs[k] = v
		}
	}

	if m.RD != nil {
		m.RD.Normalize()
	}

}

func (m *Route) References(tenant string, path string, resp map[string]apiintf.ReferenceObj) {

	{

		dlmtr := "."
		if path == "" {
			dlmtr = ""
		}
		tag := path + dlmtr + "target-virtual-router"
		uref, ok := resp[tag]
		if !ok {
			uref = apiintf.ReferenceObj{
				RefType: apiintf.ReferenceType("WeakRef"),
				RefKind: "VirtualRouter",
			}
		}

		if m.TargetVirtualRouter != "" {
			uref.Refs = append(uref.Refs, globals.ConfigRootPrefix+"/network/"+"virtualrouters/"+tenant+"/"+m.TargetVirtualRouter)
		}

		if len(uref.Refs) > 0 {
			resp[tag] = uref
		}
	}
}

func (m *Route) Validate(ver, path string, ignoreStatus bool, ignoreSpec bool) []error {
	var ret []error
	if vs, ok := validatorMapRoute["Route"][ver]; ok {
		for _, v := range vs {
			if err := v(path, m); err != nil {
				ret = append(ret, err)
			}
		}
	} else if vs, ok := validatorMapRoute["Route"]["all"]; ok {
		for _, v := range vs {
			if err := v(path, m); err != nil {
				ret = append(ret, err)
			}
		}
	}
	return ret
}

func (m *Route) Normalize() {

}

func (m *RouteDistinguisher) References(tenant string, path string, resp map[string]apiintf.ReferenceObj) {

}

func (m *RouteDistinguisher) Validate(ver, path string, ignoreStatus bool, ignoreSpec bool) []error {
	var ret []error
	if vs, ok := validatorMapRoute["RouteDistinguisher"][ver]; ok {
		for _, v := range vs {
			if err := v(path, m); err != nil {
				ret = append(ret, err)
			}
		}
	} else if vs, ok := validatorMapRoute["RouteDistinguisher"]["all"]; ok {
		for _, v := range vs {
			if err := v(path, m); err != nil {
				ret = append(ret, err)
			}
		}
	}
	return ret
}

func (m *RouteDistinguisher) Normalize() {

	m.Type = RouteDistinguisher_RDType_normal[strings.ToLower(m.Type)]

}

func (m *RouteTable) References(tenant string, path string, resp map[string]apiintf.ReferenceObj) {

	tenant = m.Tenant

	{

		dlmtr := "."
		if path == "" {
			dlmtr = ""
		}
		tag := path + dlmtr + "status"

		m.Status.References(tenant, tag, resp)

	}
	{

		dlmtr := "."
		if path == "" {
			dlmtr = ""
		}
		tag := path + dlmtr + "meta.tenant"
		uref, ok := resp[tag]
		if !ok {
			uref = apiintf.ReferenceObj{
				RefType: apiintf.ReferenceType("NamedRef"),
				RefKind: "Tenant",
			}
		}

		if m.Tenant != "" {
			uref.Refs = append(uref.Refs, globals.ConfigRootPrefix+"/cluster/"+"tenants/"+m.Tenant)
		}

		if len(uref.Refs) > 0 {
			resp[tag] = uref
		}
	}
}

func (m *RouteTable) Validate(ver, path string, ignoreStatus bool, ignoreSpec bool) []error {
	var ret []error

	if m.Namespace != "default" {
		ret = append(ret, errors.New("Only Namespace default is allowed for RouteTable"))
	}

	{
		dlmtr := "."
		if path == "" {
			dlmtr = ""
		}
		npath := path + dlmtr + "ObjectMeta"
		if errs := m.ObjectMeta.Validate(ver, npath, ignoreStatus, ignoreSpec); errs != nil {
			ret = append(ret, errs...)
		}
	}

	if !ignoreStatus {

		dlmtr := "."
		if path == "" {
			dlmtr = ""
		}
		npath := path + dlmtr + "Status"
		if errs := m.Status.Validate(ver, npath, ignoreStatus, ignoreSpec); errs != nil {
			ret = append(ret, errs...)
		}
	}
	return ret
}

func (m *RouteTable) Normalize() {

	m.ObjectMeta.Normalize()

	m.Status.Normalize()

}

func (m *RouteTableSpec) References(tenant string, path string, resp map[string]apiintf.ReferenceObj) {

}

func (m *RouteTableSpec) Validate(ver, path string, ignoreStatus bool, ignoreSpec bool) []error {
	var ret []error
	return ret
}

func (m *RouteTableSpec) Normalize() {

}

func (m *RouteTableStatus) References(tenant string, path string, resp map[string]apiintf.ReferenceObj) {

	{

		dlmtr := "."
		if path == "" {
			dlmtr = ""
		}
		tag := path + dlmtr + "routes"

		for _, v := range m.Routes {
			if v != nil {
				v.References(tenant, tag, resp)
			}
		}
	}
}

func (m *RouteTableStatus) Validate(ver, path string, ignoreStatus bool, ignoreSpec bool) []error {
	var ret []error
	for k, v := range m.Routes {
		dlmtr := "."
		if path == "" {
			dlmtr = ""
		}
		npath := fmt.Sprintf("%s%sRoutes[%v]", path, dlmtr, k)
		if errs := v.Validate(ver, npath, ignoreStatus, ignoreSpec); errs != nil {
			ret = append(ret, errs...)
		}
	}
	return ret
}

func (m *RouteTableStatus) Normalize() {

	for k, v := range m.Routes {
		if v != nil {
			v.Normalize()
			m.Routes[k] = v
		}
	}

}

func (m *RoutingConfig) References(tenant string, path string, resp map[string]apiintf.ReferenceObj) {

}

func (m *RoutingConfig) Validate(ver, path string, ignoreStatus bool, ignoreSpec bool) []error {
	var ret []error

	if m.Tenant != "" {
		ret = append(ret, errors.New("Tenant not allowed for RoutingConfig"))
	}
	if m.Namespace != "" {
		ret = append(ret, errors.New("Namespace not allowed for RoutingConfig"))
	}

	{
		dlmtr := "."
		if path == "" {
			dlmtr = ""
		}
		npath := path + dlmtr + "ObjectMeta"
		if errs := m.ObjectMeta.Validate(ver, npath, ignoreStatus, ignoreSpec); errs != nil {
			ret = append(ret, errs...)
		}
	}

	if !ignoreSpec {

		dlmtr := "."
		if path == "" {
			dlmtr = ""
		}
		npath := path + dlmtr + "Spec"
		if errs := m.Spec.Validate(ver, npath, ignoreStatus, ignoreSpec); errs != nil {
			ret = append(ret, errs...)
		}
	}

	{
		dlmtr := "."
		if path == "" {
			dlmtr = ""
		}
		npath := path + dlmtr + "Spec"
		if errs := m.Spec.Validate(ver, npath, ignoreStatus, ignoreSpec); errs != nil {
			ret = append(ret, errs...)
		}
	}

	if !ignoreStatus {

		dlmtr := "."
		if path == "" {
			dlmtr = ""
		}
		npath := path + dlmtr + "Status"
		if errs := m.Status.Validate(ver, npath, ignoreStatus, ignoreSpec); errs != nil {
			ret = append(ret, errs...)
		}
	}
	return ret
}

func (m *RoutingConfig) Normalize() {

	m.ObjectMeta.Normalize()

	m.Spec.Normalize()

	m.Status.Normalize()

}

func (m *RoutingConfigSpec) References(tenant string, path string, resp map[string]apiintf.ReferenceObj) {

}

func (m *RoutingConfigSpec) Validate(ver, path string, ignoreStatus bool, ignoreSpec bool) []error {
	var ret []error

	if m.BGPConfig != nil {
		{
			dlmtr := "."
			if path == "" {
				dlmtr = ""
			}
			npath := path + dlmtr + "BGPConfig"
			if errs := m.BGPConfig.Validate(ver, npath, ignoreStatus, ignoreSpec); errs != nil {
				ret = append(ret, errs...)
			}
		}
	}
	return ret
}

func (m *RoutingConfigSpec) Normalize() {

	if m.BGPConfig != nil {
		m.BGPConfig.Normalize()
	}

}

func (m *RoutingConfigStatus) References(tenant string, path string, resp map[string]apiintf.ReferenceObj) {

}

func (m *RoutingConfigStatus) Validate(ver, path string, ignoreStatus bool, ignoreSpec bool) []error {
	var ret []error
	for k, v := range m.AuthConfigStatus {
		dlmtr := "."
		if path == "" {
			dlmtr = ""
		}
		npath := fmt.Sprintf("%s%sAuthConfigStatus[%v]", path, dlmtr, k)
		if errs := v.Validate(ver, npath, ignoreStatus, ignoreSpec); errs != nil {
			ret = append(ret, errs...)
		}
	}
	return ret
}

func (m *RoutingConfigStatus) Normalize() {

	for k, v := range m.AuthConfigStatus {
		if v != nil {
			v.Normalize()
			m.AuthConfigStatus[k] = v
		}
	}

}

// Transformers

func (m *BGPConfig) ApplyStorageTransformer(ctx context.Context, toStorage bool) error {
	for i, v := range m.Neighbors {
		c := *v
		if err := c.ApplyStorageTransformer(ctx, toStorage); err != nil {
			return err
		}
		m.Neighbors[i] = &c
	}
	return nil
}

func (m *BGPConfig) EraseSecrets() {
	for _, v := range m.Neighbors {
		v.EraseSecrets()
	}
	return
}

func (m *BGPNeighbor) ApplyStorageTransformer(ctx context.Context, toStorage bool) error {
	if vs, ok := storageTransformersMapRoute["BGPNeighbor"]; ok {
		for _, v := range vs {
			if err := v(ctx, m, toStorage); err != nil {
				return err
			}
		}
	}
	return nil
}

func (m *BGPNeighbor) EraseSecrets() {
	if v, ok := eraseSecretsMapRoute["BGPNeighbor"]; ok {
		v(m)
	}
	return
}

func (m *RoutingConfig) ApplyStorageTransformer(ctx context.Context, toStorage bool) error {
	if err := m.Spec.ApplyStorageTransformer(ctx, toStorage); err != nil {
		return err
	}
	return nil
}

func (m *RoutingConfig) EraseSecrets() {
	m.Spec.EraseSecrets()

	return
}

type storageRoutingConfigTransformer struct{}

var StorageRoutingConfigTransformer storageRoutingConfigTransformer

func (st *storageRoutingConfigTransformer) TransformFromStorage(ctx context.Context, i interface{}) (interface{}, error) {
	r := i.(RoutingConfig)
	err := r.ApplyStorageTransformer(ctx, false)
	if err != nil {
		return nil, err
	}
	return r, nil
}

func (st *storageRoutingConfigTransformer) TransformToStorage(ctx context.Context, i interface{}) (interface{}, error) {
	r := i.(RoutingConfig)
	err := r.ApplyStorageTransformer(ctx, true)
	if err != nil {
		return nil, err
	}
	return r, nil
}

func (m *RoutingConfigSpec) ApplyStorageTransformer(ctx context.Context, toStorage bool) error {

	if m.BGPConfig == nil {
		return nil
	}
	if err := m.BGPConfig.ApplyStorageTransformer(ctx, toStorage); err != nil {
		return err
	}
	return nil
}

func (m *RoutingConfigSpec) EraseSecrets() {

	if m.BGPConfig == nil {
		return
	}
	m.BGPConfig.EraseSecrets()

	return
}

func init() {
	scheme := runtime.GetDefaultScheme()
	scheme.AddKnownTypes(
		&RouteTable{},
		&RoutingConfig{},
	)

	validatorMapRoute = make(map[string]map[string][]func(string, interface{}) error)

	validatorMapRoute["BGPAuthStatus"] = make(map[string][]func(string, interface{}) error)
	validatorMapRoute["BGPAuthStatus"]["all"] = append(validatorMapRoute["BGPAuthStatus"]["all"], func(path string, i interface{}) error {
		m := i.(*BGPAuthStatus)

		if _, ok := BGPAuthStatus_AuthStatus_vvalue[m.Status]; !ok {
			vals := []string{}
			for k1, _ := range BGPAuthStatus_AuthStatus_vvalue {
				vals = append(vals, k1)
			}
			return fmt.Errorf("%v did not match allowed strings %v", path+"."+"Status", vals)
		}
		return nil
	})

	validatorMapRoute["BGPConfig"] = make(map[string][]func(string, interface{}) error)
	validatorMapRoute["BGPConfig"]["all"] = append(validatorMapRoute["BGPConfig"]["all"], func(path string, i interface{}) error {
		m := i.(*BGPConfig)
		args := make([]string, 0)
		args = append(args, "0")
		args = append(args, "3600")

		if err := validators.IntRange(m.Holdtime, args); err != nil {
			return fmt.Errorf("%v failed validation: %s", path+"."+"Holdtime", err.Error())
		}
		return nil
	})

	validatorMapRoute["BGPConfig"]["all"] = append(validatorMapRoute["BGPConfig"]["all"], func(path string, i interface{}) error {
		m := i.(*BGPConfig)
		args := make([]string, 0)
		args = append(args, "0")
		args = append(args, "3600")

		if err := validators.IntRange(m.KeepaliveInterval, args); err != nil {
			return fmt.Errorf("%v failed validation: %s", path+"."+"KeepaliveInterval", err.Error())
		}
		return nil
	})

	validatorMapRoute["BGPConfig"]["all"] = append(validatorMapRoute["BGPConfig"]["all"], func(path string, i interface{}) error {
		m := i.(*BGPConfig)
		if err := validators.EmptyOr(validators.IPAddr, m.RouterId, nil); err != nil {
			return fmt.Errorf("%v failed validation: %s", path+"."+"RouterId", err.Error())
		}
		return nil
	})

	validatorMapRoute["BGPNeighbor"] = make(map[string][]func(string, interface{}) error)
	validatorMapRoute["BGPNeighbor"]["all"] = append(validatorMapRoute["BGPNeighbor"]["all"], func(path string, i interface{}) error {
		m := i.(*BGPNeighbor)

		for k, v := range m.EnableAddressFamilies {
			if _, ok := BGPAddressFamily_vvalue[v]; !ok {
				vals := []string{}
				for k1, _ := range BGPAddressFamily_vvalue {
					vals = append(vals, k1)
				}
				return fmt.Errorf("%v[%v] did not match allowed strings %v", path+"."+"EnableAddressFamilies", k, vals)
			}
		}
		return nil
	})

	validatorMapRoute["BGPNeighbor"]["all"] = append(validatorMapRoute["BGPNeighbor"]["all"], func(path string, i interface{}) error {
		m := i.(*BGPNeighbor)
		if err := validators.EmptyOr(validators.IPAddr, m.IPAddress, nil); err != nil {
			return fmt.Errorf("%v failed validation: %s", path+"."+"IPAddress", err.Error())
		}
		return nil
	})

	validatorMapRoute["BGPNeighbor"]["all"] = append(validatorMapRoute["BGPNeighbor"]["all"], func(path string, i interface{}) error {
		m := i.(*BGPNeighbor)
		args := make([]string, 0)
		args = append(args, "1")
		args = append(args, "255")

		if err := validators.IntRange(m.MultiHop, args); err != nil {
			return fmt.Errorf("%v failed validation: %s", path+"."+"MultiHop", err.Error())
		}
		return nil
	})

	validatorMapRoute["BGPNeighbor"]["all"] = append(validatorMapRoute["BGPNeighbor"]["all"], func(path string, i interface{}) error {
		m := i.(*BGPNeighbor)
		args := make([]string, 0)
		args = append(args, "1")
		args = append(args, "128")

		if err := validators.EmptyOr(validators.StrLen, m.Password, args); err != nil {
			return fmt.Errorf("%v failed validation: %s", path+"."+"Password", err.Error())
		}
		return nil
	})

	validatorMapRoute["RDSpec"] = make(map[string][]func(string, interface{}) error)
	validatorMapRoute["RDSpec"]["all"] = append(validatorMapRoute["RDSpec"]["all"], func(path string, i interface{}) error {
		m := i.(*RDSpec)

		if _, ok := BGPAddressFamily_vvalue[m.AddressFamily]; !ok {
			vals := []string{}
			for k1, _ := range BGPAddressFamily_vvalue {
				vals = append(vals, k1)
			}
			return fmt.Errorf("%v did not match allowed strings %v", path+"."+"AddressFamily", vals)
		}
		return nil
	})

	validatorMapRoute["Route"] = make(map[string][]func(string, interface{}) error)

	validatorMapRoute["Route"]["all"] = append(validatorMapRoute["Route"]["all"], func(path string, i interface{}) error {
		m := i.(*Route)
		if err := validators.CIDR(m.NexhHop); err != nil {
			return fmt.Errorf("%v failed validation: %s", path+"."+"NexhHop", err.Error())
		}
		return nil
	})

	validatorMapRoute["Route"]["all"] = append(validatorMapRoute["Route"]["all"], func(path string, i interface{}) error {
		m := i.(*Route)
		if err := validators.CIDR(m.Prefix); err != nil {
			return fmt.Errorf("%v failed validation: %s", path+"."+"Prefix", err.Error())
		}
		return nil
	})

	validatorMapRoute["RouteDistinguisher"] = make(map[string][]func(string, interface{}) error)
	validatorMapRoute["RouteDistinguisher"]["all"] = append(validatorMapRoute["RouteDistinguisher"]["all"], func(path string, i interface{}) error {
		m := i.(*RouteDistinguisher)

		if _, ok := RouteDistinguisher_RDType_vvalue[m.Type]; !ok {
			vals := []string{}
			for k1, _ := range RouteDistinguisher_RDType_vvalue {
				vals = append(vals, k1)
			}
			return fmt.Errorf("%v did not match allowed strings %v", path+"."+"Type", vals)
		}
		return nil
	})

	{
		BGPNeighborPasswordTx, err := storage.NewSecretValueTransformer()
		if err != nil {
			log.Fatalf("Error instantiating SecretStorageTransformer: %v", err)
		}
		storageTransformersMapRoute["BGPNeighbor"] = append(storageTransformersMapRoute["BGPNeighbor"],
			func(ctx context.Context, i interface{}, toStorage bool) error {
				var data []byte
				var err error
				m := i.(*BGPNeighbor)

				if toStorage {
					data, err = BGPNeighborPasswordTx.TransformToStorage(ctx, []byte(m.Password))
				} else {
					data, err = BGPNeighborPasswordTx.TransformFromStorage(ctx, []byte(m.Password))
				}
				m.Password = string(data)

				return err
			})

		eraseSecretsMapRoute["BGPNeighbor"] = func(i interface{}) {
			m := i.(*BGPNeighbor)

			var data []byte
			m.Password = string(data)

			return
		}

	}

}
