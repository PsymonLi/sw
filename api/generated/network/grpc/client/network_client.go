// Code generated by protoc-gen-grpc-pensando DO NOT EDIT.

package grpcclient

import (
	"context"
	"errors"
	oldlog "log"

	"github.com/go-kit/kit/endpoint"
	"github.com/go-kit/kit/tracing/opentracing"
	grpctransport "github.com/go-kit/kit/transport/grpc"
	stdopentracing "github.com/opentracing/opentracing-go"
	"google.golang.org/grpc"
	"google.golang.org/grpc/metadata"

	api "github.com/pensando/sw/api"
	network "github.com/pensando/sw/api/generated/network"
	listerwatcher "github.com/pensando/sw/api/listerwatcher"
	apiserver "github.com/pensando/sw/apiserver"
	"github.com/pensando/sw/utils/kvstore"
	"github.com/pensando/sw/utils/log"
)

func dummyBefore(ctx context.Context, md *metadata.MD) context.Context {
	xmd, ok := metadata.FromContext(ctx)
	if ok {
		cmd := metadata.Join(*md, xmd)
		*md = cmd
	}
	return ctx
}

// Dummy vars to suppress import errors
var _ api.TypeMeta
var _ listerwatcher.WatcherClient
var _ kvstore.Interface

func addVersion(ctx context.Context, version string) context.Context {
	pairs := []string{apiserver.RequestParamVersion, version}
	inmd, ok := metadata.FromContext(ctx)
	var outmd metadata.MD
	if ok {
		outmd = metadata.Join(inmd, metadata.Pairs(pairs...))
	} else {
		outmd = metadata.Pairs(pairs...)
	}
	return metadata.NewContext(ctx, outmd)
}

// NewTenantV1 sets up a new client for TenantV1
func NewTenantV1(conn *grpc.ClientConn, logger log.Logger) network.ServiceTenantV1Client {

	var lAutoAddTenantEndpoint endpoint.Endpoint
	{
		lAutoAddTenantEndpoint = grpctransport.NewClient(
			conn,
			"network.TenantV1",
			"AutoAddTenant",
			network.EncodeGrpcReqTenant,
			network.DecodeGrpcRespTenant,
			&network.Tenant{},
			grpctransport.ClientBefore(opentracing.ToGRPCRequest(stdopentracing.GlobalTracer(), logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoAddTenantEndpoint = opentracing.TraceClient(stdopentracing.GlobalTracer(), "TenantV1:AutoAddTenant")(lAutoAddTenantEndpoint)
	}
	var lAutoUpdateTenantEndpoint endpoint.Endpoint
	{
		lAutoUpdateTenantEndpoint = grpctransport.NewClient(
			conn,
			"network.TenantV1",
			"AutoUpdateTenant",
			network.EncodeGrpcReqTenant,
			network.DecodeGrpcRespTenant,
			&network.Tenant{},
			grpctransport.ClientBefore(opentracing.ToGRPCRequest(stdopentracing.GlobalTracer(), logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoUpdateTenantEndpoint = opentracing.TraceClient(stdopentracing.GlobalTracer(), "TenantV1:AutoUpdateTenant")(lAutoUpdateTenantEndpoint)
	}
	var lAutoGetTenantEndpoint endpoint.Endpoint
	{
		lAutoGetTenantEndpoint = grpctransport.NewClient(
			conn,
			"network.TenantV1",
			"AutoGetTenant",
			network.EncodeGrpcReqTenant,
			network.DecodeGrpcRespTenant,
			&network.Tenant{},
			grpctransport.ClientBefore(opentracing.ToGRPCRequest(stdopentracing.GlobalTracer(), logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoGetTenantEndpoint = opentracing.TraceClient(stdopentracing.GlobalTracer(), "TenantV1:AutoGetTenant")(lAutoGetTenantEndpoint)
	}
	var lAutoDeleteTenantEndpoint endpoint.Endpoint
	{
		lAutoDeleteTenantEndpoint = grpctransport.NewClient(
			conn,
			"network.TenantV1",
			"AutoDeleteTenant",
			network.EncodeGrpcReqTenant,
			network.DecodeGrpcRespTenant,
			&network.Tenant{},
			grpctransport.ClientBefore(opentracing.ToGRPCRequest(stdopentracing.GlobalTracer(), logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoDeleteTenantEndpoint = opentracing.TraceClient(stdopentracing.GlobalTracer(), "TenantV1:AutoDeleteTenant")(lAutoDeleteTenantEndpoint)
	}
	var lAutoListTenantEndpoint endpoint.Endpoint
	{
		lAutoListTenantEndpoint = grpctransport.NewClient(
			conn,
			"network.TenantV1",
			"AutoListTenant",
			network.EncodeGrpcReqListWatchOptions,
			network.DecodeGrpcRespAutoMsgTenantListHelper,
			&network.AutoMsgTenantListHelper{},
			grpctransport.ClientBefore(opentracing.ToGRPCRequest(stdopentracing.GlobalTracer(), logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoListTenantEndpoint = opentracing.TraceClient(stdopentracing.GlobalTracer(), "TenantV1:AutoListTenant")(lAutoListTenantEndpoint)
	}
	return network.EndpointsTenantV1Client{
		Client: network.NewTenantV1Client(conn),

		AutoAddTenantEndpoint:    lAutoAddTenantEndpoint,
		AutoUpdateTenantEndpoint: lAutoUpdateTenantEndpoint,
		AutoGetTenantEndpoint:    lAutoGetTenantEndpoint,
		AutoDeleteTenantEndpoint: lAutoDeleteTenantEndpoint,
		AutoListTenantEndpoint:   lAutoListTenantEndpoint,
	}
}

// NewTenantV1Backend creates an instrumented client with middleware
func NewTenantV1Backend(conn *grpc.ClientConn, logger log.Logger) network.ServiceTenantV1Client {
	cl := NewTenantV1(conn, logger)
	cl = network.LoggingTenantV1MiddlewareClient(logger)(cl)
	return cl
}

// NewNetworkV1 sets up a new client for NetworkV1
func NewNetworkV1(conn *grpc.ClientConn, logger log.Logger) network.ServiceNetworkV1Client {

	var lAutoAddNetworkEndpoint endpoint.Endpoint
	{
		lAutoAddNetworkEndpoint = grpctransport.NewClient(
			conn,
			"network.NetworkV1",
			"AutoAddNetwork",
			network.EncodeGrpcReqNetwork,
			network.DecodeGrpcRespNetwork,
			&network.Network{},
			grpctransport.ClientBefore(opentracing.ToGRPCRequest(stdopentracing.GlobalTracer(), logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoAddNetworkEndpoint = opentracing.TraceClient(stdopentracing.GlobalTracer(), "NetworkV1:AutoAddNetwork")(lAutoAddNetworkEndpoint)
	}
	var lAutoUpdateNetworkEndpoint endpoint.Endpoint
	{
		lAutoUpdateNetworkEndpoint = grpctransport.NewClient(
			conn,
			"network.NetworkV1",
			"AutoUpdateNetwork",
			network.EncodeGrpcReqNetwork,
			network.DecodeGrpcRespNetwork,
			&network.Network{},
			grpctransport.ClientBefore(opentracing.ToGRPCRequest(stdopentracing.GlobalTracer(), logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoUpdateNetworkEndpoint = opentracing.TraceClient(stdopentracing.GlobalTracer(), "NetworkV1:AutoUpdateNetwork")(lAutoUpdateNetworkEndpoint)
	}
	var lAutoGetNetworkEndpoint endpoint.Endpoint
	{
		lAutoGetNetworkEndpoint = grpctransport.NewClient(
			conn,
			"network.NetworkV1",
			"AutoGetNetwork",
			network.EncodeGrpcReqNetwork,
			network.DecodeGrpcRespNetwork,
			&network.Network{},
			grpctransport.ClientBefore(opentracing.ToGRPCRequest(stdopentracing.GlobalTracer(), logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoGetNetworkEndpoint = opentracing.TraceClient(stdopentracing.GlobalTracer(), "NetworkV1:AutoGetNetwork")(lAutoGetNetworkEndpoint)
	}
	var lAutoDeleteNetworkEndpoint endpoint.Endpoint
	{
		lAutoDeleteNetworkEndpoint = grpctransport.NewClient(
			conn,
			"network.NetworkV1",
			"AutoDeleteNetwork",
			network.EncodeGrpcReqNetwork,
			network.DecodeGrpcRespNetwork,
			&network.Network{},
			grpctransport.ClientBefore(opentracing.ToGRPCRequest(stdopentracing.GlobalTracer(), logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoDeleteNetworkEndpoint = opentracing.TraceClient(stdopentracing.GlobalTracer(), "NetworkV1:AutoDeleteNetwork")(lAutoDeleteNetworkEndpoint)
	}
	var lAutoListNetworkEndpoint endpoint.Endpoint
	{
		lAutoListNetworkEndpoint = grpctransport.NewClient(
			conn,
			"network.NetworkV1",
			"AutoListNetwork",
			network.EncodeGrpcReqListWatchOptions,
			network.DecodeGrpcRespAutoMsgNetworkListHelper,
			&network.AutoMsgNetworkListHelper{},
			grpctransport.ClientBefore(opentracing.ToGRPCRequest(stdopentracing.GlobalTracer(), logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoListNetworkEndpoint = opentracing.TraceClient(stdopentracing.GlobalTracer(), "NetworkV1:AutoListNetwork")(lAutoListNetworkEndpoint)
	}
	return network.EndpointsNetworkV1Client{
		Client: network.NewNetworkV1Client(conn),

		AutoAddNetworkEndpoint:    lAutoAddNetworkEndpoint,
		AutoUpdateNetworkEndpoint: lAutoUpdateNetworkEndpoint,
		AutoGetNetworkEndpoint:    lAutoGetNetworkEndpoint,
		AutoDeleteNetworkEndpoint: lAutoDeleteNetworkEndpoint,
		AutoListNetworkEndpoint:   lAutoListNetworkEndpoint,
	}
}

// NewNetworkV1Backend creates an instrumented client with middleware
func NewNetworkV1Backend(conn *grpc.ClientConn, logger log.Logger) network.ServiceNetworkV1Client {
	cl := NewNetworkV1(conn, logger)
	cl = network.LoggingNetworkV1MiddlewareClient(logger)(cl)
	return cl
}

// NewSecurityGroupV1 sets up a new client for SecurityGroupV1
func NewSecurityGroupV1(conn *grpc.ClientConn, logger log.Logger) network.ServiceSecurityGroupV1Client {

	var lAutoAddSecurityGroupEndpoint endpoint.Endpoint
	{
		lAutoAddSecurityGroupEndpoint = grpctransport.NewClient(
			conn,
			"network.SecurityGroupV1",
			"AutoAddSecurityGroup",
			network.EncodeGrpcReqSecurityGroup,
			network.DecodeGrpcRespSecurityGroup,
			&network.SecurityGroup{},
			grpctransport.ClientBefore(opentracing.ToGRPCRequest(stdopentracing.GlobalTracer(), logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoAddSecurityGroupEndpoint = opentracing.TraceClient(stdopentracing.GlobalTracer(), "SecurityGroupV1:AutoAddSecurityGroup")(lAutoAddSecurityGroupEndpoint)
	}
	var lAutoUpdateSecurityGroupEndpoint endpoint.Endpoint
	{
		lAutoUpdateSecurityGroupEndpoint = grpctransport.NewClient(
			conn,
			"network.SecurityGroupV1",
			"AutoUpdateSecurityGroup",
			network.EncodeGrpcReqSecurityGroup,
			network.DecodeGrpcRespSecurityGroup,
			&network.SecurityGroup{},
			grpctransport.ClientBefore(opentracing.ToGRPCRequest(stdopentracing.GlobalTracer(), logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoUpdateSecurityGroupEndpoint = opentracing.TraceClient(stdopentracing.GlobalTracer(), "SecurityGroupV1:AutoUpdateSecurityGroup")(lAutoUpdateSecurityGroupEndpoint)
	}
	var lAutoGetSecurityGroupEndpoint endpoint.Endpoint
	{
		lAutoGetSecurityGroupEndpoint = grpctransport.NewClient(
			conn,
			"network.SecurityGroupV1",
			"AutoGetSecurityGroup",
			network.EncodeGrpcReqSecurityGroup,
			network.DecodeGrpcRespSecurityGroup,
			&network.SecurityGroup{},
			grpctransport.ClientBefore(opentracing.ToGRPCRequest(stdopentracing.GlobalTracer(), logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoGetSecurityGroupEndpoint = opentracing.TraceClient(stdopentracing.GlobalTracer(), "SecurityGroupV1:AutoGetSecurityGroup")(lAutoGetSecurityGroupEndpoint)
	}
	var lAutoDeleteSecurityGroupEndpoint endpoint.Endpoint
	{
		lAutoDeleteSecurityGroupEndpoint = grpctransport.NewClient(
			conn,
			"network.SecurityGroupV1",
			"AutoDeleteSecurityGroup",
			network.EncodeGrpcReqSecurityGroup,
			network.DecodeGrpcRespSecurityGroup,
			&network.SecurityGroup{},
			grpctransport.ClientBefore(opentracing.ToGRPCRequest(stdopentracing.GlobalTracer(), logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoDeleteSecurityGroupEndpoint = opentracing.TraceClient(stdopentracing.GlobalTracer(), "SecurityGroupV1:AutoDeleteSecurityGroup")(lAutoDeleteSecurityGroupEndpoint)
	}
	var lAutoListSecurityGroupEndpoint endpoint.Endpoint
	{
		lAutoListSecurityGroupEndpoint = grpctransport.NewClient(
			conn,
			"network.SecurityGroupV1",
			"AutoListSecurityGroup",
			network.EncodeGrpcReqListWatchOptions,
			network.DecodeGrpcRespAutoMsgSecurityGroupListHelper,
			&network.AutoMsgSecurityGroupListHelper{},
			grpctransport.ClientBefore(opentracing.ToGRPCRequest(stdopentracing.GlobalTracer(), logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoListSecurityGroupEndpoint = opentracing.TraceClient(stdopentracing.GlobalTracer(), "SecurityGroupV1:AutoListSecurityGroup")(lAutoListSecurityGroupEndpoint)
	}
	return network.EndpointsSecurityGroupV1Client{
		Client: network.NewSecurityGroupV1Client(conn),

		AutoAddSecurityGroupEndpoint:    lAutoAddSecurityGroupEndpoint,
		AutoUpdateSecurityGroupEndpoint: lAutoUpdateSecurityGroupEndpoint,
		AutoGetSecurityGroupEndpoint:    lAutoGetSecurityGroupEndpoint,
		AutoDeleteSecurityGroupEndpoint: lAutoDeleteSecurityGroupEndpoint,
		AutoListSecurityGroupEndpoint:   lAutoListSecurityGroupEndpoint,
	}
}

// NewSecurityGroupV1Backend creates an instrumented client with middleware
func NewSecurityGroupV1Backend(conn *grpc.ClientConn, logger log.Logger) network.ServiceSecurityGroupV1Client {
	cl := NewSecurityGroupV1(conn, logger)
	cl = network.LoggingSecurityGroupV1MiddlewareClient(logger)(cl)
	return cl
}

// NewSgpolicyV1 sets up a new client for SgpolicyV1
func NewSgpolicyV1(conn *grpc.ClientConn, logger log.Logger) network.ServiceSgpolicyV1Client {

	var lAutoAddSgpolicyEndpoint endpoint.Endpoint
	{
		lAutoAddSgpolicyEndpoint = grpctransport.NewClient(
			conn,
			"network.SgpolicyV1",
			"AutoAddSgpolicy",
			network.EncodeGrpcReqSgpolicy,
			network.DecodeGrpcRespSgpolicy,
			&network.Sgpolicy{},
			grpctransport.ClientBefore(opentracing.ToGRPCRequest(stdopentracing.GlobalTracer(), logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoAddSgpolicyEndpoint = opentracing.TraceClient(stdopentracing.GlobalTracer(), "SgpolicyV1:AutoAddSgpolicy")(lAutoAddSgpolicyEndpoint)
	}
	var lAutoUpdateSgpolicyEndpoint endpoint.Endpoint
	{
		lAutoUpdateSgpolicyEndpoint = grpctransport.NewClient(
			conn,
			"network.SgpolicyV1",
			"AutoUpdateSgpolicy",
			network.EncodeGrpcReqSgpolicy,
			network.DecodeGrpcRespSgpolicy,
			&network.Sgpolicy{},
			grpctransport.ClientBefore(opentracing.ToGRPCRequest(stdopentracing.GlobalTracer(), logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoUpdateSgpolicyEndpoint = opentracing.TraceClient(stdopentracing.GlobalTracer(), "SgpolicyV1:AutoUpdateSgpolicy")(lAutoUpdateSgpolicyEndpoint)
	}
	var lAutoGetSgpolicyEndpoint endpoint.Endpoint
	{
		lAutoGetSgpolicyEndpoint = grpctransport.NewClient(
			conn,
			"network.SgpolicyV1",
			"AutoGetSgpolicy",
			network.EncodeGrpcReqSgpolicy,
			network.DecodeGrpcRespSgpolicy,
			&network.Sgpolicy{},
			grpctransport.ClientBefore(opentracing.ToGRPCRequest(stdopentracing.GlobalTracer(), logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoGetSgpolicyEndpoint = opentracing.TraceClient(stdopentracing.GlobalTracer(), "SgpolicyV1:AutoGetSgpolicy")(lAutoGetSgpolicyEndpoint)
	}
	var lAutoDeleteSgpolicyEndpoint endpoint.Endpoint
	{
		lAutoDeleteSgpolicyEndpoint = grpctransport.NewClient(
			conn,
			"network.SgpolicyV1",
			"AutoDeleteSgpolicy",
			network.EncodeGrpcReqSgpolicy,
			network.DecodeGrpcRespSgpolicy,
			&network.Sgpolicy{},
			grpctransport.ClientBefore(opentracing.ToGRPCRequest(stdopentracing.GlobalTracer(), logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoDeleteSgpolicyEndpoint = opentracing.TraceClient(stdopentracing.GlobalTracer(), "SgpolicyV1:AutoDeleteSgpolicy")(lAutoDeleteSgpolicyEndpoint)
	}
	var lAutoListSgpolicyEndpoint endpoint.Endpoint
	{
		lAutoListSgpolicyEndpoint = grpctransport.NewClient(
			conn,
			"network.SgpolicyV1",
			"AutoListSgpolicy",
			network.EncodeGrpcReqListWatchOptions,
			network.DecodeGrpcRespAutoMsgSgpolicyListHelper,
			&network.AutoMsgSgpolicyListHelper{},
			grpctransport.ClientBefore(opentracing.ToGRPCRequest(stdopentracing.GlobalTracer(), logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoListSgpolicyEndpoint = opentracing.TraceClient(stdopentracing.GlobalTracer(), "SgpolicyV1:AutoListSgpolicy")(lAutoListSgpolicyEndpoint)
	}
	return network.EndpointsSgpolicyV1Client{
		Client: network.NewSgpolicyV1Client(conn),

		AutoAddSgpolicyEndpoint:    lAutoAddSgpolicyEndpoint,
		AutoUpdateSgpolicyEndpoint: lAutoUpdateSgpolicyEndpoint,
		AutoGetSgpolicyEndpoint:    lAutoGetSgpolicyEndpoint,
		AutoDeleteSgpolicyEndpoint: lAutoDeleteSgpolicyEndpoint,
		AutoListSgpolicyEndpoint:   lAutoListSgpolicyEndpoint,
	}
}

// NewSgpolicyV1Backend creates an instrumented client with middleware
func NewSgpolicyV1Backend(conn *grpc.ClientConn, logger log.Logger) network.ServiceSgpolicyV1Client {
	cl := NewSgpolicyV1(conn, logger)
	cl = network.LoggingSgpolicyV1MiddlewareClient(logger)(cl)
	return cl
}

// NewServiceV1 sets up a new client for ServiceV1
func NewServiceV1(conn *grpc.ClientConn, logger log.Logger) network.ServiceServiceV1Client {

	var lAutoAddServiceEndpoint endpoint.Endpoint
	{
		lAutoAddServiceEndpoint = grpctransport.NewClient(
			conn,
			"network.ServiceV1",
			"AutoAddService",
			network.EncodeGrpcReqService,
			network.DecodeGrpcRespService,
			&network.Service{},
			grpctransport.ClientBefore(opentracing.ToGRPCRequest(stdopentracing.GlobalTracer(), logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoAddServiceEndpoint = opentracing.TraceClient(stdopentracing.GlobalTracer(), "ServiceV1:AutoAddService")(lAutoAddServiceEndpoint)
	}
	var lAutoUpdateServiceEndpoint endpoint.Endpoint
	{
		lAutoUpdateServiceEndpoint = grpctransport.NewClient(
			conn,
			"network.ServiceV1",
			"AutoUpdateService",
			network.EncodeGrpcReqService,
			network.DecodeGrpcRespService,
			&network.Service{},
			grpctransport.ClientBefore(opentracing.ToGRPCRequest(stdopentracing.GlobalTracer(), logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoUpdateServiceEndpoint = opentracing.TraceClient(stdopentracing.GlobalTracer(), "ServiceV1:AutoUpdateService")(lAutoUpdateServiceEndpoint)
	}
	var lAutoGetServiceEndpoint endpoint.Endpoint
	{
		lAutoGetServiceEndpoint = grpctransport.NewClient(
			conn,
			"network.ServiceV1",
			"AutoGetService",
			network.EncodeGrpcReqService,
			network.DecodeGrpcRespService,
			&network.Service{},
			grpctransport.ClientBefore(opentracing.ToGRPCRequest(stdopentracing.GlobalTracer(), logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoGetServiceEndpoint = opentracing.TraceClient(stdopentracing.GlobalTracer(), "ServiceV1:AutoGetService")(lAutoGetServiceEndpoint)
	}
	var lAutoDeleteServiceEndpoint endpoint.Endpoint
	{
		lAutoDeleteServiceEndpoint = grpctransport.NewClient(
			conn,
			"network.ServiceV1",
			"AutoDeleteService",
			network.EncodeGrpcReqService,
			network.DecodeGrpcRespService,
			&network.Service{},
			grpctransport.ClientBefore(opentracing.ToGRPCRequest(stdopentracing.GlobalTracer(), logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoDeleteServiceEndpoint = opentracing.TraceClient(stdopentracing.GlobalTracer(), "ServiceV1:AutoDeleteService")(lAutoDeleteServiceEndpoint)
	}
	var lAutoListServiceEndpoint endpoint.Endpoint
	{
		lAutoListServiceEndpoint = grpctransport.NewClient(
			conn,
			"network.ServiceV1",
			"AutoListService",
			network.EncodeGrpcReqListWatchOptions,
			network.DecodeGrpcRespAutoMsgServiceListHelper,
			&network.AutoMsgServiceListHelper{},
			grpctransport.ClientBefore(opentracing.ToGRPCRequest(stdopentracing.GlobalTracer(), logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoListServiceEndpoint = opentracing.TraceClient(stdopentracing.GlobalTracer(), "ServiceV1:AutoListService")(lAutoListServiceEndpoint)
	}
	return network.EndpointsServiceV1Client{
		Client: network.NewServiceV1Client(conn),

		AutoAddServiceEndpoint:    lAutoAddServiceEndpoint,
		AutoUpdateServiceEndpoint: lAutoUpdateServiceEndpoint,
		AutoGetServiceEndpoint:    lAutoGetServiceEndpoint,
		AutoDeleteServiceEndpoint: lAutoDeleteServiceEndpoint,
		AutoListServiceEndpoint:   lAutoListServiceEndpoint,
	}
}

// NewServiceV1Backend creates an instrumented client with middleware
func NewServiceV1Backend(conn *grpc.ClientConn, logger log.Logger) network.ServiceServiceV1Client {
	cl := NewServiceV1(conn, logger)
	cl = network.LoggingServiceV1MiddlewareClient(logger)(cl)
	return cl
}

// NewLbPolicyV1 sets up a new client for LbPolicyV1
func NewLbPolicyV1(conn *grpc.ClientConn, logger log.Logger) network.ServiceLbPolicyV1Client {

	var lAutoAddLbPolicyEndpoint endpoint.Endpoint
	{
		lAutoAddLbPolicyEndpoint = grpctransport.NewClient(
			conn,
			"network.LbPolicyV1",
			"AutoAddLbPolicy",
			network.EncodeGrpcReqLbPolicy,
			network.DecodeGrpcRespLbPolicy,
			&network.LbPolicy{},
			grpctransport.ClientBefore(opentracing.ToGRPCRequest(stdopentracing.GlobalTracer(), logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoAddLbPolicyEndpoint = opentracing.TraceClient(stdopentracing.GlobalTracer(), "LbPolicyV1:AutoAddLbPolicy")(lAutoAddLbPolicyEndpoint)
	}
	var lAutoUpdateLbPolicyEndpoint endpoint.Endpoint
	{
		lAutoUpdateLbPolicyEndpoint = grpctransport.NewClient(
			conn,
			"network.LbPolicyV1",
			"AutoUpdateLbPolicy",
			network.EncodeGrpcReqLbPolicy,
			network.DecodeGrpcRespLbPolicy,
			&network.LbPolicy{},
			grpctransport.ClientBefore(opentracing.ToGRPCRequest(stdopentracing.GlobalTracer(), logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoUpdateLbPolicyEndpoint = opentracing.TraceClient(stdopentracing.GlobalTracer(), "LbPolicyV1:AutoUpdateLbPolicy")(lAutoUpdateLbPolicyEndpoint)
	}
	var lAutoGetLbPolicyEndpoint endpoint.Endpoint
	{
		lAutoGetLbPolicyEndpoint = grpctransport.NewClient(
			conn,
			"network.LbPolicyV1",
			"AutoGetLbPolicy",
			network.EncodeGrpcReqLbPolicy,
			network.DecodeGrpcRespLbPolicy,
			&network.LbPolicy{},
			grpctransport.ClientBefore(opentracing.ToGRPCRequest(stdopentracing.GlobalTracer(), logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoGetLbPolicyEndpoint = opentracing.TraceClient(stdopentracing.GlobalTracer(), "LbPolicyV1:AutoGetLbPolicy")(lAutoGetLbPolicyEndpoint)
	}
	var lAutoDeleteLbPolicyEndpoint endpoint.Endpoint
	{
		lAutoDeleteLbPolicyEndpoint = grpctransport.NewClient(
			conn,
			"network.LbPolicyV1",
			"AutoDeleteLbPolicy",
			network.EncodeGrpcReqLbPolicy,
			network.DecodeGrpcRespLbPolicy,
			&network.LbPolicy{},
			grpctransport.ClientBefore(opentracing.ToGRPCRequest(stdopentracing.GlobalTracer(), logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoDeleteLbPolicyEndpoint = opentracing.TraceClient(stdopentracing.GlobalTracer(), "LbPolicyV1:AutoDeleteLbPolicy")(lAutoDeleteLbPolicyEndpoint)
	}
	var lAutoListLbPolicyEndpoint endpoint.Endpoint
	{
		lAutoListLbPolicyEndpoint = grpctransport.NewClient(
			conn,
			"network.LbPolicyV1",
			"AutoListLbPolicy",
			network.EncodeGrpcReqListWatchOptions,
			network.DecodeGrpcRespAutoMsgLbPolicyListHelper,
			&network.AutoMsgLbPolicyListHelper{},
			grpctransport.ClientBefore(opentracing.ToGRPCRequest(stdopentracing.GlobalTracer(), logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoListLbPolicyEndpoint = opentracing.TraceClient(stdopentracing.GlobalTracer(), "LbPolicyV1:AutoListLbPolicy")(lAutoListLbPolicyEndpoint)
	}
	return network.EndpointsLbPolicyV1Client{
		Client: network.NewLbPolicyV1Client(conn),

		AutoAddLbPolicyEndpoint:    lAutoAddLbPolicyEndpoint,
		AutoUpdateLbPolicyEndpoint: lAutoUpdateLbPolicyEndpoint,
		AutoGetLbPolicyEndpoint:    lAutoGetLbPolicyEndpoint,
		AutoDeleteLbPolicyEndpoint: lAutoDeleteLbPolicyEndpoint,
		AutoListLbPolicyEndpoint:   lAutoListLbPolicyEndpoint,
	}
}

// NewLbPolicyV1Backend creates an instrumented client with middleware
func NewLbPolicyV1Backend(conn *grpc.ClientConn, logger log.Logger) network.ServiceLbPolicyV1Client {
	cl := NewLbPolicyV1(conn, logger)
	cl = network.LoggingLbPolicyV1MiddlewareClient(logger)(cl)
	return cl
}

// NewEndpointV1 sets up a new client for EndpointV1
func NewEndpointV1(conn *grpc.ClientConn, logger log.Logger) network.ServiceEndpointV1Client {

	var lAutoAddEndpointEndpoint endpoint.Endpoint
	{
		lAutoAddEndpointEndpoint = grpctransport.NewClient(
			conn,
			"network.EndpointV1",
			"AutoAddEndpoint",
			network.EncodeGrpcReqEndpoint,
			network.DecodeGrpcRespEndpoint,
			&network.Endpoint{},
			grpctransport.ClientBefore(opentracing.ToGRPCRequest(stdopentracing.GlobalTracer(), logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoAddEndpointEndpoint = opentracing.TraceClient(stdopentracing.GlobalTracer(), "EndpointV1:AutoAddEndpoint")(lAutoAddEndpointEndpoint)
	}
	var lAutoUpdateEndpointEndpoint endpoint.Endpoint
	{
		lAutoUpdateEndpointEndpoint = grpctransport.NewClient(
			conn,
			"network.EndpointV1",
			"AutoUpdateEndpoint",
			network.EncodeGrpcReqEndpoint,
			network.DecodeGrpcRespEndpoint,
			&network.Endpoint{},
			grpctransport.ClientBefore(opentracing.ToGRPCRequest(stdopentracing.GlobalTracer(), logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoUpdateEndpointEndpoint = opentracing.TraceClient(stdopentracing.GlobalTracer(), "EndpointV1:AutoUpdateEndpoint")(lAutoUpdateEndpointEndpoint)
	}
	var lAutoGetEndpointEndpoint endpoint.Endpoint
	{
		lAutoGetEndpointEndpoint = grpctransport.NewClient(
			conn,
			"network.EndpointV1",
			"AutoGetEndpoint",
			network.EncodeGrpcReqEndpoint,
			network.DecodeGrpcRespEndpoint,
			&network.Endpoint{},
			grpctransport.ClientBefore(opentracing.ToGRPCRequest(stdopentracing.GlobalTracer(), logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoGetEndpointEndpoint = opentracing.TraceClient(stdopentracing.GlobalTracer(), "EndpointV1:AutoGetEndpoint")(lAutoGetEndpointEndpoint)
	}
	var lAutoDeleteEndpointEndpoint endpoint.Endpoint
	{
		lAutoDeleteEndpointEndpoint = grpctransport.NewClient(
			conn,
			"network.EndpointV1",
			"AutoDeleteEndpoint",
			network.EncodeGrpcReqEndpoint,
			network.DecodeGrpcRespEndpoint,
			&network.Endpoint{},
			grpctransport.ClientBefore(opentracing.ToGRPCRequest(stdopentracing.GlobalTracer(), logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoDeleteEndpointEndpoint = opentracing.TraceClient(stdopentracing.GlobalTracer(), "EndpointV1:AutoDeleteEndpoint")(lAutoDeleteEndpointEndpoint)
	}
	var lAutoListEndpointEndpoint endpoint.Endpoint
	{
		lAutoListEndpointEndpoint = grpctransport.NewClient(
			conn,
			"network.EndpointV1",
			"AutoListEndpoint",
			network.EncodeGrpcReqListWatchOptions,
			network.DecodeGrpcRespAutoMsgEndpointListHelper,
			&network.AutoMsgEndpointListHelper{},
			grpctransport.ClientBefore(opentracing.ToGRPCRequest(stdopentracing.GlobalTracer(), logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoListEndpointEndpoint = opentracing.TraceClient(stdopentracing.GlobalTracer(), "EndpointV1:AutoListEndpoint")(lAutoListEndpointEndpoint)
	}
	return network.EndpointsEndpointV1Client{
		Client: network.NewEndpointV1Client(conn),

		AutoAddEndpointEndpoint:    lAutoAddEndpointEndpoint,
		AutoUpdateEndpointEndpoint: lAutoUpdateEndpointEndpoint,
		AutoGetEndpointEndpoint:    lAutoGetEndpointEndpoint,
		AutoDeleteEndpointEndpoint: lAutoDeleteEndpointEndpoint,
		AutoListEndpointEndpoint:   lAutoListEndpointEndpoint,
	}
}

// NewEndpointV1Backend creates an instrumented client with middleware
func NewEndpointV1Backend(conn *grpc.ClientConn, logger log.Logger) network.ServiceEndpointV1Client {
	cl := NewEndpointV1(conn, logger)
	cl = network.LoggingEndpointV1MiddlewareClient(logger)(cl)
	return cl
}

type grpcObjTenantV1Tenant struct {
	logger log.Logger
	client network.ServiceTenantV1Client
}

func (a *grpcObjTenantV1Tenant) Create(ctx context.Context, in *network.Tenant) (*network.Tenant, error) {
	a.logger.DebugLog("msg", "recieved call", "object", "Tenant", "oper", "create")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoAddTenant(nctx, in)
}

func (a *grpcObjTenantV1Tenant) Update(ctx context.Context, in *network.Tenant) (*network.Tenant, error) {
	a.logger.DebugLog("msg", "received call", "object", "Tenant", "oper", "update")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoUpdateTenant(nctx, in)
}

func (a *grpcObjTenantV1Tenant) Get(ctx context.Context, objMeta *api.ObjectMeta) (*network.Tenant, error) {
	a.logger.DebugLog("msg", "received call", "object", "Tenant", "oper", "get")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := network.Tenant{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoGetTenant(nctx, &in)
}

func (a *grpcObjTenantV1Tenant) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*network.Tenant, error) {
	a.logger.DebugLog("msg", "received call", "object", "Tenant", "oper", "delete")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := network.Tenant{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoDeleteTenant(nctx, &in)
}

func (a *grpcObjTenantV1Tenant) List(ctx context.Context, options *api.ListWatchOptions) ([]*network.Tenant, error) {
	a.logger.DebugLog("msg", "received call", "object", "Tenant", "oper", "list")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	r, err := a.client.AutoListTenant(nctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *grpcObjTenantV1Tenant) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	a.logger.DebugLog("msg", "received call", "object", "Tenant", "oper", "WatchOper")
	nctx := addVersion(ctx, "v1")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	stream, err := a.client.AutoWatchTenant(nctx, options)
	if err != nil {
		return nil, err
	}
	wstream := stream.(network.TenantV1_AutoWatchTenantClient)
	bridgefn := func(lw *listerwatcher.WatcherClient) {
		for {
			r, err := wstream.Recv()
			if err != nil {
				a.logger.ErrorLog("msg", "error on recieve", "error", err)
				close(lw.OutCh)
				return
			}
			ev := kvstore.WatchEvent{
				Type:   kvstore.WatchEventType(r.Type),
				Object: r.Object,
			}
			lw.OutCh <- &ev
		}
	}
	lw := listerwatcher.NewWatcherClient(wstream, bridgefn)
	lw.Run()
	return lw, nil
}

func (a *grpcObjTenantV1Tenant) Allowed(oper apiserver.APIOperType) bool {
	return true
}

type restObjTenantV1Tenant struct {
	endpoints network.EndpointsTenantV1RestClient
	instance  string
}

func (a *restObjTenantV1Tenant) Create(ctx context.Context, in *network.Tenant) (*network.Tenant, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoAddTenant(ctx, in)
}

func (a *restObjTenantV1Tenant) Update(ctx context.Context, in *network.Tenant) (*network.Tenant, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoUpdateTenant(ctx, in)
}

func (a *restObjTenantV1Tenant) Get(ctx context.Context, objMeta *api.ObjectMeta) (*network.Tenant, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := network.Tenant{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoGetTenant(ctx, &in)
}

func (a *restObjTenantV1Tenant) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*network.Tenant, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := network.Tenant{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoDeleteTenant(ctx, &in)
}

func (a *restObjTenantV1Tenant) List(ctx context.Context, options *api.ListWatchOptions) ([]*network.Tenant, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}
	r, err := a.endpoints.AutoListTenant(ctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *restObjTenantV1Tenant) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	return nil, errors.New("not allowed")
}

func (a *restObjTenantV1Tenant) Allowed(oper apiserver.APIOperType) bool {
	switch oper {
	case apiserver.CreateOper:
		return true
	case apiserver.UpdateOper:
		return true
	case apiserver.GetOper:
		return true
	case apiserver.DeleteOper:
		return true
	case apiserver.ListOper:
		return true
	case apiserver.WatchOper:
		return false
	default:
		return false
	}
}

type grpcObjNetworkV1Network struct {
	logger log.Logger
	client network.ServiceNetworkV1Client
}

func (a *grpcObjNetworkV1Network) Create(ctx context.Context, in *network.Network) (*network.Network, error) {
	a.logger.DebugLog("msg", "recieved call", "object", "Network", "oper", "create")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoAddNetwork(nctx, in)
}

func (a *grpcObjNetworkV1Network) Update(ctx context.Context, in *network.Network) (*network.Network, error) {
	a.logger.DebugLog("msg", "received call", "object", "Network", "oper", "update")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoUpdateNetwork(nctx, in)
}

func (a *grpcObjNetworkV1Network) Get(ctx context.Context, objMeta *api.ObjectMeta) (*network.Network, error) {
	a.logger.DebugLog("msg", "received call", "object", "Network", "oper", "get")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := network.Network{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoGetNetwork(nctx, &in)
}

func (a *grpcObjNetworkV1Network) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*network.Network, error) {
	a.logger.DebugLog("msg", "received call", "object", "Network", "oper", "delete")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := network.Network{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoDeleteNetwork(nctx, &in)
}

func (a *grpcObjNetworkV1Network) List(ctx context.Context, options *api.ListWatchOptions) ([]*network.Network, error) {
	a.logger.DebugLog("msg", "received call", "object", "Network", "oper", "list")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	r, err := a.client.AutoListNetwork(nctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *grpcObjNetworkV1Network) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	a.logger.DebugLog("msg", "received call", "object", "Network", "oper", "WatchOper")
	nctx := addVersion(ctx, "v1")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	stream, err := a.client.AutoWatchNetwork(nctx, options)
	if err != nil {
		return nil, err
	}
	wstream := stream.(network.NetworkV1_AutoWatchNetworkClient)
	bridgefn := func(lw *listerwatcher.WatcherClient) {
		for {
			r, err := wstream.Recv()
			if err != nil {
				a.logger.ErrorLog("msg", "error on recieve", "error", err)
				close(lw.OutCh)
				return
			}
			ev := kvstore.WatchEvent{
				Type:   kvstore.WatchEventType(r.Type),
				Object: r.Object,
			}
			lw.OutCh <- &ev
		}
	}
	lw := listerwatcher.NewWatcherClient(wstream, bridgefn)
	lw.Run()
	return lw, nil
}

func (a *grpcObjNetworkV1Network) Allowed(oper apiserver.APIOperType) bool {
	return true
}

type restObjNetworkV1Network struct {
	endpoints network.EndpointsNetworkV1RestClient
	instance  string
}

func (a *restObjNetworkV1Network) Create(ctx context.Context, in *network.Network) (*network.Network, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoAddNetwork(ctx, in)
}

func (a *restObjNetworkV1Network) Update(ctx context.Context, in *network.Network) (*network.Network, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoUpdateNetwork(ctx, in)
}

func (a *restObjNetworkV1Network) Get(ctx context.Context, objMeta *api.ObjectMeta) (*network.Network, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := network.Network{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoGetNetwork(ctx, &in)
}

func (a *restObjNetworkV1Network) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*network.Network, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := network.Network{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoDeleteNetwork(ctx, &in)
}

func (a *restObjNetworkV1Network) List(ctx context.Context, options *api.ListWatchOptions) ([]*network.Network, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}
	r, err := a.endpoints.AutoListNetwork(ctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *restObjNetworkV1Network) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	return nil, errors.New("not allowed")
}

func (a *restObjNetworkV1Network) Allowed(oper apiserver.APIOperType) bool {
	switch oper {
	case apiserver.CreateOper:
		return true
	case apiserver.UpdateOper:
		return true
	case apiserver.GetOper:
		return true
	case apiserver.DeleteOper:
		return true
	case apiserver.ListOper:
		return true
	case apiserver.WatchOper:
		return false
	default:
		return false
	}
}

type grpcObjSecurityGroupV1SecurityGroup struct {
	logger log.Logger
	client network.ServiceSecurityGroupV1Client
}

func (a *grpcObjSecurityGroupV1SecurityGroup) Create(ctx context.Context, in *network.SecurityGroup) (*network.SecurityGroup, error) {
	a.logger.DebugLog("msg", "recieved call", "object", "SecurityGroup", "oper", "create")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoAddSecurityGroup(nctx, in)
}

func (a *grpcObjSecurityGroupV1SecurityGroup) Update(ctx context.Context, in *network.SecurityGroup) (*network.SecurityGroup, error) {
	a.logger.DebugLog("msg", "received call", "object", "SecurityGroup", "oper", "update")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoUpdateSecurityGroup(nctx, in)
}

func (a *grpcObjSecurityGroupV1SecurityGroup) Get(ctx context.Context, objMeta *api.ObjectMeta) (*network.SecurityGroup, error) {
	a.logger.DebugLog("msg", "received call", "object", "SecurityGroup", "oper", "get")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := network.SecurityGroup{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoGetSecurityGroup(nctx, &in)
}

func (a *grpcObjSecurityGroupV1SecurityGroup) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*network.SecurityGroup, error) {
	a.logger.DebugLog("msg", "received call", "object", "SecurityGroup", "oper", "delete")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := network.SecurityGroup{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoDeleteSecurityGroup(nctx, &in)
}

func (a *grpcObjSecurityGroupV1SecurityGroup) List(ctx context.Context, options *api.ListWatchOptions) ([]*network.SecurityGroup, error) {
	a.logger.DebugLog("msg", "received call", "object", "SecurityGroup", "oper", "list")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	r, err := a.client.AutoListSecurityGroup(nctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *grpcObjSecurityGroupV1SecurityGroup) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	a.logger.DebugLog("msg", "received call", "object", "SecurityGroup", "oper", "WatchOper")
	nctx := addVersion(ctx, "v1")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	stream, err := a.client.AutoWatchSecurityGroup(nctx, options)
	if err != nil {
		return nil, err
	}
	wstream := stream.(network.SecurityGroupV1_AutoWatchSecurityGroupClient)
	bridgefn := func(lw *listerwatcher.WatcherClient) {
		for {
			r, err := wstream.Recv()
			if err != nil {
				a.logger.ErrorLog("msg", "error on recieve", "error", err)
				close(lw.OutCh)
				return
			}
			ev := kvstore.WatchEvent{
				Type:   kvstore.WatchEventType(r.Type),
				Object: r.Object,
			}
			lw.OutCh <- &ev
		}
	}
	lw := listerwatcher.NewWatcherClient(wstream, bridgefn)
	lw.Run()
	return lw, nil
}

func (a *grpcObjSecurityGroupV1SecurityGroup) Allowed(oper apiserver.APIOperType) bool {
	return true
}

type restObjSecurityGroupV1SecurityGroup struct {
	endpoints network.EndpointsSecurityGroupV1RestClient
	instance  string
}

func (a *restObjSecurityGroupV1SecurityGroup) Create(ctx context.Context, in *network.SecurityGroup) (*network.SecurityGroup, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoAddSecurityGroup(ctx, in)
}

func (a *restObjSecurityGroupV1SecurityGroup) Update(ctx context.Context, in *network.SecurityGroup) (*network.SecurityGroup, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoUpdateSecurityGroup(ctx, in)
}

func (a *restObjSecurityGroupV1SecurityGroup) Get(ctx context.Context, objMeta *api.ObjectMeta) (*network.SecurityGroup, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := network.SecurityGroup{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoGetSecurityGroup(ctx, &in)
}

func (a *restObjSecurityGroupV1SecurityGroup) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*network.SecurityGroup, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := network.SecurityGroup{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoDeleteSecurityGroup(ctx, &in)
}

func (a *restObjSecurityGroupV1SecurityGroup) List(ctx context.Context, options *api.ListWatchOptions) ([]*network.SecurityGroup, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}
	r, err := a.endpoints.AutoListSecurityGroup(ctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *restObjSecurityGroupV1SecurityGroup) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	return nil, errors.New("not allowed")
}

func (a *restObjSecurityGroupV1SecurityGroup) Allowed(oper apiserver.APIOperType) bool {
	switch oper {
	case apiserver.CreateOper:
		return true
	case apiserver.UpdateOper:
		return true
	case apiserver.GetOper:
		return true
	case apiserver.DeleteOper:
		return true
	case apiserver.ListOper:
		return true
	case apiserver.WatchOper:
		return false
	default:
		return false
	}
}

type grpcObjSgpolicyV1Sgpolicy struct {
	logger log.Logger
	client network.ServiceSgpolicyV1Client
}

func (a *grpcObjSgpolicyV1Sgpolicy) Create(ctx context.Context, in *network.Sgpolicy) (*network.Sgpolicy, error) {
	a.logger.DebugLog("msg", "recieved call", "object", "Sgpolicy", "oper", "create")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoAddSgpolicy(nctx, in)
}

func (a *grpcObjSgpolicyV1Sgpolicy) Update(ctx context.Context, in *network.Sgpolicy) (*network.Sgpolicy, error) {
	a.logger.DebugLog("msg", "received call", "object", "Sgpolicy", "oper", "update")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoUpdateSgpolicy(nctx, in)
}

func (a *grpcObjSgpolicyV1Sgpolicy) Get(ctx context.Context, objMeta *api.ObjectMeta) (*network.Sgpolicy, error) {
	a.logger.DebugLog("msg", "received call", "object", "Sgpolicy", "oper", "get")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := network.Sgpolicy{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoGetSgpolicy(nctx, &in)
}

func (a *grpcObjSgpolicyV1Sgpolicy) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*network.Sgpolicy, error) {
	a.logger.DebugLog("msg", "received call", "object", "Sgpolicy", "oper", "delete")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := network.Sgpolicy{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoDeleteSgpolicy(nctx, &in)
}

func (a *grpcObjSgpolicyV1Sgpolicy) List(ctx context.Context, options *api.ListWatchOptions) ([]*network.Sgpolicy, error) {
	a.logger.DebugLog("msg", "received call", "object", "Sgpolicy", "oper", "list")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	r, err := a.client.AutoListSgpolicy(nctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *grpcObjSgpolicyV1Sgpolicy) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	a.logger.DebugLog("msg", "received call", "object", "Sgpolicy", "oper", "WatchOper")
	nctx := addVersion(ctx, "v1")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	stream, err := a.client.AutoWatchSgpolicy(nctx, options)
	if err != nil {
		return nil, err
	}
	wstream := stream.(network.SgpolicyV1_AutoWatchSgpolicyClient)
	bridgefn := func(lw *listerwatcher.WatcherClient) {
		for {
			r, err := wstream.Recv()
			if err != nil {
				a.logger.ErrorLog("msg", "error on recieve", "error", err)
				close(lw.OutCh)
				return
			}
			ev := kvstore.WatchEvent{
				Type:   kvstore.WatchEventType(r.Type),
				Object: r.Object,
			}
			lw.OutCh <- &ev
		}
	}
	lw := listerwatcher.NewWatcherClient(wstream, bridgefn)
	lw.Run()
	return lw, nil
}

func (a *grpcObjSgpolicyV1Sgpolicy) Allowed(oper apiserver.APIOperType) bool {
	return true
}

type restObjSgpolicyV1Sgpolicy struct {
	endpoints network.EndpointsSgpolicyV1RestClient
	instance  string
}

func (a *restObjSgpolicyV1Sgpolicy) Create(ctx context.Context, in *network.Sgpolicy) (*network.Sgpolicy, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoAddSgpolicy(ctx, in)
}

func (a *restObjSgpolicyV1Sgpolicy) Update(ctx context.Context, in *network.Sgpolicy) (*network.Sgpolicy, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoUpdateSgpolicy(ctx, in)
}

func (a *restObjSgpolicyV1Sgpolicy) Get(ctx context.Context, objMeta *api.ObjectMeta) (*network.Sgpolicy, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := network.Sgpolicy{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoGetSgpolicy(ctx, &in)
}

func (a *restObjSgpolicyV1Sgpolicy) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*network.Sgpolicy, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := network.Sgpolicy{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoDeleteSgpolicy(ctx, &in)
}

func (a *restObjSgpolicyV1Sgpolicy) List(ctx context.Context, options *api.ListWatchOptions) ([]*network.Sgpolicy, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}
	r, err := a.endpoints.AutoListSgpolicy(ctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *restObjSgpolicyV1Sgpolicy) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	return nil, errors.New("not allowed")
}

func (a *restObjSgpolicyV1Sgpolicy) Allowed(oper apiserver.APIOperType) bool {
	switch oper {
	case apiserver.CreateOper:
		return true
	case apiserver.UpdateOper:
		return true
	case apiserver.GetOper:
		return true
	case apiserver.DeleteOper:
		return true
	case apiserver.ListOper:
		return true
	case apiserver.WatchOper:
		return false
	default:
		return false
	}
}

type grpcObjServiceV1Service struct {
	logger log.Logger
	client network.ServiceServiceV1Client
}

func (a *grpcObjServiceV1Service) Create(ctx context.Context, in *network.Service) (*network.Service, error) {
	a.logger.DebugLog("msg", "recieved call", "object", "Service", "oper", "create")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoAddService(nctx, in)
}

func (a *grpcObjServiceV1Service) Update(ctx context.Context, in *network.Service) (*network.Service, error) {
	a.logger.DebugLog("msg", "received call", "object", "Service", "oper", "update")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoUpdateService(nctx, in)
}

func (a *grpcObjServiceV1Service) Get(ctx context.Context, objMeta *api.ObjectMeta) (*network.Service, error) {
	a.logger.DebugLog("msg", "received call", "object", "Service", "oper", "get")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := network.Service{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoGetService(nctx, &in)
}

func (a *grpcObjServiceV1Service) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*network.Service, error) {
	a.logger.DebugLog("msg", "received call", "object", "Service", "oper", "delete")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := network.Service{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoDeleteService(nctx, &in)
}

func (a *grpcObjServiceV1Service) List(ctx context.Context, options *api.ListWatchOptions) ([]*network.Service, error) {
	a.logger.DebugLog("msg", "received call", "object", "Service", "oper", "list")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	r, err := a.client.AutoListService(nctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *grpcObjServiceV1Service) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	a.logger.DebugLog("msg", "received call", "object", "Service", "oper", "WatchOper")
	nctx := addVersion(ctx, "v1")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	stream, err := a.client.AutoWatchService(nctx, options)
	if err != nil {
		return nil, err
	}
	wstream := stream.(network.ServiceV1_AutoWatchServiceClient)
	bridgefn := func(lw *listerwatcher.WatcherClient) {
		for {
			r, err := wstream.Recv()
			if err != nil {
				a.logger.ErrorLog("msg", "error on recieve", "error", err)
				close(lw.OutCh)
				return
			}
			ev := kvstore.WatchEvent{
				Type:   kvstore.WatchEventType(r.Type),
				Object: r.Object,
			}
			lw.OutCh <- &ev
		}
	}
	lw := listerwatcher.NewWatcherClient(wstream, bridgefn)
	lw.Run()
	return lw, nil
}

func (a *grpcObjServiceV1Service) Allowed(oper apiserver.APIOperType) bool {
	return true
}

type restObjServiceV1Service struct {
	endpoints network.EndpointsServiceV1RestClient
	instance  string
}

func (a *restObjServiceV1Service) Create(ctx context.Context, in *network.Service) (*network.Service, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoAddService(ctx, in)
}

func (a *restObjServiceV1Service) Update(ctx context.Context, in *network.Service) (*network.Service, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoUpdateService(ctx, in)
}

func (a *restObjServiceV1Service) Get(ctx context.Context, objMeta *api.ObjectMeta) (*network.Service, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := network.Service{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoGetService(ctx, &in)
}

func (a *restObjServiceV1Service) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*network.Service, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := network.Service{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoDeleteService(ctx, &in)
}

func (a *restObjServiceV1Service) List(ctx context.Context, options *api.ListWatchOptions) ([]*network.Service, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}
	r, err := a.endpoints.AutoListService(ctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *restObjServiceV1Service) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	return nil, errors.New("not allowed")
}

func (a *restObjServiceV1Service) Allowed(oper apiserver.APIOperType) bool {
	switch oper {
	case apiserver.CreateOper:
		return true
	case apiserver.UpdateOper:
		return true
	case apiserver.GetOper:
		return true
	case apiserver.DeleteOper:
		return true
	case apiserver.ListOper:
		return true
	case apiserver.WatchOper:
		return false
	default:
		return false
	}
}

type grpcObjLbPolicyV1LbPolicy struct {
	logger log.Logger
	client network.ServiceLbPolicyV1Client
}

func (a *grpcObjLbPolicyV1LbPolicy) Create(ctx context.Context, in *network.LbPolicy) (*network.LbPolicy, error) {
	a.logger.DebugLog("msg", "recieved call", "object", "LbPolicy", "oper", "create")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoAddLbPolicy(nctx, in)
}

func (a *grpcObjLbPolicyV1LbPolicy) Update(ctx context.Context, in *network.LbPolicy) (*network.LbPolicy, error) {
	a.logger.DebugLog("msg", "received call", "object", "LbPolicy", "oper", "update")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoUpdateLbPolicy(nctx, in)
}

func (a *grpcObjLbPolicyV1LbPolicy) Get(ctx context.Context, objMeta *api.ObjectMeta) (*network.LbPolicy, error) {
	a.logger.DebugLog("msg", "received call", "object", "LbPolicy", "oper", "get")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := network.LbPolicy{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoGetLbPolicy(nctx, &in)
}

func (a *grpcObjLbPolicyV1LbPolicy) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*network.LbPolicy, error) {
	a.logger.DebugLog("msg", "received call", "object", "LbPolicy", "oper", "delete")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := network.LbPolicy{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoDeleteLbPolicy(nctx, &in)
}

func (a *grpcObjLbPolicyV1LbPolicy) List(ctx context.Context, options *api.ListWatchOptions) ([]*network.LbPolicy, error) {
	a.logger.DebugLog("msg", "received call", "object", "LbPolicy", "oper", "list")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	r, err := a.client.AutoListLbPolicy(nctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *grpcObjLbPolicyV1LbPolicy) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	a.logger.DebugLog("msg", "received call", "object", "LbPolicy", "oper", "WatchOper")
	nctx := addVersion(ctx, "v1")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	stream, err := a.client.AutoWatchLbPolicy(nctx, options)
	if err != nil {
		return nil, err
	}
	wstream := stream.(network.LbPolicyV1_AutoWatchLbPolicyClient)
	bridgefn := func(lw *listerwatcher.WatcherClient) {
		for {
			r, err := wstream.Recv()
			if err != nil {
				a.logger.ErrorLog("msg", "error on recieve", "error", err)
				close(lw.OutCh)
				return
			}
			ev := kvstore.WatchEvent{
				Type:   kvstore.WatchEventType(r.Type),
				Object: r.Object,
			}
			lw.OutCh <- &ev
		}
	}
	lw := listerwatcher.NewWatcherClient(wstream, bridgefn)
	lw.Run()
	return lw, nil
}

func (a *grpcObjLbPolicyV1LbPolicy) Allowed(oper apiserver.APIOperType) bool {
	return true
}

type restObjLbPolicyV1LbPolicy struct {
	endpoints network.EndpointsLbPolicyV1RestClient
	instance  string
}

func (a *restObjLbPolicyV1LbPolicy) Create(ctx context.Context, in *network.LbPolicy) (*network.LbPolicy, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoAddLbPolicy(ctx, in)
}

func (a *restObjLbPolicyV1LbPolicy) Update(ctx context.Context, in *network.LbPolicy) (*network.LbPolicy, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoUpdateLbPolicy(ctx, in)
}

func (a *restObjLbPolicyV1LbPolicy) Get(ctx context.Context, objMeta *api.ObjectMeta) (*network.LbPolicy, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := network.LbPolicy{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoGetLbPolicy(ctx, &in)
}

func (a *restObjLbPolicyV1LbPolicy) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*network.LbPolicy, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := network.LbPolicy{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoDeleteLbPolicy(ctx, &in)
}

func (a *restObjLbPolicyV1LbPolicy) List(ctx context.Context, options *api.ListWatchOptions) ([]*network.LbPolicy, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}
	r, err := a.endpoints.AutoListLbPolicy(ctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *restObjLbPolicyV1LbPolicy) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	return nil, errors.New("not allowed")
}

func (a *restObjLbPolicyV1LbPolicy) Allowed(oper apiserver.APIOperType) bool {
	switch oper {
	case apiserver.CreateOper:
		return true
	case apiserver.UpdateOper:
		return true
	case apiserver.GetOper:
		return true
	case apiserver.DeleteOper:
		return true
	case apiserver.ListOper:
		return true
	case apiserver.WatchOper:
		return false
	default:
		return false
	}
}

type grpcObjEndpointV1Endpoint struct {
	logger log.Logger
	client network.ServiceEndpointV1Client
}

func (a *grpcObjEndpointV1Endpoint) Create(ctx context.Context, in *network.Endpoint) (*network.Endpoint, error) {
	a.logger.DebugLog("msg", "recieved call", "object", "Endpoint", "oper", "create")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoAddEndpoint(nctx, in)
}

func (a *grpcObjEndpointV1Endpoint) Update(ctx context.Context, in *network.Endpoint) (*network.Endpoint, error) {
	a.logger.DebugLog("msg", "received call", "object", "Endpoint", "oper", "update")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoUpdateEndpoint(nctx, in)
}

func (a *grpcObjEndpointV1Endpoint) Get(ctx context.Context, objMeta *api.ObjectMeta) (*network.Endpoint, error) {
	a.logger.DebugLog("msg", "received call", "object", "Endpoint", "oper", "get")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := network.Endpoint{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoGetEndpoint(nctx, &in)
}

func (a *grpcObjEndpointV1Endpoint) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*network.Endpoint, error) {
	a.logger.DebugLog("msg", "received call", "object", "Endpoint", "oper", "delete")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := network.Endpoint{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoDeleteEndpoint(nctx, &in)
}

func (a *grpcObjEndpointV1Endpoint) List(ctx context.Context, options *api.ListWatchOptions) ([]*network.Endpoint, error) {
	a.logger.DebugLog("msg", "received call", "object", "Endpoint", "oper", "list")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	r, err := a.client.AutoListEndpoint(nctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *grpcObjEndpointV1Endpoint) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	a.logger.DebugLog("msg", "received call", "object", "Endpoint", "oper", "WatchOper")
	nctx := addVersion(ctx, "v1")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	stream, err := a.client.AutoWatchEndpoint(nctx, options)
	if err != nil {
		return nil, err
	}
	wstream := stream.(network.EndpointV1_AutoWatchEndpointClient)
	bridgefn := func(lw *listerwatcher.WatcherClient) {
		for {
			r, err := wstream.Recv()
			if err != nil {
				a.logger.ErrorLog("msg", "error on recieve", "error", err)
				close(lw.OutCh)
				return
			}
			ev := kvstore.WatchEvent{
				Type:   kvstore.WatchEventType(r.Type),
				Object: r.Object,
			}
			lw.OutCh <- &ev
		}
	}
	lw := listerwatcher.NewWatcherClient(wstream, bridgefn)
	lw.Run()
	return lw, nil
}

func (a *grpcObjEndpointV1Endpoint) Allowed(oper apiserver.APIOperType) bool {
	return true
}

type restObjEndpointV1Endpoint struct {
	endpoints network.EndpointsEndpointV1RestClient
	instance  string
}

func (a *restObjEndpointV1Endpoint) Create(ctx context.Context, in *network.Endpoint) (*network.Endpoint, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoAddEndpoint(ctx, in)
}

func (a *restObjEndpointV1Endpoint) Update(ctx context.Context, in *network.Endpoint) (*network.Endpoint, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoUpdateEndpoint(ctx, in)
}

func (a *restObjEndpointV1Endpoint) Get(ctx context.Context, objMeta *api.ObjectMeta) (*network.Endpoint, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := network.Endpoint{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoGetEndpoint(ctx, &in)
}

func (a *restObjEndpointV1Endpoint) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*network.Endpoint, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := network.Endpoint{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoDeleteEndpoint(ctx, &in)
}

func (a *restObjEndpointV1Endpoint) List(ctx context.Context, options *api.ListWatchOptions) ([]*network.Endpoint, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}
	r, err := a.endpoints.AutoListEndpoint(ctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *restObjEndpointV1Endpoint) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	return nil, errors.New("not allowed")
}

func (a *restObjEndpointV1Endpoint) Allowed(oper apiserver.APIOperType) bool {
	switch oper {
	case apiserver.CreateOper:
		return true
	case apiserver.UpdateOper:
		return true
	case apiserver.GetOper:
		return true
	case apiserver.DeleteOper:
		return true
	case apiserver.ListOper:
		return true
	case apiserver.WatchOper:
		return false
	default:
		return false
	}
}

type crudClientTenantV1 struct {
	grpcTenant network.TenantInterface
}

// NewGrpcCrudClientTenantV1 creates a GRPC client for the service
func NewGrpcCrudClientTenantV1(conn *grpc.ClientConn, logger log.Logger) network.TenantV1Interface {
	client := NewTenantV1Backend(conn, logger)
	return &crudClientTenantV1{

		grpcTenant: &grpcObjTenantV1Tenant{client: client, logger: logger},
	}
}

func (a *crudClientTenantV1) Tenant() network.TenantInterface {
	return a.grpcTenant
}

type crudRestClientTenantV1 struct {
	restTenant network.TenantInterface
}

// NewRestCrudClientTenantV1 creates a REST client for the service.
func NewRestCrudClientTenantV1(url string) network.TenantV1Interface {
	endpoints, err := network.MakeTenantV1RestClientEndpoints(url)
	if err != nil {
		oldlog.Fatal("failed to create client")
	}
	return &crudRestClientTenantV1{

		restTenant: &restObjTenantV1Tenant{endpoints: endpoints, instance: url},
	}
}

func (a *crudRestClientTenantV1) Tenant() network.TenantInterface {
	return a.restTenant
}

type crudClientNetworkV1 struct {
	grpcNetwork network.NetworkInterface
}

// NewGrpcCrudClientNetworkV1 creates a GRPC client for the service
func NewGrpcCrudClientNetworkV1(conn *grpc.ClientConn, logger log.Logger) network.NetworkV1Interface {
	client := NewNetworkV1Backend(conn, logger)
	return &crudClientNetworkV1{

		grpcNetwork: &grpcObjNetworkV1Network{client: client, logger: logger},
	}
}

func (a *crudClientNetworkV1) Network() network.NetworkInterface {
	return a.grpcNetwork
}

type crudRestClientNetworkV1 struct {
	restNetwork network.NetworkInterface
}

// NewRestCrudClientNetworkV1 creates a REST client for the service.
func NewRestCrudClientNetworkV1(url string) network.NetworkV1Interface {
	endpoints, err := network.MakeNetworkV1RestClientEndpoints(url)
	if err != nil {
		oldlog.Fatal("failed to create client")
	}
	return &crudRestClientNetworkV1{

		restNetwork: &restObjNetworkV1Network{endpoints: endpoints, instance: url},
	}
}

func (a *crudRestClientNetworkV1) Network() network.NetworkInterface {
	return a.restNetwork
}

type crudClientSecurityGroupV1 struct {
	grpcSecurityGroup network.SecurityGroupInterface
}

// NewGrpcCrudClientSecurityGroupV1 creates a GRPC client for the service
func NewGrpcCrudClientSecurityGroupV1(conn *grpc.ClientConn, logger log.Logger) network.SecurityGroupV1Interface {
	client := NewSecurityGroupV1Backend(conn, logger)
	return &crudClientSecurityGroupV1{

		grpcSecurityGroup: &grpcObjSecurityGroupV1SecurityGroup{client: client, logger: logger},
	}
}

func (a *crudClientSecurityGroupV1) SecurityGroup() network.SecurityGroupInterface {
	return a.grpcSecurityGroup
}

type crudRestClientSecurityGroupV1 struct {
	restSecurityGroup network.SecurityGroupInterface
}

// NewRestCrudClientSecurityGroupV1 creates a REST client for the service.
func NewRestCrudClientSecurityGroupV1(url string) network.SecurityGroupV1Interface {
	endpoints, err := network.MakeSecurityGroupV1RestClientEndpoints(url)
	if err != nil {
		oldlog.Fatal("failed to create client")
	}
	return &crudRestClientSecurityGroupV1{

		restSecurityGroup: &restObjSecurityGroupV1SecurityGroup{endpoints: endpoints, instance: url},
	}
}

func (a *crudRestClientSecurityGroupV1) SecurityGroup() network.SecurityGroupInterface {
	return a.restSecurityGroup
}

type crudClientSgpolicyV1 struct {
	grpcSgpolicy network.SgpolicyInterface
}

// NewGrpcCrudClientSgpolicyV1 creates a GRPC client for the service
func NewGrpcCrudClientSgpolicyV1(conn *grpc.ClientConn, logger log.Logger) network.SgpolicyV1Interface {
	client := NewSgpolicyV1Backend(conn, logger)
	return &crudClientSgpolicyV1{

		grpcSgpolicy: &grpcObjSgpolicyV1Sgpolicy{client: client, logger: logger},
	}
}

func (a *crudClientSgpolicyV1) Sgpolicy() network.SgpolicyInterface {
	return a.grpcSgpolicy
}

type crudRestClientSgpolicyV1 struct {
	restSgpolicy network.SgpolicyInterface
}

// NewRestCrudClientSgpolicyV1 creates a REST client for the service.
func NewRestCrudClientSgpolicyV1(url string) network.SgpolicyV1Interface {
	endpoints, err := network.MakeSgpolicyV1RestClientEndpoints(url)
	if err != nil {
		oldlog.Fatal("failed to create client")
	}
	return &crudRestClientSgpolicyV1{

		restSgpolicy: &restObjSgpolicyV1Sgpolicy{endpoints: endpoints, instance: url},
	}
}

func (a *crudRestClientSgpolicyV1) Sgpolicy() network.SgpolicyInterface {
	return a.restSgpolicy
}

type crudClientServiceV1 struct {
	grpcService network.ServiceInterface
}

// NewGrpcCrudClientServiceV1 creates a GRPC client for the service
func NewGrpcCrudClientServiceV1(conn *grpc.ClientConn, logger log.Logger) network.ServiceV1Interface {
	client := NewServiceV1Backend(conn, logger)
	return &crudClientServiceV1{

		grpcService: &grpcObjServiceV1Service{client: client, logger: logger},
	}
}

func (a *crudClientServiceV1) Service() network.ServiceInterface {
	return a.grpcService
}

type crudRestClientServiceV1 struct {
	restService network.ServiceInterface
}

// NewRestCrudClientServiceV1 creates a REST client for the service.
func NewRestCrudClientServiceV1(url string) network.ServiceV1Interface {
	endpoints, err := network.MakeServiceV1RestClientEndpoints(url)
	if err != nil {
		oldlog.Fatal("failed to create client")
	}
	return &crudRestClientServiceV1{

		restService: &restObjServiceV1Service{endpoints: endpoints, instance: url},
	}
}

func (a *crudRestClientServiceV1) Service() network.ServiceInterface {
	return a.restService
}

type crudClientLbPolicyV1 struct {
	grpcLbPolicy network.LbPolicyInterface
}

// NewGrpcCrudClientLbPolicyV1 creates a GRPC client for the service
func NewGrpcCrudClientLbPolicyV1(conn *grpc.ClientConn, logger log.Logger) network.LbPolicyV1Interface {
	client := NewLbPolicyV1Backend(conn, logger)
	return &crudClientLbPolicyV1{

		grpcLbPolicy: &grpcObjLbPolicyV1LbPolicy{client: client, logger: logger},
	}
}

func (a *crudClientLbPolicyV1) LbPolicy() network.LbPolicyInterface {
	return a.grpcLbPolicy
}

type crudRestClientLbPolicyV1 struct {
	restLbPolicy network.LbPolicyInterface
}

// NewRestCrudClientLbPolicyV1 creates a REST client for the service.
func NewRestCrudClientLbPolicyV1(url string) network.LbPolicyV1Interface {
	endpoints, err := network.MakeLbPolicyV1RestClientEndpoints(url)
	if err != nil {
		oldlog.Fatal("failed to create client")
	}
	return &crudRestClientLbPolicyV1{

		restLbPolicy: &restObjLbPolicyV1LbPolicy{endpoints: endpoints, instance: url},
	}
}

func (a *crudRestClientLbPolicyV1) LbPolicy() network.LbPolicyInterface {
	return a.restLbPolicy
}

type crudClientEndpointV1 struct {
	grpcEndpoint network.EndpointInterface
}

// NewGrpcCrudClientEndpointV1 creates a GRPC client for the service
func NewGrpcCrudClientEndpointV1(conn *grpc.ClientConn, logger log.Logger) network.EndpointV1Interface {
	client := NewEndpointV1Backend(conn, logger)
	return &crudClientEndpointV1{

		grpcEndpoint: &grpcObjEndpointV1Endpoint{client: client, logger: logger},
	}
}

func (a *crudClientEndpointV1) Endpoint() network.EndpointInterface {
	return a.grpcEndpoint
}

type crudRestClientEndpointV1 struct {
	restEndpoint network.EndpointInterface
}

// NewRestCrudClientEndpointV1 creates a REST client for the service.
func NewRestCrudClientEndpointV1(url string) network.EndpointV1Interface {
	endpoints, err := network.MakeEndpointV1RestClientEndpoints(url)
	if err != nil {
		oldlog.Fatal("failed to create client")
	}
	return &crudRestClientEndpointV1{

		restEndpoint: &restObjEndpointV1Endpoint{endpoints: endpoints, instance: url},
	}
}

func (a *crudRestClientEndpointV1) Endpoint() network.EndpointInterface {
	return a.restEndpoint
}
