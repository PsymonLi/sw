// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: route.proto

package network

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/pensando/grpc-gateway/third_party/googleapis/google/api"
import _ "github.com/pensando/sw/venice/utils/apigen/annotations"
import _ "github.com/gogo/protobuf/gogoproto"
import api "github.com/pensando/sw/api"
import _ "github.com/pensando/sw/api/labels"
import _ "github.com/pensando/sw/api/generated/cluster"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

//
type BGPAddressFamily int32

const (
	//
	BGPAddressFamily_IPv4Unicast BGPAddressFamily = 0
	//
	BGPAddressFamily_EVPN BGPAddressFamily = 1
)

var BGPAddressFamily_name = map[int32]string{
	0: "IPv4Unicast",
	1: "EVPN",
}
var BGPAddressFamily_value = map[string]int32{
	"IPv4Unicast": 0,
	"EVPN":        1,
}

func (BGPAddressFamily) EnumDescriptor() ([]byte, []int) { return fileDescriptorRoute, []int{0} }

//
type RouteDistinguisher_RDType int32

const (
	//
	RouteDistinguisher_Type0 RouteDistinguisher_RDType = 0
	//
	RouteDistinguisher_Type1 RouteDistinguisher_RDType = 1
	//
	RouteDistinguisher_Type2 RouteDistinguisher_RDType = 2
)

var RouteDistinguisher_RDType_name = map[int32]string{
	0: "Type0",
	1: "Type1",
	2: "Type2",
}
var RouteDistinguisher_RDType_value = map[string]int32{
	"Type0": 0,
	"Type1": 1,
	"Type2": 2,
}

func (RouteDistinguisher_RDType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorRoute, []int{5, 0}
}

//
type BGPConfig struct {
	// Router ID for the BGP Instance.
	RouterId string `protobuf:"bytes,1,opt,name=RouterId,json=router-id,omitempty,proto3" json:"router-id,omitempty"`
	// Local ASN for the BGP Instance.
	ASNumber uint32 `protobuf:"varint,2,opt,name=ASNumber,json=as-number,omitempty,proto3" json:"as-number,omitempty"`
	// List of all neighbors.
	Neighbors []*BGPNeighbor `protobuf:"bytes,3,rep,name=Neighbors,json=neighbors,omitempty" json:"neighbors,omitempty"`
}

func (m *BGPConfig) Reset()                    { *m = BGPConfig{} }
func (m *BGPConfig) String() string            { return proto.CompactTextString(m) }
func (*BGPConfig) ProtoMessage()               {}
func (*BGPConfig) Descriptor() ([]byte, []int) { return fileDescriptorRoute, []int{0} }

func (m *BGPConfig) GetRouterId() string {
	if m != nil {
		return m.RouterId
	}
	return ""
}

func (m *BGPConfig) GetASNumber() uint32 {
	if m != nil {
		return m.ASNumber
	}
	return 0
}

func (m *BGPConfig) GetNeighbors() []*BGPNeighbor {
	if m != nil {
		return m.Neighbors
	}
	return nil
}

//
type BGPNeighbor struct {
	// Shutdown this neighbor session.
	Shutdown bool `protobuf:"varint,1,opt,name=Shutdown,json=shutdown,omitempty,proto3" json:"shutdown,omitempty"`
	// Neighbor IP Address.
	IPAddress string `protobuf:"bytes,2,opt,name=IPAddress,json=ip-address,omitempty,proto3" json:"ip-address,omitempty"`
	// ASN the neighbor belongs to.
	RemoteAS uint32 `protobuf:"varint,3,opt,name=RemoteAS,json=remote-as,omitempty,proto3" json:"remote-as,omitempty"`
	// BGP Multihop configuration, 0 disables multihop.
	MultiHop uint32 `protobuf:"varint,4,opt,name=MultiHop,json=multi-hop,omitempty,proto3" json:"multi-hop,omitempty"`
	// Address families to enable on the neighbor.
	EnableAddressFamilies []string `protobuf:"bytes,5,rep,name=EnableAddressFamilies,json=enable-address-families,omitempty" json:"enable-address-families,omitempty"`
	// Enable Password authentication. Disabled if the string is empty.
	Password string `protobuf:"bytes,6,opt,name=Password,json=password,omitempty,proto3" json:"password,omitempty"`
}

func (m *BGPNeighbor) Reset()                    { *m = BGPNeighbor{} }
func (m *BGPNeighbor) String() string            { return proto.CompactTextString(m) }
func (*BGPNeighbor) ProtoMessage()               {}
func (*BGPNeighbor) Descriptor() ([]byte, []int) { return fileDescriptorRoute, []int{1} }

func (m *BGPNeighbor) GetShutdown() bool {
	if m != nil {
		return m.Shutdown
	}
	return false
}

func (m *BGPNeighbor) GetIPAddress() string {
	if m != nil {
		return m.IPAddress
	}
	return ""
}

func (m *BGPNeighbor) GetRemoteAS() uint32 {
	if m != nil {
		return m.RemoteAS
	}
	return 0
}

func (m *BGPNeighbor) GetMultiHop() uint32 {
	if m != nil {
		return m.MultiHop
	}
	return 0
}

func (m *BGPNeighbor) GetEnableAddressFamilies() []string {
	if m != nil {
		return m.EnableAddressFamilies
	}
	return nil
}

func (m *BGPNeighbor) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

//
type EVPNConfig struct {
	//
	Shutdown bool `protobuf:"varint,1,opt,name=Shutdown,json=shutdown,omitempty,proto3" json:"shutdown,omitempty"`
}

func (m *EVPNConfig) Reset()                    { *m = EVPNConfig{} }
func (m *EVPNConfig) String() string            { return proto.CompactTextString(m) }
func (*EVPNConfig) ProtoMessage()               {}
func (*EVPNConfig) Descriptor() ([]byte, []int) { return fileDescriptorRoute, []int{2} }

func (m *EVPNConfig) GetShutdown() bool {
	if m != nil {
		return m.Shutdown
	}
	return false
}

//
type RDSpec struct {
	// Address family where this config applies.
	AddressFamily string `protobuf:"bytes,1,opt,name=AddressFamily,json=address-family,omitempty,proto3" json:"address-family,omitempty"`
	// True indicates the system will generate the RD automatically.
	RDAuto bool `protobuf:"varint,2,opt,name=RDAuto,json=rd-auto,omitempty,proto3" json:"rd-auto,omitempty"`
	// If Import and Export RDs are not specified, RD is used uniformly as RD, and import and export route-targets.
	RD *RouteDistinguisher `protobuf:"bytes,3,opt,name=RD,json=rd,omitempty" json:"rd,omitempty"`
	// Route Targets to Export.
	ExportRDs []*RouteDistinguisher `protobuf:"bytes,4,rep,name=ExportRDs,json=rd-export,omitempty" json:"rd-export,omitempty"`
	// Route Targets to Import.
	ImportRDs []*RouteDistinguisher `protobuf:"bytes,5,rep,name=ImportRDs,json=rd-import,omitempty" json:"rd-import,omitempty"`
}

func (m *RDSpec) Reset()                    { *m = RDSpec{} }
func (m *RDSpec) String() string            { return proto.CompactTextString(m) }
func (*RDSpec) ProtoMessage()               {}
func (*RDSpec) Descriptor() ([]byte, []int) { return fileDescriptorRoute, []int{3} }

func (m *RDSpec) GetAddressFamily() string {
	if m != nil {
		return m.AddressFamily
	}
	return ""
}

func (m *RDSpec) GetRDAuto() bool {
	if m != nil {
		return m.RDAuto
	}
	return false
}

func (m *RDSpec) GetRD() *RouteDistinguisher {
	if m != nil {
		return m.RD
	}
	return nil
}

func (m *RDSpec) GetExportRDs() []*RouteDistinguisher {
	if m != nil {
		return m.ExportRDs
	}
	return nil
}

func (m *RDSpec) GetImportRDs() []*RouteDistinguisher {
	if m != nil {
		return m.ImportRDs
	}
	return nil
}

//
type Route struct {
	// Route Prefix for the route.
	Prefix string `protobuf:"bytes,1,opt,name=Prefix,json=prefix,omitempty,proto3" json:"prefix,omitempty"`
	// NextHop for the route.
	NexhHop string `protobuf:"bytes,2,opt,name=NexhHop,json=next-hop,omitempty,proto3" json:"next-hop,omitempty"`
	// Target VirtualRouter instance
	TargetVirtualRouter string `protobuf:"bytes,3,opt,name=TargetVirtualRouter,json=target-virtual-router,omitempty,proto3" json:"target-virtual-router,omitempty"`
}

func (m *Route) Reset()                    { *m = Route{} }
func (m *Route) String() string            { return proto.CompactTextString(m) }
func (*Route) ProtoMessage()               {}
func (*Route) Descriptor() ([]byte, []int) { return fileDescriptorRoute, []int{4} }

func (m *Route) GetPrefix() string {
	if m != nil {
		return m.Prefix
	}
	return ""
}

func (m *Route) GetNexhHop() string {
	if m != nil {
		return m.NexhHop
	}
	return ""
}

func (m *Route) GetTargetVirtualRouter() string {
	if m != nil {
		return m.TargetVirtualRouter
	}
	return ""
}

//
type RouteDistinguisher struct {
	// RD Type as in rfc4364.
	Type string `protobuf:"bytes,1,opt,name=Type,json=type,omitempty,proto3" json:"type,omitempty"`
	// Administrator subfield of Value. Length depends on Type.
	AdminValue uint32 `protobuf:"varint,2,opt,name=AdminValue,json=admin-value,omitempty,proto3" json:"admin-value,omitempty"`
	// Assigned subfield of Value. Length depends on Type.
	AssignedValue uint32 `protobuf:"varint,3,opt,name=AssignedValue,json=assigned-value,omitempty,proto3" json:"assigned-value,omitempty"`
}

func (m *RouteDistinguisher) Reset()                    { *m = RouteDistinguisher{} }
func (m *RouteDistinguisher) String() string            { return proto.CompactTextString(m) }
func (*RouteDistinguisher) ProtoMessage()               {}
func (*RouteDistinguisher) Descriptor() ([]byte, []int) { return fileDescriptorRoute, []int{5} }

func (m *RouteDistinguisher) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *RouteDistinguisher) GetAdminValue() uint32 {
	if m != nil {
		return m.AdminValue
	}
	return 0
}

func (m *RouteDistinguisher) GetAssignedValue() uint32 {
	if m != nil {
		return m.AssignedValue
	}
	return 0
}

//
type RouteTable struct {
	//
	api.TypeMeta `protobuf:"bytes,1,opt,name=T,json=,inline,embedded=T" json:",inline"`
	//
	api.ObjectMeta `protobuf:"bytes,2,opt,name=O,json=meta,omitempty,embedded=O" json:"meta,omitempty"`
	// Spec contains the configuration of the Route Table.
	Spec RouteTableSpec `protobuf:"bytes,3,opt,name=Spec,json=spec,omitempty" json:"spec,omitempty"`
	// Status contains the current state of the Route Table.
	Status RouteTableStatus `protobuf:"bytes,4,opt,name=Status,json=status,omitempty" json:"status,omitempty"`
}

func (m *RouteTable) Reset()                    { *m = RouteTable{} }
func (m *RouteTable) String() string            { return proto.CompactTextString(m) }
func (*RouteTable) ProtoMessage()               {}
func (*RouteTable) Descriptor() ([]byte, []int) { return fileDescriptorRoute, []int{6} }

func (m *RouteTable) GetSpec() RouteTableSpec {
	if m != nil {
		return m.Spec
	}
	return RouteTableSpec{}
}

func (m *RouteTable) GetStatus() RouteTableStatus {
	if m != nil {
		return m.Status
	}
	return RouteTableStatus{}
}

//
type RouteTableSpec struct {
}

func (m *RouteTableSpec) Reset()                    { *m = RouteTableSpec{} }
func (m *RouteTableSpec) String() string            { return proto.CompactTextString(m) }
func (*RouteTableSpec) ProtoMessage()               {}
func (*RouteTableSpec) Descriptor() ([]byte, []int) { return fileDescriptorRoute, []int{7} }

//
type RouteTableStatus struct {
	//
	Routes []*Route `protobuf:"bytes,1,rep,name=Routes,json=routes,omitempty" json:"routes,omitempty"`
}

func (m *RouteTableStatus) Reset()                    { *m = RouteTableStatus{} }
func (m *RouteTableStatus) String() string            { return proto.CompactTextString(m) }
func (*RouteTableStatus) ProtoMessage()               {}
func (*RouteTableStatus) Descriptor() ([]byte, []int) { return fileDescriptorRoute, []int{8} }

func (m *RouteTableStatus) GetRoutes() []*Route {
	if m != nil {
		return m.Routes
	}
	return nil
}

//
type RoutingConfig struct {
	//
	api.TypeMeta `protobuf:"bytes,1,opt,name=T,json=,inline,embedded=T" json:",inline"`
	//
	api.ObjectMeta `protobuf:"bytes,2,opt,name=O,json=meta,omitempty,embedded=O" json:"meta,omitempty"`
	// Spec contains the configuration of the RoutingConfig.
	Spec RoutingConfigSpec `protobuf:"bytes,3,opt,name=Spec,json=spec,omitempty" json:"spec,omitempty"`
	// Status contains the current state of the RoutingConfig.
	Status RoutingConfigStatus `protobuf:"bytes,4,opt,name=Status,json=status,omitempty" json:"status,omitempty"`
}

func (m *RoutingConfig) Reset()                    { *m = RoutingConfig{} }
func (m *RoutingConfig) String() string            { return proto.CompactTextString(m) }
func (*RoutingConfig) ProtoMessage()               {}
func (*RoutingConfig) Descriptor() ([]byte, []int) { return fileDescriptorRoute, []int{9} }

func (m *RoutingConfig) GetSpec() RoutingConfigSpec {
	if m != nil {
		return m.Spec
	}
	return RoutingConfigSpec{}
}

func (m *RoutingConfig) GetStatus() RoutingConfigStatus {
	if m != nil {
		return m.Status
	}
	return RoutingConfigStatus{}
}

//
type RoutingConfigSpec struct {
	// Configuration for the BGP instance.
	BGPConfig *BGPConfig `protobuf:"bytes,1,opt,name=BGPConfig,json=bgp-config,omitempty" json:"bgp-config,omitempty"`
	// EVPN related configuration.
	EVPNConfig *EVPNConfig `protobuf:"bytes,2,opt,name=EVPNConfig,json=evpn-config,omitempty" json:"evpn-config,omitempty"`
}

func (m *RoutingConfigSpec) Reset()                    { *m = RoutingConfigSpec{} }
func (m *RoutingConfigSpec) String() string            { return proto.CompactTextString(m) }
func (*RoutingConfigSpec) ProtoMessage()               {}
func (*RoutingConfigSpec) Descriptor() ([]byte, []int) { return fileDescriptorRoute, []int{10} }

func (m *RoutingConfigSpec) GetBGPConfig() *BGPConfig {
	if m != nil {
		return m.BGPConfig
	}
	return nil
}

func (m *RoutingConfigSpec) GetEVPNConfig() *EVPNConfig {
	if m != nil {
		return m.EVPNConfig
	}
	return nil
}

//
type RoutingConfigStatus struct {
}

func (m *RoutingConfigStatus) Reset()                    { *m = RoutingConfigStatus{} }
func (m *RoutingConfigStatus) String() string            { return proto.CompactTextString(m) }
func (*RoutingConfigStatus) ProtoMessage()               {}
func (*RoutingConfigStatus) Descriptor() ([]byte, []int) { return fileDescriptorRoute, []int{11} }

func init() {
	proto.RegisterType((*BGPConfig)(nil), "network.BGPConfig")
	proto.RegisterType((*BGPNeighbor)(nil), "network.BGPNeighbor")
	proto.RegisterType((*EVPNConfig)(nil), "network.EVPNConfig")
	proto.RegisterType((*RDSpec)(nil), "network.RDSpec")
	proto.RegisterType((*Route)(nil), "network.Route")
	proto.RegisterType((*RouteDistinguisher)(nil), "network.RouteDistinguisher")
	proto.RegisterType((*RouteTable)(nil), "network.RouteTable")
	proto.RegisterType((*RouteTableSpec)(nil), "network.RouteTableSpec")
	proto.RegisterType((*RouteTableStatus)(nil), "network.RouteTableStatus")
	proto.RegisterType((*RoutingConfig)(nil), "network.RoutingConfig")
	proto.RegisterType((*RoutingConfigSpec)(nil), "network.RoutingConfigSpec")
	proto.RegisterType((*RoutingConfigStatus)(nil), "network.RoutingConfigStatus")
	proto.RegisterEnum("network.BGPAddressFamily", BGPAddressFamily_name, BGPAddressFamily_value)
	proto.RegisterEnum("network.RouteDistinguisher_RDType", RouteDistinguisher_RDType_name, RouteDistinguisher_RDType_value)
}
func (m *BGPConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RouterId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRoute(dAtA, i, uint64(len(m.RouterId)))
		i += copy(dAtA[i:], m.RouterId)
	}
	if m.ASNumber != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRoute(dAtA, i, uint64(m.ASNumber))
	}
	if len(m.Neighbors) > 0 {
		for _, msg := range m.Neighbors {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintRoute(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *BGPNeighbor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPNeighbor) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Shutdown {
		dAtA[i] = 0x8
		i++
		if m.Shutdown {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.IPAddress) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRoute(dAtA, i, uint64(len(m.IPAddress)))
		i += copy(dAtA[i:], m.IPAddress)
	}
	if m.RemoteAS != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintRoute(dAtA, i, uint64(m.RemoteAS))
	}
	if m.MultiHop != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintRoute(dAtA, i, uint64(m.MultiHop))
	}
	if len(m.EnableAddressFamilies) > 0 {
		for _, s := range m.EnableAddressFamilies {
			dAtA[i] = 0x2a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Password) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintRoute(dAtA, i, uint64(len(m.Password)))
		i += copy(dAtA[i:], m.Password)
	}
	return i, nil
}

func (m *EVPNConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EVPNConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Shutdown {
		dAtA[i] = 0x8
		i++
		if m.Shutdown {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *RDSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RDSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AddressFamily) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRoute(dAtA, i, uint64(len(m.AddressFamily)))
		i += copy(dAtA[i:], m.AddressFamily)
	}
	if m.RDAuto {
		dAtA[i] = 0x10
		i++
		if m.RDAuto {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.RD != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintRoute(dAtA, i, uint64(m.RD.Size()))
		n1, err := m.RD.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if len(m.ExportRDs) > 0 {
		for _, msg := range m.ExportRDs {
			dAtA[i] = 0x22
			i++
			i = encodeVarintRoute(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.ImportRDs) > 0 {
		for _, msg := range m.ImportRDs {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintRoute(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Route) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Route) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Prefix) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRoute(dAtA, i, uint64(len(m.Prefix)))
		i += copy(dAtA[i:], m.Prefix)
	}
	if len(m.NexhHop) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRoute(dAtA, i, uint64(len(m.NexhHop)))
		i += copy(dAtA[i:], m.NexhHop)
	}
	if len(m.TargetVirtualRouter) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintRoute(dAtA, i, uint64(len(m.TargetVirtualRouter)))
		i += copy(dAtA[i:], m.TargetVirtualRouter)
	}
	return i, nil
}

func (m *RouteDistinguisher) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouteDistinguisher) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRoute(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if m.AdminValue != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRoute(dAtA, i, uint64(m.AdminValue))
	}
	if m.AssignedValue != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintRoute(dAtA, i, uint64(m.AssignedValue))
	}
	return i, nil
}

func (m *RouteTable) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouteTable) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintRoute(dAtA, i, uint64(m.TypeMeta.Size()))
	n2, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n2
	dAtA[i] = 0x12
	i++
	i = encodeVarintRoute(dAtA, i, uint64(m.ObjectMeta.Size()))
	n3, err := m.ObjectMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n3
	dAtA[i] = 0x1a
	i++
	i = encodeVarintRoute(dAtA, i, uint64(m.Spec.Size()))
	n4, err := m.Spec.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n4
	dAtA[i] = 0x22
	i++
	i = encodeVarintRoute(dAtA, i, uint64(m.Status.Size()))
	n5, err := m.Status.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n5
	return i, nil
}

func (m *RouteTableSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouteTableSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *RouteTableStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouteTableStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Routes) > 0 {
		for _, msg := range m.Routes {
			dAtA[i] = 0xa
			i++
			i = encodeVarintRoute(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *RoutingConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoutingConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintRoute(dAtA, i, uint64(m.TypeMeta.Size()))
	n6, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n6
	dAtA[i] = 0x12
	i++
	i = encodeVarintRoute(dAtA, i, uint64(m.ObjectMeta.Size()))
	n7, err := m.ObjectMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n7
	dAtA[i] = 0x1a
	i++
	i = encodeVarintRoute(dAtA, i, uint64(m.Spec.Size()))
	n8, err := m.Spec.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n8
	dAtA[i] = 0x22
	i++
	i = encodeVarintRoute(dAtA, i, uint64(m.Status.Size()))
	n9, err := m.Status.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n9
	return i, nil
}

func (m *RoutingConfigSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoutingConfigSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.BGPConfig != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRoute(dAtA, i, uint64(m.BGPConfig.Size()))
		n10, err := m.BGPConfig.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.EVPNConfig != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRoute(dAtA, i, uint64(m.EVPNConfig.Size()))
		n11, err := m.EVPNConfig.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	return i, nil
}

func (m *RoutingConfigStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoutingConfigStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func encodeVarintRoute(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *BGPConfig) Size() (n int) {
	var l int
	_ = l
	l = len(m.RouterId)
	if l > 0 {
		n += 1 + l + sovRoute(uint64(l))
	}
	if m.ASNumber != 0 {
		n += 1 + sovRoute(uint64(m.ASNumber))
	}
	if len(m.Neighbors) > 0 {
		for _, e := range m.Neighbors {
			l = e.Size()
			n += 1 + l + sovRoute(uint64(l))
		}
	}
	return n
}

func (m *BGPNeighbor) Size() (n int) {
	var l int
	_ = l
	if m.Shutdown {
		n += 2
	}
	l = len(m.IPAddress)
	if l > 0 {
		n += 1 + l + sovRoute(uint64(l))
	}
	if m.RemoteAS != 0 {
		n += 1 + sovRoute(uint64(m.RemoteAS))
	}
	if m.MultiHop != 0 {
		n += 1 + sovRoute(uint64(m.MultiHop))
	}
	if len(m.EnableAddressFamilies) > 0 {
		for _, s := range m.EnableAddressFamilies {
			l = len(s)
			n += 1 + l + sovRoute(uint64(l))
		}
	}
	l = len(m.Password)
	if l > 0 {
		n += 1 + l + sovRoute(uint64(l))
	}
	return n
}

func (m *EVPNConfig) Size() (n int) {
	var l int
	_ = l
	if m.Shutdown {
		n += 2
	}
	return n
}

func (m *RDSpec) Size() (n int) {
	var l int
	_ = l
	l = len(m.AddressFamily)
	if l > 0 {
		n += 1 + l + sovRoute(uint64(l))
	}
	if m.RDAuto {
		n += 2
	}
	if m.RD != nil {
		l = m.RD.Size()
		n += 1 + l + sovRoute(uint64(l))
	}
	if len(m.ExportRDs) > 0 {
		for _, e := range m.ExportRDs {
			l = e.Size()
			n += 1 + l + sovRoute(uint64(l))
		}
	}
	if len(m.ImportRDs) > 0 {
		for _, e := range m.ImportRDs {
			l = e.Size()
			n += 1 + l + sovRoute(uint64(l))
		}
	}
	return n
}

func (m *Route) Size() (n int) {
	var l int
	_ = l
	l = len(m.Prefix)
	if l > 0 {
		n += 1 + l + sovRoute(uint64(l))
	}
	l = len(m.NexhHop)
	if l > 0 {
		n += 1 + l + sovRoute(uint64(l))
	}
	l = len(m.TargetVirtualRouter)
	if l > 0 {
		n += 1 + l + sovRoute(uint64(l))
	}
	return n
}

func (m *RouteDistinguisher) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovRoute(uint64(l))
	}
	if m.AdminValue != 0 {
		n += 1 + sovRoute(uint64(m.AdminValue))
	}
	if m.AssignedValue != 0 {
		n += 1 + sovRoute(uint64(m.AssignedValue))
	}
	return n
}

func (m *RouteTable) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovRoute(uint64(l))
	l = m.ObjectMeta.Size()
	n += 1 + l + sovRoute(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovRoute(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovRoute(uint64(l))
	return n
}

func (m *RouteTableSpec) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *RouteTableStatus) Size() (n int) {
	var l int
	_ = l
	if len(m.Routes) > 0 {
		for _, e := range m.Routes {
			l = e.Size()
			n += 1 + l + sovRoute(uint64(l))
		}
	}
	return n
}

func (m *RoutingConfig) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovRoute(uint64(l))
	l = m.ObjectMeta.Size()
	n += 1 + l + sovRoute(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovRoute(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovRoute(uint64(l))
	return n
}

func (m *RoutingConfigSpec) Size() (n int) {
	var l int
	_ = l
	if m.BGPConfig != nil {
		l = m.BGPConfig.Size()
		n += 1 + l + sovRoute(uint64(l))
	}
	if m.EVPNConfig != nil {
		l = m.EVPNConfig.Size()
		n += 1 + l + sovRoute(uint64(l))
	}
	return n
}

func (m *RoutingConfigStatus) Size() (n int) {
	var l int
	_ = l
	return n
}

func sovRoute(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozRoute(x uint64) (n int) {
	return sovRoute(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *BGPConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouterId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RouterId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ASNumber", wireType)
			}
			m.ASNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ASNumber |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Neighbors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Neighbors = append(m.Neighbors, &BGPNeighbor{})
			if err := m.Neighbors[len(m.Neighbors)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPNeighbor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPNeighbor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPNeighbor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shutdown", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Shutdown = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IPAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IPAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoteAS", wireType)
			}
			m.RemoteAS = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RemoteAS |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MultiHop", wireType)
			}
			m.MultiHop = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MultiHop |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableAddressFamilies", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EnableAddressFamilies = append(m.EnableAddressFamilies, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Password", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Password = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EVPNConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EVPNConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EVPNConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shutdown", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Shutdown = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipRoute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RDSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RDSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RDSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddressFamily", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AddressFamily = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RDAuto", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RDAuto = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RD", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RD == nil {
				m.RD = &RouteDistinguisher{}
			}
			if err := m.RD.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExportRDs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExportRDs = append(m.ExportRDs, &RouteDistinguisher{})
			if err := m.ExportRDs[len(m.ExportRDs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImportRDs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ImportRDs = append(m.ImportRDs, &RouteDistinguisher{})
			if err := m.ImportRDs[len(m.ImportRDs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Route) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Route: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Route: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Prefix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NexhHop", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NexhHop = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetVirtualRouter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TargetVirtualRouter = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RouteDistinguisher) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RouteDistinguisher: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RouteDistinguisher: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdminValue", wireType)
			}
			m.AdminValue = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AdminValue |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssignedValue", wireType)
			}
			m.AssignedValue = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AssignedValue |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRoute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RouteTable) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RouteTable: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RouteTable: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RouteTableSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RouteTableSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RouteTableSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipRoute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RouteTableStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RouteTableStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RouteTableStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Routes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Routes = append(m.Routes, &Route{})
			if err := m.Routes[len(m.Routes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoutingConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoutingConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoutingConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoutingConfigSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoutingConfigSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoutingConfigSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BGPConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BGPConfig == nil {
				m.BGPConfig = &BGPConfig{}
			}
			if err := m.BGPConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EVPNConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EVPNConfig == nil {
				m.EVPNConfig = &EVPNConfig{}
			}
			if err := m.EVPNConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoutingConfigStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoutingConfigStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoutingConfigStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipRoute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipRoute(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthRoute
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowRoute
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipRoute(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthRoute = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowRoute   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("route.proto", fileDescriptorRoute) }

var fileDescriptorRoute = []byte{
	// 1303 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x56, 0xcd, 0x6f, 0x1b, 0x45,
	0x14, 0xcf, 0x3a, 0x89, 0x63, 0x8f, 0x93, 0xb0, 0x9d, 0x24, 0xad, 0x37, 0xad, 0x62, 0x77, 0x01,
	0xc9, 0x81, 0xac, 0xdd, 0x9a, 0x52, 0x15, 0xc4, 0x57, 0xb6, 0x76, 0x43, 0x2a, 0x92, 0x58, 0x76,
	0x1a, 0x3e, 0xc4, 0x65, 0x6d, 0x4f, 0x36, 0xd3, 0xda, 0xb3, 0xab, 0x9d, 0xd9, 0x7c, 0x08, 0x71,
	0xa3, 0x16, 0x7f, 0x02, 0xe2, 0xc8, 0x31, 0xe2, 0xc6, 0x8d, 0x3b, 0x52, 0x8f, 0xa5, 0xdc, 0x2d,
	0x94, 0x13, 0xf2, 0x81, 0xbf, 0x01, 0xcd, 0xec, 0x3a, 0x9d, 0xb5, 0x37, 0x2d, 0x15, 0x07, 0x4e,
	0xbb, 0xf3, 0x9b, 0xf7, 0x7e, 0x33, 0xef, 0xf7, 0xe6, 0xbd, 0x19, 0x90, 0xf1, 0x1c, 0x9f, 0xa1,
	0xa2, 0xeb, 0x39, 0xcc, 0x81, 0x33, 0x04, 0xb1, 0x23, 0xc7, 0x7b, 0xb4, 0x7c, 0xcd, 0x76, 0x1c,
	0xbb, 0x83, 0x4a, 0x96, 0x8b, 0x4b, 0x16, 0x21, 0x0e, 0xb3, 0x18, 0x76, 0x08, 0x0d, 0xcc, 0x96,
	0xab, 0x36, 0x66, 0x07, 0x7e, 0xb3, 0xd8, 0x72, 0xba, 0x25, 0x17, 0x11, 0x6a, 0x91, 0xb6, 0x53,
	0xa2, 0x47, 0xa5, 0x43, 0x44, 0x70, 0x0b, 0x95, 0x7c, 0x86, 0x3b, 0x94, 0xbb, 0xda, 0x88, 0xc8,
	0xde, 0x25, 0x4c, 0x5a, 0x1d, 0xbf, 0x8d, 0x86, 0x34, 0x86, 0x44, 0x63, 0x3b, 0xb6, 0x53, 0x12,
	0x70, 0xd3, 0xdf, 0x17, 0x23, 0x31, 0x10, 0x7f, 0xa1, 0xf9, 0x9b, 0x17, 0xac, 0xca, 0xf7, 0xd8,
	0x45, 0xcc, 0x0a, 0xcd, 0x6e, 0xbc, 0xc0, 0xac, 0x63, 0x35, 0x51, 0x87, 0x96, 0x28, 0xea, 0xa0,
	0x16, 0x73, 0xbc, 0xd0, 0x63, 0x96, 0x21, 0x62, 0x11, 0x16, 0x8c, 0xf4, 0xbf, 0x15, 0x90, 0x36,
	0x37, 0x6a, 0x77, 0x1d, 0xb2, 0x8f, 0x6d, 0x78, 0x1f, 0xa4, 0xea, 0x5c, 0x20, 0x6f, 0xb3, 0x9d,
	0x55, 0xf2, 0x4a, 0x21, 0x6d, 0xbe, 0x7e, 0xda, 0xd3, 0x52, 0x9b, 0xb5, 0xf5, 0x76, 0xdb, 0x2b,
	0xac, 0x0e, 0xfa, 0xb9, 0x05, 0x21, 0xa0, 0x67, 0xe0, 0xf6, 0x9a, 0xd3, 0xc5, 0x0c, 0x75, 0x5d,
	0x76, 0x52, 0x8f, 0x03, 0xe1, 0x47, 0x20, 0xb5, 0xde, 0xd8, 0xf6, 0xbb, 0x4d, 0xe4, 0x65, 0x13,
	0x79, 0xa5, 0x30, 0x67, 0x5e, 0xe1, 0xfe, 0x16, 0x35, 0x88, 0x00, 0x65, 0xff, 0x18, 0x10, 0x3e,
	0x00, 0xe9, 0x6d, 0x84, 0xed, 0x83, 0xa6, 0xe3, 0xd1, 0xec, 0x64, 0x7e, 0xb2, 0x90, 0x29, 0x2f,
	0x16, 0xc3, 0x8c, 0x15, 0xcd, 0x8d, 0xda, 0x70, 0x32, 0xa0, 0x25, 0x43, 0x53, 0x99, 0x36, 0x06,
	0xd4, 0x7f, 0x9c, 0x02, 0x19, 0xc9, 0x1b, 0x7e, 0x00, 0x52, 0x8d, 0x03, 0x9f, 0xb5, 0x9d, 0x23,
	0x22, 0x42, 0x4e, 0x99, 0x97, 0x07, 0xfd, 0x1c, 0xa4, 0x21, 0x26, 0xd1, 0xc5, 0x60, 0x70, 0x0b,
	0xa4, 0x03, 0x71, 0x10, 0xa5, 0x22, 0xca, 0xb4, 0xf9, 0xc6, 0x88, 0x62, 0x8b, 0xd8, 0x35, 0xac,
	0xc0, 0x42, 0x22, 0x8b, 0x45, 0xb9, 0x66, 0x75, 0xd4, 0x75, 0x18, 0x5a, 0x6f, 0x64, 0x27, 0x9f,
	0x6b, 0xe6, 0x09, 0xcc, 0xb0, 0x22, 0xc1, 0xc5, 0x80, 0xb0, 0x0e, 0x52, 0x5b, 0x7e, 0x87, 0xe1,
	0x4f, 0x1d, 0x37, 0x3b, 0x25, 0xfc, 0xdf, 0x3e, 0xed, 0x69, 0xea, 0x26, 0x61, 0x75, 0x8b, 0xd8,
	0xa8, 0x70, 0x63, 0x2d, 0x5f, 0x7e, 0xf7, 0xb6, 0xc8, 0x63, 0x97, 0xdb, 0x19, 0x07, 0x8e, 0x2b,
	0x73, 0xc6, 0x80, 0xf0, 0x3b, 0x05, 0x2c, 0x55, 0x89, 0xd5, 0xec, 0xa0, 0x30, 0xce, 0x7b, 0x56,
	0x17, 0x77, 0x30, 0xa2, 0xd9, 0xe9, 0xfc, 0x64, 0x21, 0x6d, 0x9a, 0xa7, 0x3d, 0x4d, 0x6b, 0x30,
	0xaf, 0x4a, 0xfc, 0x6e, 0xc1, 0xdc, 0xa8, 0xc9, 0x56, 0x27, 0x7c, 0xa9, 0xeb, 0x48, 0x78, 0x0f,
	0xc3, 0x35, 0xf6, 0x43, 0x7f, 0x69, 0xe1, 0x97, 0x9b, 0xc0, 0x16, 0x48, 0xd5, 0x2c, 0x4a, 0x8f,
	0x1c, 0xaf, 0x9d, 0x4d, 0x0a, 0xa1, 0x3f, 0x3c, 0xed, 0x69, 0x57, 0xaa, 0x7c, 0x72, 0xc7, 0x2b,
	0x34, 0x98, 0xf7, 0x19, 0x22, 0x85, 0x9b, 0x6b, 0xf9, 0x9b, 0xe5, 0x3b, 0xab, 0xab, 0xbf, 0xf6,
	0xb4, 0x54, 0x03, 0xb5, 0x3c, 0xc4, 0x44, 0x0e, 0xa0, 0x1b, 0xba, 0xca, 0xe9, 0x1c, 0xc7, 0xf4,
	0xfb, 0x00, 0x54, 0xf7, 0x6a, 0xdb, 0x61, 0x35, 0xfc, 0xa7, 0xa3, 0xa1, 0xff, 0x32, 0x09, 0x92,
	0xf5, 0x4a, 0xc3, 0x45, 0x2d, 0xf8, 0x10, 0xcc, 0x45, 0x54, 0x09, 0x6b, 0xeb, 0xbd, 0x97, 0x29,
	0x97, 0x8d, 0xe8, 0x71, 0x22, 0x2d, 0x78, 0xe1, 0x0c, 0xbc, 0xc3, 0x57, 0x5d, 0xf7, 0x99, 0x23,
	0x8e, 0x63, 0xca, 0x5c, 0x1a, 0xf4, 0x73, 0x97, 0xbc, 0xb6, 0x61, 0xf9, 0xcc, 0x91, 0x08, 0xc6,
	0x21, 0xb8, 0x01, 0x12, 0xf5, 0x8a, 0x38, 0x76, 0x99, 0xf2, 0xd5, 0xf3, 0x4a, 0x13, 0xfd, 0xa0,
	0x82, 0x29, 0xc3, 0xc4, 0xf6, 0x31, 0x3d, 0x40, 0x9e, 0xa9, 0x0e, 0xfa, 0xb9, 0xd9, 0x88, 0x96,
	0x91, 0x11, 0xfc, 0x1a, 0xa4, 0xab, 0xc7, 0xae, 0xe3, 0xb1, 0x7a, 0x85, 0x66, 0xa7, 0x44, 0xe5,
	0xbe, 0x90, 0x2f, 0x38, 0xe3, 0x6d, 0x03, 0x09, 0xa7, 0xc8, 0x19, 0x1f, 0x07, 0x39, 0xfb, 0x66,
	0x77, 0xc8, 0x3e, 0xfd, 0xef, 0xd9, 0x71, 0x37, 0x86, 0x7d, 0x14, 0xd4, 0x7f, 0x48, 0x80, 0x69,
	0x41, 0x02, 0x3f, 0x01, 0xc9, 0x9a, 0x87, 0xf6, 0xf1, 0x71, 0x98, 0xad, 0x95, 0xd3, 0x9e, 0x96,
	0xbc, 0xbb, 0x59, 0xa9, 0x8b, 0x13, 0xa5, 0xba, 0x62, 0x4e, 0xa2, 0x1b, 0x43, 0x60, 0x15, 0xcc,
	0x6c, 0xa3, 0xe3, 0x03, 0x5e, 0x8c, 0x41, 0x6b, 0xc8, 0x47, 0x28, 0x20, 0x41, 0xc7, 0x6c, 0xa4,
	0x02, 0x63, 0x30, 0xf8, 0x58, 0x01, 0x0b, 0xbb, 0x96, 0x67, 0x23, 0xb6, 0x87, 0x3d, 0xe6, 0x5b,
	0x9d, 0xa0, 0x45, 0x8b, 0x4c, 0xa5, 0xcd, 0x8d, 0x9f, 0x7a, 0x5a, 0x1e, 0xcc, 0x7c, 0x8e, 0xac,
	0x47, 0x75, 0xb4, 0x0f, 0x97, 0x42, 0x25, 0x4a, 0x11, 0xdb, 0x41, 0x3f, 0x97, 0x63, 0x82, 0xc2,
	0x38, 0x0c, 0x70, 0x23, 0x68, 0xd9, 0xd2, 0xd2, 0x2f, 0x33, 0xd0, 0x7f, 0x4e, 0x00, 0x38, 0xae,
	0x2f, 0xdc, 0x03, 0x53, 0xbb, 0x27, 0x2e, 0x0a, 0x55, 0xba, 0x73, 0xda, 0xd3, 0xf4, 0xe1, 0x99,
	0x1e, 0xb7, 0x2e, 0xd6, 0x2b, 0xdc, 0x98, 0x87, 0x3f, 0xcf, 0x4e, 0x5c, 0x24, 0xad, 0x3f, 0x32,
	0x86, 0x15, 0x00, 0xd6, 0xdb, 0x5d, 0x4c, 0xf6, 0xac, 0x8e, 0x8f, 0xc2, 0x1b, 0x44, 0x1b, 0xf4,
	0x73, 0x4b, 0x16, 0x47, 0x8d, 0x43, 0x0e, 0x4b, 0xee, 0xf1, 0x30, 0xdc, 0x02, 0x73, 0xeb, 0x94,
	0x62, 0x9b, 0xa0, 0x76, 0x40, 0x14, 0xb4, 0xd5, 0x6b, 0xa2, 0xba, 0xc2, 0x89, 0x31, 0xae, 0x0b,
	0x67, 0xf4, 0x55, 0x5e, 0x5d, 0x3c, 0x02, 0x98, 0x06, 0xd3, 0xfc, 0x7b, 0x43, 0x9d, 0x18, 0xfe,
	0xde, 0x54, 0x95, 0xe1, 0x6f, 0x59, 0x4d, 0xe8, 0x7f, 0x24, 0x00, 0x10, 0x02, 0xec, 0xf2, 0xd6,
	0x06, 0x6f, 0x03, 0x65, 0x57, 0x68, 0x94, 0x29, 0xcf, 0x15, 0x2d, 0x17, 0x17, 0xb9, 0xdd, 0x16,
	0x62, 0x96, 0xb9, 0xf0, 0xa4, 0x9f, 0x9b, 0x78, 0xda, 0xcf, 0x29, 0x83, 0x7e, 0x6e, 0x66, 0x0d,
	0x93, 0x0e, 0x26, 0xa8, 0x3e, 0xfc, 0x81, 0xf7, 0x80, 0xb2, 0x23, 0xa2, 0xcf, 0x94, 0x5f, 0x13,
	0x7e, 0x3b, 0xcd, 0x87, 0xa8, 0xc5, 0x84, 0xe7, 0xb2, 0xe4, 0x39, 0xcf, 0x1f, 0x05, 0xb2, 0x9c,
	0xd1, 0x31, 0xdc, 0x02, 0x53, 0xbc, 0x17, 0x85, 0xf5, 0x7d, 0x25, 0x5a, 0x31, 0x62, 0x8b, 0x7c,
	0xda, 0xbc, 0xcc, 0x29, 0x39, 0x1d, 0x75, 0x51, 0x4b, 0xa6, 0x8b, 0x8e, 0xe1, 0x03, 0x90, 0x6c,
	0x30, 0x8b, 0xf9, 0x54, 0xdc, 0x33, 0x99, 0xb2, 0x16, 0x47, 0x28, 0x0c, 0xcc, 0x6c, 0x48, 0xa9,
	0x52, 0x31, 0x96, 0x4b, 0x66, 0x14, 0x79, 0x3f, 0xf7, 0xec, 0xb1, 0x76, 0x15, 0x64, 0x4a, 0xdf,
	0xec, 0x14, 0x77, 0xc5, 0x33, 0xe5, 0x5b, 0x38, 0x2b, 0x0e, 0xa2, 0xc1, 0x38, 0x23, 0xd5, 0x55,
	0x30, 0x1f, 0xdd, 0xb1, 0xfe, 0x15, 0x50, 0x47, 0x97, 0x84, 0xf7, 0x40, 0x52, 0x60, 0x34, 0xab,
	0x88, 0x06, 0x31, 0x1f, 0xdd, 0x9d, 0xb9, 0xc8, 0xb7, 0x23, 0x78, 0x23, 0xdb, 0x19, 0x45, 0xf4,
	0xdf, 0x13, 0x60, 0x8e, 0x7b, 0x60, 0x62, 0x87, 0x77, 0xc2, 0xff, 0x9d, 0xc6, 0x5a, 0x24, 0x8d,
	0xcb, 0x91, 0xb8, 0xce, 0x77, 0xf9, 0x4a, 0x99, 0xfc, 0x62, 0x24, 0x93, 0xd7, 0x2e, 0xe0, 0x7c,
	0xf5, 0x64, 0x2e, 0x3e, 0x7b, 0xac, 0xa9, 0x70, 0xde, 0x0b, 0x68, 0x8c, 0x96, 0xe0, 0xd1, 0x7f,
	0x53, 0xc0, 0xa5, 0xb1, 0xdd, 0xf2, 0xd7, 0xde, 0xf9, 0x33, 0x34, 0xd4, 0x17, 0xca, 0xaf, 0xbd,
	0x60, 0xc6, 0xcc, 0xf2, 0x07, 0x55, 0xd3, 0x76, 0x43, 0x32, 0xf9, 0x41, 0x15, 0x87, 0xc2, 0x2f,
	0xe5, 0x0b, 0x3d, 0xd4, 0x7f, 0xe1, 0x9c, 0xf7, 0xf9, 0x54, 0xd0, 0x59, 0xd0, 0xa1, 0x4b, 0xc6,
	0x99, 0xe3, 0x61, 0x7d, 0x09, 0x2c, 0xc4, 0x08, 0xf4, 0xd6, 0xc7, 0x40, 0x1d, 0xbd, 0xca, 0xe1,
	0x75, 0x90, 0xd9, 0xac, 0x1d, 0xde, 0x7a, 0x40, 0x70, 0xcb, 0xa2, 0x4c, 0x9d, 0x58, 0x56, 0xcf,
	0xbe, 0xd7, 0x66, 0xb1, 0x7b, 0x78, 0xcb, 0xf0, 0x03, 0x0c, 0xa6, 0xc0, 0x14, 0xdf, 0x8d, 0xaa,
	0x98, 0xea, 0x93, 0xb3, 0x15, 0xe5, 0xe9, 0xd9, 0x8a, 0xf2, 0xe7, 0xd9, 0x8a, 0xf2, 0xd7, 0xd9,
	0xca, 0x44, 0x4d, 0x69, 0x26, 0xc5, 0x63, 0xfd, 0x9d, 0x7f, 0x02, 0x00, 0x00, 0xff, 0xff, 0xa0,
	0xa4, 0x4c, 0x4c, 0xbf, 0x0c, 0x00, 0x00,
}
