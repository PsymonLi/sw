// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: route.proto

package network

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/pensando/grpc-gateway/third_party/googleapis/google/api"
import _ "github.com/pensando/sw/venice/utils/apigen/annotations"
import _ "github.com/gogo/protobuf/gogoproto"
import api "github.com/pensando/sw/api"
import _ "github.com/pensando/sw/api/labels"
import _ "github.com/pensando/sw/api/generated/cluster"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

//
type BGPAddressFamily int32

const (
	//
	BGPAddressFamily_IPv4Unicast BGPAddressFamily = 0
	//
	BGPAddressFamily_L2vpnEvpn BGPAddressFamily = 1
)

var BGPAddressFamily_name = map[int32]string{
	0: "IPv4Unicast",
	1: "L2vpnEvpn",
}
var BGPAddressFamily_value = map[string]int32{
	"IPv4Unicast": 0,
	"L2vpnEvpn":   1,
}

func (BGPAddressFamily) EnumDescriptor() ([]byte, []int) { return fileDescriptorRoute, []int{0} }

//
type BGPAuthStatus_AuthStatus int32

const (
	//
	BGPAuthStatus_Disabled BGPAuthStatus_AuthStatus = 0
	//
	BGPAuthStatus_Enabled BGPAuthStatus_AuthStatus = 1
)

var BGPAuthStatus_AuthStatus_name = map[int32]string{
	0: "Disabled",
	1: "Enabled",
}
var BGPAuthStatus_AuthStatus_value = map[string]int32{
	"Disabled": 0,
	"Enabled":  1,
}

func (BGPAuthStatus_AuthStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorRoute, []int{0, 0}
}

//
type RouteDistinguisher_RDType int32

const (
	//
	RouteDistinguisher_Type0 RouteDistinguisher_RDType = 0
	//
	RouteDistinguisher_Type1 RouteDistinguisher_RDType = 1
	//
	RouteDistinguisher_Type2 RouteDistinguisher_RDType = 2
)

var RouteDistinguisher_RDType_name = map[int32]string{
	0: "Type0",
	1: "Type1",
	2: "Type2",
}
var RouteDistinguisher_RDType_value = map[string]int32{
	"Type0": 0,
	"Type1": 1,
	"Type2": 2,
}

func (RouteDistinguisher_RDType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorRoute, []int{6, 0}
}

//
type BGPAuthStatus struct {
	// Neighbor IP Address.
	IPAddress string `protobuf:"bytes,1,opt,name=IPAddress,json=ip-address,omitempty,proto3" json:"ip-address,omitempty"`
	// ASN the neighbor belongs to.
	RemoteAS uint32 `protobuf:"varint,2,opt,name=RemoteAS,json=remote-as,omitempty,proto3" json:"remote-as,omitempty"`
	// Authentication status.
	Status string `protobuf:"bytes,3,opt,name=Status,json=status,omitempty,proto3" json:"status,omitempty"`
}

func (m *BGPAuthStatus) Reset()                    { *m = BGPAuthStatus{} }
func (m *BGPAuthStatus) String() string            { return proto.CompactTextString(m) }
func (*BGPAuthStatus) ProtoMessage()               {}
func (*BGPAuthStatus) Descriptor() ([]byte, []int) { return fileDescriptorRoute, []int{0} }

func (m *BGPAuthStatus) GetIPAddress() string {
	if m != nil {
		return m.IPAddress
	}
	return ""
}

func (m *BGPAuthStatus) GetRemoteAS() uint32 {
	if m != nil {
		return m.RemoteAS
	}
	return 0
}

func (m *BGPAuthStatus) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

//
type BGPConfig struct {
	// Router ID for the BGP Instance.
	RouterId string `protobuf:"bytes,1,opt,name=RouterId,json=router-id,omitempty,proto3" json:"router-id,omitempty"`
	// Local ASN for the BGP Instance.
	ASNumber api.BgpAsn `protobuf:"bytes,2,opt,name=ASNumber,json=as-number,omitempty" json:"as-number,omitempty"`
	// KeepaliveInterval is time interval at which keepalive messages are sent.
	KeepaliveInterval uint32 `protobuf:"varint,3,opt,name=KeepaliveInterval,json=keepalive-interval,omitempty,proto3" json:"keepalive-interval,omitempty"`
	// Holdtime is time for which not receiving a keepalive message results in declaring the peer as dead.
	Holdtime uint32 `protobuf:"varint,4,opt,name=Holdtime,json=holdtime,omitempty,proto3" json:"holdtime,omitempty"`
	// DSCAutoConfig sets the flag that this config is to be used as a template for auto configuration.
	DSCAutoConfig bool `protobuf:"varint,5,opt,name=DSCAutoConfig,json=dsc-auto-config,omitempty,proto3" json:"dsc-auto-config,omitempty"`
	// List of all neighbors.
	Neighbors []*BGPNeighbor `protobuf:"bytes,6,rep,name=Neighbors,json=neighbors,omitempty" json:"neighbors,omitempty"`
}

func (m *BGPConfig) Reset()                    { *m = BGPConfig{} }
func (m *BGPConfig) String() string            { return proto.CompactTextString(m) }
func (*BGPConfig) ProtoMessage()               {}
func (*BGPConfig) Descriptor() ([]byte, []int) { return fileDescriptorRoute, []int{1} }

func (m *BGPConfig) GetRouterId() string {
	if m != nil {
		return m.RouterId
	}
	return ""
}

func (m *BGPConfig) GetASNumber() api.BgpAsn {
	if m != nil {
		return m.ASNumber
	}
	return api.BgpAsn{}
}

func (m *BGPConfig) GetKeepaliveInterval() uint32 {
	if m != nil {
		return m.KeepaliveInterval
	}
	return 0
}

func (m *BGPConfig) GetHoldtime() uint32 {
	if m != nil {
		return m.Holdtime
	}
	return 0
}

func (m *BGPConfig) GetDSCAutoConfig() bool {
	if m != nil {
		return m.DSCAutoConfig
	}
	return false
}

func (m *BGPConfig) GetNeighbors() []*BGPNeighbor {
	if m != nil {
		return m.Neighbors
	}
	return nil
}

//
type BGPNeighbor struct {
	// Shutdown this neighbor session.
	Shutdown bool `protobuf:"varint,1,opt,name=Shutdown,json=shutdown,omitempty,proto3" json:"shutdown,omitempty"`
	// Neighbor IP Address.
	IPAddress string `protobuf:"bytes,2,opt,name=IPAddress,json=ip-address,omitempty,proto3" json:"ip-address,omitempty"`
	// ASN the neighbor belongs to.
	RemoteAS api.BgpAsn `protobuf:"bytes,3,opt,name=RemoteAS,json=remote-as,omitempty" json:"remote-as,omitempty"`
	// BGP Multihop configuration.
	MultiHop uint32 `protobuf:"varint,4,opt,name=MultiHop,json=multi-hop,omitempty,proto3" json:"multi-hop,omitempty"`
	// Address families to enable on the neighbor.
	EnableAddressFamilies []string `protobuf:"bytes,5,rep,name=EnableAddressFamilies,json=enable-address-families,omitempty" json:"enable-address-families,omitempty"`
	// Enable Password authentication. Disabled if the string is empty.
	Password string `protobuf:"bytes,6,opt,name=Password,json=password,omitempty,proto3" json:"password,omitempty"`
	// DSCAutoConfig sets the flag that this neighbor config is to be used as a template for auto configuration.
	DSCAutoConfig bool `protobuf:"varint,7,opt,name=DSCAutoConfig,json=dsc-auto-config,omitempty,proto3" json:"dsc-auto-config,omitempty"`
	// KeepaliveInterval is time interval at which keepalive messages are sent.
	KeepaliveInterval uint32 `protobuf:"varint,8,opt,name=KeepaliveInterval,json=keepalive-interval,omitempty,proto3" json:"keepalive-interval,omitempty"`
	// Holdtime is time for which not receiving a keepalive message results in declaring the peer as dead.
	Holdtime uint32 `protobuf:"varint,9,opt,name=Holdtime,json=holdtime,omitempty,proto3" json:"holdtime,omitempty"`
}

func (m *BGPNeighbor) Reset()                    { *m = BGPNeighbor{} }
func (m *BGPNeighbor) String() string            { return proto.CompactTextString(m) }
func (*BGPNeighbor) ProtoMessage()               {}
func (*BGPNeighbor) Descriptor() ([]byte, []int) { return fileDescriptorRoute, []int{2} }

func (m *BGPNeighbor) GetShutdown() bool {
	if m != nil {
		return m.Shutdown
	}
	return false
}

func (m *BGPNeighbor) GetIPAddress() string {
	if m != nil {
		return m.IPAddress
	}
	return ""
}

func (m *BGPNeighbor) GetRemoteAS() api.BgpAsn {
	if m != nil {
		return m.RemoteAS
	}
	return api.BgpAsn{}
}

func (m *BGPNeighbor) GetMultiHop() uint32 {
	if m != nil {
		return m.MultiHop
	}
	return 0
}

func (m *BGPNeighbor) GetEnableAddressFamilies() []string {
	if m != nil {
		return m.EnableAddressFamilies
	}
	return nil
}

func (m *BGPNeighbor) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

func (m *BGPNeighbor) GetDSCAutoConfig() bool {
	if m != nil {
		return m.DSCAutoConfig
	}
	return false
}

func (m *BGPNeighbor) GetKeepaliveInterval() uint32 {
	if m != nil {
		return m.KeepaliveInterval
	}
	return 0
}

func (m *BGPNeighbor) GetHoldtime() uint32 {
	if m != nil {
		return m.Holdtime
	}
	return 0
}

//
type EVPNConfig struct {
	//
	Shutdown bool `protobuf:"varint,1,opt,name=Shutdown,json=shutdown,omitempty,proto3" json:"shutdown,omitempty"`
}

func (m *EVPNConfig) Reset()                    { *m = EVPNConfig{} }
func (m *EVPNConfig) String() string            { return proto.CompactTextString(m) }
func (*EVPNConfig) ProtoMessage()               {}
func (*EVPNConfig) Descriptor() ([]byte, []int) { return fileDescriptorRoute, []int{3} }

func (m *EVPNConfig) GetShutdown() bool {
	if m != nil {
		return m.Shutdown
	}
	return false
}

//
type RDSpec struct {
	// Address family where this config applies.
	AddressFamily string `protobuf:"bytes,1,opt,name=AddressFamily,json=address-family,omitempty,proto3" json:"address-family,omitempty"`
	// True indicates the system will generate the RD automatically.
	RDAuto bool `protobuf:"varint,2,opt,name=RDAuto,json=rd-auto,omitempty,proto3" json:"rd-auto,omitempty"`
	// If Import and Export RDs are not specified, RD is used uniformly as RD, and import and export route-targets.
	RD *RouteDistinguisher `protobuf:"bytes,3,opt,name=RD,json=rd,omitempty" json:"rd,omitempty"`
	// Route Targets to Export.
	ExportRTs []*RouteDistinguisher `protobuf:"bytes,4,rep,name=ExportRTs,json=rt-export,omitempty" json:"rt-export,omitempty"`
	// Route Targets to Import.
	ImportRTs []*RouteDistinguisher `protobuf:"bytes,5,rep,name=ImportRTs,json=rt-import,omitempty" json:"rt-import,omitempty"`
}

func (m *RDSpec) Reset()                    { *m = RDSpec{} }
func (m *RDSpec) String() string            { return proto.CompactTextString(m) }
func (*RDSpec) ProtoMessage()               {}
func (*RDSpec) Descriptor() ([]byte, []int) { return fileDescriptorRoute, []int{4} }

func (m *RDSpec) GetAddressFamily() string {
	if m != nil {
		return m.AddressFamily
	}
	return ""
}

func (m *RDSpec) GetRDAuto() bool {
	if m != nil {
		return m.RDAuto
	}
	return false
}

func (m *RDSpec) GetRD() *RouteDistinguisher {
	if m != nil {
		return m.RD
	}
	return nil
}

func (m *RDSpec) GetExportRTs() []*RouteDistinguisher {
	if m != nil {
		return m.ExportRTs
	}
	return nil
}

func (m *RDSpec) GetImportRTs() []*RouteDistinguisher {
	if m != nil {
		return m.ImportRTs
	}
	return nil
}

//
type Route struct {
	// Route Prefix for the route.
	Prefix string `protobuf:"bytes,1,opt,name=Prefix,json=prefix,omitempty,proto3" json:"prefix,omitempty"`
	// NextHop for the route.
	NexhHop string `protobuf:"bytes,2,opt,name=NexhHop,json=next-hop,omitempty,proto3" json:"next-hop,omitempty"`
	// Target VirtualRouter instance
	TargetVirtualRouter string `protobuf:"bytes,3,opt,name=TargetVirtualRouter,json=target-virtual-router,omitempty,proto3" json:"target-virtual-router,omitempty"`
}

func (m *Route) Reset()                    { *m = Route{} }
func (m *Route) String() string            { return proto.CompactTextString(m) }
func (*Route) ProtoMessage()               {}
func (*Route) Descriptor() ([]byte, []int) { return fileDescriptorRoute, []int{5} }

func (m *Route) GetPrefix() string {
	if m != nil {
		return m.Prefix
	}
	return ""
}

func (m *Route) GetNexhHop() string {
	if m != nil {
		return m.NexhHop
	}
	return ""
}

func (m *Route) GetTargetVirtualRouter() string {
	if m != nil {
		return m.TargetVirtualRouter
	}
	return ""
}

//
type RouteDistinguisher struct {
	// RD Type as in rfc4364.
	Type string `protobuf:"bytes,1,opt,name=Type,json=type,omitempty,proto3" json:"type,omitempty"`
	// Administrator subfield of Value. Length depends on Type.
	AdminValue api.RDAdminValue `protobuf:"bytes,2,opt,name=AdminValue,json=admin-value,omitempty" json:"admin-value,omitempty"`
	// Assigned subfield of Value. Length depends on Type.
	AssignedValue uint32 `protobuf:"varint,3,opt,name=AssignedValue,json=assigned-value,omitempty,proto3" json:"assigned-value,omitempty"`
}

func (m *RouteDistinguisher) Reset()                    { *m = RouteDistinguisher{} }
func (m *RouteDistinguisher) String() string            { return proto.CompactTextString(m) }
func (*RouteDistinguisher) ProtoMessage()               {}
func (*RouteDistinguisher) Descriptor() ([]byte, []int) { return fileDescriptorRoute, []int{6} }

func (m *RouteDistinguisher) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *RouteDistinguisher) GetAdminValue() api.RDAdminValue {
	if m != nil {
		return m.AdminValue
	}
	return api.RDAdminValue{}
}

func (m *RouteDistinguisher) GetAssignedValue() uint32 {
	if m != nil {
		return m.AssignedValue
	}
	return 0
}

//
type RouteTable struct {
	//
	api.TypeMeta `protobuf:"bytes,1,opt,name=T,json=,inline,embedded=T" json:",inline"`
	//
	api.ObjectMeta `protobuf:"bytes,2,opt,name=O,json=meta,omitempty,embedded=O" json:"meta,omitempty"`
	// Spec contains the configuration of the Route Table.
	Spec RouteTableSpec `protobuf:"bytes,3,opt,name=Spec,json=spec,omitempty" json:"spec,omitempty"`
	// Status contains the current state of the Route Table.
	Status RouteTableStatus `protobuf:"bytes,4,opt,name=Status,json=status,omitempty" json:"status,omitempty"`
}

func (m *RouteTable) Reset()                    { *m = RouteTable{} }
func (m *RouteTable) String() string            { return proto.CompactTextString(m) }
func (*RouteTable) ProtoMessage()               {}
func (*RouteTable) Descriptor() ([]byte, []int) { return fileDescriptorRoute, []int{7} }

func (m *RouteTable) GetSpec() RouteTableSpec {
	if m != nil {
		return m.Spec
	}
	return RouteTableSpec{}
}

func (m *RouteTable) GetStatus() RouteTableStatus {
	if m != nil {
		return m.Status
	}
	return RouteTableStatus{}
}

//
type RouteTableSpec struct {
}

func (m *RouteTableSpec) Reset()                    { *m = RouteTableSpec{} }
func (m *RouteTableSpec) String() string            { return proto.CompactTextString(m) }
func (*RouteTableSpec) ProtoMessage()               {}
func (*RouteTableSpec) Descriptor() ([]byte, []int) { return fileDescriptorRoute, []int{8} }

//
type RouteTableStatus struct {
	//
	Routes []*Route `protobuf:"bytes,1,rep,name=Routes,json=routes,omitempty" json:"routes,omitempty"`
}

func (m *RouteTableStatus) Reset()                    { *m = RouteTableStatus{} }
func (m *RouteTableStatus) String() string            { return proto.CompactTextString(m) }
func (*RouteTableStatus) ProtoMessage()               {}
func (*RouteTableStatus) Descriptor() ([]byte, []int) { return fileDescriptorRoute, []int{9} }

func (m *RouteTableStatus) GetRoutes() []*Route {
	if m != nil {
		return m.Routes
	}
	return nil
}

//
type RoutingConfig struct {
	//
	api.TypeMeta `protobuf:"bytes,1,opt,name=T,json=,inline,embedded=T" json:",inline"`
	//
	api.ObjectMeta `protobuf:"bytes,2,opt,name=O,json=meta,omitempty,embedded=O" json:"meta,omitempty"`
	// Spec contains the configuration of the RoutingConfig.
	Spec RoutingConfigSpec `protobuf:"bytes,3,opt,name=Spec,json=spec,omitempty" json:"spec,omitempty"`
	// Status contains the current state of the RoutingConfig.
	Status RoutingConfigStatus `protobuf:"bytes,4,opt,name=Status,json=status,omitempty" json:"status,omitempty"`
}

func (m *RoutingConfig) Reset()                    { *m = RoutingConfig{} }
func (m *RoutingConfig) String() string            { return proto.CompactTextString(m) }
func (*RoutingConfig) ProtoMessage()               {}
func (*RoutingConfig) Descriptor() ([]byte, []int) { return fileDescriptorRoute, []int{10} }

func (m *RoutingConfig) GetSpec() RoutingConfigSpec {
	if m != nil {
		return m.Spec
	}
	return RoutingConfigSpec{}
}

func (m *RoutingConfig) GetStatus() RoutingConfigStatus {
	if m != nil {
		return m.Status
	}
	return RoutingConfigStatus{}
}

//
type RoutingConfigSpec struct {
	// Configuration for the BGP instance.
	BGPConfig *BGPConfig `protobuf:"bytes,1,opt,name=BGPConfig,json=bgp-config,omitempty" json:"bgp-config,omitempty"`
}

func (m *RoutingConfigSpec) Reset()                    { *m = RoutingConfigSpec{} }
func (m *RoutingConfigSpec) String() string            { return proto.CompactTextString(m) }
func (*RoutingConfigSpec) ProtoMessage()               {}
func (*RoutingConfigSpec) Descriptor() ([]byte, []int) { return fileDescriptorRoute, []int{11} }

func (m *RoutingConfigSpec) GetBGPConfig() *BGPConfig {
	if m != nil {
		return m.BGPConfig
	}
	return nil
}

//
type RoutingConfigStatus struct {
	// Authentication config status
	AuthConfigStatus []*BGPAuthStatus `protobuf:"bytes,1,rep,name=AuthConfigStatus,json=auth-config-status,omitempty" json:"auth-config-status,omitempty"`
}

func (m *RoutingConfigStatus) Reset()                    { *m = RoutingConfigStatus{} }
func (m *RoutingConfigStatus) String() string            { return proto.CompactTextString(m) }
func (*RoutingConfigStatus) ProtoMessage()               {}
func (*RoutingConfigStatus) Descriptor() ([]byte, []int) { return fileDescriptorRoute, []int{12} }

func (m *RoutingConfigStatus) GetAuthConfigStatus() []*BGPAuthStatus {
	if m != nil {
		return m.AuthConfigStatus
	}
	return nil
}

func init() {
	proto.RegisterType((*BGPAuthStatus)(nil), "network.BGPAuthStatus")
	proto.RegisterType((*BGPConfig)(nil), "network.BGPConfig")
	proto.RegisterType((*BGPNeighbor)(nil), "network.BGPNeighbor")
	proto.RegisterType((*EVPNConfig)(nil), "network.EVPNConfig")
	proto.RegisterType((*RDSpec)(nil), "network.RDSpec")
	proto.RegisterType((*Route)(nil), "network.Route")
	proto.RegisterType((*RouteDistinguisher)(nil), "network.RouteDistinguisher")
	proto.RegisterType((*RouteTable)(nil), "network.RouteTable")
	proto.RegisterType((*RouteTableSpec)(nil), "network.RouteTableSpec")
	proto.RegisterType((*RouteTableStatus)(nil), "network.RouteTableStatus")
	proto.RegisterType((*RoutingConfig)(nil), "network.RoutingConfig")
	proto.RegisterType((*RoutingConfigSpec)(nil), "network.RoutingConfigSpec")
	proto.RegisterType((*RoutingConfigStatus)(nil), "network.RoutingConfigStatus")
	proto.RegisterEnum("network.BGPAddressFamily", BGPAddressFamily_name, BGPAddressFamily_value)
	proto.RegisterEnum("network.BGPAuthStatus_AuthStatus", BGPAuthStatus_AuthStatus_name, BGPAuthStatus_AuthStatus_value)
	proto.RegisterEnum("network.RouteDistinguisher_RDType", RouteDistinguisher_RDType_name, RouteDistinguisher_RDType_value)
}
func (m *BGPAuthStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPAuthStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.IPAddress) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRoute(dAtA, i, uint64(len(m.IPAddress)))
		i += copy(dAtA[i:], m.IPAddress)
	}
	if m.RemoteAS != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRoute(dAtA, i, uint64(m.RemoteAS))
	}
	if len(m.Status) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintRoute(dAtA, i, uint64(len(m.Status)))
		i += copy(dAtA[i:], m.Status)
	}
	return i, nil
}

func (m *BGPConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RouterId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRoute(dAtA, i, uint64(len(m.RouterId)))
		i += copy(dAtA[i:], m.RouterId)
	}
	dAtA[i] = 0x12
	i++
	i = encodeVarintRoute(dAtA, i, uint64(m.ASNumber.Size()))
	n1, err := m.ASNumber.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n1
	if m.KeepaliveInterval != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintRoute(dAtA, i, uint64(m.KeepaliveInterval))
	}
	if m.Holdtime != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintRoute(dAtA, i, uint64(m.Holdtime))
	}
	if m.DSCAutoConfig {
		dAtA[i] = 0x28
		i++
		if m.DSCAutoConfig {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Neighbors) > 0 {
		for _, msg := range m.Neighbors {
			dAtA[i] = 0x32
			i++
			i = encodeVarintRoute(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *BGPNeighbor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPNeighbor) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Shutdown {
		dAtA[i] = 0x8
		i++
		if m.Shutdown {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.IPAddress) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRoute(dAtA, i, uint64(len(m.IPAddress)))
		i += copy(dAtA[i:], m.IPAddress)
	}
	dAtA[i] = 0x1a
	i++
	i = encodeVarintRoute(dAtA, i, uint64(m.RemoteAS.Size()))
	n2, err := m.RemoteAS.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n2
	if m.MultiHop != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintRoute(dAtA, i, uint64(m.MultiHop))
	}
	if len(m.EnableAddressFamilies) > 0 {
		for _, s := range m.EnableAddressFamilies {
			dAtA[i] = 0x2a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Password) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintRoute(dAtA, i, uint64(len(m.Password)))
		i += copy(dAtA[i:], m.Password)
	}
	if m.DSCAutoConfig {
		dAtA[i] = 0x38
		i++
		if m.DSCAutoConfig {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.KeepaliveInterval != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintRoute(dAtA, i, uint64(m.KeepaliveInterval))
	}
	if m.Holdtime != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintRoute(dAtA, i, uint64(m.Holdtime))
	}
	return i, nil
}

func (m *EVPNConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EVPNConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Shutdown {
		dAtA[i] = 0x8
		i++
		if m.Shutdown {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *RDSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RDSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AddressFamily) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRoute(dAtA, i, uint64(len(m.AddressFamily)))
		i += copy(dAtA[i:], m.AddressFamily)
	}
	if m.RDAuto {
		dAtA[i] = 0x10
		i++
		if m.RDAuto {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.RD != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintRoute(dAtA, i, uint64(m.RD.Size()))
		n3, err := m.RD.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if len(m.ExportRTs) > 0 {
		for _, msg := range m.ExportRTs {
			dAtA[i] = 0x22
			i++
			i = encodeVarintRoute(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.ImportRTs) > 0 {
		for _, msg := range m.ImportRTs {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintRoute(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Route) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Route) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Prefix) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRoute(dAtA, i, uint64(len(m.Prefix)))
		i += copy(dAtA[i:], m.Prefix)
	}
	if len(m.NexhHop) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRoute(dAtA, i, uint64(len(m.NexhHop)))
		i += copy(dAtA[i:], m.NexhHop)
	}
	if len(m.TargetVirtualRouter) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintRoute(dAtA, i, uint64(len(m.TargetVirtualRouter)))
		i += copy(dAtA[i:], m.TargetVirtualRouter)
	}
	return i, nil
}

func (m *RouteDistinguisher) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouteDistinguisher) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRoute(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	dAtA[i] = 0x12
	i++
	i = encodeVarintRoute(dAtA, i, uint64(m.AdminValue.Size()))
	n4, err := m.AdminValue.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n4
	if m.AssignedValue != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintRoute(dAtA, i, uint64(m.AssignedValue))
	}
	return i, nil
}

func (m *RouteTable) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouteTable) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintRoute(dAtA, i, uint64(m.TypeMeta.Size()))
	n5, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n5
	dAtA[i] = 0x12
	i++
	i = encodeVarintRoute(dAtA, i, uint64(m.ObjectMeta.Size()))
	n6, err := m.ObjectMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n6
	dAtA[i] = 0x1a
	i++
	i = encodeVarintRoute(dAtA, i, uint64(m.Spec.Size()))
	n7, err := m.Spec.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n7
	dAtA[i] = 0x22
	i++
	i = encodeVarintRoute(dAtA, i, uint64(m.Status.Size()))
	n8, err := m.Status.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n8
	return i, nil
}

func (m *RouteTableSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouteTableSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *RouteTableStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouteTableStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Routes) > 0 {
		for _, msg := range m.Routes {
			dAtA[i] = 0xa
			i++
			i = encodeVarintRoute(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *RoutingConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoutingConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintRoute(dAtA, i, uint64(m.TypeMeta.Size()))
	n9, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n9
	dAtA[i] = 0x12
	i++
	i = encodeVarintRoute(dAtA, i, uint64(m.ObjectMeta.Size()))
	n10, err := m.ObjectMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n10
	dAtA[i] = 0x1a
	i++
	i = encodeVarintRoute(dAtA, i, uint64(m.Spec.Size()))
	n11, err := m.Spec.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n11
	dAtA[i] = 0x22
	i++
	i = encodeVarintRoute(dAtA, i, uint64(m.Status.Size()))
	n12, err := m.Status.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n12
	return i, nil
}

func (m *RoutingConfigSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoutingConfigSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.BGPConfig != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRoute(dAtA, i, uint64(m.BGPConfig.Size()))
		n13, err := m.BGPConfig.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	return i, nil
}

func (m *RoutingConfigStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoutingConfigStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AuthConfigStatus) > 0 {
		for _, msg := range m.AuthConfigStatus {
			dAtA[i] = 0xa
			i++
			i = encodeVarintRoute(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func encodeVarintRoute(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *BGPAuthStatus) Size() (n int) {
	var l int
	_ = l
	l = len(m.IPAddress)
	if l > 0 {
		n += 1 + l + sovRoute(uint64(l))
	}
	if m.RemoteAS != 0 {
		n += 1 + sovRoute(uint64(m.RemoteAS))
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovRoute(uint64(l))
	}
	return n
}

func (m *BGPConfig) Size() (n int) {
	var l int
	_ = l
	l = len(m.RouterId)
	if l > 0 {
		n += 1 + l + sovRoute(uint64(l))
	}
	l = m.ASNumber.Size()
	n += 1 + l + sovRoute(uint64(l))
	if m.KeepaliveInterval != 0 {
		n += 1 + sovRoute(uint64(m.KeepaliveInterval))
	}
	if m.Holdtime != 0 {
		n += 1 + sovRoute(uint64(m.Holdtime))
	}
	if m.DSCAutoConfig {
		n += 2
	}
	if len(m.Neighbors) > 0 {
		for _, e := range m.Neighbors {
			l = e.Size()
			n += 1 + l + sovRoute(uint64(l))
		}
	}
	return n
}

func (m *BGPNeighbor) Size() (n int) {
	var l int
	_ = l
	if m.Shutdown {
		n += 2
	}
	l = len(m.IPAddress)
	if l > 0 {
		n += 1 + l + sovRoute(uint64(l))
	}
	l = m.RemoteAS.Size()
	n += 1 + l + sovRoute(uint64(l))
	if m.MultiHop != 0 {
		n += 1 + sovRoute(uint64(m.MultiHop))
	}
	if len(m.EnableAddressFamilies) > 0 {
		for _, s := range m.EnableAddressFamilies {
			l = len(s)
			n += 1 + l + sovRoute(uint64(l))
		}
	}
	l = len(m.Password)
	if l > 0 {
		n += 1 + l + sovRoute(uint64(l))
	}
	if m.DSCAutoConfig {
		n += 2
	}
	if m.KeepaliveInterval != 0 {
		n += 1 + sovRoute(uint64(m.KeepaliveInterval))
	}
	if m.Holdtime != 0 {
		n += 1 + sovRoute(uint64(m.Holdtime))
	}
	return n
}

func (m *EVPNConfig) Size() (n int) {
	var l int
	_ = l
	if m.Shutdown {
		n += 2
	}
	return n
}

func (m *RDSpec) Size() (n int) {
	var l int
	_ = l
	l = len(m.AddressFamily)
	if l > 0 {
		n += 1 + l + sovRoute(uint64(l))
	}
	if m.RDAuto {
		n += 2
	}
	if m.RD != nil {
		l = m.RD.Size()
		n += 1 + l + sovRoute(uint64(l))
	}
	if len(m.ExportRTs) > 0 {
		for _, e := range m.ExportRTs {
			l = e.Size()
			n += 1 + l + sovRoute(uint64(l))
		}
	}
	if len(m.ImportRTs) > 0 {
		for _, e := range m.ImportRTs {
			l = e.Size()
			n += 1 + l + sovRoute(uint64(l))
		}
	}
	return n
}

func (m *Route) Size() (n int) {
	var l int
	_ = l
	l = len(m.Prefix)
	if l > 0 {
		n += 1 + l + sovRoute(uint64(l))
	}
	l = len(m.NexhHop)
	if l > 0 {
		n += 1 + l + sovRoute(uint64(l))
	}
	l = len(m.TargetVirtualRouter)
	if l > 0 {
		n += 1 + l + sovRoute(uint64(l))
	}
	return n
}

func (m *RouteDistinguisher) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovRoute(uint64(l))
	}
	l = m.AdminValue.Size()
	n += 1 + l + sovRoute(uint64(l))
	if m.AssignedValue != 0 {
		n += 1 + sovRoute(uint64(m.AssignedValue))
	}
	return n
}

func (m *RouteTable) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovRoute(uint64(l))
	l = m.ObjectMeta.Size()
	n += 1 + l + sovRoute(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovRoute(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovRoute(uint64(l))
	return n
}

func (m *RouteTableSpec) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *RouteTableStatus) Size() (n int) {
	var l int
	_ = l
	if len(m.Routes) > 0 {
		for _, e := range m.Routes {
			l = e.Size()
			n += 1 + l + sovRoute(uint64(l))
		}
	}
	return n
}

func (m *RoutingConfig) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovRoute(uint64(l))
	l = m.ObjectMeta.Size()
	n += 1 + l + sovRoute(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovRoute(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovRoute(uint64(l))
	return n
}

func (m *RoutingConfigSpec) Size() (n int) {
	var l int
	_ = l
	if m.BGPConfig != nil {
		l = m.BGPConfig.Size()
		n += 1 + l + sovRoute(uint64(l))
	}
	return n
}

func (m *RoutingConfigStatus) Size() (n int) {
	var l int
	_ = l
	if len(m.AuthConfigStatus) > 0 {
		for _, e := range m.AuthConfigStatus {
			l = e.Size()
			n += 1 + l + sovRoute(uint64(l))
		}
	}
	return n
}

func sovRoute(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozRoute(x uint64) (n int) {
	return sovRoute(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *BGPAuthStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPAuthStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPAuthStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IPAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IPAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoteAS", wireType)
			}
			m.RemoteAS = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RemoteAS |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouterId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RouterId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ASNumber", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ASNumber.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeepaliveInterval", wireType)
			}
			m.KeepaliveInterval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeepaliveInterval |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Holdtime", wireType)
			}
			m.Holdtime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Holdtime |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DSCAutoConfig", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DSCAutoConfig = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Neighbors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Neighbors = append(m.Neighbors, &BGPNeighbor{})
			if err := m.Neighbors[len(m.Neighbors)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPNeighbor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPNeighbor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPNeighbor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shutdown", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Shutdown = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IPAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IPAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoteAS", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RemoteAS.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MultiHop", wireType)
			}
			m.MultiHop = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MultiHop |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableAddressFamilies", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EnableAddressFamilies = append(m.EnableAddressFamilies, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Password", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Password = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DSCAutoConfig", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DSCAutoConfig = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeepaliveInterval", wireType)
			}
			m.KeepaliveInterval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeepaliveInterval |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Holdtime", wireType)
			}
			m.Holdtime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Holdtime |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRoute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EVPNConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EVPNConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EVPNConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shutdown", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Shutdown = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipRoute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RDSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RDSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RDSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddressFamily", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AddressFamily = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RDAuto", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RDAuto = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RD", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RD == nil {
				m.RD = &RouteDistinguisher{}
			}
			if err := m.RD.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExportRTs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExportRTs = append(m.ExportRTs, &RouteDistinguisher{})
			if err := m.ExportRTs[len(m.ExportRTs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImportRTs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ImportRTs = append(m.ImportRTs, &RouteDistinguisher{})
			if err := m.ImportRTs[len(m.ImportRTs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Route) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Route: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Route: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Prefix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NexhHop", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NexhHop = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetVirtualRouter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TargetVirtualRouter = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RouteDistinguisher) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RouteDistinguisher: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RouteDistinguisher: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdminValue", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AdminValue.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssignedValue", wireType)
			}
			m.AssignedValue = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AssignedValue |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRoute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RouteTable) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RouteTable: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RouteTable: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RouteTableSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RouteTableSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RouteTableSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipRoute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RouteTableStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RouteTableStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RouteTableStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Routes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Routes = append(m.Routes, &Route{})
			if err := m.Routes[len(m.Routes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoutingConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoutingConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoutingConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoutingConfigSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoutingConfigSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoutingConfigSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BGPConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BGPConfig == nil {
				m.BGPConfig = &BGPConfig{}
			}
			if err := m.BGPConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoutingConfigStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoutingConfigStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoutingConfigStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthConfigStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuthConfigStatus = append(m.AuthConfigStatus, &BGPAuthStatus{})
			if err := m.AuthConfigStatus[len(m.AuthConfigStatus)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipRoute(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthRoute
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowRoute
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipRoute(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthRoute = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowRoute   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("route.proto", fileDescriptorRoute) }

var fileDescriptorRoute = []byte{
	// 1570 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x57, 0xcf, 0x4f, 0x1b, 0xcf,
	0x15, 0x67, 0x0d, 0x18, 0x7b, 0x8c, 0xe9, 0x32, 0x40, 0xe2, 0x25, 0x04, 0x3b, 0x96, 0xaa, 0x9a,
	0x88, 0xb5, 0x81, 0x90, 0x88, 0x44, 0x6d, 0x55, 0x6f, 0xec, 0x10, 0xda, 0x00, 0x96, 0x4d, 0x48,
	0xd4, 0xf4, 0xb2, 0xb6, 0x07, 0x7b, 0x92, 0xf5, 0xec, 0x6a, 0x77, 0xd6, 0x80, 0xaa, 0xde, 0x1a,
	0x37, 0x7f, 0x42, 0xcf, 0xbd, 0x54, 0xe2, 0xd8, 0xde, 0x7a, 0xed, 0x25, 0x87, 0x1e, 0xd2, 0xf4,
	0x6e, 0x55, 0x9c, 0xbe, 0xf2, 0x5f, 0xf1, 0xd5, 0xcc, 0xae, 0xc9, 0xac, 0x7f, 0x10, 0xa2, 0x1c,
	0xbe, 0xa7, 0xdd, 0xf9, 0xcc, 0x7b, 0x9f, 0x37, 0xf3, 0x7e, 0xcc, 0xbc, 0x01, 0x31, 0xdb, 0x74,
	0x29, 0xca, 0x5a, 0xb6, 0x49, 0x4d, 0x38, 0x43, 0x10, 0x3d, 0x35, 0xed, 0x77, 0xcb, 0x2b, 0x0d,
	0xd3, 0x6c, 0x18, 0x28, 0xa7, 0x5b, 0x38, 0xa7, 0x13, 0x62, 0x52, 0x9d, 0x62, 0x93, 0x38, 0x9e,
	0xd8, 0x72, 0xb1, 0x81, 0x69, 0xd3, 0xad, 0x66, 0x6b, 0x66, 0x2b, 0x67, 0x21, 0xe2, 0xe8, 0xa4,
	0x6e, 0xe6, 0x9c, 0xd3, 0x5c, 0x1b, 0x11, 0x5c, 0x43, 0x39, 0x97, 0x62, 0xc3, 0x61, 0xaa, 0x0d,
	0x44, 0x44, 0xed, 0x1c, 0x26, 0x35, 0xc3, 0xad, 0xa3, 0x3e, 0x8d, 0x2a, 0xd0, 0x34, 0xcc, 0x86,
	0x99, 0xe3, 0x70, 0xd5, 0x3d, 0xe1, 0x23, 0x3e, 0xe0, 0x7f, 0xbe, 0xf8, 0xcf, 0xc7, 0x58, 0x65,
	0x6b, 0x6c, 0x21, 0xaa, 0xfb, 0x62, 0x1b, 0xd7, 0x88, 0x19, 0x7a, 0x15, 0x19, 0x4e, 0xce, 0x41,
	0x06, 0xaa, 0x51, 0xd3, 0xf6, 0x35, 0x66, 0x29, 0x22, 0x3a, 0xa1, 0xde, 0x28, 0xfd, 0xd7, 0x10,
	0x88, 0x6b, 0xbb, 0xa5, 0xbc, 0x4b, 0x9b, 0x15, 0xaa, 0x53, 0xd7, 0x81, 0x79, 0x10, 0xdd, 0x2b,
	0xe5, 0xeb, 0x75, 0x1b, 0x39, 0x4e, 0x42, 0x4a, 0x49, 0x99, 0xa8, 0x96, 0xe8, 0x75, 0x93, 0x8b,
	0xd8, 0x52, 0x75, 0x0f, 0x5d, 0x37, 0x5b, 0x98, 0xa2, 0x96, 0x45, 0xcf, 0xcb, 0x23, 0x51, 0xf8,
	0x6b, 0x10, 0x29, 0xa3, 0x96, 0x49, 0x51, 0xbe, 0x92, 0x08, 0xa5, 0xa4, 0x4c, 0x5c, 0xbb, 0xdd,
	0xeb, 0x26, 0x17, 0x6c, 0x8e, 0xa9, 0xba, 0x48, 0x30, 0x0a, 0x84, 0x6f, 0x40, 0xd8, 0x5b, 0x4c,
	0x62, 0x92, 0xdb, 0x7f, 0x7c, 0xd1, 0x51, 0xee, 0x55, 0xa8, 0x5d, 0x24, 0x6e, 0x2b, 0x13, 0x58,
	0x6d, 0xf6, 0xcb, 0xef, 0x5a, 0xaf, 0x9b, 0x94, 0x1d, 0xfe, 0x2b, 0xf0, 0x0f, 0x21, 0xe9, 0x5f,
	0x00, 0x20, 0xec, 0x76, 0x16, 0x44, 0x0a, 0xd8, 0xd1, 0xab, 0x06, 0xaa, 0xcb, 0x13, 0x30, 0x06,
	0x66, 0x8a, 0xc4, 0x1b, 0x48, 0xe9, 0xbf, 0x4f, 0x81, 0xa8, 0xb6, 0x5b, 0x7a, 0x6a, 0x92, 0x13,
	0xdc, 0x80, 0x15, 0x10, 0x29, 0xb3, 0xdc, 0xb1, 0xf7, 0xea, 0xbe, 0x57, 0xd6, 0x2f, 0x3a, 0xca,
	0x7c, 0x91, 0x71, 0x1e, 0xda, 0x19, 0xcf, 0x65, 0x99, 0xb5, 0x35, 0xbe, 0x51, 0x2e, 0xa8, 0xe2,
	0x7a, 0x60, 0xa3, 0xc3, 0x20, 0x3c, 0x04, 0x91, 0x7c, 0xe5, 0xc0, 0x6d, 0x55, 0x91, 0xcd, 0x1d,
	0x15, 0xdb, 0x8a, 0x65, 0x75, 0x0b, 0x67, 0xb5, 0x86, 0x95, 0x77, 0x88, 0x76, 0xe7, 0x63, 0x37,
	0x39, 0xc1, 0x08, 0x75, 0x47, 0x25, 0x5c, 0x4a, 0x24, 0x1c, 0x01, 0x42, 0x07, 0xcc, 0xff, 0x0e,
	0x21, 0x4b, 0x37, 0x70, 0x1b, 0xed, 0x11, 0x8a, 0xec, 0xb6, 0x6e, 0x70, 0x27, 0xc6, 0xb5, 0x27,
	0x17, 0x1d, 0x45, 0xde, 0x23, 0xb4, 0xac, 0x93, 0x06, 0xca, 0x6c, 0xac, 0x3f, 0x78, 0xb4, 0xb1,
	0xb1, 0xf6, 0x8f, 0x8e, 0x12, 0x7a, 0xb4, 0xd1, 0xeb, 0x26, 0x57, 0xde, 0xf5, 0xd5, 0x54, 0xec,
	0xeb, 0x09, 0xb6, 0xae, 0x9d, 0x85, 0xaf, 0x40, 0xe4, 0xb9, 0x69, 0xd4, 0x29, 0x6e, 0xa1, 0xc4,
	0x14, 0xb7, 0xb5, 0x39, 0xc6, 0xd6, 0xe4, 0xe6, 0x0e, 0x33, 0x06, 0x9b, 0xbe, 0xb8, 0x60, 0x62,
	0x04, 0x06, 0x0f, 0x41, 0xbc, 0x50, 0x79, 0x9a, 0x77, 0xa9, 0xe9, 0x05, 0x21, 0x31, 0x9d, 0x92,
	0x32, 0x11, 0xed, 0x6e, 0xaf, 0x9b, 0x54, 0xea, 0x4e, 0x4d, 0xd5, 0x5d, 0x6a, 0xaa, 0x35, 0x3e,
	0x25, 0x30, 0x8d, 0x9f, 0x82, 0x2f, 0x41, 0xf4, 0x00, 0xe1, 0x46, 0xb3, 0x6a, 0xda, 0x4e, 0x22,
	0x9c, 0x9a, 0xcc, 0xc4, 0xb6, 0x16, 0xb3, 0xfe, 0x29, 0x90, 0xd5, 0x76, 0x4b, 0xfd, 0x49, 0x2f,
	0x5f, 0x49, 0x5f, 0x54, 0xf4, 0xfa, 0x08, 0x30, 0xfd, 0x9f, 0x30, 0x88, 0x09, 0xda, 0xf0, 0x97,
	0x20, 0x52, 0x69, 0xba, 0xb4, 0x6e, 0x9e, 0x12, 0x9e, 0x2b, 0x11, 0xed, 0x16, 0xdb, 0xb5, 0xe3,
	0x63, 0xe2, 0xae, 0x87, 0x31, 0x78, 0x2c, 0x16, 0x60, 0x88, 0xa7, 0x9a, 0x3a, 0x2e, 0xd5, 0xbe,
	0xa5, 0x2a, 0x0f, 0x85, 0xaa, 0x9c, 0xbc, 0x26, 0xd9, 0x6e, 0x5c, 0xa6, 0xaf, 0x41, 0x64, 0xdf,
	0x35, 0x28, 0x7e, 0x6e, 0x5a, 0x23, 0xe3, 0xbe, 0xb9, 0x9e, 0xda, 0x7a, 0xf8, 0xd0, 0xcb, 0xb1,
	0x6d, 0xc6, 0xdc, 0x62, 0xd2, 0x6a, 0xd3, 0xb4, 0x44, 0xe6, 0x11, 0x20, 0xfc, 0xb3, 0x04, 0x96,
	0xbc, 0x42, 0xf4, 0xfd, 0xf0, 0x4c, 0x6f, 0x61, 0x03, 0x23, 0x27, 0x31, 0x9d, 0x9a, 0xcc, 0x44,
	0x35, 0xed, 0xa2, 0xa3, 0x28, 0xe2, 0x81, 0x20, 0x48, 0x9d, 0x33, 0xbf, 0xdc, 0x43, 0x5c, 0xbb,
	0xef, 0x05, 0xf5, 0xc4, 0xd7, 0x17, 0x0c, 0x7f, 0x5d, 0x04, 0xd6, 0x40, 0xa4, 0xa4, 0x3b, 0xce,
	0xa9, 0x69, 0xd7, 0x13, 0x61, 0x1e, 0x88, 0x5f, 0x5d, 0x74, 0x94, 0xdb, 0xfd, 0x40, 0x54, 0xa8,
	0xfd, 0x02, 0x11, 0xb6, 0xcd, 0xcd, 0xad, 0x9d, 0xb5, 0xb5, 0x7f, 0x75, 0x94, 0x48, 0x05, 0xd5,
	0x6c, 0x44, 0x33, 0x6c, 0x09, 0xd0, 0xf2, 0x55, 0xc5, 0x70, 0x0f, 0x63, 0xc3, 0x49, 0x3e, 0xf3,
	0x9d, 0x49, 0xde, 0x1a, 0x75, 0x06, 0x44, 0x78, 0x7c, 0xb6, 0x47, 0xd5, 0xe5, 0x77, 0x56, 0x7f,
	0x49, 0xa8, 0xfe, 0x28, 0xb7, 0x72, 0x7f, 0x8c, 0x95, 0x1b, 0x96, 0x7d, 0xfa, 0xb7, 0x00, 0x14,
	0x8f, 0x4b, 0x07, 0xfe, 0xc1, 0xfb, 0x5d, 0xc5, 0x94, 0xfe, 0xe7, 0x24, 0x08, 0x97, 0x0b, 0x15,
	0x0b, 0xd5, 0xe0, 0x5b, 0x10, 0x0f, 0xe4, 0x89, 0x7f, 0x8c, 0x3f, 0xfe, 0x5a, 0x2e, 0x25, 0x02,
	0x19, 0x72, 0x2e, 0x18, 0x1c, 0x3b, 0x03, 0x77, 0x98, 0x55, 0x16, 0x53, 0x5e, 0xc0, 0x11, 0x6d,
	0xa9, 0xd7, 0x4d, 0xce, 0xdb, 0x75, 0x1e, 0x31, 0x81, 0x60, 0x18, 0x82, 0xbb, 0x20, 0x54, 0x2e,
	0xf8, 0xf5, 0x79, 0xe7, 0xea, 0x6c, 0xe2, 0x57, 0x4f, 0x01, 0x3b, 0x14, 0x93, 0x86, 0x8b, 0x9d,
	0x26, 0xb2, 0x35, 0xb9, 0xd7, 0x4d, 0xce, 0x06, 0xb2, 0x2b, 0x30, 0x82, 0x7f, 0x00, 0xd1, 0xe2,
	0x99, 0x65, 0xda, 0xb4, 0x7c, 0xe4, 0x24, 0xa6, 0xf8, 0x59, 0x77, 0x2d, 0x9f, 0x77, 0x45, 0x53,
	0x15, 0x71, 0xa5, 0x40, 0xed, 0x0f, 0x83, 0x8c, 0x7d, 0xaf, 0xd5, 0x67, 0x9f, 0xbe, 0x39, 0x3b,
	0x6e, 0x8d, 0x60, 0x1f, 0x04, 0x59, 0x57, 0x32, 0xcd, 0x49, 0xe0, 0x6f, 0x40, 0xb8, 0x64, 0xa3,
	0x13, 0x7c, 0xe6, 0x47, 0x6b, 0xf5, 0xa2, 0xa3, 0x84, 0x9f, 0xee, 0x15, 0xca, 0xbc, 0xc6, 0x64,
	0x8b, 0xcf, 0x89, 0xf7, 0xfd, 0x20, 0x02, 0x8b, 0x60, 0xe6, 0x00, 0x9d, 0x35, 0xd9, 0x21, 0xe5,
	0x1d, 0xa6, 0xa9, 0x00, 0x05, 0x24, 0xe8, 0x8c, 0x0e, 0x9c, 0x49, 0x23, 0x30, 0xf8, 0x5e, 0x02,
	0x0b, 0x47, 0xba, 0xdd, 0x40, 0xf4, 0x18, 0xdb, 0xd4, 0xd5, 0x0d, 0xaf, 0x1b, 0xf0, 0x3b, 0x94,
	0xdd, 0xbf, 0x75, 0x94, 0x14, 0x98, 0x79, 0x85, 0xf4, 0x77, 0x65, 0x74, 0x02, 0x97, 0x7c, 0x4f,
	0xe4, 0x02, 0xb2, 0xbd, 0x6e, 0x32, 0x49, 0x39, 0x85, 0xda, 0xf6, 0x70, 0xd5, 0x6b, 0x0a, 0x04,
	0xd3, 0x5f, 0x13, 0x48, 0xff, 0x3b, 0x04, 0xe0, 0xb0, 0x7f, 0xe1, 0x31, 0x98, 0x3a, 0x3a, 0xb7,
	0x90, 0xef, 0xa5, 0x9d, 0x8b, 0x8e, 0x92, 0xee, 0xe7, 0xf4, 0xb0, 0x74, 0xb6, 0x5c, 0x60, 0xc2,
	0x6c, 0xfb, 0x73, 0xf4, 0xdc, 0x12, 0xeb, 0x71, 0x60, 0x0c, 0xdf, 0x00, 0x90, 0xaf, 0xb7, 0x30,
	0x39, 0xd6, 0x0d, 0x17, 0xf9, 0x3d, 0xca, 0x3c, 0xbf, 0x36, 0xca, 0x85, 0x2f, 0x13, 0xda, 0x5d,
	0xff, 0xf2, 0x58, 0xd2, 0x19, 0xa6, 0xb6, 0x19, 0x28, 0xb0, 0x8e, 0x86, 0xe1, 0x3e, 0x88, 0xe7,
	0x1d, 0x07, 0x37, 0x08, 0xaa, 0x7b, 0xfc, 0x5e, 0xa7, 0xb2, 0xc2, 0x8b, 0xce, 0x9f, 0x18, 0xe2,
	0x1a, 0x3b, 0x93, 0x5e, 0x63, 0x45, 0xc7, 0x36, 0x06, 0xa3, 0x60, 0x9a, 0x7d, 0x37, 0xe4, 0x89,
	0xfe, 0xef, 0xa6, 0x2c, 0xf5, 0x7f, 0xb7, 0xe4, 0x50, 0xfa, 0x7f, 0x21, 0x00, 0xb8, 0x5f, 0x8e,
	0xd8, 0x1d, 0x00, 0x1f, 0x01, 0xe9, 0x88, 0xbb, 0x2e, 0xb6, 0x15, 0xe7, 0x9b, 0x63, 0x72, 0xfb,
	0x88, 0xea, 0xda, 0x02, 0xdb, 0xd8, 0xa7, 0x6e, 0x52, 0xea, 0x75, 0x93, 0x33, 0xeb, 0x98, 0x18,
	0x98, 0xa0, 0x72, 0xff, 0x07, 0x3e, 0x03, 0xd2, 0xa1, 0xef, 0x94, 0x9f, 0x71, 0xbd, 0xc3, 0xea,
	0x5b, 0x54, 0xa3, 0x5c, 0x73, 0x59, 0xd0, 0x9c, 0x63, 0x1d, 0xbb, 0xe8, 0xe5, 0xe0, 0x18, 0xee,
	0x83, 0x29, 0x76, 0x44, 0xf9, 0x65, 0x7f, 0x3b, 0x58, 0x48, 0x7c, 0x89, 0x6c, 0x5a, 0xbb, 0xe5,
	0x7b, 0x79, 0xce, 0xb1, 0x50, 0x4d, 0xa4, 0x0b, 0x8e, 0xe1, 0xcb, 0xab, 0xfe, 0x79, 0x8a, 0x13,
	0x2a, 0xa3, 0x08, 0xb9, 0x80, 0x96, 0xf0, 0x29, 0x6f, 0xd0, 0x39, 0x3f, 0x49, 0x7e, 0x7e, 0xaf,
	0xdc, 0x01, 0xb1, 0xdc, 0x1f, 0x0f, 0xb3, 0x47, 0xfc, 0x0d, 0xf1, 0x27, 0x38, 0xcb, 0xf3, 0x53,
	0xa5, 0x8c, 0xd1, 0x49, 0xcb, 0x60, 0x2e, 0xb8, 0xe2, 0xf4, 0xef, 0x81, 0x3c, 0x68, 0x12, 0x3e,
	0x03, 0x61, 0x8e, 0xb1, 0xd7, 0x05, 0x3b, 0x37, 0xe6, 0x82, 0xab, 0xd3, 0x16, 0xd9, 0x72, 0x38,
	0x6f, 0x60, 0x39, 0x83, 0x48, 0xfa, 0xbf, 0x21, 0x10, 0x67, 0x1a, 0x98, 0x34, 0xfc, 0xab, 0xe2,
	0xa7, 0x0e, 0x63, 0x29, 0x10, 0xc6, 0xe5, 0xc0, 0xbe, 0xae, 0x56, 0xf9, 0x4d, 0x91, 0x7c, 0x3d,
	0x10, 0xc9, 0x95, 0x31, 0x9c, 0xdf, 0x1e, 0xcc, 0xc5, 0xcf, 0xef, 0x15, 0x19, 0xce, 0xd9, 0x1e,
	0x8d, 0xdf, 0x45, 0xa4, 0xdf, 0x82, 0xf9, 0xa1, 0xc5, 0xb2, 0xae, 0xf9, 0xea, 0x1d, 0xe4, 0xbb,
	0x17, 0x8a, 0x5d, 0xb3, 0x37, 0xe3, 0xbd, 0x12, 0xab, 0x0d, 0x6b, 0xb8, 0x59, 0x19, 0x89, 0xa6,
	0xff, 0x22, 0x81, 0x85, 0x11, 0xbb, 0x80, 0x16, 0x90, 0xd9, 0x03, 0x4d, 0xc4, 0xfc, 0x4c, 0xb9,
	0x25, 0x5a, 0xfd, 0xf2, 0x88, 0xd3, 0x52, 0xac, 0x85, 0xd1, 0x5d, 0xda, 0xf4, 0x8d, 0xa8, 0x43,
	0xfb, 0xbf, 0x76, 0xf6, 0xfe, 0x11, 0x90, 0x07, 0x2f, 0x7e, 0x78, 0x0f, 0xc4, 0xf6, 0x4a, 0xed,
	0xed, 0x97, 0x04, 0xd7, 0x74, 0x87, 0xca, 0x13, 0xcb, 0xf2, 0xe5, 0x07, 0x65, 0x16, 0x5b, 0xed,
	0x6d, 0xd5, 0xf5, 0x30, 0x78, 0x17, 0x44, 0x5f, 0x6c, 0xb5, 0x2d, 0x52, 0x6c, 0x5b, 0x44, 0x96,
	0x96, 0xe7, 0x2e, 0x3f, 0x28, 0xc0, 0x60, 0x80, 0x8a, 0xda, 0x16, 0xd1, 0xe4, 0x8f, 0x97, 0xab,
	0xd2, 0xa7, 0xcb, 0x55, 0xe9, 0xff, 0x97, 0xab, 0xd2, 0x0f, 0x97, 0xab, 0x13, 0x25, 0xa9, 0x1a,
	0xe6, 0xaf, 0xee, 0x07, 0x3f, 0x06, 0x00, 0x00, 0xff, 0xff, 0xd8, 0x6b, 0x63, 0x75, 0x88, 0x10,
	0x00, 0x00,
}
