// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: staging.proto

/*
	Package staging is a generated protocol buffer package.

	Service name

	It is generated from these files:
		staging.proto
		svc_staging.proto

	It has these top-level messages:
		Buffer
		BufferSpec
		BufferStatus
		ClearAction
		ClearActionSpec
		ClearActionStatus
		CommitAction
		CommitActionSpec
		CommitActionStatus
		Item
		ItemId
		ValidationError
		AutoMsgBufferWatchHelper
		BufferList
*/
package staging

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/pensando/sw/venice/utils/apigen/annotations"
import api "github.com/pensando/sw/api"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

//
type BufferStatus_ValidationStatus int32

const (
	// ui-hint: Success
	BufferStatus_SUCCESS BufferStatus_ValidationStatus = 0
	// ui-hint: Failed
	BufferStatus_FAILED BufferStatus_ValidationStatus = 1
)

var BufferStatus_ValidationStatus_name = map[int32]string{
	0: "SUCCESS",
	1: "FAILED",
}
var BufferStatus_ValidationStatus_value = map[string]int32{
	"SUCCESS": 0,
	"FAILED":  1,
}

func (BufferStatus_ValidationStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorStaging, []int{2, 0}
}

//
type ClearActionStatus_ClearStatus int32

const (
	//
	ClearActionStatus_SUCCESS ClearActionStatus_ClearStatus = 0
	//
	ClearActionStatus_FAILED ClearActionStatus_ClearStatus = 1
)

var ClearActionStatus_ClearStatus_name = map[int32]string{
	0: "SUCCESS",
	1: "FAILED",
}
var ClearActionStatus_ClearStatus_value = map[string]int32{
	"SUCCESS": 0,
	"FAILED":  1,
}

func (ClearActionStatus_ClearStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorStaging, []int{5, 0}
}

//
type CommitActionStatus_CommitStatus int32

const (
	//
	CommitActionStatus_SUCCESS CommitActionStatus_CommitStatus = 0
	//
	CommitActionStatus_FAILED CommitActionStatus_CommitStatus = 1
)

var CommitActionStatus_CommitStatus_name = map[int32]string{
	0: "SUCCESS",
	1: "FAILED",
}
var CommitActionStatus_CommitStatus_value = map[string]int32{
	"SUCCESS": 0,
	"FAILED":  1,
}

func (CommitActionStatus_CommitStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorStaging, []int{8, 0}
}

//
type Buffer struct {
	//
	api.TypeMeta `protobuf:"bytes,1,opt,name=T,json=,inline,embedded=T" json:",inline"`
	//
	api.ObjectMeta `protobuf:"bytes,2,opt,name=O,json=meta,inline,embedded=O" json:"meta,inline"`
	//
	Spec BufferSpec `protobuf:"bytes,3,opt,name=Spec,json=spec" json:"spec"`
	//
	Status BufferStatus `protobuf:"bytes,4,opt,name=Status,json=status" json:"status"`
}

func (m *Buffer) Reset()                    { *m = Buffer{} }
func (m *Buffer) String() string            { return proto.CompactTextString(m) }
func (*Buffer) ProtoMessage()               {}
func (*Buffer) Descriptor() ([]byte, []int) { return fileDescriptorStaging, []int{0} }

func (m *Buffer) GetSpec() BufferSpec {
	if m != nil {
		return m.Spec
	}
	return BufferSpec{}
}

func (m *Buffer) GetStatus() BufferStatus {
	if m != nil {
		return m.Status
	}
	return BufferStatus{}
}

//
type BufferSpec struct {
	//
	Contact string `protobuf:"bytes,1,opt,name=Contact,proto3" json:"Contact,omitempty"`
}

func (m *BufferSpec) Reset()                    { *m = BufferSpec{} }
func (m *BufferSpec) String() string            { return proto.CompactTextString(m) }
func (*BufferSpec) ProtoMessage()               {}
func (*BufferSpec) Descriptor() ([]byte, []int) { return fileDescriptorStaging, []int{1} }

func (m *BufferSpec) GetContact() string {
	if m != nil {
		return m.Contact
	}
	return ""
}

//
type BufferStatus struct {
	//
	ValidationResult string `protobuf:"bytes,1,opt,name=ValidationResult,json=validation-result,proto3" json:"validation-result"`
	//
	Errors []*ValidationError `protobuf:"bytes,2,rep,name=Errors,json=errors" json:"errors"`
	//
	Items []*Item `protobuf:"bytes,3,rep,name=Items,json=items" json:"items"`
}

func (m *BufferStatus) Reset()                    { *m = BufferStatus{} }
func (m *BufferStatus) String() string            { return proto.CompactTextString(m) }
func (*BufferStatus) ProtoMessage()               {}
func (*BufferStatus) Descriptor() ([]byte, []int) { return fileDescriptorStaging, []int{2} }

func (m *BufferStatus) GetValidationResult() string {
	if m != nil {
		return m.ValidationResult
	}
	return ""
}

func (m *BufferStatus) GetErrors() []*ValidationError {
	if m != nil {
		return m.Errors
	}
	return nil
}

func (m *BufferStatus) GetItems() []*Item {
	if m != nil {
		return m.Items
	}
	return nil
}

// ClearAction deletes objects from the staging buffer. A list of items to be cleared is specified
//  in the Spec. If there are no items are specified then all items are deleted from the staging.
//  buffer.
type ClearAction struct {
	//
	api.TypeMeta `protobuf:"bytes,1,opt,name=T,json=,inline,embedded=T" json:",inline"`
	//
	api.ObjectMeta `protobuf:"bytes,2,opt,name=O,json=meta,inline,embedded=O" json:"meta,inline"`
	//
	Spec ClearActionSpec `protobuf:"bytes,3,opt,name=Spec,json=spec" json:"spec"`
	//
	Status ClearActionStatus `protobuf:"bytes,4,opt,name=Status,json=status" json:"status"`
}

func (m *ClearAction) Reset()                    { *m = ClearAction{} }
func (m *ClearAction) String() string            { return proto.CompactTextString(m) }
func (*ClearAction) ProtoMessage()               {}
func (*ClearAction) Descriptor() ([]byte, []int) { return fileDescriptorStaging, []int{3} }

func (m *ClearAction) GetSpec() ClearActionSpec {
	if m != nil {
		return m.Spec
	}
	return ClearActionSpec{}
}

func (m *ClearAction) GetStatus() ClearActionStatus {
	if m != nil {
		return m.Status
	}
	return ClearActionStatus{}
}

//
type ClearActionSpec struct {
	// Empty Items indicates everyting in the buffer
	Items []*ItemId `protobuf:"bytes,1,rep,name=Items,json=items" json:"items"`
}

func (m *ClearActionSpec) Reset()                    { *m = ClearActionSpec{} }
func (m *ClearActionSpec) String() string            { return proto.CompactTextString(m) }
func (*ClearActionSpec) ProtoMessage()               {}
func (*ClearActionSpec) Descriptor() ([]byte, []int) { return fileDescriptorStaging, []int{4} }

func (m *ClearActionSpec) GetItems() []*ItemId {
	if m != nil {
		return m.Items
	}
	return nil
}

//
type ClearActionStatus struct {
	//
	Status string `protobuf:"bytes,1,opt,name=Status,json=status,proto3" json:"status"`
	//
	Reason string `protobuf:"bytes,2,opt,name=Reason,json=reason,proto3" json:"reason"`
}

func (m *ClearActionStatus) Reset()                    { *m = ClearActionStatus{} }
func (m *ClearActionStatus) String() string            { return proto.CompactTextString(m) }
func (*ClearActionStatus) ProtoMessage()               {}
func (*ClearActionStatus) Descriptor() ([]byte, []int) { return fileDescriptorStaging, []int{5} }

func (m *ClearActionStatus) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *ClearActionStatus) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

// CommitAction commits the changes in the staging buffer. All staged entries
//  are verified and if verification is successful they are commited.
type CommitAction struct {
	//
	api.TypeMeta `protobuf:"bytes,1,opt,name=T,json=,inline,embedded=T" json:",inline"`
	//
	api.ObjectMeta `protobuf:"bytes,2,opt,name=O,json=meta,inline,embedded=O" json:"meta,inline"`
	//
	Spec CommitActionSpec `protobuf:"bytes,3,opt,name=Spec,json=spec" json:"spec"`
	//
	Status CommitActionStatus `protobuf:"bytes,4,opt,name=Status,json=status" json:"status"`
}

func (m *CommitAction) Reset()                    { *m = CommitAction{} }
func (m *CommitAction) String() string            { return proto.CompactTextString(m) }
func (*CommitAction) ProtoMessage()               {}
func (*CommitAction) Descriptor() ([]byte, []int) { return fileDescriptorStaging, []int{6} }

func (m *CommitAction) GetSpec() CommitActionSpec {
	if m != nil {
		return m.Spec
	}
	return CommitActionSpec{}
}

func (m *CommitAction) GetStatus() CommitActionStatus {
	if m != nil {
		return m.Status
	}
	return CommitActionStatus{}
}

//
type CommitActionSpec struct {
}

func (m *CommitActionSpec) Reset()                    { *m = CommitActionSpec{} }
func (m *CommitActionSpec) String() string            { return proto.CompactTextString(m) }
func (*CommitActionSpec) ProtoMessage()               {}
func (*CommitActionSpec) Descriptor() ([]byte, []int) { return fileDescriptorStaging, []int{7} }

//
type CommitActionStatus struct {
	//
	Status string `protobuf:"bytes,1,opt,name=Status,json=status,proto3" json:"status"`
	//
	Reason string `protobuf:"bytes,2,opt,name=Reason,json=reason,proto3" json:"reason"`
}

func (m *CommitActionStatus) Reset()                    { *m = CommitActionStatus{} }
func (m *CommitActionStatus) String() string            { return proto.CompactTextString(m) }
func (*CommitActionStatus) ProtoMessage()               {}
func (*CommitActionStatus) Descriptor() ([]byte, []int) { return fileDescriptorStaging, []int{8} }

func (m *CommitActionStatus) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *CommitActionStatus) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

//
type Item struct {
	//
	ItemId `protobuf:"bytes,1,opt,name=Id,json=,inline,embedded=Id" json:",inline"`
	//
	Object *api.Any `protobuf:"bytes,2,opt,name=Object,json=object" json:"object"`
}

func (m *Item) Reset()                    { *m = Item{} }
func (m *Item) String() string            { return proto.CompactTextString(m) }
func (*Item) ProtoMessage()               {}
func (*Item) Descriptor() ([]byte, []int) { return fileDescriptorStaging, []int{9} }

func (m *Item) GetObject() *api.Any {
	if m != nil {
		return m.Object
	}
	return nil
}

//
type ItemId struct {
	//
	URI string `protobuf:"bytes,2,opt,name=URI,json=uri,proto3" json:"uri"`
	//
	Method string `protobuf:"bytes,3,opt,name=Method,json=method,proto3" json:"method"`
}

func (m *ItemId) Reset()                    { *m = ItemId{} }
func (m *ItemId) String() string            { return proto.CompactTextString(m) }
func (*ItemId) ProtoMessage()               {}
func (*ItemId) Descriptor() ([]byte, []int) { return fileDescriptorStaging, []int{10} }

func (m *ItemId) GetURI() string {
	if m != nil {
		return m.URI
	}
	return ""
}

func (m *ItemId) GetMethod() string {
	if m != nil {
		return m.Method
	}
	return ""
}

//
type ValidationError struct {
	//
	ItemId `protobuf:"bytes,1,opt,name=Id,json=,inline,embedded=Id" json:",inline"`
	//
	Errors []string `protobuf:"bytes,2,rep,name=Errors,json=error" json:"error"`
}

func (m *ValidationError) Reset()                    { *m = ValidationError{} }
func (m *ValidationError) String() string            { return proto.CompactTextString(m) }
func (*ValidationError) ProtoMessage()               {}
func (*ValidationError) Descriptor() ([]byte, []int) { return fileDescriptorStaging, []int{11} }

func (m *ValidationError) GetErrors() []string {
	if m != nil {
		return m.Errors
	}
	return nil
}

func init() {
	proto.RegisterType((*Buffer)(nil), "staging.Buffer")
	proto.RegisterType((*BufferSpec)(nil), "staging.BufferSpec")
	proto.RegisterType((*BufferStatus)(nil), "staging.BufferStatus")
	proto.RegisterType((*ClearAction)(nil), "staging.ClearAction")
	proto.RegisterType((*ClearActionSpec)(nil), "staging.ClearActionSpec")
	proto.RegisterType((*ClearActionStatus)(nil), "staging.ClearActionStatus")
	proto.RegisterType((*CommitAction)(nil), "staging.CommitAction")
	proto.RegisterType((*CommitActionSpec)(nil), "staging.CommitActionSpec")
	proto.RegisterType((*CommitActionStatus)(nil), "staging.CommitActionStatus")
	proto.RegisterType((*Item)(nil), "staging.Item")
	proto.RegisterType((*ItemId)(nil), "staging.ItemId")
	proto.RegisterType((*ValidationError)(nil), "staging.ValidationError")
	proto.RegisterEnum("staging.BufferStatus_ValidationStatus", BufferStatus_ValidationStatus_name, BufferStatus_ValidationStatus_value)
	proto.RegisterEnum("staging.ClearActionStatus_ClearStatus", ClearActionStatus_ClearStatus_name, ClearActionStatus_ClearStatus_value)
	proto.RegisterEnum("staging.CommitActionStatus_CommitStatus", CommitActionStatus_CommitStatus_name, CommitActionStatus_CommitStatus_value)
}
func (m *Buffer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Buffer) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintStaging(dAtA, i, uint64(m.TypeMeta.Size()))
	n1, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n1
	dAtA[i] = 0x12
	i++
	i = encodeVarintStaging(dAtA, i, uint64(m.ObjectMeta.Size()))
	n2, err := m.ObjectMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n2
	dAtA[i] = 0x1a
	i++
	i = encodeVarintStaging(dAtA, i, uint64(m.Spec.Size()))
	n3, err := m.Spec.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n3
	dAtA[i] = 0x22
	i++
	i = encodeVarintStaging(dAtA, i, uint64(m.Status.Size()))
	n4, err := m.Status.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n4
	return i, nil
}

func (m *BufferSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BufferSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Contact) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStaging(dAtA, i, uint64(len(m.Contact)))
		i += copy(dAtA[i:], m.Contact)
	}
	return i, nil
}

func (m *BufferStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BufferStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ValidationResult) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStaging(dAtA, i, uint64(len(m.ValidationResult)))
		i += copy(dAtA[i:], m.ValidationResult)
	}
	if len(m.Errors) > 0 {
		for _, msg := range m.Errors {
			dAtA[i] = 0x12
			i++
			i = encodeVarintStaging(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Items) > 0 {
		for _, msg := range m.Items {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintStaging(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ClearAction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClearAction) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintStaging(dAtA, i, uint64(m.TypeMeta.Size()))
	n5, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n5
	dAtA[i] = 0x12
	i++
	i = encodeVarintStaging(dAtA, i, uint64(m.ObjectMeta.Size()))
	n6, err := m.ObjectMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n6
	dAtA[i] = 0x1a
	i++
	i = encodeVarintStaging(dAtA, i, uint64(m.Spec.Size()))
	n7, err := m.Spec.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n7
	dAtA[i] = 0x22
	i++
	i = encodeVarintStaging(dAtA, i, uint64(m.Status.Size()))
	n8, err := m.Status.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n8
	return i, nil
}

func (m *ClearActionSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClearActionSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, msg := range m.Items {
			dAtA[i] = 0xa
			i++
			i = encodeVarintStaging(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ClearActionStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClearActionStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Status) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStaging(dAtA, i, uint64(len(m.Status)))
		i += copy(dAtA[i:], m.Status)
	}
	if len(m.Reason) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStaging(dAtA, i, uint64(len(m.Reason)))
		i += copy(dAtA[i:], m.Reason)
	}
	return i, nil
}

func (m *CommitAction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommitAction) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintStaging(dAtA, i, uint64(m.TypeMeta.Size()))
	n9, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n9
	dAtA[i] = 0x12
	i++
	i = encodeVarintStaging(dAtA, i, uint64(m.ObjectMeta.Size()))
	n10, err := m.ObjectMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n10
	dAtA[i] = 0x1a
	i++
	i = encodeVarintStaging(dAtA, i, uint64(m.Spec.Size()))
	n11, err := m.Spec.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n11
	dAtA[i] = 0x22
	i++
	i = encodeVarintStaging(dAtA, i, uint64(m.Status.Size()))
	n12, err := m.Status.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n12
	return i, nil
}

func (m *CommitActionSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommitActionSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *CommitActionStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommitActionStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Status) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStaging(dAtA, i, uint64(len(m.Status)))
		i += copy(dAtA[i:], m.Status)
	}
	if len(m.Reason) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStaging(dAtA, i, uint64(len(m.Reason)))
		i += copy(dAtA[i:], m.Reason)
	}
	return i, nil
}

func (m *Item) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Item) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintStaging(dAtA, i, uint64(m.ItemId.Size()))
	n13, err := m.ItemId.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n13
	if m.Object != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStaging(dAtA, i, uint64(m.Object.Size()))
		n14, err := m.Object.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	return i, nil
}

func (m *ItemId) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ItemId) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.URI) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStaging(dAtA, i, uint64(len(m.URI)))
		i += copy(dAtA[i:], m.URI)
	}
	if len(m.Method) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintStaging(dAtA, i, uint64(len(m.Method)))
		i += copy(dAtA[i:], m.Method)
	}
	return i, nil
}

func (m *ValidationError) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValidationError) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintStaging(dAtA, i, uint64(m.ItemId.Size()))
	n15, err := m.ItemId.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n15
	if len(m.Errors) > 0 {
		for _, s := range m.Errors {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func encodeVarintStaging(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Buffer) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovStaging(uint64(l))
	l = m.ObjectMeta.Size()
	n += 1 + l + sovStaging(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovStaging(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovStaging(uint64(l))
	return n
}

func (m *BufferSpec) Size() (n int) {
	var l int
	_ = l
	l = len(m.Contact)
	if l > 0 {
		n += 1 + l + sovStaging(uint64(l))
	}
	return n
}

func (m *BufferStatus) Size() (n int) {
	var l int
	_ = l
	l = len(m.ValidationResult)
	if l > 0 {
		n += 1 + l + sovStaging(uint64(l))
	}
	if len(m.Errors) > 0 {
		for _, e := range m.Errors {
			l = e.Size()
			n += 1 + l + sovStaging(uint64(l))
		}
	}
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovStaging(uint64(l))
		}
	}
	return n
}

func (m *ClearAction) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovStaging(uint64(l))
	l = m.ObjectMeta.Size()
	n += 1 + l + sovStaging(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovStaging(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovStaging(uint64(l))
	return n
}

func (m *ClearActionSpec) Size() (n int) {
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovStaging(uint64(l))
		}
	}
	return n
}

func (m *ClearActionStatus) Size() (n int) {
	var l int
	_ = l
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovStaging(uint64(l))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovStaging(uint64(l))
	}
	return n
}

func (m *CommitAction) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovStaging(uint64(l))
	l = m.ObjectMeta.Size()
	n += 1 + l + sovStaging(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovStaging(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovStaging(uint64(l))
	return n
}

func (m *CommitActionSpec) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *CommitActionStatus) Size() (n int) {
	var l int
	_ = l
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovStaging(uint64(l))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovStaging(uint64(l))
	}
	return n
}

func (m *Item) Size() (n int) {
	var l int
	_ = l
	l = m.ItemId.Size()
	n += 1 + l + sovStaging(uint64(l))
	if m.Object != nil {
		l = m.Object.Size()
		n += 1 + l + sovStaging(uint64(l))
	}
	return n
}

func (m *ItemId) Size() (n int) {
	var l int
	_ = l
	l = len(m.URI)
	if l > 0 {
		n += 1 + l + sovStaging(uint64(l))
	}
	l = len(m.Method)
	if l > 0 {
		n += 1 + l + sovStaging(uint64(l))
	}
	return n
}

func (m *ValidationError) Size() (n int) {
	var l int
	_ = l
	l = m.ItemId.Size()
	n += 1 + l + sovStaging(uint64(l))
	if len(m.Errors) > 0 {
		for _, s := range m.Errors {
			l = len(s)
			n += 1 + l + sovStaging(uint64(l))
		}
	}
	return n
}

func sovStaging(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozStaging(x uint64) (n int) {
	return sovStaging(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Buffer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStaging
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Buffer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Buffer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaging
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStaging
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaging
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStaging
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaging
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStaging
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaging
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStaging
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStaging(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStaging
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BufferSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStaging
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BufferSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BufferSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Contact", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaging
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStaging
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Contact = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStaging(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStaging
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BufferStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStaging
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BufferStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BufferStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidationResult", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaging
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStaging
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValidationResult = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Errors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaging
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStaging
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Errors = append(m.Errors, &ValidationError{})
			if err := m.Errors[len(m.Errors)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaging
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStaging
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &Item{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStaging(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStaging
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClearAction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStaging
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClearAction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClearAction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaging
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStaging
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaging
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStaging
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaging
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStaging
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaging
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStaging
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStaging(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStaging
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClearActionSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStaging
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClearActionSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClearActionSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaging
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStaging
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &ItemId{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStaging(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStaging
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClearActionStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStaging
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClearActionStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClearActionStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaging
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStaging
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaging
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStaging
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStaging(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStaging
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommitAction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStaging
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommitAction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommitAction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaging
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStaging
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaging
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStaging
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaging
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStaging
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaging
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStaging
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStaging(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStaging
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommitActionSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStaging
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommitActionSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommitActionSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipStaging(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStaging
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommitActionStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStaging
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommitActionStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommitActionStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaging
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStaging
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaging
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStaging
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStaging(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStaging
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Item) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStaging
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Item: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Item: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaging
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStaging
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ItemId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Object", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaging
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStaging
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Object == nil {
				m.Object = &api.Any{}
			}
			if err := m.Object.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStaging(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStaging
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ItemId) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStaging
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ItemId: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ItemId: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URI", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaging
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStaging
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.URI = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Method", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaging
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStaging
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Method = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStaging(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStaging
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ValidationError) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStaging
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValidationError: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValidationError: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaging
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStaging
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ItemId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Errors", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaging
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStaging
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Errors = append(m.Errors, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStaging(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStaging
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipStaging(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowStaging
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowStaging
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowStaging
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthStaging
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowStaging
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipStaging(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthStaging = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowStaging   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("staging.proto", fileDescriptorStaging) }

var fileDescriptorStaging = []byte{
	// 768 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x55, 0x41, 0x6f, 0xd3, 0x48,
	0x14, 0x8e, 0x93, 0xd4, 0xd9, 0xbc, 0xb4, 0x9b, 0x74, 0xaa, 0xdd, 0x75, 0xb2, 0x52, 0x52, 0x59,
	0xda, 0x6e, 0x56, 0x5b, 0x6c, 0x54, 0xa0, 0x12, 0x05, 0x04, 0x75, 0x08, 0x28, 0x52, 0x4b, 0x91,
	0xd3, 0x72, 0x77, 0x9c, 0x69, 0x6a, 0x94, 0x8c, 0x2d, 0x7b, 0x5c, 0x54, 0x21, 0x8e, 0xf4, 0x17,
	0x20, 0xf1, 0x03, 0x90, 0x38, 0x54, 0xe2, 0xc0, 0xbf, 0xe8, 0xb1, 0xe2, 0x07, 0x44, 0x28, 0x27,
	0x94, 0x5f, 0x81, 0x3c, 0x9e, 0x24, 0x8e, 0xd3, 0x52, 0xa9, 0x3d, 0xf4, 0x32, 0x2f, 0xf3, 0xe6,
	0x7d, 0x6f, 0xde, 0x7b, 0xdf, 0x97, 0x31, 0x2c, 0x78, 0xd4, 0xe8, 0x58, 0xa4, 0xa3, 0x38, 0xae,
	0x4d, 0x6d, 0x94, 0xe1, 0xdb, 0x52, 0xbd, 0x63, 0xd1, 0x03, 0xbf, 0xa5, 0x98, 0x76, 0x4f, 0x75,
	0x30, 0xf1, 0x0c, 0xd2, 0xb6, 0x55, 0xef, 0x8d, 0x7a, 0x88, 0x89, 0x65, 0x62, 0xd5, 0xa7, 0x56,
	0xd7, 0x53, 0x0d, 0xc7, 0xea, 0x60, 0xa2, 0x1a, 0x84, 0xd8, 0xd4, 0xa0, 0x96, 0x4d, 0x3c, 0xd5,
	0x22, 0x66, 0xd7, 0x6f, 0x63, 0x2f, 0xcc, 0x57, 0xfa, 0xe7, 0x82, 0x34, 0x86, 0x63, 0xa9, 0x3d,
	0x4c, 0x8d, 0x30, 0x4c, 0xfe, 0x90, 0x04, 0x51, 0xf3, 0xf7, 0xf7, 0xb1, 0x8b, 0xd6, 0x41, 0xd8,
	0x95, 0x84, 0x65, 0xa1, 0x9a, 0x5b, 0x5b, 0x50, 0x0c, 0xc7, 0x52, 0x76, 0x8f, 0x1c, 0xbc, 0x8d,
	0xa9, 0xa1, 0x2d, 0x9d, 0xf6, 0x2b, 0x89, 0xb3, 0x7e, 0x45, 0x18, 0xf6, 0x2b, 0x99, 0x55, 0x8b,
	0x74, 0x2d, 0x82, 0xf5, 0xd1, 0x0f, 0xf4, 0x04, 0x84, 0x1d, 0x29, 0xc9, 0x70, 0x79, 0x86, 0xdb,
	0x69, 0xbd, 0xc6, 0x26, 0x65, 0xc8, 0xbf, 0x22, 0xc8, 0x5c, 0x70, 0xed, 0x08, 0x1d, 0xdd, 0xa0,
	0x7b, 0x90, 0x6e, 0x3a, 0xd8, 0x94, 0x52, 0x2c, 0xc9, 0x92, 0x32, 0x9a, 0x4c, 0x58, 0x58, 0x70,
	0xa4, 0xcd, 0x07, 0x89, 0x86, 0xfd, 0x4a, 0xda, 0x73, 0xb0, 0xa9, 0xb3, 0x15, 0x3d, 0x02, 0xb1,
	0x49, 0x0d, 0xea, 0x7b, 0x52, 0x9a, 0x01, 0xff, 0x88, 0x03, 0xd9, 0xa1, 0xf6, 0x3b, 0x87, 0x8a,
	0x1e, 0xdb, 0xeb, 0xdc, 0x6e, 0x94, 0xbe, 0xbd, 0x2f, 0xfe, 0x09, 0x39, 0xf5, 0xed, 0x8e, 0xb2,
	0x8b, 0x89, 0x41, 0xe8, 0x3b, 0x94, 0x69, 0x31, 0xa0, 0x27, 0xaf, 0x00, 0x4c, 0x2e, 0x47, 0x12,
	0x64, 0x6a, 0x36, 0xa1, 0x86, 0x49, 0xd9, 0x7c, 0xb2, 0xfa, 0x68, 0x2b, 0x7f, 0x4c, 0xc2, 0x7c,
	0xf4, 0x32, 0xd4, 0x85, 0xc2, 0x2b, 0xa3, 0x6b, 0xb5, 0x19, 0x29, 0x3a, 0xf6, 0xfc, 0x2e, 0xc7,
	0x68, 0x8f, 0x4f, 0x8e, 0x8b, 0x2b, 0x4d, 0xea, 0xd6, 0x89, 0xdf, 0xab, 0x46, 0x31, 0xca, 0x04,
	0x10, 0x3a, 0xfe, 0x1b, 0xf6, 0x2b, 0x8b, 0x87, 0x63, 0xe7, 0x2d, 0x97, 0xa5, 0xd1, 0x67, 0x5d,
	0xe8, 0x21, 0x88, 0x75, 0xd7, 0xb5, 0x5d, 0x4f, 0x4a, 0x2e, 0xa7, 0xaa, 0xb9, 0x35, 0x69, 0x3c,
	0x81, 0x49, 0x4e, 0x16, 0xa0, 0x41, 0x30, 0x00, 0xcc, 0x62, 0x75, 0x6e, 0x91, 0x02, 0x73, 0x0d,
	0x8a, 0x7b, 0x9e, 0x94, 0x62, 0xe0, 0x85, 0x31, 0x38, 0xf0, 0x6a, 0xd9, 0x61, 0xbf, 0x32, 0x67,
	0x05, 0xe7, 0x7a, 0x68, 0xe4, 0xff, 0xa3, 0xbd, 0xf1, 0x7e, 0x73, 0x90, 0x69, 0xee, 0xd5, 0x6a,
	0xf5, 0x66, 0xb3, 0x90, 0x40, 0x00, 0xe2, 0xb3, 0xcd, 0xc6, 0x56, 0xfd, 0x69, 0x41, 0x90, 0x3f,
	0x25, 0x21, 0x57, 0xeb, 0x62, 0xc3, 0xdd, 0x34, 0x83, 0xf0, 0x1b, 0x54, 0xd7, 0xc6, 0x94, 0xba,
	0x26, 0x23, 0x8a, 0x54, 0x77, 0xa1, 0xc4, 0xb4, 0x98, 0xc4, 0x4a, 0xe7, 0xa2, 0xaf, 0xae, 0xb3,
	0x1a, 0xe4, 0x63, 0x65, 0xa0, 0xdb, 0x23, 0x56, 0x04, 0xc6, 0x4a, 0x7e, 0x8a, 0x95, 0x46, 0xfb,
	0x1c, 0x5e, 0xbe, 0x08, 0xb0, 0x38, 0x53, 0x0e, 0xda, 0x1a, 0x97, 0x1e, 0xea, 0xef, 0x6e, 0x54,
	0x7f, 0x33, 0xe1, 0x61, 0x3f, 0x13, 0xfd, 0xc5, 0x9a, 0x40, 0x32, 0x88, 0x3a, 0x36, 0x3c, 0x9b,
	0x30, 0x2e, 0xb2, 0xa1, 0x9e, 0x5c, 0xe6, 0xd1, 0xb9, 0x95, 0x57, 0x38, 0xe3, 0x97, 0x49, 0xe3,
	0x73, 0x12, 0xe6, 0x6b, 0x76, 0xaf, 0x67, 0xd1, 0x1b, 0xd7, 0xc6, 0x83, 0x29, 0x6d, 0x14, 0x27,
	0xec, 0x46, 0xca, 0xbb, 0x50, 0x1c, 0xb5, 0x98, 0x38, 0xfe, 0x3e, 0x1f, 0x7e, 0x75, 0x75, 0x20,
	0x28, 0xc4, 0x0b, 0x91, 0xbf, 0x0a, 0x80, 0x66, 0xd3, 0xa3, 0x17, 0x31, 0xb6, 0xd7, 0x4f, 0x8e,
	0x8b, 0xd5, 0x31, 0xdb, 0x33, 0xf1, 0xbc, 0xc2, 0xeb, 0xf1, 0xfd, 0xef, 0x88, 0xc6, 0xcb, 0x08,
	0xb7, 0x21, 0x1d, 0x88, 0x17, 0xdd, 0x87, 0x64, 0xa3, 0xcd, 0x89, 0x9e, 0xd1, 0xf5, 0xaf, 0xa9,
	0x5e, 0x05, 0x31, 0x24, 0x97, 0xf3, 0xfd, 0x1b, 0xe3, 0x7b, 0x93, 0x1c, 0x85, 0x95, 0xd9, 0xec,
	0x4c, 0xe7, 0x56, 0x7e, 0x0e, 0x62, 0x98, 0x15, 0x15, 0x21, 0xb5, 0xa7, 0x37, 0x78, 0x13, 0x99,
	0x61, 0xbf, 0x92, 0xf2, 0x5d, 0x4b, 0x0f, 0x96, 0xa0, 0xc5, 0x6d, 0x4c, 0x0f, 0xec, 0x36, 0x63,
	0x9f, 0xb7, 0xd8, 0x63, 0x1e, 0x9d, 0x5b, 0x99, 0x40, 0x3e, 0xf6, 0x92, 0x5e, 0xa7, 0x89, 0xe5,
	0xa9, 0xe7, 0x3a, 0x1b, 0xfe, 0x95, 0xd9, 0x63, 0xac, 0x87, 0x46, 0x2b, 0x9c, 0x0e, 0xca, 0xc2,
	0xd9, 0xa0, 0x2c, 0x7c, 0x1f, 0x94, 0x85, 0x1f, 0x83, 0x72, 0xe2, 0x65, 0xa2, 0x25, 0xb2, 0x2f,
	0xf5, 0x9d, 0x9f, 0x01, 0x00, 0x00, 0xff, 0xff, 0xc5, 0xe2, 0xf5, 0x81, 0x31, 0x08, 0x00, 0x00,
}
