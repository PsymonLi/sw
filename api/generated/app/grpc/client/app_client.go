// Code generated by protoc-gen-grpc-pensando DO NOT EDIT.

package grpcclient

import (
	"context"
	"errors"
	oldlog "log"

	"github.com/go-kit/kit/endpoint"
	grpctransport "github.com/go-kit/kit/transport/grpc"
	"google.golang.org/grpc"

	api "github.com/pensando/sw/api"
	app "github.com/pensando/sw/api/generated/app"
	listerwatcher "github.com/pensando/sw/api/listerwatcher"
	apiserver "github.com/pensando/sw/venice/apiserver"
	"github.com/pensando/sw/venice/utils/kvstore"
	"github.com/pensando/sw/venice/utils/log"
	"github.com/pensando/sw/venice/utils/trace"
)

// Dummy vars to suppress import errors
var _ api.TypeMeta
var _ listerwatcher.WatcherClient
var _ kvstore.Interface

// NewAppV1 sets up a new client for AppV1
func NewAppV1(conn *grpc.ClientConn, logger log.Logger) app.ServiceAppV1Client {

	var lAutoAddAppEndpoint endpoint.Endpoint
	{
		lAutoAddAppEndpoint = grpctransport.NewClient(
			conn,
			"app.AppV1",
			"AutoAddApp",
			app.EncodeGrpcReqApp,
			app.DecodeGrpcRespApp,
			&app.App{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoAddAppEndpoint = trace.ClientEndPoint("AppV1:AutoAddApp")(lAutoAddAppEndpoint)
	}
	var lAutoAddAppUserEndpoint endpoint.Endpoint
	{
		lAutoAddAppUserEndpoint = grpctransport.NewClient(
			conn,
			"app.AppV1",
			"AutoAddAppUser",
			app.EncodeGrpcReqAppUser,
			app.DecodeGrpcRespAppUser,
			&app.AppUser{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoAddAppUserEndpoint = trace.ClientEndPoint("AppV1:AutoAddAppUser")(lAutoAddAppUserEndpoint)
	}
	var lAutoAddAppUserGrpEndpoint endpoint.Endpoint
	{
		lAutoAddAppUserGrpEndpoint = grpctransport.NewClient(
			conn,
			"app.AppV1",
			"AutoAddAppUserGrp",
			app.EncodeGrpcReqAppUserGrp,
			app.DecodeGrpcRespAppUserGrp,
			&app.AppUserGrp{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoAddAppUserGrpEndpoint = trace.ClientEndPoint("AppV1:AutoAddAppUserGrp")(lAutoAddAppUserGrpEndpoint)
	}
	var lAutoDeleteAppEndpoint endpoint.Endpoint
	{
		lAutoDeleteAppEndpoint = grpctransport.NewClient(
			conn,
			"app.AppV1",
			"AutoDeleteApp",
			app.EncodeGrpcReqApp,
			app.DecodeGrpcRespApp,
			&app.App{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoDeleteAppEndpoint = trace.ClientEndPoint("AppV1:AutoDeleteApp")(lAutoDeleteAppEndpoint)
	}
	var lAutoDeleteAppUserEndpoint endpoint.Endpoint
	{
		lAutoDeleteAppUserEndpoint = grpctransport.NewClient(
			conn,
			"app.AppV1",
			"AutoDeleteAppUser",
			app.EncodeGrpcReqAppUser,
			app.DecodeGrpcRespAppUser,
			&app.AppUser{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoDeleteAppUserEndpoint = trace.ClientEndPoint("AppV1:AutoDeleteAppUser")(lAutoDeleteAppUserEndpoint)
	}
	var lAutoDeleteAppUserGrpEndpoint endpoint.Endpoint
	{
		lAutoDeleteAppUserGrpEndpoint = grpctransport.NewClient(
			conn,
			"app.AppV1",
			"AutoDeleteAppUserGrp",
			app.EncodeGrpcReqAppUserGrp,
			app.DecodeGrpcRespAppUserGrp,
			&app.AppUserGrp{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoDeleteAppUserGrpEndpoint = trace.ClientEndPoint("AppV1:AutoDeleteAppUserGrp")(lAutoDeleteAppUserGrpEndpoint)
	}
	var lAutoGetAppEndpoint endpoint.Endpoint
	{
		lAutoGetAppEndpoint = grpctransport.NewClient(
			conn,
			"app.AppV1",
			"AutoGetApp",
			app.EncodeGrpcReqApp,
			app.DecodeGrpcRespApp,
			&app.App{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoGetAppEndpoint = trace.ClientEndPoint("AppV1:AutoGetApp")(lAutoGetAppEndpoint)
	}
	var lAutoGetAppUserEndpoint endpoint.Endpoint
	{
		lAutoGetAppUserEndpoint = grpctransport.NewClient(
			conn,
			"app.AppV1",
			"AutoGetAppUser",
			app.EncodeGrpcReqAppUser,
			app.DecodeGrpcRespAppUser,
			&app.AppUser{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoGetAppUserEndpoint = trace.ClientEndPoint("AppV1:AutoGetAppUser")(lAutoGetAppUserEndpoint)
	}
	var lAutoGetAppUserGrpEndpoint endpoint.Endpoint
	{
		lAutoGetAppUserGrpEndpoint = grpctransport.NewClient(
			conn,
			"app.AppV1",
			"AutoGetAppUserGrp",
			app.EncodeGrpcReqAppUserGrp,
			app.DecodeGrpcRespAppUserGrp,
			&app.AppUserGrp{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoGetAppUserGrpEndpoint = trace.ClientEndPoint("AppV1:AutoGetAppUserGrp")(lAutoGetAppUserGrpEndpoint)
	}
	var lAutoListAppEndpoint endpoint.Endpoint
	{
		lAutoListAppEndpoint = grpctransport.NewClient(
			conn,
			"app.AppV1",
			"AutoListApp",
			app.EncodeGrpcReqListWatchOptions,
			app.DecodeGrpcRespAppList,
			&app.AppList{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoListAppEndpoint = trace.ClientEndPoint("AppV1:AutoListApp")(lAutoListAppEndpoint)
	}
	var lAutoListAppUserEndpoint endpoint.Endpoint
	{
		lAutoListAppUserEndpoint = grpctransport.NewClient(
			conn,
			"app.AppV1",
			"AutoListAppUser",
			app.EncodeGrpcReqListWatchOptions,
			app.DecodeGrpcRespAppUserList,
			&app.AppUserList{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoListAppUserEndpoint = trace.ClientEndPoint("AppV1:AutoListAppUser")(lAutoListAppUserEndpoint)
	}
	var lAutoListAppUserGrpEndpoint endpoint.Endpoint
	{
		lAutoListAppUserGrpEndpoint = grpctransport.NewClient(
			conn,
			"app.AppV1",
			"AutoListAppUserGrp",
			app.EncodeGrpcReqListWatchOptions,
			app.DecodeGrpcRespAppUserGrpList,
			&app.AppUserGrpList{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoListAppUserGrpEndpoint = trace.ClientEndPoint("AppV1:AutoListAppUserGrp")(lAutoListAppUserGrpEndpoint)
	}
	var lAutoUpdateAppEndpoint endpoint.Endpoint
	{
		lAutoUpdateAppEndpoint = grpctransport.NewClient(
			conn,
			"app.AppV1",
			"AutoUpdateApp",
			app.EncodeGrpcReqApp,
			app.DecodeGrpcRespApp,
			&app.App{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoUpdateAppEndpoint = trace.ClientEndPoint("AppV1:AutoUpdateApp")(lAutoUpdateAppEndpoint)
	}
	var lAutoUpdateAppUserEndpoint endpoint.Endpoint
	{
		lAutoUpdateAppUserEndpoint = grpctransport.NewClient(
			conn,
			"app.AppV1",
			"AutoUpdateAppUser",
			app.EncodeGrpcReqAppUser,
			app.DecodeGrpcRespAppUser,
			&app.AppUser{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoUpdateAppUserEndpoint = trace.ClientEndPoint("AppV1:AutoUpdateAppUser")(lAutoUpdateAppUserEndpoint)
	}
	var lAutoUpdateAppUserGrpEndpoint endpoint.Endpoint
	{
		lAutoUpdateAppUserGrpEndpoint = grpctransport.NewClient(
			conn,
			"app.AppV1",
			"AutoUpdateAppUserGrp",
			app.EncodeGrpcReqAppUserGrp,
			app.DecodeGrpcRespAppUserGrp,
			&app.AppUserGrp{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoUpdateAppUserGrpEndpoint = trace.ClientEndPoint("AppV1:AutoUpdateAppUserGrp")(lAutoUpdateAppUserGrpEndpoint)
	}
	return app.EndpointsAppV1Client{
		Client: app.NewAppV1Client(conn),

		AutoAddAppEndpoint:           lAutoAddAppEndpoint,
		AutoAddAppUserEndpoint:       lAutoAddAppUserEndpoint,
		AutoAddAppUserGrpEndpoint:    lAutoAddAppUserGrpEndpoint,
		AutoDeleteAppEndpoint:        lAutoDeleteAppEndpoint,
		AutoDeleteAppUserEndpoint:    lAutoDeleteAppUserEndpoint,
		AutoDeleteAppUserGrpEndpoint: lAutoDeleteAppUserGrpEndpoint,
		AutoGetAppEndpoint:           lAutoGetAppEndpoint,
		AutoGetAppUserEndpoint:       lAutoGetAppUserEndpoint,
		AutoGetAppUserGrpEndpoint:    lAutoGetAppUserGrpEndpoint,
		AutoListAppEndpoint:          lAutoListAppEndpoint,
		AutoListAppUserEndpoint:      lAutoListAppUserEndpoint,
		AutoListAppUserGrpEndpoint:   lAutoListAppUserGrpEndpoint,
		AutoUpdateAppEndpoint:        lAutoUpdateAppEndpoint,
		AutoUpdateAppUserEndpoint:    lAutoUpdateAppUserEndpoint,
		AutoUpdateAppUserGrpEndpoint: lAutoUpdateAppUserGrpEndpoint,
	}
}

// NewAppV1Backend creates an instrumented client with middleware
func NewAppV1Backend(conn *grpc.ClientConn, logger log.Logger) app.ServiceAppV1Client {
	cl := NewAppV1(conn, logger)
	cl = app.LoggingAppV1MiddlewareClient(logger)(cl)
	return cl
}

type grpcObjAppV1App struct {
	logger log.Logger
	client app.ServiceAppV1Client
}

func (a *grpcObjAppV1App) Create(ctx context.Context, in *app.App) (*app.App, error) {
	a.logger.DebugLog("msg", "received call", "object", "App", "oper", "create")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoAddApp(nctx, in)
}

func (a *grpcObjAppV1App) Update(ctx context.Context, in *app.App) (*app.App, error) {
	a.logger.DebugLog("msg", "received call", "object", "App", "oper", "update")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoUpdateApp(nctx, in)
}

func (a *grpcObjAppV1App) Get(ctx context.Context, objMeta *api.ObjectMeta) (*app.App, error) {
	a.logger.DebugLog("msg", "received call", "object", "App", "oper", "get")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := app.App{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoGetApp(nctx, &in)
}

func (a *grpcObjAppV1App) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*app.App, error) {
	a.logger.DebugLog("msg", "received call", "object", "App", "oper", "delete")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := app.App{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoDeleteApp(nctx, &in)
}

func (a *grpcObjAppV1App) List(ctx context.Context, options *api.ListWatchOptions) ([]*app.App, error) {
	a.logger.DebugLog("msg", "received call", "object", "App", "oper", "list")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	r, err := a.client.AutoListApp(nctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *grpcObjAppV1App) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	a.logger.DebugLog("msg", "received call", "object", "App", "oper", "WatchOper")
	nctx := addVersion(ctx, "v1")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	stream, err := a.client.AutoWatchApp(nctx, options)
	if err != nil {
		return nil, err
	}
	wstream := stream.(app.AppV1_AutoWatchAppClient)
	bridgefn := func(lw *listerwatcher.WatcherClient) {
		for {
			r, err := wstream.Recv()
			if err != nil {
				a.logger.ErrorLog("msg", "error on receive", "error", err)
				close(lw.OutCh)
				return
			}
			ev := kvstore.WatchEvent{
				Type:   kvstore.WatchEventType(r.Type),
				Object: r.Object,
			}
			select {
			case lw.OutCh <- &ev:
			case <-wstream.Context().Done():
				close(lw.OutCh)
				return
			}
		}
	}
	lw := listerwatcher.NewWatcherClient(wstream, bridgefn)
	lw.Run()
	return lw, nil
}

func (a *grpcObjAppV1App) Allowed(oper apiserver.APIOperType) bool {
	return true
}

type restObjAppV1App struct {
	endpoints app.EndpointsAppV1RestClient
	instance  string
}

func (a *restObjAppV1App) Create(ctx context.Context, in *app.App) (*app.App, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoAddApp(ctx, in)
}

func (a *restObjAppV1App) Update(ctx context.Context, in *app.App) (*app.App, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoUpdateApp(ctx, in)
}

func (a *restObjAppV1App) Get(ctx context.Context, objMeta *api.ObjectMeta) (*app.App, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := app.App{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoGetApp(ctx, &in)
}

func (a *restObjAppV1App) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*app.App, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := app.App{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoDeleteApp(ctx, &in)
}

func (a *restObjAppV1App) List(ctx context.Context, options *api.ListWatchOptions) ([]*app.App, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}
	r, err := a.endpoints.AutoListApp(ctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *restObjAppV1App) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	return nil, errors.New("not allowed")
}

func (a *restObjAppV1App) Allowed(oper apiserver.APIOperType) bool {
	switch oper {
	case apiserver.CreateOper:
		return false
	case apiserver.UpdateOper:
		return false
	case apiserver.GetOper:
		return true
	case apiserver.DeleteOper:
		return false
	case apiserver.ListOper:
		return true
	case apiserver.WatchOper:
		return false
	default:
		return false
	}
}

type grpcObjAppV1AppUser struct {
	logger log.Logger
	client app.ServiceAppV1Client
}

func (a *grpcObjAppV1AppUser) Create(ctx context.Context, in *app.AppUser) (*app.AppUser, error) {
	a.logger.DebugLog("msg", "received call", "object", "AppUser", "oper", "create")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoAddAppUser(nctx, in)
}

func (a *grpcObjAppV1AppUser) Update(ctx context.Context, in *app.AppUser) (*app.AppUser, error) {
	a.logger.DebugLog("msg", "received call", "object", "AppUser", "oper", "update")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoUpdateAppUser(nctx, in)
}

func (a *grpcObjAppV1AppUser) Get(ctx context.Context, objMeta *api.ObjectMeta) (*app.AppUser, error) {
	a.logger.DebugLog("msg", "received call", "object", "AppUser", "oper", "get")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := app.AppUser{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoGetAppUser(nctx, &in)
}

func (a *grpcObjAppV1AppUser) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*app.AppUser, error) {
	a.logger.DebugLog("msg", "received call", "object", "AppUser", "oper", "delete")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := app.AppUser{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoDeleteAppUser(nctx, &in)
}

func (a *grpcObjAppV1AppUser) List(ctx context.Context, options *api.ListWatchOptions) ([]*app.AppUser, error) {
	a.logger.DebugLog("msg", "received call", "object", "AppUser", "oper", "list")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	r, err := a.client.AutoListAppUser(nctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *grpcObjAppV1AppUser) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	a.logger.DebugLog("msg", "received call", "object", "AppUser", "oper", "WatchOper")
	nctx := addVersion(ctx, "v1")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	stream, err := a.client.AutoWatchAppUser(nctx, options)
	if err != nil {
		return nil, err
	}
	wstream := stream.(app.AppV1_AutoWatchAppUserClient)
	bridgefn := func(lw *listerwatcher.WatcherClient) {
		for {
			r, err := wstream.Recv()
			if err != nil {
				a.logger.ErrorLog("msg", "error on receive", "error", err)
				close(lw.OutCh)
				return
			}
			ev := kvstore.WatchEvent{
				Type:   kvstore.WatchEventType(r.Type),
				Object: r.Object,
			}
			select {
			case lw.OutCh <- &ev:
			case <-wstream.Context().Done():
				close(lw.OutCh)
				return
			}
		}
	}
	lw := listerwatcher.NewWatcherClient(wstream, bridgefn)
	lw.Run()
	return lw, nil
}

func (a *grpcObjAppV1AppUser) Allowed(oper apiserver.APIOperType) bool {
	return true
}

type restObjAppV1AppUser struct {
	endpoints app.EndpointsAppV1RestClient
	instance  string
}

func (a *restObjAppV1AppUser) Create(ctx context.Context, in *app.AppUser) (*app.AppUser, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoAddAppUser(ctx, in)
}

func (a *restObjAppV1AppUser) Update(ctx context.Context, in *app.AppUser) (*app.AppUser, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoUpdateAppUser(ctx, in)
}

func (a *restObjAppV1AppUser) Get(ctx context.Context, objMeta *api.ObjectMeta) (*app.AppUser, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := app.AppUser{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoGetAppUser(ctx, &in)
}

func (a *restObjAppV1AppUser) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*app.AppUser, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := app.AppUser{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoDeleteAppUser(ctx, &in)
}

func (a *restObjAppV1AppUser) List(ctx context.Context, options *api.ListWatchOptions) ([]*app.AppUser, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}
	r, err := a.endpoints.AutoListAppUser(ctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *restObjAppV1AppUser) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	return nil, errors.New("not allowed")
}

func (a *restObjAppV1AppUser) Allowed(oper apiserver.APIOperType) bool {
	switch oper {
	case apiserver.CreateOper:
		return true
	case apiserver.UpdateOper:
		return true
	case apiserver.GetOper:
		return true
	case apiserver.DeleteOper:
		return true
	case apiserver.ListOper:
		return true
	case apiserver.WatchOper:
		return false
	default:
		return false
	}
}

type grpcObjAppV1AppUserGrp struct {
	logger log.Logger
	client app.ServiceAppV1Client
}

func (a *grpcObjAppV1AppUserGrp) Create(ctx context.Context, in *app.AppUserGrp) (*app.AppUserGrp, error) {
	a.logger.DebugLog("msg", "received call", "object", "AppUserGrp", "oper", "create")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoAddAppUserGrp(nctx, in)
}

func (a *grpcObjAppV1AppUserGrp) Update(ctx context.Context, in *app.AppUserGrp) (*app.AppUserGrp, error) {
	a.logger.DebugLog("msg", "received call", "object", "AppUserGrp", "oper", "update")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoUpdateAppUserGrp(nctx, in)
}

func (a *grpcObjAppV1AppUserGrp) Get(ctx context.Context, objMeta *api.ObjectMeta) (*app.AppUserGrp, error) {
	a.logger.DebugLog("msg", "received call", "object", "AppUserGrp", "oper", "get")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := app.AppUserGrp{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoGetAppUserGrp(nctx, &in)
}

func (a *grpcObjAppV1AppUserGrp) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*app.AppUserGrp, error) {
	a.logger.DebugLog("msg", "received call", "object", "AppUserGrp", "oper", "delete")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := app.AppUserGrp{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoDeleteAppUserGrp(nctx, &in)
}

func (a *grpcObjAppV1AppUserGrp) List(ctx context.Context, options *api.ListWatchOptions) ([]*app.AppUserGrp, error) {
	a.logger.DebugLog("msg", "received call", "object", "AppUserGrp", "oper", "list")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	r, err := a.client.AutoListAppUserGrp(nctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *grpcObjAppV1AppUserGrp) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	a.logger.DebugLog("msg", "received call", "object", "AppUserGrp", "oper", "WatchOper")
	nctx := addVersion(ctx, "v1")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	stream, err := a.client.AutoWatchAppUserGrp(nctx, options)
	if err != nil {
		return nil, err
	}
	wstream := stream.(app.AppV1_AutoWatchAppUserGrpClient)
	bridgefn := func(lw *listerwatcher.WatcherClient) {
		for {
			r, err := wstream.Recv()
			if err != nil {
				a.logger.ErrorLog("msg", "error on receive", "error", err)
				close(lw.OutCh)
				return
			}
			ev := kvstore.WatchEvent{
				Type:   kvstore.WatchEventType(r.Type),
				Object: r.Object,
			}
			select {
			case lw.OutCh <- &ev:
			case <-wstream.Context().Done():
				close(lw.OutCh)
				return
			}
		}
	}
	lw := listerwatcher.NewWatcherClient(wstream, bridgefn)
	lw.Run()
	return lw, nil
}

func (a *grpcObjAppV1AppUserGrp) Allowed(oper apiserver.APIOperType) bool {
	return true
}

type restObjAppV1AppUserGrp struct {
	endpoints app.EndpointsAppV1RestClient
	instance  string
}

func (a *restObjAppV1AppUserGrp) Create(ctx context.Context, in *app.AppUserGrp) (*app.AppUserGrp, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoAddAppUserGrp(ctx, in)
}

func (a *restObjAppV1AppUserGrp) Update(ctx context.Context, in *app.AppUserGrp) (*app.AppUserGrp, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoUpdateAppUserGrp(ctx, in)
}

func (a *restObjAppV1AppUserGrp) Get(ctx context.Context, objMeta *api.ObjectMeta) (*app.AppUserGrp, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := app.AppUserGrp{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoGetAppUserGrp(ctx, &in)
}

func (a *restObjAppV1AppUserGrp) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*app.AppUserGrp, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := app.AppUserGrp{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoDeleteAppUserGrp(ctx, &in)
}

func (a *restObjAppV1AppUserGrp) List(ctx context.Context, options *api.ListWatchOptions) ([]*app.AppUserGrp, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}
	r, err := a.endpoints.AutoListAppUserGrp(ctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *restObjAppV1AppUserGrp) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	return nil, errors.New("not allowed")
}

func (a *restObjAppV1AppUserGrp) Allowed(oper apiserver.APIOperType) bool {
	switch oper {
	case apiserver.CreateOper:
		return true
	case apiserver.UpdateOper:
		return true
	case apiserver.GetOper:
		return true
	case apiserver.DeleteOper:
		return true
	case apiserver.ListOper:
		return true
	case apiserver.WatchOper:
		return false
	default:
		return false
	}
}

type crudClientAppV1 struct {
	grpcApp        app.AppInterface
	grpcAppUser    app.AppUserInterface
	grpcAppUserGrp app.AppUserGrpInterface
}

// NewGrpcCrudClientAppV1 creates a GRPC client for the service
func NewGrpcCrudClientAppV1(conn *grpc.ClientConn, logger log.Logger) app.AppV1Interface {
	client := NewAppV1Backend(conn, logger)
	return &crudClientAppV1{

		grpcApp:        &grpcObjAppV1App{client: client, logger: logger},
		grpcAppUser:    &grpcObjAppV1AppUser{client: client, logger: logger},
		grpcAppUserGrp: &grpcObjAppV1AppUserGrp{client: client, logger: logger},
	}
}

func (a *crudClientAppV1) App() app.AppInterface {
	return a.grpcApp
}

func (a *crudClientAppV1) AppUser() app.AppUserInterface {
	return a.grpcAppUser
}

func (a *crudClientAppV1) AppUserGrp() app.AppUserGrpInterface {
	return a.grpcAppUserGrp
}

type crudRestClientAppV1 struct {
	restApp        app.AppInterface
	restAppUser    app.AppUserInterface
	restAppUserGrp app.AppUserGrpInterface
}

// NewRestCrudClientAppV1 creates a REST client for the service.
func NewRestCrudClientAppV1(url string) app.AppV1Interface {
	endpoints, err := app.MakeAppV1RestClientEndpoints(url)
	if err != nil {
		oldlog.Fatal("failed to create client")
	}
	return &crudRestClientAppV1{

		restApp:        &restObjAppV1App{endpoints: endpoints, instance: url},
		restAppUser:    &restObjAppV1AppUser{endpoints: endpoints, instance: url},
		restAppUserGrp: &restObjAppV1AppUserGrp{endpoints: endpoints, instance: url},
	}
}

func (a *crudRestClientAppV1) App() app.AppInterface {
	return a.restApp
}

func (a *crudRestClientAppV1) AppUser() app.AppUserInterface {
	return a.restAppUser
}

func (a *crudRestClientAppV1) AppUserGrp() app.AppUserGrpInterface {
	return a.restAppUserGrp
}
