# -*- mode: ruby -*-
# vi: set ft=ruby :

require 'fileutils'
load 'tools/vagrant-files/Vagrantfile.include'

VAGRANTFILE_API_VERSION = "2"
Vagrant.configure(VAGRANTFILE_API_VERSION) do |config|
  config.vm.box = "nasuku/centos73"
  config.vm.box_version = "0.1"
  config.ssh.insert_key = false

  nodeprops = build_nodes(3, "192.168.30.")

  nodeprops[:num_nodes].times do |n|
    node_name = nodeprops[:node_names][n]
    node_addr = nodeprops[:node_ips][n]

    config.vm.define node_name do |node|
      # Control Interface
      node.vm.network :private_network, ip: node_addr
      # Data Interface
      node.vm.network :private_network, ip: "0.0.0.0", virtualbox__intnet: "data_net", auto_config: false

      node.vm.provider "virtualbox" do |v|
          if n < 3
              v.cpus = 2
              v.memory = 3072
          else
              v.cpus = 1
              v.memory = 1024
          end
          v.linked_clone = true # use base image and clone from it. for multi-VM, saves space

          # this makes provisioning faster for yum-install type of stuff with caching
          if Vagrant.has_plugin?("vagrant-cachier")
              # ... vagrant-cachier configs ... makes provisioning faster by caching packages
              config.cache.scope = :machine
          end


          # enable 'virtio' on control nics to take benefit of builtin vlan tag
          # use intel e1000 nics on data NIC so that we can run DPDK on it
          v.customize ['modifyvm', :id, '--nictype1', 'virtio']
          v.customize ['modifyvm', :id, '--nictype2', 'virtio']
          v.customize ['modifyvm', :id, '--nictype3', '82545EM']

          v.customize ['modifyvm', :id, '--nicpromisc2', 'allow-all']
          v.customize ['modifyvm', :id, '--nicpromisc3', 'allow-all']
          v.customize ['modifyvm', :id, '--paravirtprovider', "kvm"]
      end

      node.vm.provision "shell" do |s|
          s.inline = preamble_script <<-EOF
            # Start docker and kubelet services
            systemctl enable docker && systemctl start docker
            systemctl enable kubelet && systemctl start kubelet
            # populate the master virtual ip
            echo '192.168.30.10 pen-master' >> /etc/hosts
          EOF

          s.args = [node_name, node_addr, nodeprops[:cluster_ip_nodes]]
      end

      # mount the host directories
      if File.dirname(__FILE__).include? "src/github.com/pensando/sw"
          node.vm.synced_folder "../../../", File.join("/import", "src"), rsync: true
          node.vm.synced_folder File.join("./", "bin"), File.join("/import", "bin"), rsync: true
      else
          node.vm.synced_folder "../", "/import/src/github.com/pensando/sw", rsync: true
      end

      # populate /etc/hosts entries
      build_etc_hosts(nodeprops, node)

      # populate master hostname
      node.vm.provision "shell" do |s|
        s.inline = "echo '#{nodeprops[:node_ips][0]} master.local' >> /etc/hosts"
      end

      # port mappings
      if n == 0 then
          node.vm.network "forwarded_port", guest: 80, host: 9980, auto_correct: true
      end
    end
  end
end
