#!/usr/bin/python

import os
import datetime
import json
import errno
import subprocess

''' This program creates a tar file of all the necessary containers for running venice.
In addition it also creates a venice.json which has the version info that will be read by
cluster-management-daemon at runtime to determine the list of services that need to be started
in the system '''


# this will be tag for all the dynamic containers generated by this script. Depending on versioning
#  scheme we may take this from some environment variable in the future.
container_tag = "latest"

def ExecuteCommand(cmd):
    print cmd
    return os.system(cmd)

# images which are not compiled every day
static_images = {
    'pen-kube-controller-manager': 'registry.test.pensando.io:5000/google_containers/kube-controller-manager-amd64:v1.7.14',
    'pen-kube-scheduler' : 'registry.test.pensando.io:5000/google_containers/kube-scheduler-amd64:v1.7.14',
    'pen-kube-apiserver' : 'registry.test.pensando.io:5000/google_containers/kube-apiserver-amd64:v1.7.14',
    'pen-etcd' : 'registry.test.pensando.io:5000/coreos/etcd:v3.3.2',
    'pen-filebeat' : 'registry.test.pensando.io:5000/beats/filebeat:6.2.2',
    'pen-ntp' : 'registry.test.pensando.io:5000/pens-ntp:v0.2',
    'pen-influx' : 'registry.test.pensando.io:5000/influxdb:1.4.2',
    'pen-elastic'  : 'registry.test.pensando.io:5000/elasticsearch-cluster:v0.2'
}

# images which are compiled every time
dynamic_images = [
    "cmd", "apiserver", "apigw", "vchub", "npm", "vcsim", "netagent", "nmd", "collector", "tpm", "spyglass", "evtsmgr", "tsm"
]

# dictionary of module name(specified in venice/globals/modules.go )  to containerImage
imageMap = {}

# dictionary of the names used in systemd service files to the moduleNames
# systemd variables have some idiosyncracies. they should not contain '-'.
systemdNameMap = {
    'PEN_CMD' : 'pen-cmd',
    'PEN_KUBE_SCHEDULER' : 'pen-kube-scheduler',
    'PEN_KUBE_APISERVER' : 'pen-kube-apiserver',
    'PEN_KUBE_CONTROLLERMGR' : 'pen-kube-controller-manager',
    'PEN_ETCD': 'pen-etcd'
}

try:
    os.makedirs("bin/tars")
except EnvironmentError, e:
    if e.errno != errno.EEXIST:
        raise

for k, v in static_images.items():
    if subprocess.check_output(["/bin/sh", "-c", "docker images -q " + v]) == "":
        ExecuteCommand("docker pull " + v)
    ExecuteCommand("docker save -o bin/tars/{}.tar {}".format(k, v))
    imageMap[k] = v


for i in dynamic_images:
    ExecuteCommand("docker tag pen-{}:latest pen-{}:{}".format(i, i, container_tag))
    ExecuteCommand("docker save -o bin/tars/pen-{}.tar pen-{}:{}".format(i, i, container_tag))
    imageMap["""pen-{}""".format(i)] = "pen-{}:{}".format(i, container_tag)
    # remove old images to conserve disk space on dev machines
    old_images = subprocess.check_output(["/bin/sh", "-c", '''docker images pen-{} --filter "before=pen-{}:latest" --format {} | sort | uniq '''.format(i, i, '{{.ID}}') ])
    if old_images != "" :
        ExecuteCommand('''docker rmi -f ''' + old_images)

with open("tools/docker-files/install/target/etc/pensando/venice.json", 'w') as f:
    json.dump(imageMap, f, indent=True, sort_keys=True)
with open("tools/docker-files/install/target/etc/pensando/venice.conf", 'w') as f:
    for  k,v in systemdNameMap.items():
        f.write("{}='{}'\n".format(k,imageMap[v]))
