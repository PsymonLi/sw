// Code generated by protoc-gen-go. DO NOT EDIT.
// source: nic/upgrade_manager/upgrade/upgrade.proto

/*
Package upgrade is a generated protocol buffer package.

It is generated from these files:
	nic/upgrade_manager/upgrade/upgrade.proto

It has these top-level messages:
	UpgReq_
	UpgResp_
	UpgStateReq_
	UpgAppResp_
	UpgApp_
*/
package upgrade

import gosdk "github.com/pensando/sw/nic/delphi/gosdk"
import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import delphi "github.com/pensando/sw/nic/delphi/proto/delphi"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type UpgReqType int32

const (
	UpgReqType_InvalidCmd UpgReqType = 0
	UpgReqType_UpgStart   UpgReqType = 1
	UpgReqType_UpgAbort   UpgReqType = 2
)

var UpgReqType_name = map[int32]string{
	0: "InvalidCmd",
	1: "UpgStart",
	2: "UpgAbort",
}
var UpgReqType_value = map[string]int32{
	"InvalidCmd": 0,
	"UpgStart":   1,
	"UpgAbort":   2,
}

func (x UpgReqType) String() string {
	return proto.EnumName(UpgReqType_name, int32(x))
}
func (UpgReqType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type UpgRespType int32

const (
	UpgRespType_UpgRespPass  UpgRespType = 0
	UpgRespType_UpgRespFail  UpgRespType = 1
	UpgRespType_UpgRespAbort UpgRespType = 2
)

var UpgRespType_name = map[int32]string{
	0: "UpgRespPass",
	1: "UpgRespFail",
	2: "UpgRespAbort",
}
var UpgRespType_value = map[string]int32{
	"UpgRespPass":  0,
	"UpgRespFail":  1,
	"UpgRespAbort": 2,
}

func (x UpgRespType) String() string {
	return proto.EnumName(UpgRespType_name, int32(x))
}
func (UpgRespType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

// Upgrade Request Status
type UpgReqStateType int32

const (
	UpgReqStateType_UpgStateCompatCheck             UpgReqStateType = 0
	UpgReqStateType_UpgStateProcessQuiesce          UpgReqStateType = 1
	UpgReqStateType_UpgStatePostBinRestart          UpgReqStateType = 2
	UpgReqStateType_UpgStateDataplaneDowntimePhase1 UpgReqStateType = 3
	UpgReqStateType_UpgStateDataplaneDowntimePhase2 UpgReqStateType = 4
	UpgReqStateType_UpgStateDataplaneDowntimePhase3 UpgReqStateType = 5
	UpgReqStateType_UpgStateDataplaneDowntimePhase4 UpgReqStateType = 6
	UpgReqStateType_UpgStateCleanup                 UpgReqStateType = 7
	UpgReqStateType_UpgStateSuccess                 UpgReqStateType = 8
	UpgReqStateType_UpgStateFailed                  UpgReqStateType = 9
	UpgReqStateType_UpgStateAbort                   UpgReqStateType = 10
	// Always to be last
	UpgReqStateType_UpgStateTerminal UpgReqStateType = 11
)

var UpgReqStateType_name = map[int32]string{
	0:  "UpgStateCompatCheck",
	1:  "UpgStateProcessQuiesce",
	2:  "UpgStatePostBinRestart",
	3:  "UpgStateDataplaneDowntimePhase1",
	4:  "UpgStateDataplaneDowntimePhase2",
	5:  "UpgStateDataplaneDowntimePhase3",
	6:  "UpgStateDataplaneDowntimePhase4",
	7:  "UpgStateCleanup",
	8:  "UpgStateSuccess",
	9:  "UpgStateFailed",
	10: "UpgStateAbort",
	11: "UpgStateTerminal",
}
var UpgReqStateType_value = map[string]int32{
	"UpgStateCompatCheck":             0,
	"UpgStateProcessQuiesce":          1,
	"UpgStatePostBinRestart":          2,
	"UpgStateDataplaneDowntimePhase1": 3,
	"UpgStateDataplaneDowntimePhase2": 4,
	"UpgStateDataplaneDowntimePhase3": 5,
	"UpgStateDataplaneDowntimePhase4": 6,
	"UpgStateCleanup":                 7,
	"UpgStateSuccess":                 8,
	"UpgStateFailed":                  9,
	"UpgStateAbort":                   10,
	"UpgStateTerminal":                11,
}

func (x UpgReqStateType) String() string {
	return proto.EnumName(UpgReqStateType_name, int32(x))
}
func (UpgReqStateType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

// Upgrade State Response Status
type UpgStateRespType int32

const (
	UpgStateRespType_UpgStateCompatCheckRespPass             UpgStateRespType = 0
	UpgStateRespType_UpgStateCompatCheckRespFail             UpgStateRespType = 1
	UpgStateRespType_UpgStateProcessQuiesceRespPass          UpgStateRespType = 2
	UpgStateRespType_UpgStateProcessQuiesceRespFail          UpgStateRespType = 3
	UpgStateRespType_UpgStatePostBinRestartRespPass          UpgStateRespType = 4
	UpgStateRespType_UpgStatePostBinRestartRespFail          UpgStateRespType = 5
	UpgStateRespType_UpgStateDataplaneDowntimePhase1RespPass UpgStateRespType = 6
	UpgStateRespType_UpgStateDataplaneDowntimePhase1RespFail UpgStateRespType = 7
	UpgStateRespType_UpgStateDataplaneDowntimePhase2RespPass UpgStateRespType = 8
	UpgStateRespType_UpgStateDataplaneDowntimePhase2RespFail UpgStateRespType = 9
	UpgStateRespType_UpgStateDataplaneDowntimePhase3RespPass UpgStateRespType = 10
	UpgStateRespType_UpgStateDataplaneDowntimePhase3RespFail UpgStateRespType = 11
	UpgStateRespType_UpgStateDataplaneDowntimePhase4RespPass UpgStateRespType = 12
	UpgStateRespType_UpgStateDataplaneDowntimePhase4RespFail UpgStateRespType = 13
	UpgStateRespType_UpgStateCleanupRespPass                 UpgStateRespType = 14
	UpgStateRespType_UpgStateCleanupRespFail                 UpgStateRespType = 15
	UpgStateRespType_UpgStateSuccessRespPass                 UpgStateRespType = 16
	UpgStateRespType_UpgStateSuccessRespFail                 UpgStateRespType = 17
	UpgStateRespType_UpgStateFailedRespPass                  UpgStateRespType = 18
	UpgStateRespType_UpgStateFailedRespFail                  UpgStateRespType = 19
	UpgStateRespType_UpgStateAbortRespPass                   UpgStateRespType = 20
	UpgStateRespType_UpgStateAbortRespFail                   UpgStateRespType = 21
)

var UpgStateRespType_name = map[int32]string{
	0:  "UpgStateCompatCheckRespPass",
	1:  "UpgStateCompatCheckRespFail",
	2:  "UpgStateProcessQuiesceRespPass",
	3:  "UpgStateProcessQuiesceRespFail",
	4:  "UpgStatePostBinRestartRespPass",
	5:  "UpgStatePostBinRestartRespFail",
	6:  "UpgStateDataplaneDowntimePhase1RespPass",
	7:  "UpgStateDataplaneDowntimePhase1RespFail",
	8:  "UpgStateDataplaneDowntimePhase2RespPass",
	9:  "UpgStateDataplaneDowntimePhase2RespFail",
	10: "UpgStateDataplaneDowntimePhase3RespPass",
	11: "UpgStateDataplaneDowntimePhase3RespFail",
	12: "UpgStateDataplaneDowntimePhase4RespPass",
	13: "UpgStateDataplaneDowntimePhase4RespFail",
	14: "UpgStateCleanupRespPass",
	15: "UpgStateCleanupRespFail",
	16: "UpgStateSuccessRespPass",
	17: "UpgStateSuccessRespFail",
	18: "UpgStateFailedRespPass",
	19: "UpgStateFailedRespFail",
	20: "UpgStateAbortRespPass",
	21: "UpgStateAbortRespFail",
}
var UpgStateRespType_value = map[string]int32{
	"UpgStateCompatCheckRespPass":             0,
	"UpgStateCompatCheckRespFail":             1,
	"UpgStateProcessQuiesceRespPass":          2,
	"UpgStateProcessQuiesceRespFail":          3,
	"UpgStatePostBinRestartRespPass":          4,
	"UpgStatePostBinRestartRespFail":          5,
	"UpgStateDataplaneDowntimePhase1RespPass": 6,
	"UpgStateDataplaneDowntimePhase1RespFail": 7,
	"UpgStateDataplaneDowntimePhase2RespPass": 8,
	"UpgStateDataplaneDowntimePhase2RespFail": 9,
	"UpgStateDataplaneDowntimePhase3RespPass": 10,
	"UpgStateDataplaneDowntimePhase3RespFail": 11,
	"UpgStateDataplaneDowntimePhase4RespPass": 12,
	"UpgStateDataplaneDowntimePhase4RespFail": 13,
	"UpgStateCleanupRespPass":                 14,
	"UpgStateCleanupRespFail":                 15,
	"UpgStateSuccessRespPass":                 16,
	"UpgStateSuccessRespFail":                 17,
	"UpgStateFailedRespPass":                  18,
	"UpgStateFailedRespFail":                  19,
	"UpgStateAbortRespPass":                   20,
	"UpgStateAbortRespFail":                   21,
}

func (x UpgStateRespType) String() string {
	return proto.EnumName(UpgStateRespType_name, int32(x))
}
func (UpgStateRespType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

type UpgType int32

const (
	UpgType_UpgTypeDisruptive    UpgType = 0
	UpgType_UpgTypeNonDisruptive UpgType = 1
)

var UpgType_name = map[int32]string{
	0: "UpgTypeDisruptive",
	1: "UpgTypeNonDisruptive",
}
var UpgType_value = map[string]int32{
	"UpgTypeDisruptive":    0,
	"UpgTypeNonDisruptive": 1,
}

func (x UpgType) String() string {
	return proto.EnumName(UpgType_name, int32(x))
}
func (UpgType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

// spec part of the object
type UpgReq_ struct {
	Meta       *delphi.ObjectMeta `protobuf:"bytes,1,opt,name=Meta" json:"Meta,omitempty"`
	Key        uint32             `protobuf:"varint,2,opt,name=Key" json:"Key,omitempty"`
	UpgReqCmd  UpgReqType         `protobuf:"varint,3,opt,name=UpgReqCmd,enum=upgrade.UpgReqType" json:"UpgReqCmd,omitempty"`
	UpgReqType UpgType            `protobuf:"varint,4,opt,name=UpgReqType,enum=upgrade.UpgType" json:"UpgReqType,omitempty"`
}

func (m *UpgReq_) Reset()                    { *m = UpgReq_{} }
func (m *UpgReq_) String() string            { return proto.CompactTextString(m) }
func (*UpgReq_) ProtoMessage()               {}
func (*UpgReq_) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *UpgReq_) GetMeta() *delphi.ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *UpgReq_) GetKey() uint32 {
	if m != nil {
		return m.Key
	}
	return 0
}

func (m *UpgReq_) GetUpgReqCmd() UpgReqType {
	if m != nil {
		return m.UpgReqCmd
	}
	return UpgReqType_InvalidCmd
}

func (m *UpgReq_) GetUpgReqType() UpgType {
	if m != nil {
		return m.UpgReqType
	}
	return UpgType_UpgTypeDisruptive
}

// status part of the object
type UpgResp_ struct {
	Meta           *delphi.ObjectMeta `protobuf:"bytes,1,opt,name=Meta" json:"Meta,omitempty"`
	Key            uint32             `protobuf:"varint,2,opt,name=Key" json:"Key,omitempty"`
	UpgRespVal     UpgRespType        `protobuf:"varint,3,opt,name=UpgRespVal,enum=upgrade.UpgRespType" json:"UpgRespVal,omitempty"`
	UpgRespFailStr []string           `protobuf:"bytes,4,rep,name=UpgRespFailStr" json:"UpgRespFailStr,omitempty"`
}

func (m *UpgResp_) Reset()                    { *m = UpgResp_{} }
func (m *UpgResp_) String() string            { return proto.CompactTextString(m) }
func (*UpgResp_) ProtoMessage()               {}
func (*UpgResp_) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *UpgResp_) GetMeta() *delphi.ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *UpgResp_) GetKey() uint32 {
	if m != nil {
		return m.Key
	}
	return 0
}

func (m *UpgResp_) GetUpgRespVal() UpgRespType {
	if m != nil {
		return m.UpgRespVal
	}
	return UpgRespType_UpgRespPass
}

func (m *UpgResp_) GetUpgRespFailStr() []string {
	if m != nil {
		return m.UpgRespFailStr
	}
	return nil
}

type UpgStateReq_ struct {
	Meta        *delphi.ObjectMeta `protobuf:"bytes,1,opt,name=Meta" json:"Meta,omitempty"`
	Key         uint32             `protobuf:"varint,2,opt,name=Key" json:"Key,omitempty"`
	UpgReqState UpgReqStateType    `protobuf:"varint,3,opt,name=UpgReqState,enum=upgrade.UpgReqStateType" json:"UpgReqState,omitempty"`
	UpgReqType  UpgType            `protobuf:"varint,4,opt,name=UpgReqType,enum=upgrade.UpgType" json:"UpgReqType,omitempty"`
}

func (m *UpgStateReq_) Reset()                    { *m = UpgStateReq_{} }
func (m *UpgStateReq_) String() string            { return proto.CompactTextString(m) }
func (*UpgStateReq_) ProtoMessage()               {}
func (*UpgStateReq_) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *UpgStateReq_) GetMeta() *delphi.ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *UpgStateReq_) GetKey() uint32 {
	if m != nil {
		return m.Key
	}
	return 0
}

func (m *UpgStateReq_) GetUpgReqState() UpgReqStateType {
	if m != nil {
		return m.UpgReqState
	}
	return UpgReqStateType_UpgStateCompatCheck
}

func (m *UpgStateReq_) GetUpgReqType() UpgType {
	if m != nil {
		return m.UpgReqType
	}
	return UpgType_UpgTypeDisruptive
}

type UpgAppResp_ struct {
	Meta          *delphi.ObjectMeta `protobuf:"bytes,1,opt,name=Meta" json:"Meta,omitempty"`
	Key           string             `protobuf:"bytes,2,opt,name=Key" json:"Key,omitempty"`
	UpgAppRespVal UpgStateRespType   `protobuf:"varint,3,opt,name=UpgAppRespVal,enum=upgrade.UpgStateRespType" json:"UpgAppRespVal,omitempty"`
	UpgAppRespStr string             `protobuf:"bytes,4,opt,name=UpgAppRespStr" json:"UpgAppRespStr,omitempty"`
}

func (m *UpgAppResp_) Reset()                    { *m = UpgAppResp_{} }
func (m *UpgAppResp_) String() string            { return proto.CompactTextString(m) }
func (*UpgAppResp_) ProtoMessage()               {}
func (*UpgAppResp_) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *UpgAppResp_) GetMeta() *delphi.ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *UpgAppResp_) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *UpgAppResp_) GetUpgAppRespVal() UpgStateRespType {
	if m != nil {
		return m.UpgAppRespVal
	}
	return UpgStateRespType_UpgStateCompatCheckRespPass
}

func (m *UpgAppResp_) GetUpgAppRespStr() string {
	if m != nil {
		return m.UpgAppRespStr
	}
	return ""
}

type UpgApp_ struct {
	Meta *delphi.ObjectMeta `protobuf:"bytes,1,opt,name=Meta" json:"Meta,omitempty"`
	Key  string             `protobuf:"bytes,2,opt,name=Key" json:"Key,omitempty"`
}

func (m *UpgApp_) Reset()                    { *m = UpgApp_{} }
func (m *UpgApp_) String() string            { return proto.CompactTextString(m) }
func (*UpgApp_) ProtoMessage()               {}
func (*UpgApp_) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *UpgApp_) GetMeta() *delphi.ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *UpgApp_) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

type delphiWrapper interface {
	bubbleSave()
}

type UpgStateReq struct {
	sdkClient   gosdk.Client
	parent      delphiWrapper
	meta        *delphi.ObjectMeta
	key         uint32
	upgReqState UpgReqStateType
	upgReqType  UpgType
}

func (o *UpgStateReq) GetMeta() *delphi.ObjectMeta {
	return o.meta
}

func (o *UpgStateReq) SetMeta(val *delphi.ObjectMeta) {
	o.meta = val
	o.bubbleSave()
}

func (o *UpgStateReq) GetKey() uint32 {
	return o.key
}

func (o *UpgStateReq) SetKey(val uint32) {
	o.key = val
	o.bubbleSave()
}

func (o *UpgStateReq) GetUpgReqState() UpgReqStateType {
	return o.upgReqState
}

func (o *UpgStateReq) SetUpgReqState(val UpgReqStateType) {
	o.upgReqState = val
	o.bubbleSave()
}

func (o *UpgStateReq) GetUpgReqType() UpgType {
	return o.upgReqType
}

func (o *UpgStateReq) SetUpgReqType(val UpgType) {
	o.upgReqType = val
	o.bubbleSave()
}

func (o *UpgStateReq) bubbleSave() {
	if o.parent != nil {
		o.parent.bubbleSave()
	} else {
		o.save()
	}
}

func (o *UpgStateReq) save() {
	if o.GetKeyString() != "" {
		o.sdkClient.SetObject(o)
	}
}

func (o *UpgStateReq) Delete() {
	o.sdkClient.DeleteObject(o)
}

func NewUpgStateReq(sdkClient gosdk.Client) *UpgStateReq {
	w := &UpgStateReq{}
	w.sdkClient = sdkClient
	w.meta = &delphi.ObjectMeta{
		Kind: "UpgStateReq",
	}
	return w
}

func NewUpgStateReqWithKey(sdkClient gosdk.Client, key uint32) *UpgStateReq {
	w := NewUpgStateReq(sdkClient)
	w.SetKey(key)
	return w
}

func GetUpgStateReq(sdkClient gosdk.Client, key uint32) *UpgStateReq {
	lookupKey := fmt.Sprintf("%v", key)
	b := sdkClient.GetObject("UpgStateReq", lookupKey)
	if b == nil {
		return nil
	}
	o, ok := b.(*UpgStateReq)
	if !ok {
		panic("Couldn't cast to UpgStateReq")
	}
	return o
}

func childNewUpgStateReq(parent delphiWrapper, sdkClient gosdk.Client) *UpgStateReq {
	w := NewUpgStateReq(sdkClient)
	w.parent = parent
	return w
}

func childNewUpgStateReqWithValue(parent delphiWrapper, sdkClient gosdk.Client, value *UpgStateReq) *UpgStateReq {
	w := childNewUpgStateReq(parent, sdkClient)
	w.key = value.key
	w.upgReqState = value.upgReqState
	w.upgReqType = value.upgReqType
	return w
}

func (o *UpgStateReq) GetProtoMsg() *UpgStateReq_ {
	return &UpgStateReq_{
		Meta:        o.meta,
		Key:         o.key,
		UpgReqState: o.upgReqState,
		UpgReqType:  o.upgReqType,
	}
}

func (o *UpgStateReq) GetMessage() proto.Message {
	return o.GetProtoMsg()
}

func (obj *UpgStateReq) GetKeyString() string {
	return fmt.Sprintf("%v", (obj.key))
}

func (obj *UpgStateReq) TriggerEvent(oldObj gosdk.BaseObject, op delphi.ObjectOperation, rl []gosdk.BaseReactor) {
	for _, r := range rl {
		rctr, ok := r.(UpgStateReqReactor)
		if ok == false {
			panic("Not a Reactor")
		}
		if op == delphi.ObjectOperation_SetOp {
			if oldObj == nil {
				rctr.OnUpgStateReqCreate(obj)
			} else {
				rctr.OnUpgStateReqUpdate(obj)
			}
		} else {
			rctr.OnUpgStateReqDelete(obj)
		}
	}
}

type UpgStateReqReactor interface {
	OnUpgStateReqCreate(obj *UpgStateReq)
	OnUpgStateReqUpdate(obj *UpgStateReq)
	OnUpgStateReqDelete(obj *UpgStateReq)
}

func (obj *UpgStateReq) GetPath() string {
	return "UpgStateReq" + "|" + obj.GetKeyString()
}

func newUpgStateReqFromMessage(msg *UpgStateReq_) *UpgStateReq {
	return &UpgStateReq{
		meta:        msg.Meta,
		key:         msg.Key,
		upgReqState: msg.UpgReqState,
		upgReqType:  msg.UpgReqType,
	}
}

func upgStateReqFactory(sdkClient gosdk.Client, data []byte) (gosdk.BaseObject, error) {
	var msg UpgStateReq_
	err := proto.Unmarshal(data, &msg)
	if err != nil {
		return nil, err
	}
	w := newUpgStateReqFromMessage(&msg)
	w.sdkClient = sdkClient
	return w, nil
}

func UpgStateReqMount(client gosdk.Client, mode delphi.MountMode) {
	client.MountKind("UpgStateReq", mode)
}

func UpgStateReqMountKey(client gosdk.Client, key uint32, mode delphi.MountMode) {
	keyString := fmt.Sprintf("%v", key)
	client.MountKindKey("UpgStateReq", keyString, mode)
}

func UpgStateReqWatch(client gosdk.Client, reactor UpgStateReqReactor) {
	client.WatchKind("UpgStateReq", reactor)
}

type UpgStateReqIterator struct {
	objects []gosdk.BaseObject
	cur     int
}

func (i *UpgStateReqIterator) Next() *UpgStateReq {
	if i.cur >= len(i.objects) {
		return nil
	}
	obj, ok := i.objects[i.cur].(*UpgStateReq)
	if !ok {
		panic("Cast error")
	}
	i.cur++
	return obj
}

func UpgStateReqList(client gosdk.Client) *UpgStateReqIterator {
	return &UpgStateReqIterator{
		objects: client.List("UpgStateReq"),
		cur:     0,
	}
}

type UpgAppResp struct {
	sdkClient     gosdk.Client
	parent        delphiWrapper
	meta          *delphi.ObjectMeta
	key           string
	upgAppRespVal UpgStateRespType
	upgAppRespStr string
}

func (o *UpgAppResp) GetMeta() *delphi.ObjectMeta {
	return o.meta
}

func (o *UpgAppResp) SetMeta(val *delphi.ObjectMeta) {
	o.meta = val
	o.bubbleSave()
}

func (o *UpgAppResp) GetKey() string {
	return o.key
}

func (o *UpgAppResp) SetKey(val string) {
	o.key = val
	o.bubbleSave()
}

func (o *UpgAppResp) GetUpgAppRespVal() UpgStateRespType {
	return o.upgAppRespVal
}

func (o *UpgAppResp) SetUpgAppRespVal(val UpgStateRespType) {
	o.upgAppRespVal = val
	o.bubbleSave()
}

func (o *UpgAppResp) GetUpgAppRespStr() string {
	return o.upgAppRespStr
}

func (o *UpgAppResp) SetUpgAppRespStr(val string) {
	o.upgAppRespStr = val
	o.bubbleSave()
}

func (o *UpgAppResp) bubbleSave() {
	if o.parent != nil {
		o.parent.bubbleSave()
	} else {
		o.save()
	}
}

func (o *UpgAppResp) save() {
	if o.GetKeyString() != "" {
		o.sdkClient.SetObject(o)
	}
}

func (o *UpgAppResp) Delete() {
	o.sdkClient.DeleteObject(o)
}

func NewUpgAppResp(sdkClient gosdk.Client) *UpgAppResp {
	w := &UpgAppResp{}
	w.sdkClient = sdkClient
	w.meta = &delphi.ObjectMeta{
		Kind: "UpgAppResp",
	}
	return w
}

func NewUpgAppRespWithKey(sdkClient gosdk.Client, key string) *UpgAppResp {
	w := NewUpgAppResp(sdkClient)
	w.SetKey(key)
	return w
}

func GetUpgAppResp(sdkClient gosdk.Client, key string) *UpgAppResp {
	lookupKey := fmt.Sprintf("%v", key)
	b := sdkClient.GetObject("UpgAppResp", lookupKey)
	if b == nil {
		return nil
	}
	o, ok := b.(*UpgAppResp)
	if !ok {
		panic("Couldn't cast to UpgAppResp")
	}
	return o
}

func childNewUpgAppResp(parent delphiWrapper, sdkClient gosdk.Client) *UpgAppResp {
	w := NewUpgAppResp(sdkClient)
	w.parent = parent
	return w
}

func childNewUpgAppRespWithValue(parent delphiWrapper, sdkClient gosdk.Client, value *UpgAppResp) *UpgAppResp {
	w := childNewUpgAppResp(parent, sdkClient)
	w.key = value.key
	w.upgAppRespVal = value.upgAppRespVal
	w.upgAppRespStr = value.upgAppRespStr
	return w
}

func (o *UpgAppResp) GetProtoMsg() *UpgAppResp_ {
	return &UpgAppResp_{
		Meta:          o.meta,
		Key:           o.key,
		UpgAppRespVal: o.upgAppRespVal,
		UpgAppRespStr: o.upgAppRespStr,
	}
}

func (o *UpgAppResp) GetMessage() proto.Message {
	return o.GetProtoMsg()
}

func (obj *UpgAppResp) GetKeyString() string {
	return fmt.Sprintf("%v", (obj.key))
}

func (obj *UpgAppResp) TriggerEvent(oldObj gosdk.BaseObject, op delphi.ObjectOperation, rl []gosdk.BaseReactor) {
	for _, r := range rl {
		rctr, ok := r.(UpgAppRespReactor)
		if ok == false {
			panic("Not a Reactor")
		}
		if op == delphi.ObjectOperation_SetOp {
			if oldObj == nil {
				rctr.OnUpgAppRespCreate(obj)
			} else {
				rctr.OnUpgAppRespUpdate(obj)
			}
		} else {
			rctr.OnUpgAppRespDelete(obj)
		}
	}
}

type UpgAppRespReactor interface {
	OnUpgAppRespCreate(obj *UpgAppResp)
	OnUpgAppRespUpdate(obj *UpgAppResp)
	OnUpgAppRespDelete(obj *UpgAppResp)
}

func (obj *UpgAppResp) GetPath() string {
	return "UpgAppResp" + "|" + obj.GetKeyString()
}

func newUpgAppRespFromMessage(msg *UpgAppResp_) *UpgAppResp {
	return &UpgAppResp{
		meta:          msg.Meta,
		key:           msg.Key,
		upgAppRespVal: msg.UpgAppRespVal,
		upgAppRespStr: msg.UpgAppRespStr,
	}
}

func upgAppRespFactory(sdkClient gosdk.Client, data []byte) (gosdk.BaseObject, error) {
	var msg UpgAppResp_
	err := proto.Unmarshal(data, &msg)
	if err != nil {
		return nil, err
	}
	w := newUpgAppRespFromMessage(&msg)
	w.sdkClient = sdkClient
	return w, nil
}

func UpgAppRespMount(client gosdk.Client, mode delphi.MountMode) {
	client.MountKind("UpgAppResp", mode)
}

func UpgAppRespMountKey(client gosdk.Client, key string, mode delphi.MountMode) {
	keyString := fmt.Sprintf("%v", key)
	client.MountKindKey("UpgAppResp", keyString, mode)
}

func UpgAppRespWatch(client gosdk.Client, reactor UpgAppRespReactor) {
	client.WatchKind("UpgAppResp", reactor)
}

type UpgAppRespIterator struct {
	objects []gosdk.BaseObject
	cur     int
}

func (i *UpgAppRespIterator) Next() *UpgAppResp {
	if i.cur >= len(i.objects) {
		return nil
	}
	obj, ok := i.objects[i.cur].(*UpgAppResp)
	if !ok {
		panic("Cast error")
	}
	i.cur++
	return obj
}

func UpgAppRespList(client gosdk.Client) *UpgAppRespIterator {
	return &UpgAppRespIterator{
		objects: client.List("UpgAppResp"),
		cur:     0,
	}
}

type UpgApp struct {
	sdkClient gosdk.Client
	parent    delphiWrapper
	meta      *delphi.ObjectMeta
	key       string
}

func (o *UpgApp) GetMeta() *delphi.ObjectMeta {
	return o.meta
}

func (o *UpgApp) SetMeta(val *delphi.ObjectMeta) {
	o.meta = val
	o.bubbleSave()
}

func (o *UpgApp) GetKey() string {
	return o.key
}

func (o *UpgApp) SetKey(val string) {
	o.key = val
	o.bubbleSave()
}

func (o *UpgApp) bubbleSave() {
	if o.parent != nil {
		o.parent.bubbleSave()
	} else {
		o.save()
	}
}

func (o *UpgApp) save() {
	if o.GetKeyString() != "" {
		o.sdkClient.SetObject(o)
	}
}

func (o *UpgApp) Delete() {
	o.sdkClient.DeleteObject(o)
}

func NewUpgApp(sdkClient gosdk.Client) *UpgApp {
	w := &UpgApp{}
	w.sdkClient = sdkClient
	w.meta = &delphi.ObjectMeta{
		Kind: "UpgApp",
	}
	return w
}

func NewUpgAppWithKey(sdkClient gosdk.Client, key string) *UpgApp {
	w := NewUpgApp(sdkClient)
	w.SetKey(key)
	return w
}

func GetUpgApp(sdkClient gosdk.Client, key string) *UpgApp {
	lookupKey := fmt.Sprintf("%v", key)
	b := sdkClient.GetObject("UpgApp", lookupKey)
	if b == nil {
		return nil
	}
	o, ok := b.(*UpgApp)
	if !ok {
		panic("Couldn't cast to UpgApp")
	}
	return o
}

func childNewUpgApp(parent delphiWrapper, sdkClient gosdk.Client) *UpgApp {
	w := NewUpgApp(sdkClient)
	w.parent = parent
	return w
}

func childNewUpgAppWithValue(parent delphiWrapper, sdkClient gosdk.Client, value *UpgApp) *UpgApp {
	w := childNewUpgApp(parent, sdkClient)
	w.key = value.key
	return w
}

func (o *UpgApp) GetProtoMsg() *UpgApp_ {
	return &UpgApp_{
		Meta: o.meta,
		Key:  o.key,
	}
}

func (o *UpgApp) GetMessage() proto.Message {
	return o.GetProtoMsg()
}

func (obj *UpgApp) GetKeyString() string {
	return fmt.Sprintf("%v", (obj.key))
}

func (obj *UpgApp) TriggerEvent(oldObj gosdk.BaseObject, op delphi.ObjectOperation, rl []gosdk.BaseReactor) {
	for _, r := range rl {
		rctr, ok := r.(UpgAppReactor)
		if ok == false {
			panic("Not a Reactor")
		}
		if op == delphi.ObjectOperation_SetOp {
			if oldObj == nil {
				rctr.OnUpgAppCreate(obj)
			} else {
				rctr.OnUpgAppUpdate(obj)
			}
		} else {
			rctr.OnUpgAppDelete(obj)
		}
	}
}

type UpgAppReactor interface {
	OnUpgAppCreate(obj *UpgApp)
	OnUpgAppUpdate(obj *UpgApp)
	OnUpgAppDelete(obj *UpgApp)
}

func (obj *UpgApp) GetPath() string {
	return "UpgApp" + "|" + obj.GetKeyString()
}

func newUpgAppFromMessage(msg *UpgApp_) *UpgApp {
	return &UpgApp{
		meta: msg.Meta,
		key:  msg.Key,
	}
}

func upgAppFactory(sdkClient gosdk.Client, data []byte) (gosdk.BaseObject, error) {
	var msg UpgApp_
	err := proto.Unmarshal(data, &msg)
	if err != nil {
		return nil, err
	}
	w := newUpgAppFromMessage(&msg)
	w.sdkClient = sdkClient
	return w, nil
}

func UpgAppMount(client gosdk.Client, mode delphi.MountMode) {
	client.MountKind("UpgApp", mode)
}

func UpgAppMountKey(client gosdk.Client, key string, mode delphi.MountMode) {
	keyString := fmt.Sprintf("%v", key)
	client.MountKindKey("UpgApp", keyString, mode)
}

func UpgAppWatch(client gosdk.Client, reactor UpgAppReactor) {
	client.WatchKind("UpgApp", reactor)
}

type UpgAppIterator struct {
	objects []gosdk.BaseObject
	cur     int
}

func (i *UpgAppIterator) Next() *UpgApp {
	if i.cur >= len(i.objects) {
		return nil
	}
	obj, ok := i.objects[i.cur].(*UpgApp)
	if !ok {
		panic("Cast error")
	}
	i.cur++
	return obj
}

func UpgAppList(client gosdk.Client) *UpgAppIterator {
	return &UpgAppIterator{
		objects: client.List("UpgApp"),
		cur:     0,
	}
}

type UpgReq struct {
	sdkClient  gosdk.Client
	parent     delphiWrapper
	meta       *delphi.ObjectMeta
	key        uint32
	upgReqCmd  UpgReqType
	upgReqType UpgType
}

func (o *UpgReq) GetMeta() *delphi.ObjectMeta {
	return o.meta
}

func (o *UpgReq) SetMeta(val *delphi.ObjectMeta) {
	o.meta = val
	o.bubbleSave()
}

func (o *UpgReq) GetKey() uint32 {
	return o.key
}

func (o *UpgReq) SetKey(val uint32) {
	o.key = val
	o.bubbleSave()
}

func (o *UpgReq) GetUpgReqCmd() UpgReqType {
	return o.upgReqCmd
}

func (o *UpgReq) SetUpgReqCmd(val UpgReqType) {
	o.upgReqCmd = val
	o.bubbleSave()
}

func (o *UpgReq) GetUpgReqType() UpgType {
	return o.upgReqType
}

func (o *UpgReq) SetUpgReqType(val UpgType) {
	o.upgReqType = val
	o.bubbleSave()
}

func (o *UpgReq) bubbleSave() {
	if o.parent != nil {
		o.parent.bubbleSave()
	} else {
		o.save()
	}
}

func (o *UpgReq) save() {
	if o.GetKeyString() != "" {
		o.sdkClient.SetObject(o)
	}
}

func (o *UpgReq) Delete() {
	o.sdkClient.DeleteObject(o)
}

func NewUpgReq(sdkClient gosdk.Client) *UpgReq {
	w := &UpgReq{}
	w.sdkClient = sdkClient
	w.meta = &delphi.ObjectMeta{
		Kind: "UpgReq",
	}
	return w
}

func NewUpgReqWithKey(sdkClient gosdk.Client, key uint32) *UpgReq {
	w := NewUpgReq(sdkClient)
	w.SetKey(key)
	return w
}

func GetUpgReq(sdkClient gosdk.Client, key uint32) *UpgReq {
	lookupKey := fmt.Sprintf("%v", key)
	b := sdkClient.GetObject("UpgReq", lookupKey)
	if b == nil {
		return nil
	}
	o, ok := b.(*UpgReq)
	if !ok {
		panic("Couldn't cast to UpgReq")
	}
	return o
}

func childNewUpgReq(parent delphiWrapper, sdkClient gosdk.Client) *UpgReq {
	w := NewUpgReq(sdkClient)
	w.parent = parent
	return w
}

func childNewUpgReqWithValue(parent delphiWrapper, sdkClient gosdk.Client, value *UpgReq) *UpgReq {
	w := childNewUpgReq(parent, sdkClient)
	w.key = value.key
	w.upgReqCmd = value.upgReqCmd
	w.upgReqType = value.upgReqType
	return w
}

func (o *UpgReq) GetProtoMsg() *UpgReq_ {
	return &UpgReq_{
		Meta:       o.meta,
		Key:        o.key,
		UpgReqCmd:  o.upgReqCmd,
		UpgReqType: o.upgReqType,
	}
}

func (o *UpgReq) GetMessage() proto.Message {
	return o.GetProtoMsg()
}

func (obj *UpgReq) GetKeyString() string {
	return fmt.Sprintf("%v", (obj.key))
}

func (obj *UpgReq) TriggerEvent(oldObj gosdk.BaseObject, op delphi.ObjectOperation, rl []gosdk.BaseReactor) {
	for _, r := range rl {
		rctr, ok := r.(UpgReqReactor)
		if ok == false {
			panic("Not a Reactor")
		}
		if op == delphi.ObjectOperation_SetOp {
			if oldObj == nil {
				rctr.OnUpgReqCreate(obj)
			} else {
				rctr.OnUpgReqUpdate(obj)
			}
		} else {
			rctr.OnUpgReqDelete(obj)
		}
	}
}

type UpgReqReactor interface {
	OnUpgReqCreate(obj *UpgReq)
	OnUpgReqUpdate(obj *UpgReq)
	OnUpgReqDelete(obj *UpgReq)
}

func (obj *UpgReq) GetPath() string {
	return "UpgReq" + "|" + obj.GetKeyString()
}

func newUpgReqFromMessage(msg *UpgReq_) *UpgReq {
	return &UpgReq{
		meta:       msg.Meta,
		key:        msg.Key,
		upgReqCmd:  msg.UpgReqCmd,
		upgReqType: msg.UpgReqType,
	}
}

func upgReqFactory(sdkClient gosdk.Client, data []byte) (gosdk.BaseObject, error) {
	var msg UpgReq_
	err := proto.Unmarshal(data, &msg)
	if err != nil {
		return nil, err
	}
	w := newUpgReqFromMessage(&msg)
	w.sdkClient = sdkClient
	return w, nil
}

func UpgReqMount(client gosdk.Client, mode delphi.MountMode) {
	client.MountKind("UpgReq", mode)
}

func UpgReqMountKey(client gosdk.Client, key uint32, mode delphi.MountMode) {
	keyString := fmt.Sprintf("%v", key)
	client.MountKindKey("UpgReq", keyString, mode)
}

func UpgReqWatch(client gosdk.Client, reactor UpgReqReactor) {
	client.WatchKind("UpgReq", reactor)
}

type UpgReqIterator struct {
	objects []gosdk.BaseObject
	cur     int
}

func (i *UpgReqIterator) Next() *UpgReq {
	if i.cur >= len(i.objects) {
		return nil
	}
	obj, ok := i.objects[i.cur].(*UpgReq)
	if !ok {
		panic("Cast error")
	}
	i.cur++
	return obj
}

func UpgReqList(client gosdk.Client) *UpgReqIterator {
	return &UpgReqIterator{
		objects: client.List("UpgReq"),
		cur:     0,
	}
}

type UpgResp struct {
	sdkClient      gosdk.Client
	parent         delphiWrapper
	meta           *delphi.ObjectMeta
	key            uint32
	upgRespVal     UpgRespType
	upgRespFailStr *StringArray
}

func (o *UpgResp) GetMeta() *delphi.ObjectMeta {
	return o.meta
}

func (o *UpgResp) SetMeta(val *delphi.ObjectMeta) {
	o.meta = val
	o.bubbleSave()
}

func (o *UpgResp) GetKey() uint32 {
	return o.key
}

func (o *UpgResp) SetKey(val uint32) {
	o.key = val
	o.bubbleSave()
}

func (o *UpgResp) GetUpgRespVal() UpgRespType {
	return o.upgRespVal
}

func (o *UpgResp) SetUpgRespVal(val UpgRespType) {
	o.upgRespVal = val
	o.bubbleSave()
}

func (o *UpgResp) GetUpgRespFailStr() *StringArray {
	return o.upgRespFailStr
}

func (o *UpgResp) bubbleSave() {
	if o.parent != nil {
		o.parent.bubbleSave()
	} else {
		o.save()
	}
}

func (o *UpgResp) save() {
	if o.GetKeyString() != "" {
		o.sdkClient.SetObject(o)
	}
}

func (o *UpgResp) Delete() {
	o.sdkClient.DeleteObject(o)
}

func NewUpgResp(sdkClient gosdk.Client) *UpgResp {
	w := &UpgResp{}
	w.sdkClient = sdkClient
	w.meta = &delphi.ObjectMeta{
		Kind: "UpgResp",
	}
	w.upgRespFailStr = childNewStringArray(w, sdkClient)
	return w
}

func NewUpgRespWithKey(sdkClient gosdk.Client, key uint32) *UpgResp {
	w := NewUpgResp(sdkClient)
	w.SetKey(key)
	return w
}

func GetUpgResp(sdkClient gosdk.Client, key uint32) *UpgResp {
	lookupKey := fmt.Sprintf("%v", key)
	b := sdkClient.GetObject("UpgResp", lookupKey)
	if b == nil {
		return nil
	}
	o, ok := b.(*UpgResp)
	if !ok {
		panic("Couldn't cast to UpgResp")
	}
	return o
}

func childNewUpgResp(parent delphiWrapper, sdkClient gosdk.Client) *UpgResp {
	w := NewUpgResp(sdkClient)
	w.parent = parent
	return w
}

func childNewUpgRespWithValue(parent delphiWrapper, sdkClient gosdk.Client, value *UpgResp) *UpgResp {
	w := childNewUpgResp(parent, sdkClient)
	w.key = value.key
	w.upgRespVal = value.upgRespVal
	w.upgRespFailStr = childNewStringArrayWithValue(w, sdkClient, value.upgRespFailStr)
	return w
}

func (o *UpgResp) GetProtoMsg() *UpgResp_ {
	return &UpgResp_{
		Meta:           o.meta,
		Key:            o.key,
		UpgRespVal:     o.upgRespVal,
		UpgRespFailStr: o.upgRespFailStr.GetProtoMsg(),
	}
}

func (o *UpgResp) GetMessage() proto.Message {
	return o.GetProtoMsg()
}

func (obj *UpgResp) GetKeyString() string {
	return fmt.Sprintf("%v", (obj.key))
}

func (obj *UpgResp) TriggerEvent(oldObj gosdk.BaseObject, op delphi.ObjectOperation, rl []gosdk.BaseReactor) {
	for _, r := range rl {
		rctr, ok := r.(UpgRespReactor)
		if ok == false {
			panic("Not a Reactor")
		}
		if op == delphi.ObjectOperation_SetOp {
			if oldObj == nil {
				rctr.OnUpgRespCreate(obj)
			} else {
				rctr.OnUpgRespUpdate(obj)
			}
		} else {
			rctr.OnUpgRespDelete(obj)
		}
	}
}

type UpgRespReactor interface {
	OnUpgRespCreate(obj *UpgResp)
	OnUpgRespUpdate(obj *UpgResp)
	OnUpgRespDelete(obj *UpgResp)
}

func (obj *UpgResp) GetPath() string {
	return "UpgResp" + "|" + obj.GetKeyString()
}

func newUpgRespFromMessage(msg *UpgResp_) *UpgResp {
	return &UpgResp{
		meta:           msg.Meta,
		key:            msg.Key,
		upgRespVal:     msg.UpgRespVal,
		upgRespFailStr: newStringArrayFromMessage(msg.UpgRespFailStr),
	}
}

func upgRespFactory(sdkClient gosdk.Client, data []byte) (gosdk.BaseObject, error) {
	var msg UpgResp_
	err := proto.Unmarshal(data, &msg)
	if err != nil {
		return nil, err
	}
	w := newUpgRespFromMessage(&msg)
	w.sdkClient = sdkClient
	return w, nil
}

func UpgRespMount(client gosdk.Client, mode delphi.MountMode) {
	client.MountKind("UpgResp", mode)
}

func UpgRespMountKey(client gosdk.Client, key uint32, mode delphi.MountMode) {
	keyString := fmt.Sprintf("%v", key)
	client.MountKindKey("UpgResp", keyString, mode)
}

func UpgRespWatch(client gosdk.Client, reactor UpgRespReactor) {
	client.WatchKind("UpgResp", reactor)
}

type UpgRespIterator struct {
	objects []gosdk.BaseObject
	cur     int
}

func (i *UpgRespIterator) Next() *UpgResp {
	if i.cur >= len(i.objects) {
		return nil
	}
	obj, ok := i.objects[i.cur].(*UpgResp)
	if !ok {
		panic("Cast error")
	}
	i.cur++
	return obj
}

func UpgRespList(client gosdk.Client) *UpgRespIterator {
	return &UpgRespIterator{
		objects: client.List("UpgResp"),
		cur:     0,
	}
}

type StringArray struct {
	parent delphiWrapper
	values []string
}

func (arr *StringArray) Append(value string) {
	arr.values = append(arr.values, value)
	arr.parent.bubbleSave()
}

func (arr *StringArray) Get(pos int) string {
	return arr.values[pos]
}

func (arr *StringArray) Length() int {
	return len(arr.values)
}

func newStringArrayFromMessage(msg []string) *StringArray {
	arr := new(StringArray)
	arr.values = make([]string, len(msg))
	copy(arr.values, msg)
	return arr
}

func childNewStringArray(parent delphiWrapper, sdkClient gosdk.Client) *StringArray {
	arr := new(StringArray)
	arr.values = make([]string, 0)
	arr.parent = parent
	return arr
}

func childNewStringArrayWithValue(parent delphiWrapper, sdkClient gosdk.Client, value *StringArray) *StringArray {
	arr := childNewStringArray(parent, sdkClient)
	for _, v := range value.values {
		arr.values = append(arr.values, v)
	}
	return arr
}

func (arr *StringArray) GetProtoMsg() []string {
	v := make([]string, len(arr.values))
	copy(v, arr.values)
	return v
}

func init() {
	proto.RegisterType((*UpgReq_)(nil), "upgrade.UpgReq_")
	proto.RegisterType((*UpgResp_)(nil), "upgrade.UpgResp_")
	proto.RegisterType((*UpgStateReq_)(nil), "upgrade.UpgStateReq_")
	proto.RegisterType((*UpgAppResp_)(nil), "upgrade.UpgAppResp_")
	proto.RegisterType((*UpgApp_)(nil), "upgrade.UpgApp_")
	gosdk.RegisterFactory("UpgStateReq", upgStateReqFactory)
	gosdk.RegisterFactory("UpgAppResp", upgAppRespFactory)
	gosdk.RegisterFactory("UpgApp", upgAppFactory)
	gosdk.RegisterFactory("UpgReq", upgReqFactory)
	gosdk.RegisterFactory("UpgResp", upgRespFactory)
	proto.RegisterEnum("upgrade.UpgReqType", UpgReqType_name, UpgReqType_value)
	proto.RegisterEnum("upgrade.UpgRespType", UpgRespType_name, UpgRespType_value)
	proto.RegisterEnum("upgrade.UpgReqStateType", UpgReqStateType_name, UpgReqStateType_value)
	proto.RegisterEnum("upgrade.UpgStateRespType", UpgStateRespType_name, UpgStateRespType_value)
	proto.RegisterEnum("upgrade.UpgType", UpgType_name, UpgType_value)
}

func init() { proto.RegisterFile("nic/upgrade_manager/upgrade/upgrade.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 718 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x56, 0xdf, 0x4e, 0x1a, 0x4d,
	0x14, 0x67, 0x01, 0x41, 0x0e, 0x8a, 0xe3, 0x80, 0x9f, 0xa8, 0xc9, 0x27, 0xe1, 0x33, 0x7e, 0x94,
	0x26, 0x9a, 0xa2, 0x69, 0x1b, 0xaf, 0x8a, 0xd8, 0x26, 0xa6, 0x69, 0x6b, 0x41, 0x7b, 0x6b, 0x46,
	0x98, 0xe0, 0xb6, 0xb0, 0x3b, 0xdd, 0x1d, 0x6c, 0xbc, 0xeb, 0x5b, 0xf4, 0x2d, 0x7c, 0x00, 0x9f,
	0xa0, 0x2f, 0xd1, 0x77, 0x69, 0xf6, 0xec, 0xec, 0x32, 0x4b, 0xd1, 0x25, 0xe5, 0x0a, 0xe6, 0xfc,
	0xfe, 0xf8, 0x9b, 0x73, 0xce, 0x18, 0xe0, 0x89, 0x65, 0x76, 0xf7, 0x47, 0xa2, 0xef, 0xb0, 0x1e,
	0xbf, 0x1c, 0x32, 0x8b, 0xf5, 0xb9, 0x13, 0x9c, 0x83, 0xcf, 0x3d, 0xe1, 0xd8, 0xd2, 0xa6, 0x59,
	0x75, 0xdc, 0xdc, 0xf1, 0x34, 0x3d, 0x3e, 0x10, 0xd7, 0xe6, 0x3e, 0x42, 0xc1, 0xc1, 0xff, 0xf0,
	0xe9, 0xd5, 0x7b, 0x03, 0xb2, 0x17, 0xa2, 0xdf, 0xe6, 0x5f, 0x2f, 0xe9, 0x2e, 0xa4, 0xdf, 0x71,
	0xc9, 0xca, 0x46, 0xc5, 0xa8, 0xe5, 0x1b, 0x74, 0x4f, 0x11, 0x3f, 0x5c, 0x7d, 0xe6, 0x5d, 0xe9,
	0x21, 0x6d, 0xc4, 0x29, 0x81, 0xd4, 0x5b, 0x7e, 0x5b, 0x4e, 0x56, 0x8c, 0xda, 0x72, 0xdb, 0xfb,
	0x4a, 0x5f, 0x40, 0xce, 0x37, 0x69, 0x0d, 0x7b, 0xe5, 0x54, 0xc5, 0xa8, 0x15, 0x1a, 0xc5, 0xbd,
	0x20, 0x97, 0x8f, 0x9c, 0xdf, 0x0a, 0x7e, 0x9c, 0xfe, 0xfe, 0xa3, 0x6a, 0xb4, 0xc7, 0x5c, 0xfa,
	0x1c, 0x60, 0x0c, 0x97, 0xd3, 0xa8, 0x24, 0xba, 0x52, 0x93, 0x69, 0xcc, 0x23, 0xac, 0x54, 0xef,
	0x0c, 0x58, 0xc4, 0xa2, 0x2b, 0xe6, 0x49, 0x7f, 0xa4, 0x42, 0xb8, 0xe2, 0x13, 0x1b, 0xa8, 0xf8,
	0xa5, 0x68, 0x7c, 0x57, 0xfc, 0x11, 0x04, 0xd9, 0x74, 0x17, 0x0a, 0xea, 0xf4, 0x86, 0x99, 0x83,
	0x8e, 0x74, 0xca, 0xe9, 0x4a, 0xaa, 0x96, 0x6b, 0x4f, 0x54, 0x55, 0xe0, 0x9f, 0x06, 0x2c, 0x5d,
	0x88, 0x7e, 0x47, 0x32, 0xc9, 0xe7, 0x6c, 0xf9, 0x2b, 0xc8, 0xfb, 0xfd, 0x40, 0x33, 0x95, 0xba,
	0x3c, 0xd1, 0x74, 0xc4, 0xb4, 0xe4, 0xba, 0x64, 0xce, 0xde, 0xdf, 0x1b, 0x18, 0xa0, 0x29, 0xc4,
	0x5f, 0xb7, 0x3f, 0xe7, 0xdf, 0xe4, 0x35, 0x2c, 0x8f, 0x8d, 0xc6, 0x13, 0xd8, 0xd0, 0xa3, 0xa8,
	0x8e, 0x45, 0xc6, 0x10, 0x55, 0xd1, 0x1d, 0xdd, 0xc6, 0x1f, 0x84, 0xf7, 0x27, 0xa2, 0x45, 0x15,
	0xfe, 0x14, 0x97, 0xbe, 0x29, 0xe6, 0xc9, 0xed, 0x5b, 0xd5, 0x5f, 0xea, 0x5d, 0xa4, 0x05, 0x80,
	0x53, 0xeb, 0x86, 0x0d, 0xcc, 0x5e, 0x6b, 0xd8, 0x23, 0x09, 0xba, 0x84, 0x0b, 0xda, 0x91, 0xcc,
	0x91, 0xc4, 0x50, 0xa7, 0xe6, 0x95, 0xed, 0x48, 0x92, 0xac, 0x37, 0xd5, 0x04, 0xfd, 0x4b, 0xd1,
	0x95, 0xf0, 0x78, 0xc6, 0x5c, 0x97, 0x24, 0xb4, 0x82, 0xb7, 0x44, 0xc4, 0xa0, 0x04, 0x97, 0xc7,
	0x2b, 0x04, 0x16, 0xbf, 0x92, 0xb0, 0x32, 0x31, 0x69, 0xba, 0x0e, 0xc5, 0xa0, 0x61, 0x2d, 0x7b,
	0x28, 0x98, 0x6c, 0x5d, 0xf3, 0xee, 0x17, 0x92, 0xa0, 0x9b, 0xf0, 0x4f, 0x00, 0x9c, 0x39, 0x76,
	0x97, 0xbb, 0xee, 0xc7, 0x91, 0xc9, 0xdd, 0x2e, 0x27, 0x46, 0x04, 0xb3, 0x5d, 0x79, 0x6c, 0x5a,
	0x6d, 0xee, 0x62, 0xea, 0x24, 0xfd, 0x0f, 0xb6, 0x03, 0xec, 0x84, 0x49, 0x26, 0x06, 0xcc, 0xe2,
	0x27, 0xf6, 0x37, 0x4b, 0x9a, 0x43, 0x7e, 0x76, 0xcd, 0x5c, 0xfe, 0x8c, 0xa4, 0xe2, 0x49, 0x0d,
	0x92, 0x8e, 0x27, 0x1d, 0x90, 0x85, 0x78, 0xd2, 0x21, 0xc9, 0xd0, 0x22, 0xde, 0xdb, 0xbf, 0xe4,
	0x80, 0x33, 0x6b, 0x24, 0x48, 0x56, 0x2f, 0x76, 0x46, 0x5d, 0xef, 0x82, 0x64, 0x91, 0x52, 0x7c,
	0xa0, 0x58, 0xf4, 0xda, 0xc8, 0x7b, 0x24, 0x47, 0x57, 0x71, 0x55, 0xb0, 0xe6, 0x77, 0x12, 0x68,
	0x09, 0x48, 0x50, 0x3a, 0xe7, 0xce, 0xd0, 0xb4, 0xd8, 0x80, 0xe4, 0xeb, 0x77, 0x99, 0x71, 0x39,
	0x1c, 0xd4, 0x36, 0x6c, 0x4d, 0x69, 0xb0, 0x36, 0xb8, 0x87, 0x09, 0x6a, 0x90, 0x55, 0xf8, 0x77,
	0xfa, 0x24, 0x42, 0x93, 0xe4, 0xe3, 0x1c, 0xf4, 0x49, 0x45, 0x38, 0x91, 0xa9, 0x85, 0x3e, 0xe9,
	0xc7, 0x39, 0xe8, 0xb3, 0x40, 0x9f, 0xc2, 0xff, 0x31, 0x13, 0x0e, 0x0d, 0x33, 0x33, 0x92, 0xd1,
	0x39, 0x1b, 0x4f, 0x6e, 0x84, 0xce, 0x8b, 0x33, 0x92, 0xd1, 0x39, 0x17, 0x4f, 0x3e, 0x08, 0x9d,
	0x61, 0x46, 0x32, 0x3a, 0xe7, 0xe3, 0xc9, 0x87, 0xa1, 0xf3, 0xd2, 0x8c, 0x64, 0x74, 0x5e, 0xa6,
	0x5b, 0xb0, 0x3e, 0xb1, 0xb5, 0xa1, 0x53, 0xe1, 0x01, 0x10, 0x95, 0x2b, 0x3a, 0xa8, 0x56, 0x3b,
	0x54, 0x92, 0x07, 0x40, 0x54, 0xae, 0xea, 0x2f, 0xdb, 0xdf, 0xff, 0x50, 0x48, 0xa7, 0x63, 0xa8,
	0x2b, 0xd2, 0x0d, 0x58, 0x8b, 0xbc, 0x91, 0x50, 0x56, 0x9a, 0x0a, 0xa1, 0x6a, 0xad, 0x7e, 0x84,
	0xff, 0x58, 0xf1, 0x99, 0xac, 0xc1, 0xaa, 0xfa, 0x7a, 0x62, 0xba, 0xce, 0x48, 0x48, 0xf3, 0x86,
	0x93, 0x04, 0x2d, 0x43, 0x49, 0x95, 0xdf, 0xdb, 0x96, 0x86, 0x18, 0x57, 0x19, 0xfc, 0x45, 0x72,
	0xf0, 0x3b, 0x00, 0x00, 0xff, 0xff, 0xfd, 0x54, 0xc2, 0xb4, 0xed, 0x08, 0x00, 0x00,
}
