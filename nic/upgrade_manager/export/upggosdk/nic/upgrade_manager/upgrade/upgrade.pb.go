// Code generated by protoc-gen-go. DO NOT EDIT.
// source: nic/upgrade_manager/upgrade/upgrade.proto

/*
Package upgrade is a generated protocol buffer package.

It is generated from these files:
	nic/upgrade_manager/upgrade/upgrade.proto

It has these top-level messages:
	UpgReq_
	UpgResp_
	UpgStateReq_
	UpgAppResp_
	UpgApp_
	UpgradeMetrics_
*/
package upgrade

import clientApi "github.com/pensando/sw/nic/delphi/gosdk/client_api"
import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import delphi "github.com/pensando/sw/nic/delphi/proto/delphi"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type UpgReqType int32

const (
	UpgReqType_InvalidCmd    UpgReqType = 0
	UpgReqType_UpgStart      UpgReqType = 1
	UpgReqType_UpgAbort      UpgReqType = 2
	UpgReqType_IsUpgPossible UpgReqType = 3
)

var UpgReqType_name = map[int32]string{
	0: "InvalidCmd",
	1: "UpgStart",
	2: "UpgAbort",
	3: "IsUpgPossible",
}
var UpgReqType_value = map[string]int32{
	"InvalidCmd":    0,
	"UpgStart":      1,
	"UpgAbort":      2,
	"IsUpgPossible": 3,
}

func (x UpgReqType) String() string {
	return proto.EnumName(UpgReqType_name, int32(x))
}
func (UpgReqType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type UpgRespType int32

const (
	UpgRespType_UpgRespPass        UpgRespType = 0
	UpgRespType_UpgRespFail        UpgRespType = 1
	UpgRespType_UpgRespAbort       UpgRespType = 2
	UpgRespType_UpgRespUpgPossible UpgRespType = 3
)

var UpgRespType_name = map[int32]string{
	0: "UpgRespPass",
	1: "UpgRespFail",
	2: "UpgRespAbort",
	3: "UpgRespUpgPossible",
}
var UpgRespType_value = map[string]int32{
	"UpgRespPass":        0,
	"UpgRespFail":        1,
	"UpgRespAbort":       2,
	"UpgRespUpgPossible": 3,
}

func (x UpgRespType) String() string {
	return proto.EnumName(UpgRespType_name, int32(x))
}
func (UpgRespType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

// Upgrade Request Status
type UpgReqStateType int32

const (
	UpgReqStateType_UpgStateCompatCheck             UpgReqStateType = 0
	UpgReqStateType_UpgStateProcessQuiesce          UpgReqStateType = 1
	UpgReqStateType_UpgStatePostBinRestart          UpgReqStateType = 2
	UpgReqStateType_UpgStateDataplaneDowntimePhase1 UpgReqStateType = 3
	UpgReqStateType_UpgStateDataplaneDowntimePhase2 UpgReqStateType = 4
	UpgReqStateType_UpgStateDataplaneDowntimePhase3 UpgReqStateType = 5
	UpgReqStateType_UpgStateDataplaneDowntimePhase4 UpgReqStateType = 6
	UpgReqStateType_UpgStateCleanup                 UpgReqStateType = 7
	UpgReqStateType_UpgStateSuccess                 UpgReqStateType = 8
	UpgReqStateType_UpgStateFailed                  UpgReqStateType = 9
	UpgReqStateType_UpgStateAbort                   UpgReqStateType = 10
	UpgReqStateType_UpgStateUpgPossible             UpgReqStateType = 11
	UpgReqStateType_UpgStateLinkDown                UpgReqStateType = 12
	UpgReqStateType_UpgStateLinkUp                  UpgReqStateType = 13
	UpgReqStateType_UpgStateDataplaneDowntimeStart  UpgReqStateType = 14
	UpgReqStateType_UpgStateIsSystemReady           UpgReqStateType = 15
	// Always to be last
	UpgReqStateType_UpgStateTerminal UpgReqStateType = 16
)

var UpgReqStateType_name = map[int32]string{
	0:  "UpgStateCompatCheck",
	1:  "UpgStateProcessQuiesce",
	2:  "UpgStatePostBinRestart",
	3:  "UpgStateDataplaneDowntimePhase1",
	4:  "UpgStateDataplaneDowntimePhase2",
	5:  "UpgStateDataplaneDowntimePhase3",
	6:  "UpgStateDataplaneDowntimePhase4",
	7:  "UpgStateCleanup",
	8:  "UpgStateSuccess",
	9:  "UpgStateFailed",
	10: "UpgStateAbort",
	11: "UpgStateUpgPossible",
	12: "UpgStateLinkDown",
	13: "UpgStateLinkUp",
	14: "UpgStateDataplaneDowntimeStart",
	15: "UpgStateIsSystemReady",
	16: "UpgStateTerminal",
}
var UpgReqStateType_value = map[string]int32{
	"UpgStateCompatCheck":             0,
	"UpgStateProcessQuiesce":          1,
	"UpgStatePostBinRestart":          2,
	"UpgStateDataplaneDowntimePhase1": 3,
	"UpgStateDataplaneDowntimePhase2": 4,
	"UpgStateDataplaneDowntimePhase3": 5,
	"UpgStateDataplaneDowntimePhase4": 6,
	"UpgStateCleanup":                 7,
	"UpgStateSuccess":                 8,
	"UpgStateFailed":                  9,
	"UpgStateAbort":                   10,
	"UpgStateUpgPossible":             11,
	"UpgStateLinkDown":                12,
	"UpgStateLinkUp":                  13,
	"UpgStateDataplaneDowntimeStart":  14,
	"UpgStateIsSystemReady":           15,
	"UpgStateTerminal":                16,
}

func (x UpgReqStateType) String() string {
	return proto.EnumName(UpgReqStateType_name, int32(x))
}
func (UpgReqStateType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

// Upgrade State Response Status
type UpgStateRespType int32

const (
	UpgStateRespType_UpgStateCompatCheckRespPass             UpgStateRespType = 0
	UpgStateRespType_UpgStateCompatCheckRespFail             UpgStateRespType = 1
	UpgStateRespType_UpgStateProcessQuiesceRespPass          UpgStateRespType = 2
	UpgStateRespType_UpgStateProcessQuiesceRespFail          UpgStateRespType = 3
	UpgStateRespType_UpgStatePostBinRestartRespPass          UpgStateRespType = 4
	UpgStateRespType_UpgStatePostBinRestartRespFail          UpgStateRespType = 5
	UpgStateRespType_UpgStateDataplaneDowntimePhase1RespPass UpgStateRespType = 6
	UpgStateRespType_UpgStateDataplaneDowntimePhase1RespFail UpgStateRespType = 7
	UpgStateRespType_UpgStateDataplaneDowntimePhase2RespPass UpgStateRespType = 8
	UpgStateRespType_UpgStateDataplaneDowntimePhase2RespFail UpgStateRespType = 9
	UpgStateRespType_UpgStateDataplaneDowntimePhase3RespPass UpgStateRespType = 10
	UpgStateRespType_UpgStateDataplaneDowntimePhase3RespFail UpgStateRespType = 11
	UpgStateRespType_UpgStateDataplaneDowntimePhase4RespPass UpgStateRespType = 12
	UpgStateRespType_UpgStateDataplaneDowntimePhase4RespFail UpgStateRespType = 13
	UpgStateRespType_UpgStateCleanupRespPass                 UpgStateRespType = 14
	UpgStateRespType_UpgStateCleanupRespFail                 UpgStateRespType = 15
	UpgStateRespType_UpgStateSuccessRespPass                 UpgStateRespType = 16
	UpgStateRespType_UpgStateSuccessRespFail                 UpgStateRespType = 17
	UpgStateRespType_UpgStateFailedRespPass                  UpgStateRespType = 18
	UpgStateRespType_UpgStateFailedRespFail                  UpgStateRespType = 19
	UpgStateRespType_UpgStateAbortRespPass                   UpgStateRespType = 20
	UpgStateRespType_UpgStateAbortRespFail                   UpgStateRespType = 21
	UpgStateRespType_UpgStateUpgPossibleRespPass             UpgStateRespType = 22
	UpgStateRespType_UpgStateUpgPossibleRespFail             UpgStateRespType = 23
	UpgStateRespType_UpgStateLinkDownRespPass                UpgStateRespType = 24
	UpgStateRespType_UpgStateLinkDownRespFail                UpgStateRespType = 25
	UpgStateRespType_UpgStateLinkUpRespPass                  UpgStateRespType = 26
	UpgStateRespType_UpgStateLinkUpRespFail                  UpgStateRespType = 27
	UpgStateRespType_UpgStateDataplaneDowntimeStartRespPass  UpgStateRespType = 28
	UpgStateRespType_UpgStateDataplaneDowntimeStartRespFail  UpgStateRespType = 29
	UpgStateRespType_UpgStateIsSystemReadyRespPass           UpgStateRespType = 30
	UpgStateRespType_UpgStateIsSystemReadyRespFail           UpgStateRespType = 31
)

var UpgStateRespType_name = map[int32]string{
	0:  "UpgStateCompatCheckRespPass",
	1:  "UpgStateCompatCheckRespFail",
	2:  "UpgStateProcessQuiesceRespPass",
	3:  "UpgStateProcessQuiesceRespFail",
	4:  "UpgStatePostBinRestartRespPass",
	5:  "UpgStatePostBinRestartRespFail",
	6:  "UpgStateDataplaneDowntimePhase1RespPass",
	7:  "UpgStateDataplaneDowntimePhase1RespFail",
	8:  "UpgStateDataplaneDowntimePhase2RespPass",
	9:  "UpgStateDataplaneDowntimePhase2RespFail",
	10: "UpgStateDataplaneDowntimePhase3RespPass",
	11: "UpgStateDataplaneDowntimePhase3RespFail",
	12: "UpgStateDataplaneDowntimePhase4RespPass",
	13: "UpgStateDataplaneDowntimePhase4RespFail",
	14: "UpgStateCleanupRespPass",
	15: "UpgStateCleanupRespFail",
	16: "UpgStateSuccessRespPass",
	17: "UpgStateSuccessRespFail",
	18: "UpgStateFailedRespPass",
	19: "UpgStateFailedRespFail",
	20: "UpgStateAbortRespPass",
	21: "UpgStateAbortRespFail",
	22: "UpgStateUpgPossibleRespPass",
	23: "UpgStateUpgPossibleRespFail",
	24: "UpgStateLinkDownRespPass",
	25: "UpgStateLinkDownRespFail",
	26: "UpgStateLinkUpRespPass",
	27: "UpgStateLinkUpRespFail",
	28: "UpgStateDataplaneDowntimeStartRespPass",
	29: "UpgStateDataplaneDowntimeStartRespFail",
	30: "UpgStateIsSystemReadyRespPass",
	31: "UpgStateIsSystemReadyRespFail",
}
var UpgStateRespType_value = map[string]int32{
	"UpgStateCompatCheckRespPass":             0,
	"UpgStateCompatCheckRespFail":             1,
	"UpgStateProcessQuiesceRespPass":          2,
	"UpgStateProcessQuiesceRespFail":          3,
	"UpgStatePostBinRestartRespPass":          4,
	"UpgStatePostBinRestartRespFail":          5,
	"UpgStateDataplaneDowntimePhase1RespPass": 6,
	"UpgStateDataplaneDowntimePhase1RespFail": 7,
	"UpgStateDataplaneDowntimePhase2RespPass": 8,
	"UpgStateDataplaneDowntimePhase2RespFail": 9,
	"UpgStateDataplaneDowntimePhase3RespPass": 10,
	"UpgStateDataplaneDowntimePhase3RespFail": 11,
	"UpgStateDataplaneDowntimePhase4RespPass": 12,
	"UpgStateDataplaneDowntimePhase4RespFail": 13,
	"UpgStateCleanupRespPass":                 14,
	"UpgStateCleanupRespFail":                 15,
	"UpgStateSuccessRespPass":                 16,
	"UpgStateSuccessRespFail":                 17,
	"UpgStateFailedRespPass":                  18,
	"UpgStateFailedRespFail":                  19,
	"UpgStateAbortRespPass":                   20,
	"UpgStateAbortRespFail":                   21,
	"UpgStateUpgPossibleRespPass":             22,
	"UpgStateUpgPossibleRespFail":             23,
	"UpgStateLinkDownRespPass":                24,
	"UpgStateLinkDownRespFail":                25,
	"UpgStateLinkUpRespPass":                  26,
	"UpgStateLinkUpRespFail":                  27,
	"UpgStateDataplaneDowntimeStartRespPass":  28,
	"UpgStateDataplaneDowntimeStartRespFail":  29,
	"UpgStateIsSystemReadyRespPass":           30,
	"UpgStateIsSystemReadyRespFail":           31,
}

func (x UpgStateRespType) String() string {
	return proto.EnumName(UpgStateRespType_name, int32(x))
}
func (UpgStateRespType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

type UpgType int32

const (
	UpgType_UpgTypeDisruptive    UpgType = 0
	UpgType_UpgTypeNonDisruptive UpgType = 1
)

var UpgType_name = map[int32]string{
	0: "UpgTypeDisruptive",
	1: "UpgTypeNonDisruptive",
}
var UpgType_value = map[string]int32{
	"UpgTypeDisruptive":    0,
	"UpgTypeNonDisruptive": 1,
}

func (x UpgType) String() string {
	return proto.EnumName(UpgType_name, int32(x))
}
func (UpgType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

// spec part of the object
type UpgReq_ struct {
	Meta       *delphi.ObjectMeta `protobuf:"bytes,1,opt,name=Meta" json:"Meta,omitempty"`
	UpgReqCmd  UpgReqType         `protobuf:"varint,2,opt,name=UpgReqCmd,enum=upgrade.UpgReqType" json:"UpgReqCmd,omitempty"`
	UpgReqType UpgType            `protobuf:"varint,3,opt,name=UpgReqType,enum=upgrade.UpgType" json:"UpgReqType,omitempty"`
}

func (m *UpgReq_) Reset()                    { *m = UpgReq_{} }
func (m *UpgReq_) String() string            { return proto.CompactTextString(m) }
func (*UpgReq_) ProtoMessage()               {}
func (*UpgReq_) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *UpgReq_) GetMeta() *delphi.ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *UpgReq_) GetUpgReqCmd() UpgReqType {
	if m != nil {
		return m.UpgReqCmd
	}
	return UpgReqType_InvalidCmd
}

func (m *UpgReq_) GetUpgReqType() UpgType {
	if m != nil {
		return m.UpgReqType
	}
	return UpgType_UpgTypeDisruptive
}

// status part of the object
type UpgResp_ struct {
	Meta           *delphi.ObjectMeta `protobuf:"bytes,1,opt,name=Meta" json:"Meta,omitempty"`
	UpgRespVal     UpgRespType        `protobuf:"varint,2,opt,name=UpgRespVal,enum=upgrade.UpgRespType" json:"UpgRespVal,omitempty"`
	UpgRespFailStr []string           `protobuf:"bytes,3,rep,name=UpgRespFailStr" json:"UpgRespFailStr,omitempty"`
}

func (m *UpgResp_) Reset()                    { *m = UpgResp_{} }
func (m *UpgResp_) String() string            { return proto.CompactTextString(m) }
func (*UpgResp_) ProtoMessage()               {}
func (*UpgResp_) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *UpgResp_) GetMeta() *delphi.ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *UpgResp_) GetUpgRespVal() UpgRespType {
	if m != nil {
		return m.UpgRespVal
	}
	return UpgRespType_UpgRespPass
}

func (m *UpgResp_) GetUpgRespFailStr() []string {
	if m != nil {
		return m.UpgRespFailStr
	}
	return nil
}

type UpgStateReq_ struct {
	Meta        *delphi.ObjectMeta `protobuf:"bytes,1,opt,name=Meta" json:"Meta,omitempty"`
	UpgReqState UpgReqStateType    `protobuf:"varint,2,opt,name=UpgReqState,enum=upgrade.UpgReqStateType" json:"UpgReqState,omitempty"`
	UpgReqType  UpgType            `protobuf:"varint,3,opt,name=UpgReqType,enum=upgrade.UpgType" json:"UpgReqType,omitempty"`
}

func (m *UpgStateReq_) Reset()                    { *m = UpgStateReq_{} }
func (m *UpgStateReq_) String() string            { return proto.CompactTextString(m) }
func (*UpgStateReq_) ProtoMessage()               {}
func (*UpgStateReq_) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *UpgStateReq_) GetMeta() *delphi.ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *UpgStateReq_) GetUpgReqState() UpgReqStateType {
	if m != nil {
		return m.UpgReqState
	}
	return UpgReqStateType_UpgStateCompatCheck
}

func (m *UpgStateReq_) GetUpgReqType() UpgType {
	if m != nil {
		return m.UpgReqType
	}
	return UpgType_UpgTypeDisruptive
}

type UpgAppResp_ struct {
	Meta          *delphi.ObjectMeta `protobuf:"bytes,1,opt,name=Meta" json:"Meta,omitempty"`
	Key           string             `protobuf:"bytes,2,opt,name=Key" json:"Key,omitempty"`
	UpgAppRespVal UpgStateRespType   `protobuf:"varint,3,opt,name=UpgAppRespVal,enum=upgrade.UpgStateRespType" json:"UpgAppRespVal,omitempty"`
	UpgAppRespStr string             `protobuf:"bytes,4,opt,name=UpgAppRespStr" json:"UpgAppRespStr,omitempty"`
}

func (m *UpgAppResp_) Reset()                    { *m = UpgAppResp_{} }
func (m *UpgAppResp_) String() string            { return proto.CompactTextString(m) }
func (*UpgAppResp_) ProtoMessage()               {}
func (*UpgAppResp_) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *UpgAppResp_) GetMeta() *delphi.ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *UpgAppResp_) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *UpgAppResp_) GetUpgAppRespVal() UpgStateRespType {
	if m != nil {
		return m.UpgAppRespVal
	}
	return UpgStateRespType_UpgStateCompatCheckRespPass
}

func (m *UpgAppResp_) GetUpgAppRespStr() string {
	if m != nil {
		return m.UpgAppRespStr
	}
	return ""
}

type UpgApp_ struct {
	Meta *delphi.ObjectMeta `protobuf:"bytes,1,opt,name=Meta" json:"Meta,omitempty"`
	Key  string             `protobuf:"bytes,2,opt,name=Key" json:"Key,omitempty"`
}

func (m *UpgApp_) Reset()                    { *m = UpgApp_{} }
func (m *UpgApp_) String() string            { return proto.CompactTextString(m) }
func (*UpgApp_) ProtoMessage()               {}
func (*UpgApp_) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *UpgApp_) GetMeta() *delphi.ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *UpgApp_) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

type UpgradeMetrics_ struct {
	Meta             *delphi.ObjectMeta `protobuf:"bytes,1,opt,name=Meta" json:"Meta,omitempty"`
	Key              uint32             `protobuf:"varint,2,opt,name=Key" json:"Key,omitempty"`
	IsUpgPossible    *delphi.Counter    `protobuf:"bytes,3,opt,name=IsUpgPossible" json:"IsUpgPossible,omitempty"`
	DisruptiveUpg    *delphi.Counter    `protobuf:"bytes,4,opt,name=DisruptiveUpg" json:"DisruptiveUpg,omitempty"`
	NonDisruptiveUpg *delphi.Counter    `protobuf:"bytes,5,opt,name=NonDisruptiveUpg" json:"NonDisruptiveUpg,omitempty"`
	SuccessfulUpg    *delphi.Counter    `protobuf:"bytes,6,opt,name=SuccessfulUpg" json:"SuccessfulUpg,omitempty"`
	FailedUpg        *delphi.Counter    `protobuf:"bytes,7,opt,name=FailedUpg" json:"FailedUpg,omitempty"`
	AbortedUpg       *delphi.Counter    `protobuf:"bytes,8,opt,name=AbortedUpg" json:"AbortedUpg,omitempty"`
	NumRegApps       *delphi.Gauge      `protobuf:"bytes,9,opt,name=NumRegApps" json:"NumRegApps,omitempty"`
	UpgPossible      *delphi.Counter    `protobuf:"bytes,10,opt,name=UpgPossible" json:"UpgPossible,omitempty"`
	UpgNotPossible   *delphi.Counter    `protobuf:"bytes,11,opt,name=UpgNotPossible" json:"UpgNotPossible,omitempty"`
}

func (m *UpgradeMetrics_) Reset()                    { *m = UpgradeMetrics_{} }
func (m *UpgradeMetrics_) String() string            { return proto.CompactTextString(m) }
func (*UpgradeMetrics_) ProtoMessage()               {}
func (*UpgradeMetrics_) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *UpgradeMetrics_) GetMeta() *delphi.ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *UpgradeMetrics_) GetKey() uint32 {
	if m != nil {
		return m.Key
	}
	return 0
}

func (m *UpgradeMetrics_) GetIsUpgPossible() *delphi.Counter {
	if m != nil {
		return m.IsUpgPossible
	}
	return nil
}

func (m *UpgradeMetrics_) GetDisruptiveUpg() *delphi.Counter {
	if m != nil {
		return m.DisruptiveUpg
	}
	return nil
}

func (m *UpgradeMetrics_) GetNonDisruptiveUpg() *delphi.Counter {
	if m != nil {
		return m.NonDisruptiveUpg
	}
	return nil
}

func (m *UpgradeMetrics_) GetSuccessfulUpg() *delphi.Counter {
	if m != nil {
		return m.SuccessfulUpg
	}
	return nil
}

func (m *UpgradeMetrics_) GetFailedUpg() *delphi.Counter {
	if m != nil {
		return m.FailedUpg
	}
	return nil
}

func (m *UpgradeMetrics_) GetAbortedUpg() *delphi.Counter {
	if m != nil {
		return m.AbortedUpg
	}
	return nil
}

func (m *UpgradeMetrics_) GetNumRegApps() *delphi.Gauge {
	if m != nil {
		return m.NumRegApps
	}
	return nil
}

func (m *UpgradeMetrics_) GetUpgPossible() *delphi.Counter {
	if m != nil {
		return m.UpgPossible
	}
	return nil
}

func (m *UpgradeMetrics_) GetUpgNotPossible() *delphi.Counter {
	if m != nil {
		return m.UpgNotPossible
	}
	return nil
}

type delphiWrapper interface {
	bubbleSave()
}

type UpgApp struct {
	sdkClient clientApi.Client
	parent    delphiWrapper
	meta      *delphi.ObjectMeta
	key       string
}

func (o *UpgApp) GetMeta() *delphi.ObjectMeta {
	return o.meta
}

func (o *UpgApp) SetMeta(val *delphi.ObjectMeta) {
	o.meta = val
	o.bubbleSave()
}

func (o *UpgApp) GetKey() string {
	return o.key
}

func (o *UpgApp) SetKey(val string) {
	o.key = val
	o.bubbleSave()
}

func (o *UpgApp) bubbleSave() {
	if o.parent != nil {
		o.parent.bubbleSave()
	} else {
		o.save()
	}
}

func (o *UpgApp) save() {
	if o.GetKeyString() != "" {
		o.sdkClient.SetObject(o)
	}
}

func (o *UpgApp) Delete() {
	o.sdkClient.DeleteObject(o)
}

func NewUpgApp(sdkClient clientApi.Client) *UpgApp {
	w := &UpgApp{}
	w.sdkClient = sdkClient
	w.meta = &delphi.ObjectMeta{
		Kind: "UpgApp",
	}
	return w
}

func NewUpgAppWithKey(sdkClient clientApi.Client, key string) *UpgApp {
	w := NewUpgApp(sdkClient)
	w.SetKey(key)
	return w
}

func GetUpgApp(sdkClient clientApi.Client, key string) *UpgApp {
	lookupKey := fmt.Sprintf("%v", key)
	b := sdkClient.GetObject("UpgApp", lookupKey)
	if b == nil {
		return nil
	}
	o, ok := b.(*UpgApp)
	if !ok {
		panic("Couldn't cast to UpgApp")
	}
	return o
}

func childNewUpgApp(parent delphiWrapper, sdkClient clientApi.Client) *UpgApp {
	w := NewUpgApp(sdkClient)
	w.parent = parent
	return w
}

func childNewUpgAppWithValue(parent delphiWrapper, sdkClient clientApi.Client, value *UpgApp) *UpgApp {
	w := childNewUpgApp(parent, sdkClient)
	w.key = value.key
	return w
}

func (o *UpgApp) GetProtoMsg() *UpgApp_ {
	return &UpgApp_{
		Meta: o.meta,
		Key:  o.key,
	}
}

func (o *UpgApp) GetMessage() proto.Message {
	return o.GetProtoMsg()
}

func (obj *UpgApp) GetKeyString() string {
	return fmt.Sprintf("%v", (obj.key))
}

func (obj *UpgApp) TriggerEvent(oldObj clientApi.BaseObject, op delphi.ObjectOperation, rl []clientApi.BaseReactor) {
	for _, r := range rl {
		rctr, ok := r.(UpgAppReactor)
		if ok == false {
			panic("Not a Reactor")
		}
		if op == delphi.ObjectOperation_SetOp {
			if oldObj == nil {
				rctr.OnUpgAppCreate(obj)
			} else {
				rctr.OnUpgAppUpdate(obj)
			}
		} else {
			rctr.OnUpgAppDelete(obj)
		}
	}
}

type UpgAppReactor interface {
	OnUpgAppCreate(obj *UpgApp)
	OnUpgAppUpdate(obj *UpgApp)
	OnUpgAppDelete(obj *UpgApp)
}

func (obj *UpgApp) GetPath() string {
	return "UpgApp" + "|" + obj.GetKeyString()
}

func newUpgAppFromMessage(msg *UpgApp_) *UpgApp {
	return &UpgApp{
		meta: msg.Meta,
		key:  msg.Key,
	}
}

func upgAppFactory(sdkClient clientApi.Client, data []byte) (clientApi.BaseObject, error) {
	var msg UpgApp_
	err := proto.Unmarshal(data, &msg)
	if err != nil {
		return nil, err
	}
	w := newUpgAppFromMessage(&msg)
	w.sdkClient = sdkClient
	return w, nil
}

func UpgAppMount(client clientApi.Client, mode delphi.MountMode) {
	client.MountKind("UpgApp", mode)
}

func UpgAppMountKey(client clientApi.Client, key string, mode delphi.MountMode) {
	keyString := fmt.Sprintf("%v", key)
	client.MountKindKey("UpgApp", keyString, mode)
}

func UpgAppWatch(client clientApi.Client, reactor UpgAppReactor) {
	client.WatchKind("UpgApp", reactor)
}

type UpgAppIterator struct {
	objects []clientApi.BaseObject
	cur     int
}

func (i *UpgAppIterator) Next() *UpgApp {
	if i.cur >= len(i.objects) {
		return nil
	}
	obj, ok := i.objects[i.cur].(*UpgApp)
	if !ok {
		panic("Cast error")
	}
	i.cur++
	return obj
}

func UpgAppList(client clientApi.Client) *UpgAppIterator {
	return &UpgAppIterator{
		objects: client.List("UpgApp"),
		cur:     0,
	}
}

type UpgradeMetrics struct {
	sdkClient        clientApi.Client
	parent           delphiWrapper
	meta             *delphi.ObjectMeta
	key              uint32
	isUpgPossible    *delphi.Counter
	disruptiveUpg    *delphi.Counter
	nonDisruptiveUpg *delphi.Counter
	successfulUpg    *delphi.Counter
	failedUpg        *delphi.Counter
	abortedUpg       *delphi.Counter
	numRegApps       *delphi.Gauge
	upgPossible      *delphi.Counter
	upgNotPossible   *delphi.Counter
}

func (o *UpgradeMetrics) GetMeta() *delphi.ObjectMeta {
	return o.meta
}

func (o *UpgradeMetrics) SetMeta(val *delphi.ObjectMeta) {
	o.meta = val
	o.bubbleSave()
}

func (o *UpgradeMetrics) GetKey() uint32 {
	return o.key
}

func (o *UpgradeMetrics) SetKey(val uint32) {
	o.key = val
	o.bubbleSave()
}

func (o *UpgradeMetrics) GetIsUpgPossible() *delphi.Counter {
	return o.isUpgPossible
}

func (o *UpgradeMetrics) SetIsUpgPossible(val *delphi.Counter) {
	o.isUpgPossible = val
	o.bubbleSave()
}

func (o *UpgradeMetrics) GetDisruptiveUpg() *delphi.Counter {
	return o.disruptiveUpg
}

func (o *UpgradeMetrics) SetDisruptiveUpg(val *delphi.Counter) {
	o.disruptiveUpg = val
	o.bubbleSave()
}

func (o *UpgradeMetrics) GetNonDisruptiveUpg() *delphi.Counter {
	return o.nonDisruptiveUpg
}

func (o *UpgradeMetrics) SetNonDisruptiveUpg(val *delphi.Counter) {
	o.nonDisruptiveUpg = val
	o.bubbleSave()
}

func (o *UpgradeMetrics) GetSuccessfulUpg() *delphi.Counter {
	return o.successfulUpg
}

func (o *UpgradeMetrics) SetSuccessfulUpg(val *delphi.Counter) {
	o.successfulUpg = val
	o.bubbleSave()
}

func (o *UpgradeMetrics) GetFailedUpg() *delphi.Counter {
	return o.failedUpg
}

func (o *UpgradeMetrics) SetFailedUpg(val *delphi.Counter) {
	o.failedUpg = val
	o.bubbleSave()
}

func (o *UpgradeMetrics) GetAbortedUpg() *delphi.Counter {
	return o.abortedUpg
}

func (o *UpgradeMetrics) SetAbortedUpg(val *delphi.Counter) {
	o.abortedUpg = val
	o.bubbleSave()
}

func (o *UpgradeMetrics) GetNumRegApps() *delphi.Gauge {
	return o.numRegApps
}

func (o *UpgradeMetrics) SetNumRegApps(val *delphi.Gauge) {
	o.numRegApps = val
	o.bubbleSave()
}

func (o *UpgradeMetrics) GetUpgPossible() *delphi.Counter {
	return o.upgPossible
}

func (o *UpgradeMetrics) SetUpgPossible(val *delphi.Counter) {
	o.upgPossible = val
	o.bubbleSave()
}

func (o *UpgradeMetrics) GetUpgNotPossible() *delphi.Counter {
	return o.upgNotPossible
}

func (o *UpgradeMetrics) SetUpgNotPossible(val *delphi.Counter) {
	o.upgNotPossible = val
	o.bubbleSave()
}

func (o *UpgradeMetrics) bubbleSave() {
	if o.parent != nil {
		o.parent.bubbleSave()
	} else {
		o.save()
	}
}

func (o *UpgradeMetrics) save() {
	if o.GetKeyString() != "" {
		o.sdkClient.SetObject(o)
	}
}

func (o *UpgradeMetrics) Delete() {
	o.sdkClient.DeleteObject(o)
}

func NewUpgradeMetrics(sdkClient clientApi.Client) *UpgradeMetrics {
	w := &UpgradeMetrics{}
	w.sdkClient = sdkClient
	w.meta = &delphi.ObjectMeta{
		Kind: "UpgradeMetrics",
	}
	return w
}

func NewUpgradeMetricsWithKey(sdkClient clientApi.Client, key uint32) *UpgradeMetrics {
	w := NewUpgradeMetrics(sdkClient)
	w.SetKey(key)
	return w
}

func GetUpgradeMetrics(sdkClient clientApi.Client, key uint32) *UpgradeMetrics {
	lookupKey := fmt.Sprintf("%v", key)
	b := sdkClient.GetObject("UpgradeMetrics", lookupKey)
	if b == nil {
		return nil
	}
	o, ok := b.(*UpgradeMetrics)
	if !ok {
		panic("Couldn't cast to UpgradeMetrics")
	}
	return o
}

func childNewUpgradeMetrics(parent delphiWrapper, sdkClient clientApi.Client) *UpgradeMetrics {
	w := NewUpgradeMetrics(sdkClient)
	w.parent = parent
	return w
}

func childNewUpgradeMetricsWithValue(parent delphiWrapper, sdkClient clientApi.Client, value *UpgradeMetrics) *UpgradeMetrics {
	w := childNewUpgradeMetrics(parent, sdkClient)
	w.key = value.key
	w.isUpgPossible = value.isUpgPossible
	w.disruptiveUpg = value.disruptiveUpg
	w.nonDisruptiveUpg = value.nonDisruptiveUpg
	w.successfulUpg = value.successfulUpg
	w.failedUpg = value.failedUpg
	w.abortedUpg = value.abortedUpg
	w.numRegApps = value.numRegApps
	w.upgPossible = value.upgPossible
	w.upgNotPossible = value.upgNotPossible
	return w
}

func (o *UpgradeMetrics) GetProtoMsg() *UpgradeMetrics_ {
	return &UpgradeMetrics_{
		Meta:             o.meta,
		Key:              o.key,
		IsUpgPossible:    o.isUpgPossible,
		DisruptiveUpg:    o.disruptiveUpg,
		NonDisruptiveUpg: o.nonDisruptiveUpg,
		SuccessfulUpg:    o.successfulUpg,
		FailedUpg:        o.failedUpg,
		AbortedUpg:       o.abortedUpg,
		NumRegApps:       o.numRegApps,
		UpgPossible:      o.upgPossible,
		UpgNotPossible:   o.upgNotPossible,
	}
}

func (o *UpgradeMetrics) GetMessage() proto.Message {
	return o.GetProtoMsg()
}

func (obj *UpgradeMetrics) GetKeyString() string {
	return fmt.Sprintf("%v", (obj.key))
}

func (obj *UpgradeMetrics) TriggerEvent(oldObj clientApi.BaseObject, op delphi.ObjectOperation, rl []clientApi.BaseReactor) {
	for _, r := range rl {
		rctr, ok := r.(UpgradeMetricsReactor)
		if ok == false {
			panic("Not a Reactor")
		}
		if op == delphi.ObjectOperation_SetOp {
			if oldObj == nil {
				rctr.OnUpgradeMetricsCreate(obj)
			} else {
				rctr.OnUpgradeMetricsUpdate(obj)
			}
		} else {
			rctr.OnUpgradeMetricsDelete(obj)
		}
	}
}

type UpgradeMetricsReactor interface {
	OnUpgradeMetricsCreate(obj *UpgradeMetrics)
	OnUpgradeMetricsUpdate(obj *UpgradeMetrics)
	OnUpgradeMetricsDelete(obj *UpgradeMetrics)
}

func (obj *UpgradeMetrics) GetPath() string {
	return "UpgradeMetrics" + "|" + obj.GetKeyString()
}

func newUpgradeMetricsFromMessage(msg *UpgradeMetrics_) *UpgradeMetrics {
	return &UpgradeMetrics{
		meta:             msg.Meta,
		key:              msg.Key,
		isUpgPossible:    msg.IsUpgPossible,
		disruptiveUpg:    msg.DisruptiveUpg,
		nonDisruptiveUpg: msg.NonDisruptiveUpg,
		successfulUpg:    msg.SuccessfulUpg,
		failedUpg:        msg.FailedUpg,
		abortedUpg:       msg.AbortedUpg,
		numRegApps:       msg.NumRegApps,
		upgPossible:      msg.UpgPossible,
		upgNotPossible:   msg.UpgNotPossible,
	}
}

func upgradeMetricsFactory(sdkClient clientApi.Client, data []byte) (clientApi.BaseObject, error) {
	var msg UpgradeMetrics_
	err := proto.Unmarshal(data, &msg)
	if err != nil {
		return nil, err
	}
	w := newUpgradeMetricsFromMessage(&msg)
	w.sdkClient = sdkClient
	return w, nil
}

func UpgradeMetricsMount(client clientApi.Client, mode delphi.MountMode) {
	client.MountKind("UpgradeMetrics", mode)
}

func UpgradeMetricsMountKey(client clientApi.Client, key uint32, mode delphi.MountMode) {
	keyString := fmt.Sprintf("%v", key)
	client.MountKindKey("UpgradeMetrics", keyString, mode)
}

func UpgradeMetricsWatch(client clientApi.Client, reactor UpgradeMetricsReactor) {
	client.WatchKind("UpgradeMetrics", reactor)
}

type UpgradeMetricsIterator struct {
	objects []clientApi.BaseObject
	cur     int
}

func (i *UpgradeMetricsIterator) Next() *UpgradeMetrics {
	if i.cur >= len(i.objects) {
		return nil
	}
	obj, ok := i.objects[i.cur].(*UpgradeMetrics)
	if !ok {
		panic("Cast error")
	}
	i.cur++
	return obj
}

func UpgradeMetricsList(client clientApi.Client) *UpgradeMetricsIterator {
	return &UpgradeMetricsIterator{
		objects: client.List("UpgradeMetrics"),
		cur:     0,
	}
}

type UpgReq struct {
	sdkClient  clientApi.Client
	parent     delphiWrapper
	meta       *delphi.ObjectMeta
	upgReqCmd  UpgReqType
	upgReqType UpgType
}

func (o *UpgReq) GetMeta() *delphi.ObjectMeta {
	return o.meta
}

func (o *UpgReq) SetMeta(val *delphi.ObjectMeta) {
	o.meta = val
	o.bubbleSave()
}

func (o *UpgReq) GetUpgReqCmd() UpgReqType {
	return o.upgReqCmd
}

func (o *UpgReq) SetUpgReqCmd(val UpgReqType) {
	o.upgReqCmd = val
	o.bubbleSave()
}

func (o *UpgReq) GetUpgReqType() UpgType {
	return o.upgReqType
}

func (o *UpgReq) SetUpgReqType(val UpgType) {
	o.upgReqType = val
	o.bubbleSave()
}

func (o *UpgReq) bubbleSave() {
	if o.parent != nil {
		o.parent.bubbleSave()
	} else {
		o.save()
	}
}

func (o *UpgReq) save() {
	if o.GetKeyString() != "" {
		o.sdkClient.SetObject(o)
	}
}

func (o *UpgReq) Delete() {
	o.sdkClient.DeleteObject(o)
}

func NewUpgReq(sdkClient clientApi.Client) *UpgReq {
	w := &UpgReq{}
	w.sdkClient = sdkClient
	w.meta = &delphi.ObjectMeta{
		Kind: "UpgReq",
	}
	return w
}

func GetUpgReq(sdkClient clientApi.Client) *UpgReq {
	b := sdkClient.GetObject("UpgReq", "default")
	if b == nil {
		return nil
	}
	o, ok := b.(*UpgReq)
	if !ok {
		panic("Couldn't cast to UpgReq")
	}
	return o
}

func childNewUpgReq(parent delphiWrapper, sdkClient clientApi.Client) *UpgReq {
	w := NewUpgReq(sdkClient)
	w.parent = parent
	return w
}

func childNewUpgReqWithValue(parent delphiWrapper, sdkClient clientApi.Client, value *UpgReq) *UpgReq {
	w := childNewUpgReq(parent, sdkClient)
	w.upgReqCmd = value.upgReqCmd
	w.upgReqType = value.upgReqType
	return w
}

func (o *UpgReq) GetProtoMsg() *UpgReq_ {
	return &UpgReq_{
		Meta:       o.meta,
		UpgReqCmd:  o.upgReqCmd,
		UpgReqType: o.upgReqType,
	}
}

func (o *UpgReq) GetMessage() proto.Message {
	return o.GetProtoMsg()
}

func (obj *UpgReq) GetKeyString() string {
	return "default"
}

func (obj *UpgReq) TriggerEvent(oldObj clientApi.BaseObject, op delphi.ObjectOperation, rl []clientApi.BaseReactor) {
	for _, r := range rl {
		rctr, ok := r.(UpgReqReactor)
		if ok == false {
			panic("Not a Reactor")
		}
		if op == delphi.ObjectOperation_SetOp {
			if oldObj == nil {
				rctr.OnUpgReqCreate(obj)
			} else {
				rctr.OnUpgReqUpdate(obj)
			}
		} else {
			rctr.OnUpgReqDelete(obj)
		}
	}
}

type UpgReqReactor interface {
	OnUpgReqCreate(obj *UpgReq)
	OnUpgReqUpdate(obj *UpgReq)
	OnUpgReqDelete(obj *UpgReq)
}

func (obj *UpgReq) GetPath() string {
	return "UpgReq" + "|" + obj.GetKeyString()
}

func newUpgReqFromMessage(msg *UpgReq_) *UpgReq {
	return &UpgReq{
		meta:       msg.Meta,
		upgReqCmd:  msg.UpgReqCmd,
		upgReqType: msg.UpgReqType,
	}
}

func upgReqFactory(sdkClient clientApi.Client, data []byte) (clientApi.BaseObject, error) {
	var msg UpgReq_
	err := proto.Unmarshal(data, &msg)
	if err != nil {
		return nil, err
	}
	w := newUpgReqFromMessage(&msg)
	w.sdkClient = sdkClient
	return w, nil
}

func UpgReqMount(client clientApi.Client, mode delphi.MountMode) {
	client.MountKind("UpgReq", mode)
}

func UpgReqWatch(client clientApi.Client, reactor UpgReqReactor) {
	client.WatchKind("UpgReq", reactor)
}

type UpgReqIterator struct {
	objects []clientApi.BaseObject
	cur     int
}

func (i *UpgReqIterator) Next() *UpgReq {
	if i.cur >= len(i.objects) {
		return nil
	}
	obj, ok := i.objects[i.cur].(*UpgReq)
	if !ok {
		panic("Cast error")
	}
	i.cur++
	return obj
}

func UpgReqList(client clientApi.Client) *UpgReqIterator {
	return &UpgReqIterator{
		objects: client.List("UpgReq"),
		cur:     0,
	}
}

type UpgResp struct {
	sdkClient      clientApi.Client
	parent         delphiWrapper
	meta           *delphi.ObjectMeta
	upgRespVal     UpgRespType
	upgRespFailStr *StringArray
}

func (o *UpgResp) GetMeta() *delphi.ObjectMeta {
	return o.meta
}

func (o *UpgResp) SetMeta(val *delphi.ObjectMeta) {
	o.meta = val
	o.bubbleSave()
}

func (o *UpgResp) GetUpgRespVal() UpgRespType {
	return o.upgRespVal
}

func (o *UpgResp) SetUpgRespVal(val UpgRespType) {
	o.upgRespVal = val
	o.bubbleSave()
}

func (o *UpgResp) GetUpgRespFailStr() *StringArray {
	return o.upgRespFailStr
}

func (o *UpgResp) bubbleSave() {
	if o.parent != nil {
		o.parent.bubbleSave()
	} else {
		o.save()
	}
}

func (o *UpgResp) save() {
	if o.GetKeyString() != "" {
		o.sdkClient.SetObject(o)
	}
}

func (o *UpgResp) Delete() {
	o.sdkClient.DeleteObject(o)
}

func NewUpgResp(sdkClient clientApi.Client) *UpgResp {
	w := &UpgResp{}
	w.sdkClient = sdkClient
	w.meta = &delphi.ObjectMeta{
		Kind: "UpgResp",
	}
	w.upgRespFailStr = childNewStringArray(w, sdkClient)
	return w
}

func GetUpgResp(sdkClient clientApi.Client) *UpgResp {
	b := sdkClient.GetObject("UpgResp", "default")
	if b == nil {
		return nil
	}
	o, ok := b.(*UpgResp)
	if !ok {
		panic("Couldn't cast to UpgResp")
	}
	return o
}

func childNewUpgResp(parent delphiWrapper, sdkClient clientApi.Client) *UpgResp {
	w := NewUpgResp(sdkClient)
	w.parent = parent
	return w
}

func childNewUpgRespWithValue(parent delphiWrapper, sdkClient clientApi.Client, value *UpgResp) *UpgResp {
	w := childNewUpgResp(parent, sdkClient)
	w.upgRespVal = value.upgRespVal
	w.upgRespFailStr = childNewStringArrayWithValue(w, sdkClient, value.upgRespFailStr)
	return w
}

func (o *UpgResp) GetProtoMsg() *UpgResp_ {
	return &UpgResp_{
		Meta:           o.meta,
		UpgRespVal:     o.upgRespVal,
		UpgRespFailStr: o.upgRespFailStr.GetProtoMsg(),
	}
}

func (o *UpgResp) GetMessage() proto.Message {
	return o.GetProtoMsg()
}

func (obj *UpgResp) GetKeyString() string {
	return "default"
}

func (obj *UpgResp) TriggerEvent(oldObj clientApi.BaseObject, op delphi.ObjectOperation, rl []clientApi.BaseReactor) {
	for _, r := range rl {
		rctr, ok := r.(UpgRespReactor)
		if ok == false {
			panic("Not a Reactor")
		}
		if op == delphi.ObjectOperation_SetOp {
			if oldObj == nil {
				rctr.OnUpgRespCreate(obj)
			} else {
				rctr.OnUpgRespUpdate(obj)
			}
		} else {
			rctr.OnUpgRespDelete(obj)
		}
	}
}

type UpgRespReactor interface {
	OnUpgRespCreate(obj *UpgResp)
	OnUpgRespUpdate(obj *UpgResp)
	OnUpgRespDelete(obj *UpgResp)
}

func (obj *UpgResp) GetPath() string {
	return "UpgResp" + "|" + obj.GetKeyString()
}

func newUpgRespFromMessage(msg *UpgResp_) *UpgResp {
	return &UpgResp{
		meta:           msg.Meta,
		upgRespVal:     msg.UpgRespVal,
		upgRespFailStr: newStringArrayFromMessage(msg.UpgRespFailStr),
	}
}

func upgRespFactory(sdkClient clientApi.Client, data []byte) (clientApi.BaseObject, error) {
	var msg UpgResp_
	err := proto.Unmarshal(data, &msg)
	if err != nil {
		return nil, err
	}
	w := newUpgRespFromMessage(&msg)
	w.sdkClient = sdkClient
	return w, nil
}

func UpgRespMount(client clientApi.Client, mode delphi.MountMode) {
	client.MountKind("UpgResp", mode)
}

func UpgRespWatch(client clientApi.Client, reactor UpgRespReactor) {
	client.WatchKind("UpgResp", reactor)
}

type UpgRespIterator struct {
	objects []clientApi.BaseObject
	cur     int
}

func (i *UpgRespIterator) Next() *UpgResp {
	if i.cur >= len(i.objects) {
		return nil
	}
	obj, ok := i.objects[i.cur].(*UpgResp)
	if !ok {
		panic("Cast error")
	}
	i.cur++
	return obj
}

func UpgRespList(client clientApi.Client) *UpgRespIterator {
	return &UpgRespIterator{
		objects: client.List("UpgResp"),
		cur:     0,
	}
}

type UpgStateReq struct {
	sdkClient   clientApi.Client
	parent      delphiWrapper
	meta        *delphi.ObjectMeta
	upgReqState UpgReqStateType
	upgReqType  UpgType
}

func (o *UpgStateReq) GetMeta() *delphi.ObjectMeta {
	return o.meta
}

func (o *UpgStateReq) SetMeta(val *delphi.ObjectMeta) {
	o.meta = val
	o.bubbleSave()
}

func (o *UpgStateReq) GetUpgReqState() UpgReqStateType {
	return o.upgReqState
}

func (o *UpgStateReq) SetUpgReqState(val UpgReqStateType) {
	o.upgReqState = val
	o.bubbleSave()
}

func (o *UpgStateReq) GetUpgReqType() UpgType {
	return o.upgReqType
}

func (o *UpgStateReq) SetUpgReqType(val UpgType) {
	o.upgReqType = val
	o.bubbleSave()
}

func (o *UpgStateReq) bubbleSave() {
	if o.parent != nil {
		o.parent.bubbleSave()
	} else {
		o.save()
	}
}

func (o *UpgStateReq) save() {
	if o.GetKeyString() != "" {
		o.sdkClient.SetObject(o)
	}
}

func (o *UpgStateReq) Delete() {
	o.sdkClient.DeleteObject(o)
}

func NewUpgStateReq(sdkClient clientApi.Client) *UpgStateReq {
	w := &UpgStateReq{}
	w.sdkClient = sdkClient
	w.meta = &delphi.ObjectMeta{
		Kind: "UpgStateReq",
	}
	return w
}

func GetUpgStateReq(sdkClient clientApi.Client) *UpgStateReq {
	b := sdkClient.GetObject("UpgStateReq", "default")
	if b == nil {
		return nil
	}
	o, ok := b.(*UpgStateReq)
	if !ok {
		panic("Couldn't cast to UpgStateReq")
	}
	return o
}

func childNewUpgStateReq(parent delphiWrapper, sdkClient clientApi.Client) *UpgStateReq {
	w := NewUpgStateReq(sdkClient)
	w.parent = parent
	return w
}

func childNewUpgStateReqWithValue(parent delphiWrapper, sdkClient clientApi.Client, value *UpgStateReq) *UpgStateReq {
	w := childNewUpgStateReq(parent, sdkClient)
	w.upgReqState = value.upgReqState
	w.upgReqType = value.upgReqType
	return w
}

func (o *UpgStateReq) GetProtoMsg() *UpgStateReq_ {
	return &UpgStateReq_{
		Meta:        o.meta,
		UpgReqState: o.upgReqState,
		UpgReqType:  o.upgReqType,
	}
}

func (o *UpgStateReq) GetMessage() proto.Message {
	return o.GetProtoMsg()
}

func (obj *UpgStateReq) GetKeyString() string {
	return "default"
}

func (obj *UpgStateReq) TriggerEvent(oldObj clientApi.BaseObject, op delphi.ObjectOperation, rl []clientApi.BaseReactor) {
	for _, r := range rl {
		rctr, ok := r.(UpgStateReqReactor)
		if ok == false {
			panic("Not a Reactor")
		}
		if op == delphi.ObjectOperation_SetOp {
			if oldObj == nil {
				rctr.OnUpgStateReqCreate(obj)
			} else {
				rctr.OnUpgStateReqUpdate(obj)
			}
		} else {
			rctr.OnUpgStateReqDelete(obj)
		}
	}
}

type UpgStateReqReactor interface {
	OnUpgStateReqCreate(obj *UpgStateReq)
	OnUpgStateReqUpdate(obj *UpgStateReq)
	OnUpgStateReqDelete(obj *UpgStateReq)
}

func (obj *UpgStateReq) GetPath() string {
	return "UpgStateReq" + "|" + obj.GetKeyString()
}

func newUpgStateReqFromMessage(msg *UpgStateReq_) *UpgStateReq {
	return &UpgStateReq{
		meta:        msg.Meta,
		upgReqState: msg.UpgReqState,
		upgReqType:  msg.UpgReqType,
	}
}

func upgStateReqFactory(sdkClient clientApi.Client, data []byte) (clientApi.BaseObject, error) {
	var msg UpgStateReq_
	err := proto.Unmarshal(data, &msg)
	if err != nil {
		return nil, err
	}
	w := newUpgStateReqFromMessage(&msg)
	w.sdkClient = sdkClient
	return w, nil
}

func UpgStateReqMount(client clientApi.Client, mode delphi.MountMode) {
	client.MountKind("UpgStateReq", mode)
}

func UpgStateReqWatch(client clientApi.Client, reactor UpgStateReqReactor) {
	client.WatchKind("UpgStateReq", reactor)
}

type UpgStateReqIterator struct {
	objects []clientApi.BaseObject
	cur     int
}

func (i *UpgStateReqIterator) Next() *UpgStateReq {
	if i.cur >= len(i.objects) {
		return nil
	}
	obj, ok := i.objects[i.cur].(*UpgStateReq)
	if !ok {
		panic("Cast error")
	}
	i.cur++
	return obj
}

func UpgStateReqList(client clientApi.Client) *UpgStateReqIterator {
	return &UpgStateReqIterator{
		objects: client.List("UpgStateReq"),
		cur:     0,
	}
}

type UpgAppResp struct {
	sdkClient     clientApi.Client
	parent        delphiWrapper
	meta          *delphi.ObjectMeta
	key           string
	upgAppRespVal UpgStateRespType
	upgAppRespStr string
}

func (o *UpgAppResp) GetMeta() *delphi.ObjectMeta {
	return o.meta
}

func (o *UpgAppResp) SetMeta(val *delphi.ObjectMeta) {
	o.meta = val
	o.bubbleSave()
}

func (o *UpgAppResp) GetKey() string {
	return o.key
}

func (o *UpgAppResp) SetKey(val string) {
	o.key = val
	o.bubbleSave()
}

func (o *UpgAppResp) GetUpgAppRespVal() UpgStateRespType {
	return o.upgAppRespVal
}

func (o *UpgAppResp) SetUpgAppRespVal(val UpgStateRespType) {
	o.upgAppRespVal = val
	o.bubbleSave()
}

func (o *UpgAppResp) GetUpgAppRespStr() string {
	return o.upgAppRespStr
}

func (o *UpgAppResp) SetUpgAppRespStr(val string) {
	o.upgAppRespStr = val
	o.bubbleSave()
}

func (o *UpgAppResp) bubbleSave() {
	if o.parent != nil {
		o.parent.bubbleSave()
	} else {
		o.save()
	}
}

func (o *UpgAppResp) save() {
	if o.GetKeyString() != "" {
		o.sdkClient.SetObject(o)
	}
}

func (o *UpgAppResp) Delete() {
	o.sdkClient.DeleteObject(o)
}

func NewUpgAppResp(sdkClient clientApi.Client) *UpgAppResp {
	w := &UpgAppResp{}
	w.sdkClient = sdkClient
	w.meta = &delphi.ObjectMeta{
		Kind: "UpgAppResp",
	}
	return w
}

func NewUpgAppRespWithKey(sdkClient clientApi.Client, key string) *UpgAppResp {
	w := NewUpgAppResp(sdkClient)
	w.SetKey(key)
	return w
}

func GetUpgAppResp(sdkClient clientApi.Client, key string) *UpgAppResp {
	lookupKey := fmt.Sprintf("%v", key)
	b := sdkClient.GetObject("UpgAppResp", lookupKey)
	if b == nil {
		return nil
	}
	o, ok := b.(*UpgAppResp)
	if !ok {
		panic("Couldn't cast to UpgAppResp")
	}
	return o
}

func childNewUpgAppResp(parent delphiWrapper, sdkClient clientApi.Client) *UpgAppResp {
	w := NewUpgAppResp(sdkClient)
	w.parent = parent
	return w
}

func childNewUpgAppRespWithValue(parent delphiWrapper, sdkClient clientApi.Client, value *UpgAppResp) *UpgAppResp {
	w := childNewUpgAppResp(parent, sdkClient)
	w.key = value.key
	w.upgAppRespVal = value.upgAppRespVal
	w.upgAppRespStr = value.upgAppRespStr
	return w
}

func (o *UpgAppResp) GetProtoMsg() *UpgAppResp_ {
	return &UpgAppResp_{
		Meta:          o.meta,
		Key:           o.key,
		UpgAppRespVal: o.upgAppRespVal,
		UpgAppRespStr: o.upgAppRespStr,
	}
}

func (o *UpgAppResp) GetMessage() proto.Message {
	return o.GetProtoMsg()
}

func (obj *UpgAppResp) GetKeyString() string {
	return fmt.Sprintf("%v", (obj.key))
}

func (obj *UpgAppResp) TriggerEvent(oldObj clientApi.BaseObject, op delphi.ObjectOperation, rl []clientApi.BaseReactor) {
	for _, r := range rl {
		rctr, ok := r.(UpgAppRespReactor)
		if ok == false {
			panic("Not a Reactor")
		}
		if op == delphi.ObjectOperation_SetOp {
			if oldObj == nil {
				rctr.OnUpgAppRespCreate(obj)
			} else {
				rctr.OnUpgAppRespUpdate(obj)
			}
		} else {
			rctr.OnUpgAppRespDelete(obj)
		}
	}
}

type UpgAppRespReactor interface {
	OnUpgAppRespCreate(obj *UpgAppResp)
	OnUpgAppRespUpdate(obj *UpgAppResp)
	OnUpgAppRespDelete(obj *UpgAppResp)
}

func (obj *UpgAppResp) GetPath() string {
	return "UpgAppResp" + "|" + obj.GetKeyString()
}

func newUpgAppRespFromMessage(msg *UpgAppResp_) *UpgAppResp {
	return &UpgAppResp{
		meta:          msg.Meta,
		key:           msg.Key,
		upgAppRespVal: msg.UpgAppRespVal,
		upgAppRespStr: msg.UpgAppRespStr,
	}
}

func upgAppRespFactory(sdkClient clientApi.Client, data []byte) (clientApi.BaseObject, error) {
	var msg UpgAppResp_
	err := proto.Unmarshal(data, &msg)
	if err != nil {
		return nil, err
	}
	w := newUpgAppRespFromMessage(&msg)
	w.sdkClient = sdkClient
	return w, nil
}

func UpgAppRespMount(client clientApi.Client, mode delphi.MountMode) {
	client.MountKind("UpgAppResp", mode)
}

func UpgAppRespMountKey(client clientApi.Client, key string, mode delphi.MountMode) {
	keyString := fmt.Sprintf("%v", key)
	client.MountKindKey("UpgAppResp", keyString, mode)
}

func UpgAppRespWatch(client clientApi.Client, reactor UpgAppRespReactor) {
	client.WatchKind("UpgAppResp", reactor)
}

type UpgAppRespIterator struct {
	objects []clientApi.BaseObject
	cur     int
}

func (i *UpgAppRespIterator) Next() *UpgAppResp {
	if i.cur >= len(i.objects) {
		return nil
	}
	obj, ok := i.objects[i.cur].(*UpgAppResp)
	if !ok {
		panic("Cast error")
	}
	i.cur++
	return obj
}

func UpgAppRespList(client clientApi.Client) *UpgAppRespIterator {
	return &UpgAppRespIterator{
		objects: client.List("UpgAppResp"),
		cur:     0,
	}
}

type StringArray struct {
	parent delphiWrapper
	values []string
}

func (arr *StringArray) Append(value string) {
	arr.values = append(arr.values, value)
	arr.parent.bubbleSave()
}

func (arr *StringArray) Get(pos int) string {
	return arr.values[pos]
}

func (arr *StringArray) Length() int {
	return len(arr.values)
}

func newStringArrayFromMessage(msg []string) *StringArray {
	arr := new(StringArray)
	arr.values = make([]string, len(msg))
	copy(arr.values, msg)
	return arr
}

func childNewStringArray(parent delphiWrapper, sdkClient clientApi.Client) *StringArray {
	arr := new(StringArray)
	arr.values = make([]string, 0)
	arr.parent = parent
	return arr
}

func childNewStringArrayWithValue(parent delphiWrapper, sdkClient clientApi.Client, value *StringArray) *StringArray {
	arr := childNewStringArray(parent, sdkClient)
	for _, v := range value.values {
		arr.values = append(arr.values, v)
	}
	return arr
}

func (arr *StringArray) GetProtoMsg() []string {
	v := make([]string, len(arr.values))
	copy(v, arr.values)
	return v
}

func init() {
	proto.RegisterType((*UpgReq_)(nil), "upgrade.UpgReq_")
	proto.RegisterType((*UpgResp_)(nil), "upgrade.UpgResp_")
	proto.RegisterType((*UpgStateReq_)(nil), "upgrade.UpgStateReq_")
	proto.RegisterType((*UpgAppResp_)(nil), "upgrade.UpgAppResp_")
	proto.RegisterType((*UpgApp_)(nil), "upgrade.UpgApp_")
	proto.RegisterType((*UpgradeMetrics_)(nil), "upgrade.UpgradeMetrics_")
	clientApi.RegisterFactory("UpgApp", upgAppFactory)
	clientApi.RegisterFactory("UpgradeMetrics", upgradeMetricsFactory)
	clientApi.RegisterFactory("UpgReq", upgReqFactory)
	clientApi.RegisterFactory("UpgResp", upgRespFactory)
	clientApi.RegisterFactory("UpgStateReq", upgStateReqFactory)
	clientApi.RegisterFactory("UpgAppResp", upgAppRespFactory)
	proto.RegisterEnum("upgrade.UpgReqType", UpgReqType_name, UpgReqType_value)
	proto.RegisterEnum("upgrade.UpgRespType", UpgRespType_name, UpgRespType_value)
	proto.RegisterEnum("upgrade.UpgReqStateType", UpgReqStateType_name, UpgReqStateType_value)
	proto.RegisterEnum("upgrade.UpgStateRespType", UpgStateRespType_name, UpgStateRespType_value)
	proto.RegisterEnum("upgrade.UpgType", UpgType_name, UpgType_value)
}

func init() { proto.RegisterFile("nic/upgrade_manager/upgrade/upgrade.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 1003 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x57, 0xcd, 0x72, 0x1b, 0x45,
	0x10, 0xf6, 0x5a, 0xb2, 0x25, 0xb5, 0x2c, 0x69, 0x3c, 0xfe, 0x93, 0xed, 0x24, 0x36, 0x22, 0x65,
	0x8c, 0xa8, 0xd8, 0x15, 0x39, 0x90, 0x2a, 0x73, 0xc1, 0x91, 0x81, 0x72, 0x85, 0x18, 0xb3, 0x8a,
	0xa8, 0xe2, 0x94, 0x1a, 0x4b, 0x83, 0xbc, 0x44, 0xda, 0x1d, 0x76, 0x56, 0xa1, 0x7c, 0xa3, 0x38,
	0xf1, 0x06, 0xb9, 0x72, 0xe4, 0xc0, 0x13, 0xe4, 0x65, 0x78, 0x15, 0x6a, 0x7a, 0x77, 0x47, 0xb3,
	0xca, 0xea, 0xc7, 0xc0, 0xc9, 0x9a, 0xfe, 0x7e, 0xa6, 0xa7, 0xa7, 0x7b, 0x6a, 0x0d, 0x1f, 0xbb,
	0x4e, 0xe7, 0x78, 0x28, 0x7a, 0x3e, 0xeb, 0xf2, 0x57, 0x03, 0xe6, 0xb2, 0x1e, 0xf7, 0xe3, 0x75,
	0xfc, 0xf7, 0x48, 0xf8, 0x5e, 0xe0, 0xd1, 0x5c, 0xb4, 0xdc, 0x79, 0xa8, 0x34, 0x5d, 0xde, 0x17,
	0x37, 0xce, 0x31, 0x42, 0xf1, 0x22, 0xfc, 0x13, 0xd2, 0x6b, 0x7f, 0x59, 0x90, 0x6b, 0x8b, 0x9e,
	0xcd, 0x7f, 0x7e, 0x45, 0x0f, 0x20, 0xfb, 0x82, 0x07, 0xac, 0x6a, 0xed, 0x5b, 0x87, 0xc5, 0x06,
	0x3d, 0x8a, 0x88, 0xdf, 0x5e, 0xff, 0xc4, 0x3b, 0x81, 0x42, 0x6c, 0xc4, 0xe9, 0x53, 0x28, 0x84,
	0x92, 0xe6, 0xa0, 0x5b, 0x5d, 0xdc, 0xb7, 0x0e, 0xcb, 0x8d, 0xb5, 0xa3, 0x38, 0x8b, 0x10, 0x79,
	0x79, 0x2b, 0xf8, 0xb3, 0xec, 0xaf, 0x6f, 0x6b, 0x96, 0x3d, 0xe2, 0xd2, 0xcf, 0x00, 0x46, 0x70,
	0x35, 0x83, 0x4a, 0x62, 0x2a, 0x0d, 0x99, 0xc1, 0x3c, 0xcd, 0xab, 0xc8, 0xef, 0x6f, 0x6b, 0x56,
	0xed, 0x0f, 0x0b, 0xf2, 0x08, 0x48, 0x31, 0x7f, 0xbe, 0xa7, 0xd1, 0xb6, 0x52, 0x7c, 0xcf, 0xfa,
	0x51, 0xc2, 0xeb, 0xc9, 0x84, 0xa5, 0x78, 0x6f, 0x6b, 0x64, 0xd3, 0x03, 0x28, 0x47, 0xab, 0xaf,
	0x98, 0xd3, 0x6f, 0x05, 0x7e, 0x35, 0xb3, 0x9f, 0x39, 0x2c, 0xd8, 0x63, 0x51, 0x23, 0xc5, 0x77,
	0x16, 0xac, 0xb4, 0x45, 0xaf, 0x15, 0xb0, 0x80, 0xdf, 0xa9, 0xac, 0x5f, 0x40, 0x31, 0x3c, 0x33,
	0x4a, 0xa3, 0x3c, 0xab, 0x63, 0x85, 0x45, 0xcc, 0xc8, 0xd5, 0x94, 0xfc, 0x0f, 0xf5, 0x7d, 0x67,
	0x61, 0x12, 0x67, 0x42, 0xdc, 0xad, 0xc4, 0x04, 0x32, 0xcf, 0xf9, 0x2d, 0xe6, 0x5c, 0xb0, 0xd5,
	0x4f, 0xfa, 0x25, 0x94, 0x46, 0x46, 0xaa, 0xee, 0x61, 0x3a, 0xdb, 0x66, 0x3a, 0x51, 0x8d, 0x12,
	0xc5, 0x4f, 0xaa, 0xe8, 0x43, 0xd3, 0x46, 0x95, 0x3f, 0x8b, 0x5b, 0x24, 0x83, 0xa7, 0x28, 0xad,
	0x5d, 0x60, 0x2b, 0x9f, 0x89, 0xff, 0x92, 0x77, 0x64, 0xf5, 0x67, 0x16, 0x2a, 0xed, 0x30, 0xd1,
	0x17, 0x3c, 0xf0, 0x9d, 0x8e, 0xfc, 0x57, 0x9e, 0xa5, 0xb0, 0x16, 0x9f, 0x42, 0xe9, 0x42, 0xb6,
	0x45, 0xef, 0xca, 0x93, 0xd2, 0xb9, 0xee, 0x87, 0x57, 0x53, 0x6c, 0x54, 0x62, 0x8b, 0xa6, 0x37,
	0x74, 0x03, 0xee, 0xdb, 0x49, 0x96, 0x92, 0x9d, 0x3b, 0xd2, 0x1f, 0x8a, 0xc0, 0x79, 0xc3, 0xdb,
	0xa2, 0x87, 0x67, 0x4f, 0x93, 0x25, 0x58, 0xf4, 0x73, 0x20, 0x97, 0x9e, 0x9b, 0x54, 0x2e, 0xa5,
	0x2b, 0xdf, 0x23, 0xaa, 0x3d, 0x5b, 0xc3, 0x4e, 0x87, 0x4b, 0xf9, 0xe3, 0xb0, 0xaf, 0x94, 0xcb,
	0x13, 0xf6, 0x4c, 0xb0, 0xe8, 0x23, 0x28, 0xa8, 0x49, 0xe0, 0x5d, 0x25, 0xc9, 0xa5, 0x4b, 0x46,
	0x0c, 0x7a, 0x0c, 0x70, 0x76, 0xed, 0xf9, 0x41, 0xc8, 0xcf, 0xa7, 0xf3, 0x0d, 0x0a, 0x7d, 0x04,
	0x70, 0x39, 0x1c, 0xd8, 0x5c, 0xdd, 0xae, 0xac, 0x16, 0x50, 0x50, 0x8a, 0x05, 0x5f, 0xb3, 0x61,
	0x8f, 0xdb, 0x06, 0x81, 0x3e, 0xc6, 0x2e, 0xd6, 0xe5, 0x86, 0xf4, 0x0d, 0x4c, 0x0e, 0x7d, 0x8a,
	0x83, 0x7e, 0xe9, 0x05, 0x5a, 0x55, 0x4c, 0x57, 0x8d, 0xd1, 0xea, 0xcf, 0xcd, 0xa1, 0xa3, 0x65,
	0x80, 0x0b, 0xf7, 0x0d, 0xeb, 0x3b, 0xdd, 0xe6, 0xa0, 0x4b, 0x16, 0xe8, 0x0a, 0xbe, 0x57, 0xad,
	0x80, 0xf9, 0x01, 0xb1, 0xa2, 0x15, 0x9e, 0x8b, 0x2c, 0xd2, 0xd5, 0xb1, 0xb6, 0x20, 0x99, 0xfa,
	0x0f, 0xd1, 0x1b, 0x10, 0x8e, 0x04, 0xad, 0xe8, 0xe5, 0x15, 0x93, 0x92, 0x2c, 0x18, 0x01, 0x55,
	0x4c, 0x62, 0x51, 0x82, 0x8f, 0x8d, 0x0a, 0xc4, 0xae, 0x9b, 0x40, 0xa3, 0x48, 0xd2, 0xfa, 0xef,
	0x0c, 0xb6, 0xb4, 0xf9, 0x86, 0xd0, 0x2d, 0x58, 0x8b, 0xc7, 0xb0, 0xe9, 0x0d, 0x04, 0x0b, 0x9a,
	0x37, 0xbc, 0xf3, 0x9a, 0x2c, 0xd0, 0x1d, 0xd8, 0x8c, 0x81, 0x2b, 0xdf, 0x53, 0x17, 0xfd, 0xdd,
	0xd0, 0xe1, 0xb2, 0xc3, 0x89, 0x95, 0xc0, 0x3c, 0x19, 0x3c, 0x73, 0x5c, 0x9b, 0x4b, 0x3c, 0xe0,
	0x22, 0xfd, 0x10, 0xf6, 0x62, 0xec, 0x9c, 0x05, 0x4c, 0xf4, 0x99, 0xcb, 0xcf, 0xbd, 0x5f, 0xdc,
	0xc0, 0x19, 0xf0, 0xab, 0x1b, 0x26, 0xf9, 0x63, 0x92, 0x99, 0x4d, 0x6a, 0x90, 0xec, 0x6c, 0xd2,
	0x09, 0x59, 0x9a, 0x4d, 0x7a, 0x42, 0x96, 0xe9, 0x1a, 0x9e, 0x3b, 0x3c, 0x64, 0x9f, 0x33, 0x77,
	0x28, 0x48, 0xce, 0x0c, 0x46, 0x9d, 0x4c, 0xf2, 0x94, 0x62, 0x0f, 0x60, 0x30, 0xec, 0x55, 0x52,
	0x50, 0x97, 0x14, 0xc7, 0xc2, 0x0a, 0x83, 0x59, 0x35, 0xb3, 0xc4, 0x45, 0xba, 0x0e, 0x24, 0x06,
	0xbe, 0x71, 0xdc, 0xd7, 0x2a, 0x13, 0xb2, 0x62, 0xba, 0xaa, 0x68, 0x5b, 0x90, 0x12, 0xad, 0xc1,
	0x83, 0x89, 0x89, 0x87, 0xcd, 0x52, 0xa6, 0xdb, 0xb0, 0x11, 0x73, 0x2e, 0x64, 0xeb, 0x56, 0x06,
	0x7c, 0x60, 0x73, 0xd6, 0xbd, 0x25, 0x15, 0x73, 0xa3, 0x97, 0xdc, 0x1f, 0x38, 0x2e, 0xeb, 0x13,
	0x52, 0xff, 0xad, 0x30, 0x0a, 0xeb, 0x16, 0xda, 0x83, 0xdd, 0x94, 0x2b, 0x36, 0x5a, 0x6a, 0x32,
	0x21, 0x6a, 0x31, 0x23, 0xd7, 0x64, 0x2f, 0x68, 0x93, 0xc5, 0xe9, 0x1c, 0xf4, 0xc9, 0x24, 0x38,
	0x89, 0xbe, 0xd1, 0x3e, 0xd9, 0xe9, 0x1c, 0xf4, 0x59, 0xa2, 0x9f, 0xc0, 0x47, 0x33, 0x7a, 0x4c,
	0x1b, 0x2e, 0xcf, 0x49, 0x46, 0xe7, 0xdc, 0x6c, 0x72, 0x43, 0x3b, 0xe7, 0xe7, 0x24, 0xa3, 0x73,
	0x61, 0x36, 0xf9, 0x44, 0x3b, 0xc3, 0x9c, 0x64, 0x74, 0x2e, 0xce, 0x26, 0x3f, 0xd1, 0xce, 0x2b,
	0x73, 0x92, 0xd1, 0xb9, 0x44, 0x77, 0x61, 0x6b, 0x6c, 0x6e, 0xb4, 0x53, 0x79, 0x02, 0x88, 0xca,
	0x8a, 0x09, 0x46, 0xc3, 0xa5, 0x95, 0x64, 0x02, 0x88, 0xca, 0x55, 0xf3, 0x6d, 0x09, 0x27, 0x50,
	0x0b, 0x69, 0x3a, 0x86, 0xba, 0x35, 0x73, 0x56, 0x70, 0x4a, 0xb5, 0x6c, 0x3d, 0x15, 0x42, 0xd5,
	0x86, 0xd9, 0xfa, 0xc6, 0x20, 0x6b, 0xed, 0xe6, 0x14, 0x02, 0x3a, 0x6c, 0xd1, 0x7b, 0x50, 0x1d,
	0x9f, 0x78, 0x2d, 0xaf, 0x4e, 0x42, 0x51, 0xbb, 0x6d, 0x9e, 0x27, 0x7c, 0x17, 0xb4, 0x72, 0x27,
	0x1d, 0x43, 0xdd, 0x2e, 0xad, 0xc3, 0xc1, 0xf4, 0xb7, 0x43, 0xfb, 0xdc, 0x9b, 0x8f, 0x8b, 0xbe,
	0xf7, 0xe9, 0x07, 0x70, 0x3f, 0xf5, 0xbd, 0xd1, 0x76, 0x0f, 0xa6, 0x52, 0xd0, 0x65, 0xaf, 0x7e,
	0x8a, 0x1f, 0x61, 0xf8, 0xf4, 0x6c, 0xc0, 0x6a, 0xf4, 0x73, 0xf4, 0x8d, 0x41, 0x16, 0x68, 0x15,
	0xd6, 0xa3, 0x70, 0xe2, 0xeb, 0x83, 0x58, 0xd7, 0xcb, 0xf8, 0x3f, 0xc9, 0xc9, 0x3f, 0x01, 0x00,
	0x00, 0xff, 0xff, 0x31, 0xb3, 0xe0, 0xaa, 0xef, 0x0c, 0x00, 0x00,
}
