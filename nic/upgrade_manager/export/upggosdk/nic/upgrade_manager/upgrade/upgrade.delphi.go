// Code generated by protoc-gen-go. DO NOT EDIT.
// source: nic/upgrade_manager/upgrade/upgrade.proto

/*
Package upgrade is a generated protocol buffer package.

It is generated from these files:
	nic/upgrade_manager/upgrade/upgrade.proto

It has these top-level messages:
	UpgReq
	UpgResp
	UpgStateReq
	UpgAppResp
	UpgApp
	UpgradeMetrics
*/
package upgrade

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import clientApi "github.com/pensando/sw/nic/delphi/gosdk/client_api"
import delphi "github.com/pensando/sw/nic/delphi/proto/delphi"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type UpgReqType int32

const (
	UpgReqType_InvalidCmd    UpgReqType = 0
	UpgReqType_UpgStart      UpgReqType = 1
	UpgReqType_UpgAbort      UpgReqType = 2
	UpgReqType_IsUpgPossible UpgReqType = 3
)

var UpgReqType_name = map[int32]string{
	0: "InvalidCmd",
	1: "UpgStart",
	2: "UpgAbort",
	3: "IsUpgPossible",
}
var UpgReqType_value = map[string]int32{
	"InvalidCmd":    0,
	"UpgStart":      1,
	"UpgAbort":      2,
	"IsUpgPossible": 3,
}

func (x UpgReqType) String() string {
	return proto.EnumName(UpgReqType_name, int32(x))
}
func (UpgReqType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type UpgRespType int32

const (
	UpgRespType_UpgRespPass        UpgRespType = 0
	UpgRespType_UpgRespFail        UpgRespType = 1
	UpgRespType_UpgRespAbort       UpgRespType = 2
	UpgRespType_UpgRespUpgPossible UpgRespType = 3
)

var UpgRespType_name = map[int32]string{
	0: "UpgRespPass",
	1: "UpgRespFail",
	2: "UpgRespAbort",
	3: "UpgRespUpgPossible",
}
var UpgRespType_value = map[string]int32{
	"UpgRespPass":        0,
	"UpgRespFail":        1,
	"UpgRespAbort":       2,
	"UpgRespUpgPossible": 3,
}

func (x UpgRespType) String() string {
	return proto.EnumName(UpgRespType_name, int32(x))
}
func (UpgRespType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

// Upgrade Request Status
type UpgReqStateType int32

const (
	UpgReqStateType_UpgStateCompatCheck             UpgReqStateType = 0
	UpgReqStateType_UpgStateProcessQuiesce          UpgReqStateType = 1
	UpgReqStateType_UpgStatePostRestart             UpgReqStateType = 2
	UpgReqStateType_UpgStateDataplaneDowntimePhase1 UpgReqStateType = 3
	UpgReqStateType_UpgStateDataplaneDowntimePhase2 UpgReqStateType = 4
	UpgReqStateType_UpgStateDataplaneDowntimePhase3 UpgReqStateType = 5
	UpgReqStateType_UpgStateDataplaneDowntimePhase4 UpgReqStateType = 6
	UpgReqStateType_UpgStateSuccess                 UpgReqStateType = 7
	UpgReqStateType_UpgStateFailed                  UpgReqStateType = 8
	UpgReqStateType_UpgStateAbort                   UpgReqStateType = 9
	UpgReqStateType_UpgStateUpgPossible             UpgReqStateType = 10
	UpgReqStateType_UpgStateLinkDown                UpgReqStateType = 11
	UpgReqStateType_UpgStateLinkUp                  UpgReqStateType = 12
	UpgReqStateType_UpgStateHostDown                UpgReqStateType = 13
	UpgReqStateType_UpgStateHostUp                  UpgReqStateType = 14
	UpgReqStateType_UpgStatePostHostDown            UpgReqStateType = 15
	UpgReqStateType_UpgStatePostLinkUp              UpgReqStateType = 16
	UpgReqStateType_UpgStateSaveState               UpgReqStateType = 17
	// Always to be last
	UpgReqStateType_UpgStateTerminal UpgReqStateType = 18
)

var UpgReqStateType_name = map[int32]string{
	0:  "UpgStateCompatCheck",
	1:  "UpgStateProcessQuiesce",
	2:  "UpgStatePostRestart",
	3:  "UpgStateDataplaneDowntimePhase1",
	4:  "UpgStateDataplaneDowntimePhase2",
	5:  "UpgStateDataplaneDowntimePhase3",
	6:  "UpgStateDataplaneDowntimePhase4",
	7:  "UpgStateSuccess",
	8:  "UpgStateFailed",
	9:  "UpgStateAbort",
	10: "UpgStateUpgPossible",
	11: "UpgStateLinkDown",
	12: "UpgStateLinkUp",
	13: "UpgStateHostDown",
	14: "UpgStateHostUp",
	15: "UpgStatePostHostDown",
	16: "UpgStatePostLinkUp",
	17: "UpgStateSaveState",
	18: "UpgStateTerminal",
}
var UpgReqStateType_value = map[string]int32{
	"UpgStateCompatCheck":             0,
	"UpgStateProcessQuiesce":          1,
	"UpgStatePostRestart":             2,
	"UpgStateDataplaneDowntimePhase1": 3,
	"UpgStateDataplaneDowntimePhase2": 4,
	"UpgStateDataplaneDowntimePhase3": 5,
	"UpgStateDataplaneDowntimePhase4": 6,
	"UpgStateSuccess":                 7,
	"UpgStateFailed":                  8,
	"UpgStateAbort":                   9,
	"UpgStateUpgPossible":             10,
	"UpgStateLinkDown":                11,
	"UpgStateLinkUp":                  12,
	"UpgStateHostDown":                13,
	"UpgStateHostUp":                  14,
	"UpgStatePostHostDown":            15,
	"UpgStatePostLinkUp":              16,
	"UpgStateSaveState":               17,
	"UpgStateTerminal":                18,
}

func (x UpgReqStateType) String() string {
	return proto.EnumName(UpgReqStateType_name, int32(x))
}
func (UpgReqStateType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

// Upgrade State Response Status
type UpgStateRespType int32

const (
	UpgStateRespType_UpgStateCompatCheckRespPass             UpgStateRespType = 0
	UpgStateRespType_UpgStateCompatCheckRespFail             UpgStateRespType = 1
	UpgStateRespType_UpgStateProcessQuiesceRespPass          UpgStateRespType = 2
	UpgStateRespType_UpgStateProcessQuiesceRespFail          UpgStateRespType = 3
	UpgStateRespType_UpgStatePostRestartRespPass             UpgStateRespType = 4
	UpgStateRespType_UpgStatePostRestartRespFail             UpgStateRespType = 5
	UpgStateRespType_UpgStateDataplaneDowntimePhase1RespPass UpgStateRespType = 6
	UpgStateRespType_UpgStateDataplaneDowntimePhase1RespFail UpgStateRespType = 7
	UpgStateRespType_UpgStateDataplaneDowntimePhase2RespPass UpgStateRespType = 8
	UpgStateRespType_UpgStateDataplaneDowntimePhase2RespFail UpgStateRespType = 9
	UpgStateRespType_UpgStateDataplaneDowntimePhase3RespPass UpgStateRespType = 10
	UpgStateRespType_UpgStateDataplaneDowntimePhase3RespFail UpgStateRespType = 11
	UpgStateRespType_UpgStateDataplaneDowntimePhase4RespPass UpgStateRespType = 12
	UpgStateRespType_UpgStateDataplaneDowntimePhase4RespFail UpgStateRespType = 13
	UpgStateRespType_UpgStateSuccessRespPass                 UpgStateRespType = 14
	UpgStateRespType_UpgStateSuccessRespFail                 UpgStateRespType = 15
	UpgStateRespType_UpgStateFailedRespPass                  UpgStateRespType = 16
	UpgStateRespType_UpgStateFailedRespFail                  UpgStateRespType = 17
	UpgStateRespType_UpgStateAbortRespPass                   UpgStateRespType = 18
	UpgStateRespType_UpgStateAbortRespFail                   UpgStateRespType = 19
	UpgStateRespType_UpgStateUpgPossibleRespPass             UpgStateRespType = 20
	UpgStateRespType_UpgStateUpgPossibleRespFail             UpgStateRespType = 21
	UpgStateRespType_UpgStateLinkDownRespPass                UpgStateRespType = 22
	UpgStateRespType_UpgStateLinkDownRespFail                UpgStateRespType = 23
	UpgStateRespType_UpgStateLinkUpRespPass                  UpgStateRespType = 24
	UpgStateRespType_UpgStateLinkUpRespFail                  UpgStateRespType = 25
	UpgStateRespType_UpgStateHostDownRespPass                UpgStateRespType = 26
	UpgStateRespType_UpgStateHostDownRespFail                UpgStateRespType = 27
	UpgStateRespType_UpgStateHostUpRespPass                  UpgStateRespType = 28
	UpgStateRespType_UpgStateHostUpRespFail                  UpgStateRespType = 29
	UpgStateRespType_UpgStatePostHostDownRespPass            UpgStateRespType = 30
	UpgStateRespType_UpgStatePostHostDownRespFail            UpgStateRespType = 31
	UpgStateRespType_UpgStatePostLinkUpRespPass              UpgStateRespType = 32
	UpgStateRespType_UpgStatePostLinkUpRespFail              UpgStateRespType = 33
	UpgStateRespType_UpgStateSaveStateRespPass               UpgStateRespType = 34
	UpgStateRespType_UpgStateSaveStateRespFail               UpgStateRespType = 35
)

var UpgStateRespType_name = map[int32]string{
	0:  "UpgStateCompatCheckRespPass",
	1:  "UpgStateCompatCheckRespFail",
	2:  "UpgStateProcessQuiesceRespPass",
	3:  "UpgStateProcessQuiesceRespFail",
	4:  "UpgStatePostRestartRespPass",
	5:  "UpgStatePostRestartRespFail",
	6:  "UpgStateDataplaneDowntimePhase1RespPass",
	7:  "UpgStateDataplaneDowntimePhase1RespFail",
	8:  "UpgStateDataplaneDowntimePhase2RespPass",
	9:  "UpgStateDataplaneDowntimePhase2RespFail",
	10: "UpgStateDataplaneDowntimePhase3RespPass",
	11: "UpgStateDataplaneDowntimePhase3RespFail",
	12: "UpgStateDataplaneDowntimePhase4RespPass",
	13: "UpgStateDataplaneDowntimePhase4RespFail",
	14: "UpgStateSuccessRespPass",
	15: "UpgStateSuccessRespFail",
	16: "UpgStateFailedRespPass",
	17: "UpgStateFailedRespFail",
	18: "UpgStateAbortRespPass",
	19: "UpgStateAbortRespFail",
	20: "UpgStateUpgPossibleRespPass",
	21: "UpgStateUpgPossibleRespFail",
	22: "UpgStateLinkDownRespPass",
	23: "UpgStateLinkDownRespFail",
	24: "UpgStateLinkUpRespPass",
	25: "UpgStateLinkUpRespFail",
	26: "UpgStateHostDownRespPass",
	27: "UpgStateHostDownRespFail",
	28: "UpgStateHostUpRespPass",
	29: "UpgStateHostUpRespFail",
	30: "UpgStatePostHostDownRespPass",
	31: "UpgStatePostHostDownRespFail",
	32: "UpgStatePostLinkUpRespPass",
	33: "UpgStatePostLinkUpRespFail",
	34: "UpgStateSaveStateRespPass",
	35: "UpgStateSaveStateRespFail",
}
var UpgStateRespType_value = map[string]int32{
	"UpgStateCompatCheckRespPass":             0,
	"UpgStateCompatCheckRespFail":             1,
	"UpgStateProcessQuiesceRespPass":          2,
	"UpgStateProcessQuiesceRespFail":          3,
	"UpgStatePostRestartRespPass":             4,
	"UpgStatePostRestartRespFail":             5,
	"UpgStateDataplaneDowntimePhase1RespPass": 6,
	"UpgStateDataplaneDowntimePhase1RespFail": 7,
	"UpgStateDataplaneDowntimePhase2RespPass": 8,
	"UpgStateDataplaneDowntimePhase2RespFail": 9,
	"UpgStateDataplaneDowntimePhase3RespPass": 10,
	"UpgStateDataplaneDowntimePhase3RespFail": 11,
	"UpgStateDataplaneDowntimePhase4RespPass": 12,
	"UpgStateDataplaneDowntimePhase4RespFail": 13,
	"UpgStateSuccessRespPass":                 14,
	"UpgStateSuccessRespFail":                 15,
	"UpgStateFailedRespPass":                  16,
	"UpgStateFailedRespFail":                  17,
	"UpgStateAbortRespPass":                   18,
	"UpgStateAbortRespFail":                   19,
	"UpgStateUpgPossibleRespPass":             20,
	"UpgStateUpgPossibleRespFail":             21,
	"UpgStateLinkDownRespPass":                22,
	"UpgStateLinkDownRespFail":                23,
	"UpgStateLinkUpRespPass":                  24,
	"UpgStateLinkUpRespFail":                  25,
	"UpgStateHostDownRespPass":                26,
	"UpgStateHostDownRespFail":                27,
	"UpgStateHostUpRespPass":                  28,
	"UpgStateHostUpRespFail":                  29,
	"UpgStatePostHostDownRespPass":            30,
	"UpgStatePostHostDownRespFail":            31,
	"UpgStatePostLinkUpRespPass":              32,
	"UpgStatePostLinkUpRespFail":              33,
	"UpgStateSaveStateRespPass":               34,
	"UpgStateSaveStateRespFail":               35,
}

func (x UpgStateRespType) String() string {
	return proto.EnumName(UpgStateRespType_name, int32(x))
}
func (UpgStateRespType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

type UpgType int32

const (
	UpgType_UpgTypeDisruptive    UpgType = 0
	UpgType_UpgTypeNonDisruptive UpgType = 1
)

var UpgType_name = map[int32]string{
	0: "UpgTypeDisruptive",
	1: "UpgTypeNonDisruptive",
}
var UpgType_value = map[string]int32{
	"UpgTypeDisruptive":    0,
	"UpgTypeNonDisruptive": 1,
}

func (x UpgType) String() string {
	return proto.EnumName(UpgType_name, int32(x))
}
func (UpgType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

// spec part of the object
type UpgReq struct {
	Meta       *delphi.ObjectMeta `protobuf:"bytes,1,opt,name=Meta" json:"Meta,omitempty"`
	UpgReqCmd  UpgReqType         `protobuf:"varint,2,opt,name=UpgReqCmd,enum=upgrade.UpgReqType" json:"UpgReqCmd,omitempty"`
	UpgReqType UpgType            `protobuf:"varint,3,opt,name=UpgReqType,enum=upgrade.UpgType" json:"UpgReqType,omitempty"`
	UpgPkgName string             `protobuf:"bytes,4,opt,name=UpgPkgName" json:"UpgPkgName,omitempty"`
}

func (m *UpgReq) GetDelphiMessage() proto.Message {
	return m
}

func (m *UpgReq) GetDelphiMeta() *delphi.ObjectMeta {
	return m.Meta
}

func (m *UpgReq) SetDelphiMeta(meta *delphi.ObjectMeta) {
	m.Meta = meta
}

func (m *UpgReq) GetDelphiKey() string {
	return "default"
}

func (m *UpgReq) GetDelphiKind() string {
	return "UpgReq"
}

func (m *UpgReq) GetDelphiPath() string {
	return fmt.Sprintf("%s|%s", m.GetDelphiKind(), m.GetDelphiKey())
}

func (m *UpgReq) DelphiClone() clientApi.BaseObject {
	obj, _ := proto.Clone(m).(*UpgReq)
	return obj
}

func UpgReqMount(client clientApi.Client, mode delphi.MountMode) {
	client.MountKind("UpgReq", mode)
}

func GetUpgReq(client clientApi.Client) *UpgReq {
	o := client.GetObject("UpgReq", "default")
	if o == nil {
		return nil
	}
	obj, ok := o.(*UpgReq)
	if ok != true {
		panic("Cast failed")
	}
	return obj
}

func UpgReqFactory(sdkClient clientApi.Client, data []byte) (clientApi.BaseObject, error) {
	var msg UpgReq
	err := proto.Unmarshal(data, &msg)
	if err != nil {
		return nil, err
	}
	return &msg, nil
}

func UpgReqWatch(client clientApi.Client, reactor UpgReqReactor) {
	client.WatchKind("UpgReq", reactor)
}
func UpgReqList(client clientApi.Client) []*UpgReq {
	bobjs := client.List("UpgReq")
	objs := make([]*UpgReq, 0)
	for _, bobj := range bobjs {
		obj, _ := bobj.(*UpgReq)
		objs = append(objs, obj)
	}
	return objs
}
func (m *UpgReq) TriggerEvent(sdkClient clientApi.Client, old clientApi.BaseObject, op delphi.ObjectOperation, rl []clientApi.BaseReactor) {
	for _, r := range rl {
		rctr, ok := r.(UpgReqReactor)
		if ok == false {
			panic("Not a Reactor")
		}
		if op == delphi.ObjectOperation_SetOp {
			if old == nil {
				rctr.OnUpgReqCreate(m)
			} else {
				oldObj, ok := old.(*UpgReq)
				if ok == false {
					panic("Not an UpgReq object")
				}
				rctr.OnUpgReqUpdate(oldObj, m)
			}
		} else {
			rctr.OnUpgReqDelete(m)
		}
	}
}

type UpgReqReactor interface {
	OnUpgReqCreate(obj *UpgReq)
	OnUpgReqUpdate(old *UpgReq, obj *UpgReq)
	OnUpgReqDelete(obj *UpgReq)
}

func (m *UpgReq) Reset()                    { *m = UpgReq{} }
func (m *UpgReq) String() string            { return proto.CompactTextString(m) }
func (*UpgReq) ProtoMessage()               {}
func (*UpgReq) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *UpgReq) GetMeta() *delphi.ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *UpgReq) GetUpgReqCmd() UpgReqType {
	if m != nil {
		return m.UpgReqCmd
	}
	return UpgReqType_InvalidCmd
}

func (m *UpgReq) GetUpgReqType() UpgType {
	if m != nil {
		return m.UpgReqType
	}
	return UpgType_UpgTypeDisruptive
}

func (m *UpgReq) GetUpgPkgName() string {
	if m != nil {
		return m.UpgPkgName
	}
	return ""
}

// status part of the object
type UpgResp struct {
	Meta           *delphi.ObjectMeta `protobuf:"bytes,1,opt,name=Meta" json:"Meta,omitempty"`
	UpgRespVal     UpgRespType        `protobuf:"varint,2,opt,name=UpgRespVal,enum=upgrade.UpgRespType" json:"UpgRespVal,omitempty"`
	UpgRespFailStr []string           `protobuf:"bytes,3,rep,name=UpgRespFailStr" json:"UpgRespFailStr,omitempty"`
}

func (m *UpgResp) GetDelphiMessage() proto.Message {
	return m
}

func (m *UpgResp) GetDelphiMeta() *delphi.ObjectMeta {
	return m.Meta
}

func (m *UpgResp) SetDelphiMeta(meta *delphi.ObjectMeta) {
	m.Meta = meta
}

func (m *UpgResp) GetDelphiKey() string {
	return "default"
}

func (m *UpgResp) GetDelphiKind() string {
	return "UpgResp"
}

func (m *UpgResp) GetDelphiPath() string {
	return fmt.Sprintf("%s|%s", m.GetDelphiKind(), m.GetDelphiKey())
}

func (m *UpgResp) DelphiClone() clientApi.BaseObject {
	obj, _ := proto.Clone(m).(*UpgResp)
	return obj
}

func UpgRespMount(client clientApi.Client, mode delphi.MountMode) {
	client.MountKind("UpgResp", mode)
}

func GetUpgResp(client clientApi.Client) *UpgResp {
	o := client.GetObject("UpgResp", "default")
	if o == nil {
		return nil
	}
	obj, ok := o.(*UpgResp)
	if ok != true {
		panic("Cast failed")
	}
	return obj
}

func UpgRespFactory(sdkClient clientApi.Client, data []byte) (clientApi.BaseObject, error) {
	var msg UpgResp
	err := proto.Unmarshal(data, &msg)
	if err != nil {
		return nil, err
	}
	return &msg, nil
}

func UpgRespWatch(client clientApi.Client, reactor UpgRespReactor) {
	client.WatchKind("UpgResp", reactor)
}
func UpgRespList(client clientApi.Client) []*UpgResp {
	bobjs := client.List("UpgResp")
	objs := make([]*UpgResp, 0)
	for _, bobj := range bobjs {
		obj, _ := bobj.(*UpgResp)
		objs = append(objs, obj)
	}
	return objs
}
func (m *UpgResp) TriggerEvent(sdkClient clientApi.Client, old clientApi.BaseObject, op delphi.ObjectOperation, rl []clientApi.BaseReactor) {
	for _, r := range rl {
		rctr, ok := r.(UpgRespReactor)
		if ok == false {
			panic("Not a Reactor")
		}
		if op == delphi.ObjectOperation_SetOp {
			if old == nil {
				rctr.OnUpgRespCreate(m)
			} else {
				oldObj, ok := old.(*UpgResp)
				if ok == false {
					panic("Not an UpgResp object")
				}
				rctr.OnUpgRespUpdate(oldObj, m)
			}
		} else {
			rctr.OnUpgRespDelete(m)
		}
	}
}

type UpgRespReactor interface {
	OnUpgRespCreate(obj *UpgResp)
	OnUpgRespUpdate(old *UpgResp, obj *UpgResp)
	OnUpgRespDelete(obj *UpgResp)
}

func (m *UpgResp) Reset()                    { *m = UpgResp{} }
func (m *UpgResp) String() string            { return proto.CompactTextString(m) }
func (*UpgResp) ProtoMessage()               {}
func (*UpgResp) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *UpgResp) GetMeta() *delphi.ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *UpgResp) GetUpgRespVal() UpgRespType {
	if m != nil {
		return m.UpgRespVal
	}
	return UpgRespType_UpgRespPass
}

func (m *UpgResp) GetUpgRespFailStr() []string {
	if m != nil {
		return m.UpgRespFailStr
	}
	return nil
}

type UpgStateReq struct {
	Meta        *delphi.ObjectMeta `protobuf:"bytes,1,opt,name=Meta" json:"Meta,omitempty"`
	UpgReqState UpgReqStateType    `protobuf:"varint,2,opt,name=UpgReqState,enum=upgrade.UpgReqStateType" json:"UpgReqState,omitempty"`
	UpgReqType  UpgType            `protobuf:"varint,3,opt,name=UpgReqType,enum=upgrade.UpgType" json:"UpgReqType,omitempty"`
}

func (m *UpgStateReq) GetDelphiMessage() proto.Message {
	return m
}

func (m *UpgStateReq) GetDelphiMeta() *delphi.ObjectMeta {
	return m.Meta
}

func (m *UpgStateReq) SetDelphiMeta(meta *delphi.ObjectMeta) {
	m.Meta = meta
}

func (m *UpgStateReq) GetDelphiKey() string {
	return "default"
}

func (m *UpgStateReq) GetDelphiKind() string {
	return "UpgStateReq"
}

func (m *UpgStateReq) GetDelphiPath() string {
	return fmt.Sprintf("%s|%s", m.GetDelphiKind(), m.GetDelphiKey())
}

func (m *UpgStateReq) DelphiClone() clientApi.BaseObject {
	obj, _ := proto.Clone(m).(*UpgStateReq)
	return obj
}

func UpgStateReqMount(client clientApi.Client, mode delphi.MountMode) {
	client.MountKind("UpgStateReq", mode)
}

func GetUpgStateReq(client clientApi.Client) *UpgStateReq {
	o := client.GetObject("UpgStateReq", "default")
	if o == nil {
		return nil
	}
	obj, ok := o.(*UpgStateReq)
	if ok != true {
		panic("Cast failed")
	}
	return obj
}

func UpgStateReqFactory(sdkClient clientApi.Client, data []byte) (clientApi.BaseObject, error) {
	var msg UpgStateReq
	err := proto.Unmarshal(data, &msg)
	if err != nil {
		return nil, err
	}
	return &msg, nil
}

func UpgStateReqWatch(client clientApi.Client, reactor UpgStateReqReactor) {
	client.WatchKind("UpgStateReq", reactor)
}
func UpgStateReqList(client clientApi.Client) []*UpgStateReq {
	bobjs := client.List("UpgStateReq")
	objs := make([]*UpgStateReq, 0)
	for _, bobj := range bobjs {
		obj, _ := bobj.(*UpgStateReq)
		objs = append(objs, obj)
	}
	return objs
}
func (m *UpgStateReq) TriggerEvent(sdkClient clientApi.Client, old clientApi.BaseObject, op delphi.ObjectOperation, rl []clientApi.BaseReactor) {
	for _, r := range rl {
		rctr, ok := r.(UpgStateReqReactor)
		if ok == false {
			panic("Not a Reactor")
		}
		if op == delphi.ObjectOperation_SetOp {
			if old == nil {
				rctr.OnUpgStateReqCreate(m)
			} else {
				oldObj, ok := old.(*UpgStateReq)
				if ok == false {
					panic("Not an UpgStateReq object")
				}
				rctr.OnUpgStateReqUpdate(oldObj, m)
			}
		} else {
			rctr.OnUpgStateReqDelete(m)
		}
	}
}

type UpgStateReqReactor interface {
	OnUpgStateReqCreate(obj *UpgStateReq)
	OnUpgStateReqUpdate(old *UpgStateReq, obj *UpgStateReq)
	OnUpgStateReqDelete(obj *UpgStateReq)
}

func (m *UpgStateReq) Reset()                    { *m = UpgStateReq{} }
func (m *UpgStateReq) String() string            { return proto.CompactTextString(m) }
func (*UpgStateReq) ProtoMessage()               {}
func (*UpgStateReq) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *UpgStateReq) GetMeta() *delphi.ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *UpgStateReq) GetUpgReqState() UpgReqStateType {
	if m != nil {
		return m.UpgReqState
	}
	return UpgReqStateType_UpgStateCompatCheck
}

func (m *UpgStateReq) GetUpgReqType() UpgType {
	if m != nil {
		return m.UpgReqType
	}
	return UpgType_UpgTypeDisruptive
}

type UpgAppResp struct {
	Meta          *delphi.ObjectMeta `protobuf:"bytes,1,opt,name=Meta" json:"Meta,omitempty"`
	Key           string             `protobuf:"bytes,2,opt,name=Key" json:"Key,omitempty"`
	UpgAppRespVal UpgStateRespType   `protobuf:"varint,3,opt,name=UpgAppRespVal,enum=upgrade.UpgStateRespType" json:"UpgAppRespVal,omitempty"`
	UpgAppRespStr string             `protobuf:"bytes,4,opt,name=UpgAppRespStr" json:"UpgAppRespStr,omitempty"`
}

func (m *UpgAppResp) GetDelphiMessage() proto.Message {
	return m
}

func (m *UpgAppResp) GetDelphiMeta() *delphi.ObjectMeta {
	return m.Meta
}

func (m *UpgAppResp) SetDelphiMeta(meta *delphi.ObjectMeta) {
	m.Meta = meta
}

func (m *UpgAppResp) GetDelphiKey() string {
	return fmt.Sprintf("%v", m.Key)
}

func (m *UpgAppResp) GetDelphiKind() string {
	return "UpgAppResp"
}

func (m *UpgAppResp) GetDelphiPath() string {
	return fmt.Sprintf("%s|%s", m.GetDelphiKind(), m.GetDelphiKey())
}

func (m *UpgAppResp) DelphiClone() clientApi.BaseObject {
	obj, _ := proto.Clone(m).(*UpgAppResp)
	return obj
}

func UpgAppRespMount(client clientApi.Client, mode delphi.MountMode) {
	client.MountKind("UpgAppResp", mode)
}

func UpgAppRespMountKey(client clientApi.Client, key string, mode delphi.MountMode) {
	client.MountKindKey("UpgAppResp", fmt.Sprintf("%v", key), mode)
}

func GetUpgAppResp(client clientApi.Client, key string) *UpgAppResp {
	o := client.GetObject("UpgAppResp", fmt.Sprintf("%v", key))
	if o == nil {
		return nil
	}
	obj, ok := o.(*UpgAppResp)
	if ok != true {
		panic("Cast failed")
	}
	return obj
}

func UpgAppRespFactory(sdkClient clientApi.Client, data []byte) (clientApi.BaseObject, error) {
	var msg UpgAppResp
	err := proto.Unmarshal(data, &msg)
	if err != nil {
		return nil, err
	}
	return &msg, nil
}

func UpgAppRespWatch(client clientApi.Client, reactor UpgAppRespReactor) {
	client.WatchKind("UpgAppResp", reactor)
}
func UpgAppRespList(client clientApi.Client) []*UpgAppResp {
	bobjs := client.List("UpgAppResp")
	objs := make([]*UpgAppResp, 0)
	for _, bobj := range bobjs {
		obj, _ := bobj.(*UpgAppResp)
		objs = append(objs, obj)
	}
	return objs
}
func (m *UpgAppResp) TriggerEvent(sdkClient clientApi.Client, old clientApi.BaseObject, op delphi.ObjectOperation, rl []clientApi.BaseReactor) {
	for _, r := range rl {
		rctr, ok := r.(UpgAppRespReactor)
		if ok == false {
			panic("Not a Reactor")
		}
		if op == delphi.ObjectOperation_SetOp {
			if old == nil {
				rctr.OnUpgAppRespCreate(m)
			} else {
				oldObj, ok := old.(*UpgAppResp)
				if ok == false {
					panic("Not an UpgAppResp object")
				}
				rctr.OnUpgAppRespUpdate(oldObj, m)
			}
		} else {
			rctr.OnUpgAppRespDelete(m)
		}
	}
}

type UpgAppRespReactor interface {
	OnUpgAppRespCreate(obj *UpgAppResp)
	OnUpgAppRespUpdate(old *UpgAppResp, obj *UpgAppResp)
	OnUpgAppRespDelete(obj *UpgAppResp)
}

func (m *UpgAppResp) Reset()                    { *m = UpgAppResp{} }
func (m *UpgAppResp) String() string            { return proto.CompactTextString(m) }
func (*UpgAppResp) ProtoMessage()               {}
func (*UpgAppResp) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *UpgAppResp) GetMeta() *delphi.ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *UpgAppResp) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *UpgAppResp) GetUpgAppRespVal() UpgStateRespType {
	if m != nil {
		return m.UpgAppRespVal
	}
	return UpgStateRespType_UpgStateCompatCheckRespPass
}

func (m *UpgAppResp) GetUpgAppRespStr() string {
	if m != nil {
		return m.UpgAppRespStr
	}
	return ""
}

type UpgApp struct {
	Meta *delphi.ObjectMeta `protobuf:"bytes,1,opt,name=Meta" json:"Meta,omitempty"`
	Key  string             `protobuf:"bytes,2,opt,name=Key" json:"Key,omitempty"`
}

func (m *UpgApp) GetDelphiMessage() proto.Message {
	return m
}

func (m *UpgApp) GetDelphiMeta() *delphi.ObjectMeta {
	return m.Meta
}

func (m *UpgApp) SetDelphiMeta(meta *delphi.ObjectMeta) {
	m.Meta = meta
}

func (m *UpgApp) GetDelphiKey() string {
	return fmt.Sprintf("%v", m.Key)
}

func (m *UpgApp) GetDelphiKind() string {
	return "UpgApp"
}

func (m *UpgApp) GetDelphiPath() string {
	return fmt.Sprintf("%s|%s", m.GetDelphiKind(), m.GetDelphiKey())
}

func (m *UpgApp) DelphiClone() clientApi.BaseObject {
	obj, _ := proto.Clone(m).(*UpgApp)
	return obj
}

func UpgAppMount(client clientApi.Client, mode delphi.MountMode) {
	client.MountKind("UpgApp", mode)
}

func UpgAppMountKey(client clientApi.Client, key string, mode delphi.MountMode) {
	client.MountKindKey("UpgApp", fmt.Sprintf("%v", key), mode)
}

func GetUpgApp(client clientApi.Client, key string) *UpgApp {
	o := client.GetObject("UpgApp", fmt.Sprintf("%v", key))
	if o == nil {
		return nil
	}
	obj, ok := o.(*UpgApp)
	if ok != true {
		panic("Cast failed")
	}
	return obj
}

func UpgAppFactory(sdkClient clientApi.Client, data []byte) (clientApi.BaseObject, error) {
	var msg UpgApp
	err := proto.Unmarshal(data, &msg)
	if err != nil {
		return nil, err
	}
	return &msg, nil
}

func UpgAppWatch(client clientApi.Client, reactor UpgAppReactor) {
	client.WatchKind("UpgApp", reactor)
}
func UpgAppList(client clientApi.Client) []*UpgApp {
	bobjs := client.List("UpgApp")
	objs := make([]*UpgApp, 0)
	for _, bobj := range bobjs {
		obj, _ := bobj.(*UpgApp)
		objs = append(objs, obj)
	}
	return objs
}
func (m *UpgApp) TriggerEvent(sdkClient clientApi.Client, old clientApi.BaseObject, op delphi.ObjectOperation, rl []clientApi.BaseReactor) {
	for _, r := range rl {
		rctr, ok := r.(UpgAppReactor)
		if ok == false {
			panic("Not a Reactor")
		}
		if op == delphi.ObjectOperation_SetOp {
			if old == nil {
				rctr.OnUpgAppCreate(m)
			} else {
				oldObj, ok := old.(*UpgApp)
				if ok == false {
					panic("Not an UpgApp object")
				}
				rctr.OnUpgAppUpdate(oldObj, m)
			}
		} else {
			rctr.OnUpgAppDelete(m)
		}
	}
}

type UpgAppReactor interface {
	OnUpgAppCreate(obj *UpgApp)
	OnUpgAppUpdate(old *UpgApp, obj *UpgApp)
	OnUpgAppDelete(obj *UpgApp)
}

func (m *UpgApp) Reset()                    { *m = UpgApp{} }
func (m *UpgApp) String() string            { return proto.CompactTextString(m) }
func (*UpgApp) ProtoMessage()               {}
func (*UpgApp) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *UpgApp) GetMeta() *delphi.ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *UpgApp) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

type UpgradeMetrics struct {
	Meta             *delphi.ObjectMeta `protobuf:"bytes,1,opt,name=Meta" json:"Meta,omitempty"`
	Key              uint32             `protobuf:"varint,2,opt,name=Key" json:"Key,omitempty"`
	IsUpgPossible    *delphi.Counter    `protobuf:"bytes,3,opt,name=IsUpgPossible" json:"IsUpgPossible,omitempty"`
	DisruptiveUpg    *delphi.Counter    `protobuf:"bytes,4,opt,name=DisruptiveUpg" json:"DisruptiveUpg,omitempty"`
	NonDisruptiveUpg *delphi.Counter    `protobuf:"bytes,5,opt,name=NonDisruptiveUpg" json:"NonDisruptiveUpg,omitempty"`
	SuccessfulUpg    *delphi.Counter    `protobuf:"bytes,6,opt,name=SuccessfulUpg" json:"SuccessfulUpg,omitempty"`
	FailedUpg        *delphi.Counter    `protobuf:"bytes,7,opt,name=FailedUpg" json:"FailedUpg,omitempty"`
	AbortedUpg       *delphi.Counter    `protobuf:"bytes,8,opt,name=AbortedUpg" json:"AbortedUpg,omitempty"`
	NumRegApps       *delphi.Gauge      `protobuf:"bytes,9,opt,name=NumRegApps" json:"NumRegApps,omitempty"`
	UpgPossible      *delphi.Counter    `protobuf:"bytes,10,opt,name=UpgPossible" json:"UpgPossible,omitempty"`
	UpgNotPossible   *delphi.Counter    `protobuf:"bytes,11,opt,name=UpgNotPossible" json:"UpgNotPossible,omitempty"`
}

func (m *UpgradeMetrics) GetDelphiMessage() proto.Message {
	return m
}

func (m *UpgradeMetrics) GetDelphiMeta() *delphi.ObjectMeta {
	return m.Meta
}

func (m *UpgradeMetrics) SetDelphiMeta(meta *delphi.ObjectMeta) {
	m.Meta = meta
}

func (m *UpgradeMetrics) GetDelphiKey() string {
	return fmt.Sprintf("%v", m.Key)
}

func (m *UpgradeMetrics) GetDelphiKind() string {
	return "UpgradeMetrics"
}

func (m *UpgradeMetrics) GetDelphiPath() string {
	return fmt.Sprintf("%s|%s", m.GetDelphiKind(), m.GetDelphiKey())
}

func (m *UpgradeMetrics) DelphiClone() clientApi.BaseObject {
	obj, _ := proto.Clone(m).(*UpgradeMetrics)
	return obj
}

func UpgradeMetricsMount(client clientApi.Client, mode delphi.MountMode) {
	client.MountKind("UpgradeMetrics", mode)
}

func UpgradeMetricsMountKey(client clientApi.Client, key uint32, mode delphi.MountMode) {
	client.MountKindKey("UpgradeMetrics", fmt.Sprintf("%v", key), mode)
}

func GetUpgradeMetrics(client clientApi.Client, key uint32) *UpgradeMetrics {
	o := client.GetObject("UpgradeMetrics", fmt.Sprintf("%v", key))
	if o == nil {
		return nil
	}
	obj, ok := o.(*UpgradeMetrics)
	if ok != true {
		panic("Cast failed")
	}
	return obj
}

func UpgradeMetricsFactory(sdkClient clientApi.Client, data []byte) (clientApi.BaseObject, error) {
	var msg UpgradeMetrics
	err := proto.Unmarshal(data, &msg)
	if err != nil {
		return nil, err
	}
	return &msg, nil
}

func UpgradeMetricsWatch(client clientApi.Client, reactor UpgradeMetricsReactor) {
	client.WatchKind("UpgradeMetrics", reactor)
}
func UpgradeMetricsList(client clientApi.Client) []*UpgradeMetrics {
	bobjs := client.List("UpgradeMetrics")
	objs := make([]*UpgradeMetrics, 0)
	for _, bobj := range bobjs {
		obj, _ := bobj.(*UpgradeMetrics)
		objs = append(objs, obj)
	}
	return objs
}
func (m *UpgradeMetrics) TriggerEvent(sdkClient clientApi.Client, old clientApi.BaseObject, op delphi.ObjectOperation, rl []clientApi.BaseReactor) {
	for _, r := range rl {
		rctr, ok := r.(UpgradeMetricsReactor)
		if ok == false {
			panic("Not a Reactor")
		}
		if op == delphi.ObjectOperation_SetOp {
			if old == nil {
				rctr.OnUpgradeMetricsCreate(m)
			} else {
				oldObj, ok := old.(*UpgradeMetrics)
				if ok == false {
					panic("Not an UpgradeMetrics object")
				}
				rctr.OnUpgradeMetricsUpdate(oldObj, m)
			}
		} else {
			rctr.OnUpgradeMetricsDelete(m)
		}
	}
}

type UpgradeMetricsReactor interface {
	OnUpgradeMetricsCreate(obj *UpgradeMetrics)
	OnUpgradeMetricsUpdate(old *UpgradeMetrics, obj *UpgradeMetrics)
	OnUpgradeMetricsDelete(obj *UpgradeMetrics)
}

func (m *UpgradeMetrics) Reset()                    { *m = UpgradeMetrics{} }
func (m *UpgradeMetrics) String() string            { return proto.CompactTextString(m) }
func (*UpgradeMetrics) ProtoMessage()               {}
func (*UpgradeMetrics) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *UpgradeMetrics) GetMeta() *delphi.ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *UpgradeMetrics) GetKey() uint32 {
	if m != nil {
		return m.Key
	}
	return 0
}

func (m *UpgradeMetrics) GetIsUpgPossible() *delphi.Counter {
	if m != nil {
		return m.IsUpgPossible
	}
	return nil
}

func (m *UpgradeMetrics) GetDisruptiveUpg() *delphi.Counter {
	if m != nil {
		return m.DisruptiveUpg
	}
	return nil
}

func (m *UpgradeMetrics) GetNonDisruptiveUpg() *delphi.Counter {
	if m != nil {
		return m.NonDisruptiveUpg
	}
	return nil
}

func (m *UpgradeMetrics) GetSuccessfulUpg() *delphi.Counter {
	if m != nil {
		return m.SuccessfulUpg
	}
	return nil
}

func (m *UpgradeMetrics) GetFailedUpg() *delphi.Counter {
	if m != nil {
		return m.FailedUpg
	}
	return nil
}

func (m *UpgradeMetrics) GetAbortedUpg() *delphi.Counter {
	if m != nil {
		return m.AbortedUpg
	}
	return nil
}

func (m *UpgradeMetrics) GetNumRegApps() *delphi.Gauge {
	if m != nil {
		return m.NumRegApps
	}
	return nil
}

func (m *UpgradeMetrics) GetUpgPossible() *delphi.Counter {
	if m != nil {
		return m.UpgPossible
	}
	return nil
}

func (m *UpgradeMetrics) GetUpgNotPossible() *delphi.Counter {
	if m != nil {
		return m.UpgNotPossible
	}
	return nil
}

func init() {
	clientApi.RegisterFactory("UpgReq", UpgReqFactory)
	proto.RegisterType((*UpgReq)(nil), "upgrade.UpgReq")
	clientApi.RegisterFactory("UpgResp", UpgRespFactory)
	proto.RegisterType((*UpgResp)(nil), "upgrade.UpgResp")
	clientApi.RegisterFactory("UpgStateReq", UpgStateReqFactory)
	proto.RegisterType((*UpgStateReq)(nil), "upgrade.UpgStateReq")
	clientApi.RegisterFactory("UpgAppResp", UpgAppRespFactory)
	proto.RegisterType((*UpgAppResp)(nil), "upgrade.UpgAppResp")
	clientApi.RegisterFactory("UpgApp", UpgAppFactory)
	proto.RegisterType((*UpgApp)(nil), "upgrade.UpgApp")
	clientApi.RegisterFactory("UpgradeMetrics", UpgradeMetricsFactory)
	proto.RegisterType((*UpgradeMetrics)(nil), "upgrade.UpgradeMetrics")
	proto.RegisterEnum("upgrade.UpgReqType", UpgReqType_name, UpgReqType_value)
	proto.RegisterEnum("upgrade.UpgRespType", UpgRespType_name, UpgRespType_value)
	proto.RegisterEnum("upgrade.UpgReqStateType", UpgReqStateType_name, UpgReqStateType_value)
	proto.RegisterEnum("upgrade.UpgStateRespType", UpgStateRespType_name, UpgStateRespType_value)
	proto.RegisterEnum("upgrade.UpgType", UpgType_name, UpgType_value)
}

func init() { proto.RegisterFile("nic/upgrade_manager/upgrade/upgrade.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 1035 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x57, 0x4b, 0x73, 0xdb, 0x54,
	0x14, 0x8e, 0x62, 0xc7, 0x8f, 0xe3, 0xd7, 0xcd, 0xc9, 0x4b, 0x79, 0x34, 0x31, 0x6e, 0xa7, 0x84,
	0x30, 0x4d, 0xa7, 0x4e, 0xa1, 0x33, 0x61, 0x43, 0x70, 0x80, 0x76, 0x4a, 0x83, 0x51, 0x6a, 0x66,
	0x58, 0x31, 0x8a, 0x7d, 0x71, 0x44, 0x6c, 0x49, 0x95, 0xe4, 0x30, 0xdd, 0xb1, 0xe4, 0x1f, 0x74,
	0xc9, 0x92, 0xdf, 0xc0, 0xcf, 0x60, 0xcb, 0x5f, 0x61, 0xc3, 0xdc, 0x23, 0xe9, 0xfa, 0xca, 0x91,
	0x63, 0x37, 0x5d, 0x45, 0xf7, 0x9c, 0xef, 0xfb, 0xee, 0xb9, 0xe7, 0x35, 0x31, 0x7c, 0x62, 0x5b,
	0xdd, 0xc7, 0x23, 0xb7, 0xef, 0x99, 0x3d, 0xfe, 0xf3, 0xd0, 0xb4, 0xcd, 0x3e, 0xf7, 0xe2, 0x73,
	0xfc, 0xf7, 0xd0, 0xf5, 0x9c, 0xc0, 0xc1, 0x7c, 0x74, 0xdc, 0x2a, 0xf7, 0xf8, 0xc0, 0xbd, 0xb4,
	0x42, 0x73, 0xe3, 0x1f, 0x0d, 0x72, 0x1d, 0xb7, 0x6f, 0xf0, 0x37, 0xf8, 0x10, 0xb2, 0xaf, 0x78,
	0x60, 0xea, 0x5a, 0x5d, 0xdb, 0x2f, 0x35, 0xf1, 0x30, 0xc2, 0x7d, 0x7f, 0xf1, 0x2b, 0xef, 0x06,
	0xc2, 0x63, 0x90, 0x1f, 0x9f, 0x41, 0x31, 0x64, 0xb4, 0x86, 0x3d, 0x7d, 0xb1, 0xae, 0xed, 0x57,
	0x9b, 0x2b, 0x87, 0xf1, 0x65, 0xa1, 0xe7, 0xf5, 0x5b, 0x97, 0x7f, 0x95, 0xfd, 0xfd, 0x5d, 0x43,
	0x33, 0xc6, 0x58, 0xfc, 0x1c, 0x60, 0xec, 0xd6, 0x33, 0xc4, 0x64, 0x2a, 0x53, 0xa1, 0x29, 0x48,
	0x7c, 0x40, 0xbc, 0xf6, 0x55, 0xff, 0xcc, 0x1c, 0x72, 0x3d, 0x5b, 0xd7, 0xf6, 0x8b, 0x0a, 0x2a,
	0xb2, 0x1f, 0x17, 0x84, 0xe5, 0x8f, 0x77, 0x0d, 0xad, 0xf1, 0xa7, 0x06, 0x79, 0xa2, 0xfb, 0xee,
	0xdc, 0x8f, 0x3a, 0x8e, 0x62, 0xf3, 0xdd, 0x1f, 0xcd, 0x41, 0xf4, 0xaa, 0xd5, 0xe4, 0xab, 0x7c,
	0xf7, 0x46, 0x7c, 0x84, 0xc6, 0x87, 0x50, 0x8d, 0x4e, 0xdf, 0x98, 0xd6, 0xe0, 0x3c, 0xf0, 0xf4,
	0x4c, 0x3d, 0xb3, 0x5f, 0x34, 0x26, 0xac, 0x4a, 0x84, 0x7f, 0x6b, 0x50, 0xea, 0xb8, 0xfd, 0xf3,
	0xc0, 0x0c, 0xf8, 0xfb, 0xa4, 0xfe, 0x4b, 0xa2, 0x19, 0xfc, 0x0d, 0x31, 0xa3, 0x30, 0xf5, 0x89,
	0xe4, 0x93, 0x4f, 0x09, 0x55, 0xa5, 0xdc, 0xb5, 0x06, 0xc9, 0xd8, 0x85, 0xe3, 0xc4, 0x75, 0xdf,
	0x2b, 0xc1, 0x0c, 0x32, 0x2f, 0xf9, 0x5b, 0x0a, 0xb9, 0x68, 0x88, 0x4f, 0xfc, 0x1a, 0x2a, 0x63,
	0x1d, 0x91, 0xf5, 0x30, 0x9a, 0x4d, 0x35, 0x9a, 0x28, 0x43, 0x89, 0xd4, 0x27, 0x59, 0xf8, 0x40,
	0x95, 0x11, 0xc9, 0xa7, 0x06, 0x31, 0x92, 0xc6, 0x63, 0xa2, 0x36, 0x9e, 0x53, 0xb3, 0x9f, 0xb8,
	0x1f, 0x10, 0x76, 0xa4, 0xf4, 0x57, 0x96, 0x8a, 0x2e, 0xe2, 0x7c, 0xc5, 0x03, 0xcf, 0xea, 0xfa,
	0x77, 0x91, 0xac, 0x84, 0x99, 0xf8, 0x0c, 0x2a, 0x2f, 0x7c, 0xd1, 0xca, 0x8e, 0xef, 0x5b, 0x17,
	0x83, 0xb0, 0x2e, 0xa5, 0x66, 0x2d, 0x96, 0x68, 0x39, 0x23, 0x3b, 0xe0, 0x9e, 0x91, 0x44, 0x09,
	0xda, 0xa9, 0xe5, 0x7b, 0x23, 0x37, 0xb0, 0xae, 0x79, 0xc7, 0xed, 0xd3, 0xcb, 0xd3, 0x68, 0x09,
	0x14, 0x7e, 0x01, 0xec, 0xcc, 0xb1, 0x93, 0xcc, 0xa5, 0x74, 0xe6, 0x0d, 0xa0, 0xb8, 0xf3, 0x7c,
	0xd4, 0xed, 0x72, 0xdf, 0xff, 0x65, 0x34, 0x10, 0xcc, 0xdc, 0x94, 0x3b, 0x13, 0x28, 0x7c, 0x04,
	0x45, 0x31, 0x05, 0xbc, 0x27, 0x28, 0xf9, 0x74, 0xca, 0x18, 0x81, 0x8f, 0x01, 0x4e, 0x2e, 0x1c,
	0x2f, 0x08, 0xf1, 0x85, 0x74, 0xbc, 0x02, 0xc1, 0x47, 0x00, 0x67, 0xa3, 0xa1, 0xc1, 0x45, 0x6d,
	0x7d, 0xbd, 0x48, 0x84, 0x4a, 0x4c, 0xf8, 0xd6, 0x1c, 0xf5, 0xb9, 0xa1, 0x00, 0xf0, 0x09, 0xcd,
	0x91, 0x4c, 0x37, 0xa4, 0x5f, 0xa0, 0x62, 0xf0, 0x19, 0xd5, 0xfb, 0xcc, 0x09, 0x24, 0xab, 0x94,
	0xce, 0x9a, 0x80, 0x1d, 0xbc, 0x54, 0x27, 0x0e, 0xab, 0x00, 0x2f, 0xec, 0x6b, 0x73, 0x60, 0xf5,
	0x5a, 0xc3, 0x1e, 0x5b, 0xc0, 0x32, 0x14, 0xc2, 0x36, 0xf7, 0x02, 0xa6, 0x45, 0x27, 0x7a, 0x17,
	0x5b, 0xc4, 0xe5, 0x89, 0xb6, 0x60, 0x99, 0x83, 0x9f, 0xa2, 0x05, 0x10, 0x0e, 0x04, 0xd6, 0xe4,
	0xb1, 0x6d, 0xfa, 0x3e, 0x5b, 0x50, 0x0c, 0x22, 0x99, 0x4c, 0x43, 0x06, 0xe5, 0xc8, 0x10, 0xab,
	0xae, 0x03, 0x46, 0x96, 0xa4, 0xf4, 0x7f, 0x19, 0xa8, 0x4d, 0x2c, 0x10, 0xdc, 0x80, 0x95, 0x78,
	0x08, 0x5b, 0xce, 0xd0, 0x35, 0x83, 0xd6, 0x25, 0xef, 0x5e, 0xb1, 0x05, 0xdc, 0x82, 0xf5, 0xd8,
	0xd1, 0xf6, 0x1c, 0x51, 0xe8, 0x1f, 0x46, 0x16, 0xf7, 0xbb, 0x9c, 0x69, 0x2a, 0xa9, 0xed, 0xf8,
	0x81, 0xc1, 0x7d, 0x7a, 0xdd, 0x22, 0xde, 0x87, 0xbd, 0xd8, 0x71, 0x6a, 0x06, 0xa6, 0x3b, 0x30,
	0x6d, 0x7e, 0xea, 0xfc, 0x66, 0x07, 0xd6, 0x90, 0xb7, 0x2f, 0x4d, 0x9f, 0x3f, 0x61, 0x99, 0xd9,
	0xa0, 0x26, 0xcb, 0xce, 0x06, 0x1d, 0xb1, 0xa5, 0xd9, 0xa0, 0xa7, 0x2c, 0x87, 0x2b, 0xf4, 0x68,
	0x02, 0x45, 0x1d, 0xcb, 0xf2, 0x88, 0x54, 0x6b, 0x32, 0x86, 0x3d, 0xc9, 0x0a, 0xa2, 0x18, 0xb1,
	0x2d, 0xcc, 0x64, 0x51, 0x7d, 0xa8, 0x9a, 0x4a, 0xc0, 0x55, 0x60, 0xb1, 0xe3, 0x3b, 0xcb, 0xbe,
	0x12, 0x97, 0xb2, 0x92, 0xaa, 0x2a, 0xac, 0x1d, 0x97, 0x95, 0x55, 0xe4, 0x73, 0xc7, 0x0f, 0x08,
	0x59, 0x51, 0x91, 0xc2, 0xda, 0x71, 0x59, 0x15, 0x75, 0x58, 0x55, 0xb3, 0x2a, 0xd1, 0xb5, 0xa8,
	0xa0, 0xd2, 0x13, 0x69, 0x33, 0x5c, 0x83, 0x65, 0xf9, 0x34, 0xf3, 0x9a, 0xd3, 0x07, 0x5b, 0x56,
	0xaf, 0x7c, 0xcd, 0xbd, 0xa1, 0x65, 0x9b, 0x03, 0x86, 0x07, 0xff, 0x16, 0xc7, 0x66, 0xd9, 0x5e,
	0x7b, 0xb0, 0x9d, 0x52, 0x7e, 0xa5, 0xdd, 0xa6, 0x03, 0xa2, 0xf6, 0x6b, 0xc0, 0x6e, 0x7a, 0x9f,
	0x48, 0x91, 0xc5, 0xdb, 0x31, 0xa4, 0x93, 0x51, 0x2f, 0x52, 0x7a, 0x4a, 0x8a, 0x64, 0x6f, 0x01,
	0x90, 0xc2, 0x12, 0x7e, 0x0a, 0x1f, 0xcf, 0x68, 0x3e, 0xa9, 0x96, 0x9b, 0x13, 0x4c, 0xca, 0xf9,
	0xd9, 0xe0, 0xa6, 0x54, 0x2e, 0xcc, 0x09, 0x26, 0xe5, 0xe2, 0x6c, 0xf0, 0x91, 0x54, 0x86, 0x39,
	0xc1, 0xa4, 0x5c, 0x9a, 0x0d, 0x7e, 0x2a, 0x95, 0xcb, 0x73, 0x82, 0x49, 0xb9, 0x82, 0xdb, 0xb0,
	0x31, 0x31, 0x50, 0x52, 0xa9, 0x3a, 0xc5, 0x49, 0xcc, 0x9a, 0xba, 0x53, 0xc2, 0xa9, 0x93, 0x44,
	0x96, 0xee, 0x23, 0xde, 0x32, 0x6e, 0xc2, 0x5a, 0x62, 0x32, 0x25, 0x0d, 0x53, 0x5d, 0xc4, 0x5a,
	0x51, 0x1b, 0x46, 0x19, 0x5e, 0xc9, 0x5d, 0xbd, 0x05, 0x40, 0x0a, 0x6b, 0xb8, 0x03, 0xfa, 0xe4,
	0x94, 0x4b, 0xfa, 0xfa, 0x34, 0x2f, 0x71, 0x37, 0xd4, 0xf7, 0x84, 0xf3, 0x2a, 0x99, 0x7a, 0xba,
	0x8f, 0x78, 0x9b, 0xaa, 0x6a, 0xbc, 0x01, 0x24, 0x73, 0x6b, 0x9a, 0x97, 0xb8, 0xdb, 0xaa, 0x6e,
	0xb8, 0x55, 0x24, 0x73, 0x27, 0xdd, 0x47, 0xbc, 0x7b, 0x58, 0x87, 0x9d, 0xb4, 0xcd, 0x23, 0xd9,
	0xbb, 0xb7, 0x21, 0x48, 0x63, 0x0f, 0x77, 0x61, 0xeb, 0xe6, 0x8e, 0x92, 0x0a, 0xf5, 0xe9, 0x7e,
	0xe2, 0x7f, 0x84, 0xf7, 0x60, 0xf3, 0xc6, 0x2e, 0x93, 0xf4, 0xc6, 0x54, 0x37, 0xb1, 0xef, 0x1f,
	0x1c, 0xd3, 0xef, 0x01, 0x5a, 0x69, 0xe1, 0x52, 0x14, 0x9f, 0xe3, 0xff, 0x6b, 0xd8, 0x42, 0xb4,
	0x5d, 0x85, 0x39, 0xf1, 0x1f, 0x0f, 0xd3, 0x2e, 0x72, 0xf4, 0x3b, 0xe9, 0xe8, 0xff, 0x00, 0x00,
	0x00, 0xff, 0xff, 0x52, 0xc4, 0x43, 0xa2, 0x6b, 0x0d, 0x00, 0x00,
}
