// Code generated by protoc-gen-go. DO NOT EDIT.
// source: nic/upgrade_manager/upgrade/upgrade.proto

/*
Package upgrade is a generated protocol buffer package.

It is generated from these files:
	nic/upgrade_manager/upgrade/upgrade.proto

It has these top-level messages:
	UpgReq_
	UpgResp_
	UpgStateReq_
	UpgAppResp_
	UpgApp_
*/
package upgrade

import gosdk "github.com/pensando/sw/nic/delphi/gosdk"
import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import delphi "github.com/pensando/sw/nic/delphi/proto/delphi"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type UpgReqType int32

const (
	UpgReqType_InvalidCmd UpgReqType = 0
	UpgReqType_UpgStart   UpgReqType = 1
	UpgReqType_UpgAbort   UpgReqType = 2
)

var UpgReqType_name = map[int32]string{
	0: "InvalidCmd",
	1: "UpgStart",
	2: "UpgAbort",
}
var UpgReqType_value = map[string]int32{
	"InvalidCmd": 0,
	"UpgStart":   1,
	"UpgAbort":   2,
}

func (x UpgReqType) String() string {
	return proto.EnumName(UpgReqType_name, int32(x))
}
func (UpgReqType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type UpgRespType int32

const (
	UpgRespType_UpgRespPass  UpgRespType = 0
	UpgRespType_UpgRespFail  UpgRespType = 1
	UpgRespType_UpgRespAbort UpgRespType = 2
)

var UpgRespType_name = map[int32]string{
	0: "UpgRespPass",
	1: "UpgRespFail",
	2: "UpgRespAbort",
}
var UpgRespType_value = map[string]int32{
	"UpgRespPass":  0,
	"UpgRespFail":  1,
	"UpgRespAbort": 2,
}

func (x UpgRespType) String() string {
	return proto.EnumName(UpgRespType_name, int32(x))
}
func (UpgRespType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

// Upgrade Request Status
type UpgReqStateType int32

const (
	UpgReqStateType_UpgReqRcvd                   UpgReqStateType = 0
	UpgReqStateType_PreUpgState                  UpgReqStateType = 1
	UpgReqStateType_ProcessesQuiesced            UpgReqStateType = 2
	UpgReqStateType_PostBinRestart               UpgReqStateType = 3
	UpgReqStateType_DataplaneDowntimePhase1Start UpgReqStateType = 4
	UpgReqStateType_DataplaneDowntimePhase2Start UpgReqStateType = 5
	UpgReqStateType_DataplaneDowntimePhase3Start UpgReqStateType = 6
	UpgReqStateType_DataplaneDowntimePhase4Start UpgReqStateType = 7
	UpgReqStateType_Cleanup                      UpgReqStateType = 8
	UpgReqStateType_UpgSuccess                   UpgReqStateType = 9
	UpgReqStateType_UpgFailed                    UpgReqStateType = 10
	UpgReqStateType_UpgAborted                   UpgReqStateType = 11
	// Always to be last
	UpgReqStateType_UpgStateTerminal UpgReqStateType = 12
)

var UpgReqStateType_name = map[int32]string{
	0:  "UpgReqRcvd",
	1:  "PreUpgState",
	2:  "ProcessesQuiesced",
	3:  "PostBinRestart",
	4:  "DataplaneDowntimePhase1Start",
	5:  "DataplaneDowntimePhase2Start",
	6:  "DataplaneDowntimePhase3Start",
	7:  "DataplaneDowntimePhase4Start",
	8:  "Cleanup",
	9:  "UpgSuccess",
	10: "UpgFailed",
	11: "UpgAborted",
	12: "UpgStateTerminal",
}
var UpgReqStateType_value = map[string]int32{
	"UpgReqRcvd":                   0,
	"PreUpgState":                  1,
	"ProcessesQuiesced":            2,
	"PostBinRestart":               3,
	"DataplaneDowntimePhase1Start": 4,
	"DataplaneDowntimePhase2Start": 5,
	"DataplaneDowntimePhase3Start": 6,
	"DataplaneDowntimePhase4Start": 7,
	"Cleanup":                      8,
	"UpgSuccess":                   9,
	"UpgFailed":                    10,
	"UpgAborted":                   11,
	"UpgStateTerminal":             12,
}

func (x UpgReqStateType) String() string {
	return proto.EnumName(UpgReqStateType_name, int32(x))
}
func (UpgReqStateType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

// Upgrade Request Status
type UpgRespStateType int32

const (
	UpgRespStateType_UpgReqRcvdPass                   UpgRespStateType = 0
	UpgRespStateType_UpgReqRcvdFail                   UpgRespStateType = 1
	UpgRespStateType_PreUpgStatePass                  UpgRespStateType = 2
	UpgRespStateType_PreUpgStateFail                  UpgRespStateType = 3
	UpgRespStateType_ProcessesQuiescedPass            UpgRespStateType = 4
	UpgRespStateType_ProcessesQuiescedFail            UpgRespStateType = 5
	UpgRespStateType_PostBinRestartPass               UpgRespStateType = 6
	UpgRespStateType_PostBinRestartFail               UpgRespStateType = 7
	UpgRespStateType_DataplaneDowntimePhase1StartPass UpgRespStateType = 8
	UpgRespStateType_DataplaneDowntimePhase1StartFail UpgRespStateType = 9
	UpgRespStateType_DataplaneDowntimePhase2StartPass UpgRespStateType = 10
	UpgRespStateType_DataplaneDowntimePhase2StartFail UpgRespStateType = 11
	UpgRespStateType_DataplaneDowntimePhase3StartPass UpgRespStateType = 12
	UpgRespStateType_DataplaneDowntimePhase3StartFail UpgRespStateType = 13
	UpgRespStateType_DataplaneDowntimePhase4StartPass UpgRespStateType = 14
	UpgRespStateType_DataplaneDowntimePhase4StartFail UpgRespStateType = 15
	UpgRespStateType_CleanupPass                      UpgRespStateType = 16
	UpgRespStateType_CleanupFail                      UpgRespStateType = 17
	UpgRespStateType_UpgSuccessPass                   UpgRespStateType = 18
	UpgRespStateType_UpgSuccessFail                   UpgRespStateType = 19
	UpgRespStateType_UpgFailedPass                    UpgRespStateType = 20
	UpgRespStateType_UpgFailedFail                    UpgRespStateType = 21
	UpgRespStateType_UpgAbortedPass                   UpgRespStateType = 22
	UpgRespStateType_UpgAbortedFail                   UpgRespStateType = 23
)

var UpgRespStateType_name = map[int32]string{
	0:  "UpgReqRcvdPass",
	1:  "UpgReqRcvdFail",
	2:  "PreUpgStatePass",
	3:  "PreUpgStateFail",
	4:  "ProcessesQuiescedPass",
	5:  "ProcessesQuiescedFail",
	6:  "PostBinRestartPass",
	7:  "PostBinRestartFail",
	8:  "DataplaneDowntimePhase1StartPass",
	9:  "DataplaneDowntimePhase1StartFail",
	10: "DataplaneDowntimePhase2StartPass",
	11: "DataplaneDowntimePhase2StartFail",
	12: "DataplaneDowntimePhase3StartPass",
	13: "DataplaneDowntimePhase3StartFail",
	14: "DataplaneDowntimePhase4StartPass",
	15: "DataplaneDowntimePhase4StartFail",
	16: "CleanupPass",
	17: "CleanupFail",
	18: "UpgSuccessPass",
	19: "UpgSuccessFail",
	20: "UpgFailedPass",
	21: "UpgFailedFail",
	22: "UpgAbortedPass",
	23: "UpgAbortedFail",
}
var UpgRespStateType_value = map[string]int32{
	"UpgReqRcvdPass":                   0,
	"UpgReqRcvdFail":                   1,
	"PreUpgStatePass":                  2,
	"PreUpgStateFail":                  3,
	"ProcessesQuiescedPass":            4,
	"ProcessesQuiescedFail":            5,
	"PostBinRestartPass":               6,
	"PostBinRestartFail":               7,
	"DataplaneDowntimePhase1StartPass": 8,
	"DataplaneDowntimePhase1StartFail": 9,
	"DataplaneDowntimePhase2StartPass": 10,
	"DataplaneDowntimePhase2StartFail": 11,
	"DataplaneDowntimePhase3StartPass": 12,
	"DataplaneDowntimePhase3StartFail": 13,
	"DataplaneDowntimePhase4StartPass": 14,
	"DataplaneDowntimePhase4StartFail": 15,
	"CleanupPass":                      16,
	"CleanupFail":                      17,
	"UpgSuccessPass":                   18,
	"UpgSuccessFail":                   19,
	"UpgFailedPass":                    20,
	"UpgFailedFail":                    21,
	"UpgAbortedPass":                   22,
	"UpgAbortedFail":                   23,
}

func (x UpgRespStateType) String() string {
	return proto.EnumName(UpgRespStateType_name, int32(x))
}
func (UpgRespStateType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

type UpgType int32

const (
	UpgType_UpgTypeDisruptive    UpgType = 0
	UpgType_UpgTypeNonDisruptive UpgType = 1
)

var UpgType_name = map[int32]string{
	0: "UpgTypeDisruptive",
	1: "UpgTypeNonDisruptive",
}
var UpgType_value = map[string]int32{
	"UpgTypeDisruptive":    0,
	"UpgTypeNonDisruptive": 1,
}

func (x UpgType) String() string {
	return proto.EnumName(UpgType_name, int32(x))
}
func (UpgType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

// spec part of the object
type UpgReq_ struct {
	Meta      *delphi.ObjectMeta `protobuf:"bytes,1,opt,name=Meta" json:"Meta,omitempty"`
	Key       uint32             `protobuf:"varint,2,opt,name=Key" json:"Key,omitempty"`
	UpgReqCmd UpgReqType         `protobuf:"varint,3,opt,name=UpgReqCmd,enum=upgrade.UpgReqType" json:"UpgReqCmd,omitempty"`
}

func (m *UpgReq_) Reset()                    { *m = UpgReq_{} }
func (m *UpgReq_) String() string            { return proto.CompactTextString(m) }
func (*UpgReq_) ProtoMessage()               {}
func (*UpgReq_) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *UpgReq_) GetMeta() *delphi.ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *UpgReq_) GetKey() uint32 {
	if m != nil {
		return m.Key
	}
	return 0
}

func (m *UpgReq_) GetUpgReqCmd() UpgReqType {
	if m != nil {
		return m.UpgReqCmd
	}
	return UpgReqType_InvalidCmd
}

type UpgResp_ struct {
	Meta           *delphi.ObjectMeta `protobuf:"bytes,1,opt,name=Meta" json:"Meta,omitempty"`
	Key            uint32             `protobuf:"varint,2,opt,name=Key" json:"Key,omitempty"`
	UpgRespVal     UpgRespType        `protobuf:"varint,3,opt,name=UpgRespVal,enum=upgrade.UpgRespType" json:"UpgRespVal,omitempty"`
	UpgRespFailStr []string           `protobuf:"bytes,4,rep,name=UpgRespFailStr" json:"UpgRespFailStr,omitempty"`
}

func (m *UpgResp_) Reset()                    { *m = UpgResp_{} }
func (m *UpgResp_) String() string            { return proto.CompactTextString(m) }
func (*UpgResp_) ProtoMessage()               {}
func (*UpgResp_) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *UpgResp_) GetMeta() *delphi.ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *UpgResp_) GetKey() uint32 {
	if m != nil {
		return m.Key
	}
	return 0
}

func (m *UpgResp_) GetUpgRespVal() UpgRespType {
	if m != nil {
		return m.UpgRespVal
	}
	return UpgRespType_UpgRespPass
}

func (m *UpgResp_) GetUpgRespFailStr() []string {
	if m != nil {
		return m.UpgRespFailStr
	}
	return nil
}

// status part of the object
type UpgStateReq_ struct {
	Meta        *delphi.ObjectMeta `protobuf:"bytes,1,opt,name=Meta" json:"Meta,omitempty"`
	Key         uint32             `protobuf:"varint,2,opt,name=Key" json:"Key,omitempty"`
	UpgReqState UpgReqStateType    `protobuf:"varint,3,opt,name=UpgReqState,enum=upgrade.UpgReqStateType" json:"UpgReqState,omitempty"`
	UpgReqType  UpgType            `protobuf:"varint,4,opt,name=UpgReqType,enum=upgrade.UpgType" json:"UpgReqType,omitempty"`
}

func (m *UpgStateReq_) Reset()                    { *m = UpgStateReq_{} }
func (m *UpgStateReq_) String() string            { return proto.CompactTextString(m) }
func (*UpgStateReq_) ProtoMessage()               {}
func (*UpgStateReq_) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *UpgStateReq_) GetMeta() *delphi.ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *UpgStateReq_) GetKey() uint32 {
	if m != nil {
		return m.Key
	}
	return 0
}

func (m *UpgStateReq_) GetUpgReqState() UpgReqStateType {
	if m != nil {
		return m.UpgReqState
	}
	return UpgReqStateType_UpgReqRcvd
}

func (m *UpgStateReq_) GetUpgReqType() UpgType {
	if m != nil {
		return m.UpgReqType
	}
	return UpgType_UpgTypeDisruptive
}

type UpgAppResp_ struct {
	Meta          *delphi.ObjectMeta `protobuf:"bytes,1,opt,name=Meta" json:"Meta,omitempty"`
	Key           string             `protobuf:"bytes,2,opt,name=Key" json:"Key,omitempty"`
	UpgAppRespVal UpgRespStateType   `protobuf:"varint,3,opt,name=UpgAppRespVal,enum=upgrade.UpgRespStateType" json:"UpgAppRespVal,omitempty"`
	UpgAppRespStr string             `protobuf:"bytes,4,opt,name=UpgAppRespStr" json:"UpgAppRespStr,omitempty"`
}

func (m *UpgAppResp_) Reset()                    { *m = UpgAppResp_{} }
func (m *UpgAppResp_) String() string            { return proto.CompactTextString(m) }
func (*UpgAppResp_) ProtoMessage()               {}
func (*UpgAppResp_) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *UpgAppResp_) GetMeta() *delphi.ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *UpgAppResp_) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *UpgAppResp_) GetUpgAppRespVal() UpgRespStateType {
	if m != nil {
		return m.UpgAppRespVal
	}
	return UpgRespStateType_UpgReqRcvdPass
}

func (m *UpgAppResp_) GetUpgAppRespStr() string {
	if m != nil {
		return m.UpgAppRespStr
	}
	return ""
}

type UpgApp_ struct {
	Meta *delphi.ObjectMeta `protobuf:"bytes,1,opt,name=Meta" json:"Meta,omitempty"`
	Key  string             `protobuf:"bytes,2,opt,name=Key" json:"Key,omitempty"`
}

func (m *UpgApp_) Reset()                    { *m = UpgApp_{} }
func (m *UpgApp_) String() string            { return proto.CompactTextString(m) }
func (*UpgApp_) ProtoMessage()               {}
func (*UpgApp_) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *UpgApp_) GetMeta() *delphi.ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *UpgApp_) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

type delphiWrapper interface {
	bubbleSave()
}

type UpgReq struct {
	sdkClient gosdk.Client
	parent    delphiWrapper
	meta      *delphi.ObjectMeta
	key       uint32
	upgReqCmd UpgReqType
}

func (o *UpgReq) GetMeta() *delphi.ObjectMeta {
	return o.meta
}

func (o *UpgReq) SetMeta(val *delphi.ObjectMeta) {
	o.meta = val
	o.bubbleSave()
}

func (o *UpgReq) GetKey() uint32 {
	return o.key
}

func (o *UpgReq) SetKey(val uint32) {
	o.key = val
	o.bubbleSave()
}

func (o *UpgReq) GetUpgReqCmd() UpgReqType {
	return o.upgReqCmd
}

func (o *UpgReq) SetUpgReqCmd(val UpgReqType) {
	o.upgReqCmd = val
	o.bubbleSave()
}

func (o *UpgReq) bubbleSave() {
	if o.parent != nil {
		o.parent.bubbleSave()
	} else {
		o.save()
	}
}

func (o *UpgReq) save() {
	if o.GetKeyString() != "" {
		o.sdkClient.SetObject(o)
	}
}

func (o *UpgReq) Delete() {
	o.sdkClient.DeleteObject(o)
}

func NewUpgReq(sdkClient gosdk.Client) *UpgReq {
	w := &UpgReq{}
	w.sdkClient = sdkClient
	w.meta = &delphi.ObjectMeta{
		Kind: "UpgReq",
	}
	return w
}

func NewUpgReqWithKey(sdkClient gosdk.Client, key uint32) *UpgReq {
	w := NewUpgReq(sdkClient)
	w.SetKey(key)
	return w
}

func GetUpgReq(sdkClient gosdk.Client, key uint32) *UpgReq {
	lookupKey := fmt.Sprintf("%v", key)
	b := sdkClient.GetObject("UpgReq", lookupKey)
	if b == nil {
		return nil
	}
	o, ok := b.(*UpgReq)
	if !ok {
		panic("Couldn't cast to UpgReq")
	}
	return o
}

func childNewUpgReq(parent delphiWrapper, sdkClient gosdk.Client) *UpgReq {
	w := NewUpgReq(sdkClient)
	w.parent = parent
	return w
}

func childNewUpgReqWithValue(parent delphiWrapper, sdkClient gosdk.Client, value *UpgReq) *UpgReq {
	w := childNewUpgReq(parent, sdkClient)
	w.key = value.key
	w.upgReqCmd = value.upgReqCmd
	return w
}

func (o *UpgReq) GetProtoMsg() *UpgReq_ {
	return &UpgReq_{
		Meta:      o.meta,
		Key:       o.key,
		UpgReqCmd: o.upgReqCmd,
	}
}

func (o *UpgReq) GetMessage() proto.Message {
	return o.GetProtoMsg()
}

func (obj *UpgReq) GetKeyString() string {
	return fmt.Sprintf("%v", (obj.key))
}

func (obj *UpgReq) TriggerEvent(oldObj gosdk.BaseObject, op delphi.ObjectOperation, rl []gosdk.BaseReactor) {
	for _, r := range rl {
		rctr, ok := r.(UpgReqReactor)
		if ok == false {
			panic("Not a Reactor")
		}
		if op == delphi.ObjectOperation_SetOp {
			if oldObj == nil {
				rctr.OnUpgReqCreate(obj)
			} else {
				rctr.OnUpgReqUpdate(obj)
			}
		} else {
			rctr.OnUpgReqDelete(obj)
		}
	}
}

type UpgReqReactor interface {
	OnUpgReqCreate(obj *UpgReq)
	OnUpgReqUpdate(obj *UpgReq)
	OnUpgReqDelete(obj *UpgReq)
}

func (obj *UpgReq) GetPath() string {
	return "UpgReq" + "|" + obj.GetKeyString()
}

func newUpgReqFromMessage(msg *UpgReq_) *UpgReq {
	return &UpgReq{
		meta:      msg.Meta,
		key:       msg.Key,
		upgReqCmd: msg.UpgReqCmd,
	}
}

func upgReqFactory(sdkClient gosdk.Client, data []byte) (gosdk.BaseObject, error) {
	var msg UpgReq_
	err := proto.Unmarshal(data, &msg)
	if err != nil {
		return nil, err
	}
	w := newUpgReqFromMessage(&msg)
	w.sdkClient = sdkClient
	return w, nil
}

func UpgReqMount(client gosdk.Client, mode delphi.MountMode) {
	client.MountKind("UpgReq", mode)
}

func UpgReqWatch(client gosdk.Client, reactor UpgReqReactor) {
	client.WatchKind("UpgReq", reactor)
}

type UpgResp struct {
	sdkClient      gosdk.Client
	parent         delphiWrapper
	meta           *delphi.ObjectMeta
	key            uint32
	upgRespVal     UpgRespType
	upgRespFailStr *StringArray
}

func (o *UpgResp) GetMeta() *delphi.ObjectMeta {
	return o.meta
}

func (o *UpgResp) SetMeta(val *delphi.ObjectMeta) {
	o.meta = val
	o.bubbleSave()
}

func (o *UpgResp) GetKey() uint32 {
	return o.key
}

func (o *UpgResp) SetKey(val uint32) {
	o.key = val
	o.bubbleSave()
}

func (o *UpgResp) GetUpgRespVal() UpgRespType {
	return o.upgRespVal
}

func (o *UpgResp) SetUpgRespVal(val UpgRespType) {
	o.upgRespVal = val
	o.bubbleSave()
}

func (o *UpgResp) GetUpgRespFailStr() *StringArray {
	return o.upgRespFailStr
}

func (o *UpgResp) bubbleSave() {
	if o.parent != nil {
		o.parent.bubbleSave()
	} else {
		o.save()
	}
}

func (o *UpgResp) save() {
	if o.GetKeyString() != "" {
		o.sdkClient.SetObject(o)
	}
}

func (o *UpgResp) Delete() {
	o.sdkClient.DeleteObject(o)
}

func NewUpgResp(sdkClient gosdk.Client) *UpgResp {
	w := &UpgResp{}
	w.sdkClient = sdkClient
	w.meta = &delphi.ObjectMeta{
		Kind: "UpgResp",
	}
	w.upgRespFailStr = childNewStringArray(w, sdkClient)
	return w
}

func NewUpgRespWithKey(sdkClient gosdk.Client, key uint32) *UpgResp {
	w := NewUpgResp(sdkClient)
	w.SetKey(key)
	return w
}

func GetUpgResp(sdkClient gosdk.Client, key uint32) *UpgResp {
	lookupKey := fmt.Sprintf("%v", key)
	b := sdkClient.GetObject("UpgResp", lookupKey)
	if b == nil {
		return nil
	}
	o, ok := b.(*UpgResp)
	if !ok {
		panic("Couldn't cast to UpgResp")
	}
	return o
}

func childNewUpgResp(parent delphiWrapper, sdkClient gosdk.Client) *UpgResp {
	w := NewUpgResp(sdkClient)
	w.parent = parent
	return w
}

func childNewUpgRespWithValue(parent delphiWrapper, sdkClient gosdk.Client, value *UpgResp) *UpgResp {
	w := childNewUpgResp(parent, sdkClient)
	w.key = value.key
	w.upgRespVal = value.upgRespVal
	w.upgRespFailStr = childNewStringArrayWithValue(w, sdkClient, value.upgRespFailStr)
	return w
}

func (o *UpgResp) GetProtoMsg() *UpgResp_ {
	return &UpgResp_{
		Meta:           o.meta,
		Key:            o.key,
		UpgRespVal:     o.upgRespVal,
		UpgRespFailStr: o.upgRespFailStr.GetProtoMsg(),
	}
}

func (o *UpgResp) GetMessage() proto.Message {
	return o.GetProtoMsg()
}

func (obj *UpgResp) GetKeyString() string {
	return fmt.Sprintf("%v", (obj.key))
}

func (obj *UpgResp) TriggerEvent(oldObj gosdk.BaseObject, op delphi.ObjectOperation, rl []gosdk.BaseReactor) {
	for _, r := range rl {
		rctr, ok := r.(UpgRespReactor)
		if ok == false {
			panic("Not a Reactor")
		}
		if op == delphi.ObjectOperation_SetOp {
			if oldObj == nil {
				rctr.OnUpgRespCreate(obj)
			} else {
				rctr.OnUpgRespUpdate(obj)
			}
		} else {
			rctr.OnUpgRespDelete(obj)
		}
	}
}

type UpgRespReactor interface {
	OnUpgRespCreate(obj *UpgResp)
	OnUpgRespUpdate(obj *UpgResp)
	OnUpgRespDelete(obj *UpgResp)
}

func (obj *UpgResp) GetPath() string {
	return "UpgResp" + "|" + obj.GetKeyString()
}

func newUpgRespFromMessage(msg *UpgResp_) *UpgResp {
	return &UpgResp{
		meta:           msg.Meta,
		key:            msg.Key,
		upgRespVal:     msg.UpgRespVal,
		upgRespFailStr: newStringArrayFromMessage(msg.UpgRespFailStr),
	}
}

func upgRespFactory(sdkClient gosdk.Client, data []byte) (gosdk.BaseObject, error) {
	var msg UpgResp_
	err := proto.Unmarshal(data, &msg)
	if err != nil {
		return nil, err
	}
	w := newUpgRespFromMessage(&msg)
	w.sdkClient = sdkClient
	return w, nil
}

func UpgRespMount(client gosdk.Client, mode delphi.MountMode) {
	client.MountKind("UpgResp", mode)
}

func UpgRespWatch(client gosdk.Client, reactor UpgRespReactor) {
	client.WatchKind("UpgResp", reactor)
}

type UpgStateReq struct {
	sdkClient   gosdk.Client
	parent      delphiWrapper
	meta        *delphi.ObjectMeta
	key         uint32
	upgReqState UpgReqStateType
	upgReqType  UpgType
}

func (o *UpgStateReq) GetMeta() *delphi.ObjectMeta {
	return o.meta
}

func (o *UpgStateReq) SetMeta(val *delphi.ObjectMeta) {
	o.meta = val
	o.bubbleSave()
}

func (o *UpgStateReq) GetKey() uint32 {
	return o.key
}

func (o *UpgStateReq) SetKey(val uint32) {
	o.key = val
	o.bubbleSave()
}

func (o *UpgStateReq) GetUpgReqState() UpgReqStateType {
	return o.upgReqState
}

func (o *UpgStateReq) SetUpgReqState(val UpgReqStateType) {
	o.upgReqState = val
	o.bubbleSave()
}

func (o *UpgStateReq) GetUpgReqType() UpgType {
	return o.upgReqType
}

func (o *UpgStateReq) SetUpgReqType(val UpgType) {
	o.upgReqType = val
	o.bubbleSave()
}

func (o *UpgStateReq) bubbleSave() {
	if o.parent != nil {
		o.parent.bubbleSave()
	} else {
		o.save()
	}
}

func (o *UpgStateReq) save() {
	if o.GetKeyString() != "" {
		o.sdkClient.SetObject(o)
	}
}

func (o *UpgStateReq) Delete() {
	o.sdkClient.DeleteObject(o)
}

func NewUpgStateReq(sdkClient gosdk.Client) *UpgStateReq {
	w := &UpgStateReq{}
	w.sdkClient = sdkClient
	w.meta = &delphi.ObjectMeta{
		Kind: "UpgStateReq",
	}
	return w
}

func NewUpgStateReqWithKey(sdkClient gosdk.Client, key uint32) *UpgStateReq {
	w := NewUpgStateReq(sdkClient)
	w.SetKey(key)
	return w
}

func GetUpgStateReq(sdkClient gosdk.Client, key uint32) *UpgStateReq {
	lookupKey := fmt.Sprintf("%v", key)
	b := sdkClient.GetObject("UpgStateReq", lookupKey)
	if b == nil {
		return nil
	}
	o, ok := b.(*UpgStateReq)
	if !ok {
		panic("Couldn't cast to UpgStateReq")
	}
	return o
}

func childNewUpgStateReq(parent delphiWrapper, sdkClient gosdk.Client) *UpgStateReq {
	w := NewUpgStateReq(sdkClient)
	w.parent = parent
	return w
}

func childNewUpgStateReqWithValue(parent delphiWrapper, sdkClient gosdk.Client, value *UpgStateReq) *UpgStateReq {
	w := childNewUpgStateReq(parent, sdkClient)
	w.key = value.key
	w.upgReqState = value.upgReqState
	w.upgReqType = value.upgReqType
	return w
}

func (o *UpgStateReq) GetProtoMsg() *UpgStateReq_ {
	return &UpgStateReq_{
		Meta:        o.meta,
		Key:         o.key,
		UpgReqState: o.upgReqState,
		UpgReqType:  o.upgReqType,
	}
}

func (o *UpgStateReq) GetMessage() proto.Message {
	return o.GetProtoMsg()
}

func (obj *UpgStateReq) GetKeyString() string {
	return fmt.Sprintf("%v", (obj.key))
}

func (obj *UpgStateReq) TriggerEvent(oldObj gosdk.BaseObject, op delphi.ObjectOperation, rl []gosdk.BaseReactor) {
	for _, r := range rl {
		rctr, ok := r.(UpgStateReqReactor)
		if ok == false {
			panic("Not a Reactor")
		}
		if op == delphi.ObjectOperation_SetOp {
			if oldObj == nil {
				rctr.OnUpgStateReqCreate(obj)
			} else {
				rctr.OnUpgStateReqUpdate(obj)
			}
		} else {
			rctr.OnUpgStateReqDelete(obj)
		}
	}
}

type UpgStateReqReactor interface {
	OnUpgStateReqCreate(obj *UpgStateReq)
	OnUpgStateReqUpdate(obj *UpgStateReq)
	OnUpgStateReqDelete(obj *UpgStateReq)
}

func (obj *UpgStateReq) GetPath() string {
	return "UpgStateReq" + "|" + obj.GetKeyString()
}

func newUpgStateReqFromMessage(msg *UpgStateReq_) *UpgStateReq {
	return &UpgStateReq{
		meta:        msg.Meta,
		key:         msg.Key,
		upgReqState: msg.UpgReqState,
		upgReqType:  msg.UpgReqType,
	}
}

func upgStateReqFactory(sdkClient gosdk.Client, data []byte) (gosdk.BaseObject, error) {
	var msg UpgStateReq_
	err := proto.Unmarshal(data, &msg)
	if err != nil {
		return nil, err
	}
	w := newUpgStateReqFromMessage(&msg)
	w.sdkClient = sdkClient
	return w, nil
}

func UpgStateReqMount(client gosdk.Client, mode delphi.MountMode) {
	client.MountKind("UpgStateReq", mode)
}

func UpgStateReqWatch(client gosdk.Client, reactor UpgStateReqReactor) {
	client.WatchKind("UpgStateReq", reactor)
}

type UpgAppResp struct {
	sdkClient     gosdk.Client
	parent        delphiWrapper
	meta          *delphi.ObjectMeta
	key           string
	upgAppRespVal UpgRespStateType
	upgAppRespStr string
}

func (o *UpgAppResp) GetMeta() *delphi.ObjectMeta {
	return o.meta
}

func (o *UpgAppResp) SetMeta(val *delphi.ObjectMeta) {
	o.meta = val
	o.bubbleSave()
}

func (o *UpgAppResp) GetKey() string {
	return o.key
}

func (o *UpgAppResp) SetKey(val string) {
	o.key = val
	o.bubbleSave()
}

func (o *UpgAppResp) GetUpgAppRespVal() UpgRespStateType {
	return o.upgAppRespVal
}

func (o *UpgAppResp) SetUpgAppRespVal(val UpgRespStateType) {
	o.upgAppRespVal = val
	o.bubbleSave()
}

func (o *UpgAppResp) GetUpgAppRespStr() string {
	return o.upgAppRespStr
}

func (o *UpgAppResp) SetUpgAppRespStr(val string) {
	o.upgAppRespStr = val
	o.bubbleSave()
}

func (o *UpgAppResp) bubbleSave() {
	if o.parent != nil {
		o.parent.bubbleSave()
	} else {
		o.save()
	}
}

func (o *UpgAppResp) save() {
	if o.GetKeyString() != "" {
		o.sdkClient.SetObject(o)
	}
}

func (o *UpgAppResp) Delete() {
	o.sdkClient.DeleteObject(o)
}

func NewUpgAppResp(sdkClient gosdk.Client) *UpgAppResp {
	w := &UpgAppResp{}
	w.sdkClient = sdkClient
	w.meta = &delphi.ObjectMeta{
		Kind: "UpgAppResp",
	}
	return w
}

func NewUpgAppRespWithKey(sdkClient gosdk.Client, key string) *UpgAppResp {
	w := NewUpgAppResp(sdkClient)
	w.SetKey(key)
	return w
}

func GetUpgAppResp(sdkClient gosdk.Client, key string) *UpgAppResp {
	lookupKey := fmt.Sprintf("%v", key)
	b := sdkClient.GetObject("UpgAppResp", lookupKey)
	if b == nil {
		return nil
	}
	o, ok := b.(*UpgAppResp)
	if !ok {
		panic("Couldn't cast to UpgAppResp")
	}
	return o
}

func childNewUpgAppResp(parent delphiWrapper, sdkClient gosdk.Client) *UpgAppResp {
	w := NewUpgAppResp(sdkClient)
	w.parent = parent
	return w
}

func childNewUpgAppRespWithValue(parent delphiWrapper, sdkClient gosdk.Client, value *UpgAppResp) *UpgAppResp {
	w := childNewUpgAppResp(parent, sdkClient)
	w.key = value.key
	w.upgAppRespVal = value.upgAppRespVal
	w.upgAppRespStr = value.upgAppRespStr
	return w
}

func (o *UpgAppResp) GetProtoMsg() *UpgAppResp_ {
	return &UpgAppResp_{
		Meta:          o.meta,
		Key:           o.key,
		UpgAppRespVal: o.upgAppRespVal,
		UpgAppRespStr: o.upgAppRespStr,
	}
}

func (o *UpgAppResp) GetMessage() proto.Message {
	return o.GetProtoMsg()
}

func (obj *UpgAppResp) GetKeyString() string {
	return fmt.Sprintf("%v", (obj.key))
}

func (obj *UpgAppResp) TriggerEvent(oldObj gosdk.BaseObject, op delphi.ObjectOperation, rl []gosdk.BaseReactor) {
	for _, r := range rl {
		rctr, ok := r.(UpgAppRespReactor)
		if ok == false {
			panic("Not a Reactor")
		}
		if op == delphi.ObjectOperation_SetOp {
			if oldObj == nil {
				rctr.OnUpgAppRespCreate(obj)
			} else {
				rctr.OnUpgAppRespUpdate(obj)
			}
		} else {
			rctr.OnUpgAppRespDelete(obj)
		}
	}
}

type UpgAppRespReactor interface {
	OnUpgAppRespCreate(obj *UpgAppResp)
	OnUpgAppRespUpdate(obj *UpgAppResp)
	OnUpgAppRespDelete(obj *UpgAppResp)
}

func (obj *UpgAppResp) GetPath() string {
	return "UpgAppResp" + "|" + obj.GetKeyString()
}

func newUpgAppRespFromMessage(msg *UpgAppResp_) *UpgAppResp {
	return &UpgAppResp{
		meta:          msg.Meta,
		key:           msg.Key,
		upgAppRespVal: msg.UpgAppRespVal,
		upgAppRespStr: msg.UpgAppRespStr,
	}
}

func upgAppRespFactory(sdkClient gosdk.Client, data []byte) (gosdk.BaseObject, error) {
	var msg UpgAppResp_
	err := proto.Unmarshal(data, &msg)
	if err != nil {
		return nil, err
	}
	w := newUpgAppRespFromMessage(&msg)
	w.sdkClient = sdkClient
	return w, nil
}

func UpgAppRespMount(client gosdk.Client, mode delphi.MountMode) {
	client.MountKind("UpgAppResp", mode)
}

func UpgAppRespWatch(client gosdk.Client, reactor UpgAppRespReactor) {
	client.WatchKind("UpgAppResp", reactor)
}

type UpgApp struct {
	sdkClient gosdk.Client
	parent    delphiWrapper
	meta      *delphi.ObjectMeta
	key       string
}

func (o *UpgApp) GetMeta() *delphi.ObjectMeta {
	return o.meta
}

func (o *UpgApp) SetMeta(val *delphi.ObjectMeta) {
	o.meta = val
	o.bubbleSave()
}

func (o *UpgApp) GetKey() string {
	return o.key
}

func (o *UpgApp) SetKey(val string) {
	o.key = val
	o.bubbleSave()
}

func (o *UpgApp) bubbleSave() {
	if o.parent != nil {
		o.parent.bubbleSave()
	} else {
		o.save()
	}
}

func (o *UpgApp) save() {
	if o.GetKeyString() != "" {
		o.sdkClient.SetObject(o)
	}
}

func (o *UpgApp) Delete() {
	o.sdkClient.DeleteObject(o)
}

func NewUpgApp(sdkClient gosdk.Client) *UpgApp {
	w := &UpgApp{}
	w.sdkClient = sdkClient
	w.meta = &delphi.ObjectMeta{
		Kind: "UpgApp",
	}
	return w
}

func NewUpgAppWithKey(sdkClient gosdk.Client, key string) *UpgApp {
	w := NewUpgApp(sdkClient)
	w.SetKey(key)
	return w
}

func GetUpgApp(sdkClient gosdk.Client, key string) *UpgApp {
	lookupKey := fmt.Sprintf("%v", key)
	b := sdkClient.GetObject("UpgApp", lookupKey)
	if b == nil {
		return nil
	}
	o, ok := b.(*UpgApp)
	if !ok {
		panic("Couldn't cast to UpgApp")
	}
	return o
}

func childNewUpgApp(parent delphiWrapper, sdkClient gosdk.Client) *UpgApp {
	w := NewUpgApp(sdkClient)
	w.parent = parent
	return w
}

func childNewUpgAppWithValue(parent delphiWrapper, sdkClient gosdk.Client, value *UpgApp) *UpgApp {
	w := childNewUpgApp(parent, sdkClient)
	w.key = value.key
	return w
}

func (o *UpgApp) GetProtoMsg() *UpgApp_ {
	return &UpgApp_{
		Meta: o.meta,
		Key:  o.key,
	}
}

func (o *UpgApp) GetMessage() proto.Message {
	return o.GetProtoMsg()
}

func (obj *UpgApp) GetKeyString() string {
	return fmt.Sprintf("%v", (obj.key))
}

func (obj *UpgApp) TriggerEvent(oldObj gosdk.BaseObject, op delphi.ObjectOperation, rl []gosdk.BaseReactor) {
	for _, r := range rl {
		rctr, ok := r.(UpgAppReactor)
		if ok == false {
			panic("Not a Reactor")
		}
		if op == delphi.ObjectOperation_SetOp {
			if oldObj == nil {
				rctr.OnUpgAppCreate(obj)
			} else {
				rctr.OnUpgAppUpdate(obj)
			}
		} else {
			rctr.OnUpgAppDelete(obj)
		}
	}
}

type UpgAppReactor interface {
	OnUpgAppCreate(obj *UpgApp)
	OnUpgAppUpdate(obj *UpgApp)
	OnUpgAppDelete(obj *UpgApp)
}

func (obj *UpgApp) GetPath() string {
	return "UpgApp" + "|" + obj.GetKeyString()
}

func newUpgAppFromMessage(msg *UpgApp_) *UpgApp {
	return &UpgApp{
		meta: msg.Meta,
		key:  msg.Key,
	}
}

func upgAppFactory(sdkClient gosdk.Client, data []byte) (gosdk.BaseObject, error) {
	var msg UpgApp_
	err := proto.Unmarshal(data, &msg)
	if err != nil {
		return nil, err
	}
	w := newUpgAppFromMessage(&msg)
	w.sdkClient = sdkClient
	return w, nil
}

func UpgAppMount(client gosdk.Client, mode delphi.MountMode) {
	client.MountKind("UpgApp", mode)
}

func UpgAppWatch(client gosdk.Client, reactor UpgAppReactor) {
	client.WatchKind("UpgApp", reactor)
}

type StringArray struct {
	parent delphiWrapper
	values []string
}

func (arr *StringArray) Append(value string) {
	arr.values = append(arr.values, value)
	arr.parent.bubbleSave()
}

func (arr *StringArray) Get(pos int) string {
	return arr.values[pos]
}

func (arr *StringArray) Length() int {
	return len(arr.values)
}

func newStringArrayFromMessage(msg []string) *StringArray {
	arr := new(StringArray)
	arr.values = make([]string, len(msg))
	copy(arr.values, msg)
	return arr
}

func childNewStringArray(parent delphiWrapper, sdkClient gosdk.Client) *StringArray {
	arr := new(StringArray)
	arr.values = make([]string, 0)
	arr.parent = parent
	return arr
}

func childNewStringArrayWithValue(parent delphiWrapper, sdkClient gosdk.Client, value *StringArray) *StringArray {
	arr := childNewStringArray(parent, sdkClient)
	for _, v := range value.values {
		arr.values = append(arr.values, v)
	}
	return arr
}

func (arr *StringArray) GetProtoMsg() []string {
	v := make([]string, len(arr.values))
	copy(v, arr.values)
	return v
}

func init() {
	proto.RegisterType((*UpgReq_)(nil), "upgrade.UpgReq_")
	proto.RegisterType((*UpgResp_)(nil), "upgrade.UpgResp_")
	proto.RegisterType((*UpgStateReq_)(nil), "upgrade.UpgStateReq_")
	proto.RegisterType((*UpgAppResp_)(nil), "upgrade.UpgAppResp_")
	proto.RegisterType((*UpgApp_)(nil), "upgrade.UpgApp_")
	gosdk.RegisterFactory("UpgReq", upgReqFactory)
	gosdk.RegisterFactory("UpgResp", upgRespFactory)
	gosdk.RegisterFactory("UpgStateReq", upgStateReqFactory)
	gosdk.RegisterFactory("UpgAppResp", upgAppRespFactory)
	gosdk.RegisterFactory("UpgApp", upgAppFactory)
	proto.RegisterEnum("upgrade.UpgReqType", UpgReqType_name, UpgReqType_value)
	proto.RegisterEnum("upgrade.UpgRespType", UpgRespType_name, UpgRespType_value)
	proto.RegisterEnum("upgrade.UpgReqStateType", UpgReqStateType_name, UpgReqStateType_value)
	proto.RegisterEnum("upgrade.UpgRespStateType", UpgRespStateType_name, UpgRespStateType_value)
	proto.RegisterEnum("upgrade.UpgType", UpgType_name, UpgType_value)
}

func init() { proto.RegisterFile("nic/upgrade_manager/upgrade/upgrade.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 720 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x95, 0xcd, 0x6e, 0xd3, 0x4c,
	0x14, 0x86, 0xeb, 0x24, 0x6d, 0x9a, 0x93, 0xbf, 0xc9, 0x69, 0xd2, 0x2f, 0xfd, 0xc4, 0x22, 0xaa,
	0xaa, 0x2a, 0x64, 0xd1, 0x8a, 0xb4, 0x02, 0xd4, 0x15, 0x69, 0x0b, 0x52, 0x85, 0x80, 0xe0, 0xb4,
	0x6c, 0xab, 0x69, 0x3c, 0x4a, 0x8d, 0x1c, 0x7b, 0xb0, 0x9d, 0xa2, 0xee, 0x10, 0x97, 0xc0, 0x86,
	0xbb, 0x60, 0x8b, 0xc4, 0x15, 0x70, 0x59, 0xc8, 0x67, 0xc6, 0xd8, 0x4e, 0x09, 0x91, 0xe8, 0xca,
	0x9e, 0x77, 0x9e, 0xf3, 0xf6, 0xfc, 0xd5, 0x81, 0x87, 0xae, 0x3d, 0xde, 0x9f, 0xc9, 0x89, 0xcf,
	0x2d, 0x71, 0x39, 0xe5, 0x2e, 0x9f, 0x08, 0x3f, 0x3e, 0xc7, 0xcf, 0x3d, 0xe9, 0x7b, 0xa1, 0x87,
	0x45, 0x7d, 0xfc, 0x7f, 0x27, 0x8a, 0xb1, 0x84, 0x23, 0xaf, 0xed, 0x7d, 0xba, 0x8a, 0x0f, 0xea,
	0xa1, 0xf0, 0xed, 0xcf, 0x06, 0x14, 0x2f, 0xe4, 0xc4, 0x14, 0x1f, 0x2e, 0x71, 0x17, 0x0a, 0xaf,
	0x44, 0xc8, 0xdb, 0x46, 0xc7, 0xe8, 0x96, 0xfb, 0xb8, 0xa7, 0xc1, 0x37, 0x57, 0xef, 0xc5, 0x38,
	0x8c, 0x6e, 0x4c, 0xba, 0x47, 0x06, 0xf9, 0x97, 0xe2, 0xb6, 0x9d, 0xeb, 0x18, 0xdd, 0xaa, 0x19,
	0xbd, 0xe2, 0x13, 0x28, 0x29, 0x93, 0x93, 0xa9, 0xd5, 0xce, 0x77, 0x8c, 0x6e, 0xad, 0xbf, 0xb1,
	0x17, 0xe7, 0xa5, 0x6e, 0xce, 0x6f, 0xa5, 0x38, 0x2e, 0x7c, 0xfa, 0xba, 0x6d, 0x98, 0x09, 0x7b,
	0x44, 0xc2, 0xf6, 0x37, 0x03, 0xd6, 0x49, 0x0b, 0xe4, 0x7d, 0xb2, 0x38, 0x02, 0xd0, 0x2e, 0xef,
	0xb8, 0xa3, 0xd3, 0x68, 0x66, 0xd3, 0x08, 0x64, 0x2a, 0x8f, 0x14, 0x8d, 0xbb, 0x50, 0xd3, 0xa7,
	0x17, 0xdc, 0x76, 0x46, 0xa1, 0xdf, 0x2e, 0x74, 0xf2, 0xdd, 0x92, 0x39, 0xa7, 0xea, 0x84, 0x7f,
	0x1a, 0x50, 0xb9, 0x90, 0x93, 0x51, 0xc8, 0x43, 0x71, 0xcf, 0xd6, 0x3d, 0x83, 0xb2, 0x6a, 0x07,
	0x99, 0xe9, 0xac, 0xdb, 0x73, 0xcd, 0xa3, 0xbb, 0x54, 0xe6, 0xe9, 0x10, 0x7c, 0xac, 0xcb, 0xa6,
	0x16, 0xb7, 0x0b, 0x64, 0xc0, 0xd2, 0x06, 0x77, 0x4a, 0x26, 0x52, 0x97, 0xf2, 0xc3, 0xa0, 0x04,
	0x06, 0x52, 0xfe, 0x73, 0xfb, 0x4b, 0xaa, 0x92, 0xe7, 0x50, 0x4d, 0x8c, 0x92, 0x09, 0x6c, 0xcd,
	0x4f, 0x60, 0xbe, 0x98, 0x6c, 0x14, 0xee, 0xa4, 0x6d, 0xd4, 0x20, 0xa2, 0x3f, 0x91, 0x15, 0x75,
	0xf2, 0x67, 0xb4, 0xbc, 0x03, 0x79, 0x9f, 0xbc, 0x95, 0x55, 0xef, 0x69, 0xba, 0x8b, 0x58, 0x03,
	0x38, 0x73, 0x6f, 0xb8, 0x63, 0x5b, 0x27, 0x53, 0x8b, 0xad, 0x60, 0x85, 0x16, 0x74, 0x14, 0x72,
	0x3f, 0x64, 0x86, 0x3e, 0x0d, 0xae, 0x3c, 0x3f, 0x64, 0xb9, 0xde, 0x40, 0x4f, 0x50, 0xed, 0x16,
	0xd6, 0x7f, 0x1f, 0x87, 0x3c, 0x08, 0xd8, 0x4a, 0x4a, 0x88, 0x96, 0x88, 0x19, 0xc8, 0x68, 0x79,
	0x22, 0x21, 0xb6, 0xf8, 0x9e, 0x83, 0xfa, 0xdc, 0xa4, 0xa3, 0x14, 0x94, 0x64, 0x8e, 0x6f, 0x2c,
	0x65, 0x33, 0xf4, 0x45, 0xbc, 0x75, 0xcc, 0xc0, 0x16, 0x34, 0x86, 0xbe, 0x37, 0x16, 0x41, 0x20,
	0x82, 0xb7, 0x33, 0x5b, 0x04, 0x63, 0x61, 0xb1, 0x1c, 0x22, 0xd4, 0x86, 0x5e, 0x10, 0x1e, 0xdb,
	0xae, 0x29, 0x02, 0x4a, 0x38, 0x8f, 0x1d, 0x78, 0x70, 0xca, 0x43, 0x2e, 0x1d, 0xee, 0x8a, 0x53,
	0xef, 0xa3, 0x1b, 0xda, 0x53, 0x31, 0xbc, 0xe6, 0x81, 0x78, 0xa4, 0x4a, 0x2a, 0x2c, 0x26, 0xfa,
	0x8a, 0x58, 0x5d, 0x4c, 0x1c, 0x28, 0x62, 0x6d, 0x31, 0x71, 0xa8, 0x88, 0x22, 0x96, 0xa1, 0x78,
	0xe2, 0x08, 0xee, 0xce, 0x24, 0x5b, 0xd7, 0x05, 0x8e, 0x66, 0xe3, 0xa8, 0x04, 0x56, 0xc2, 0x2a,
	0x7d, 0x44, 0xa2, 0x1e, 0x09, 0x8b, 0x81, 0xbe, 0xa6, 0x0e, 0x09, 0x8b, 0x95, 0xb1, 0x09, 0x2c,
	0x2e, 0xfe, 0x5c, 0xf8, 0x53, 0xdb, 0xe5, 0x0e, 0xab, 0xf4, 0xbe, 0xac, 0x92, 0x9c, 0xd9, 0xab,
	0xa8, 0x05, 0x49, 0xeb, 0xf4, 0x14, 0x32, 0x9a, 0x1e, 0xc4, 0x06, 0xd4, 0x53, 0x2d, 0x25, 0x30,
	0x37, 0x27, 0x12, 0x99, 0xc7, 0x2d, 0x68, 0xdd, 0xe9, 0x35, 0xf1, 0x85, 0x3f, 0x5e, 0x51, 0xd4,
	0x2a, 0x6e, 0x02, 0x66, 0x47, 0x41, 0x21, 0x6b, 0x77, 0x75, 0xe2, 0x8b, 0xb8, 0x03, 0x9d, 0xbf,
	0x8d, 0x89, 0xa2, 0xd7, 0x97, 0x51, 0xe4, 0x55, 0x5a, 0x4c, 0xf5, 0x13, 0x2f, 0x58, 0x46, 0x91,
	0x57, 0x79, 0x31, 0x75, 0x90, 0x78, 0x55, 0x96, 0x51, 0xe4, 0x55, 0x5d, 0x4c, 0x1d, 0x26, 0x5e,
	0xb5, 0x65, 0x14, 0x79, 0xd5, 0xa3, 0x7f, 0x09, 0xbd, 0x4e, 0x14, 0xc6, 0x52, 0x02, 0x11, 0x0d,
	0x3d, 0x75, 0xbd, 0x63, 0x04, 0x61, 0x56, 0x23, 0x6e, 0x03, 0x1b, 0xf4, 0xd1, 0x51, 0xbb, 0x47,
	0x58, 0x33, 0x23, 0x11, 0xd5, 0xd2, 0x91, 0x7a, 0x25, 0x09, 0xdb, 0xcc, 0x6a, 0xc4, 0xfd, 0xd7,
	0x3b, 0xa2, 0xcf, 0x12, 0xad, 0x62, 0x0b, 0x1a, 0xfa, 0xf5, 0xd4, 0x0e, 0xfc, 0x99, 0x0c, 0xed,
	0x1b, 0xc1, 0x56, 0xb0, 0x0d, 0x4d, 0x2d, 0xbf, 0xf6, 0xdc, 0xd4, 0x8d, 0x71, 0xb5, 0x46, 0xbf,
	0xcb, 0x07, 0xbf, 0x02, 0x00, 0x00, 0xff, 0xff, 0xc3, 0xc7, 0x03, 0x45, 0xf3, 0x07, 0x00, 0x00,
}
