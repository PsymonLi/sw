// Code generated by protoc-gen-grpc-pensando DO NOT EDIT.

package nimbus

import (
	fmt "fmt"
	"sync"
	"time"

	protoTypes "github.com/gogo/protobuf/types"
	"github.com/pensando/sw/api"
	"github.com/pensando/sw/nic/agent/dscagent/types"
	"github.com/pensando/sw/nic/agent/protos/netproto"
	debugStats "github.com/pensando/sw/venice/utils/debug/stats"
	"github.com/pensando/sw/venice/utils/log"
	"github.com/pensando/sw/venice/utils/rpckit"
	"github.com/pkg/errors"
	context "golang.org/x/net/context"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/connectivity"
	"google.golang.org/grpc/status"
)

const maxOpretry = 10
const evChanLength = 10000
const resyncInterval = time.Minute * 5
const DefaultRPCTimeout = time.Second * 30

// NimbusClient is the nimbus client
type NimbusClient struct {
	sync.Mutex                        // lock the npm client
	clientName string                 // client's name
	srvURL     string                 // rpc server URL
	waitGrp    sync.WaitGroup         // wait group to wait on all go routines to exit
	rpcClient  *rpckit.RPCClient      // grpc client for watch
	objlocks   map[string]*sync.Mutex // object level locks
	debugStats *debugStats.Stats
}

// NewNimbusClient creates a new nimbus client
func NewNimbusClient(clientName, srvURL string, rpcClient *rpckit.RPCClient) (*NimbusClient, error) {
	// create NimbusClient object
	client := NimbusClient{
		clientName: clientName,
		srvURL:     srvURL,
		rpcClient:  rpcClient,
		objlocks:   make(map[string]*sync.Mutex),
	}

	client.debugStats = debugStats.New(clientName).Tsdb().Kind("nimbusClientStats").TsdbPeriod(5 * time.Second).Build()

	return &client, nil
}

// Wait waits for all watchers to exit
func (client *NimbusClient) Wait() {
	client.debugStats.Close()
	client.waitGrp.Wait()
}

//Does not implement, will dynamically validate when watch is called
type AggReactor interface {
}

type AggWatchOStream struct {
	sync.Mutex
	stream netproto.AggWatchApiV1_ObjectOperUpdateClient
}

// lockObject locks an object
func (client *NimbusClient) lockObject(kind string, ometa api.ObjectMeta) {
	objkey := fmt.Sprintf("%s/%s", kind, ometa.GetKey())

	client.Lock()
	objlock, ok := client.objlocks[objkey]
	if !ok {
		client.objlocks[objkey] = &sync.Mutex{}
		objlock = client.objlocks[objkey]
	}
	client.Unlock()
	objlock.Lock()
}

// unlockObject unlocks an object
func (client *NimbusClient) unlockObject(kind string, ometa api.ObjectMeta) {
	objkey := fmt.Sprintf("%s/%s", kind, ometa.GetKey())
	client.Lock()
	objlock, ok := client.objlocks[objkey]
	if ok {
		objlock.Unlock()
	}
	client.Unlock()
}

// watchAggWatchRecvLoop receives from stream and write it to a channel
func (client *NimbusClient) watchAggWatchRecvLoop(stream netproto.AggWatchApiV1_WatchObjectsClient, recvch chan<- *netproto.AggObjectEvent) {
	defer close(recvch)
	client.waitGrp.Add(1)
	defer client.waitGrp.Done()

	// loop till the end
	for {
		// receive from stream
		objList, err := stream.Recv()
		if err != nil {
			log.Errorf("Error receiving from watch channel. Exiting Agg watch. Err: %v", err)
			return
		}
		for _, evt := range objList.AggObjectEvents {
			recvch <- evt
		}
	}
}

// GetObject retrieves the runtime.Object from a svc watch event
func GetObject(obj *netproto.AggObject) (*protoTypes.DynamicAny, error) {
	robj := &protoTypes.DynamicAny{}
	err := protoTypes.UnmarshalAny(&obj.Object.Any, robj)
	if err != nil {
		return nil, err
	}
	return robj, nil
}

// processAggObjectWatchEvent handle agg watch event
func (client *NimbusClient) processAggObjectWatchEvent(evt netproto.AggObjectEvent, reactor AggReactor, ostream *AggWatchOStream) {
	client.waitGrp.Add(1)
	defer client.waitGrp.Done()

	object, err := GetObject(&evt.AggObj)
	if err != nil {
		log.Errorf("Invalid object for get %v", err)
		return
	}

	switch evt.AggObj.Kind {

	case "App":
		err = client.processAppDynamic(evt.EventType, object.Message.(*netproto.App), reactor.(AppReactor))

	case "Endpoint":
		err = client.processEndpointDynamic(evt.EventType, object.Message.(*netproto.Endpoint), reactor.(EndpointReactor))

	case "IPAMPolicy":
		err = client.processIPAMPolicyDynamic(evt.EventType, object.Message.(*netproto.IPAMPolicy), reactor.(IPAMPolicyReactor))

	case "Interface":
		err = client.processInterfaceDynamic(evt.EventType, object.Message.(*netproto.Interface), reactor.(InterfaceReactor))

	case "Network":
		err = client.processNetworkDynamic(evt.EventType, object.Message.(*netproto.Network), reactor.(NetworkReactor))

	case "NetworkSecurityPolicy":
		err = client.processNetworkSecurityPolicyDynamic(evt.EventType, object.Message.(*netproto.NetworkSecurityPolicy), reactor.(NetworkSecurityPolicyReactor))

	case "RoutingConfig":
		err = client.processRoutingConfigDynamic(evt.EventType, object.Message.(*netproto.RoutingConfig), reactor.(RoutingConfigReactor))

	case "SecurityProfile":
		err = client.processSecurityProfileDynamic(evt.EventType, object.Message.(*netproto.SecurityProfile), reactor.(SecurityProfileReactor))

	case "Vrf":
		err = client.processVrfDynamic(evt.EventType, object.Message.(*netproto.Vrf), reactor.(VrfReactor))

	}
	if err == nil {
		robj := netproto.AggObjectEvent{
			EventType: evt.EventType,
			AggObj:    evt.AggObj,
		}
		// send oper status
		ostream.Lock()
		err := ostream.stream.Send(&robj)
		if err != nil {
			log.Errorf("failed to send Agg oper Status, %s", err)
			client.debugStats.AddInt("AggOperSendError", 1)
		} else {
			client.debugStats.AddInt("AggOperSent", 1)
		}
		ostream.Unlock()
	}

}

// diffAppsDynamic diffs local state with controller state
func (client *NimbusClient) diffAppsDynamic(objList *netproto.AppList, reactor AppReactor,
	ostream *AggWatchOStream) {
	// build a map of objects
	objmap := make(map[string]*netproto.App)
	for _, obj := range objList.Apps {
		key := obj.ObjectMeta.GetKey()
		objmap[key] = obj
	}

	// see if we need to delete any locally found object
	o := netproto.App{
		TypeMeta: api.TypeMeta{Kind: "App"},
	}

	localObjs, err := reactor.HandleApp(types.List, o)
	if err != nil {
		log.Error(errors.Wrapf(types.ErrNimbusHandling, "Op: %s | Kind: App | Err: %v", types.Operation(types.List), err))
	}
	//localObjs := reactor.ListApp()
	for _, lobj := range localObjs {
		ctby, ok := lobj.ObjectMeta.Labels["CreatedBy"]
		if ok && ctby == "Venice" {
			key := lobj.ObjectMeta.GetKey()
			if _, ok := objmap[key]; !ok {
				evt := netproto.AppEvent{
					EventType: api.EventType_DeleteEvent,
					App:       lobj,
				}
				log.Infof("diffApps(): Deleting object %+v", lobj.ObjectMeta)
				client.lockObject(evt.App.GetObjectKind(), evt.App.ObjectMeta)
				client.processAppEvent(evt, reactor, nil)
			}
		} else {
			log.Infof("Not deleting non-venice object %+v", lobj.ObjectMeta)
		}
	}

	// add/update all new objects
	for _, obj := range objList.Apps {
		evt := netproto.AppEvent{
			EventType: api.EventType_UpdateEvent,
			App:       *obj,
		}
		client.lockObject(evt.App.GetObjectKind(), evt.App.ObjectMeta)
		err := client.processAppEvent(evt, reactor, nil)

		if err == nil {
			mobj, err := protoTypes.MarshalAny(obj)
			aggObj := netproto.AggObject{Kind: "App", Object: &api.Any{}}
			aggObj.Object.Any = *mobj
			robj := netproto.AggObjectEvent{
				EventType: api.EventType_UpdateEvent,
				AggObj:    aggObj,
			}
			// send oper status
			ostream.Lock()
			err = ostream.stream.Send(&robj)
			if err != nil {
				log.Errorf("failed to send Agg oper Status, %s", err)
				client.debugStats.AddInt("AggOperSendError", 1)
			} else {
				client.debugStats.AddInt("AggOperSent", 1)
			}
			ostream.Unlock()
		}
	}
}

// diffEndpointsDynamic diffs local state with controller state
func (client *NimbusClient) diffEndpointsDynamic(objList *netproto.EndpointList, reactor EndpointReactor,
	ostream *AggWatchOStream) {
	// build a map of objects
	objmap := make(map[string]*netproto.Endpoint)
	for _, obj := range objList.Endpoints {
		key := obj.ObjectMeta.GetKey()
		objmap[key] = obj
	}

	// see if we need to delete any locally found object
	o := netproto.Endpoint{
		TypeMeta: api.TypeMeta{Kind: "Endpoint"},
	}

	localObjs, err := reactor.HandleEndpoint(types.List, o)
	if err != nil {
		log.Error(errors.Wrapf(types.ErrNimbusHandling, "Op: %s | Kind: Endpoint | Err: %v", types.Operation(types.List), err))
	}
	//localObjs := reactor.ListEndpoint()
	for _, lobj := range localObjs {
		ctby, ok := lobj.ObjectMeta.Labels["CreatedBy"]
		if ok && ctby == "Venice" {
			key := lobj.ObjectMeta.GetKey()
			if _, ok := objmap[key]; !ok {
				evt := netproto.EndpointEvent{
					EventType: api.EventType_DeleteEvent,
					Endpoint:  lobj,
				}
				log.Infof("diffEndpoints(): Deleting object %+v", lobj.ObjectMeta)
				client.lockObject(evt.Endpoint.GetObjectKind(), evt.Endpoint.ObjectMeta)
				client.processEndpointEvent(evt, reactor, nil)
			}
		} else {
			log.Infof("Not deleting non-venice object %+v", lobj.ObjectMeta)
		}
	}

	// add/update all new objects
	for _, obj := range objList.Endpoints {
		evt := netproto.EndpointEvent{
			EventType: api.EventType_UpdateEvent,
			Endpoint:  *obj,
		}
		client.lockObject(evt.Endpoint.GetObjectKind(), evt.Endpoint.ObjectMeta)
		err := client.processEndpointEvent(evt, reactor, nil)

		if err == nil {
			mobj, err := protoTypes.MarshalAny(obj)
			aggObj := netproto.AggObject{Kind: "Endpoint", Object: &api.Any{}}
			aggObj.Object.Any = *mobj
			robj := netproto.AggObjectEvent{
				EventType: api.EventType_UpdateEvent,
				AggObj:    aggObj,
			}
			// send oper status
			ostream.Lock()
			err = ostream.stream.Send(&robj)
			if err != nil {
				log.Errorf("failed to send Agg oper Status, %s", err)
				client.debugStats.AddInt("AggOperSendError", 1)
			} else {
				client.debugStats.AddInt("AggOperSent", 1)
			}
			ostream.Unlock()
		}
	}
}

// diffIPAMPolicysDynamic diffs local state with controller state
func (client *NimbusClient) diffIPAMPolicysDynamic(objList *netproto.IPAMPolicyList, reactor IPAMPolicyReactor,
	ostream *AggWatchOStream) {
	// build a map of objects
	objmap := make(map[string]*netproto.IPAMPolicy)
	for _, obj := range objList.IPAMPolicys {
		key := obj.ObjectMeta.GetKey()
		objmap[key] = obj
	}

	// see if we need to delete any locally found object
	o := netproto.IPAMPolicy{
		TypeMeta: api.TypeMeta{Kind: "IPAMPolicy"},
	}

	localObjs, err := reactor.HandleIPAMPolicy(types.List, o)
	if err != nil {
		log.Error(errors.Wrapf(types.ErrNimbusHandling, "Op: %s | Kind: IPAMPolicy | Err: %v", types.Operation(types.List), err))
	}
	//localObjs := reactor.ListIPAMPolicy()
	for _, lobj := range localObjs {
		ctby, ok := lobj.ObjectMeta.Labels["CreatedBy"]
		if ok && ctby == "Venice" {
			key := lobj.ObjectMeta.GetKey()
			if _, ok := objmap[key]; !ok {
				evt := netproto.IPAMPolicyEvent{
					EventType:  api.EventType_DeleteEvent,
					IPAMPolicy: lobj,
				}
				log.Infof("diffIPAMPolicys(): Deleting object %+v", lobj.ObjectMeta)
				client.lockObject(evt.IPAMPolicy.GetObjectKind(), evt.IPAMPolicy.ObjectMeta)
				client.processIPAMPolicyEvent(evt, reactor, nil)
			}
		} else {
			log.Infof("Not deleting non-venice object %+v", lobj.ObjectMeta)
		}
	}

	// add/update all new objects
	for _, obj := range objList.IPAMPolicys {
		evt := netproto.IPAMPolicyEvent{
			EventType:  api.EventType_UpdateEvent,
			IPAMPolicy: *obj,
		}
		client.lockObject(evt.IPAMPolicy.GetObjectKind(), evt.IPAMPolicy.ObjectMeta)
		err := client.processIPAMPolicyEvent(evt, reactor, nil)

		if err == nil {
			mobj, err := protoTypes.MarshalAny(obj)
			aggObj := netproto.AggObject{Kind: "IPAMPolicy", Object: &api.Any{}}
			aggObj.Object.Any = *mobj
			robj := netproto.AggObjectEvent{
				EventType: api.EventType_UpdateEvent,
				AggObj:    aggObj,
			}
			// send oper status
			ostream.Lock()
			err = ostream.stream.Send(&robj)
			if err != nil {
				log.Errorf("failed to send Agg oper Status, %s", err)
				client.debugStats.AddInt("AggOperSendError", 1)
			} else {
				client.debugStats.AddInt("AggOperSent", 1)
			}
			ostream.Unlock()
		}
	}
}

// diffInterfacesDynamic diffs local state with controller state
func (client *NimbusClient) diffInterfacesDynamic(objList *netproto.InterfaceList, reactor InterfaceReactor,
	ostream *AggWatchOStream) {
	// build a map of objects
	objmap := make(map[string]*netproto.Interface)
	for _, obj := range objList.Interfaces {
		key := obj.ObjectMeta.GetKey()
		objmap[key] = obj
	}

	// see if we need to delete any locally found object
	o := netproto.Interface{
		TypeMeta: api.TypeMeta{Kind: "Interface"},
	}

	localObjs, err := reactor.HandleInterface(types.List, o)
	if err != nil {
		log.Error(errors.Wrapf(types.ErrNimbusHandling, "Op: %s | Kind: Interface | Err: %v", types.Operation(types.List), err))
	}
	//localObjs := reactor.ListInterface()
	for _, lobj := range localObjs {
		ctby, ok := lobj.ObjectMeta.Labels["CreatedBy"]
		if ok && ctby == "Venice" {
			key := lobj.ObjectMeta.GetKey()
			if _, ok := objmap[key]; !ok {
				evt := netproto.InterfaceEvent{
					EventType: api.EventType_DeleteEvent,
					Interface: lobj,
				}
				log.Infof("diffInterfaces(): Deleting object %+v", lobj.ObjectMeta)
				client.lockObject(evt.Interface.GetObjectKind(), evt.Interface.ObjectMeta)
				client.processInterfaceEvent(evt, reactor, nil)
			}
		} else {
			log.Infof("Not deleting non-venice object %+v", lobj.ObjectMeta)
		}
	}

	// add/update all new objects
	for _, obj := range objList.Interfaces {
		evt := netproto.InterfaceEvent{
			EventType: api.EventType_UpdateEvent,
			Interface: *obj,
		}
		client.lockObject(evt.Interface.GetObjectKind(), evt.Interface.ObjectMeta)
		err := client.processInterfaceEvent(evt, reactor, nil)

		if err == nil {
			mobj, err := protoTypes.MarshalAny(obj)
			aggObj := netproto.AggObject{Kind: "Interface", Object: &api.Any{}}
			aggObj.Object.Any = *mobj
			robj := netproto.AggObjectEvent{
				EventType: api.EventType_UpdateEvent,
				AggObj:    aggObj,
			}
			// send oper status
			ostream.Lock()
			err = ostream.stream.Send(&robj)
			if err != nil {
				log.Errorf("failed to send Agg oper Status, %s", err)
				client.debugStats.AddInt("AggOperSendError", 1)
			} else {
				client.debugStats.AddInt("AggOperSent", 1)
			}
			ostream.Unlock()
		}
	}
}

// diffNetworksDynamic diffs local state with controller state
func (client *NimbusClient) diffNetworksDynamic(objList *netproto.NetworkList, reactor NetworkReactor,
	ostream *AggWatchOStream) {
	// build a map of objects
	objmap := make(map[string]*netproto.Network)
	for _, obj := range objList.Networks {
		key := obj.ObjectMeta.GetKey()
		objmap[key] = obj
	}

	// see if we need to delete any locally found object
	o := netproto.Network{
		TypeMeta: api.TypeMeta{Kind: "Network"},
	}

	localObjs, err := reactor.HandleNetwork(types.List, o)
	if err != nil {
		log.Error(errors.Wrapf(types.ErrNimbusHandling, "Op: %s | Kind: Network | Err: %v", types.Operation(types.List), err))
	}
	//localObjs := reactor.ListNetwork()
	for _, lobj := range localObjs {
		ctby, ok := lobj.ObjectMeta.Labels["CreatedBy"]
		if ok && ctby == "Venice" {
			key := lobj.ObjectMeta.GetKey()
			if _, ok := objmap[key]; !ok {
				evt := netproto.NetworkEvent{
					EventType: api.EventType_DeleteEvent,
					Network:   lobj,
				}
				log.Infof("diffNetworks(): Deleting object %+v", lobj.ObjectMeta)
				client.lockObject(evt.Network.GetObjectKind(), evt.Network.ObjectMeta)
				client.processNetworkEvent(evt, reactor, nil)
			}
		} else {
			log.Infof("Not deleting non-venice object %+v", lobj.ObjectMeta)
		}
	}

	// add/update all new objects
	for _, obj := range objList.Networks {
		evt := netproto.NetworkEvent{
			EventType: api.EventType_UpdateEvent,
			Network:   *obj,
		}
		client.lockObject(evt.Network.GetObjectKind(), evt.Network.ObjectMeta)
		err := client.processNetworkEvent(evt, reactor, nil)

		if err == nil {
			mobj, err := protoTypes.MarshalAny(obj)
			aggObj := netproto.AggObject{Kind: "Network", Object: &api.Any{}}
			aggObj.Object.Any = *mobj
			robj := netproto.AggObjectEvent{
				EventType: api.EventType_UpdateEvent,
				AggObj:    aggObj,
			}
			// send oper status
			ostream.Lock()
			err = ostream.stream.Send(&robj)
			if err != nil {
				log.Errorf("failed to send Agg oper Status, %s", err)
				client.debugStats.AddInt("AggOperSendError", 1)
			} else {
				client.debugStats.AddInt("AggOperSent", 1)
			}
			ostream.Unlock()
		}
	}
}

// diffNetworkSecurityPolicysDynamic diffs local state with controller state
func (client *NimbusClient) diffNetworkSecurityPolicysDynamic(objList *netproto.NetworkSecurityPolicyList, reactor NetworkSecurityPolicyReactor,
	ostream *AggWatchOStream) {
	// build a map of objects
	objmap := make(map[string]*netproto.NetworkSecurityPolicy)
	for _, obj := range objList.NetworkSecurityPolicys {
		key := obj.ObjectMeta.GetKey()
		objmap[key] = obj
	}

	// see if we need to delete any locally found object
	o := netproto.NetworkSecurityPolicy{
		TypeMeta: api.TypeMeta{Kind: "NetworkSecurityPolicy"},
	}

	localObjs, err := reactor.HandleNetworkSecurityPolicy(types.List, o)
	if err != nil {
		log.Error(errors.Wrapf(types.ErrNimbusHandling, "Op: %s | Kind: NetworkSecurityPolicy | Err: %v", types.Operation(types.List), err))
	}
	//localObjs := reactor.ListNetworkSecurityPolicy()
	for _, lobj := range localObjs {
		ctby, ok := lobj.ObjectMeta.Labels["CreatedBy"]
		if ok && ctby == "Venice" {
			key := lobj.ObjectMeta.GetKey()
			if _, ok := objmap[key]; !ok {
				evt := netproto.NetworkSecurityPolicyEvent{
					EventType:             api.EventType_DeleteEvent,
					NetworkSecurityPolicy: lobj,
				}
				log.Infof("diffNetworkSecurityPolicys(): Deleting object %+v", lobj.ObjectMeta)
				client.lockObject(evt.NetworkSecurityPolicy.GetObjectKind(), evt.NetworkSecurityPolicy.ObjectMeta)
				client.processNetworkSecurityPolicyEvent(evt, reactor, nil)
			}
		} else {
			log.Infof("Not deleting non-venice object %+v", lobj.ObjectMeta)
		}
	}

	// add/update all new objects
	for _, obj := range objList.NetworkSecurityPolicys {
		evt := netproto.NetworkSecurityPolicyEvent{
			EventType:             api.EventType_UpdateEvent,
			NetworkSecurityPolicy: *obj,
		}
		client.lockObject(evt.NetworkSecurityPolicy.GetObjectKind(), evt.NetworkSecurityPolicy.ObjectMeta)
		err := client.processNetworkSecurityPolicyEvent(evt, reactor, nil)

		if err == nil {
			mobj, err := protoTypes.MarshalAny(obj)
			aggObj := netproto.AggObject{Kind: "NetworkSecurityPolicy", Object: &api.Any{}}
			aggObj.Object.Any = *mobj
			robj := netproto.AggObjectEvent{
				EventType: api.EventType_UpdateEvent,
				AggObj:    aggObj,
			}
			// send oper status
			ostream.Lock()
			err = ostream.stream.Send(&robj)
			if err != nil {
				log.Errorf("failed to send Agg oper Status, %s", err)
				client.debugStats.AddInt("AggOperSendError", 1)
			} else {
				client.debugStats.AddInt("AggOperSent", 1)
			}
			ostream.Unlock()
		}
	}
}

// diffRoutingConfigsDynamic diffs local state with controller state
func (client *NimbusClient) diffRoutingConfigsDynamic(objList *netproto.RoutingConfigList, reactor RoutingConfigReactor,
	ostream *AggWatchOStream) {
	// build a map of objects
	objmap := make(map[string]*netproto.RoutingConfig)
	for _, obj := range objList.RoutingConfigs {
		key := obj.ObjectMeta.GetKey()
		objmap[key] = obj
	}

	// see if we need to delete any locally found object
	o := netproto.RoutingConfig{
		TypeMeta: api.TypeMeta{Kind: "RoutingConfig"},
	}

	localObjs, err := reactor.HandleRoutingConfig(types.List, o)
	if err != nil {
		log.Error(errors.Wrapf(types.ErrNimbusHandling, "Op: %s | Kind: RoutingConfig | Err: %v", types.Operation(types.List), err))
	}
	//localObjs := reactor.ListRoutingConfig()
	for _, lobj := range localObjs {
		ctby, ok := lobj.ObjectMeta.Labels["CreatedBy"]
		if ok && ctby == "Venice" {
			key := lobj.ObjectMeta.GetKey()
			if _, ok := objmap[key]; !ok {
				evt := netproto.RoutingConfigEvent{
					EventType:     api.EventType_DeleteEvent,
					RoutingConfig: lobj,
				}
				log.Infof("diffRoutingConfigs(): Deleting object %+v", lobj.ObjectMeta)
				client.lockObject(evt.RoutingConfig.GetObjectKind(), evt.RoutingConfig.ObjectMeta)
				client.processRoutingConfigEvent(evt, reactor, nil)
			}
		} else {
			log.Infof("Not deleting non-venice object %+v", lobj.ObjectMeta)
		}
	}

	// add/update all new objects
	for _, obj := range objList.RoutingConfigs {
		evt := netproto.RoutingConfigEvent{
			EventType:     api.EventType_UpdateEvent,
			RoutingConfig: *obj,
		}
		client.lockObject(evt.RoutingConfig.GetObjectKind(), evt.RoutingConfig.ObjectMeta)
		err := client.processRoutingConfigEvent(evt, reactor, nil)

		if err == nil {
			mobj, err := protoTypes.MarshalAny(obj)
			aggObj := netproto.AggObject{Kind: "RoutingConfig", Object: &api.Any{}}
			aggObj.Object.Any = *mobj
			robj := netproto.AggObjectEvent{
				EventType: api.EventType_UpdateEvent,
				AggObj:    aggObj,
			}
			// send oper status
			ostream.Lock()
			err = ostream.stream.Send(&robj)
			if err != nil {
				log.Errorf("failed to send Agg oper Status, %s", err)
				client.debugStats.AddInt("AggOperSendError", 1)
			} else {
				client.debugStats.AddInt("AggOperSent", 1)
			}
			ostream.Unlock()
		}
	}
}

// diffSecurityProfilesDynamic diffs local state with controller state
func (client *NimbusClient) diffSecurityProfilesDynamic(objList *netproto.SecurityProfileList, reactor SecurityProfileReactor,
	ostream *AggWatchOStream) {
	// build a map of objects
	objmap := make(map[string]*netproto.SecurityProfile)
	for _, obj := range objList.SecurityProfiles {
		key := obj.ObjectMeta.GetKey()
		objmap[key] = obj
	}

	// see if we need to delete any locally found object
	o := netproto.SecurityProfile{
		TypeMeta: api.TypeMeta{Kind: "SecurityProfile"},
	}

	localObjs, err := reactor.HandleSecurityProfile(types.List, o)
	if err != nil {
		log.Error(errors.Wrapf(types.ErrNimbusHandling, "Op: %s | Kind: SecurityProfile | Err: %v", types.Operation(types.List), err))
	}
	//localObjs := reactor.ListSecurityProfile()
	for _, lobj := range localObjs {
		ctby, ok := lobj.ObjectMeta.Labels["CreatedBy"]
		if ok && ctby == "Venice" {
			key := lobj.ObjectMeta.GetKey()
			if _, ok := objmap[key]; !ok {
				evt := netproto.SecurityProfileEvent{
					EventType:       api.EventType_DeleteEvent,
					SecurityProfile: lobj,
				}
				log.Infof("diffSecurityProfiles(): Deleting object %+v", lobj.ObjectMeta)
				client.lockObject(evt.SecurityProfile.GetObjectKind(), evt.SecurityProfile.ObjectMeta)
				client.processSecurityProfileEvent(evt, reactor, nil)
			}
		} else {
			log.Infof("Not deleting non-venice object %+v", lobj.ObjectMeta)
		}
	}

	// add/update all new objects
	for _, obj := range objList.SecurityProfiles {
		evt := netproto.SecurityProfileEvent{
			EventType:       api.EventType_UpdateEvent,
			SecurityProfile: *obj,
		}
		client.lockObject(evt.SecurityProfile.GetObjectKind(), evt.SecurityProfile.ObjectMeta)
		err := client.processSecurityProfileEvent(evt, reactor, nil)

		if err == nil {
			mobj, err := protoTypes.MarshalAny(obj)
			aggObj := netproto.AggObject{Kind: "SecurityProfile", Object: &api.Any{}}
			aggObj.Object.Any = *mobj
			robj := netproto.AggObjectEvent{
				EventType: api.EventType_UpdateEvent,
				AggObj:    aggObj,
			}
			// send oper status
			ostream.Lock()
			err = ostream.stream.Send(&robj)
			if err != nil {
				log.Errorf("failed to send Agg oper Status, %s", err)
				client.debugStats.AddInt("AggOperSendError", 1)
			} else {
				client.debugStats.AddInt("AggOperSent", 1)
			}
			ostream.Unlock()
		}
	}
}

// diffVrfsDynamic diffs local state with controller state
func (client *NimbusClient) diffVrfsDynamic(objList *netproto.VrfList, reactor VrfReactor,
	ostream *AggWatchOStream) {
	// build a map of objects
	objmap := make(map[string]*netproto.Vrf)
	for _, obj := range objList.Vrfs {
		key := obj.ObjectMeta.GetKey()
		objmap[key] = obj
	}

	// see if we need to delete any locally found object
	o := netproto.Vrf{
		TypeMeta: api.TypeMeta{Kind: "Vrf"},
	}

	localObjs, err := reactor.HandleVrf(types.List, o)
	if err != nil {
		log.Error(errors.Wrapf(types.ErrNimbusHandling, "Op: %s | Kind: Vrf | Err: %v", types.Operation(types.List), err))
	}
	//localObjs := reactor.ListVrf()
	for _, lobj := range localObjs {
		ctby, ok := lobj.ObjectMeta.Labels["CreatedBy"]
		if ok && ctby == "Venice" {
			key := lobj.ObjectMeta.GetKey()
			if _, ok := objmap[key]; !ok {
				evt := netproto.VrfEvent{
					EventType: api.EventType_DeleteEvent,
					Vrf:       lobj,
				}
				log.Infof("diffVrfs(): Deleting object %+v", lobj.ObjectMeta)
				client.lockObject(evt.Vrf.GetObjectKind(), evt.Vrf.ObjectMeta)
				client.processVrfEvent(evt, reactor, nil)
			}
		} else {
			log.Infof("Not deleting non-venice object %+v", lobj.ObjectMeta)
		}
	}

	// add/update all new objects
	for _, obj := range objList.Vrfs {
		evt := netproto.VrfEvent{
			EventType: api.EventType_UpdateEvent,
			Vrf:       *obj,
		}
		client.lockObject(evt.Vrf.GetObjectKind(), evt.Vrf.ObjectMeta)
		err := client.processVrfEvent(evt, reactor, nil)

		if err == nil {
			mobj, err := protoTypes.MarshalAny(obj)
			aggObj := netproto.AggObject{Kind: "Vrf", Object: &api.Any{}}
			aggObj.Object.Any = *mobj
			robj := netproto.AggObjectEvent{
				EventType: api.EventType_UpdateEvent,
				AggObj:    aggObj,
			}
			// send oper status
			ostream.Lock()
			err = ostream.stream.Send(&robj)
			if err != nil {
				log.Errorf("failed to send Agg oper Status, %s", err)
				client.debugStats.AddInt("AggOperSendError", 1)
			} else {
				client.debugStats.AddInt("AggOperSent", 1)
			}
			ostream.Unlock()
		}
	}
}

// diffApp diffs local state with controller state
// FIXME: this is not handling deletes today
func (client *NimbusClient) diffAggWatchObjects(objList *netproto.AggObjectList, reactor AggReactor, ostream *AggWatchOStream) {

	type listObject struct {
		kind    string
		objects interface{}
	}

	//This will order be diffed
	listOrderObjects := []*listObject{}

	addToListOrder := func(kind string, obj *protoTypes.DynamicAny) {
		for _, lobj := range listOrderObjects {
			if lobj.kind == kind {
				switch kind {

				case "App":
					msglist := lobj.objects.(*netproto.AppList)
					msglist.Apps = append(msglist.Apps, obj.Message.(*netproto.App))
					return

				case "Endpoint":
					msglist := lobj.objects.(*netproto.EndpointList)
					msglist.Endpoints = append(msglist.Endpoints, obj.Message.(*netproto.Endpoint))
					return

				case "IPAMPolicy":
					msglist := lobj.objects.(*netproto.IPAMPolicyList)
					msglist.IPAMPolicys = append(msglist.IPAMPolicys, obj.Message.(*netproto.IPAMPolicy))
					return

				case "Interface":
					msglist := lobj.objects.(*netproto.InterfaceList)
					msglist.Interfaces = append(msglist.Interfaces, obj.Message.(*netproto.Interface))
					return

				case "Network":
					msglist := lobj.objects.(*netproto.NetworkList)
					msglist.Networks = append(msglist.Networks, obj.Message.(*netproto.Network))
					return

				case "NetworkSecurityPolicy":
					msglist := lobj.objects.(*netproto.NetworkSecurityPolicyList)
					msglist.NetworkSecurityPolicys = append(msglist.NetworkSecurityPolicys, obj.Message.(*netproto.NetworkSecurityPolicy))
					return

				case "RoutingConfig":
					msglist := lobj.objects.(*netproto.RoutingConfigList)
					msglist.RoutingConfigs = append(msglist.RoutingConfigs, obj.Message.(*netproto.RoutingConfig))
					return

				case "SecurityProfile":
					msglist := lobj.objects.(*netproto.SecurityProfileList)
					msglist.SecurityProfiles = append(msglist.SecurityProfiles, obj.Message.(*netproto.SecurityProfile))
					return

				case "Vrf":
					msglist := lobj.objects.(*netproto.VrfList)
					msglist.Vrfs = append(msglist.Vrfs, obj.Message.(*netproto.Vrf))
					return

				}
			}
		}
		//This kind not added, create a new one
		listObj := &listObject{kind: kind}
		switch kind {

		case "App":
			listObj.objects = &netproto.AppList{}
			msglist := listObj.objects.(*netproto.AppList)
			msglist.Apps = append(msglist.Apps, obj.Message.(*netproto.App))

		case "Endpoint":
			listObj.objects = &netproto.EndpointList{}
			msglist := listObj.objects.(*netproto.EndpointList)
			msglist.Endpoints = append(msglist.Endpoints, obj.Message.(*netproto.Endpoint))

		case "IPAMPolicy":
			listObj.objects = &netproto.IPAMPolicyList{}
			msglist := listObj.objects.(*netproto.IPAMPolicyList)
			msglist.IPAMPolicys = append(msglist.IPAMPolicys, obj.Message.(*netproto.IPAMPolicy))

		case "Interface":
			listObj.objects = &netproto.InterfaceList{}
			msglist := listObj.objects.(*netproto.InterfaceList)
			msglist.Interfaces = append(msglist.Interfaces, obj.Message.(*netproto.Interface))

		case "Network":
			listObj.objects = &netproto.NetworkList{}
			msglist := listObj.objects.(*netproto.NetworkList)
			msglist.Networks = append(msglist.Networks, obj.Message.(*netproto.Network))

		case "NetworkSecurityPolicy":
			listObj.objects = &netproto.NetworkSecurityPolicyList{}
			msglist := listObj.objects.(*netproto.NetworkSecurityPolicyList)
			msglist.NetworkSecurityPolicys = append(msglist.NetworkSecurityPolicys, obj.Message.(*netproto.NetworkSecurityPolicy))

		case "RoutingConfig":
			listObj.objects = &netproto.RoutingConfigList{}
			msglist := listObj.objects.(*netproto.RoutingConfigList)
			msglist.RoutingConfigs = append(msglist.RoutingConfigs, obj.Message.(*netproto.RoutingConfig))

		case "SecurityProfile":
			listObj.objects = &netproto.SecurityProfileList{}
			msglist := listObj.objects.(*netproto.SecurityProfileList)
			msglist.SecurityProfiles = append(msglist.SecurityProfiles, obj.Message.(*netproto.SecurityProfile))

		case "Vrf":
			listObj.objects = &netproto.VrfList{}
			msglist := listObj.objects.(*netproto.VrfList)
			msglist.Vrfs = append(msglist.Vrfs, obj.Message.(*netproto.Vrf))

		}
		listOrderObjects = append(listOrderObjects, listObj)
	}

	for _, obj := range objList.Objects {
		object, err := GetObject(obj)
		if err != nil {
			log.Errorf("Invalid object for get %v", err)
			return
		}
		addToListOrder(obj.Kind, object)
	}

	for _, lobj := range listOrderObjects {
		switch lobj.kind {

		case "App":
			client.diffAppsDynamic(lobj.objects.(*netproto.AppList), reactor.(AppReactor), ostream)

		case "Endpoint":
			client.diffEndpointsDynamic(lobj.objects.(*netproto.EndpointList), reactor.(EndpointReactor), ostream)

		case "IPAMPolicy":
			client.diffIPAMPolicysDynamic(lobj.objects.(*netproto.IPAMPolicyList), reactor.(IPAMPolicyReactor), ostream)

		case "Interface":
			client.diffInterfacesDynamic(lobj.objects.(*netproto.InterfaceList), reactor.(InterfaceReactor), ostream)

		case "Network":
			client.diffNetworksDynamic(lobj.objects.(*netproto.NetworkList), reactor.(NetworkReactor), ostream)

		case "NetworkSecurityPolicy":
			client.diffNetworkSecurityPolicysDynamic(lobj.objects.(*netproto.NetworkSecurityPolicyList), reactor.(NetworkSecurityPolicyReactor), ostream)

		case "RoutingConfig":
			client.diffRoutingConfigsDynamic(lobj.objects.(*netproto.RoutingConfigList), reactor.(RoutingConfigReactor), ostream)

		case "SecurityProfile":
			client.diffSecurityProfilesDynamic(lobj.objects.(*netproto.SecurityProfileList), reactor.(SecurityProfileReactor), ostream)

		case "Vrf":
			client.diffVrfsDynamic(lobj.objects.(*netproto.VrfList), reactor.(VrfReactor), ostream)

		}
	}

}

func (client *NimbusClient) WatchAggregate(ctx context.Context, kinds []string, reactor AggReactor) error {

	// setup wait group
	client.waitGrp.Add(1)
	defer client.waitGrp.Done()
	client.debugStats.AddInt("ActiveAggWatch", 1)

	//Make sure all kinds are implemented by the reactor

	// make sure rpc client is good
	if client.rpcClient == nil || client.rpcClient.ClientConn == nil || client.rpcClient.ClientConn.GetState() != connectivity.Ready {
		log.Errorf("RPC client is disconnected. Exiting watch")
		return nil

	}

	aggKinds := api.AggWatchOptions{}
	for _, kind := range kinds {
		switch kind {

		case "App":
			//Make sure all kinds are implemented by the reactor to avoid later failures
			if _, ok := reactor.(AppReactor); !ok {
				return fmt.Errorf("Reactor does not implement %v", "AppReactor")
			}
			aggKind := api.KindWatchOptions{}
			aggKind.Kind = kind
			aggKinds.WatchOptions = append(aggKinds.WatchOptions, aggKind)

		case "Endpoint":
			//Make sure all kinds are implemented by the reactor to avoid later failures
			if _, ok := reactor.(EndpointReactor); !ok {
				return fmt.Errorf("Reactor does not implement %v", "EndpointReactor")
			}
			aggKind := api.KindWatchOptions{}
			aggKind.Kind = kind
			aggKinds.WatchOptions = append(aggKinds.WatchOptions, aggKind)

		case "IPAMPolicy":
			//Make sure all kinds are implemented by the reactor to avoid later failures
			if _, ok := reactor.(IPAMPolicyReactor); !ok {
				return fmt.Errorf("Reactor does not implement %v", "IPAMPolicyReactor")
			}
			aggKind := api.KindWatchOptions{}
			aggKind.Kind = kind
			aggKinds.WatchOptions = append(aggKinds.WatchOptions, aggKind)

		case "Interface":
			//Make sure all kinds are implemented by the reactor to avoid later failures
			if _, ok := reactor.(InterfaceReactor); !ok {
				return fmt.Errorf("Reactor does not implement %v", "InterfaceReactor")
			}
			aggKind := api.KindWatchOptions{}
			aggKind.Kind = kind
			aggKinds.WatchOptions = append(aggKinds.WatchOptions, aggKind)

		case "Network":
			//Make sure all kinds are implemented by the reactor to avoid later failures
			if _, ok := reactor.(NetworkReactor); !ok {
				return fmt.Errorf("Reactor does not implement %v", "NetworkReactor")
			}
			aggKind := api.KindWatchOptions{}
			aggKind.Kind = kind
			aggKinds.WatchOptions = append(aggKinds.WatchOptions, aggKind)

		case "NetworkSecurityPolicy":
			//Make sure all kinds are implemented by the reactor to avoid later failures
			if _, ok := reactor.(NetworkSecurityPolicyReactor); !ok {
				return fmt.Errorf("Reactor does not implement %v", "NetworkSecurityPolicyReactor")
			}
			aggKind := api.KindWatchOptions{}
			aggKind.Kind = kind
			aggKinds.WatchOptions = append(aggKinds.WatchOptions, aggKind)

		case "RoutingConfig":
			//Make sure all kinds are implemented by the reactor to avoid later failures
			if _, ok := reactor.(RoutingConfigReactor); !ok {
				return fmt.Errorf("Reactor does not implement %v", "RoutingConfigReactor")
			}
			aggKind := api.KindWatchOptions{}
			aggKind.Kind = kind
			aggKinds.WatchOptions = append(aggKinds.WatchOptions, aggKind)

		case "SecurityProfile":
			//Make sure all kinds are implemented by the reactor to avoid later failures
			if _, ok := reactor.(SecurityProfileReactor); !ok {
				return fmt.Errorf("Reactor does not implement %v", "SecurityProfileReactor")
			}
			aggKind := api.KindWatchOptions{}
			aggKind.Kind = kind
			aggKinds.WatchOptions = append(aggKinds.WatchOptions, aggKind)

		case "Vrf":
			//Make sure all kinds are implemented by the reactor to avoid later failures
			if _, ok := reactor.(VrfReactor); !ok {
				return fmt.Errorf("Reactor does not implement %v", "VrfReactor")
			}
			aggKind := api.KindWatchOptions{}
			aggKind.Kind = kind
			aggKinds.WatchOptions = append(aggKinds.WatchOptions, aggKind)

		}
	}

	// start the watch
	aggRPCClient := netproto.NewAggWatchApiV1Client(client.rpcClient.ClientConn)

	stream, err := aggRPCClient.WatchObjects(ctx, &aggKinds)
	if err != nil {
		log.Errorf("Error watching Aggregate watch for . Err: %v", err)
		return nil
	}

	// start oper update stream
	opStream, err := aggRPCClient.ObjectOperUpdate(ctx)
	if err != nil {
		log.Errorf("Error starting Aggregate oper updates. Err: %v", err)
		return nil
	}

	ostream := &AggWatchOStream{stream: opStream}

	// get a list of objects
	objList, err := aggRPCClient.ListObjects(ctx, &aggKinds)
	if err != nil {
		st, ok := status.FromError(err)
		if !ok || st.Code() == codes.Unavailable {
			log.Errorf("Error getting Aggregate list. Err: %v", err)
			return nil
		}
	} else {
		// perform a diff of the states
		client.diffAggWatchObjects(objList, reactor, ostream)

	}

	// start grpc stream recv
	recvCh := make(chan *netproto.AggObjectEvent, evChanLength)
	go client.watchAggWatchRecvLoop(stream, recvCh)

	// loop till the end
	for {
		evtWork := func(evt *netproto.AggObjectEvent) {
			client.debugStats.AddInt("AggWatchEvents", 1)
			client.processAggObjectWatchEvent(*evt, reactor, ostream)
		}
		//Give priority to evnt work.
		select {
		case evt, ok := <-recvCh:
			if !ok {
				log.Warnf("Agg Watch channel closed. Exisint AggWatch")
				return nil
			}
			evtWork(evt)
		case <-time.After(resyncInterval):
			//Give priority to evt work
			//Wait for batch interval for inflight work
			time.Sleep(5 * DefaultWatchHoldInterval)
			select {
			case evt, ok := <-recvCh:
				if !ok {
					log.Warnf("NetworkSecurityPolicy Watch channel closed. Exisint NetworkSecurityPolicyWatch")
					return nil
				}
				evtWork(evt)
				continue
			default:
			}

			// get a list of objects
			objList, err := aggRPCClient.ListObjects(ctx, &aggKinds)
			if err != nil {
				st, ok := status.FromError(err)
				if !ok || st.Code() == codes.Unavailable {
					log.Errorf("Error getting Aggregate list. Err: %v", err)
					return err
				}
			} else {
				// perform a diff of the states
				client.diffAggWatchObjects(objList, reactor, ostream)
			}
		}
	}
}
