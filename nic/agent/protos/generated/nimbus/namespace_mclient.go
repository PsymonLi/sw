// Code generated by protoc-gen-grpc-pensando DO NOT EDIT.

/*
Package nimbus is a auto generated package.
Input file: namespace.proto
*/

package nimbus

import (
	"context"
	"time"

	"github.com/pensando/sw/api"
	"github.com/pensando/sw/nic/agent/netagent/state"
	"github.com/pensando/sw/nic/agent/protos/netproto"
	"github.com/pensando/sw/venice/utils/log"
	"google.golang.org/grpc/connectivity"
)

type NamespaceReactor interface {
	CreateNamespace(namespace *netproto.Namespace) error            // creates an Namespace
	FindNamespace(meta api.ObjectMeta) (*netproto.Namespace, error) // finds an Namespace
	ListNamespace() []*netproto.Namespace                           // lists all Namespaces
	UpdateNamespace(namespace *netproto.Namespace) error            // updates an Namespace
	DeleteNamespace(namespace, ns, name string) error               // deletes an Namespace
}

// WatchNamespaces runs Namespace watcher loop
func (client *NimbusClient) WatchNamespaces(ctx context.Context, reactor NamespaceReactor) {
	// setup wait group
	client.waitGrp.Add(1)
	defer client.waitGrp.Done()
	client.debugStats.AddInt("ActiveNamespaceWatch", 1)

	// make sure rpc client is good
	if client.rpcClient == nil || client.rpcClient.ClientConn == nil || client.rpcClient.ClientConn.GetState() != connectivity.Ready {
		log.Errorf("RPC client is disconnected. Exiting watch")
		return
	}

	// start the watch
	namespaceRPCClient := netproto.NewNamespaceApiClient(client.rpcClient.ClientConn)
	stream, err := namespaceRPCClient.WatchNamespaces(ctx, &api.ObjectMeta{})
	if err != nil {
		log.Errorf("Error watching Namespace. Err: %v", err)
		return
	}

	// get a list of objects
	objList, err := namespaceRPCClient.ListNamespaces(ctx, &api.ObjectMeta{})
	if err != nil {
		log.Errorf("Error getting Namespace list. Err: %v", err)
		return
	}

	// perform a diff of the states
	client.diffNamespaces(objList, reactor)

	// start grpc stream recv
	recvCh := make(chan *netproto.NamespaceEvent, evChanLength)
	go client.watchNamespaceRecvLoop(stream, recvCh)

	// loop till the end
	for {
		select {
		case evt, ok := <-recvCh:
			if !ok {
				log.Warnf("Namespace Watch channel closed. Exisint NamespaceWatch")
				return
			}
			client.debugStats.AddInt("NamespaceWatchEvents", 1)

			log.Infof("Ctrlerif: agent %s got Namespace watch event: Type: {%+v} Namespace:{%+v}", client.clientName, evt.EventType, evt.Namespace)

			client.lockObject(evt.Namespace.GetObjectKind(), evt.Namespace.ObjectMeta)
			client.processNamespaceEvent(*evt, reactor)
		// periodic resync
		case <-time.After(resyncInterval):
			// get a list of objects
			objList, err := namespaceRPCClient.ListNamespaces(ctx, &api.ObjectMeta{})
			if err != nil {
				log.Errorf("Error getting Namespace list. Err: %v", err)
				return
			}
			client.debugStats.AddInt("NamespaceWatchResyncs", 1)

			// perform a diff of the states
			client.diffNamespaces(objList, reactor)
		}
	}
}

// watchNamespaceRecvLoop receives from stream and write it to a channel
func (client *NimbusClient) watchNamespaceRecvLoop(stream netproto.NamespaceApi_WatchNamespacesClient, recvch chan<- *netproto.NamespaceEvent) {
	defer close(recvch)
	client.waitGrp.Add(1)
	defer client.waitGrp.Done()

	// loop till the end
	for {
		// receive from stream
		evt, err := stream.Recv()
		if err != nil {
			log.Errorf("Error receiving from watch channel. Exiting Namespace watch. Err: %v", err)
			return
		}

		recvch <- evt
	}
}

// diffNamespace diffs local state with controller state
// FIXME: this is not handling deletes today
func (client *NimbusClient) diffNamespaces(objList *netproto.NamespaceList, reactor NamespaceReactor) {
	// build a map of objects
	objmap := make(map[string]*netproto.Namespace)
	for _, obj := range objList.Namespaces {
		key := obj.ObjectMeta.GetKey()
		objmap[key] = obj
	}

	// see if we need to delete any locally found object
	localObjs := reactor.ListNamespace()
	for _, lobj := range localObjs {
		key := lobj.ObjectMeta.GetKey()
		if _, ok := objmap[key]; !ok {
			evt := netproto.NamespaceEvent{
				EventType: api.EventType_DeleteEvent,
				Namespace: *lobj,
			}
			client.lockObject(evt.Namespace.GetObjectKind(), evt.Namespace.ObjectMeta)
			client.processNamespaceEvent(evt, reactor)
		}
	}

	// add/update all new objects
	for _, obj := range objList.Namespaces {
		evt := netproto.NamespaceEvent{
			EventType: api.EventType_CreateEvent,
			Namespace: *obj,
		}
		client.lockObject(evt.Namespace.GetObjectKind(), evt.Namespace.ObjectMeta)
		client.processNamespaceEvent(evt, reactor)
	}
}

// processNamespaceEvent handles Namespace event
func (client *NimbusClient) processNamespaceEvent(evt netproto.NamespaceEvent, reactor NamespaceReactor) {
	var err error
	client.waitGrp.Add(1)
	defer client.waitGrp.Done()

	// unlock the object once we are done
	defer client.unlockObject(evt.Namespace.GetObjectKind(), evt.Namespace.ObjectMeta)

	// retry till successful
	for iter := 0; iter < maxOpretry; iter++ {
		switch evt.EventType {
		case api.EventType_CreateEvent:
			fallthrough
		case api.EventType_UpdateEvent:
			_, err = reactor.FindNamespace(evt.Namespace.ObjectMeta)
			if err != nil {
				// create the Namespace
				err = reactor.CreateNamespace(&evt.Namespace)
				if err != nil {
					log.Errorf("Error creating the Namespace {%+v}. Err: %v", evt.Namespace, err)
					client.debugStats.AddInt("CreateNamespaceError", 1)
				} else {
					client.debugStats.AddInt("CreateNamespace", 1)
				}
			} else {
				// update the Namespace
				err = reactor.UpdateNamespace(&evt.Namespace)
				if err != nil {
					log.Errorf("Error updating the Namespace {%+v}. Err: %v", evt.Namespace, err)
					client.debugStats.AddInt("UpdateNamespaceError", 1)
				} else {
					client.debugStats.AddInt("UpdateNamespace", 1)
				}
			}

		case api.EventType_DeleteEvent:
			// delete the object
			err = reactor.DeleteNamespace(evt.Namespace.Tenant, evt.Namespace.Namespace, evt.Namespace.Name)
			if err == state.ErrObjectNotFound { // give idempotency to caller
				log.Debugf("Namespace {%+v} not found", evt.Namespace.ObjectMeta)
				err = nil
			}
			if err != nil {
				log.Errorf("Error deleting the Namespace {%+v}. Err: %v", evt.Namespace.ObjectMeta, err)
				client.debugStats.AddInt("DeleteNamespaceError", 1)
			} else {
				client.debugStats.AddInt("DeleteNamespace", 1)
			}
		}

		// return if there is no error
		if err == nil {
			if evt.EventType == api.EventType_CreateEvent || evt.EventType == api.EventType_UpdateEvent {
				robj := netproto.Namespace{
					TypeMeta:   evt.Namespace.TypeMeta,
					ObjectMeta: evt.Namespace.ObjectMeta,
					Status:     evt.Namespace.Status,
				}
				client.updateNamespaceStatus(&robj)
			}
			return
		}

		// else, retry after some time, with backoff
		time.Sleep(time.Second * time.Duration(2*iter))
	}
}

// updateNamespaceStatus sends status back to the controller
func (client *NimbusClient) updateNamespaceStatus(resp *netproto.Namespace) {
	if client.rpcClient != nil && client.rpcClient.ClientConn != nil && client.rpcClient.ClientConn.GetState() == connectivity.Ready {
		namespaceRPCClient := netproto.NewNamespaceApiClient(client.rpcClient.ClientConn)
		ctx, _ := context.WithTimeout(context.Background(), DefaultRPCTimeout)
		_, err := namespaceRPCClient.UpdateNamespace(ctx, resp)
		if err != nil {
			log.Errorf("failed to send Namespace Status, %s", err)
			client.debugStats.AddInt("NamespaceStatusSendError", 1)
		} else {
			client.debugStats.AddInt("NamespaceStatusSent", 1)
		}

	}
}
