// Code generated by protoc-gen-grpc-pensando DO NOT EDIT.

/*
Package nimbus is a auto generated package.
Input file: sgpolicy.proto
*/

package nimbus

import (
	"context"
	"errors"
	"io"

	"github.com/pensando/sw/api"
	"github.com/pensando/sw/nic/agent/protos/netproto"
	"github.com/pensando/sw/venice/utils/log"
	memdb "github.com/pensando/sw/venice/utils/memdb"
	"github.com/pensando/sw/venice/utils/netutils"
	"github.com/pensando/sw/venice/utils/rpckit"
)

// FindSGPolicy finds an SGPolicy by object meta
func (ms *MbusServer) FindSGPolicy(objmeta *api.ObjectMeta) (*netproto.SGPolicy, error) {
	// find the object
	obj, err := ms.memDB.FindObject("SGPolicy", objmeta)
	if err != nil {
		return nil, err
	}

	return SGPolicyFromObj(obj)
}

// ListSGPolicys lists all SGPolicys in the mbus
func (ms *MbusServer) ListSGPolicys(ctx context.Context, filterFn func(memdb.Object) bool) ([]*netproto.SGPolicy, error) {
	var objlist []*netproto.SGPolicy

	// walk all objects
	objs := ms.memDB.ListObjects("SGPolicy", filterFn)
	for _, oo := range objs {
		obj, err := SGPolicyFromObj(oo)
		if err == nil {
			objlist = append(objlist, obj)
		}
	}

	return objlist, nil
}

// SGPolicyStatusReactor is the reactor interface implemented by controllers
type SGPolicyStatusReactor interface {
	OnSGPolicyCreateReq(nodeID string, objinfo *netproto.SGPolicy) error
	OnSGPolicyUpdateReq(nodeID string, objinfo *netproto.SGPolicy) error
	OnSGPolicyDeleteReq(nodeID string, objinfo *netproto.SGPolicy) error
	OnSGPolicyOperUpdate(nodeID string, objinfo *netproto.SGPolicy) error
	OnSGPolicyOperDelete(nodeID string, objinfo *netproto.SGPolicy) error
	GetWatchFilter(kind string, ometa *api.ObjectMeta) func(memdb.Object) bool
}

// SGPolicyTopic is the SGPolicy topic on message bus
type SGPolicyTopic struct {
	grpcServer    *rpckit.RPCServer // gRPC server instance
	server        *MbusServer
	statusReactor SGPolicyStatusReactor // status event reactor
}

// AddSGPolicyTopic returns a network RPC server
func AddSGPolicyTopic(server *MbusServer, reactor SGPolicyStatusReactor) (*SGPolicyTopic, error) {
	// RPC handler instance
	handler := SGPolicyTopic{
		grpcServer:    server.grpcServer,
		server:        server,
		statusReactor: reactor,
	}

	// register the RPC handlers
	if server.grpcServer != nil {
		netproto.RegisterSGPolicyApiServer(server.grpcServer.GrpcServer, &handler)
	}

	return &handler, nil
}

// CreateSGPolicy creates SGPolicy
func (eh *SGPolicyTopic) CreateSGPolicy(ctx context.Context, objinfo *netproto.SGPolicy) (*netproto.SGPolicy, error) {
	nodeID := netutils.GetNodeUUIDFromCtx(ctx)
	log.Infof("Received CreateSGPolicy from node %v: {%+v}", nodeID, objinfo)

	// trigger callbacks. we allow creates to happen before it exists in memdb
	if eh.statusReactor != nil {
		eh.statusReactor.OnSGPolicyCreateReq(nodeID, objinfo)
	}

	// increment stats
	eh.server.Stats("SGPolicy", "AgentCreate").Inc()

	return objinfo, nil
}

// UpdateSGPolicy updates SGPolicy
func (eh *SGPolicyTopic) UpdateSGPolicy(ctx context.Context, objinfo *netproto.SGPolicy) (*netproto.SGPolicy, error) {
	nodeID := netutils.GetNodeUUIDFromCtx(ctx)
	log.Infof("Received UpdateSGPolicy from node %v: {%+v}", nodeID, objinfo)

	// incr stats
	eh.server.Stats("SGPolicy", "AgentUpdate").Inc()

	// trigger callbacks
	if eh.statusReactor != nil {
		eh.statusReactor.OnSGPolicyUpdateReq(nodeID, objinfo)
	}

	return objinfo, nil
}

// DeleteSGPolicy deletes an SGPolicy
func (eh *SGPolicyTopic) DeleteSGPolicy(ctx context.Context, objinfo *netproto.SGPolicy) (*netproto.SGPolicy, error) {
	nodeID := netutils.GetNodeUUIDFromCtx(ctx)
	log.Infof("Received DeleteSGPolicy from node %v: {%+v}", nodeID, objinfo)

	// incr stats
	eh.server.Stats("SGPolicy", "AgentDelete").Inc()

	// trigger callbacks
	if eh.statusReactor != nil {
		eh.statusReactor.OnSGPolicyDeleteReq(nodeID, objinfo)
	}

	return objinfo, nil
}

// SGPolicyFromObj converts memdb object to SGPolicy
func SGPolicyFromObj(obj memdb.Object) (*netproto.SGPolicy, error) {
	switch obj.(type) {
	case *netproto.SGPolicy:
		eobj := obj.(*netproto.SGPolicy)
		return eobj, nil
	default:
		return nil, ErrIncorrectObjectType
	}
}

// GetSGPolicy returns a specific SGPolicy
func (eh *SGPolicyTopic) GetSGPolicy(ctx context.Context, objmeta *api.ObjectMeta) (*netproto.SGPolicy, error) {
	// find the object
	obj, err := eh.server.memDB.FindObject("SGPolicy", objmeta)
	if err != nil {
		return nil, err
	}

	return SGPolicyFromObj(obj)
}

// ListSGPolicys lists all SGPolicys matching object selector
func (eh *SGPolicyTopic) ListSGPolicys(ctx context.Context, objsel *api.ObjectMeta) (*netproto.SGPolicyList, error) {
	var objlist netproto.SGPolicyList

	filterFn := func(memdb.Object) bool {
		return true
	}

	if eh.statusReactor != nil {
		filterFn = eh.statusReactor.GetWatchFilter("SGPolicy", objsel)
	}

	// walk all objects
	objs := eh.server.memDB.ListObjects("SGPolicy", filterFn)
	for _, oo := range objs {
		obj, err := SGPolicyFromObj(oo)
		if err == nil {
			objlist.SGPolicys = append(objlist.SGPolicys, obj)
		}
	}

	return &objlist, nil
}

// WatchSGPolicys watches SGPolicys and sends streaming resp
func (eh *SGPolicyTopic) WatchSGPolicys(ometa *api.ObjectMeta, stream netproto.SGPolicyApi_WatchSGPolicysServer) error {
	// watch for changes
	watcher := memdb.Watcher{}
	watcher.Channel = make(chan memdb.Event, memdb.WatchLen)
	defer close(watcher.Channel)

	if eh.statusReactor != nil {
		watcher.Filter = eh.statusReactor.GetWatchFilter("SGPolicy", ometa)
	} else {
		watcher.Filter = func(memdb.Object) bool {
			return true
		}
	}

	ctx := stream.Context()
	nodeID := netutils.GetNodeUUIDFromCtx(ctx)
	watcher.Name = nodeID
	eh.server.memDB.WatchObjects("SGPolicy", &watcher)
	defer eh.server.memDB.StopWatchObjects("SGPolicy", &watcher)

	// get a list of all SGPolicys
	objlist, err := eh.ListSGPolicys(context.Background(), ometa)
	if err != nil {
		log.Errorf("Error getting a list of objects. Err: %v", err)
		return err
	}

	// increment stats
	eh.server.Stats("SGPolicy", "ActiveWatch").Inc()
	eh.server.Stats("SGPolicy", "WatchConnect").Inc()
	defer eh.server.Stats("SGPolicy", "ActiveWatch").Dec()
	defer eh.server.Stats("SGPolicy", "WatchDisconnect").Inc()

	// walk all SGPolicys and send it out
	for _, obj := range objlist.SGPolicys {
		watchEvt := netproto.SGPolicyEvent{
			EventType: api.EventType_CreateEvent,
			SGPolicy:  *obj,
		}
		err = stream.Send(&watchEvt)
		if err != nil {
			log.Errorf("Error sending SGPolicy to stream. Err: %v", err)
			return err
		}
	}

	// loop forever on watch channel
	for {
		select {
		// read from channel
		case evt, ok := <-watcher.Channel:
			if !ok {
				log.Errorf("Error reading from channel. Closing watch")
				return errors.New("Error reading from channel")
			}

			// convert the events
			var etype api.EventType
			switch evt.EventType {
			case memdb.CreateEvent:
				etype = api.EventType_CreateEvent
			case memdb.UpdateEvent:
				etype = api.EventType_UpdateEvent
			case memdb.DeleteEvent:
				etype = api.EventType_DeleteEvent
			}

			// get the object
			obj, err := SGPolicyFromObj(evt.Obj)
			if err != nil {
				return err
			}

			// convert to netproto format
			watchEvt := netproto.SGPolicyEvent{
				EventType: etype,
				SGPolicy:  *obj,
			}
			// streaming send
			err = stream.Send(&watchEvt)
			if err != nil {
				log.Errorf("Error sending SGPolicy to stream. Err: %v", err)
				return err
			}
		case <-ctx.Done():
			return ctx.Err()
		}
	}

	// done
}

// updateSGPolicyOper triggers oper update callbacks
func (eh *SGPolicyTopic) updateSGPolicyOper(oper *netproto.SGPolicyEvent, nodeID string) error {
	switch oper.EventType {
	case api.EventType_CreateEvent:
		fallthrough
	case api.EventType_UpdateEvent:
		// incr stats
		eh.server.Stats("SGPolicy", "AgentUpdate").Inc()

		// trigger callbacks
		if eh.statusReactor != nil {
			return eh.statusReactor.OnSGPolicyOperUpdate(nodeID, &oper.SGPolicy)
		}
	case api.EventType_DeleteEvent:
		// incr stats
		eh.server.Stats("SGPolicy", "AgentDelete").Inc()

		// trigger callbacks
		if eh.statusReactor != nil {
			eh.statusReactor.OnSGPolicyOperDelete(nodeID, &oper.SGPolicy)
		}
	}

	return nil
}

func (eh *SGPolicyTopic) SGPolicyOperUpdate(stream netproto.SGPolicyApi_SGPolicyOperUpdateServer) error {
	ctx := stream.Context()
	nodeID := netutils.GetNodeUUIDFromCtx(ctx)

	for {
		oper, err := stream.Recv()
		if err == io.EOF {
			log.Errorf("SGPolicyOperUpdate stream ended. closing..")
			return stream.SendAndClose(&api.TypeMeta{})
		} else if err != nil {
			log.Errorf("Error receiving from SGPolicyOperUpdate stream. Err: %v", err)
			return err
		}

		err = eh.updateSGPolicyOper(oper, nodeID)
		if err != nil {
			log.Errorf("Error updating SGPolicy oper state. Err: %v", err)
		}
	}
}
