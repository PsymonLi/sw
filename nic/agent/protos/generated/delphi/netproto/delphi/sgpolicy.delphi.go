// Code generated by protoc-gen-go. DO NOT EDIT.
// source: delphi/sgpolicy.proto

package dnetproto

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import clientApi "github.com/pensando/sw/nic/delphi/gosdk/client_api"
import netproto6 "github.com/pensando/sw/nic/agent/protos/netproto"
import delphi "github.com/pensando/sw/nic/delphi/proto/delphi"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// SGPolicy object
type SGPolicy struct {
	Meta     *delphi.ObjectMeta  `protobuf:"bytes,1,opt,name=Meta" json:"Meta,omitempty"`
	Key      string              `protobuf:"bytes,2,opt,name=Key" json:"Key,omitempty"`
	SGPolicy *netproto6.SGPolicy `protobuf:"bytes,3,opt,name=SGPolicy" json:"SGPolicy,omitempty"`
}

func (m *SGPolicy) GetDelphiMessage() proto.Message {
	return m
}

func (m *SGPolicy) GetDelphiMeta() *delphi.ObjectMeta {
	return m.Meta
}

func (m *SGPolicy) SetDelphiMeta(meta *delphi.ObjectMeta) {
	m.Meta = meta
}

func (m *SGPolicy) GetDelphiKey() string {
	return fmt.Sprintf("%v", m.Key)
}

func (m *SGPolicy) GetDelphiKind() string {
	return "SGPolicy"
}

func (m *SGPolicy) GetDelphiPath() string {
	return fmt.Sprintf("%s|%s", m.GetDelphiKind(), m.GetDelphiKey())
}

func (m *SGPolicy) DelphiClone() clientApi.BaseObject {
	obj, _ := proto.Clone(m).(*SGPolicy)
	return obj
}

func SGPolicyMount(client clientApi.Client, mode delphi.MountMode) {
	client.MountKind("SGPolicy", mode)
}

func SGPolicyMountKey(client clientApi.Client, key string, mode delphi.MountMode) {
	client.MountKindKey("SGPolicy", fmt.Sprintf("%v", key), mode)
}

func GetSGPolicy(client clientApi.Client, key string) *SGPolicy {
	o := client.GetObject("SGPolicy", fmt.Sprintf("%v", key))
	if o == nil {
		return nil
	}
	obj, ok := o.(*SGPolicy)
	if ok != true {
		panic("Cast failed")
	}
	return obj
}

func (m *SGPolicy) IsPersistent() bool {
	return false
}
func SGPolicyFactory(sdkClient clientApi.Client, data []byte) (clientApi.BaseObject, error) {
	var msg SGPolicy
	err := proto.Unmarshal(data, &msg)
	if err != nil {
		return nil, err
	}
	return &msg, nil
}

func SGPolicyWatch(client clientApi.Client, reactor SGPolicyReactor) {
	client.WatchKind("SGPolicy", reactor)
}
func SGPolicyList(client clientApi.Client) []*SGPolicy {
	bobjs := client.List("SGPolicy")
	objs := make([]*SGPolicy, 0)
	for _, bobj := range bobjs {
		obj, _ := bobj.(*SGPolicy)
		objs = append(objs, obj)
	}
	return objs
}
func (m *SGPolicy) TriggerEvent(sdkClient clientApi.Client, old clientApi.BaseObject, op delphi.ObjectOperation, rl []clientApi.BaseReactor) {
	for _, r := range rl {
		rctr, ok := r.(SGPolicyReactor)
		if ok == false {
			panic("Not a Reactor")
		}
		if op == delphi.ObjectOperation_SetOp {
			if old == nil {
				rctr.OnSGPolicyCreate(m)
			} else {
				oldObj, ok := old.(*SGPolicy)
				if ok == false {
					panic("Not an SGPolicy object")
				}
				rctr.OnSGPolicyUpdate(oldObj, m)
			}
		} else {
			rctr.OnSGPolicyDelete(m)
		}
	}
}

type SGPolicyReactor interface {
	OnSGPolicyCreate(obj *SGPolicy)
	OnSGPolicyUpdate(old *SGPolicy, obj *SGPolicy)
	OnSGPolicyDelete(obj *SGPolicy)
}

func (m *SGPolicy) Reset()                    { *m = SGPolicy{} }
func (m *SGPolicy) String() string            { return proto.CompactTextString(m) }
func (*SGPolicy) ProtoMessage()               {}
func (*SGPolicy) Descriptor() ([]byte, []int) { return fileDescriptor5, []int{0} }

func (m *SGPolicy) GetMeta() *delphi.ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *SGPolicy) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *SGPolicy) GetSGPolicy() *netproto6.SGPolicy {
	if m != nil {
		return m.SGPolicy
	}
	return nil
}

func init() {
	clientApi.RegisterFactory("SGPolicy", SGPolicyFactory)
	proto.RegisterType((*SGPolicy)(nil), "dnetproto.SGPolicy")
}

func init() { proto.RegisterFile("delphi/sgpolicy.proto", fileDescriptor5) }

var fileDescriptor5 = []byte{
	// 185 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe2, 0x12, 0x4d, 0x49, 0xcd, 0x29,
	0xc8, 0xc8, 0xd4, 0x2f, 0x4e, 0x2f, 0xc8, 0xcf, 0xc9, 0x4c, 0xae, 0xd4, 0x2b, 0x28, 0xca, 0x2f,
	0xc9, 0x17, 0xe2, 0x4c, 0xc9, 0x4b, 0x2d, 0x01, 0x33, 0xa5, 0xec, 0xd3, 0x33, 0x4b, 0x32, 0x4a,
	0x93, 0xf4, 0x92, 0xf3, 0x73, 0xf5, 0x0b, 0x52, 0xf3, 0x8a, 0x13, 0xf3, 0x52, 0xf2, 0xf5, 0x8b,
	0xcb, 0xf5, 0xf3, 0x32, 0x93, 0xf5, 0x13, 0xd3, 0x53, 0xf3, 0x4a, 0xf4, 0xc1, 0xea, 0x8a, 0xf5,
	0x61, 0x3a, 0xd0, 0xcc, 0x92, 0xe2, 0x81, 0x58, 0x01, 0xe1, 0x29, 0x55, 0x71, 0x71, 0x04, 0xbb,
	0x07, 0x80, 0xe5, 0x85, 0xd4, 0xb8, 0x58, 0x7c, 0x53, 0x4b, 0x12, 0x25, 0x18, 0x15, 0x18, 0x35,
	0xb8, 0x8d, 0x84, 0xf4, 0xa0, 0x0a, 0xfd, 0x93, 0xb2, 0x52, 0x93, 0x4b, 0x40, 0x32, 0x41, 0x60,
	0x79, 0x21, 0x01, 0x2e, 0x66, 0xef, 0xd4, 0x4a, 0x09, 0x26, 0x05, 0x46, 0x0d, 0xce, 0x20, 0x10,
	0x53, 0x48, 0x0f, 0x61, 0x8a, 0x04, 0x33, 0x54, 0x37, 0xcc, 0x7e, 0x3d, 0x98, 0x4c, 0x10, 0x5c,
	0x8d, 0x15, 0x4b, 0xc3, 0x74, 0x25, 0xc6, 0x24, 0x36, 0xb0, 0xbc, 0x31, 0x20, 0x00, 0x00, 0xff,
	0xff, 0x74, 0xf7, 0x3f, 0x54, 0xf5, 0x00, 0x00, 0x00,
}
