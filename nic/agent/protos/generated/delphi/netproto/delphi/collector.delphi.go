// Code generated by protoc-gen-go. DO NOT EDIT.
// source: delphi/collector.proto

package dnetproto

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import clientApi "github.com/pensando/sw/nic/delphi/gosdk/client_api"
import netproto13 "github.com/pensando/sw/nic/agent/protos/netproto"
import delphi "github.com/pensando/sw/nic/delphi/proto/delphi"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// Endpoint Object
type Collector struct {
	Meta      *delphi.ObjectMeta    `protobuf:"bytes,1,opt,name=Meta" json:"Meta,omitempty"`
	Key       string                `protobuf:"bytes,2,opt,name=Key" json:"Key,omitempty"`
	Collector *netproto13.Collector `protobuf:"bytes,3,opt,name=Collector" json:"Collector,omitempty"`
}

func (m *Collector) GetDelphiMessage() proto.Message {
	return m
}

func (m *Collector) GetDelphiMeta() *delphi.ObjectMeta {
	return m.Meta
}

func (m *Collector) SetDelphiMeta(meta *delphi.ObjectMeta) {
	m.Meta = meta
}

func (m *Collector) GetDelphiKey() string {
	return fmt.Sprintf("%v", m.Key)
}

func (m *Collector) GetDelphiKind() string {
	return "Collector"
}

func (m *Collector) GetDelphiPath() string {
	return fmt.Sprintf("%s|%s", m.GetDelphiKind(), m.GetDelphiKey())
}

func (m *Collector) DelphiClone() clientApi.BaseObject {
	obj, _ := proto.Clone(m).(*Collector)
	return obj
}

func CollectorMount(client clientApi.Client, mode delphi.MountMode) {
	client.MountKind("Collector", mode)
}

func CollectorMountKey(client clientApi.Client, key string, mode delphi.MountMode) {
	client.MountKindKey("Collector", fmt.Sprintf("%v", key), mode)
}

func GetCollector(client clientApi.Client, key string) *Collector {
	o := client.GetObject("Collector", fmt.Sprintf("%v", key))
	if o == nil {
		return nil
	}
	obj, ok := o.(*Collector)
	if ok != true {
		panic("Cast failed")
	}
	return obj
}

func (m *Collector) IsPersistent() bool {
	return false
}
func CollectorFactory(sdkClient clientApi.Client, data []byte) (clientApi.BaseObject, error) {
	var msg Collector
	err := proto.Unmarshal(data, &msg)
	if err != nil {
		return nil, err
	}
	return &msg, nil
}

func CollectorWatch(client clientApi.Client, reactor CollectorReactor) {
	client.WatchKind("Collector", reactor)
}
func CollectorList(client clientApi.Client) []*Collector {
	bobjs := client.List("Collector")
	objs := make([]*Collector, 0)
	for _, bobj := range bobjs {
		obj, _ := bobj.(*Collector)
		objs = append(objs, obj)
	}
	return objs
}
func (m *Collector) TriggerEvent(sdkClient clientApi.Client, old clientApi.BaseObject, op delphi.ObjectOperation, rl []clientApi.BaseReactor) {
	for _, r := range rl {
		rctr, ok := r.(CollectorReactor)
		if ok == false {
			panic("Not a Reactor")
		}
		if op == delphi.ObjectOperation_SetOp {
			if old == nil {
				rctr.OnCollectorCreate(m)
			} else {
				oldObj, ok := old.(*Collector)
				if ok == false {
					panic("Not an Collector object")
				}
				rctr.OnCollectorUpdate(oldObj, m)
			}
		} else {
			rctr.OnCollectorDelete(m)
		}
	}
}

type CollectorReactor interface {
	OnCollectorCreate(obj *Collector)
	OnCollectorUpdate(old *Collector, obj *Collector)
	OnCollectorDelete(obj *Collector)
}

func (m *Collector) Reset()                    { *m = Collector{} }
func (m *Collector) String() string            { return proto.CompactTextString(m) }
func (*Collector) ProtoMessage()               {}
func (*Collector) Descriptor() ([]byte, []int) { return fileDescriptor10, []int{0} }

func (m *Collector) GetMeta() *delphi.ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *Collector) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *Collector) GetCollector() *netproto13.Collector {
	if m != nil {
		return m.Collector
	}
	return nil
}

func init() {
	clientApi.RegisterFactory("Collector", CollectorFactory)
	proto.RegisterType((*Collector)(nil), "dnetproto.Collector")
}

func init() { proto.RegisterFile("delphi/collector.proto", fileDescriptor10) }

var fileDescriptor10 = []byte{
	// 187 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe2, 0x12, 0x4b, 0x49, 0xcd, 0x29,
	0xc8, 0xc8, 0xd4, 0x4f, 0xce, 0xcf, 0xc9, 0x49, 0x4d, 0x2e, 0xc9, 0x2f, 0xd2, 0x2b, 0x28, 0xca,
	0x2f, 0xc9, 0x17, 0xe2, 0x4c, 0xc9, 0x4b, 0x2d, 0x01, 0x33, 0xa5, 0x1c, 0xd2, 0x33, 0x4b, 0x32,
	0x4a, 0x93, 0xf4, 0x92, 0xf3, 0x73, 0xf5, 0x0b, 0x52, 0xf3, 0x8a, 0x13, 0xf3, 0x52, 0xf2, 0xf5,
	0x8b, 0xcb, 0xf5, 0xf3, 0x32, 0x93, 0xf5, 0x13, 0xd3, 0x53, 0xf3, 0x4a, 0xf4, 0xc1, 0xea, 0x8a,
	0xf5, 0x61, 0x3a, 0xd0, 0x0d, 0x93, 0xe2, 0x81, 0x58, 0x02, 0xe1, 0x29, 0xd5, 0x71, 0x71, 0x3a,
	0xc3, 0x14, 0x08, 0xa9, 0x71, 0xb1, 0xf8, 0xa6, 0x96, 0x24, 0x4a, 0x30, 0x2a, 0x30, 0x6a, 0x70,
	0x1b, 0x09, 0xe9, 0x41, 0x55, 0xfa, 0x27, 0x65, 0xa5, 0x26, 0x97, 0x80, 0x64, 0x82, 0xc0, 0xf2,
	0x42, 0x02, 0x5c, 0xcc, 0xde, 0xa9, 0x95, 0x12, 0x4c, 0x0a, 0x8c, 0x1a, 0x9c, 0x41, 0x20, 0xa6,
	0x90, 0x21, 0x92, 0x31, 0x12, 0xcc, 0x60, 0xed, 0xc2, 0x7a, 0x30, 0x27, 0xe8, 0xc1, 0xa5, 0x82,
	0x10, 0xaa, 0xac, 0x58, 0x1a, 0xa6, 0x2b, 0x31, 0x26, 0xb1, 0x81, 0x55, 0x18, 0x03, 0x02, 0x00,
	0x00, 0xff, 0xff, 0xac, 0x55, 0x34, 0xc9, 0xfb, 0x00, 0x00, 0x00,
}
