// Code generated by protoc-gen-go. DO NOT EDIT.
// source: delphi/vrf.proto

package dnetproto

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import clientApi "github.com/pensando/sw/nic/delphi/gosdk/client_api"
import netproto11 "github.com/pensando/sw/nic/agent/protos/netproto"
import delphi "github.com/pensando/sw/nic/delphi/proto/delphi"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// app object
type Vrf struct {
	Meta *delphi.ObjectMeta `protobuf:"bytes,1,opt,name=Meta" json:"Meta,omitempty"`
	Key  string             `protobuf:"bytes,2,opt,name=Key" json:"Key,omitempty"`
	Vrf  *netproto11.Vrf    `protobuf:"bytes,3,opt,name=Vrf" json:"Vrf,omitempty"`
}

func (m *Vrf) GetDelphiMessage() proto.Message {
	return m
}

func (m *Vrf) GetDelphiMeta() *delphi.ObjectMeta {
	return m.Meta
}

func (m *Vrf) SetDelphiMeta(meta *delphi.ObjectMeta) {
	m.Meta = meta
}

func (m *Vrf) GetDelphiKey() string {
	return fmt.Sprintf("%v", m.Key)
}

func (m *Vrf) GetDelphiKind() string {
	return "Vrf"
}

func (m *Vrf) GetDelphiPath() string {
	return fmt.Sprintf("%s|%s", m.GetDelphiKind(), m.GetDelphiKey())
}

func (m *Vrf) DelphiClone() clientApi.BaseObject {
	obj, _ := proto.Clone(m).(*Vrf)
	return obj
}

func VrfMount(client clientApi.Client, mode delphi.MountMode) {
	client.MountKind("Vrf", mode)
}

func VrfMountKey(client clientApi.Client, key string, mode delphi.MountMode) {
	client.MountKindKey("Vrf", fmt.Sprintf("%v", key), mode)
}

func GetVrf(client clientApi.Client, key string) *Vrf {
	o := client.GetObject("Vrf", fmt.Sprintf("%v", key))
	if o == nil {
		return nil
	}
	obj, ok := o.(*Vrf)
	if ok != true {
		panic("Cast failed")
	}
	return obj
}

func (m *Vrf) IsPersistent() bool {
	return false
}
func VrfFactory(sdkClient clientApi.Client, data []byte) (clientApi.BaseObject, error) {
	var msg Vrf
	err := proto.Unmarshal(data, &msg)
	if err != nil {
		return nil, err
	}
	return &msg, nil
}

func VrfWatch(client clientApi.Client, reactor VrfReactor) {
	client.WatchKind("Vrf", reactor)
}
func VrfList(client clientApi.Client) []*Vrf {
	bobjs := client.List("Vrf")
	objs := make([]*Vrf, 0)
	for _, bobj := range bobjs {
		obj, _ := bobj.(*Vrf)
		objs = append(objs, obj)
	}
	return objs
}
func (m *Vrf) TriggerEvent(sdkClient clientApi.Client, old clientApi.BaseObject, op delphi.ObjectOperation, rl []clientApi.BaseReactor) {
	for _, r := range rl {
		rctr, ok := r.(VrfReactor)
		if ok == false {
			panic("Not a Reactor")
		}
		if op == delphi.ObjectOperation_SetOp {
			if old == nil {
				rctr.OnVrfCreate(m)
			} else {
				oldObj, ok := old.(*Vrf)
				if ok == false {
					panic("Not an Vrf object")
				}
				rctr.OnVrfUpdate(oldObj, m)
			}
		} else {
			rctr.OnVrfDelete(m)
		}
	}
}

type VrfReactor interface {
	OnVrfCreate(obj *Vrf)
	OnVrfUpdate(old *Vrf, obj *Vrf)
	OnVrfDelete(obj *Vrf)
}

func (m *Vrf) Reset()                    { *m = Vrf{} }
func (m *Vrf) String() string            { return proto.CompactTextString(m) }
func (*Vrf) ProtoMessage()               {}
func (*Vrf) Descriptor() ([]byte, []int) { return fileDescriptor9, []int{0} }

func (m *Vrf) GetMeta() *delphi.ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *Vrf) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *Vrf) GetVrf() *netproto11.Vrf {
	if m != nil {
		return m.Vrf
	}
	return nil
}

func init() {
	clientApi.RegisterFactory("Vrf", VrfFactory)
	proto.RegisterType((*Vrf)(nil), "dnetproto.Vrf")
}

func init() { proto.RegisterFile("delphi/vrf.proto", fileDescriptor9) }

var fileDescriptor9 = []byte{
	// 142 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe2, 0x12, 0x48, 0x49, 0xcd, 0x29,
	0xc8, 0xc8, 0xd4, 0x2f, 0x2b, 0x4a, 0xd3, 0x2b, 0x28, 0xca, 0x2f, 0xc9, 0x17, 0xe2, 0x4c, 0xc9,
	0x4b, 0x2d, 0x01, 0x33, 0xa5, 0x38, 0xe1, 0xa2, 0x52, 0x3c, 0x10, 0x75, 0x10, 0x9e, 0x52, 0x1a,
	0x17, 0x73, 0x58, 0x51, 0x9a, 0x90, 0x1a, 0x17, 0x8b, 0x6f, 0x6a, 0x49, 0xa2, 0x04, 0xa3, 0x02,
	0xa3, 0x06, 0xb7, 0x91, 0x90, 0x1e, 0x54, 0x8d, 0x7f, 0x52, 0x56, 0x6a, 0x72, 0x09, 0x48, 0x26,
	0x08, 0x2c, 0x2f, 0x24, 0xc0, 0xc5, 0xec, 0x9d, 0x5a, 0x29, 0xc1, 0xa4, 0xc0, 0xa8, 0xc1, 0x19,
	0x04, 0x62, 0x0a, 0xc9, 0x83, 0x0d, 0x90, 0x60, 0x06, 0x6b, 0xe4, 0xd5, 0x83, 0xd9, 0xa8, 0x17,
	0x56, 0x94, 0x16, 0x04, 0x92, 0xb1, 0x62, 0x69, 0x98, 0xae, 0xc4, 0x98, 0xc4, 0x06, 0x16, 0x35,
	0x06, 0x04, 0x00, 0x00, 0xff, 0xff, 0x3f, 0xe4, 0x56, 0x81, 0xa6, 0x00, 0x00, 0x00,
}
