// Code generated by protoc-gen-go. DO NOT EDIT.
// source: delphi/endpoint.proto

package dnetproto

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import clientApi "github.com/pensando/sw/nic/delphi/gosdk/client_api"
import netproto2 "github.com/pensando/sw/nic/agent/protos/netproto"
import delphi "github.com/pensando/sw/nic/delphi/proto/delphi"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// Endpoint Object
type Endpoint struct {
	Meta     *delphi.ObjectMeta  `protobuf:"bytes,1,opt,name=Meta" json:"Meta,omitempty"`
	Key      string              `protobuf:"bytes,2,opt,name=Key" json:"Key,omitempty"`
	Endpoint *netproto2.Endpoint `protobuf:"bytes,3,opt,name=Endpoint" json:"Endpoint,omitempty"`
}

func (m *Endpoint) GetDelphiMessage() proto.Message {
	return m
}

func (m *Endpoint) GetDelphiMeta() *delphi.ObjectMeta {
	return m.Meta
}

func (m *Endpoint) SetDelphiMeta(meta *delphi.ObjectMeta) {
	m.Meta = meta
}

func (m *Endpoint) GetDelphiKey() string {
	return fmt.Sprintf("%v", m.Key)
}

func (m *Endpoint) GetDelphiKind() string {
	return "Endpoint"
}

func (m *Endpoint) GetDelphiPath() string {
	return fmt.Sprintf("%s|%s", m.GetDelphiKind(), m.GetDelphiKey())
}

func (m *Endpoint) DelphiClone() clientApi.BaseObject {
	obj, _ := proto.Clone(m).(*Endpoint)
	return obj
}

func EndpointMount(client clientApi.Client, mode delphi.MountMode) {
	client.MountKind("Endpoint", mode)
}

func EndpointMountKey(client clientApi.Client, key string, mode delphi.MountMode) {
	client.MountKindKey("Endpoint", fmt.Sprintf("%v", key), mode)
}

func GetEndpoint(client clientApi.Client, key string) *Endpoint {
	o := client.GetObject("Endpoint", fmt.Sprintf("%v", key))
	if o == nil {
		return nil
	}
	obj, ok := o.(*Endpoint)
	if ok != true {
		panic("Cast failed")
	}
	return obj
}

func (m *Endpoint) IsPersistent() bool {
	return false
}
func EndpointFactory(sdkClient clientApi.Client, data []byte) (clientApi.BaseObject, error) {
	var msg Endpoint
	err := proto.Unmarshal(data, &msg)
	if err != nil {
		return nil, err
	}
	return &msg, nil
}

func EndpointWatch(client clientApi.Client, reactor EndpointReactor) {
	client.WatchKind("Endpoint", reactor)
}
func EndpointList(client clientApi.Client) []*Endpoint {
	bobjs := client.List("Endpoint")
	objs := make([]*Endpoint, 0)
	for _, bobj := range bobjs {
		obj, _ := bobj.(*Endpoint)
		objs = append(objs, obj)
	}
	return objs
}
func (m *Endpoint) TriggerEvent(sdkClient clientApi.Client, old clientApi.BaseObject, op delphi.ObjectOperation, rl []clientApi.BaseReactor) {
	for _, r := range rl {
		rctr, ok := r.(EndpointReactor)
		if ok == false {
			panic("Not a Reactor")
		}
		if op == delphi.ObjectOperation_SetOp {
			if old == nil {
				rctr.OnEndpointCreate(m)
			} else {
				oldObj, ok := old.(*Endpoint)
				if ok == false {
					panic("Not an Endpoint object")
				}
				rctr.OnEndpointUpdate(oldObj, m)
			}
		} else {
			rctr.OnEndpointDelete(m)
		}
	}
}

type EndpointReactor interface {
	OnEndpointCreate(obj *Endpoint)
	OnEndpointUpdate(old *Endpoint, obj *Endpoint)
	OnEndpointDelete(obj *Endpoint)
}

func (m *Endpoint) Reset()                    { *m = Endpoint{} }
func (m *Endpoint) String() string            { return proto.CompactTextString(m) }
func (*Endpoint) ProtoMessage()               {}
func (*Endpoint) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{0} }

func (m *Endpoint) GetMeta() *delphi.ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *Endpoint) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *Endpoint) GetEndpoint() *netproto2.Endpoint {
	if m != nil {
		return m.Endpoint
	}
	return nil
}

func init() {
	clientApi.RegisterFactory("Endpoint", EndpointFactory)
	proto.RegisterType((*Endpoint)(nil), "dnetproto.Endpoint")
}

func init() { proto.RegisterFile("delphi/endpoint.proto", fileDescriptor1) }

var fileDescriptor1 = []byte{
	// 183 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe2, 0x12, 0x4d, 0x49, 0xcd, 0x29,
	0xc8, 0xc8, 0xd4, 0x4f, 0xcd, 0x4b, 0x29, 0xc8, 0xcf, 0xcc, 0x2b, 0xd1, 0x2b, 0x28, 0xca, 0x2f,
	0xc9, 0x17, 0xe2, 0x4c, 0xc9, 0x4b, 0x2d, 0x01, 0x33, 0xa5, 0xec, 0xd3, 0x33, 0x4b, 0x32, 0x4a,
	0x93, 0xf4, 0x92, 0xf3, 0x73, 0xf5, 0x0b, 0x52, 0xf3, 0x8a, 0x13, 0xf3, 0x52, 0xf2, 0xf5, 0x8b,
	0xcb, 0xf5, 0xf3, 0x32, 0x93, 0xf5, 0x13, 0xd3, 0x53, 0xf3, 0x4a, 0xf4, 0xc1, 0xea, 0x8a, 0xf5,
	0x61, 0x3a, 0xd0, 0xcc, 0x92, 0xe2, 0x81, 0x58, 0x01, 0xe1, 0x29, 0x55, 0x71, 0x71, 0xb8, 0x42,
	0xe5, 0x85, 0xd4, 0xb8, 0x58, 0x7c, 0x53, 0x4b, 0x12, 0x25, 0x18, 0x15, 0x18, 0x35, 0xb8, 0x8d,
	0x84, 0xf4, 0xa0, 0x0a, 0xfd, 0x93, 0xb2, 0x52, 0x93, 0x4b, 0x40, 0x32, 0x41, 0x60, 0x79, 0x21,
	0x01, 0x2e, 0x66, 0xef, 0xd4, 0x4a, 0x09, 0x26, 0x05, 0x46, 0x0d, 0xce, 0x20, 0x10, 0x53, 0x48,
	0x0f, 0x61, 0x8a, 0x04, 0x33, 0x54, 0x37, 0xcc, 0x7e, 0x3d, 0x98, 0x4c, 0x10, 0x5c, 0x8d, 0x15,
	0x4b, 0xc3, 0x74, 0x25, 0xc6, 0x24, 0x36, 0xb0, 0xbc, 0x31, 0x20, 0x00, 0x00, 0xff, 0xff, 0xf9,
	0x1d, 0x1d, 0x5c, 0xf5, 0x00, 0x00, 0x00,
}
