// Code generated by protoc-gen-go. DO NOT EDIT.
// source: delphi/namespace.proto

package dnetproto

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import clientApi "github.com/pensando/sw/nic/delphi/gosdk/client_api"
import netproto4 "github.com/pensando/sw/nic/agent/protos/netproto"
import delphi "github.com/pensando/sw/nic/delphi/proto/delphi"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// Namespace object
type Namespace struct {
	Meta      *delphi.ObjectMeta   `protobuf:"bytes,1,opt,name=Meta" json:"Meta,omitempty"`
	Key       string               `protobuf:"bytes,2,opt,name=Key" json:"Key,omitempty"`
	Namespace *netproto4.Namespace `protobuf:"bytes,3,opt,name=Namespace" json:"Namespace,omitempty"`
}

func (m *Namespace) GetDelphiMessage() proto.Message {
	return m
}

func (m *Namespace) GetDelphiMeta() *delphi.ObjectMeta {
	return m.Meta
}

func (m *Namespace) SetDelphiMeta(meta *delphi.ObjectMeta) {
	m.Meta = meta
}

func (m *Namespace) GetDelphiKey() string {
	return fmt.Sprintf("%v", m.Key)
}

func (m *Namespace) GetDelphiKind() string {
	return "Namespace"
}

func (m *Namespace) GetDelphiPath() string {
	return fmt.Sprintf("%s|%s", m.GetDelphiKind(), m.GetDelphiKey())
}

func (m *Namespace) DelphiClone() clientApi.BaseObject {
	obj, _ := proto.Clone(m).(*Namespace)
	return obj
}

func NamespaceMount(client clientApi.Client, mode delphi.MountMode) {
	client.MountKind("Namespace", mode)
}

func NamespaceMountKey(client clientApi.Client, key string, mode delphi.MountMode) {
	client.MountKindKey("Namespace", fmt.Sprintf("%v", key), mode)
}

func GetNamespace(client clientApi.Client, key string) *Namespace {
	o := client.GetObject("Namespace", fmt.Sprintf("%v", key))
	if o == nil {
		return nil
	}
	obj, ok := o.(*Namespace)
	if ok != true {
		panic("Cast failed")
	}
	return obj
}

func (m *Namespace) IsPersistent() bool {
	return false
}
func NamespaceFactory(sdkClient clientApi.Client, data []byte) (clientApi.BaseObject, error) {
	var msg Namespace
	err := proto.Unmarshal(data, &msg)
	if err != nil {
		return nil, err
	}
	return &msg, nil
}

func NamespaceWatch(client clientApi.Client, reactor NamespaceReactor) {
	client.WatchKind("Namespace", reactor)
}
func NamespaceList(client clientApi.Client) []*Namespace {
	bobjs := client.List("Namespace")
	objs := make([]*Namespace, 0)
	for _, bobj := range bobjs {
		obj, _ := bobj.(*Namespace)
		objs = append(objs, obj)
	}
	return objs
}
func (m *Namespace) TriggerEvent(sdkClient clientApi.Client, old clientApi.BaseObject, op delphi.ObjectOperation, rl []clientApi.BaseReactor) {
	for _, r := range rl {
		rctr, ok := r.(NamespaceReactor)
		if ok == false {
			panic("Not a Reactor")
		}
		if op == delphi.ObjectOperation_SetOp {
			if old == nil {
				rctr.OnNamespaceCreate(m)
			} else {
				oldObj, ok := old.(*Namespace)
				if ok == false {
					panic("Not an Namespace object")
				}
				rctr.OnNamespaceUpdate(oldObj, m)
			}
		} else {
			rctr.OnNamespaceDelete(m)
		}
	}
}

type NamespaceReactor interface {
	OnNamespaceCreate(obj *Namespace)
	OnNamespaceUpdate(old *Namespace, obj *Namespace)
	OnNamespaceDelete(obj *Namespace)
}

func (m *Namespace) Reset()                    { *m = Namespace{} }
func (m *Namespace) String() string            { return proto.CompactTextString(m) }
func (*Namespace) ProtoMessage()               {}
func (*Namespace) Descriptor() ([]byte, []int) { return fileDescriptor4, []int{0} }

func (m *Namespace) GetMeta() *delphi.ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *Namespace) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *Namespace) GetNamespace() *netproto4.Namespace {
	if m != nil {
		return m.Namespace
	}
	return nil
}

func init() {
	clientApi.RegisterFactory("Namespace", NamespaceFactory)
	proto.RegisterType((*Namespace)(nil), "dnetproto.Namespace")
}

func init() { proto.RegisterFile("delphi/namespace.proto", fileDescriptor4) }

var fileDescriptor4 = []byte{
	// 187 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe2, 0x12, 0x4b, 0x49, 0xcd, 0x29,
	0xc8, 0xc8, 0xd4, 0xcf, 0x4b, 0xcc, 0x4d, 0x2d, 0x2e, 0x48, 0x4c, 0x4e, 0xd5, 0x2b, 0x28, 0xca,
	0x2f, 0xc9, 0x17, 0xe2, 0x4c, 0xc9, 0x4b, 0x2d, 0x01, 0x33, 0xa5, 0x1c, 0xd2, 0x33, 0x4b, 0x32,
	0x4a, 0x93, 0xf4, 0x92, 0xf3, 0x73, 0xf5, 0x0b, 0x52, 0xf3, 0x8a, 0x13, 0xf3, 0x52, 0xf2, 0xf5,
	0x8b, 0xcb, 0xf5, 0xf3, 0x32, 0x93, 0xf5, 0x13, 0xd3, 0x53, 0xf3, 0x4a, 0xf4, 0xc1, 0xea, 0x8a,
	0xf5, 0x61, 0x3a, 0xd0, 0x0d, 0x93, 0xe2, 0x81, 0x58, 0x02, 0xe1, 0x29, 0xd5, 0x71, 0x71, 0xfa,
	0xc1, 0x14, 0x08, 0xa9, 0x71, 0xb1, 0xf8, 0xa6, 0x96, 0x24, 0x4a, 0x30, 0x2a, 0x30, 0x6a, 0x70,
	0x1b, 0x09, 0xe9, 0x41, 0x55, 0xfa, 0x27, 0x65, 0xa5, 0x26, 0x97, 0x80, 0x64, 0x82, 0xc0, 0xf2,
	0x42, 0x02, 0x5c, 0xcc, 0xde, 0xa9, 0x95, 0x12, 0x4c, 0x0a, 0x8c, 0x1a, 0x9c, 0x41, 0x20, 0xa6,
	0x90, 0x21, 0x92, 0x31, 0x12, 0xcc, 0x60, 0xed, 0xc2, 0x7a, 0x30, 0x27, 0xe8, 0xc1, 0xa5, 0x82,
	0x10, 0xaa, 0xac, 0x58, 0x1a, 0xa6, 0x2b, 0x31, 0x26, 0xb1, 0x81, 0x55, 0x18, 0x03, 0x02, 0x00,
	0x00, 0xff, 0xff, 0x01, 0x65, 0x66, 0xca, 0xfb, 0x00, 0x00, 0x00,
}
