// Code generated by protoc-gen-go. DO NOT EDIT.
// source: delphi/interface.proto

package dnetproto

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import clientApi "github.com/pensando/sw/nic/delphi/gosdk/client_api"
import netproto9 "github.com/pensando/sw/nic/agent/protos/netproto"
import delphi "github.com/pensando/sw/nic/delphi/proto/delphi"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// Interface object
type Interface struct {
	Meta      *delphi.ObjectMeta   `protobuf:"bytes,1,opt,name=Meta" json:"Meta,omitempty"`
	Key       string               `protobuf:"bytes,2,opt,name=Key" json:"Key,omitempty"`
	Interface *netproto9.Interface `protobuf:"bytes,3,opt,name=Interface" json:"Interface,omitempty"`
}

func (m *Interface) GetDelphiMessage() proto.Message {
	return m
}

func (m *Interface) GetDelphiMeta() *delphi.ObjectMeta {
	return m.Meta
}

func (m *Interface) SetDelphiMeta(meta *delphi.ObjectMeta) {
	m.Meta = meta
}

func (m *Interface) GetDelphiKey() string {
	return fmt.Sprintf("%v", m.Key)
}

func (m *Interface) GetDelphiKind() string {
	return "Interface"
}

func (m *Interface) GetDelphiPath() string {
	return fmt.Sprintf("%s|%s", m.GetDelphiKind(), m.GetDelphiKey())
}

func (m *Interface) DelphiClone() clientApi.BaseObject {
	obj, _ := proto.Clone(m).(*Interface)
	return obj
}

func InterfaceMount(client clientApi.Client, mode delphi.MountMode) {
	client.MountKind("Interface", mode)
}

func InterfaceMountKey(client clientApi.Client, key string, mode delphi.MountMode) {
	client.MountKindKey("Interface", fmt.Sprintf("%v", key), mode)
}

func GetInterface(client clientApi.Client, key string) *Interface {
	o := client.GetObject("Interface", fmt.Sprintf("%v", key))
	if o == nil {
		return nil
	}
	obj, ok := o.(*Interface)
	if ok != true {
		panic("Cast failed")
	}
	return obj
}

func (m *Interface) IsPersistent() bool {
	return false
}
func InterfaceFactory(sdkClient clientApi.Client, data []byte) (clientApi.BaseObject, error) {
	var msg Interface
	err := proto.Unmarshal(data, &msg)
	if err != nil {
		return nil, err
	}
	return &msg, nil
}

func InterfaceWatch(client clientApi.Client, reactor InterfaceReactor) {
	client.WatchKind("Interface", reactor)
}
func InterfaceList(client clientApi.Client) []*Interface {
	bobjs := client.List("Interface")
	objs := make([]*Interface, 0)
	for _, bobj := range bobjs {
		obj, _ := bobj.(*Interface)
		objs = append(objs, obj)
	}
	return objs
}
func (m *Interface) TriggerEvent(sdkClient clientApi.Client, old clientApi.BaseObject, op delphi.ObjectOperation, rl []clientApi.BaseReactor) {
	for _, r := range rl {
		rctr, ok := r.(InterfaceReactor)
		if ok == false {
			panic("Not a Reactor")
		}
		if op == delphi.ObjectOperation_SetOp {
			if old == nil {
				rctr.OnInterfaceCreate(m)
			} else {
				oldObj, ok := old.(*Interface)
				if ok == false {
					panic("Not an Interface object")
				}
				rctr.OnInterfaceUpdate(oldObj, m)
			}
		} else {
			rctr.OnInterfaceDelete(m)
		}
	}
}

type InterfaceReactor interface {
	OnInterfaceCreate(obj *Interface)
	OnInterfaceUpdate(old *Interface, obj *Interface)
	OnInterfaceDelete(obj *Interface)
}

func (m *Interface) Reset()                    { *m = Interface{} }
func (m *Interface) String() string            { return proto.CompactTextString(m) }
func (*Interface) ProtoMessage()               {}
func (*Interface) Descriptor() ([]byte, []int) { return fileDescriptor8, []int{0} }

func (m *Interface) GetMeta() *delphi.ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *Interface) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *Interface) GetInterface() *netproto9.Interface {
	if m != nil {
		return m.Interface
	}
	return nil
}

func init() {
	clientApi.RegisterFactory("Interface", InterfaceFactory)
	proto.RegisterType((*Interface)(nil), "dnetproto.Interface")
}

func init() { proto.RegisterFile("delphi/interface.proto", fileDescriptor8) }

var fileDescriptor8 = []byte{
	// 187 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe2, 0x12, 0x4b, 0x49, 0xcd, 0x29,
	0xc8, 0xc8, 0xd4, 0xcf, 0xcc, 0x2b, 0x49, 0x2d, 0x4a, 0x4b, 0x4c, 0x4e, 0xd5, 0x2b, 0x28, 0xca,
	0x2f, 0xc9, 0x17, 0xe2, 0x4c, 0xc9, 0x4b, 0x2d, 0x01, 0x33, 0xa5, 0x1c, 0xd2, 0x33, 0x4b, 0x32,
	0x4a, 0x93, 0xf4, 0x92, 0xf3, 0x73, 0xf5, 0x0b, 0x52, 0xf3, 0x8a, 0x13, 0xf3, 0x52, 0xf2, 0xf5,
	0x8b, 0xcb, 0xf5, 0xf3, 0x32, 0x93, 0xf5, 0x13, 0xd3, 0x53, 0xf3, 0x4a, 0xf4, 0xc1, 0xea, 0x8a,
	0xf5, 0x61, 0x3a, 0xd0, 0x0d, 0x93, 0xe2, 0x81, 0x58, 0x02, 0xe1, 0x29, 0xd5, 0x71, 0x71, 0x7a,
	0xc2, 0x14, 0x08, 0xa9, 0x71, 0xb1, 0xf8, 0xa6, 0x96, 0x24, 0x4a, 0x30, 0x2a, 0x30, 0x6a, 0x70,
	0x1b, 0x09, 0xe9, 0x41, 0x55, 0xfa, 0x27, 0x65, 0xa5, 0x26, 0x97, 0x80, 0x64, 0x82, 0xc0, 0xf2,
	0x42, 0x02, 0x5c, 0xcc, 0xde, 0xa9, 0x95, 0x12, 0x4c, 0x0a, 0x8c, 0x1a, 0x9c, 0x41, 0x20, 0xa6,
	0x90, 0x21, 0x92, 0x31, 0x12, 0xcc, 0x60, 0xed, 0xc2, 0x7a, 0x30, 0x27, 0xe8, 0xc1, 0xa5, 0x82,
	0x10, 0xaa, 0xac, 0x58, 0x1a, 0xa6, 0x2b, 0x31, 0x26, 0xb1, 0x81, 0x55, 0x18, 0x03, 0x02, 0x00,
	0x00, 0xff, 0xff, 0x08, 0x6c, 0x1e, 0x1c, 0xfb, 0x00, 0x00, 0x00,
}
