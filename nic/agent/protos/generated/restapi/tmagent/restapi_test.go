// Code generated by protoc-gen-grpc-pensando DO NOT EDIT.

/*
Package registerproto is a auto generated package.
Input file: register-temp.proto
*/
package restapi_test

import (
	"context"
	"os"
	"testing"

	"github.com/golang/mock/gomock"

	"github.com/pensando/sw/api"
	netrestapi "github.com/pensando/sw/nic/agent/netagent/ctrlerif/restapi"
	"github.com/pensando/sw/nic/agent/netagent/datapath"
	"github.com/pensando/sw/nic/agent/netagent/state"
	"github.com/pensando/sw/nic/agent/protos/netproto"
	"github.com/pensando/sw/nic/agent/tmagent/ctrlerif/restapi"
	tmstate "github.com/pensando/sw/nic/agent/tmagent/state"
	"github.com/pensando/sw/venice/utils/log"
)

const (
	agentRestURL    = "localhost:1337"
	netAgentRestURL = "localhost:2337"
)

// Response captures the HTTP Response sent by Agent REST Server
type Response struct {
	StatusCode int      `json:"status-code,omitempty"`
	Error      string   `json:"error,omitempty"`
	References []string `json:"references,omitempty"`
}

func TestMain(m *testing.M) {
	_, err := setup()
	if err != nil {
		log.Fatalf("Test set up failed. Error: %v", err)
	}
	testCode := m.Run()
	// srv.Stop()
	os.Exit(testCode)
}

func setup() (*restapi.RestServer, error) {
	dp, err := datapath.NewHalDatapath(datapath.Kind("mock"))
	if err != nil {
		log.Errorf("Could not create HAL datapath. Kind: mock, Error %v", err)
		return nil, err
	}

	// Set tenant creation expectation
	dp.Hal.MockClients.MockTnclient.EXPECT().VrfCreate(gomock.Any(), gomock.Any()).Return(nil, nil)

	nagent, err := state.NewNetAgent(dp, "", nil)
	if err != nil {
		log.Errorf("Could not create net agent")
		return nil, err
	}

	err = populatePreTestData(nagent)
	if err != nil {
		log.Errorf("Could not meet prerequisites for testing Endpoint CRUD Methods")
		return nil, err
	}

	netrestapi.NewRestServer(nagent, nil, nil, netAgentRestURL)

	tpstate, err := tmstate.NewTpAgent(context.Background(), "2337")
	if err != nil {
		log.Errorf("Error creating telemetry policy agent. Err: %v", err)
		return nil, err
	}

	return restapi.NewRestServer(context.Background(), agentRestURL, tpstate)
}

func populatePreTestData(nagent *state.Nagent) (err error) {
	vrf := netproto.Vrf{
		TypeMeta: api.TypeMeta{Kind: "Vrf"},
		ObjectMeta: api.ObjectMeta{
			Tenant:    "default",
			Namespace: "default",
			Name:      "preCreatedVrf",
		},
		Spec: netproto.VrfSpec{
			VrfType: "CUSTOMER",
		},
	}
	err = nagent.CreateVrf(&vrf)
	if err != nil {
		log.Errorf("Failed to create vrf. {%v}", vrf)
		return
	}

	nt := netproto.Network{
		TypeMeta: api.TypeMeta{Kind: "Network"},
		ObjectMeta: api.ObjectMeta{
			Tenant:    "default",
			Namespace: "default",
			Name:      "preCreatedNetwork",
		},
		Spec: netproto.NetworkSpec{
			VlanID:      42,
			IPv4Gateway: "10.1.1.254",
		},
	}
	err = nagent.CreateNetwork(&nt)
	if err != nil {
		log.Errorf("Failed to create network. {%v}", nt)
		return
	}

	ep := netproto.Endpoint{
		TypeMeta: api.TypeMeta{Kind: "Endpoint"},
		ObjectMeta: api.ObjectMeta{
			Tenant:    "default",
			Namespace: "default",
			Name:      "preCreatedEndpoint",
		},
		Spec: netproto.EndpointSpec{
			NetworkName:   "preCreatedNetwork",
			NodeUUID:      "dummy-node-uuid",
			IPv4Addresses: []string{"10.1.1.0/24"},
			MacAddress:    "42:42:42:42:42:42",
		},
	}
	err = nagent.CreateEndpoint(&ep)
	if err != nil {
		log.Errorf("Failed to create endpoint. {%v}", ep)
		return
	}

	sg := netproto.SecurityGroup{
		TypeMeta: api.TypeMeta{Kind: "SecurityGroup"},
		ObjectMeta: api.ObjectMeta{
			Tenant:    "default",
			Namespace: "default",
			Name:      "preCreatedSecurityGroup",
		},
		Spec: netproto.SecurityGroupSpec{
			SecurityProfile: "unknown",
		},
	}
	err = nagent.CreateSecurityGroup(&sg)
	if err != nil {
		log.Errorf("Failed to create security group. {%v}", sg)
		return
	}

	natPool := netproto.NatPool{
		TypeMeta: api.TypeMeta{Kind: "NatPool"},
		ObjectMeta: api.ObjectMeta{
			Tenant:    "default",
			Namespace: "default",
			Name:      "preCreatedNatPool",
		},
		Spec: netproto.NatPoolSpec{
			IPRange: "10.1.2.1-10.1.2.200",
		},
	}
	err = nagent.CreateNatPool(&natPool)
	if err != nil {
		log.Errorf("Failed to create nat pool. {%v}", sg)
		return
	}

	natPolicy := netproto.NatPolicy{
		TypeMeta: api.TypeMeta{Kind: "NatPolicy"},
		ObjectMeta: api.ObjectMeta{
			Tenant:    "default",
			Namespace: "default",
			Name:      "preCreatedNatPolicy",
		},
		Spec: netproto.NatPolicySpec{
			Rules: []netproto.NatRule{
				{
					Src: &netproto.MatchSelector{
						Addresses: []string{"10.0.0.0 - 10.0.1.0"},
					},
					Dst: &netproto.MatchSelector{
						Addresses: []string{"192.168.0.0 - 192.168.1.1"},
					},
					NatPool: "preCreatedNatPool",
					Action:  "SNAT",
				},
			},
		},
	}

	err = nagent.CreateNatPolicy(&natPolicy)
	if err != nil {
		log.Errorf("Failed to create nat policy. {%v}", sg)
		return
	}

	tn := netproto.Tenant{
		TypeMeta: api.TypeMeta{Kind: "Tenant"},
		ObjectMeta: api.ObjectMeta{
			Tenant:    "preCreatedTenant",
			Name:      "preCreatedTenant",
			Namespace: "preCreatedTenant",
		},
	}

	err = nagent.CreateTenant(&tn)
	if err != nil {
		log.Errorf("Failed to create tenant. {%v}", tn)
		return
	}

	ns := netproto.Namespace{
		TypeMeta: api.TypeMeta{Kind: "Namespace"},
		ObjectMeta: api.ObjectMeta{
			Tenant: "preCreatedTenant",
			Name:   "preCreatedNamespace",
		},
	}

	err = nagent.CreateNamespace(&ns)
	if err != nil {
		log.Errorf("Failed to create Namespace. {%v}", ns)
		return
	}

	rt := netproto.Route{
		TypeMeta: api.TypeMeta{Kind: "Route"},
		ObjectMeta: api.ObjectMeta{
			Tenant:    "preCreatedTenant",
			Name:      "preCreatedRoute",
			Namespace: "preCreatedNamespace",
		},
		Spec: netproto.RouteSpec{
			IPPrefix:  "192.168.1.0/24",
			GatewayIP: "192.168.1.1",
			Interface: "uplink-2",
		},
	}

	err = nagent.CreateRoute(&rt)
	if err != nil {
		log.Errorf("Failed to create Route. {%v}", rt)
		return

	}

	nb := netproto.NatBinding{
		TypeMeta: api.TypeMeta{Kind: "NatBinding"},
		ObjectMeta: api.ObjectMeta{
			Tenant:    "default",
			Name:      "preCreatedNatBinding",
			Namespace: "default",
		},
		Spec: netproto.NatBindingSpec{
			NatPoolName: "preCreatedNatPool",
			IPAddress:   "10.1.1.1",
		},
	}

	err = nagent.CreateNatBinding(&nb)
	if err != nil {
		log.Errorf("Failed to create Nat Binding. {%v}", ns)
		return
	}

	ipSecEncrypt := netproto.IPSecSAEncrypt{
		TypeMeta: api.TypeMeta{Kind: "IPSecSAEncrypt"},
		ObjectMeta: api.ObjectMeta{
			Tenant:    "default",
			Namespace: "default",
			Name:      "preCreatedIPSecSAEncrypt",
		},
		Spec: netproto.IPSecSAEncryptSpec{
			Protocol:      "ESP",
			AuthAlgo:      "AES_GCM",
			AuthKey:       "someRandomString",
			EncryptAlgo:   "AES_GCM_256",
			EncryptionKey: "someRandomKey",
			LocalGwIP:     "10.0.0.1",
			RemoteGwIP:    "192.168.1.1",
			TepVrf:        "default",
		},
	}
	err = nagent.CreateIPSecSAEncrypt(&ipSecEncrypt)
	if err != nil {
		log.Errorf("Failed to create IPSec Encrypt SA. {%v}", ns)
		return
	}

	ipSecDecrypt := netproto.IPSecSADecrypt{
		TypeMeta: api.TypeMeta{Kind: "IPSecSADecrypt"},
		ObjectMeta: api.ObjectMeta{
			Tenant:    "default",
			Namespace: "default",
			Name:      "preCreatedIPSecSADecrypt",
		},
		Spec: netproto.IPSecSADecryptSpec{
			Protocol:      "ESP",
			AuthAlgo:      "AES_GCM",
			AuthKey:       "someRandomString",
			DecryptAlgo:   "AES_GCM_256",
			DecryptionKey: "someRandomKey",
			LocalGwIP:     "10.0.0.1",
			RemoteGwIP:    "192.168.1.1",
			TepVrf:        "default",
		},
	}
	err = nagent.CreateIPSecSADecrypt(&ipSecDecrypt)
	if err != nil {
		log.Errorf("Failed to create IPSec Decrypt SA. {%v}", ns)
		return
	}

	ipSecPolicy := netproto.IPSecPolicy{
		TypeMeta: api.TypeMeta{Kind: "IPSecPolicy"},
		ObjectMeta: api.ObjectMeta{
			Tenant:    "default",
			Namespace: "default",
			Name:      "preCreatedIPSecPolicy",
		},
		Spec: netproto.IPSecPolicySpec{
			Rules: []netproto.IPSecRule{
				{
					Src: &netproto.MatchSelector{
						Addresses: []string{"10.0.0.0 - 10.0.1.0"},
					},
					Dst: &netproto.MatchSelector{
						Addresses: []string{"192.168.0.1 - 192.168.1.0"},
					},
					SAName: "preCreatedIPSecSAEncrypt",
					SAType: "ENCRYPT",
				},
				{
					Src: &netproto.MatchSelector{
						Addresses: []string{"10.0.0.0 - 10.0.1.0"},
					},
					Dst: &netproto.MatchSelector{
						Addresses: []string{"192.168.0.1 - 192.168.1.0"},
					},
					SAName: "preCreatedIPSecSADecrypt",
					SAType: "DECRYPT",
				},
			},
		},
	}
	err = nagent.CreateIPSecPolicy(&ipSecPolicy)
	if err != nil {
		log.Errorf("Failed to create IPSec Policy. {%v}", ns)
		return
	}

	sgPolicy := netproto.NetworkSecurityPolicy{
		TypeMeta: api.TypeMeta{Kind: "NetworkSecurityPolicy"},
		ObjectMeta: api.ObjectMeta{
			Tenant:    "default",
			Namespace: "default",
			Name:      "preCreatedNetworkSecurityPolicy",
		},
		Spec: netproto.NetworkSecurityPolicySpec{
			AttachGroup:  []string{"preCreatedSecurityGroup"},
			AttachTenant: false,
			Rules: []netproto.PolicyRule{
				{
					Action: "PERMIT",
					Src: &netproto.MatchSelector{
						Addresses: []string{"10.0.0.0 - 10.0.1.0"},
						AppConfigs: []*netproto.AppConfig{
							{
								Port:     "80",
								Protocol: "tcp",
							},
						},
					},
					Dst: &netproto.MatchSelector{
						Addresses: []string{"192.168.0.1 - 192.168.1.0"},
					},
				},
			},
		},
	}

	err = nagent.CreateNetworkSecurityPolicy(&sgPolicy)
	if err != nil {
		log.Errorf("Failed to create SG policy. {%v}", sg)
		return
	}

	tunnel := netproto.Tunnel{
		TypeMeta: api.TypeMeta{Kind: "Tunnel"},
		ObjectMeta: api.ObjectMeta{
			Tenant:    "default",
			Namespace: "default",
			Name:      "preCreatedTunnel",
		},
		Spec: netproto.TunnelSpec{
			Type:        "VXLAN",
			AdminStatus: "UP",
			Src:         "10.1.1.1",
			Dst:         "192.168.1.1",
		},
	}

	err = nagent.CreateTunnel(&tunnel)
	if err != nil {
		log.Errorf("Failed to create tunnel. {%v}", tunnel)
		return
	}

	tcpProxy := netproto.TCPProxyPolicy{
		TypeMeta: api.TypeMeta{Kind: "TCPProxyPolicy"},
		ObjectMeta: api.ObjectMeta{
			Tenant:    "default",
			Namespace: "default",
			Name:      "preCreatedTCPProxyPolicy",
		},
		Spec: netproto.TCPProxyPolicySpec{
			Rules: []netproto.TCPProxyRule{
				{
					Src: &netproto.MatchSelector{
						Addresses: []string{"64.0.0.1"},
					},

					Dst: &netproto.MatchSelector{
						Addresses: []string{"100.0.0.1"},
					},
					Action: "ENABLE",
				},
			},
		},
	}

	err = nagent.CreateTCPProxyPolicy(&tcpProxy)
	if err != nil {
		log.Errorf("Failed to create tcp proxy policy. {%v}", tcpProxy)
		return
	}

	enic := netproto.Interface{
		TypeMeta: api.TypeMeta{Kind: "Interface"},
		ObjectMeta: api.ObjectMeta{
			Tenant:    "default",
			Namespace: "default",
			Name:      "preCreatedInterface",
		},
		Spec: netproto.InterfaceSpec{
			Type:        "ENIC",
			AdminStatus: "UP",
		},
		Status: netproto.InterfaceStatus{
			OperStatus: "UP",
		},
	}

	err = nagent.CreateInterface(&enic)
	if err != nil {
		log.Errorf("Failed to create ENIC. {%v}", enic)
		return
	}

	port := netproto.Port{
		TypeMeta: api.TypeMeta{Kind: "Port"},
		ObjectMeta: api.ObjectMeta{
			Tenant:    "default",
			Namespace: "default",
			Name:      "preCreatedPort",
		},
		Spec: netproto.PortSpec{
			Speed:        "SPEED_100G",
			Type:         "TYPE_ETHERNET",
			AdminStatus:  "UP",
			BreakoutMode: "BREAKOUT_NONE",
			Lanes:        4,
		},
	}

	err = nagent.CreatePort(&port)
	if err != nil {
		log.Errorf("Failed to create port. {%v}", enic)
		return
	}

	secProfile := netproto.SecurityProfile{
		TypeMeta: api.TypeMeta{Kind: "SecurityProfile"},
		ObjectMeta: api.ObjectMeta{
			Tenant:    "default",
			Namespace: "default",
			Name:      "preCreatedSecurityProfile",
		},
		Spec: netproto.SecurityProfileSpec{
			Timeouts: &netproto.Timeouts{
				SessionIdle:        "10s",
				TCP:                "1m",
				TCPDrop:            "5s",
				TCPConnectionSetup: "300ms",
				TCPClose:           "1h",
				Drop:               "30s",
				UDP:                "5s",
				UDPDrop:            "1s",
				ICMP:               "100ms",
				ICMPDrop:           "1h10m15s",
			},
		},
	}

	err = nagent.CreateSecurityProfile(&secProfile)
	if err != nil {
		log.Errorf("Failed to create security profile. {%v}", secProfile)
		return
	}

	app := netproto.App{
		TypeMeta: api.TypeMeta{Kind: "App"},
		ObjectMeta: api.ObjectMeta{
			Tenant:    "default",
			Namespace: "default",
			Name:      "preCreatedApp",
		},
		Spec: netproto.AppSpec{
			ProtoPorts: []string{"udp/53"},
			ALG: &netproto.ALG{
				DNS: &netproto.DNS{
					DropLargeDomainPackets: true,
					QueryResponseTimeout:   "30s",
				},
			},
		},
	}

	err = nagent.CreateApp(&app)
	if err != nil {
		log.Errorf("Failed to create app. %v", app)
	}

	return nil
}
