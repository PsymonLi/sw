// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ipam.proto

package netproto

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "google.golang.org/genproto/googleapis/api/annotations"
import _ "github.com/pensando/sw/venice/utils/apigen/annotations"
import _ "github.com/gogo/protobuf/gogoproto"
import api "github.com/pensando/sw/api"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type IPAMPolicySpec_IPAMType int32

const (
	IPAMPolicySpec_DHCP_Relay IPAMPolicySpec_IPAMType = 0
)

var IPAMPolicySpec_IPAMType_name = map[int32]string{
	0: "DHCP_Relay",
}
var IPAMPolicySpec_IPAMType_value = map[string]int32{
	"DHCP_Relay": 0,
}

func (x IPAMPolicySpec_IPAMType) String() string {
	return proto.EnumName(IPAMPolicySpec_IPAMType_name, int32(x))
}
func (IPAMPolicySpec_IPAMType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorIpam, []int{2, 0}
}

type DHCPServer struct {
	// IP Address of the server.
	IPAddress string `protobuf:"bytes,1,opt,name=IPAddress,proto3" json:"ip-address,omitempty"`
	// Destination VRF where the server is connected. An empty value specifies that the server is reachable in the same vrf as the one where the policy is attached.
	VirtualRouter string `protobuf:"bytes,2,opt,name=VirtualRouter,proto3" json:"virtual-router,omitempty"`
}

func (m *DHCPServer) Reset()                    { *m = DHCPServer{} }
func (m *DHCPServer) String() string            { return proto.CompactTextString(m) }
func (*DHCPServer) ProtoMessage()               {}
func (*DHCPServer) Descriptor() ([]byte, []int) { return fileDescriptorIpam, []int{0} }

func (m *DHCPServer) GetIPAddress() string {
	if m != nil {
		return m.IPAddress
	}
	return ""
}

func (m *DHCPServer) GetVirtualRouter() string {
	if m != nil {
		return m.VirtualRouter
	}
	return ""
}

type DHCPRelayPolicy struct {
	Servers []*DHCPServer `protobuf:"bytes,1,rep,name=Servers" json:"relay-servers,omitempty"`
}

func (m *DHCPRelayPolicy) Reset()                    { *m = DHCPRelayPolicy{} }
func (m *DHCPRelayPolicy) String() string            { return proto.CompactTextString(m) }
func (*DHCPRelayPolicy) ProtoMessage()               {}
func (*DHCPRelayPolicy) Descriptor() ([]byte, []int) { return fileDescriptorIpam, []int{1} }

func (m *DHCPRelayPolicy) GetServers() []*DHCPServer {
	if m != nil {
		return m.Servers
	}
	return nil
}

type IPAMPolicySpec struct {
	Type      string           `protobuf:"bytes,1,opt,name=Type,proto3" json:"type,omitempty"`
	DHCPRelay *DHCPRelayPolicy `protobuf:"bytes,2,opt,name=DHCPRelay" json:"dhcp-relay,omitempty"`
}

func (m *IPAMPolicySpec) Reset()                    { *m = IPAMPolicySpec{} }
func (m *IPAMPolicySpec) String() string            { return proto.CompactTextString(m) }
func (*IPAMPolicySpec) ProtoMessage()               {}
func (*IPAMPolicySpec) Descriptor() ([]byte, []int) { return fileDescriptorIpam, []int{2} }

func (m *IPAMPolicySpec) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *IPAMPolicySpec) GetDHCPRelay() *DHCPRelayPolicy {
	if m != nil {
		return m.DHCPRelay
	}
	return nil
}

type IPAMPolicyStatus struct {
}

func (m *IPAMPolicyStatus) Reset()                    { *m = IPAMPolicyStatus{} }
func (m *IPAMPolicyStatus) String() string            { return proto.CompactTextString(m) }
func (*IPAMPolicyStatus) ProtoMessage()               {}
func (*IPAMPolicyStatus) Descriptor() ([]byte, []int) { return fileDescriptorIpam, []int{3} }

type IPAMPolicyEvent struct {
	EventType  api.EventType `protobuf:"varint,1,opt,name=EventType,proto3,enum=api.EventType" json:"event-type,omitempty"`
	IPAMPolicy IPAMPolicy    `protobuf:"bytes,2,opt,name=IPAMPolicy" json:"ipam-policy,omitempty"`
}

func (m *IPAMPolicyEvent) Reset()                    { *m = IPAMPolicyEvent{} }
func (m *IPAMPolicyEvent) String() string            { return proto.CompactTextString(m) }
func (*IPAMPolicyEvent) ProtoMessage()               {}
func (*IPAMPolicyEvent) Descriptor() ([]byte, []int) { return fileDescriptorIpam, []int{4} }

func (m *IPAMPolicyEvent) GetEventType() api.EventType {
	if m != nil {
		return m.EventType
	}
	return api.EventType_CreateEvent
}

func (m *IPAMPolicyEvent) GetIPAMPolicy() IPAMPolicy {
	if m != nil {
		return m.IPAMPolicy
	}
	return IPAMPolicy{}
}

type IPAMPolicyEventList struct {
	IPAMPolicyEvents []*IPAMPolicyEvent `protobuf:"bytes,1,rep,name=iPAMPolicyEvents" json:"iPAMPolicyEvents,omitempty"`
}

func (m *IPAMPolicyEventList) Reset()                    { *m = IPAMPolicyEventList{} }
func (m *IPAMPolicyEventList) String() string            { return proto.CompactTextString(m) }
func (*IPAMPolicyEventList) ProtoMessage()               {}
func (*IPAMPolicyEventList) Descriptor() ([]byte, []int) { return fileDescriptorIpam, []int{5} }

func (m *IPAMPolicyEventList) GetIPAMPolicyEvents() []*IPAMPolicyEvent {
	if m != nil {
		return m.IPAMPolicyEvents
	}
	return nil
}

type IPAMPolicyList struct {
	IPAMPolicys []*IPAMPolicy `protobuf:"bytes,1,rep,name=iPAMPolicys" json:"iPAMPolicys,omitempty"`
}

func (m *IPAMPolicyList) Reset()                    { *m = IPAMPolicyList{} }
func (m *IPAMPolicyList) String() string            { return proto.CompactTextString(m) }
func (*IPAMPolicyList) ProtoMessage()               {}
func (*IPAMPolicyList) Descriptor() ([]byte, []int) { return fileDescriptorIpam, []int{6} }

func (m *IPAMPolicyList) GetIPAMPolicys() []*IPAMPolicy {
	if m != nil {
		return m.IPAMPolicys
	}
	return nil
}

type IPAMPolicy struct {
	api.TypeMeta   `protobuf:"bytes,1,opt,name=TypeMeta,embedded=TypeMeta" json:",inline"`
	api.ObjectMeta `protobuf:"bytes,2,opt,name=ObjectMeta,embedded=ObjectMeta" json:"meta,omitempty"`
	Spec           IPAMPolicySpec   `protobuf:"bytes,3,opt,name=Spec" json:"spec,omitempty"`
	Status         IPAMPolicyStatus `protobuf:"bytes,4,opt,name=Status" json:"status,omitempty"`
}

func (m *IPAMPolicy) Reset()                    { *m = IPAMPolicy{} }
func (m *IPAMPolicy) String() string            { return proto.CompactTextString(m) }
func (*IPAMPolicy) ProtoMessage()               {}
func (*IPAMPolicy) Descriptor() ([]byte, []int) { return fileDescriptorIpam, []int{7} }

func (m *IPAMPolicy) GetSpec() IPAMPolicySpec {
	if m != nil {
		return m.Spec
	}
	return IPAMPolicySpec{}
}

func (m *IPAMPolicy) GetStatus() IPAMPolicyStatus {
	if m != nil {
		return m.Status
	}
	return IPAMPolicyStatus{}
}

func init() {
	proto.RegisterType((*DHCPServer)(nil), "netproto.DHCPServer")
	proto.RegisterType((*DHCPRelayPolicy)(nil), "netproto.DHCPRelayPolicy")
	proto.RegisterType((*IPAMPolicySpec)(nil), "netproto.IPAMPolicySpec")
	proto.RegisterType((*IPAMPolicyStatus)(nil), "netproto.IPAMPolicyStatus")
	proto.RegisterType((*IPAMPolicyEvent)(nil), "netproto.IPAMPolicyEvent")
	proto.RegisterType((*IPAMPolicyEventList)(nil), "netproto.IPAMPolicyEventList")
	proto.RegisterType((*IPAMPolicyList)(nil), "netproto.IPAMPolicyList")
	proto.RegisterType((*IPAMPolicy)(nil), "netproto.IPAMPolicy")
	proto.RegisterEnum("netproto.IPAMPolicySpec_IPAMType", IPAMPolicySpec_IPAMType_name, IPAMPolicySpec_IPAMType_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for IPAMPolicyApi service

type IPAMPolicyApiClient interface {
	GetIPAMPolicy(ctx context.Context, in *api.ObjectMeta, opts ...grpc.CallOption) (*IPAMPolicy, error)
	ListIPAMPolicys(ctx context.Context, in *api.ObjectMeta, opts ...grpc.CallOption) (*IPAMPolicyList, error)
	WatchIPAMPolicys(ctx context.Context, in *api.ObjectMeta, opts ...grpc.CallOption) (IPAMPolicyApi_WatchIPAMPolicysClient, error)
	UpdateIPAMPolicy(ctx context.Context, in *IPAMPolicy, opts ...grpc.CallOption) (*IPAMPolicy, error)
	IPAMPolicyOperUpdate(ctx context.Context, opts ...grpc.CallOption) (IPAMPolicyApi_IPAMPolicyOperUpdateClient, error)
}

type iPAMPolicyApiClient struct {
	cc *grpc.ClientConn
}

func NewIPAMPolicyApiClient(cc *grpc.ClientConn) IPAMPolicyApiClient {
	return &iPAMPolicyApiClient{cc}
}

func (c *iPAMPolicyApiClient) GetIPAMPolicy(ctx context.Context, in *api.ObjectMeta, opts ...grpc.CallOption) (*IPAMPolicy, error) {
	out := new(IPAMPolicy)
	err := grpc.Invoke(ctx, "/netproto.IPAMPolicyApi/GetIPAMPolicy", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iPAMPolicyApiClient) ListIPAMPolicys(ctx context.Context, in *api.ObjectMeta, opts ...grpc.CallOption) (*IPAMPolicyList, error) {
	out := new(IPAMPolicyList)
	err := grpc.Invoke(ctx, "/netproto.IPAMPolicyApi/ListIPAMPolicys", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iPAMPolicyApiClient) WatchIPAMPolicys(ctx context.Context, in *api.ObjectMeta, opts ...grpc.CallOption) (IPAMPolicyApi_WatchIPAMPolicysClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_IPAMPolicyApi_serviceDesc.Streams[0], c.cc, "/netproto.IPAMPolicyApi/WatchIPAMPolicys", opts...)
	if err != nil {
		return nil, err
	}
	x := &iPAMPolicyApiWatchIPAMPolicysClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type IPAMPolicyApi_WatchIPAMPolicysClient interface {
	Recv() (*IPAMPolicyEventList, error)
	grpc.ClientStream
}

type iPAMPolicyApiWatchIPAMPolicysClient struct {
	grpc.ClientStream
}

func (x *iPAMPolicyApiWatchIPAMPolicysClient) Recv() (*IPAMPolicyEventList, error) {
	m := new(IPAMPolicyEventList)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *iPAMPolicyApiClient) UpdateIPAMPolicy(ctx context.Context, in *IPAMPolicy, opts ...grpc.CallOption) (*IPAMPolicy, error) {
	out := new(IPAMPolicy)
	err := grpc.Invoke(ctx, "/netproto.IPAMPolicyApi/UpdateIPAMPolicy", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iPAMPolicyApiClient) IPAMPolicyOperUpdate(ctx context.Context, opts ...grpc.CallOption) (IPAMPolicyApi_IPAMPolicyOperUpdateClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_IPAMPolicyApi_serviceDesc.Streams[1], c.cc, "/netproto.IPAMPolicyApi/IPAMPolicyOperUpdate", opts...)
	if err != nil {
		return nil, err
	}
	x := &iPAMPolicyApiIPAMPolicyOperUpdateClient{stream}
	return x, nil
}

type IPAMPolicyApi_IPAMPolicyOperUpdateClient interface {
	Send(*IPAMPolicyEvent) error
	CloseAndRecv() (*api.TypeMeta, error)
	grpc.ClientStream
}

type iPAMPolicyApiIPAMPolicyOperUpdateClient struct {
	grpc.ClientStream
}

func (x *iPAMPolicyApiIPAMPolicyOperUpdateClient) Send(m *IPAMPolicyEvent) error {
	return x.ClientStream.SendMsg(m)
}

func (x *iPAMPolicyApiIPAMPolicyOperUpdateClient) CloseAndRecv() (*api.TypeMeta, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(api.TypeMeta)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for IPAMPolicyApi service

type IPAMPolicyApiServer interface {
	GetIPAMPolicy(context.Context, *api.ObjectMeta) (*IPAMPolicy, error)
	ListIPAMPolicys(context.Context, *api.ObjectMeta) (*IPAMPolicyList, error)
	WatchIPAMPolicys(*api.ObjectMeta, IPAMPolicyApi_WatchIPAMPolicysServer) error
	UpdateIPAMPolicy(context.Context, *IPAMPolicy) (*IPAMPolicy, error)
	IPAMPolicyOperUpdate(IPAMPolicyApi_IPAMPolicyOperUpdateServer) error
}

func RegisterIPAMPolicyApiServer(s *grpc.Server, srv IPAMPolicyApiServer) {
	s.RegisterService(&_IPAMPolicyApi_serviceDesc, srv)
}

func _IPAMPolicyApi_GetIPAMPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(api.ObjectMeta)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IPAMPolicyApiServer).GetIPAMPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/netproto.IPAMPolicyApi/GetIPAMPolicy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IPAMPolicyApiServer).GetIPAMPolicy(ctx, req.(*api.ObjectMeta))
	}
	return interceptor(ctx, in, info, handler)
}

func _IPAMPolicyApi_ListIPAMPolicys_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(api.ObjectMeta)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IPAMPolicyApiServer).ListIPAMPolicys(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/netproto.IPAMPolicyApi/ListIPAMPolicys",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IPAMPolicyApiServer).ListIPAMPolicys(ctx, req.(*api.ObjectMeta))
	}
	return interceptor(ctx, in, info, handler)
}

func _IPAMPolicyApi_WatchIPAMPolicys_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(api.ObjectMeta)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(IPAMPolicyApiServer).WatchIPAMPolicys(m, &iPAMPolicyApiWatchIPAMPolicysServer{stream})
}

type IPAMPolicyApi_WatchIPAMPolicysServer interface {
	Send(*IPAMPolicyEventList) error
	grpc.ServerStream
}

type iPAMPolicyApiWatchIPAMPolicysServer struct {
	grpc.ServerStream
}

func (x *iPAMPolicyApiWatchIPAMPolicysServer) Send(m *IPAMPolicyEventList) error {
	return x.ServerStream.SendMsg(m)
}

func _IPAMPolicyApi_UpdateIPAMPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IPAMPolicy)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IPAMPolicyApiServer).UpdateIPAMPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/netproto.IPAMPolicyApi/UpdateIPAMPolicy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IPAMPolicyApiServer).UpdateIPAMPolicy(ctx, req.(*IPAMPolicy))
	}
	return interceptor(ctx, in, info, handler)
}

func _IPAMPolicyApi_IPAMPolicyOperUpdate_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(IPAMPolicyApiServer).IPAMPolicyOperUpdate(&iPAMPolicyApiIPAMPolicyOperUpdateServer{stream})
}

type IPAMPolicyApi_IPAMPolicyOperUpdateServer interface {
	SendAndClose(*api.TypeMeta) error
	Recv() (*IPAMPolicyEvent, error)
	grpc.ServerStream
}

type iPAMPolicyApiIPAMPolicyOperUpdateServer struct {
	grpc.ServerStream
}

func (x *iPAMPolicyApiIPAMPolicyOperUpdateServer) SendAndClose(m *api.TypeMeta) error {
	return x.ServerStream.SendMsg(m)
}

func (x *iPAMPolicyApiIPAMPolicyOperUpdateServer) Recv() (*IPAMPolicyEvent, error) {
	m := new(IPAMPolicyEvent)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _IPAMPolicyApi_serviceDesc = grpc.ServiceDesc{
	ServiceName: "netproto.IPAMPolicyApi",
	HandlerType: (*IPAMPolicyApiServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetIPAMPolicy",
			Handler:    _IPAMPolicyApi_GetIPAMPolicy_Handler,
		},
		{
			MethodName: "ListIPAMPolicys",
			Handler:    _IPAMPolicyApi_ListIPAMPolicys_Handler,
		},
		{
			MethodName: "UpdateIPAMPolicy",
			Handler:    _IPAMPolicyApi_UpdateIPAMPolicy_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "WatchIPAMPolicys",
			Handler:       _IPAMPolicyApi_WatchIPAMPolicys_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "IPAMPolicyOperUpdate",
			Handler:       _IPAMPolicyApi_IPAMPolicyOperUpdate_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "ipam.proto",
}

func (m *DHCPServer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DHCPServer) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.IPAddress) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintIpam(dAtA, i, uint64(len(m.IPAddress)))
		i += copy(dAtA[i:], m.IPAddress)
	}
	if len(m.VirtualRouter) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintIpam(dAtA, i, uint64(len(m.VirtualRouter)))
		i += copy(dAtA[i:], m.VirtualRouter)
	}
	return i, nil
}

func (m *DHCPRelayPolicy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DHCPRelayPolicy) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Servers) > 0 {
		for _, msg := range m.Servers {
			dAtA[i] = 0xa
			i++
			i = encodeVarintIpam(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *IPAMPolicySpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IPAMPolicySpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintIpam(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if m.DHCPRelay != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintIpam(dAtA, i, uint64(m.DHCPRelay.Size()))
		n1, err := m.DHCPRelay.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	return i, nil
}

func (m *IPAMPolicyStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IPAMPolicyStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *IPAMPolicyEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IPAMPolicyEvent) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.EventType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintIpam(dAtA, i, uint64(m.EventType))
	}
	dAtA[i] = 0x12
	i++
	i = encodeVarintIpam(dAtA, i, uint64(m.IPAMPolicy.Size()))
	n2, err := m.IPAMPolicy.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n2
	return i, nil
}

func (m *IPAMPolicyEventList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IPAMPolicyEventList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.IPAMPolicyEvents) > 0 {
		for _, msg := range m.IPAMPolicyEvents {
			dAtA[i] = 0xa
			i++
			i = encodeVarintIpam(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *IPAMPolicyList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IPAMPolicyList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.IPAMPolicys) > 0 {
		for _, msg := range m.IPAMPolicys {
			dAtA[i] = 0xa
			i++
			i = encodeVarintIpam(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *IPAMPolicy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IPAMPolicy) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintIpam(dAtA, i, uint64(m.TypeMeta.Size()))
	n3, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n3
	dAtA[i] = 0x12
	i++
	i = encodeVarintIpam(dAtA, i, uint64(m.ObjectMeta.Size()))
	n4, err := m.ObjectMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n4
	dAtA[i] = 0x1a
	i++
	i = encodeVarintIpam(dAtA, i, uint64(m.Spec.Size()))
	n5, err := m.Spec.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n5
	dAtA[i] = 0x22
	i++
	i = encodeVarintIpam(dAtA, i, uint64(m.Status.Size()))
	n6, err := m.Status.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n6
	return i, nil
}

func encodeVarintIpam(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *DHCPServer) Size() (n int) {
	var l int
	_ = l
	l = len(m.IPAddress)
	if l > 0 {
		n += 1 + l + sovIpam(uint64(l))
	}
	l = len(m.VirtualRouter)
	if l > 0 {
		n += 1 + l + sovIpam(uint64(l))
	}
	return n
}

func (m *DHCPRelayPolicy) Size() (n int) {
	var l int
	_ = l
	if len(m.Servers) > 0 {
		for _, e := range m.Servers {
			l = e.Size()
			n += 1 + l + sovIpam(uint64(l))
		}
	}
	return n
}

func (m *IPAMPolicySpec) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovIpam(uint64(l))
	}
	if m.DHCPRelay != nil {
		l = m.DHCPRelay.Size()
		n += 1 + l + sovIpam(uint64(l))
	}
	return n
}

func (m *IPAMPolicyStatus) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *IPAMPolicyEvent) Size() (n int) {
	var l int
	_ = l
	if m.EventType != 0 {
		n += 1 + sovIpam(uint64(m.EventType))
	}
	l = m.IPAMPolicy.Size()
	n += 1 + l + sovIpam(uint64(l))
	return n
}

func (m *IPAMPolicyEventList) Size() (n int) {
	var l int
	_ = l
	if len(m.IPAMPolicyEvents) > 0 {
		for _, e := range m.IPAMPolicyEvents {
			l = e.Size()
			n += 1 + l + sovIpam(uint64(l))
		}
	}
	return n
}

func (m *IPAMPolicyList) Size() (n int) {
	var l int
	_ = l
	if len(m.IPAMPolicys) > 0 {
		for _, e := range m.IPAMPolicys {
			l = e.Size()
			n += 1 + l + sovIpam(uint64(l))
		}
	}
	return n
}

func (m *IPAMPolicy) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovIpam(uint64(l))
	l = m.ObjectMeta.Size()
	n += 1 + l + sovIpam(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovIpam(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovIpam(uint64(l))
	return n
}

func sovIpam(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozIpam(x uint64) (n int) {
	return sovIpam(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *DHCPServer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIpam
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DHCPServer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DHCPServer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IPAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpam
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIpam
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IPAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VirtualRouter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpam
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIpam
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VirtualRouter = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIpam(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIpam
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DHCPRelayPolicy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIpam
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DHCPRelayPolicy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DHCPRelayPolicy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Servers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpam
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIpam
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Servers = append(m.Servers, &DHCPServer{})
			if err := m.Servers[len(m.Servers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIpam(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIpam
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IPAMPolicySpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIpam
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IPAMPolicySpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IPAMPolicySpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpam
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIpam
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DHCPRelay", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpam
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIpam
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DHCPRelay == nil {
				m.DHCPRelay = &DHCPRelayPolicy{}
			}
			if err := m.DHCPRelay.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIpam(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIpam
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IPAMPolicyStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIpam
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IPAMPolicyStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IPAMPolicyStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipIpam(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIpam
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IPAMPolicyEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIpam
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IPAMPolicyEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IPAMPolicyEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventType", wireType)
			}
			m.EventType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpam
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EventType |= (api.EventType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IPAMPolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpam
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIpam
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.IPAMPolicy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIpam(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIpam
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IPAMPolicyEventList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIpam
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IPAMPolicyEventList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IPAMPolicyEventList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IPAMPolicyEvents", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpam
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIpam
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IPAMPolicyEvents = append(m.IPAMPolicyEvents, &IPAMPolicyEvent{})
			if err := m.IPAMPolicyEvents[len(m.IPAMPolicyEvents)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIpam(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIpam
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IPAMPolicyList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIpam
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IPAMPolicyList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IPAMPolicyList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IPAMPolicys", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpam
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIpam
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IPAMPolicys = append(m.IPAMPolicys, &IPAMPolicy{})
			if err := m.IPAMPolicys[len(m.IPAMPolicys)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIpam(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIpam
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IPAMPolicy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIpam
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IPAMPolicy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IPAMPolicy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpam
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIpam
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpam
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIpam
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpam
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIpam
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpam
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIpam
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIpam(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIpam
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipIpam(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowIpam
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowIpam
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowIpam
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthIpam
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowIpam
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipIpam(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthIpam = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowIpam   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("ipam.proto", fileDescriptorIpam) }

var fileDescriptorIpam = []byte{
	// 809 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x7c, 0x55, 0xcd, 0x6e, 0xdb, 0x46,
	0x10, 0x16, 0x6d, 0xc1, 0x96, 0x56, 0xd5, 0x4f, 0xd7, 0x6e, 0x4b, 0xb1, 0xb6, 0x65, 0x10, 0x2d,
	0xa0, 0x02, 0x16, 0x59, 0xa8, 0x80, 0xd1, 0x4b, 0x8d, 0x9a, 0xb5, 0x5c, 0xbb, 0xb6, 0x6b, 0x45,
	0x72, 0x92, 0x4b, 0x90, 0x60, 0x45, 0x6d, 0xa4, 0x0d, 0x28, 0x72, 0x41, 0x2e, 0x15, 0x08, 0x81,
	0x4f, 0x01, 0xfc, 0x04, 0x79, 0x0a, 0x03, 0xc9, 0x21, 0xaf, 0x90, 0x8b, 0x81, 0x5c, 0xfc, 0x04,
	0x42, 0xe0, 0xa3, 0x9e, 0x22, 0xd8, 0xa5, 0x24, 0xae, 0x6c, 0x29, 0x37, 0xce, 0xec, 0x37, 0xdf,
	0x7e, 0xdf, 0xcc, 0x2c, 0x08, 0x00, 0xa1, 0xa8, 0x67, 0x50, 0xdf, 0x63, 0x1e, 0x4c, 0xb9, 0x98,
	0x89, 0x2f, 0x6d, 0xa3, 0xe3, 0x79, 0x1d, 0x07, 0x9b, 0x88, 0x12, 0x13, 0xb9, 0xae, 0xc7, 0x10,
	0x23, 0x9e, 0x1b, 0x44, 0x38, 0xad, 0xd6, 0x21, 0xac, 0x1b, 0xb6, 0x0c, 0xdb, 0xeb, 0x99, 0x14,
	0xbb, 0x01, 0x72, 0xdb, 0x9e, 0x19, 0xbc, 0x36, 0xfb, 0xd8, 0x25, 0x36, 0x36, 0x43, 0x46, 0x9c,
	0x80, 0x97, 0x76, 0xb0, 0x2b, 0x57, 0x9b, 0xc4, 0xb5, 0x9d, 0xb0, 0x8d, 0x27, 0x34, 0x15, 0x89,
	0xa6, 0xe3, 0x75, 0x3c, 0x53, 0xa4, 0x5b, 0xe1, 0x4b, 0x11, 0x89, 0x40, 0x7c, 0x8d, 0xe1, 0xbf,
	0x2e, 0xb8, 0x95, 0x6b, 0xec, 0x61, 0x86, 0x22, 0x98, 0xfe, 0x4e, 0x01, 0xe0, 0xe0, 0xe8, 0x9f,
	0x7a, 0x13, 0xfb, 0x7d, 0xec, 0x43, 0x0b, 0xa4, 0x8f, 0xeb, 0xfb, 0xed, 0xb6, 0x8f, 0x83, 0x40,
	0x55, 0xb6, 0x95, 0x72, 0xda, 0xfa, 0xe5, 0xfa, 0xaa, 0x98, 0x8a, 0x92, 0xe5, 0xdf, 0x46, 0xc3,
	0xd2, 0x3a, 0xa1, 0x15, 0x14, 0x21, 0x76, 0xbc, 0x1e, 0x61, 0xb8, 0x47, 0xd9, 0xa0, 0x11, 0x97,
	0x41, 0x0b, 0x64, 0x9f, 0x10, 0x9f, 0x85, 0xc8, 0x69, 0x78, 0x21, 0xc3, 0xbe, 0xba, 0x24, 0x78,
	0x36, 0x46, 0xc3, 0x92, 0xda, 0x8f, 0x0e, 0x2a, 0xbe, 0x38, 0x91, 0xea, 0x67, 0x4b, 0xf4, 0xe7,
	0x20, 0xcf, 0x55, 0x35, 0xb0, 0x83, 0x06, 0x75, 0xcf, 0x21, 0xf6, 0x00, 0x9e, 0x80, 0xd5, 0x48,
	0x24, 0x17, 0xb6, 0x5c, 0xce, 0x54, 0xd7, 0x8d, 0xc9, 0x00, 0x8c, 0xd8, 0x81, 0xf5, 0xf3, 0x68,
	0x58, 0xfa, 0xc9, 0xe7, 0x75, 0x95, 0x20, 0x82, 0x4b, 0xb7, 0x4c, 0x18, 0xf4, 0xcf, 0x0a, 0xc8,
	0x1d, 0xd7, 0xf7, 0xcf, 0x22, 0xee, 0x26, 0xc5, 0x36, 0xfc, 0x0f, 0x24, 0x2f, 0x06, 0x14, 0x8f,
	0x5d, 0xef, 0x5e, 0x5f, 0x15, 0xb7, 0x9b, 0xcc, 0xaf, 0xb9, 0x61, 0xaf, 0x3c, 0x8b, 0x34, 0x78,
	0xc8, 0xa1, 0xbc, 0x1b, 0x39, 0x36, 0xa0, 0x58, 0xba, 0x41, 0x70, 0xc0, 0x47, 0x20, 0x3d, 0x95,
	0x2f, 0xec, 0x67, 0xaa, 0xc5, 0x59, 0xb5, 0x92, 0x33, 0x4b, 0xe5, 0x5d, 0x6d, 0x77, 0x6d, 0x5a,
	0x11, 0xba, 0xe5, 0xae, 0x4e, 0xa1, 0xba, 0x06, 0x52, 0x93, 0x7b, 0x61, 0x2e, 0x9a, 0xd9, 0x0b,
	0x71, 0x52, 0x48, 0xe8, 0x10, 0x14, 0x24, 0x89, 0x0c, 0xb1, 0x30, 0xd0, 0x3f, 0x28, 0x20, 0x1f,
	0x27, 0x6b, 0x7d, 0xec, 0x32, 0x78, 0x08, 0xd2, 0xe2, 0x63, 0xea, 0x33, 0x57, 0xcd, 0x19, 0x88,
	0x12, 0x63, 0x9a, 0x8d, 0xb4, 0x60, 0x1e, 0x56, 0xee, 0x39, 0x8b, 0x4b, 0x61, 0x13, 0x80, 0x98,
	0x7a, 0xec, 0x4f, 0x9a, 0x46, 0x7c, 0x66, 0x6d, 0xde, 0x0c, 0x4b, 0x89, 0xd1, 0xb0, 0xf4, 0x03,
	0x7f, 0x37, 0x15, 0x2a, 0x92, 0x12, 0xa7, 0x44, 0xa3, 0x3f, 0x03, 0x6b, 0xf7, 0xf4, 0x9e, 0x92,
	0x80, 0xc1, 0x1a, 0x28, 0x90, 0xd9, 0xf4, 0x64, 0xfe, 0xc5, 0x79, 0x37, 0x0a, 0x44, 0xe3, 0x41,
	0x89, 0x7e, 0x24, 0xcf, 0x5b, 0x10, 0xef, 0x82, 0x4c, 0x8c, 0x9a, 0xb3, 0x53, 0x31, 0xbc, 0x21,
	0x03, 0xf5, 0xf7, 0x4b, 0xb2, 0x7b, 0xb8, 0x07, 0x52, 0xbc, 0x27, 0x67, 0x98, 0x21, 0xd1, 0xd2,
	0x4c, 0x35, 0x2b, 0x5a, 0x3a, 0x49, 0x5a, 0x6b, 0xbc, 0x05, 0xb7, 0xc3, 0x92, 0x32, 0x1a, 0x96,
	0x56, 0x77, 0x88, 0xeb, 0x10, 0x17, 0x37, 0xa6, 0x35, 0xf0, 0x04, 0x80, 0xf3, 0xd6, 0x2b, 0x6c,
	0x33, 0xc1, 0x10, 0xf5, 0x32, 0x2f, 0x18, 0xe2, 0xb4, 0xa5, 0x49, 0x1c, 0x39, 0xfe, 0x7a, 0xe5,
	0x1e, 0xc6, 0x38, 0x78, 0x00, 0x92, 0x7c, 0x43, 0xd5, 0x65, 0x41, 0xa3, 0xce, 0x33, 0xc3, 0xcf,
	0xad, 0x1f, 0xc7, 0x63, 0xc9, 0x05, 0x14, 0xdb, 0xf2, 0xf6, 0x8a, 0x97, 0x70, 0x0a, 0x56, 0xa2,
	0x25, 0x52, 0x93, 0x82, 0x47, 0x9b, 0xcb, 0x23, 0x10, 0x96, 0x3a, 0x66, 0x2a, 0x04, 0x22, 0x96,
	0xb8, 0xc6, 0x1c, 0xd5, 0x4f, 0xcb, 0x20, 0x1b, 0x97, 0xed, 0x53, 0x02, 0xff, 0x04, 0xd9, 0x7f,
	0x31, 0x93, 0x7a, 0x78, 0xdf, 0xaf, 0x36, 0x77, 0x0c, 0x7a, 0x02, 0xee, 0x81, 0x3c, 0x9f, 0x5d,
	0x9c, 0x0b, 0x1e, 0xd6, 0xce, 0x75, 0xcd, 0xab, 0xf4, 0x04, 0x3c, 0x04, 0x85, 0xa7, 0x88, 0xd9,
	0xdd, 0x6f, 0x12, 0x6c, 0x2e, 0xdc, 0xab, 0x88, 0xe5, 0x77, 0x05, 0xfe, 0x0d, 0x0a, 0x8f, 0x69,
	0x1b, 0x31, 0x2c, 0x99, 0x98, 0xab, 0x79, 0xa1, 0x93, 0x03, 0xb0, 0x1e, 0xc7, 0xe7, 0x14, 0xfb,
	0x11, 0x1f, 0x5c, 0xbc, 0xd4, 0xda, 0xec, 0x5e, 0xe9, 0x89, 0xb2, 0xa2, 0x75, 0x3f, 0xbe, 0x2d,
	0xb6, 0x67, 0xd6, 0x31, 0xe9, 0x90, 0x80, 0x69, 0x7f, 0x99, 0x6f, 0x62, 0x43, 0xc6, 0x05, 0x76,
	0x91, 0xcb, 0x2e, 0x67, 0x72, 0xff, 0xa3, 0x1e, 0x0e, 0x28, 0xb2, 0xf1, 0xc3, 0xf4, 0xa5, 0xfe,
	0x3d, 0xff, 0x49, 0xc4, 0x2f, 0x96, 0xe0, 0xc0, 0xfa, 0xee, 0xe6, 0x6e, 0x4b, 0xb9, 0xbd, 0xdb,
	0x52, 0xbe, 0xdc, 0x6d, 0x29, 0x75, 0xa5, 0xb5, 0x22, 0x34, 0xfe, 0xf1, 0x35, 0x00, 0x00, 0xff,
	0xff, 0x5a, 0x54, 0xa4, 0x63, 0x11, 0x07, 0x00, 0x00,
}
