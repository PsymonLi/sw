// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ipam.proto

package netproto

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "google.golang.org/genproto/googleapis/api/annotations"
import _ "github.com/pensando/sw/venice/utils/apigen/annotations"
import _ "github.com/gogo/protobuf/gogoproto"
import api "github.com/pensando/sw/api"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type IPAMPolicySpec_IPAMType int32

const (
	IPAMPolicySpec_DHCP_Relay IPAMPolicySpec_IPAMType = 0
)

var IPAMPolicySpec_IPAMType_name = map[int32]string{
	0: "DHCP_Relay",
}
var IPAMPolicySpec_IPAMType_value = map[string]int32{
	"DHCP_Relay": 0,
}

func (x IPAMPolicySpec_IPAMType) String() string {
	return proto.EnumName(IPAMPolicySpec_IPAMType_name, int32(x))
}
func (IPAMPolicySpec_IPAMType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorIpam, []int{2, 0}
}

type DHCPServer struct {
	// IP Address of the server.
	IPAddress string `protobuf:"bytes,1,opt,name=IPAddress,proto3" json:"ip-address,omitempty"`
	// Destination VRF where the server is connected. An empty value specifies that the server is reachable in the same vrf as the one where the policy is attached.
	VirtualRouter string `protobuf:"bytes,2,opt,name=VirtualRouter,proto3" json:"virtual-router,omitempty"`
}

func (m *DHCPServer) Reset()                    { *m = DHCPServer{} }
func (m *DHCPServer) String() string            { return proto.CompactTextString(m) }
func (*DHCPServer) ProtoMessage()               {}
func (*DHCPServer) Descriptor() ([]byte, []int) { return fileDescriptorIpam, []int{0} }

func (m *DHCPServer) GetIPAddress() string {
	if m != nil {
		return m.IPAddress
	}
	return ""
}

func (m *DHCPServer) GetVirtualRouter() string {
	if m != nil {
		return m.VirtualRouter
	}
	return ""
}

type DHCPRelayPolicy struct {
	Servers []*DHCPServer `protobuf:"bytes,1,rep,name=Servers" json:"relay-servers,omitempty"`
}

func (m *DHCPRelayPolicy) Reset()                    { *m = DHCPRelayPolicy{} }
func (m *DHCPRelayPolicy) String() string            { return proto.CompactTextString(m) }
func (*DHCPRelayPolicy) ProtoMessage()               {}
func (*DHCPRelayPolicy) Descriptor() ([]byte, []int) { return fileDescriptorIpam, []int{1} }

func (m *DHCPRelayPolicy) GetServers() []*DHCPServer {
	if m != nil {
		return m.Servers
	}
	return nil
}

type IPAMPolicySpec struct {
	Type      string           `protobuf:"bytes,1,opt,name=Type,proto3" json:"type,omitempty"`
	DHCPRelay *DHCPRelayPolicy `protobuf:"bytes,2,opt,name=DHCPRelay" json:"dhcp-relay,omitempty"`
}

func (m *IPAMPolicySpec) Reset()                    { *m = IPAMPolicySpec{} }
func (m *IPAMPolicySpec) String() string            { return proto.CompactTextString(m) }
func (*IPAMPolicySpec) ProtoMessage()               {}
func (*IPAMPolicySpec) Descriptor() ([]byte, []int) { return fileDescriptorIpam, []int{2} }

func (m *IPAMPolicySpec) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *IPAMPolicySpec) GetDHCPRelay() *DHCPRelayPolicy {
	if m != nil {
		return m.DHCPRelay
	}
	return nil
}

type IPAMPolicyStatus struct {
}

func (m *IPAMPolicyStatus) Reset()                    { *m = IPAMPolicyStatus{} }
func (m *IPAMPolicyStatus) String() string            { return proto.CompactTextString(m) }
func (*IPAMPolicyStatus) ProtoMessage()               {}
func (*IPAMPolicyStatus) Descriptor() ([]byte, []int) { return fileDescriptorIpam, []int{3} }

type IPAMPolicyEvent struct {
	EventType  api.EventType `protobuf:"varint,1,opt,name=EventType,proto3,enum=api.EventType" json:"event-type,omitempty"`
	IPAMPolicy IPAMPolicy    `protobuf:"bytes,2,opt,name=IPAMPolicy" json:"ipam-policy,omitempty"`
}

func (m *IPAMPolicyEvent) Reset()                    { *m = IPAMPolicyEvent{} }
func (m *IPAMPolicyEvent) String() string            { return proto.CompactTextString(m) }
func (*IPAMPolicyEvent) ProtoMessage()               {}
func (*IPAMPolicyEvent) Descriptor() ([]byte, []int) { return fileDescriptorIpam, []int{4} }

func (m *IPAMPolicyEvent) GetEventType() api.EventType {
	if m != nil {
		return m.EventType
	}
	return api.EventType_CreateEvent
}

func (m *IPAMPolicyEvent) GetIPAMPolicy() IPAMPolicy {
	if m != nil {
		return m.IPAMPolicy
	}
	return IPAMPolicy{}
}

type IPAMPolicyEventList struct {
	IPAMPolicyEvents []*IPAMPolicyEvent `protobuf:"bytes,1,rep,name=iPAMPolicyEvents" json:"iPAMPolicyEvents,omitempty"`
}

func (m *IPAMPolicyEventList) Reset()                    { *m = IPAMPolicyEventList{} }
func (m *IPAMPolicyEventList) String() string            { return proto.CompactTextString(m) }
func (*IPAMPolicyEventList) ProtoMessage()               {}
func (*IPAMPolicyEventList) Descriptor() ([]byte, []int) { return fileDescriptorIpam, []int{5} }

func (m *IPAMPolicyEventList) GetIPAMPolicyEvents() []*IPAMPolicyEvent {
	if m != nil {
		return m.IPAMPolicyEvents
	}
	return nil
}

type IPAMPolicyList struct {
	IPAMPolicys []*IPAMPolicy `protobuf:"bytes,1,rep,name=iPAMPolicys" json:"iPAMPolicys,omitempty"`
}

func (m *IPAMPolicyList) Reset()                    { *m = IPAMPolicyList{} }
func (m *IPAMPolicyList) String() string            { return proto.CompactTextString(m) }
func (*IPAMPolicyList) ProtoMessage()               {}
func (*IPAMPolicyList) Descriptor() ([]byte, []int) { return fileDescriptorIpam, []int{6} }

func (m *IPAMPolicyList) GetIPAMPolicys() []*IPAMPolicy {
	if m != nil {
		return m.IPAMPolicys
	}
	return nil
}

type IPAMPolicy struct {
	api.TypeMeta   `protobuf:"bytes,1,opt,name=TypeMeta,embedded=TypeMeta" json:",inline"`
	api.ObjectMeta `protobuf:"bytes,2,opt,name=ObjectMeta,embedded=ObjectMeta" json:"meta,omitempty"`
	Spec           IPAMPolicySpec   `protobuf:"bytes,3,opt,name=Spec" json:"spec,omitempty"`
	Status         IPAMPolicyStatus `protobuf:"bytes,4,opt,name=Status" json:"status,omitempty"`
}

func (m *IPAMPolicy) Reset()                    { *m = IPAMPolicy{} }
func (m *IPAMPolicy) String() string            { return proto.CompactTextString(m) }
func (*IPAMPolicy) ProtoMessage()               {}
func (*IPAMPolicy) Descriptor() ([]byte, []int) { return fileDescriptorIpam, []int{7} }

func (m *IPAMPolicy) GetSpec() IPAMPolicySpec {
	if m != nil {
		return m.Spec
	}
	return IPAMPolicySpec{}
}

func (m *IPAMPolicy) GetStatus() IPAMPolicyStatus {
	if m != nil {
		return m.Status
	}
	return IPAMPolicyStatus{}
}

func init() {
	proto.RegisterType((*DHCPServer)(nil), "netproto.DHCPServer")
	proto.RegisterType((*DHCPRelayPolicy)(nil), "netproto.DHCPRelayPolicy")
	proto.RegisterType((*IPAMPolicySpec)(nil), "netproto.IPAMPolicySpec")
	proto.RegisterType((*IPAMPolicyStatus)(nil), "netproto.IPAMPolicyStatus")
	proto.RegisterType((*IPAMPolicyEvent)(nil), "netproto.IPAMPolicyEvent")
	proto.RegisterType((*IPAMPolicyEventList)(nil), "netproto.IPAMPolicyEventList")
	proto.RegisterType((*IPAMPolicyList)(nil), "netproto.IPAMPolicyList")
	proto.RegisterType((*IPAMPolicy)(nil), "netproto.IPAMPolicy")
	proto.RegisterEnum("netproto.IPAMPolicySpec_IPAMType", IPAMPolicySpec_IPAMType_name, IPAMPolicySpec_IPAMType_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for IPAMPolicyApiV1 service

type IPAMPolicyApiV1Client interface {
	ListIPAMPolicys(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (*IPAMPolicyList, error)
	WatchIPAMPolicys(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (IPAMPolicyApiV1_WatchIPAMPolicysClient, error)
	IPAMPolicyOperUpdate(ctx context.Context, opts ...grpc.CallOption) (IPAMPolicyApiV1_IPAMPolicyOperUpdateClient, error)
}

type iPAMPolicyApiV1Client struct {
	cc *grpc.ClientConn
}

func NewIPAMPolicyApiV1Client(cc *grpc.ClientConn) IPAMPolicyApiV1Client {
	return &iPAMPolicyApiV1Client{cc}
}

func (c *iPAMPolicyApiV1Client) ListIPAMPolicys(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (*IPAMPolicyList, error) {
	out := new(IPAMPolicyList)
	err := grpc.Invoke(ctx, "/netproto.IPAMPolicyApiV1/ListIPAMPolicys", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iPAMPolicyApiV1Client) WatchIPAMPolicys(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (IPAMPolicyApiV1_WatchIPAMPolicysClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_IPAMPolicyApiV1_serviceDesc.Streams[0], c.cc, "/netproto.IPAMPolicyApiV1/WatchIPAMPolicys", opts...)
	if err != nil {
		return nil, err
	}
	x := &iPAMPolicyApiV1WatchIPAMPolicysClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type IPAMPolicyApiV1_WatchIPAMPolicysClient interface {
	Recv() (*IPAMPolicyEventList, error)
	grpc.ClientStream
}

type iPAMPolicyApiV1WatchIPAMPolicysClient struct {
	grpc.ClientStream
}

func (x *iPAMPolicyApiV1WatchIPAMPolicysClient) Recv() (*IPAMPolicyEventList, error) {
	m := new(IPAMPolicyEventList)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *iPAMPolicyApiV1Client) IPAMPolicyOperUpdate(ctx context.Context, opts ...grpc.CallOption) (IPAMPolicyApiV1_IPAMPolicyOperUpdateClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_IPAMPolicyApiV1_serviceDesc.Streams[1], c.cc, "/netproto.IPAMPolicyApiV1/IPAMPolicyOperUpdate", opts...)
	if err != nil {
		return nil, err
	}
	x := &iPAMPolicyApiV1IPAMPolicyOperUpdateClient{stream}
	return x, nil
}

type IPAMPolicyApiV1_IPAMPolicyOperUpdateClient interface {
	Send(*IPAMPolicyEvent) error
	CloseAndRecv() (*api.TypeMeta, error)
	grpc.ClientStream
}

type iPAMPolicyApiV1IPAMPolicyOperUpdateClient struct {
	grpc.ClientStream
}

func (x *iPAMPolicyApiV1IPAMPolicyOperUpdateClient) Send(m *IPAMPolicyEvent) error {
	return x.ClientStream.SendMsg(m)
}

func (x *iPAMPolicyApiV1IPAMPolicyOperUpdateClient) CloseAndRecv() (*api.TypeMeta, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(api.TypeMeta)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for IPAMPolicyApiV1 service

type IPAMPolicyApiV1Server interface {
	ListIPAMPolicys(context.Context, *api.ListWatchOptions) (*IPAMPolicyList, error)
	WatchIPAMPolicys(*api.ListWatchOptions, IPAMPolicyApiV1_WatchIPAMPolicysServer) error
	IPAMPolicyOperUpdate(IPAMPolicyApiV1_IPAMPolicyOperUpdateServer) error
}

func RegisterIPAMPolicyApiV1Server(s *grpc.Server, srv IPAMPolicyApiV1Server) {
	s.RegisterService(&_IPAMPolicyApiV1_serviceDesc, srv)
}

func _IPAMPolicyApiV1_ListIPAMPolicys_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(api.ListWatchOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IPAMPolicyApiV1Server).ListIPAMPolicys(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/netproto.IPAMPolicyApiV1/ListIPAMPolicys",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IPAMPolicyApiV1Server).ListIPAMPolicys(ctx, req.(*api.ListWatchOptions))
	}
	return interceptor(ctx, in, info, handler)
}

func _IPAMPolicyApiV1_WatchIPAMPolicys_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(api.ListWatchOptions)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(IPAMPolicyApiV1Server).WatchIPAMPolicys(m, &iPAMPolicyApiV1WatchIPAMPolicysServer{stream})
}

type IPAMPolicyApiV1_WatchIPAMPolicysServer interface {
	Send(*IPAMPolicyEventList) error
	grpc.ServerStream
}

type iPAMPolicyApiV1WatchIPAMPolicysServer struct {
	grpc.ServerStream
}

func (x *iPAMPolicyApiV1WatchIPAMPolicysServer) Send(m *IPAMPolicyEventList) error {
	return x.ServerStream.SendMsg(m)
}

func _IPAMPolicyApiV1_IPAMPolicyOperUpdate_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(IPAMPolicyApiV1Server).IPAMPolicyOperUpdate(&iPAMPolicyApiV1IPAMPolicyOperUpdateServer{stream})
}

type IPAMPolicyApiV1_IPAMPolicyOperUpdateServer interface {
	SendAndClose(*api.TypeMeta) error
	Recv() (*IPAMPolicyEvent, error)
	grpc.ServerStream
}

type iPAMPolicyApiV1IPAMPolicyOperUpdateServer struct {
	grpc.ServerStream
}

func (x *iPAMPolicyApiV1IPAMPolicyOperUpdateServer) SendAndClose(m *api.TypeMeta) error {
	return x.ServerStream.SendMsg(m)
}

func (x *iPAMPolicyApiV1IPAMPolicyOperUpdateServer) Recv() (*IPAMPolicyEvent, error) {
	m := new(IPAMPolicyEvent)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _IPAMPolicyApiV1_serviceDesc = grpc.ServiceDesc{
	ServiceName: "netproto.IPAMPolicyApiV1",
	HandlerType: (*IPAMPolicyApiV1Server)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListIPAMPolicys",
			Handler:    _IPAMPolicyApiV1_ListIPAMPolicys_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "WatchIPAMPolicys",
			Handler:       _IPAMPolicyApiV1_WatchIPAMPolicys_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "IPAMPolicyOperUpdate",
			Handler:       _IPAMPolicyApiV1_IPAMPolicyOperUpdate_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "ipam.proto",
}

func (m *DHCPServer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DHCPServer) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.IPAddress) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintIpam(dAtA, i, uint64(len(m.IPAddress)))
		i += copy(dAtA[i:], m.IPAddress)
	}
	if len(m.VirtualRouter) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintIpam(dAtA, i, uint64(len(m.VirtualRouter)))
		i += copy(dAtA[i:], m.VirtualRouter)
	}
	return i, nil
}

func (m *DHCPRelayPolicy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DHCPRelayPolicy) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Servers) > 0 {
		for _, msg := range m.Servers {
			dAtA[i] = 0xa
			i++
			i = encodeVarintIpam(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *IPAMPolicySpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IPAMPolicySpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintIpam(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if m.DHCPRelay != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintIpam(dAtA, i, uint64(m.DHCPRelay.Size()))
		n1, err := m.DHCPRelay.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	return i, nil
}

func (m *IPAMPolicyStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IPAMPolicyStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *IPAMPolicyEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IPAMPolicyEvent) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.EventType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintIpam(dAtA, i, uint64(m.EventType))
	}
	dAtA[i] = 0x12
	i++
	i = encodeVarintIpam(dAtA, i, uint64(m.IPAMPolicy.Size()))
	n2, err := m.IPAMPolicy.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n2
	return i, nil
}

func (m *IPAMPolicyEventList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IPAMPolicyEventList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.IPAMPolicyEvents) > 0 {
		for _, msg := range m.IPAMPolicyEvents {
			dAtA[i] = 0xa
			i++
			i = encodeVarintIpam(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *IPAMPolicyList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IPAMPolicyList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.IPAMPolicys) > 0 {
		for _, msg := range m.IPAMPolicys {
			dAtA[i] = 0xa
			i++
			i = encodeVarintIpam(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *IPAMPolicy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IPAMPolicy) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintIpam(dAtA, i, uint64(m.TypeMeta.Size()))
	n3, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n3
	dAtA[i] = 0x12
	i++
	i = encodeVarintIpam(dAtA, i, uint64(m.ObjectMeta.Size()))
	n4, err := m.ObjectMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n4
	dAtA[i] = 0x1a
	i++
	i = encodeVarintIpam(dAtA, i, uint64(m.Spec.Size()))
	n5, err := m.Spec.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n5
	dAtA[i] = 0x22
	i++
	i = encodeVarintIpam(dAtA, i, uint64(m.Status.Size()))
	n6, err := m.Status.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n6
	return i, nil
}

func encodeVarintIpam(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *DHCPServer) Size() (n int) {
	var l int
	_ = l
	l = len(m.IPAddress)
	if l > 0 {
		n += 1 + l + sovIpam(uint64(l))
	}
	l = len(m.VirtualRouter)
	if l > 0 {
		n += 1 + l + sovIpam(uint64(l))
	}
	return n
}

func (m *DHCPRelayPolicy) Size() (n int) {
	var l int
	_ = l
	if len(m.Servers) > 0 {
		for _, e := range m.Servers {
			l = e.Size()
			n += 1 + l + sovIpam(uint64(l))
		}
	}
	return n
}

func (m *IPAMPolicySpec) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovIpam(uint64(l))
	}
	if m.DHCPRelay != nil {
		l = m.DHCPRelay.Size()
		n += 1 + l + sovIpam(uint64(l))
	}
	return n
}

func (m *IPAMPolicyStatus) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *IPAMPolicyEvent) Size() (n int) {
	var l int
	_ = l
	if m.EventType != 0 {
		n += 1 + sovIpam(uint64(m.EventType))
	}
	l = m.IPAMPolicy.Size()
	n += 1 + l + sovIpam(uint64(l))
	return n
}

func (m *IPAMPolicyEventList) Size() (n int) {
	var l int
	_ = l
	if len(m.IPAMPolicyEvents) > 0 {
		for _, e := range m.IPAMPolicyEvents {
			l = e.Size()
			n += 1 + l + sovIpam(uint64(l))
		}
	}
	return n
}

func (m *IPAMPolicyList) Size() (n int) {
	var l int
	_ = l
	if len(m.IPAMPolicys) > 0 {
		for _, e := range m.IPAMPolicys {
			l = e.Size()
			n += 1 + l + sovIpam(uint64(l))
		}
	}
	return n
}

func (m *IPAMPolicy) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovIpam(uint64(l))
	l = m.ObjectMeta.Size()
	n += 1 + l + sovIpam(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovIpam(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovIpam(uint64(l))
	return n
}

func sovIpam(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozIpam(x uint64) (n int) {
	return sovIpam(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *DHCPServer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIpam
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DHCPServer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DHCPServer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IPAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpam
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIpam
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IPAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VirtualRouter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpam
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIpam
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VirtualRouter = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIpam(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIpam
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DHCPRelayPolicy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIpam
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DHCPRelayPolicy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DHCPRelayPolicy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Servers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpam
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIpam
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Servers = append(m.Servers, &DHCPServer{})
			if err := m.Servers[len(m.Servers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIpam(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIpam
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IPAMPolicySpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIpam
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IPAMPolicySpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IPAMPolicySpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpam
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIpam
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DHCPRelay", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpam
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIpam
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DHCPRelay == nil {
				m.DHCPRelay = &DHCPRelayPolicy{}
			}
			if err := m.DHCPRelay.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIpam(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIpam
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IPAMPolicyStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIpam
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IPAMPolicyStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IPAMPolicyStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipIpam(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIpam
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IPAMPolicyEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIpam
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IPAMPolicyEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IPAMPolicyEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventType", wireType)
			}
			m.EventType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpam
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EventType |= (api.EventType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IPAMPolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpam
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIpam
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.IPAMPolicy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIpam(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIpam
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IPAMPolicyEventList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIpam
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IPAMPolicyEventList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IPAMPolicyEventList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IPAMPolicyEvents", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpam
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIpam
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IPAMPolicyEvents = append(m.IPAMPolicyEvents, &IPAMPolicyEvent{})
			if err := m.IPAMPolicyEvents[len(m.IPAMPolicyEvents)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIpam(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIpam
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IPAMPolicyList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIpam
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IPAMPolicyList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IPAMPolicyList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IPAMPolicys", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpam
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIpam
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IPAMPolicys = append(m.IPAMPolicys, &IPAMPolicy{})
			if err := m.IPAMPolicys[len(m.IPAMPolicys)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIpam(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIpam
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IPAMPolicy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIpam
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IPAMPolicy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IPAMPolicy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpam
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIpam
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpam
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIpam
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpam
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIpam
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpam
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIpam
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIpam(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIpam
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipIpam(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowIpam
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowIpam
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowIpam
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthIpam
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowIpam
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipIpam(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthIpam = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowIpam   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("ipam.proto", fileDescriptorIpam) }

var fileDescriptorIpam = []byte{
	// 791 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x54, 0x41, 0x4f, 0xdb, 0x48,
	0x14, 0x8e, 0x21, 0x82, 0x64, 0xb2, 0x24, 0xd9, 0x01, 0x76, 0x1d, 0x2f, 0x10, 0x64, 0xed, 0x4a,
	0x59, 0x89, 0xd8, 0xbb, 0xa9, 0xc4, 0xad, 0x95, 0x70, 0x93, 0x0a, 0x0a, 0x94, 0x34, 0xa1, 0xf4,
	0x52, 0xb5, 0x9a, 0x38, 0xd3, 0x64, 0x2a, 0xc7, 0x1e, 0xd9, 0xe3, 0x54, 0x51, 0xc5, 0xa9, 0x12,
	0xbf, 0xa0, 0xbf, 0x02, 0xa9, 0x3d, 0xf4, 0x57, 0x20, 0xf5, 0xc2, 0xa5, 0xd7, 0xa8, 0xe2, 0x98,
	0x5f, 0x51, 0xcd, 0x38, 0x89, 0x27, 0x10, 0xa4, 0xde, 0x3c, 0xdf, 0xfb, 0xde, 0x37, 0xef, 0x7b,
	0xef, 0x8d, 0x01, 0x20, 0x14, 0xf5, 0x0c, 0xea, 0x7b, 0xcc, 0x83, 0x29, 0x17, 0x33, 0xf1, 0xa5,
	0x6d, 0x74, 0x3c, 0xaf, 0xe3, 0x60, 0x13, 0x51, 0x62, 0x22, 0xd7, 0xf5, 0x18, 0x62, 0xc4, 0x73,
	0x83, 0x88, 0xa7, 0xd5, 0x3a, 0x84, 0x75, 0xc3, 0x96, 0x61, 0x7b, 0x3d, 0x93, 0x62, 0x37, 0x40,
	0x6e, 0xdb, 0x33, 0x83, 0xf7, 0x66, 0x1f, 0xbb, 0xc4, 0xc6, 0x66, 0xc8, 0x88, 0x13, 0xf0, 0xd4,
	0x0e, 0x76, 0xe5, 0x6c, 0x93, 0xb8, 0xb6, 0x13, 0xb6, 0xf1, 0x44, 0xa6, 0x2c, 0xc9, 0x74, 0xbc,
	0x8e, 0x67, 0x0a, 0xb8, 0x15, 0xbe, 0x15, 0x27, 0x71, 0x10, 0x5f, 0x63, 0xfa, 0x3f, 0xf7, 0xdc,
	0xca, 0x6b, 0xec, 0x61, 0x86, 0x22, 0x9a, 0xfe, 0x49, 0x01, 0xa0, 0xba, 0xff, 0xb8, 0xde, 0xc4,
	0x7e, 0x1f, 0xfb, 0xd0, 0x02, 0xe9, 0x83, 0xfa, 0x5e, 0xbb, 0xed, 0xe3, 0x20, 0x50, 0x95, 0x6d,
	0xa5, 0x94, 0xb6, 0xfe, 0xbe, 0xbc, 0x28, 0xa4, 0x22, 0xb0, 0xf4, 0xef, 0x68, 0x58, 0x5c, 0x23,
	0xb4, 0x8c, 0x22, 0xc6, 0x8e, 0xd7, 0x23, 0x0c, 0xf7, 0x28, 0x1b, 0x34, 0xe2, 0x34, 0x68, 0x81,
	0x95, 0x33, 0xe2, 0xb3, 0x10, 0x39, 0x0d, 0x2f, 0x64, 0xd8, 0x57, 0x17, 0x84, 0xce, 0xc6, 0x68,
	0x58, 0x54, 0xfb, 0x51, 0xa0, 0xec, 0x8b, 0x88, 0x94, 0x3f, 0x9b, 0xa2, 0xbf, 0x06, 0x39, 0x5e,
	0x55, 0x03, 0x3b, 0x68, 0x50, 0xf7, 0x1c, 0x62, 0x0f, 0xe0, 0x21, 0x58, 0x8e, 0x8a, 0xe4, 0x85,
	0x2d, 0x96, 0x32, 0x95, 0x35, 0x63, 0x32, 0x00, 0x23, 0x76, 0x60, 0xfd, 0x35, 0x1a, 0x16, 0xff,
	0xf4, 0x79, 0x5e, 0x39, 0x88, 0xe8, 0xd2, 0x2d, 0x13, 0x05, 0xfd, 0x9b, 0x02, 0xb2, 0x07, 0xf5,
	0xbd, 0xe3, 0x48, 0xbb, 0x49, 0xb1, 0x0d, 0x9f, 0x82, 0xe4, 0xe9, 0x80, 0xe2, 0xb1, 0xeb, 0xdd,
	0xcb, 0x8b, 0xc2, 0x76, 0x93, 0xf9, 0x35, 0x37, 0xec, 0x95, 0x66, 0x99, 0x06, 0x3f, 0x72, 0x2a,
	0xef, 0x46, 0x96, 0x0d, 0x28, 0x96, 0x6e, 0x10, 0x1a, 0xf0, 0x39, 0x48, 0x4f, 0xcb, 0x17, 0xf6,
	0x33, 0x95, 0xc2, 0x6c, 0xb5, 0x92, 0x33, 0x4b, 0xe5, 0x5d, 0x6d, 0x77, 0x6d, 0x5a, 0x16, 0x75,
	0xcb, 0x5d, 0x9d, 0x52, 0x75, 0x0d, 0xa4, 0x26, 0xf7, 0xc2, 0x6c, 0x34, 0xb3, 0x37, 0x22, 0x92,
	0x4f, 0xe8, 0x10, 0xe4, 0xa5, 0x12, 0x19, 0x62, 0x61, 0xa0, 0x7f, 0x51, 0x40, 0x2e, 0x06, 0x6b,
	0x7d, 0xec, 0x32, 0xf8, 0x04, 0xa4, 0xc5, 0xc7, 0xd4, 0x67, 0xb6, 0x92, 0x35, 0x10, 0x25, 0xc6,
	0x14, 0x8d, 0x6a, 0xc1, 0xfc, 0x58, 0xbe, 0xe5, 0x2c, 0x4e, 0x85, 0x4d, 0x00, 0x62, 0xe9, 0xb1,
	0x3f, 0x69, 0x1a, 0x71, 0xcc, 0xda, 0xbc, 0x1a, 0x16, 0x13, 0xa3, 0x61, 0x71, 0x9d, 0xbf, 0x9b,
	0x32, 0x15, 0xa0, 0xa4, 0x29, 0xc9, 0xe8, 0xaf, 0xc0, 0xea, 0xad, 0x7a, 0x8f, 0x48, 0xc0, 0x60,
	0x0d, 0xe4, 0xc9, 0x2c, 0x3c, 0x99, 0x7f, 0x61, 0xde, 0x8d, 0x82, 0xd1, 0xb8, 0x93, 0xa2, 0xef,
	0xcb, 0xf3, 0x16, 0xc2, 0xbb, 0x20, 0x13, 0xb3, 0xe6, 0xec, 0x54, 0x4c, 0x6f, 0xc8, 0x44, 0xfd,
	0xf3, 0x82, 0xec, 0x1e, 0x3e, 0x02, 0x29, 0xde, 0x93, 0x63, 0xcc, 0x90, 0x68, 0x69, 0xa6, 0xb2,
	0x22, 0x5a, 0x3a, 0x01, 0xad, 0x55, 0xde, 0x82, 0xeb, 0x61, 0x51, 0x19, 0x0d, 0x8b, 0xcb, 0x3b,
	0xc4, 0x75, 0x88, 0x8b, 0x1b, 0xd3, 0x1c, 0x78, 0x08, 0xc0, 0x49, 0xeb, 0x1d, 0xb6, 0x99, 0x50,
	0x88, 0x7a, 0x99, 0x13, 0x0a, 0x31, 0x6c, 0x69, 0x92, 0x46, 0x96, 0xbf, 0x5e, 0xb9, 0x87, 0x31,
	0x0f, 0x56, 0x41, 0x92, 0x6f, 0xa8, 0xba, 0x28, 0x64, 0xd4, 0x79, 0x66, 0x78, 0xdc, 0xfa, 0x63,
	0x3c, 0x96, 0x6c, 0x40, 0xb1, 0x2d, 0x6f, 0xaf, 0x78, 0x09, 0x47, 0x60, 0x29, 0x5a, 0x22, 0x35,
	0x29, 0x74, 0xb4, 0xb9, 0x3a, 0x82, 0x61, 0xa9, 0x63, 0xa5, 0x7c, 0x20, 0xce, 0x92, 0xd6, 0x58,
	0xa3, 0xf2, 0x7d, 0x41, 0x5e, 0xc4, 0x3d, 0x4a, 0xce, 0xfe, 0x87, 0x55, 0x90, 0xe3, 0x33, 0x88,
	0xe1, 0x00, 0xae, 0x0b, 0xcf, 0x1c, 0x7d, 0x89, 0x98, 0xdd, 0x3d, 0xa1, 0xe2, 0x27, 0xa8, 0xcd,
	0xf5, 0xc0, 0x59, 0x7a, 0x02, 0x1e, 0x81, 0xbc, 0xe0, 0xfe, 0x82, 0xcc, 0xe6, 0xbd, 0xbb, 0x12,
	0x69, 0xfd, 0xa7, 0xc0, 0x2a, 0x58, 0x8b, 0x43, 0x27, 0x14, 0xfb, 0x2f, 0x68, 0x1b, 0x31, 0x0c,
	0xef, 0x5f, 0x33, 0x6d, 0x76, 0xd2, 0x7a, 0xa2, 0xa4, 0x68, 0xdd, 0xaf, 0x1f, 0x0b, 0xed, 0x99,
	0x05, 0x49, 0x3a, 0x24, 0x60, 0xda, 0x43, 0xf3, 0x43, 0x3c, 0x27, 0xe3, 0x14, 0xbb, 0xc8, 0x65,
	0xe7, 0x33, 0xd8, 0x33, 0xd4, 0xc3, 0x01, 0x45, 0x36, 0xbe, 0x0b, 0x9f, 0xeb, 0xbf, 0xf3, 0xdf,
	0x76, 0xfc, 0x86, 0x08, 0x0e, 0xac, 0xdf, 0xae, 0x6e, 0xb6, 0x94, 0xeb, 0x9b, 0x2d, 0xe5, 0xc7,
	0xcd, 0x96, 0x52, 0x57, 0x5a, 0x4b, 0xa2, 0xc6, 0x07, 0x3f, 0x03, 0x00, 0x00, 0xff, 0xff, 0xe6,
	0x31, 0xea, 0xd1, 0xa3, 0x06, 0x00, 0x00,
}
