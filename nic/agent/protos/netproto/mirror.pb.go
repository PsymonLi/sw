// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: mirror.proto

package netproto

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "google.golang.org/genproto/googleapis/api/annotations"
import _ "github.com/pensando/sw/venice/utils/apigen/annotations"
import _ "github.com/gogo/protobuf/gogoproto"
import api "github.com/pensando/sw/api"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type MirrorDir int32

const (
	MirrorDir_BOTH    MirrorDir = 0
	MirrorDir_INGRESS MirrorDir = 1
	MirrorDir_EGRESS  MirrorDir = 2
)

var MirrorDir_name = map[int32]string{
	0: "BOTH",
	1: "INGRESS",
	2: "EGRESS",
}
var MirrorDir_value = map[string]int32{
	"BOTH":    0,
	"INGRESS": 1,
	"EGRESS":  2,
}

func (x MirrorDir) String() string {
	return proto.EnumName(MirrorDir_name, int32(x))
}
func (MirrorDir) EnumDescriptor() ([]byte, []int) { return fileDescriptorMirror, []int{0} }

type MirrorSession struct {
	api.TypeMeta   `protobuf:"bytes,1,opt,name=TypeMeta,embedded=TypeMeta" json:",inline"`
	api.ObjectMeta `protobuf:"bytes,2,opt,name=ObjectMeta,embedded=ObjectMeta" json:"meta,omitempty"`
	Spec           MirrorSessionSpec   `protobuf:"bytes,3,opt,name=Spec" json:"spec,omitempty"`
	Status         MirrorSessionStatus `protobuf:"bytes,4,opt,name=Status" json:"status,omitempty"`
}

func (m *MirrorSession) Reset()                    { *m = MirrorSession{} }
func (m *MirrorSession) String() string            { return proto.CompactTextString(m) }
func (*MirrorSession) ProtoMessage()               {}
func (*MirrorSession) Descriptor() ([]byte, []int) { return fileDescriptorMirror, []int{0} }

func (m *MirrorSession) GetSpec() MirrorSessionSpec {
	if m != nil {
		return m.Spec
	}
	return MirrorSessionSpec{}
}

func (m *MirrorSession) GetStatus() MirrorSessionStatus {
	if m != nil {
		return m.Status
	}
	return MirrorSessionStatus{}
}

type MirrorSessionSpec struct {
	VrfName string `protobuf:"bytes,1,opt,name=VrfName,proto3" json:"vrf-name,omitempty"`
	// Mirrored packet collectors
	Collectors []MirrorCollector `protobuf:"bytes,2,rep,name=Collectors" json:"collectors,inline"`
	// Traffic Selection Rules - Matching pakcets are mirrored, based on packet filters and start/stop conditions
	MatchRules      []MatchRule `protobuf:"bytes,3,rep,name=MatchRules" json:"match-rules,inline"`
	PacketSize      uint32      `protobuf:"varint,4,opt,name=PacketSize,proto3" json:"packet-size,omitempty"`
	MirrorDirection MirrorDir   `protobuf:"varint,5,opt,name=MirrorDirection,proto3,enum=netproto.MirrorDir" json:"mirror-direction,omitempty"`
}

func (m *MirrorSessionSpec) Reset()                    { *m = MirrorSessionSpec{} }
func (m *MirrorSessionSpec) String() string            { return proto.CompactTextString(m) }
func (*MirrorSessionSpec) ProtoMessage()               {}
func (*MirrorSessionSpec) Descriptor() ([]byte, []int) { return fileDescriptorMirror, []int{1} }

func (m *MirrorSessionSpec) GetVrfName() string {
	if m != nil {
		return m.VrfName
	}
	return ""
}

func (m *MirrorSessionSpec) GetCollectors() []MirrorCollector {
	if m != nil {
		return m.Collectors
	}
	return nil
}

func (m *MirrorSessionSpec) GetMatchRules() []MatchRule {
	if m != nil {
		return m.MatchRules
	}
	return nil
}

func (m *MirrorSessionSpec) GetPacketSize() uint32 {
	if m != nil {
		return m.PacketSize
	}
	return 0
}

func (m *MirrorSessionSpec) GetMirrorDirection() MirrorDir {
	if m != nil {
		return m.MirrorDirection
	}
	return MirrorDir_BOTH
}

// MatchRule : This is used to select packets that need to be monitored (mirrored)
type MatchRule struct {
	// Either Src or Dst or both must be specified, both cannot be *
	// Src = * when not specified
	// When Src is specified and resides on Pesnsando SmartNIC, matching pkts to/from src will be mirrored
	Src *MatchSelector `protobuf:"bytes,1,opt,name=Src" json:"source,omitempty"`
	// Dst = * when not specified
	// When Dst is specified and resides on Pesnsando SmartNIC, matching pkts to/from dst will be mirrored
	Dst *MatchSelector `protobuf:"bytes,2,opt,name=Dst" json:"destination,omitempty"`
}

func (m *MatchRule) Reset()                    { *m = MatchRule{} }
func (m *MatchRule) String() string            { return proto.CompactTextString(m) }
func (*MatchRule) ProtoMessage()               {}
func (*MatchRule) Descriptor() ([]byte, []int) { return fileDescriptorMirror, []int{2} }

func (m *MatchRule) GetSrc() *MatchSelector {
	if m != nil {
		return m.Src
	}
	return nil
}

func (m *MatchRule) GetDst() *MatchSelector {
	if m != nil {
		return m.Dst
	}
	return nil
}

// MirrorSessionStatus captures the sg policy status
type MirrorSessionStatus struct {
	MirrorSessionID uint64 `protobuf:"varint,1,opt,name=MirrorSessionID,proto3" json:"id,omitempty"`
}

func (m *MirrorSessionStatus) Reset()                    { *m = MirrorSessionStatus{} }
func (m *MirrorSessionStatus) String() string            { return proto.CompactTextString(m) }
func (*MirrorSessionStatus) ProtoMessage()               {}
func (*MirrorSessionStatus) Descriptor() ([]byte, []int) { return fileDescriptorMirror, []int{3} }

func (m *MirrorSessionStatus) GetMirrorSessionID() uint64 {
	if m != nil {
		return m.MirrorSessionID
	}
	return 0
}

type MirrorSessionList struct {
	MirrorSessions []*MirrorSession `protobuf:"bytes,1,rep,name=MirrorSessions" json:"MirrorSessions,omitempty"`
}

func (m *MirrorSessionList) Reset()                    { *m = MirrorSessionList{} }
func (m *MirrorSessionList) String() string            { return proto.CompactTextString(m) }
func (*MirrorSessionList) ProtoMessage()               {}
func (*MirrorSessionList) Descriptor() ([]byte, []int) { return fileDescriptorMirror, []int{4} }

func (m *MirrorSessionList) GetMirrorSessions() []*MirrorSession {
	if m != nil {
		return m.MirrorSessions
	}
	return nil
}

// mirror watch event
type MirrorSessionEvent struct {
	EventType     api.EventType  `protobuf:"varint,1,opt,name=EventType,proto3,enum=api.EventType" json:"event-type,omitempty"`
	MirrorSession *MirrorSession `protobuf:"bytes,2,opt,name=MirrorSession" json:"mirror-session,omitempty"`
}

func (m *MirrorSessionEvent) Reset()                    { *m = MirrorSessionEvent{} }
func (m *MirrorSessionEvent) String() string            { return proto.CompactTextString(m) }
func (*MirrorSessionEvent) ProtoMessage()               {}
func (*MirrorSessionEvent) Descriptor() ([]byte, []int) { return fileDescriptorMirror, []int{5} }

func (m *MirrorSessionEvent) GetEventType() api.EventType {
	if m != nil {
		return m.EventType
	}
	return api.EventType_CreateEvent
}

func (m *MirrorSessionEvent) GetMirrorSession() *MirrorSession {
	if m != nil {
		return m.MirrorSession
	}
	return nil
}

// mirror watch events batched
type MirrorSessionEventList struct {
	MirrorSessionEvents []*MirrorSessionEvent `protobuf:"bytes,1,rep,name=MirrorSessionEvents" json:"MirrorSessionEvents,omitempty"`
}

func (m *MirrorSessionEventList) Reset()                    { *m = MirrorSessionEventList{} }
func (m *MirrorSessionEventList) String() string            { return proto.CompactTextString(m) }
func (*MirrorSessionEventList) ProtoMessage()               {}
func (*MirrorSessionEventList) Descriptor() ([]byte, []int) { return fileDescriptorMirror, []int{6} }

func (m *MirrorSessionEventList) GetMirrorSessionEvents() []*MirrorSessionEvent {
	if m != nil {
		return m.MirrorSessionEvents
	}
	return nil
}

type MirrorExportConfig struct {
	// IP address or URL of the collector/entity to which the data is to be exported
	Destination string `protobuf:"bytes,1,opt,name=Destination,proto3" json:"destination,omitempty"`
}

func (m *MirrorExportConfig) Reset()                    { *m = MirrorExportConfig{} }
func (m *MirrorExportConfig) String() string            { return proto.CompactTextString(m) }
func (*MirrorExportConfig) ProtoMessage()               {}
func (*MirrorExportConfig) Descriptor() ([]byte, []int) { return fileDescriptorMirror, []int{7} }

func (m *MirrorExportConfig) GetDestination() string {
	if m != nil {
		return m.Destination
	}
	return ""
}

// Mirror collector - can be an external device (via ERSPAN) or Venice (internal packet capture)
type MirrorCollector struct {
	// Collector export information for ERSPAN. Not required for VENICE collector
	ExportCfg   MirrorExportConfig `protobuf:"bytes,1,opt,name=ExportCfg" json:"export-config,omitempty"`
	PcapDirName string             `protobuf:"bytes,2,opt,name=PcapDirName,proto3" json:"pcap-dir-name"`
}

func (m *MirrorCollector) Reset()                    { *m = MirrorCollector{} }
func (m *MirrorCollector) String() string            { return proto.CompactTextString(m) }
func (*MirrorCollector) ProtoMessage()               {}
func (*MirrorCollector) Descriptor() ([]byte, []int) { return fileDescriptorMirror, []int{8} }

func (m *MirrorCollector) GetExportCfg() MirrorExportConfig {
	if m != nil {
		return m.ExportCfg
	}
	return MirrorExportConfig{}
}

func (m *MirrorCollector) GetPcapDirName() string {
	if m != nil {
		return m.PcapDirName
	}
	return ""
}

func init() {
	proto.RegisterType((*MirrorSession)(nil), "netproto.MirrorSession")
	proto.RegisterType((*MirrorSessionSpec)(nil), "netproto.MirrorSessionSpec")
	proto.RegisterType((*MatchRule)(nil), "netproto.MatchRule")
	proto.RegisterType((*MirrorSessionStatus)(nil), "netproto.MirrorSessionStatus")
	proto.RegisterType((*MirrorSessionList)(nil), "netproto.MirrorSessionList")
	proto.RegisterType((*MirrorSessionEvent)(nil), "netproto.MirrorSessionEvent")
	proto.RegisterType((*MirrorSessionEventList)(nil), "netproto.MirrorSessionEventList")
	proto.RegisterType((*MirrorExportConfig)(nil), "netproto.MirrorExportConfig")
	proto.RegisterType((*MirrorCollector)(nil), "netproto.MirrorCollector")
	proto.RegisterEnum("netproto.MirrorDir", MirrorDir_name, MirrorDir_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for MirrorSessionApiV1 service

type MirrorSessionApiV1Client interface {
	//    TODO uncomment this when TSM uses nimbus
	WatchMirrorSessions(ctx context.Context, in *api.ObjectMeta, opts ...grpc.CallOption) (MirrorSessionApiV1_WatchMirrorSessionsClient, error)
	ListMirrorSessions(ctx context.Context, in *api.ObjectMeta, opts ...grpc.CallOption) (*MirrorSessionEventList, error)
}

type mirrorSessionApiV1Client struct {
	cc *grpc.ClientConn
}

func NewMirrorSessionApiV1Client(cc *grpc.ClientConn) MirrorSessionApiV1Client {
	return &mirrorSessionApiV1Client{cc}
}

func (c *mirrorSessionApiV1Client) WatchMirrorSessions(ctx context.Context, in *api.ObjectMeta, opts ...grpc.CallOption) (MirrorSessionApiV1_WatchMirrorSessionsClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_MirrorSessionApiV1_serviceDesc.Streams[0], c.cc, "/netproto.MirrorSessionApiV1/WatchMirrorSessions", opts...)
	if err != nil {
		return nil, err
	}
	x := &mirrorSessionApiV1WatchMirrorSessionsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type MirrorSessionApiV1_WatchMirrorSessionsClient interface {
	Recv() (*MirrorSessionEventList, error)
	grpc.ClientStream
}

type mirrorSessionApiV1WatchMirrorSessionsClient struct {
	grpc.ClientStream
}

func (x *mirrorSessionApiV1WatchMirrorSessionsClient) Recv() (*MirrorSessionEventList, error) {
	m := new(MirrorSessionEventList)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *mirrorSessionApiV1Client) ListMirrorSessions(ctx context.Context, in *api.ObjectMeta, opts ...grpc.CallOption) (*MirrorSessionEventList, error) {
	out := new(MirrorSessionEventList)
	err := grpc.Invoke(ctx, "/netproto.MirrorSessionApiV1/ListMirrorSessions", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for MirrorSessionApiV1 service

type MirrorSessionApiV1Server interface {
	//    TODO uncomment this when TSM uses nimbus
	WatchMirrorSessions(*api.ObjectMeta, MirrorSessionApiV1_WatchMirrorSessionsServer) error
	ListMirrorSessions(context.Context, *api.ObjectMeta) (*MirrorSessionEventList, error)
}

func RegisterMirrorSessionApiV1Server(s *grpc.Server, srv MirrorSessionApiV1Server) {
	s.RegisterService(&_MirrorSessionApiV1_serviceDesc, srv)
}

func _MirrorSessionApiV1_WatchMirrorSessions_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(api.ObjectMeta)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(MirrorSessionApiV1Server).WatchMirrorSessions(m, &mirrorSessionApiV1WatchMirrorSessionsServer{stream})
}

type MirrorSessionApiV1_WatchMirrorSessionsServer interface {
	Send(*MirrorSessionEventList) error
	grpc.ServerStream
}

type mirrorSessionApiV1WatchMirrorSessionsServer struct {
	grpc.ServerStream
}

func (x *mirrorSessionApiV1WatchMirrorSessionsServer) Send(m *MirrorSessionEventList) error {
	return x.ServerStream.SendMsg(m)
}

func _MirrorSessionApiV1_ListMirrorSessions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(api.ObjectMeta)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MirrorSessionApiV1Server).ListMirrorSessions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/netproto.MirrorSessionApiV1/ListMirrorSessions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MirrorSessionApiV1Server).ListMirrorSessions(ctx, req.(*api.ObjectMeta))
	}
	return interceptor(ctx, in, info, handler)
}

var _MirrorSessionApiV1_serviceDesc = grpc.ServiceDesc{
	ServiceName: "netproto.MirrorSessionApiV1",
	HandlerType: (*MirrorSessionApiV1Server)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListMirrorSessions",
			Handler:    _MirrorSessionApiV1_ListMirrorSessions_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "WatchMirrorSessions",
			Handler:       _MirrorSessionApiV1_WatchMirrorSessions_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "mirror.proto",
}

func (m *MirrorSession) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MirrorSession) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintMirror(dAtA, i, uint64(m.TypeMeta.Size()))
	n1, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n1
	dAtA[i] = 0x12
	i++
	i = encodeVarintMirror(dAtA, i, uint64(m.ObjectMeta.Size()))
	n2, err := m.ObjectMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n2
	dAtA[i] = 0x1a
	i++
	i = encodeVarintMirror(dAtA, i, uint64(m.Spec.Size()))
	n3, err := m.Spec.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n3
	dAtA[i] = 0x22
	i++
	i = encodeVarintMirror(dAtA, i, uint64(m.Status.Size()))
	n4, err := m.Status.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n4
	return i, nil
}

func (m *MirrorSessionSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MirrorSessionSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.VrfName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMirror(dAtA, i, uint64(len(m.VrfName)))
		i += copy(dAtA[i:], m.VrfName)
	}
	if len(m.Collectors) > 0 {
		for _, msg := range m.Collectors {
			dAtA[i] = 0x12
			i++
			i = encodeVarintMirror(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.MatchRules) > 0 {
		for _, msg := range m.MatchRules {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintMirror(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.PacketSize != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintMirror(dAtA, i, uint64(m.PacketSize))
	}
	if m.MirrorDirection != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintMirror(dAtA, i, uint64(m.MirrorDirection))
	}
	return i, nil
}

func (m *MatchRule) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MatchRule) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Src != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMirror(dAtA, i, uint64(m.Src.Size()))
		n5, err := m.Src.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.Dst != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMirror(dAtA, i, uint64(m.Dst.Size()))
		n6, err := m.Dst.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}

func (m *MirrorSessionStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MirrorSessionStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MirrorSessionID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMirror(dAtA, i, uint64(m.MirrorSessionID))
	}
	return i, nil
}

func (m *MirrorSessionList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MirrorSessionList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.MirrorSessions) > 0 {
		for _, msg := range m.MirrorSessions {
			dAtA[i] = 0xa
			i++
			i = encodeVarintMirror(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *MirrorSessionEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MirrorSessionEvent) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.EventType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMirror(dAtA, i, uint64(m.EventType))
	}
	if m.MirrorSession != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMirror(dAtA, i, uint64(m.MirrorSession.Size()))
		n7, err := m.MirrorSession.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	return i, nil
}

func (m *MirrorSessionEventList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MirrorSessionEventList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.MirrorSessionEvents) > 0 {
		for _, msg := range m.MirrorSessionEvents {
			dAtA[i] = 0xa
			i++
			i = encodeVarintMirror(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *MirrorExportConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MirrorExportConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Destination) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMirror(dAtA, i, uint64(len(m.Destination)))
		i += copy(dAtA[i:], m.Destination)
	}
	return i, nil
}

func (m *MirrorCollector) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MirrorCollector) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintMirror(dAtA, i, uint64(m.ExportCfg.Size()))
	n8, err := m.ExportCfg.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n8
	if len(m.PcapDirName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMirror(dAtA, i, uint64(len(m.PcapDirName)))
		i += copy(dAtA[i:], m.PcapDirName)
	}
	return i, nil
}

func encodeVarintMirror(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *MirrorSession) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovMirror(uint64(l))
	l = m.ObjectMeta.Size()
	n += 1 + l + sovMirror(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovMirror(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovMirror(uint64(l))
	return n
}

func (m *MirrorSessionSpec) Size() (n int) {
	var l int
	_ = l
	l = len(m.VrfName)
	if l > 0 {
		n += 1 + l + sovMirror(uint64(l))
	}
	if len(m.Collectors) > 0 {
		for _, e := range m.Collectors {
			l = e.Size()
			n += 1 + l + sovMirror(uint64(l))
		}
	}
	if len(m.MatchRules) > 0 {
		for _, e := range m.MatchRules {
			l = e.Size()
			n += 1 + l + sovMirror(uint64(l))
		}
	}
	if m.PacketSize != 0 {
		n += 1 + sovMirror(uint64(m.PacketSize))
	}
	if m.MirrorDirection != 0 {
		n += 1 + sovMirror(uint64(m.MirrorDirection))
	}
	return n
}

func (m *MatchRule) Size() (n int) {
	var l int
	_ = l
	if m.Src != nil {
		l = m.Src.Size()
		n += 1 + l + sovMirror(uint64(l))
	}
	if m.Dst != nil {
		l = m.Dst.Size()
		n += 1 + l + sovMirror(uint64(l))
	}
	return n
}

func (m *MirrorSessionStatus) Size() (n int) {
	var l int
	_ = l
	if m.MirrorSessionID != 0 {
		n += 1 + sovMirror(uint64(m.MirrorSessionID))
	}
	return n
}

func (m *MirrorSessionList) Size() (n int) {
	var l int
	_ = l
	if len(m.MirrorSessions) > 0 {
		for _, e := range m.MirrorSessions {
			l = e.Size()
			n += 1 + l + sovMirror(uint64(l))
		}
	}
	return n
}

func (m *MirrorSessionEvent) Size() (n int) {
	var l int
	_ = l
	if m.EventType != 0 {
		n += 1 + sovMirror(uint64(m.EventType))
	}
	if m.MirrorSession != nil {
		l = m.MirrorSession.Size()
		n += 1 + l + sovMirror(uint64(l))
	}
	return n
}

func (m *MirrorSessionEventList) Size() (n int) {
	var l int
	_ = l
	if len(m.MirrorSessionEvents) > 0 {
		for _, e := range m.MirrorSessionEvents {
			l = e.Size()
			n += 1 + l + sovMirror(uint64(l))
		}
	}
	return n
}

func (m *MirrorExportConfig) Size() (n int) {
	var l int
	_ = l
	l = len(m.Destination)
	if l > 0 {
		n += 1 + l + sovMirror(uint64(l))
	}
	return n
}

func (m *MirrorCollector) Size() (n int) {
	var l int
	_ = l
	l = m.ExportCfg.Size()
	n += 1 + l + sovMirror(uint64(l))
	l = len(m.PcapDirName)
	if l > 0 {
		n += 1 + l + sovMirror(uint64(l))
	}
	return n
}

func sovMirror(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozMirror(x uint64) (n int) {
	return sovMirror(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *MirrorSession) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMirror
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MirrorSession: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MirrorSession: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMirror
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMirror
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMirror
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMirror
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMirror(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMirror
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MirrorSessionSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMirror
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MirrorSessionSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MirrorSessionSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VrfName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMirror
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VrfName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Collectors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMirror
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Collectors = append(m.Collectors, MirrorCollector{})
			if err := m.Collectors[len(m.Collectors)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchRules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMirror
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MatchRules = append(m.MatchRules, MatchRule{})
			if err := m.MatchRules[len(m.MatchRules)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PacketSize", wireType)
			}
			m.PacketSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PacketSize |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MirrorDirection", wireType)
			}
			m.MirrorDirection = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MirrorDirection |= (MirrorDir(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMirror(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMirror
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MatchRule) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMirror
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MatchRule: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MatchRule: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Src", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMirror
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Src == nil {
				m.Src = &MatchSelector{}
			}
			if err := m.Src.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dst", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMirror
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Dst == nil {
				m.Dst = &MatchSelector{}
			}
			if err := m.Dst.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMirror(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMirror
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MirrorSessionStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMirror
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MirrorSessionStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MirrorSessionStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MirrorSessionID", wireType)
			}
			m.MirrorSessionID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MirrorSessionID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMirror(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMirror
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MirrorSessionList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMirror
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MirrorSessionList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MirrorSessionList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MirrorSessions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMirror
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MirrorSessions = append(m.MirrorSessions, &MirrorSession{})
			if err := m.MirrorSessions[len(m.MirrorSessions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMirror(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMirror
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MirrorSessionEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMirror
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MirrorSessionEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MirrorSessionEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventType", wireType)
			}
			m.EventType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EventType |= (api.EventType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MirrorSession", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMirror
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MirrorSession == nil {
				m.MirrorSession = &MirrorSession{}
			}
			if err := m.MirrorSession.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMirror(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMirror
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MirrorSessionEventList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMirror
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MirrorSessionEventList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MirrorSessionEventList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MirrorSessionEvents", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMirror
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MirrorSessionEvents = append(m.MirrorSessionEvents, &MirrorSessionEvent{})
			if err := m.MirrorSessionEvents[len(m.MirrorSessionEvents)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMirror(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMirror
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MirrorExportConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMirror
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MirrorExportConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MirrorExportConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Destination", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMirror
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Destination = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMirror(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMirror
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MirrorCollector) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMirror
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MirrorCollector: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MirrorCollector: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExportCfg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMirror
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ExportCfg.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PcapDirName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMirror
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PcapDirName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMirror(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMirror
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMirror(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMirror
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthMirror
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowMirror
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipMirror(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthMirror = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMirror   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("mirror.proto", fileDescriptorMirror) }

var fileDescriptorMirror = []byte{
	// 985 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x55, 0xcf, 0x6f, 0xe3, 0x44,
	0x14, 0xae, 0x93, 0xd0, 0x36, 0x93, 0x36, 0xdb, 0x4e, 0x4b, 0xeb, 0x84, 0xa5, 0x8e, 0x2c, 0x21,
	0x65, 0xa1, 0x89, 0xbb, 0xd9, 0x3d, 0x00, 0x12, 0xac, 0xf0, 0x26, 0x2c, 0x15, 0xfd, 0x45, 0x1c,
	0x2d, 0x07, 0x0e, 0xc8, 0x75, 0x26, 0xe9, 0x40, 0x32, 0x63, 0x79, 0x26, 0x85, 0x2e, 0xda, 0x0b,
	0x48, 0xcb, 0x9d, 0x33, 0x37, 0x6e, 0x7b, 0xe4, 0x00, 0x27, 0xee, 0x3d, 0xf6, 0x2f, 0xb0, 0x50,
	0x8f, 0xf9, 0x2b, 0xd0, 0x4c, 0x6c, 0x67, 0xe2, 0x34, 0x9c, 0xf6, 0x36, 0xf3, 0xfc, 0xbd, 0x6f,
	0xbe, 0x79, 0xef, 0x7b, 0x63, 0xb0, 0x36, 0xc4, 0x41, 0x40, 0x83, 0xba, 0x1f, 0x50, 0x4e, 0xe1,
	0x2a, 0x41, 0x5c, 0xae, 0xca, 0xf7, 0xfb, 0x94, 0xf6, 0x07, 0xc8, 0x72, 0x7d, 0x6c, 0xb9, 0x84,
	0x50, 0xee, 0x72, 0x4c, 0x09, 0x9b, 0xe0, 0xca, 0xad, 0x3e, 0xe6, 0x17, 0xa3, 0xf3, 0xba, 0x47,
	0x87, 0x96, 0x8f, 0x08, 0x73, 0x49, 0x97, 0x5a, 0xec, 0x07, 0xeb, 0x12, 0x11, 0xec, 0x21, 0x6b,
	0xc4, 0xf1, 0x80, 0x89, 0xd4, 0x3e, 0x22, 0x6a, 0xb6, 0x85, 0x89, 0x37, 0x18, 0x75, 0x51, 0x4c,
	0x53, 0x53, 0x68, 0xfa, 0xb4, 0x4f, 0x2d, 0x19, 0x3e, 0x1f, 0xf5, 0xe4, 0x4e, 0x6e, 0xe4, 0x2a,
	0x82, 0xbf, 0xb7, 0xe0, 0x54, 0xa1, 0x71, 0x88, 0xb8, 0x1b, 0xc1, 0x0a, 0x43, 0x97, 0x7b, 0x17,
	0x93, 0x8d, 0xf9, 0x57, 0x06, 0xac, 0x1f, 0xcb, 0x2b, 0x3a, 0x88, 0x31, 0x4c, 0x09, 0xfc, 0x14,
	0xac, 0x76, 0xae, 0x7c, 0x74, 0x8c, 0xb8, 0xab, 0x6b, 0x15, 0xad, 0x5a, 0x68, 0xac, 0xd7, 0x5d,
	0x1f, 0xd7, 0xe3, 0xa0, 0xbd, 0x75, 0x1d, 0x1a, 0x4b, 0x37, 0xa1, 0xa1, 0x8d, 0x43, 0x63, 0x65,
	0x1f, 0x93, 0x01, 0x26, 0xa8, 0x9d, 0xe4, 0xc0, 0x2f, 0x01, 0x38, 0x3d, 0xff, 0x0e, 0x79, 0x5c,
	0x32, 0x64, 0x24, 0xc3, 0x3d, 0xc9, 0x30, 0x0d, 0xdb, 0x65, 0x85, 0xa3, 0x28, 0xb4, 0xed, 0xd3,
	0x21, 0xe6, 0x68, 0xe8, 0xf3, 0xab, 0xb6, 0x92, 0x0e, 0x9f, 0x81, 0x9c, 0xe3, 0x23, 0x4f, 0xcf,
	0x4a, 0x9a, 0x77, 0xea, 0x71, 0xfd, 0xeb, 0x33, 0x9a, 0x05, 0xc4, 0xde, 0x11, 0x94, 0x82, 0x8e,
	0xf9, 0xc8, 0x53, 0xe8, 0x24, 0x01, 0x3c, 0x05, 0xcb, 0x0e, 0x77, 0xf9, 0x88, 0xe9, 0x39, 0x49,
	0xf5, 0xee, 0x22, 0x2a, 0x09, 0xb2, 0xf5, 0x88, 0x6c, 0x83, 0xc9, 0xbd, 0x42, 0x17, 0xd1, 0x98,
	0xbf, 0x67, 0xc1, 0xe6, 0x9c, 0x08, 0x78, 0x00, 0x56, 0x9e, 0x07, 0xbd, 0x13, 0x77, 0x88, 0x64,
	0xed, 0xf2, 0xf6, 0xce, 0x38, 0x34, 0xe0, 0x65, 0xd0, 0xab, 0x11, 0x77, 0x88, 0x14, 0x9a, 0x18,
	0x06, 0x3b, 0x00, 0x3c, 0xa5, 0x83, 0x01, 0xf2, 0x38, 0x0d, 0x98, 0x9e, 0xa9, 0x64, 0xab, 0x85,
	0x46, 0x29, 0x2d, 0x2e, 0x41, 0xd8, 0xa5, 0x48, 0xd8, 0xa6, 0x97, 0x24, 0xc5, 0x2d, 0x50, 0x78,
	0xe0, 0x29, 0x00, 0xc7, 0xa2, 0xcb, 0xed, 0xd1, 0x00, 0x31, 0x3d, 0x2b, 0x59, 0xb7, 0x14, 0xd6,
	0xf8, 0xdb, 0xa4, 0x11, 0x42, 0xa3, 0x34, 0x45, 0x2d, 0x10, 0xf8, 0x84, 0x70, 0x4a, 0x01, 0x3f,
	0x02, 0xe0, 0xcc, 0xf5, 0xbe, 0x47, 0xdc, 0xc1, 0x2f, 0x90, 0xac, 0xe1, 0xba, 0x5d, 0x1a, 0x87,
	0xc6, 0xdb, 0xbe, 0x8c, 0xd6, 0x18, 0x7e, 0xa1, 0x5e, 0x4f, 0x01, 0x43, 0x06, 0xee, 0x4d, 0x6e,
	0xd1, 0xc4, 0x01, 0xf2, 0x84, 0xd1, 0xf5, 0xb7, 0x2a, 0x5a, 0xb5, 0x38, 0x23, 0x28, 0x06, 0xd8,
	0x8f, 0x5f, 0xbf, 0x2a, 0x41, 0x87, 0x07, 0x2d, 0x32, 0x1a, 0x56, 0x93, 0xf0, 0x83, 0x71, 0x68,
	0x94, 0x27, 0xa3, 0x58, 0xeb, 0xc6, 0x34, 0xca, 0x79, 0xe9, 0x13, 0xcc, 0xdf, 0x34, 0x90, 0x4f,
	0xe4, 0xc3, 0x27, 0x20, 0xeb, 0x04, 0x5e, 0x64, 0xe7, 0xdd, 0x54, 0x1d, 0x1c, 0x14, 0xd5, 0x76,
	0x5b, 0x36, 0x9c, 0x8e, 0x02, 0x4f, 0xbd, 0x8a, 0xc8, 0x84, 0x4d, 0x90, 0x6d, 0x32, 0x1e, 0xb9,
	0x79, 0x21, 0x81, 0x2c, 0x48, 0x17, 0x31, 0x8e, 0x89, 0x9b, 0x12, 0x28, 0xd2, 0xcd, 0xaf, 0xc0,
	0xd6, 0x1d, 0x66, 0x83, 0x1f, 0xc7, 0x05, 0x8a, 0xc2, 0x87, 0x4d, 0xa9, 0x34, 0x67, 0x6f, 0x8c,
	0x43, 0x63, 0x0d, 0x77, 0xe7, 0xef, 0x99, 0x00, 0xcd, 0x4e, 0xca, 0x85, 0x47, 0x98, 0x71, 0xf8,
	0x04, 0x14, 0x67, 0x82, 0x4c, 0xd7, 0xa4, 0x03, 0x76, 0x17, 0x98, 0xbe, 0x9d, 0x82, 0x9b, 0xff,
	0x68, 0x00, 0xce, 0x84, 0x5a, 0x97, 0x88, 0x70, 0xf8, 0x39, 0xc8, 0xcb, 0x85, 0x98, 0x75, 0x29,
	0xb1, 0xd8, 0x28, 0xca, 0xc9, 0x4e, 0xa2, 0xb6, 0x3e, 0x0e, 0x8d, 0x6d, 0x24, 0xb6, 0x35, 0x7e,
	0xe5, 0xab, 0x75, 0x9c, 0xa6, 0xc2, 0x6f, 0x53, 0x6f, 0xce, 0x1d, 0x75, 0x55, 0x3f, 0xdb, 0x95,
	0xeb, 0xc9, 0x4b, 0xa1, 0x47, 0x0e, 0x60, 0x93, 0xb8, 0x42, 0x3e, 0xcb, 0x67, 0x5e, 0x80, 0x9d,
	0x79, 0xf9, 0xb2, 0x34, 0x27, 0xa9, 0x16, 0xc8, 0x2f, 0x71, 0x7d, 0xee, 0x2f, 0x10, 0x20, 0x41,
	0xed, 0xbb, 0x12, 0x4d, 0x2f, 0x2e, 0x54, 0xeb, 0x47, 0x9f, 0x06, 0xfc, 0x29, 0x25, 0x3d, 0xdc,
	0x87, 0xc7, 0xa0, 0xd0, 0x9c, 0xda, 0x20, 0x7a, 0x0a, 0x3e, 0x78, 0xfd, 0xaa, 0x54, 0x74, 0x78,
	0x70, 0x84, 0x48, 0xf5, 0xe1, 0x7e, 0xe3, 0xe0, 0xf1, 0x87, 0x0f, 0x16, 0xfb, 0x45, 0xcd, 0x37,
	0xff, 0xd0, 0x62, 0x87, 0x24, 0x23, 0x0e, 0xbf, 0x01, 0xf9, 0xe8, 0xc8, 0x5e, 0x3f, 0x32, 0xf6,
	0x9c, 0x7c, 0x55, 0x93, 0x6d, 0x44, 0x93, 0xbe, 0x8b, 0x64, 0xb4, 0xe6, 0xc9, 0xf0, 0x4c, 0x83,
	0x62, 0x3e, 0xf8, 0x08, 0x14, 0xce, 0x3c, 0xd7, 0x6f, 0xe2, 0x40, 0x3e, 0x65, 0x19, 0xa9, 0x7f,
	0x73, 0x1c, 0x1a, 0xeb, 0xbe, 0xe7, 0xfa, 0x62, 0x02, 0xe5, 0x7b, 0xd6, 0x56, 0x51, 0xef, 0xd7,
	0x41, 0x3e, 0x99, 0x42, 0xb8, 0x0a, 0x72, 0xf6, 0x69, 0xe7, 0x8b, 0x8d, 0x25, 0x58, 0x00, 0x2b,
	0x87, 0x27, 0xcf, 0xda, 0x2d, 0xc7, 0xd9, 0xd0, 0x20, 0x00, 0xcb, 0xad, 0xc9, 0x3a, 0xd3, 0xf8,
	0x3b, 0x93, 0x32, 0xd9, 0x67, 0x3e, 0x7e, 0xfe, 0x10, 0x1e, 0x81, 0xad, 0xaf, 0xc5, 0x54, 0xcd,
	0x5a, 0x12, 0xa6, 0x7f, 0x21, 0xe5, 0xca, 0xff, 0x35, 0x4b, 0xf4, 0xda, 0x5c, 0x3a, 0xd0, 0xe0,
	0x21, 0x80, 0x62, 0xfd, 0x06, 0xc8, 0xca, 0xbf, 0x6a, 0x7f, 0xfe, 0x52, 0xfa, 0x59, 0x4b, 0xff,
	0x2f, 0x73, 0x03, 0xe1, 0xab, 0x6c, 0x1f, 0x71, 0x98, 0xf3, 0x29, 0xe3, 0x70, 0xb9, 0x8b, 0x06,
	0x88, 0x23, 0x98, 0xf5, 0x47, 0xbc, 0xfc, 0x89, 0xf5, 0xd3, 0xf4, 0x98, 0x7a, 0x07, 0x11, 0x97,
	0xf0, 0x97, 0x33, 0x31, 0x51, 0x3b, 0xe6, 0xbb, 0x1e, 0x9a, 0x0f, 0xbf, 0x34, 0xb7, 0xe5, 0xbf,
	0x5b, 0x9e, 0x67, 0x45, 0xae, 0x67, 0x96, 0xbd, 0x76, 0x7d, 0xbb, 0xa7, 0xdd, 0xdc, 0xee, 0x69,
	0xff, 0xde, 0xee, 0x69, 0x67, 0xda, 0xf9, 0xb2, 0x54, 0xfe, 0xe8, 0xbf, 0x00, 0x00, 0x00, 0xff,
	0xff, 0xd4, 0x85, 0xff, 0xba, 0xad, 0x08, 0x00, 0x00,
}
