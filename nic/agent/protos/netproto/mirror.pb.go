// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: mirror.proto

package netproto

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "google.golang.org/genproto/googleapis/api/annotations"
import _ "github.com/pensando/sw/venice/utils/apigen/annotations"
import _ "github.com/gogo/protobuf/gogoproto"
import api "github.com/pensando/sw/api"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type MirrorDir int32

const (
	MirrorDir_BOTH    MirrorDir = 0
	MirrorDir_INGRESS MirrorDir = 1
	MirrorDir_EGRESS  MirrorDir = 2
)

var MirrorDir_name = map[int32]string{
	0: "BOTH",
	1: "INGRESS",
	2: "EGRESS",
}
var MirrorDir_value = map[string]int32{
	"BOTH":    0,
	"INGRESS": 1,
	"EGRESS":  2,
}

func (x MirrorDir) String() string {
	return proto.EnumName(MirrorDir_name, int32(x))
}
func (MirrorDir) EnumDescriptor() ([]byte, []int) { return fileDescriptorMirror, []int{0} }

type MirrorSession struct {
	api.TypeMeta   `protobuf:"bytes,1,opt,name=TypeMeta,embedded=TypeMeta" json:",inline"`
	api.ObjectMeta `protobuf:"bytes,2,opt,name=ObjectMeta,embedded=ObjectMeta" json:"meta,omitempty"`
	Spec           MirrorSessionSpec   `protobuf:"bytes,3,opt,name=Spec" json:"spec,omitempty"`
	Status         MirrorSessionStatus `protobuf:"bytes,4,opt,name=Status" json:"status,omitempty"`
}

func (m *MirrorSession) Reset()                    { *m = MirrorSession{} }
func (m *MirrorSession) String() string            { return proto.CompactTextString(m) }
func (*MirrorSession) ProtoMessage()               {}
func (*MirrorSession) Descriptor() ([]byte, []int) { return fileDescriptorMirror, []int{0} }

func (m *MirrorSession) GetSpec() MirrorSessionSpec {
	if m != nil {
		return m.Spec
	}
	return MirrorSessionSpec{}
}

func (m *MirrorSession) GetStatus() MirrorSessionStatus {
	if m != nil {
		return m.Status
	}
	return MirrorSessionStatus{}
}

type InterfaceMirrorSession struct {
	api.TypeMeta   `protobuf:"bytes,1,opt,name=TypeMeta,embedded=TypeMeta" json:",inline"`
	api.ObjectMeta `protobuf:"bytes,2,opt,name=ObjectMeta,embedded=ObjectMeta" json:"meta,omitempty"`
	Spec           InterfaceMirrorSessionSpec   `protobuf:"bytes,3,opt,name=Spec" json:"spec,omitempty"`
	Status         InterfaceMirrorSessionStatus `protobuf:"bytes,4,opt,name=Status" json:"status,omitempty"`
}

func (m *InterfaceMirrorSession) Reset()                    { *m = InterfaceMirrorSession{} }
func (m *InterfaceMirrorSession) String() string            { return proto.CompactTextString(m) }
func (*InterfaceMirrorSession) ProtoMessage()               {}
func (*InterfaceMirrorSession) Descriptor() ([]byte, []int) { return fileDescriptorMirror, []int{1} }

func (m *InterfaceMirrorSession) GetSpec() InterfaceMirrorSessionSpec {
	if m != nil {
		return m.Spec
	}
	return InterfaceMirrorSessionSpec{}
}

func (m *InterfaceMirrorSession) GetStatus() InterfaceMirrorSessionStatus {
	if m != nil {
		return m.Status
	}
	return InterfaceMirrorSessionStatus{}
}

type MirrorSessionSpec struct {
	VrfName string `protobuf:"bytes,1,opt,name=VrfName,proto3" json:"vrf-name,omitempty"`
	// Mirrored packet collectors
	Collectors []MirrorCollector `protobuf:"bytes,2,rep,name=Collectors" json:"collectors,inline"`
	// Traffic Selection Rules - Matching pakcets are mirrored, based on packet filters and start/stop conditions
	MatchRules      []MatchRule `protobuf:"bytes,3,rep,name=MatchRules" json:"match-rules,inline"`
	PacketSize      uint32      `protobuf:"varint,4,opt,name=PacketSize,proto3" json:"packet-size,omitempty"`
	MirrorDirection MirrorDir   `protobuf:"varint,5,opt,name=MirrorDirection,proto3,enum=netproto.MirrorDir" json:"mirror-direction,omitempty"`
	SpanID          uint32      `protobuf:"varint,6,opt,name=SpanID,proto3" json:"span-id,inline"`
}

func (m *MirrorSessionSpec) Reset()                    { *m = MirrorSessionSpec{} }
func (m *MirrorSessionSpec) String() string            { return proto.CompactTextString(m) }
func (*MirrorSessionSpec) ProtoMessage()               {}
func (*MirrorSessionSpec) Descriptor() ([]byte, []int) { return fileDescriptorMirror, []int{2} }

func (m *MirrorSessionSpec) GetVrfName() string {
	if m != nil {
		return m.VrfName
	}
	return ""
}

func (m *MirrorSessionSpec) GetCollectors() []MirrorCollector {
	if m != nil {
		return m.Collectors
	}
	return nil
}

func (m *MirrorSessionSpec) GetMatchRules() []MatchRule {
	if m != nil {
		return m.MatchRules
	}
	return nil
}

func (m *MirrorSessionSpec) GetPacketSize() uint32 {
	if m != nil {
		return m.PacketSize
	}
	return 0
}

func (m *MirrorSessionSpec) GetMirrorDirection() MirrorDir {
	if m != nil {
		return m.MirrorDirection
	}
	return MirrorDir_BOTH
}

func (m *MirrorSessionSpec) GetSpanID() uint32 {
	if m != nil {
		return m.SpanID
	}
	return 0
}

type InterfaceMirrorSessionSpec struct {
	VrfName string `protobuf:"bytes,1,opt,name=VrfName,proto3" json:"vrf-name,omitempty"`
	// Mirrored packet collectors
	Collectors      []MirrorCollector `protobuf:"bytes,2,rep,name=Collectors" json:"collectors,inline"`
	SpanID          uint32            `protobuf:"varint,3,opt,name=SpanID,proto3" json:"span-id,inline"`
	PacketSize      uint32            `protobuf:"varint,4,opt,name=PacketSize,proto3" json:"packet-size,omitempty"`
	MirrorDirection MirrorDir         `protobuf:"varint,5,opt,name=MirrorDirection,proto3,enum=netproto.MirrorDir" json:"mirror-direction,omitempty"`
	Type            string            `protobuf:"bytes,6,opt,name=Type,proto3" json:"type,omitempty"`
	StripVlanHdr    bool              `protobuf:"varint,7,opt,name=StripVlanHdr,proto3" json:"strip-vlan-hdr,omitempty"`
}

func (m *InterfaceMirrorSessionSpec) Reset()                    { *m = InterfaceMirrorSessionSpec{} }
func (m *InterfaceMirrorSessionSpec) String() string            { return proto.CompactTextString(m) }
func (*InterfaceMirrorSessionSpec) ProtoMessage()               {}
func (*InterfaceMirrorSessionSpec) Descriptor() ([]byte, []int) { return fileDescriptorMirror, []int{3} }

func (m *InterfaceMirrorSessionSpec) GetVrfName() string {
	if m != nil {
		return m.VrfName
	}
	return ""
}

func (m *InterfaceMirrorSessionSpec) GetCollectors() []MirrorCollector {
	if m != nil {
		return m.Collectors
	}
	return nil
}

func (m *InterfaceMirrorSessionSpec) GetSpanID() uint32 {
	if m != nil {
		return m.SpanID
	}
	return 0
}

func (m *InterfaceMirrorSessionSpec) GetPacketSize() uint32 {
	if m != nil {
		return m.PacketSize
	}
	return 0
}

func (m *InterfaceMirrorSessionSpec) GetMirrorDirection() MirrorDir {
	if m != nil {
		return m.MirrorDirection
	}
	return MirrorDir_BOTH
}

func (m *InterfaceMirrorSessionSpec) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *InterfaceMirrorSessionSpec) GetStripVlanHdr() bool {
	if m != nil {
		return m.StripVlanHdr
	}
	return false
}

// MirrorSessionStatus captures the sg policy status
type MirrorSessionStatus struct {
	MirrorSessionID  uint64   `protobuf:"varint,1,opt,name=MirrorSessionID,proto3" json:"id,omitempty"`
	MirrorSessionIDs []uint64 `protobuf:"varint,2,rep,packed,name=MirrorSessionIDs" json:"mirror-session-ids,omitempty"`
	FlowMonitorIDs   []uint64 `protobuf:"varint,3,rep,packed,name=FlowMonitorIDs" json:"flow-monitor-ids,omitempty"`
}

func (m *MirrorSessionStatus) Reset()                    { *m = MirrorSessionStatus{} }
func (m *MirrorSessionStatus) String() string            { return proto.CompactTextString(m) }
func (*MirrorSessionStatus) ProtoMessage()               {}
func (*MirrorSessionStatus) Descriptor() ([]byte, []int) { return fileDescriptorMirror, []int{4} }

func (m *MirrorSessionStatus) GetMirrorSessionID() uint64 {
	if m != nil {
		return m.MirrorSessionID
	}
	return 0
}

func (m *MirrorSessionStatus) GetMirrorSessionIDs() []uint64 {
	if m != nil {
		return m.MirrorSessionIDs
	}
	return nil
}

func (m *MirrorSessionStatus) GetFlowMonitorIDs() []uint64 {
	if m != nil {
		return m.FlowMonitorIDs
	}
	return nil
}

// InterfaceMirrorSessionStatus captures status
type InterfaceMirrorSessionStatus struct {
	MirrorSessionID  uint64   `protobuf:"varint,1,opt,name=MirrorSessionID,proto3" json:"id,omitempty"`
	MirrorSessionIDs []uint64 `protobuf:"varint,2,rep,packed,name=MirrorSessionIDs" json:"mirror-session-ids,omitempty"`
}

func (m *InterfaceMirrorSessionStatus) Reset()         { *m = InterfaceMirrorSessionStatus{} }
func (m *InterfaceMirrorSessionStatus) String() string { return proto.CompactTextString(m) }
func (*InterfaceMirrorSessionStatus) ProtoMessage()    {}
func (*InterfaceMirrorSessionStatus) Descriptor() ([]byte, []int) {
	return fileDescriptorMirror, []int{5}
}

func (m *InterfaceMirrorSessionStatus) GetMirrorSessionID() uint64 {
	if m != nil {
		return m.MirrorSessionID
	}
	return 0
}

func (m *InterfaceMirrorSessionStatus) GetMirrorSessionIDs() []uint64 {
	if m != nil {
		return m.MirrorSessionIDs
	}
	return nil
}

type MirrorSessionList struct {
	MirrorSessions []*MirrorSession `protobuf:"bytes,1,rep,name=MirrorSessions" json:"MirrorSessions,omitempty"`
}

func (m *MirrorSessionList) Reset()                    { *m = MirrorSessionList{} }
func (m *MirrorSessionList) String() string            { return proto.CompactTextString(m) }
func (*MirrorSessionList) ProtoMessage()               {}
func (*MirrorSessionList) Descriptor() ([]byte, []int) { return fileDescriptorMirror, []int{6} }

func (m *MirrorSessionList) GetMirrorSessions() []*MirrorSession {
	if m != nil {
		return m.MirrorSessions
	}
	return nil
}

// mirror watch event
type MirrorSessionEvent struct {
	EventType     api.EventType  `protobuf:"varint,1,opt,name=EventType,proto3,enum=api.EventType" json:"event-type,omitempty"`
	MirrorSession *MirrorSession `protobuf:"bytes,2,opt,name=MirrorSession" json:"mirror-session,omitempty"`
}

func (m *MirrorSessionEvent) Reset()                    { *m = MirrorSessionEvent{} }
func (m *MirrorSessionEvent) String() string            { return proto.CompactTextString(m) }
func (*MirrorSessionEvent) ProtoMessage()               {}
func (*MirrorSessionEvent) Descriptor() ([]byte, []int) { return fileDescriptorMirror, []int{7} }

func (m *MirrorSessionEvent) GetEventType() api.EventType {
	if m != nil {
		return m.EventType
	}
	return api.EventType_CreateEvent
}

func (m *MirrorSessionEvent) GetMirrorSession() *MirrorSession {
	if m != nil {
		return m.MirrorSession
	}
	return nil
}

// mirror watch events batched
type MirrorSessionEventList struct {
	MirrorSessionEvents []*MirrorSessionEvent `protobuf:"bytes,1,rep,name=MirrorSessionEvents" json:"MirrorSessionEvents,omitempty"`
}

func (m *MirrorSessionEventList) Reset()                    { *m = MirrorSessionEventList{} }
func (m *MirrorSessionEventList) String() string            { return proto.CompactTextString(m) }
func (*MirrorSessionEventList) ProtoMessage()               {}
func (*MirrorSessionEventList) Descriptor() ([]byte, []int) { return fileDescriptorMirror, []int{8} }

func (m *MirrorSessionEventList) GetMirrorSessionEvents() []*MirrorSessionEvent {
	if m != nil {
		return m.MirrorSessionEvents
	}
	return nil
}

type InterfaceMirrorSessionList struct {
	InterfaceMirrorSessions []*InterfaceMirrorSession `protobuf:"bytes,1,rep,name=InterfaceMirrorSessions" json:"InterfaceMirrorSessions,omitempty"`
}

func (m *InterfaceMirrorSessionList) Reset()                    { *m = InterfaceMirrorSessionList{} }
func (m *InterfaceMirrorSessionList) String() string            { return proto.CompactTextString(m) }
func (*InterfaceMirrorSessionList) ProtoMessage()               {}
func (*InterfaceMirrorSessionList) Descriptor() ([]byte, []int) { return fileDescriptorMirror, []int{9} }

func (m *InterfaceMirrorSessionList) GetInterfaceMirrorSessions() []*InterfaceMirrorSession {
	if m != nil {
		return m.InterfaceMirrorSessions
	}
	return nil
}

// mirror watch event
type InterfaceMirrorSessionEvent struct {
	EventType              api.EventType          `protobuf:"varint,1,opt,name=EventType,proto3,enum=api.EventType" json:"event-type,omitempty"`
	InterfaceMirrorSession InterfaceMirrorSession `protobuf:"bytes,2,opt,name=InterfaceMirrorSession" json:"interface-mirror-session,omitempty"`
}

func (m *InterfaceMirrorSessionEvent) Reset()         { *m = InterfaceMirrorSessionEvent{} }
func (m *InterfaceMirrorSessionEvent) String() string { return proto.CompactTextString(m) }
func (*InterfaceMirrorSessionEvent) ProtoMessage()    {}
func (*InterfaceMirrorSessionEvent) Descriptor() ([]byte, []int) {
	return fileDescriptorMirror, []int{10}
}

func (m *InterfaceMirrorSessionEvent) GetEventType() api.EventType {
	if m != nil {
		return m.EventType
	}
	return api.EventType_CreateEvent
}

func (m *InterfaceMirrorSessionEvent) GetInterfaceMirrorSession() InterfaceMirrorSession {
	if m != nil {
		return m.InterfaceMirrorSession
	}
	return InterfaceMirrorSession{}
}

// mirror watch events batched
type InterfaceMirrorSessionEventList struct {
	InterfaceMirrorSessionEvents []*InterfaceMirrorSessionEvent `protobuf:"bytes,1,rep,name=InterfaceMirrorSessionEvents" json:"InterfaceMirrorSessionEvents,omitempty"`
}

func (m *InterfaceMirrorSessionEventList) Reset()         { *m = InterfaceMirrorSessionEventList{} }
func (m *InterfaceMirrorSessionEventList) String() string { return proto.CompactTextString(m) }
func (*InterfaceMirrorSessionEventList) ProtoMessage()    {}
func (*InterfaceMirrorSessionEventList) Descriptor() ([]byte, []int) {
	return fileDescriptorMirror, []int{11}
}

func (m *InterfaceMirrorSessionEventList) GetInterfaceMirrorSessionEvents() []*InterfaceMirrorSessionEvent {
	if m != nil {
		return m.InterfaceMirrorSessionEvents
	}
	return nil
}

type MirrorExportConfig struct {
	// IP address or URL of the collector/entity to which the data is to be exported
	Destination string `protobuf:"bytes,1,opt,name=Destination,proto3" json:"destination,omitempty"`
	Gateway     string `protobuf:"bytes,2,opt,name=Gateway,proto3" json:"gateway,omitempty"`
}

func (m *MirrorExportConfig) Reset()                    { *m = MirrorExportConfig{} }
func (m *MirrorExportConfig) String() string            { return proto.CompactTextString(m) }
func (*MirrorExportConfig) ProtoMessage()               {}
func (*MirrorExportConfig) Descriptor() ([]byte, []int) { return fileDescriptorMirror, []int{12} }

func (m *MirrorExportConfig) GetDestination() string {
	if m != nil {
		return m.Destination
	}
	return ""
}

func (m *MirrorExportConfig) GetGateway() string {
	if m != nil {
		return m.Gateway
	}
	return ""
}

// Mirror collector - can be an external device (via ERSPAN) or Venice (internal packet capture)
type MirrorCollector struct {
	// Collector export information for ERSPAN. Not required for VENICE collector
	ExportCfg   MirrorExportConfig `protobuf:"bytes,1,opt,name=ExportCfg" json:"export-config,omitempty"`
	PcapDirName string             `protobuf:"bytes,2,opt,name=PcapDirName,proto3" json:"pcap-dir-name"`
	// Type of Collector
	Type string `protobuf:"bytes,3,opt,name=Type,proto3" json:"type,omitempty"`
	// remove vlan header
	StripVlanHdr bool `protobuf:"varint,4,opt,name=StripVlanHdr,proto3" json:"strip-vlan-hdr,omitempty"`
}

func (m *MirrorCollector) Reset()                    { *m = MirrorCollector{} }
func (m *MirrorCollector) String() string            { return proto.CompactTextString(m) }
func (*MirrorCollector) ProtoMessage()               {}
func (*MirrorCollector) Descriptor() ([]byte, []int) { return fileDescriptorMirror, []int{13} }

func (m *MirrorCollector) GetExportCfg() MirrorExportConfig {
	if m != nil {
		return m.ExportCfg
	}
	return MirrorExportConfig{}
}

func (m *MirrorCollector) GetPcapDirName() string {
	if m != nil {
		return m.PcapDirName
	}
	return ""
}

func (m *MirrorCollector) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *MirrorCollector) GetStripVlanHdr() bool {
	if m != nil {
		return m.StripVlanHdr
	}
	return false
}

func init() {
	proto.RegisterType((*MirrorSession)(nil), "netproto.MirrorSession")
	proto.RegisterType((*InterfaceMirrorSession)(nil), "netproto.InterfaceMirrorSession")
	proto.RegisterType((*MirrorSessionSpec)(nil), "netproto.MirrorSessionSpec")
	proto.RegisterType((*InterfaceMirrorSessionSpec)(nil), "netproto.InterfaceMirrorSessionSpec")
	proto.RegisterType((*MirrorSessionStatus)(nil), "netproto.MirrorSessionStatus")
	proto.RegisterType((*InterfaceMirrorSessionStatus)(nil), "netproto.InterfaceMirrorSessionStatus")
	proto.RegisterType((*MirrorSessionList)(nil), "netproto.MirrorSessionList")
	proto.RegisterType((*MirrorSessionEvent)(nil), "netproto.MirrorSessionEvent")
	proto.RegisterType((*MirrorSessionEventList)(nil), "netproto.MirrorSessionEventList")
	proto.RegisterType((*InterfaceMirrorSessionList)(nil), "netproto.InterfaceMirrorSessionList")
	proto.RegisterType((*InterfaceMirrorSessionEvent)(nil), "netproto.InterfaceMirrorSessionEvent")
	proto.RegisterType((*InterfaceMirrorSessionEventList)(nil), "netproto.InterfaceMirrorSessionEventList")
	proto.RegisterType((*MirrorExportConfig)(nil), "netproto.MirrorExportConfig")
	proto.RegisterType((*MirrorCollector)(nil), "netproto.MirrorCollector")
	proto.RegisterEnum("netproto.MirrorDir", MirrorDir_name, MirrorDir_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for MirrorSessionApiV1 service

type MirrorSessionApiV1Client interface {
	//    TODO uncomment this when TSM uses nimbus
	WatchMirrorSessions(ctx context.Context, in *api.ObjectMeta, opts ...grpc.CallOption) (MirrorSessionApiV1_WatchMirrorSessionsClient, error)
	ListMirrorSessions(ctx context.Context, in *api.ObjectMeta, opts ...grpc.CallOption) (*MirrorSessionEventList, error)
}

type mirrorSessionApiV1Client struct {
	cc *grpc.ClientConn
}

func NewMirrorSessionApiV1Client(cc *grpc.ClientConn) MirrorSessionApiV1Client {
	return &mirrorSessionApiV1Client{cc}
}

func (c *mirrorSessionApiV1Client) WatchMirrorSessions(ctx context.Context, in *api.ObjectMeta, opts ...grpc.CallOption) (MirrorSessionApiV1_WatchMirrorSessionsClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_MirrorSessionApiV1_serviceDesc.Streams[0], c.cc, "/netproto.MirrorSessionApiV1/WatchMirrorSessions", opts...)
	if err != nil {
		return nil, err
	}
	x := &mirrorSessionApiV1WatchMirrorSessionsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type MirrorSessionApiV1_WatchMirrorSessionsClient interface {
	Recv() (*MirrorSessionEventList, error)
	grpc.ClientStream
}

type mirrorSessionApiV1WatchMirrorSessionsClient struct {
	grpc.ClientStream
}

func (x *mirrorSessionApiV1WatchMirrorSessionsClient) Recv() (*MirrorSessionEventList, error) {
	m := new(MirrorSessionEventList)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *mirrorSessionApiV1Client) ListMirrorSessions(ctx context.Context, in *api.ObjectMeta, opts ...grpc.CallOption) (*MirrorSessionEventList, error) {
	out := new(MirrorSessionEventList)
	err := grpc.Invoke(ctx, "/netproto.MirrorSessionApiV1/ListMirrorSessions", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for MirrorSessionApiV1 service

type MirrorSessionApiV1Server interface {
	//    TODO uncomment this when TSM uses nimbus
	WatchMirrorSessions(*api.ObjectMeta, MirrorSessionApiV1_WatchMirrorSessionsServer) error
	ListMirrorSessions(context.Context, *api.ObjectMeta) (*MirrorSessionEventList, error)
}

func RegisterMirrorSessionApiV1Server(s *grpc.Server, srv MirrorSessionApiV1Server) {
	s.RegisterService(&_MirrorSessionApiV1_serviceDesc, srv)
}

func _MirrorSessionApiV1_WatchMirrorSessions_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(api.ObjectMeta)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(MirrorSessionApiV1Server).WatchMirrorSessions(m, &mirrorSessionApiV1WatchMirrorSessionsServer{stream})
}

type MirrorSessionApiV1_WatchMirrorSessionsServer interface {
	Send(*MirrorSessionEventList) error
	grpc.ServerStream
}

type mirrorSessionApiV1WatchMirrorSessionsServer struct {
	grpc.ServerStream
}

func (x *mirrorSessionApiV1WatchMirrorSessionsServer) Send(m *MirrorSessionEventList) error {
	return x.ServerStream.SendMsg(m)
}

func _MirrorSessionApiV1_ListMirrorSessions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(api.ObjectMeta)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MirrorSessionApiV1Server).ListMirrorSessions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/netproto.MirrorSessionApiV1/ListMirrorSessions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MirrorSessionApiV1Server).ListMirrorSessions(ctx, req.(*api.ObjectMeta))
	}
	return interceptor(ctx, in, info, handler)
}

var _MirrorSessionApiV1_serviceDesc = grpc.ServiceDesc{
	ServiceName: "netproto.MirrorSessionApiV1",
	HandlerType: (*MirrorSessionApiV1Server)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListMirrorSessions",
			Handler:    _MirrorSessionApiV1_ListMirrorSessions_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "WatchMirrorSessions",
			Handler:       _MirrorSessionApiV1_WatchMirrorSessions_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "mirror.proto",
}

// Client API for MirrorSessionApiV2 service

type MirrorSessionApiV2Client interface {
	//    TODO uncomment this when TSM uses nimbus
	WatchMirrorSessions(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (MirrorSessionApiV2_WatchMirrorSessionsClient, error)
	ListMirrorSessions(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (*MirrorSessionList, error)
	MirrorSessionOperUpdate(ctx context.Context, opts ...grpc.CallOption) (MirrorSessionApiV2_MirrorSessionOperUpdateClient, error)
}

type mirrorSessionApiV2Client struct {
	cc *grpc.ClientConn
}

func NewMirrorSessionApiV2Client(cc *grpc.ClientConn) MirrorSessionApiV2Client {
	return &mirrorSessionApiV2Client{cc}
}

func (c *mirrorSessionApiV2Client) WatchMirrorSessions(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (MirrorSessionApiV2_WatchMirrorSessionsClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_MirrorSessionApiV2_serviceDesc.Streams[0], c.cc, "/netproto.MirrorSessionApiV2/WatchMirrorSessions", opts...)
	if err != nil {
		return nil, err
	}
	x := &mirrorSessionApiV2WatchMirrorSessionsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type MirrorSessionApiV2_WatchMirrorSessionsClient interface {
	Recv() (*MirrorSessionEventList, error)
	grpc.ClientStream
}

type mirrorSessionApiV2WatchMirrorSessionsClient struct {
	grpc.ClientStream
}

func (x *mirrorSessionApiV2WatchMirrorSessionsClient) Recv() (*MirrorSessionEventList, error) {
	m := new(MirrorSessionEventList)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *mirrorSessionApiV2Client) ListMirrorSessions(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (*MirrorSessionList, error) {
	out := new(MirrorSessionList)
	err := grpc.Invoke(ctx, "/netproto.MirrorSessionApiV2/ListMirrorSessions", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mirrorSessionApiV2Client) MirrorSessionOperUpdate(ctx context.Context, opts ...grpc.CallOption) (MirrorSessionApiV2_MirrorSessionOperUpdateClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_MirrorSessionApiV2_serviceDesc.Streams[1], c.cc, "/netproto.MirrorSessionApiV2/MirrorSessionOperUpdate", opts...)
	if err != nil {
		return nil, err
	}
	x := &mirrorSessionApiV2MirrorSessionOperUpdateClient{stream}
	return x, nil
}

type MirrorSessionApiV2_MirrorSessionOperUpdateClient interface {
	Send(*MirrorSessionEvent) error
	CloseAndRecv() (*api.TypeMeta, error)
	grpc.ClientStream
}

type mirrorSessionApiV2MirrorSessionOperUpdateClient struct {
	grpc.ClientStream
}

func (x *mirrorSessionApiV2MirrorSessionOperUpdateClient) Send(m *MirrorSessionEvent) error {
	return x.ClientStream.SendMsg(m)
}

func (x *mirrorSessionApiV2MirrorSessionOperUpdateClient) CloseAndRecv() (*api.TypeMeta, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(api.TypeMeta)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for MirrorSessionApiV2 service

type MirrorSessionApiV2Server interface {
	//    TODO uncomment this when TSM uses nimbus
	WatchMirrorSessions(*api.ListWatchOptions, MirrorSessionApiV2_WatchMirrorSessionsServer) error
	ListMirrorSessions(context.Context, *api.ListWatchOptions) (*MirrorSessionList, error)
	MirrorSessionOperUpdate(MirrorSessionApiV2_MirrorSessionOperUpdateServer) error
}

func RegisterMirrorSessionApiV2Server(s *grpc.Server, srv MirrorSessionApiV2Server) {
	s.RegisterService(&_MirrorSessionApiV2_serviceDesc, srv)
}

func _MirrorSessionApiV2_WatchMirrorSessions_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(api.ListWatchOptions)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(MirrorSessionApiV2Server).WatchMirrorSessions(m, &mirrorSessionApiV2WatchMirrorSessionsServer{stream})
}

type MirrorSessionApiV2_WatchMirrorSessionsServer interface {
	Send(*MirrorSessionEventList) error
	grpc.ServerStream
}

type mirrorSessionApiV2WatchMirrorSessionsServer struct {
	grpc.ServerStream
}

func (x *mirrorSessionApiV2WatchMirrorSessionsServer) Send(m *MirrorSessionEventList) error {
	return x.ServerStream.SendMsg(m)
}

func _MirrorSessionApiV2_ListMirrorSessions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(api.ListWatchOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MirrorSessionApiV2Server).ListMirrorSessions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/netproto.MirrorSessionApiV2/ListMirrorSessions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MirrorSessionApiV2Server).ListMirrorSessions(ctx, req.(*api.ListWatchOptions))
	}
	return interceptor(ctx, in, info, handler)
}

func _MirrorSessionApiV2_MirrorSessionOperUpdate_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(MirrorSessionApiV2Server).MirrorSessionOperUpdate(&mirrorSessionApiV2MirrorSessionOperUpdateServer{stream})
}

type MirrorSessionApiV2_MirrorSessionOperUpdateServer interface {
	SendAndClose(*api.TypeMeta) error
	Recv() (*MirrorSessionEvent, error)
	grpc.ServerStream
}

type mirrorSessionApiV2MirrorSessionOperUpdateServer struct {
	grpc.ServerStream
}

func (x *mirrorSessionApiV2MirrorSessionOperUpdateServer) SendAndClose(m *api.TypeMeta) error {
	return x.ServerStream.SendMsg(m)
}

func (x *mirrorSessionApiV2MirrorSessionOperUpdateServer) Recv() (*MirrorSessionEvent, error) {
	m := new(MirrorSessionEvent)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _MirrorSessionApiV2_serviceDesc = grpc.ServiceDesc{
	ServiceName: "netproto.MirrorSessionApiV2",
	HandlerType: (*MirrorSessionApiV2Server)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListMirrorSessions",
			Handler:    _MirrorSessionApiV2_ListMirrorSessions_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "WatchMirrorSessions",
			Handler:       _MirrorSessionApiV2_WatchMirrorSessions_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "MirrorSessionOperUpdate",
			Handler:       _MirrorSessionApiV2_MirrorSessionOperUpdate_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "mirror.proto",
}

// Client API for InterfaceMirrorSessionApiV1 service

type InterfaceMirrorSessionApiV1Client interface {
	WatchInterfaceMirrorSessions(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (InterfaceMirrorSessionApiV1_WatchInterfaceMirrorSessionsClient, error)
	ListInterfaceMirrorSessions(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (*InterfaceMirrorSessionList, error)
	InterfaceMirrorSessionOperUpdate(ctx context.Context, opts ...grpc.CallOption) (InterfaceMirrorSessionApiV1_InterfaceMirrorSessionOperUpdateClient, error)
}

type interfaceMirrorSessionApiV1Client struct {
	cc *grpc.ClientConn
}

func NewInterfaceMirrorSessionApiV1Client(cc *grpc.ClientConn) InterfaceMirrorSessionApiV1Client {
	return &interfaceMirrorSessionApiV1Client{cc}
}

func (c *interfaceMirrorSessionApiV1Client) WatchInterfaceMirrorSessions(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (InterfaceMirrorSessionApiV1_WatchInterfaceMirrorSessionsClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_InterfaceMirrorSessionApiV1_serviceDesc.Streams[0], c.cc, "/netproto.InterfaceMirrorSessionApiV1/WatchInterfaceMirrorSessions", opts...)
	if err != nil {
		return nil, err
	}
	x := &interfaceMirrorSessionApiV1WatchInterfaceMirrorSessionsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type InterfaceMirrorSessionApiV1_WatchInterfaceMirrorSessionsClient interface {
	Recv() (*InterfaceMirrorSessionEventList, error)
	grpc.ClientStream
}

type interfaceMirrorSessionApiV1WatchInterfaceMirrorSessionsClient struct {
	grpc.ClientStream
}

func (x *interfaceMirrorSessionApiV1WatchInterfaceMirrorSessionsClient) Recv() (*InterfaceMirrorSessionEventList, error) {
	m := new(InterfaceMirrorSessionEventList)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *interfaceMirrorSessionApiV1Client) ListInterfaceMirrorSessions(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (*InterfaceMirrorSessionList, error) {
	out := new(InterfaceMirrorSessionList)
	err := grpc.Invoke(ctx, "/netproto.InterfaceMirrorSessionApiV1/ListInterfaceMirrorSessions", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *interfaceMirrorSessionApiV1Client) InterfaceMirrorSessionOperUpdate(ctx context.Context, opts ...grpc.CallOption) (InterfaceMirrorSessionApiV1_InterfaceMirrorSessionOperUpdateClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_InterfaceMirrorSessionApiV1_serviceDesc.Streams[1], c.cc, "/netproto.InterfaceMirrorSessionApiV1/InterfaceMirrorSessionOperUpdate", opts...)
	if err != nil {
		return nil, err
	}
	x := &interfaceMirrorSessionApiV1InterfaceMirrorSessionOperUpdateClient{stream}
	return x, nil
}

type InterfaceMirrorSessionApiV1_InterfaceMirrorSessionOperUpdateClient interface {
	Send(*InterfaceMirrorSessionEvent) error
	CloseAndRecv() (*api.TypeMeta, error)
	grpc.ClientStream
}

type interfaceMirrorSessionApiV1InterfaceMirrorSessionOperUpdateClient struct {
	grpc.ClientStream
}

func (x *interfaceMirrorSessionApiV1InterfaceMirrorSessionOperUpdateClient) Send(m *InterfaceMirrorSessionEvent) error {
	return x.ClientStream.SendMsg(m)
}

func (x *interfaceMirrorSessionApiV1InterfaceMirrorSessionOperUpdateClient) CloseAndRecv() (*api.TypeMeta, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(api.TypeMeta)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for InterfaceMirrorSessionApiV1 service

type InterfaceMirrorSessionApiV1Server interface {
	WatchInterfaceMirrorSessions(*api.ListWatchOptions, InterfaceMirrorSessionApiV1_WatchInterfaceMirrorSessionsServer) error
	ListInterfaceMirrorSessions(context.Context, *api.ListWatchOptions) (*InterfaceMirrorSessionList, error)
	InterfaceMirrorSessionOperUpdate(InterfaceMirrorSessionApiV1_InterfaceMirrorSessionOperUpdateServer) error
}

func RegisterInterfaceMirrorSessionApiV1Server(s *grpc.Server, srv InterfaceMirrorSessionApiV1Server) {
	s.RegisterService(&_InterfaceMirrorSessionApiV1_serviceDesc, srv)
}

func _InterfaceMirrorSessionApiV1_WatchInterfaceMirrorSessions_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(api.ListWatchOptions)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(InterfaceMirrorSessionApiV1Server).WatchInterfaceMirrorSessions(m, &interfaceMirrorSessionApiV1WatchInterfaceMirrorSessionsServer{stream})
}

type InterfaceMirrorSessionApiV1_WatchInterfaceMirrorSessionsServer interface {
	Send(*InterfaceMirrorSessionEventList) error
	grpc.ServerStream
}

type interfaceMirrorSessionApiV1WatchInterfaceMirrorSessionsServer struct {
	grpc.ServerStream
}

func (x *interfaceMirrorSessionApiV1WatchInterfaceMirrorSessionsServer) Send(m *InterfaceMirrorSessionEventList) error {
	return x.ServerStream.SendMsg(m)
}

func _InterfaceMirrorSessionApiV1_ListInterfaceMirrorSessions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(api.ListWatchOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InterfaceMirrorSessionApiV1Server).ListInterfaceMirrorSessions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/netproto.InterfaceMirrorSessionApiV1/ListInterfaceMirrorSessions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InterfaceMirrorSessionApiV1Server).ListInterfaceMirrorSessions(ctx, req.(*api.ListWatchOptions))
	}
	return interceptor(ctx, in, info, handler)
}

func _InterfaceMirrorSessionApiV1_InterfaceMirrorSessionOperUpdate_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(InterfaceMirrorSessionApiV1Server).InterfaceMirrorSessionOperUpdate(&interfaceMirrorSessionApiV1InterfaceMirrorSessionOperUpdateServer{stream})
}

type InterfaceMirrorSessionApiV1_InterfaceMirrorSessionOperUpdateServer interface {
	SendAndClose(*api.TypeMeta) error
	Recv() (*InterfaceMirrorSessionEvent, error)
	grpc.ServerStream
}

type interfaceMirrorSessionApiV1InterfaceMirrorSessionOperUpdateServer struct {
	grpc.ServerStream
}

func (x *interfaceMirrorSessionApiV1InterfaceMirrorSessionOperUpdateServer) SendAndClose(m *api.TypeMeta) error {
	return x.ServerStream.SendMsg(m)
}

func (x *interfaceMirrorSessionApiV1InterfaceMirrorSessionOperUpdateServer) Recv() (*InterfaceMirrorSessionEvent, error) {
	m := new(InterfaceMirrorSessionEvent)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _InterfaceMirrorSessionApiV1_serviceDesc = grpc.ServiceDesc{
	ServiceName: "netproto.InterfaceMirrorSessionApiV1",
	HandlerType: (*InterfaceMirrorSessionApiV1Server)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListInterfaceMirrorSessions",
			Handler:    _InterfaceMirrorSessionApiV1_ListInterfaceMirrorSessions_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "WatchInterfaceMirrorSessions",
			Handler:       _InterfaceMirrorSessionApiV1_WatchInterfaceMirrorSessions_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "InterfaceMirrorSessionOperUpdate",
			Handler:       _InterfaceMirrorSessionApiV1_InterfaceMirrorSessionOperUpdate_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "mirror.proto",
}

func (m *MirrorSession) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MirrorSession) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintMirror(dAtA, i, uint64(m.TypeMeta.Size()))
	n1, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n1
	dAtA[i] = 0x12
	i++
	i = encodeVarintMirror(dAtA, i, uint64(m.ObjectMeta.Size()))
	n2, err := m.ObjectMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n2
	dAtA[i] = 0x1a
	i++
	i = encodeVarintMirror(dAtA, i, uint64(m.Spec.Size()))
	n3, err := m.Spec.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n3
	dAtA[i] = 0x22
	i++
	i = encodeVarintMirror(dAtA, i, uint64(m.Status.Size()))
	n4, err := m.Status.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n4
	return i, nil
}

func (m *InterfaceMirrorSession) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InterfaceMirrorSession) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintMirror(dAtA, i, uint64(m.TypeMeta.Size()))
	n5, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n5
	dAtA[i] = 0x12
	i++
	i = encodeVarintMirror(dAtA, i, uint64(m.ObjectMeta.Size()))
	n6, err := m.ObjectMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n6
	dAtA[i] = 0x1a
	i++
	i = encodeVarintMirror(dAtA, i, uint64(m.Spec.Size()))
	n7, err := m.Spec.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n7
	dAtA[i] = 0x22
	i++
	i = encodeVarintMirror(dAtA, i, uint64(m.Status.Size()))
	n8, err := m.Status.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n8
	return i, nil
}

func (m *MirrorSessionSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MirrorSessionSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.VrfName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMirror(dAtA, i, uint64(len(m.VrfName)))
		i += copy(dAtA[i:], m.VrfName)
	}
	if len(m.Collectors) > 0 {
		for _, msg := range m.Collectors {
			dAtA[i] = 0x12
			i++
			i = encodeVarintMirror(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.MatchRules) > 0 {
		for _, msg := range m.MatchRules {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintMirror(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.PacketSize != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintMirror(dAtA, i, uint64(m.PacketSize))
	}
	if m.MirrorDirection != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintMirror(dAtA, i, uint64(m.MirrorDirection))
	}
	if m.SpanID != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintMirror(dAtA, i, uint64(m.SpanID))
	}
	return i, nil
}

func (m *InterfaceMirrorSessionSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InterfaceMirrorSessionSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.VrfName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMirror(dAtA, i, uint64(len(m.VrfName)))
		i += copy(dAtA[i:], m.VrfName)
	}
	if len(m.Collectors) > 0 {
		for _, msg := range m.Collectors {
			dAtA[i] = 0x12
			i++
			i = encodeVarintMirror(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.SpanID != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMirror(dAtA, i, uint64(m.SpanID))
	}
	if m.PacketSize != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintMirror(dAtA, i, uint64(m.PacketSize))
	}
	if m.MirrorDirection != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintMirror(dAtA, i, uint64(m.MirrorDirection))
	}
	if len(m.Type) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintMirror(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if m.StripVlanHdr {
		dAtA[i] = 0x38
		i++
		if m.StripVlanHdr {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *MirrorSessionStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MirrorSessionStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MirrorSessionID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMirror(dAtA, i, uint64(m.MirrorSessionID))
	}
	if len(m.MirrorSessionIDs) > 0 {
		dAtA10 := make([]byte, len(m.MirrorSessionIDs)*10)
		var j9 int
		for _, num := range m.MirrorSessionIDs {
			for num >= 1<<7 {
				dAtA10[j9] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j9++
			}
			dAtA10[j9] = uint8(num)
			j9++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintMirror(dAtA, i, uint64(j9))
		i += copy(dAtA[i:], dAtA10[:j9])
	}
	if len(m.FlowMonitorIDs) > 0 {
		dAtA12 := make([]byte, len(m.FlowMonitorIDs)*10)
		var j11 int
		for _, num := range m.FlowMonitorIDs {
			for num >= 1<<7 {
				dAtA12[j11] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j11++
			}
			dAtA12[j11] = uint8(num)
			j11++
		}
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMirror(dAtA, i, uint64(j11))
		i += copy(dAtA[i:], dAtA12[:j11])
	}
	return i, nil
}

func (m *InterfaceMirrorSessionStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InterfaceMirrorSessionStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MirrorSessionID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMirror(dAtA, i, uint64(m.MirrorSessionID))
	}
	if len(m.MirrorSessionIDs) > 0 {
		dAtA14 := make([]byte, len(m.MirrorSessionIDs)*10)
		var j13 int
		for _, num := range m.MirrorSessionIDs {
			for num >= 1<<7 {
				dAtA14[j13] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j13++
			}
			dAtA14[j13] = uint8(num)
			j13++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintMirror(dAtA, i, uint64(j13))
		i += copy(dAtA[i:], dAtA14[:j13])
	}
	return i, nil
}

func (m *MirrorSessionList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MirrorSessionList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.MirrorSessions) > 0 {
		for _, msg := range m.MirrorSessions {
			dAtA[i] = 0xa
			i++
			i = encodeVarintMirror(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *MirrorSessionEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MirrorSessionEvent) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.EventType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMirror(dAtA, i, uint64(m.EventType))
	}
	if m.MirrorSession != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMirror(dAtA, i, uint64(m.MirrorSession.Size()))
		n15, err := m.MirrorSession.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	return i, nil
}

func (m *MirrorSessionEventList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MirrorSessionEventList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.MirrorSessionEvents) > 0 {
		for _, msg := range m.MirrorSessionEvents {
			dAtA[i] = 0xa
			i++
			i = encodeVarintMirror(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *InterfaceMirrorSessionList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InterfaceMirrorSessionList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.InterfaceMirrorSessions) > 0 {
		for _, msg := range m.InterfaceMirrorSessions {
			dAtA[i] = 0xa
			i++
			i = encodeVarintMirror(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *InterfaceMirrorSessionEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InterfaceMirrorSessionEvent) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.EventType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMirror(dAtA, i, uint64(m.EventType))
	}
	dAtA[i] = 0x12
	i++
	i = encodeVarintMirror(dAtA, i, uint64(m.InterfaceMirrorSession.Size()))
	n16, err := m.InterfaceMirrorSession.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n16
	return i, nil
}

func (m *InterfaceMirrorSessionEventList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InterfaceMirrorSessionEventList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.InterfaceMirrorSessionEvents) > 0 {
		for _, msg := range m.InterfaceMirrorSessionEvents {
			dAtA[i] = 0xa
			i++
			i = encodeVarintMirror(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *MirrorExportConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MirrorExportConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Destination) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMirror(dAtA, i, uint64(len(m.Destination)))
		i += copy(dAtA[i:], m.Destination)
	}
	if len(m.Gateway) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMirror(dAtA, i, uint64(len(m.Gateway)))
		i += copy(dAtA[i:], m.Gateway)
	}
	return i, nil
}

func (m *MirrorCollector) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MirrorCollector) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintMirror(dAtA, i, uint64(m.ExportCfg.Size()))
	n17, err := m.ExportCfg.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n17
	if len(m.PcapDirName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMirror(dAtA, i, uint64(len(m.PcapDirName)))
		i += copy(dAtA[i:], m.PcapDirName)
	}
	if len(m.Type) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMirror(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if m.StripVlanHdr {
		dAtA[i] = 0x20
		i++
		if m.StripVlanHdr {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func encodeVarintMirror(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *MirrorSession) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovMirror(uint64(l))
	l = m.ObjectMeta.Size()
	n += 1 + l + sovMirror(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovMirror(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovMirror(uint64(l))
	return n
}

func (m *InterfaceMirrorSession) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovMirror(uint64(l))
	l = m.ObjectMeta.Size()
	n += 1 + l + sovMirror(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovMirror(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovMirror(uint64(l))
	return n
}

func (m *MirrorSessionSpec) Size() (n int) {
	var l int
	_ = l
	l = len(m.VrfName)
	if l > 0 {
		n += 1 + l + sovMirror(uint64(l))
	}
	if len(m.Collectors) > 0 {
		for _, e := range m.Collectors {
			l = e.Size()
			n += 1 + l + sovMirror(uint64(l))
		}
	}
	if len(m.MatchRules) > 0 {
		for _, e := range m.MatchRules {
			l = e.Size()
			n += 1 + l + sovMirror(uint64(l))
		}
	}
	if m.PacketSize != 0 {
		n += 1 + sovMirror(uint64(m.PacketSize))
	}
	if m.MirrorDirection != 0 {
		n += 1 + sovMirror(uint64(m.MirrorDirection))
	}
	if m.SpanID != 0 {
		n += 1 + sovMirror(uint64(m.SpanID))
	}
	return n
}

func (m *InterfaceMirrorSessionSpec) Size() (n int) {
	var l int
	_ = l
	l = len(m.VrfName)
	if l > 0 {
		n += 1 + l + sovMirror(uint64(l))
	}
	if len(m.Collectors) > 0 {
		for _, e := range m.Collectors {
			l = e.Size()
			n += 1 + l + sovMirror(uint64(l))
		}
	}
	if m.SpanID != 0 {
		n += 1 + sovMirror(uint64(m.SpanID))
	}
	if m.PacketSize != 0 {
		n += 1 + sovMirror(uint64(m.PacketSize))
	}
	if m.MirrorDirection != 0 {
		n += 1 + sovMirror(uint64(m.MirrorDirection))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovMirror(uint64(l))
	}
	if m.StripVlanHdr {
		n += 2
	}
	return n
}

func (m *MirrorSessionStatus) Size() (n int) {
	var l int
	_ = l
	if m.MirrorSessionID != 0 {
		n += 1 + sovMirror(uint64(m.MirrorSessionID))
	}
	if len(m.MirrorSessionIDs) > 0 {
		l = 0
		for _, e := range m.MirrorSessionIDs {
			l += sovMirror(uint64(e))
		}
		n += 1 + sovMirror(uint64(l)) + l
	}
	if len(m.FlowMonitorIDs) > 0 {
		l = 0
		for _, e := range m.FlowMonitorIDs {
			l += sovMirror(uint64(e))
		}
		n += 1 + sovMirror(uint64(l)) + l
	}
	return n
}

func (m *InterfaceMirrorSessionStatus) Size() (n int) {
	var l int
	_ = l
	if m.MirrorSessionID != 0 {
		n += 1 + sovMirror(uint64(m.MirrorSessionID))
	}
	if len(m.MirrorSessionIDs) > 0 {
		l = 0
		for _, e := range m.MirrorSessionIDs {
			l += sovMirror(uint64(e))
		}
		n += 1 + sovMirror(uint64(l)) + l
	}
	return n
}

func (m *MirrorSessionList) Size() (n int) {
	var l int
	_ = l
	if len(m.MirrorSessions) > 0 {
		for _, e := range m.MirrorSessions {
			l = e.Size()
			n += 1 + l + sovMirror(uint64(l))
		}
	}
	return n
}

func (m *MirrorSessionEvent) Size() (n int) {
	var l int
	_ = l
	if m.EventType != 0 {
		n += 1 + sovMirror(uint64(m.EventType))
	}
	if m.MirrorSession != nil {
		l = m.MirrorSession.Size()
		n += 1 + l + sovMirror(uint64(l))
	}
	return n
}

func (m *MirrorSessionEventList) Size() (n int) {
	var l int
	_ = l
	if len(m.MirrorSessionEvents) > 0 {
		for _, e := range m.MirrorSessionEvents {
			l = e.Size()
			n += 1 + l + sovMirror(uint64(l))
		}
	}
	return n
}

func (m *InterfaceMirrorSessionList) Size() (n int) {
	var l int
	_ = l
	if len(m.InterfaceMirrorSessions) > 0 {
		for _, e := range m.InterfaceMirrorSessions {
			l = e.Size()
			n += 1 + l + sovMirror(uint64(l))
		}
	}
	return n
}

func (m *InterfaceMirrorSessionEvent) Size() (n int) {
	var l int
	_ = l
	if m.EventType != 0 {
		n += 1 + sovMirror(uint64(m.EventType))
	}
	l = m.InterfaceMirrorSession.Size()
	n += 1 + l + sovMirror(uint64(l))
	return n
}

func (m *InterfaceMirrorSessionEventList) Size() (n int) {
	var l int
	_ = l
	if len(m.InterfaceMirrorSessionEvents) > 0 {
		for _, e := range m.InterfaceMirrorSessionEvents {
			l = e.Size()
			n += 1 + l + sovMirror(uint64(l))
		}
	}
	return n
}

func (m *MirrorExportConfig) Size() (n int) {
	var l int
	_ = l
	l = len(m.Destination)
	if l > 0 {
		n += 1 + l + sovMirror(uint64(l))
	}
	l = len(m.Gateway)
	if l > 0 {
		n += 1 + l + sovMirror(uint64(l))
	}
	return n
}

func (m *MirrorCollector) Size() (n int) {
	var l int
	_ = l
	l = m.ExportCfg.Size()
	n += 1 + l + sovMirror(uint64(l))
	l = len(m.PcapDirName)
	if l > 0 {
		n += 1 + l + sovMirror(uint64(l))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovMirror(uint64(l))
	}
	if m.StripVlanHdr {
		n += 2
	}
	return n
}

func sovMirror(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozMirror(x uint64) (n int) {
	return sovMirror(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *MirrorSession) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMirror
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MirrorSession: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MirrorSession: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMirror
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMirror
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMirror
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMirror
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMirror(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMirror
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InterfaceMirrorSession) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMirror
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InterfaceMirrorSession: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InterfaceMirrorSession: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMirror
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMirror
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMirror
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMirror
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMirror(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMirror
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MirrorSessionSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMirror
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MirrorSessionSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MirrorSessionSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VrfName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMirror
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VrfName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Collectors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMirror
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Collectors = append(m.Collectors, MirrorCollector{})
			if err := m.Collectors[len(m.Collectors)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchRules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMirror
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MatchRules = append(m.MatchRules, MatchRule{})
			if err := m.MatchRules[len(m.MatchRules)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PacketSize", wireType)
			}
			m.PacketSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PacketSize |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MirrorDirection", wireType)
			}
			m.MirrorDirection = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MirrorDirection |= (MirrorDir(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpanID", wireType)
			}
			m.SpanID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SpanID |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMirror(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMirror
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InterfaceMirrorSessionSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMirror
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InterfaceMirrorSessionSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InterfaceMirrorSessionSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VrfName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMirror
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VrfName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Collectors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMirror
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Collectors = append(m.Collectors, MirrorCollector{})
			if err := m.Collectors[len(m.Collectors)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpanID", wireType)
			}
			m.SpanID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SpanID |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PacketSize", wireType)
			}
			m.PacketSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PacketSize |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MirrorDirection", wireType)
			}
			m.MirrorDirection = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MirrorDirection |= (MirrorDir(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMirror
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StripVlanHdr", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.StripVlanHdr = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipMirror(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMirror
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MirrorSessionStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMirror
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MirrorSessionStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MirrorSessionStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MirrorSessionID", wireType)
			}
			m.MirrorSessionID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MirrorSessionID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMirror
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.MirrorSessionIDs = append(m.MirrorSessionIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMirror
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMirror
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMirror
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.MirrorSessionIDs = append(m.MirrorSessionIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field MirrorSessionIDs", wireType)
			}
		case 3:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMirror
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.FlowMonitorIDs = append(m.FlowMonitorIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMirror
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMirror
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMirror
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.FlowMonitorIDs = append(m.FlowMonitorIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field FlowMonitorIDs", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMirror(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMirror
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InterfaceMirrorSessionStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMirror
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InterfaceMirrorSessionStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InterfaceMirrorSessionStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MirrorSessionID", wireType)
			}
			m.MirrorSessionID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MirrorSessionID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMirror
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.MirrorSessionIDs = append(m.MirrorSessionIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMirror
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMirror
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMirror
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.MirrorSessionIDs = append(m.MirrorSessionIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field MirrorSessionIDs", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMirror(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMirror
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MirrorSessionList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMirror
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MirrorSessionList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MirrorSessionList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MirrorSessions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMirror
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MirrorSessions = append(m.MirrorSessions, &MirrorSession{})
			if err := m.MirrorSessions[len(m.MirrorSessions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMirror(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMirror
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MirrorSessionEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMirror
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MirrorSessionEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MirrorSessionEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventType", wireType)
			}
			m.EventType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EventType |= (api.EventType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MirrorSession", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMirror
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MirrorSession == nil {
				m.MirrorSession = &MirrorSession{}
			}
			if err := m.MirrorSession.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMirror(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMirror
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MirrorSessionEventList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMirror
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MirrorSessionEventList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MirrorSessionEventList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MirrorSessionEvents", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMirror
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MirrorSessionEvents = append(m.MirrorSessionEvents, &MirrorSessionEvent{})
			if err := m.MirrorSessionEvents[len(m.MirrorSessionEvents)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMirror(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMirror
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InterfaceMirrorSessionList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMirror
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InterfaceMirrorSessionList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InterfaceMirrorSessionList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InterfaceMirrorSessions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMirror
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InterfaceMirrorSessions = append(m.InterfaceMirrorSessions, &InterfaceMirrorSession{})
			if err := m.InterfaceMirrorSessions[len(m.InterfaceMirrorSessions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMirror(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMirror
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InterfaceMirrorSessionEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMirror
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InterfaceMirrorSessionEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InterfaceMirrorSessionEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventType", wireType)
			}
			m.EventType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EventType |= (api.EventType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InterfaceMirrorSession", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMirror
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.InterfaceMirrorSession.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMirror(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMirror
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InterfaceMirrorSessionEventList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMirror
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InterfaceMirrorSessionEventList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InterfaceMirrorSessionEventList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InterfaceMirrorSessionEvents", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMirror
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InterfaceMirrorSessionEvents = append(m.InterfaceMirrorSessionEvents, &InterfaceMirrorSessionEvent{})
			if err := m.InterfaceMirrorSessionEvents[len(m.InterfaceMirrorSessionEvents)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMirror(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMirror
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MirrorExportConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMirror
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MirrorExportConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MirrorExportConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Destination", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMirror
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Destination = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gateway", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMirror
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Gateway = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMirror(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMirror
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MirrorCollector) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMirror
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MirrorCollector: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MirrorCollector: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExportCfg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMirror
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ExportCfg.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PcapDirName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMirror
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PcapDirName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMirror
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StripVlanHdr", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.StripVlanHdr = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipMirror(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMirror
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMirror(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMirror
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMirror
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthMirror
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowMirror
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipMirror(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthMirror = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMirror   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("mirror.proto", fileDescriptorMirror) }

var fileDescriptorMirror = []byte{
	// 1390 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xd4, 0x57, 0x4b, 0x6f, 0xdb, 0xc6,
	0x13, 0x37, 0x25, 0xfd, 0xfd, 0x58, 0x3f, 0x62, 0xaf, 0x13, 0x9b, 0x56, 0xfc, 0xb7, 0x04, 0xa2,
	0x49, 0x15, 0x37, 0x94, 0x12, 0x25, 0x87, 0x16, 0xe8, 0x2b, 0x8c, 0x9d, 0xc4, 0xa9, 0x1d, 0x1b,
	0x92, 0xeb, 0x16, 0x6d, 0x80, 0x82, 0xa6, 0x56, 0xf2, 0xb6, 0xd4, 0x92, 0x20, 0x57, 0x76, 0x9c,
	0x22, 0xa7, 0x16, 0xb9, 0xf4, 0x71, 0xef, 0xa5, 0xc7, 0x1e, 0x02, 0xf4, 0xd2, 0x43, 0x6f, 0xbd,
	0xfb, 0x98, 0x7e, 0x01, 0x21, 0xc8, 0xad, 0x42, 0x3f, 0x44, 0xb1, 0x43, 0x52, 0x22, 0x69, 0xd1,
	0x72, 0x80, 0x14, 0x70, 0x6f, 0xe4, 0xec, 0xcc, 0x6f, 0x67, 0xe6, 0x37, 0x3b, 0xb3, 0x8b, 0x26,
	0x9a, 0xd4, 0x71, 0x2c, 0xa7, 0x68, 0x3b, 0x16, 0xb7, 0xf0, 0x28, 0x23, 0x1c, 0xbe, 0xb2, 0x8b,
	0x0d, 0xcb, 0x6a, 0x98, 0xa4, 0xa4, 0xdb, 0xb4, 0xa4, 0x33, 0x66, 0x71, 0x9d, 0x53, 0x8b, 0xb9,
	0x9e, 0x5e, 0x76, 0xb5, 0x41, 0xf9, 0x5e, 0x6b, 0xb7, 0x68, 0x58, 0xcd, 0x92, 0x4d, 0x98, 0xab,
	0xb3, 0x9a, 0x55, 0x72, 0x0f, 0x4a, 0xfb, 0x84, 0x51, 0x83, 0x94, 0x5a, 0x9c, 0x9a, 0xae, 0x30,
	0x6d, 0x10, 0x16, 0xb6, 0x2e, 0x51, 0x66, 0x98, 0xad, 0x1a, 0x09, 0x60, 0xd4, 0x10, 0x4c, 0xc3,
	0x6a, 0x58, 0x25, 0x10, 0xef, 0xb6, 0xea, 0xf0, 0x07, 0x3f, 0xf0, 0xe5, 0xab, 0x5f, 0x4a, 0xd8,
	0x55, 0xf8, 0xd8, 0x24, 0x5c, 0xf7, 0xd5, 0xc6, 0x9b, 0x3a, 0x37, 0xf6, 0xbc, 0x1f, 0xe5, 0xf7,
	0x14, 0x9a, 0xdc, 0x80, 0x10, 0xab, 0xc4, 0x75, 0xa9, 0xc5, 0xf0, 0xfb, 0x68, 0x74, 0xfb, 0xd0,
	0x26, 0x1b, 0x84, 0xeb, 0xb2, 0x94, 0x97, 0x0a, 0xe3, 0xe5, 0xc9, 0xa2, 0x6e, 0xd3, 0x62, 0x20,
	0xd4, 0x66, 0x8f, 0xda, 0xb9, 0xa1, 0xe7, 0xed, 0x9c, 0xd4, 0x69, 0xe7, 0x46, 0xae, 0x52, 0x66,
	0x52, 0x46, 0x2a, 0x5d, 0x1b, 0xfc, 0x11, 0x42, 0x9b, 0xbb, 0x5f, 0x12, 0x83, 0x03, 0x42, 0x0a,
	0x10, 0xce, 0x01, 0x42, 0x4f, 0xac, 0x65, 0x43, 0x18, 0x53, 0xc2, 0xb7, 0xab, 0x56, 0x93, 0x72,
	0xd2, 0xb4, 0xf9, 0x61, 0x25, 0x64, 0x8e, 0xef, 0xa2, 0x4c, 0xd5, 0x26, 0x86, 0x9c, 0x06, 0x98,
	0x8b, 0xc5, 0x20, 0xff, 0xc5, 0x88, 0xcf, 0x42, 0x45, 0x9b, 0x13, 0x90, 0x02, 0xce, 0xb5, 0x89,
	0x11, 0x82, 0x03, 0x00, 0xbc, 0x89, 0x86, 0xab, 0x5c, 0xe7, 0x2d, 0x57, 0xce, 0x00, 0xd4, 0xff,
	0x93, 0xa0, 0x40, 0x49, 0x93, 0x7d, 0xb0, 0x69, 0x17, 0xfe, 0x43, 0x70, 0x3e, 0x8c, 0xf2, 0x67,
	0x0a, 0xcd, 0xad, 0x31, 0x4e, 0x9c, 0xba, 0x6e, 0x90, 0x33, 0x9c, 0xc1, 0xad, 0x48, 0x06, 0xdf,
	0xe8, 0x85, 0xdd, 0xdf, 0xf9, 0x53, 0xa4, 0xf2, 0xd3, 0x58, 0x2a, 0x2f, 0x0f, 0xc4, 0x3c, 0x6d,
	0x4e, 0x8f, 0xd2, 0x68, 0xe6, 0x98, 0x37, 0xf8, 0x1a, 0x1a, 0xd9, 0x71, 0xea, 0x0f, 0xf4, 0x26,
	0x81, 0x6c, 0x8e, 0x69, 0x73, 0x9d, 0x76, 0x0e, 0xef, 0x3b, 0x75, 0x95, 0xe9, 0x4d, 0x12, 0x82,
	0x09, 0xd4, 0xf0, 0x36, 0x42, 0xb7, 0x2d, 0xd3, 0x24, 0x06, 0xb7, 0x1c, 0x57, 0x4e, 0xe5, 0xd3,
	0x85, 0xf1, 0xf2, 0x42, 0x9c, 0xf0, 0xae, 0x86, 0xb6, 0xe0, 0x3b, 0x36, 0x63, 0x74, 0x8d, 0x02,
	0x52, 0x42, 0x38, 0x78, 0x13, 0xa1, 0x0d, 0x71, 0x72, 0x2a, 0x2d, 0x93, 0xb8, 0x72, 0x1a, 0x50,
	0x67, 0x43, 0xa8, 0xc1, 0x9a, 0x47, 0x8d, 0xf0, 0x11, 0x0e, 0x9a, 0xea, 0x08, 0xfd, 0x2e, 0x60,
	0x0f, 0x02, 0xbf, 0x83, 0xd0, 0x96, 0x6e, 0x7c, 0x45, 0x78, 0x95, 0x3e, 0x26, 0x90, 0xcc, 0x49,
	0x6d, 0xa1, 0xd3, 0xce, 0x5d, 0xb0, 0x41, 0xaa, 0xba, 0xf4, 0x71, 0x38, 0xbc, 0x90, 0x32, 0x76,
	0xd1, 0x39, 0x2f, 0x8a, 0x15, 0xea, 0x10, 0x43, 0x34, 0x0f, 0xf9, 0x7f, 0x79, 0xa9, 0x30, 0x15,
	0x71, 0x28, 0x50, 0xd0, 0x6e, 0x3e, 0x7b, 0xba, 0x80, 0xab, 0xdc, 0x59, 0x65, 0xad, 0x66, 0xa1,
	0x2b, 0xbe, 0xd2, 0x69, 0xe7, 0xb2, 0x5e, 0x7b, 0x53, 0x6b, 0x01, 0x4c, 0x68, 0xbf, 0xf8, 0x0e,
	0x78, 0x19, 0x0d, 0x57, 0x6d, 0x9d, 0xad, 0xad, 0xc8, 0xc3, 0xe0, 0x2b, 0xf6, 0x4a, 0x44, 0x67,
	0x2a, 0xad, 0x05, 0xf1, 0xf9, 0x1a, 0x4a, 0x27, 0x8d, 0xb2, 0xc9, 0x15, 0x76, 0x66, 0x38, 0xed,
	0x85, 0x94, 0x1e, 0x14, 0xd2, 0x7f, 0x8e, 0xae, 0xcb, 0x28, 0x23, 0x5a, 0x0a, 0x90, 0x35, 0xe6,
	0x45, 0xc6, 0x0f, 0xed, 0xb0, 0x8b, 0xb0, 0x8e, 0x3f, 0x44, 0x13, 0x55, 0xee, 0x50, 0x7b, 0xc7,
	0xd4, 0xd9, 0xbd, 0x9a, 0x23, 0x8f, 0xe4, 0xa5, 0xc2, 0xa8, 0xb6, 0xd8, 0x69, 0xe7, 0x64, 0x57,
	0xc8, 0xd5, 0x7d, 0x53, 0x67, 0xea, 0x5e, 0xcd, 0x09, 0x59, 0x46, 0x2c, 0x94, 0xbf, 0x24, 0x34,
	0xdb, 0xe7, 0xc4, 0xe3, 0x77, 0x83, 0xb0, 0x7d, 0xf1, 0xda, 0x0a, 0xb0, 0x9d, 0x01, 0x67, 0x26,
	0x68, 0xad, 0x07, 0x28, 0x4b, 0x95, 0xb8, 0x2a, 0x5e, 0x47, 0xd3, 0x31, 0x91, 0xc7, 0x7b, 0x46,
	0xcb, 0x77, 0xda, 0xb9, 0x45, 0x3f, 0x15, 0xae, 0xb7, 0xa8, 0xd2, 0x5a, 0xb8, 0xa3, 0x1c, 0xb3,
	0xc4, 0x77, 0xd0, 0xd4, 0x1d, 0xd3, 0x3a, 0xd8, 0xb0, 0x18, 0xe5, 0x96, 0x23, 0xb0, 0xd2, 0x80,
	0xb5, 0x24, 0xd2, 0x5a, 0x37, 0xad, 0x03, 0xb5, 0xe9, 0x2d, 0xc5, 0x90, 0x62, 0x56, 0xca, 0x33,
	0x09, 0x2d, 0x9e, 0xd4, 0xe6, 0xce, 0x52, 0xd0, 0xca, 0x76, 0xac, 0x9f, 0xae, 0x53, 0x97, 0xe3,
	0x0f, 0xd0, 0x54, 0x44, 0xe8, 0xca, 0x12, 0x9c, 0xa6, 0xf9, 0x84, 0x91, 0x58, 0x89, 0xa9, 0x2b,
	0x7f, 0x48, 0x08, 0x47, 0x44, 0xab, 0xfb, 0x84, 0x71, 0x7c, 0x07, 0x8d, 0xc1, 0x07, 0x14, 0x9d,
	0x04, 0xe5, 0x3d, 0x05, 0x53, 0xab, 0x2b, 0xd5, 0xe4, 0x4e, 0x3b, 0x77, 0x9e, 0x88, 0x5f, 0x35,
	0x56, 0x8a, 0x3d, 0x53, 0xfc, 0x45, 0xec, 0x46, 0xe2, 0x4f, 0xc0, 0x24, 0xf7, 0xb4, 0xfc, 0x91,
	0x37, 0x05, 0xe5, 0x68, 0x72, 0x42, 0xe0, 0x51, 0x3c, 0x65, 0x0f, 0xcd, 0x1d, 0x77, 0x1f, 0x52,
	0xf3, 0x20, 0x56, 0xc7, 0xb0, 0x12, 0xe4, 0x67, 0x31, 0xc1, 0x01, 0x50, 0xaa, 0xf4, 0x33, 0x54,
	0x1e, 0x25, 0x35, 0x41, 0xd8, 0xed, 0x33, 0x34, 0xdf, 0x7f, 0x35, 0xd8, 0x31, 0x3f, 0x68, 0xb2,
	0x56, 0x92, 0x00, 0x94, 0xbf, 0x25, 0x74, 0xb1, 0xff, 0xda, 0xeb, 0x25, 0xeb, 0x5b, 0x29, 0xe9,
	0x1a, 0xe4, 0xd3, 0x36, 0x30, 0x06, 0x6d, 0xd9, 0x6f, 0xd5, 0x0a, 0x0d, 0xd6, 0xd5, 0x44, 0x26,
	0x13, 0xf6, 0x52, 0xbe, 0x97, 0x50, 0xee, 0x84, 0x70, 0x21, 0xdd, 0x34, 0xe9, 0xe0, 0x46, 0x58,
	0xbe, 0x34, 0xc8, 0x5f, 0x8f, 0xee, 0x13, 0xa1, 0x94, 0x5f, 0xba, 0x27, 0x64, 0xf5, 0x91, 0x6d,
	0x39, 0xfc, 0xb6, 0xc5, 0xea, 0xb4, 0x81, 0x37, 0xd0, 0xf8, 0x0a, 0x71, 0x39, 0x65, 0x70, 0xdd,
	0xf7, 0x27, 0xdf, 0x5b, 0xcf, 0x9e, 0x2e, 0x4c, 0x55, 0xb9, 0xb3, 0x4e, 0x58, 0xe1, 0xfa, 0xd5,
	0xf2, 0xb5, 0x9b, 0x6f, 0x8b, 0x4e, 0x7f, 0xa1, 0xd6, 0x53, 0x0c, 0xc5, 0x1f, 0xb6, 0xc7, 0xb7,
	0xd0, 0xc8, 0x5d, 0x9d, 0x93, 0x03, 0xfd, 0x10, 0x72, 0x3d, 0xa6, 0xbd, 0xd9, 0x17, 0x6a, 0xa6,
	0xe1, 0x29, 0x85, 0xa7, 0xaa, 0x6f, 0xa7, 0xfc, 0x90, 0x0a, 0xba, 0x55, 0x77, 0x28, 0xe2, 0xcf,
	0xd1, 0x98, 0xef, 0x75, 0xbd, 0xe1, 0xdf, 0x5f, 0x8f, 0x95, 0x7e, 0x38, 0x2c, 0x2d, 0xe7, 0x13,
	0x38, 0x4f, 0x40, 0xaa, 0x1a, 0x20, 0x8e, 0xd4, 0x4b, 0x80, 0x87, 0x6f, 0xa0, 0xf1, 0x2d, 0x43,
	0xb7, 0x57, 0xa8, 0x03, 0xc3, 0xdf, 0xf3, 0x7b, 0xa6, 0xd3, 0xce, 0x4d, 0xda, 0x86, 0x6e, 0x8b,
	0xc1, 0x06, 0x37, 0x80, 0x4a, 0x58, 0xab, 0x3b, 0xc9, 0xd2, 0xaf, 0x38, 0xc9, 0x32, 0xaf, 0x3a,
	0xc9, 0x96, 0x8b, 0x68, 0xac, 0x3b, 0x46, 0xf1, 0x28, 0xca, 0x68, 0x9b, 0xdb, 0xf7, 0xa6, 0x87,
	0xf0, 0x38, 0x1a, 0x59, 0x7b, 0x70, 0xb7, 0xb2, 0x5a, 0xad, 0x4e, 0x4b, 0x18, 0xa1, 0xe1, 0x55,
	0xef, 0x3b, 0x55, 0xfe, 0x35, 0xde, 0x0a, 0x6f, 0xd9, 0x74, 0xe7, 0x3a, 0x5e, 0x47, 0xb3, 0x9f,
	0x88, 0x7b, 0x5e, 0xf4, 0x50, 0xe2, 0xf8, 0x25, 0x3e, 0x9b, 0x3f, 0xa9, 0xa5, 0x88, 0xa2, 0x55,
	0x86, 0xae, 0x49, 0x78, 0x0d, 0x61, 0xf1, 0xfd, 0x1a, 0xc0, 0xca, 0x3f, 0xa6, 0xfb, 0xf8, 0x5b,
	0xc6, 0x95, 0xfe, 0xfe, 0x5e, 0x80, 0x2d, 0x84, 0x29, 0xac, 0x6e, 0xda, 0xf0, 0x4a, 0x3d, 0xa5,
	0xd7, 0xf7, 0xfb, 0x7a, 0x9d, 0x00, 0x99, 0xf4, 0xb2, 0xf3, 0xd0, 0xf0, 0x7d, 0x34, 0x1f, 0x11,
	0x6f, 0xda, 0xc4, 0xf9, 0xd8, 0xae, 0xe9, 0x9c, 0xe0, 0x13, 0xbb, 0x72, 0x36, 0xfa, 0xf0, 0x52,
	0x86, 0x0a, 0x52, 0xf6, 0x3b, 0xe9, 0xb7, 0x6f, 0x16, 0x9e, 0x4a, 0xf1, 0x67, 0x6f, 0xc6, 0x14,
	0x3d, 0x22, 0xdd, 0x20, 0x1c, 0x67, 0x6c, 0xcb, 0xe5, 0x78, 0xb8, 0x46, 0x4c, 0xc2, 0x09, 0x4e,
	0xdb, 0x2d, 0x9e, 0x7d, 0xaf, 0xf4, 0x75, 0x2f, 0xd3, 0xc5, 0x6d, 0xc2, 0x74, 0xc6, 0x9f, 0x44,
	0x64, 0xa2, 0x50, 0x5d, 0x5b, 0x37, 0xc8, 0x71, 0xf1, 0x13, 0xe5, 0x3c, 0x3c, 0xc1, 0x61, 0xbf,
	0x92, 0xdf, 0xd4, 0xdc, 0xd2, 0x72, 0x6a, 0xa7, 0x5c, 0x7e, 0x91, 0x4e, 0xea, 0xd3, 0x5e, 0x25,
	0xd5, 0xd0, 0x22, 0x24, 0x2a, 0xa1, 0xcf, 0x27, 0xe5, 0xf3, 0xca, 0xa9, 0xba, 0x58, 0x97, 0xab,
	0x87, 0xe8, 0xa2, 0xf8, 0x7e, 0xc5, 0x4d, 0x06, 0x3e, 0x26, 0x7d, 0xf6, 0x1e, 0xa2, 0x7c, 0xff,
	0xf5, 0x10, 0x8d, 0xa7, 0x6b, 0xbb, 0xfd, 0xf8, 0xfc, 0x59, 0xf0, 0xf9, 0x53, 0xe2, 0x18, 0xfa,
	0x77, 0x89, 0x5d, 0x0a, 0x11, 0xdb, 0x1b, 0x5f, 0x61, 0x8a, 0xaf, 0x6b, 0x13, 0x47, 0x2f, 0x97,
	0xa4, 0xe7, 0x2f, 0x97, 0xa4, 0x17, 0x2f, 0x97, 0xa4, 0x2d, 0x69, 0x77, 0x18, 0xc2, 0xbc, 0xf1,
	0x4f, 0x00, 0x00, 0x00, 0xff, 0xff, 0xfc, 0x43, 0x1c, 0x29, 0x5b, 0x12, 0x00, 0x00,
}
