// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: app.proto

/*
	Package netproto is a generated protocol buffer package.

	It is generated from these files:
		app.proto
		endpoint.proto
		copp.proto
		interface.proto
		ipsec.proto
		match.proto
		namespace.proto
		nat.proto
		network.proto
		port.proto
		qos.proto
		route.proto
		security.proto
		service.proto
		sgpolicy.proto
		secprofile.proto
		tenant.proto
		tunnel.proto
		tcp_proxy.proto
		vrf.proto

	It has these top-level messages:
		App
		AppSpec
		ALG
		DNS
		SIP
		RPC
		FTP
		TFTP
		RTSP
		ICMP
		AppStatus
		AppList
		AppEvent
		AppEventList
		Endpoint
		EndpointSpec
		EndpointStatus
		EndpointList
		EndpointEvent
		EndpointEventList
		ControlPlanePolicer
		ControlPlanePolicerSpec
		ControlPlanePolicerStatus
		ControlPlanePolicerList
		ControlPlanePolicerEvent
		ControlPlanePolicerEventList
		Interface
		PauseSpec
		InterfaceSpec
		InterfaceHostStatus
		InterfaceUplinkStatus
		TransceiverStatus
		InterfaceStatus
		InterfaceList
		InterfaceEvent
		InterfaceEventList
		IPSecPolicy
		IPSecPolicySpec
		IPSecRule
		IPSecPolicyStatus
		IPSecPolicyList
		IPSecPolicyEvent
		IPSecSAEncrypt
		IPSecSAEncryptSpec
		Protocol
		AuthAlgorithm
		EncryptionAlgorithm
		IPSecSAEncryptStatus
		IPSecSAEncryptList
		IPSecSAEncryptEvent
		IPSecSADecrypt
		IPSecSADecryptSpec
		IPSecSADecryptStatus
		IPSecSADecryptList
		IPSecSADecryptEvent
		IPSecSADecryptEventList
		MatchSelector
		AppConfig
		Namespace
		NamespaceSpec
		NamespaceStatus
		NamespaceList
		NamespaceEvent
		NamespaceEventList
		NatPool
		NatPoolSpec
		NatPoolStatus
		NatPoolList
		NatPoolEvent
		NatPoolEventList
		NatBinding
		NatBindingSpec
		NatBindingStatus
		NatBindingList
		NatBindingEvent
		NatBindingEventList
		NatPolicy
		NatPolicySpec
		NatRule
		NatPolicyStatus
		NatPolicyList
		NatPolicyEvent
		NatPolicyEventList
		ApiResponse
		Network
		NetworkSpec
		NetworkStatus
		NetworkList
		NetworkEvent
		NetworkEventList
		Port
		PortSpec
		PortStatus
		PortList
		PortEvent
		QosClass
		QosClassSpec
		PFC
		Scheduler
		UplinkClassMap
		Marking
		QosClassStatus
		QosClassList
		QosClassEvent
		QosClassEventList
		Route
		RouteSpec
		RouteStatus
		RouteList
		RouteEvent
		RouteEventList
		SecurityGroup
		SecurityGroupSpec
		SecurityGroupStatus
		SecurityGroupList
		SecurityGroupEvent
		SecurityGroupEventList
		ServiceBackend
		ServiceSpec
		HealthCheck
		ServiceStatus
		Service
		ServiceBackendSpec
		ServiceBackendStatus
		NetworkSecurityPolicy
		NetworkSecurityPolicySpec
		PolicyRule
		NetworkSecurityPolicyStatus
		NetworkSecurityPolicyList
		NetworkSecurityPolicyEvent
		NetworkSecurityPolicyEventList
		SecurityProfile
		SecurityProfileSpec
		Timeouts
		SecurityProfileStatus
		SecurityProfileList
		SecurityProfileEvent
		SecurityProfileEventList
		TenantStatus
		TenantSpec
		Tenant
		TenantList
		TenantEvent
		TenantEventList
		Tunnel
		TunnelSpec
		TunnelStatus
		TunnelList
		TunnelEvent
		TunnelEventList
		TCPProxyPolicy
		TCPProxyPolicySpec
		TCPProxyRule
		TCPProxyPolicyStatus
		TCPProxyPolicyList
		TCPProxyEvent
		TCPProxyEventList
		Vrf
		VrfSpec
		VrfStatus
		VrfList
		VrfEvent
		VrfEventList
*/
package netproto

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "google.golang.org/genproto/googleapis/api/annotations"
import _ "github.com/pensando/sw/venice/utils/apigen/annotations"
import _ "github.com/gogo/protobuf/gogoproto"
import api "github.com/pensando/sw/api"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// app object
type App struct {
	api.TypeMeta   `protobuf:"bytes,1,opt,name=TypeMeta,embedded=TypeMeta" json:",inline"`
	api.ObjectMeta `protobuf:"bytes,2,opt,name=ObjectMeta,embedded=ObjectMeta" json:"meta,omitempty"`
	Spec           AppSpec   `protobuf:"bytes,3,opt,name=Spec" json:"spec,omitempty"`
	Status         AppStatus `protobuf:"bytes,4,opt,name=Status" json:"status,omitempty"`
}

func (m *App) Reset()                    { *m = App{} }
func (m *App) String() string            { return proto.CompactTextString(m) }
func (*App) ProtoMessage()               {}
func (*App) Descriptor() ([]byte, []int) { return fileDescriptorApp, []int{0} }

func (m *App) GetSpec() AppSpec {
	if m != nil {
		return m.Spec
	}
	return AppSpec{}
}

func (m *App) GetStatus() AppStatus {
	if m != nil {
		return m.Status
	}
	return AppStatus{}
}

// app spec
type AppSpec struct {
	// List of protocol/ports. Valid combinations tcp/80 udp/10000-20000 icmp/5. For ICMP the port is interpreted as ICMP Code..
	ProtoPorts []string `protobuf:"bytes,1,rep,name=ProtoPorts" json:"proto-ports,omitempty"`
	// ALG specific configuration
	ALGType string `protobuf:"bytes,2,opt,name=ALGType,proto3" json:"alg-type,omitempty"`
	ALG     *ALG   `protobuf:"bytes,3,opt,name=ALG" json:"alg,omitempty"`
	// AppIdleTimeout is the app specific idle timeout. Specfied in parseable time, Eg: 10s, 1m30s or 1h45m15s and so on
	AppIdleTimeout string `protobuf:"bytes,4,opt,name=AppIdleTimeout,proto3" json:"app-idle-timeout,omitempty"`
}

func (m *AppSpec) Reset()                    { *m = AppSpec{} }
func (m *AppSpec) String() string            { return proto.CompactTextString(m) }
func (*AppSpec) ProtoMessage()               {}
func (*AppSpec) Descriptor() ([]byte, []int) { return fileDescriptorApp, []int{1} }

func (m *AppSpec) GetProtoPorts() []string {
	if m != nil {
		return m.ProtoPorts
	}
	return nil
}

func (m *AppSpec) GetALGType() string {
	if m != nil {
		return m.ALGType
	}
	return ""
}

func (m *AppSpec) GetALG() *ALG {
	if m != nil {
		return m.ALG
	}
	return nil
}

func (m *AppSpec) GetAppIdleTimeout() string {
	if m != nil {
		return m.AppIdleTimeout
	}
	return ""
}

type ALG struct {
	DNS    *DNS   `protobuf:"bytes,1,opt,name=DNS" json:"dns,omitempty"`
	SIP    *SIP   `protobuf:"bytes,2,opt,name=SIP" json:"sip,omitempty"`
	SUNRPC []*RPC `protobuf:"bytes,3,rep,name=SUNRPC" json:"sunrpc,omitempty"`
	FTP    *FTP   `protobuf:"bytes,4,opt,name=FTP" json:"ftp,omitempty"`
	MSRPC  []*RPC `protobuf:"bytes,5,rep,name=MSRPC" json:"msrpc,omitempty"`
	TFTP   *TFTP  `protobuf:"bytes,6,opt,name=TFTP" json:"tftp,omitempty"`
	RTSP   *RTSP  `protobuf:"bytes,7,opt,name=RTSP" json:"rtsp,omitempty"`
	ICMP   *ICMP  `protobuf:"bytes,8,opt,name=ICMP" json:"icmp,omitempty"`
}

func (m *ALG) Reset()                    { *m = ALG{} }
func (m *ALG) String() string            { return proto.CompactTextString(m) }
func (*ALG) ProtoMessage()               {}
func (*ALG) Descriptor() ([]byte, []int) { return fileDescriptorApp, []int{2} }

func (m *ALG) GetDNS() *DNS {
	if m != nil {
		return m.DNS
	}
	return nil
}

func (m *ALG) GetSIP() *SIP {
	if m != nil {
		return m.SIP
	}
	return nil
}

func (m *ALG) GetSUNRPC() []*RPC {
	if m != nil {
		return m.SUNRPC
	}
	return nil
}

func (m *ALG) GetFTP() *FTP {
	if m != nil {
		return m.FTP
	}
	return nil
}

func (m *ALG) GetMSRPC() []*RPC {
	if m != nil {
		return m.MSRPC
	}
	return nil
}

func (m *ALG) GetTFTP() *TFTP {
	if m != nil {
		return m.TFTP
	}
	return nil
}

func (m *ALG) GetRTSP() *RTSP {
	if m != nil {
		return m.RTSP
	}
	return nil
}

func (m *ALG) GetICMP() *ICMP {
	if m != nil {
		return m.ICMP
	}
	return nil
}

// DNS ALG configuration
type DNS struct {
	// Drop DNS Packets for multiple questions
	DropMultiQuestionPackets bool `protobuf:"varint,1,opt,name=DropMultiQuestionPackets,proto3" json:"drop-multi-question-packets,omitempty"`
	// Drop packets whose domain name > 255
	DropLargeDomainPackets bool `protobuf:"varint,2,opt,name=DropLargeDomainPackets,proto3" json:"drop-large-domain-packets,omitempty"`
	// Drop packets whose labels length > 63
	DropLongLabelPackets bool `protobuf:"varint,3,opt,name=DropLongLabelPackets,proto3" json:"drop-long-label-packets,omitempty"`
	// Drop packets for num zones > 1
	DropMultiZonePackets bool `protobuf:"varint,4,opt,name=DropMultiZonePackets,proto3" json:"drop-multi-zone-packets,omitempty"`
	// Maximum allowed message length
	MaxMessageLength uint32 `protobuf:"varint,5,opt,name=MaxMessageLength,proto3" json:"max-msg-length,omitempty"`
	// Timeout for query response in seconds, minutes, eg 1m, 45s
	QueryResponseTimeout string `protobuf:"bytes,6,opt,name=QueryResponseTimeout,proto3" json:"query-response-timeout,omitempty"`
}

func (m *DNS) Reset()                    { *m = DNS{} }
func (m *DNS) String() string            { return proto.CompactTextString(m) }
func (*DNS) ProtoMessage()               {}
func (*DNS) Descriptor() ([]byte, []int) { return fileDescriptorApp, []int{3} }

func (m *DNS) GetDropMultiQuestionPackets() bool {
	if m != nil {
		return m.DropMultiQuestionPackets
	}
	return false
}

func (m *DNS) GetDropLargeDomainPackets() bool {
	if m != nil {
		return m.DropLargeDomainPackets
	}
	return false
}

func (m *DNS) GetDropLongLabelPackets() bool {
	if m != nil {
		return m.DropLongLabelPackets
	}
	return false
}

func (m *DNS) GetDropMultiZonePackets() bool {
	if m != nil {
		return m.DropMultiZonePackets
	}
	return false
}

func (m *DNS) GetMaxMessageLength() uint32 {
	if m != nil {
		return m.MaxMessageLength
	}
	return 0
}

func (m *DNS) GetQueryResponseTimeout() string {
	if m != nil {
		return m.QueryResponseTimeout
	}
	return ""
}

// SIP ALG configuration
type SIP struct {
	// Maximum timeout for a call to remain active without any media
	MediaInactivityTimeout string `protobuf:"bytes,1,opt,name=MediaInactivityTimeout,proto3" json:"media-inactivity-timeout,omitempty"`
	// Maximum length of call in hours, minutes, seconds, eg 1h, 15m, 45s
	MaxCallDuration string `protobuf:"bytes,2,opt,name=MaxCallDuration,proto3" json:"max-call-duration,omitempty"`
	// Timeout for INVITE transaction in minutes, seconds, eg 1m, 45s
	CTimeout string `protobuf:"bytes,3,opt,name=CTimeout,proto3" json:"c-timeout,omitempty"`
	// Timeout for T1 Interval in minutes, seconds, eg 1m, 45s
	T1Timeout string `protobuf:"bytes,4,opt,name=T1Timeout,proto3" json:"t1-timeout,omitempty"`
	// Timeout for T4 interval in minutes, seconds, eg 1m, 45s
	T4Timeout string `protobuf:"bytes,5,opt,name=T4Timeout,proto3" json:"t4-timeout,omitempty"`
	// DSCP traffic classification. 0 - 63
	DSCPCodePoint uint32 `protobuf:"varint,6,opt,name=DSCPCodePoint,proto3" json:"dscp-code-point,omitempty"`
}

func (m *SIP) Reset()                    { *m = SIP{} }
func (m *SIP) String() string            { return proto.CompactTextString(m) }
func (*SIP) ProtoMessage()               {}
func (*SIP) Descriptor() ([]byte, []int) { return fileDescriptorApp, []int{4} }

func (m *SIP) GetMediaInactivityTimeout() string {
	if m != nil {
		return m.MediaInactivityTimeout
	}
	return ""
}

func (m *SIP) GetMaxCallDuration() string {
	if m != nil {
		return m.MaxCallDuration
	}
	return ""
}

func (m *SIP) GetCTimeout() string {
	if m != nil {
		return m.CTimeout
	}
	return ""
}

func (m *SIP) GetT1Timeout() string {
	if m != nil {
		return m.T1Timeout
	}
	return ""
}

func (m *SIP) GetT4Timeout() string {
	if m != nil {
		return m.T4Timeout
	}
	return ""
}

func (m *SIP) GetDSCPCodePoint() uint32 {
	if m != nil {
		return m.DSCPCodePoint
	}
	return 0
}

// RPC ALG configuration for MSRPC and SunRPC
type RPC struct {
	// RPC Program identifier
	ProgramID string `protobuf:"bytes,1,opt,name=ProgramID,proto3" json:"program-id,omitempty"`
	// Timeout is the timeout for the specific program-id
	ProgramIDTimeout string `protobuf:"bytes,2,opt,name=ProgramIDTimeout,proto3" json:"program-id-timeout,omitempty"`
}

func (m *RPC) Reset()                    { *m = RPC{} }
func (m *RPC) String() string            { return proto.CompactTextString(m) }
func (*RPC) ProtoMessage()               {}
func (*RPC) Descriptor() ([]byte, []int) { return fileDescriptorApp, []int{5} }

func (m *RPC) GetProgramID() string {
	if m != nil {
		return m.ProgramID
	}
	return ""
}

func (m *RPC) GetProgramIDTimeout() string {
	if m != nil {
		return m.ProgramIDTimeout
	}
	return ""
}

// FTP ALG configuration
type FTP struct {
	// Allow FTP packets with mismatched IP header address and payload
	AllowMismatchIPAddresses bool `protobuf:"varint,1,opt,name=AllowMismatchIPAddresses,proto3" json:"allow-mismatch-ip-addresses,omitempty"`
}

func (m *FTP) Reset()                    { *m = FTP{} }
func (m *FTP) String() string            { return proto.CompactTextString(m) }
func (*FTP) ProtoMessage()               {}
func (*FTP) Descriptor() ([]byte, []int) { return fileDescriptorApp, []int{6} }

func (m *FTP) GetAllowMismatchIPAddresses() bool {
	if m != nil {
		return m.AllowMismatchIPAddresses
	}
	return false
}

// TFTP ALG configuration
type TFTP struct {
}

func (m *TFTP) Reset()                    { *m = TFTP{} }
func (m *TFTP) String() string            { return proto.CompactTextString(m) }
func (*TFTP) ProtoMessage()               {}
func (*TFTP) Descriptor() ([]byte, []int) { return fileDescriptorApp, []int{7} }

// RTSP ALG configuration
type RTSP struct {
}

func (m *RTSP) Reset()                    { *m = RTSP{} }
func (m *RTSP) String() string            { return proto.CompactTextString(m) }
func (*RTSP) ProtoMessage()               {}
func (*RTSP) Descriptor() ([]byte, []int) { return fileDescriptorApp, []int{8} }

// ICMP ALG configuration
type ICMP struct {
	// ICMP Type
	Type uint32 `protobuf:"varint,1,opt,name=Type,proto3" json:"type,omitempty"`
	// ICMP Code is sub-command for a given ICMP Type
	Code uint32 `protobuf:"varint,2,opt,name=Code,proto3" json:"code,omitempty"`
}

func (m *ICMP) Reset()                    { *m = ICMP{} }
func (m *ICMP) String() string            { return proto.CompactTextString(m) }
func (*ICMP) ProtoMessage()               {}
func (*ICMP) Descriptor() ([]byte, []int) { return fileDescriptorApp, []int{9} }

func (m *ICMP) GetType() uint32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *ICMP) GetCode() uint32 {
	if m != nil {
		return m.Code
	}
	return 0
}

// app status
type AppStatus struct {
	AppID uint64 `protobuf:"varint,3,opt,name=AppID,proto3" json:"app-id,omitempty"`
}

func (m *AppStatus) Reset()                    { *m = AppStatus{} }
func (m *AppStatus) String() string            { return proto.CompactTextString(m) }
func (*AppStatus) ProtoMessage()               {}
func (*AppStatus) Descriptor() ([]byte, []int) { return fileDescriptorApp, []int{10} }

func (m *AppStatus) GetAppID() uint64 {
	if m != nil {
		return m.AppID
	}
	return 0
}

// list of apps
type AppList struct {
	Apps []*App `protobuf:"bytes,1,rep,name=apps" json:"apps,omitempty"`
}

func (m *AppList) Reset()                    { *m = AppList{} }
func (m *AppList) String() string            { return proto.CompactTextString(m) }
func (*AppList) ProtoMessage()               {}
func (*AppList) Descriptor() ([]byte, []int) { return fileDescriptorApp, []int{11} }

func (m *AppList) GetApps() []*App {
	if m != nil {
		return m.Apps
	}
	return nil
}

// app watch event
type AppEvent struct {
	EventType api.EventType `protobuf:"varint,1,opt,name=EventType,proto3,enum=api.EventType" json:"event-type,omitempty"`
	App       App           `protobuf:"bytes,2,opt,name=App" json:"app,omitempty"`
}

func (m *AppEvent) Reset()                    { *m = AppEvent{} }
func (m *AppEvent) String() string            { return proto.CompactTextString(m) }
func (*AppEvent) ProtoMessage()               {}
func (*AppEvent) Descriptor() ([]byte, []int) { return fileDescriptorApp, []int{12} }

func (m *AppEvent) GetEventType() api.EventType {
	if m != nil {
		return m.EventType
	}
	return api.EventType_CreateEvent
}

func (m *AppEvent) GetApp() App {
	if m != nil {
		return m.App
	}
	return App{}
}

// app watch events batched
type AppEventList struct {
	AppEvents []*AppEvent `protobuf:"bytes,1,rep,name=AppEvents" json:"AppEvents,omitempty"`
}

func (m *AppEventList) Reset()                    { *m = AppEventList{} }
func (m *AppEventList) String() string            { return proto.CompactTextString(m) }
func (*AppEventList) ProtoMessage()               {}
func (*AppEventList) Descriptor() ([]byte, []int) { return fileDescriptorApp, []int{13} }

func (m *AppEventList) GetAppEvents() []*AppEvent {
	if m != nil {
		return m.AppEvents
	}
	return nil
}

func init() {
	proto.RegisterType((*App)(nil), "netproto.App")
	proto.RegisterType((*AppSpec)(nil), "netproto.AppSpec")
	proto.RegisterType((*ALG)(nil), "netproto.ALG")
	proto.RegisterType((*DNS)(nil), "netproto.DNS")
	proto.RegisterType((*SIP)(nil), "netproto.SIP")
	proto.RegisterType((*RPC)(nil), "netproto.RPC")
	proto.RegisterType((*FTP)(nil), "netproto.FTP")
	proto.RegisterType((*TFTP)(nil), "netproto.TFTP")
	proto.RegisterType((*RTSP)(nil), "netproto.RTSP")
	proto.RegisterType((*ICMP)(nil), "netproto.ICMP")
	proto.RegisterType((*AppStatus)(nil), "netproto.AppStatus")
	proto.RegisterType((*AppList)(nil), "netproto.AppList")
	proto.RegisterType((*AppEvent)(nil), "netproto.AppEvent")
	proto.RegisterType((*AppEventList)(nil), "netproto.AppEventList")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for AppApi service

type AppApiClient interface {
	GetApp(ctx context.Context, in *api.ObjectMeta, opts ...grpc.CallOption) (*App, error)
	ListApps(ctx context.Context, in *api.ObjectMeta, opts ...grpc.CallOption) (*AppList, error)
	WatchApps(ctx context.Context, in *api.ObjectMeta, opts ...grpc.CallOption) (AppApi_WatchAppsClient, error)
	UpdateApp(ctx context.Context, in *App, opts ...grpc.CallOption) (*App, error)
	AppOperUpdate(ctx context.Context, opts ...grpc.CallOption) (AppApi_AppOperUpdateClient, error)
}

type appApiClient struct {
	cc *grpc.ClientConn
}

func NewAppApiClient(cc *grpc.ClientConn) AppApiClient {
	return &appApiClient{cc}
}

func (c *appApiClient) GetApp(ctx context.Context, in *api.ObjectMeta, opts ...grpc.CallOption) (*App, error) {
	out := new(App)
	err := grpc.Invoke(ctx, "/netproto.AppApi/GetApp", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *appApiClient) ListApps(ctx context.Context, in *api.ObjectMeta, opts ...grpc.CallOption) (*AppList, error) {
	out := new(AppList)
	err := grpc.Invoke(ctx, "/netproto.AppApi/ListApps", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *appApiClient) WatchApps(ctx context.Context, in *api.ObjectMeta, opts ...grpc.CallOption) (AppApi_WatchAppsClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_AppApi_serviceDesc.Streams[0], c.cc, "/netproto.AppApi/WatchApps", opts...)
	if err != nil {
		return nil, err
	}
	x := &appApiWatchAppsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type AppApi_WatchAppsClient interface {
	Recv() (*AppEventList, error)
	grpc.ClientStream
}

type appApiWatchAppsClient struct {
	grpc.ClientStream
}

func (x *appApiWatchAppsClient) Recv() (*AppEventList, error) {
	m := new(AppEventList)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *appApiClient) UpdateApp(ctx context.Context, in *App, opts ...grpc.CallOption) (*App, error) {
	out := new(App)
	err := grpc.Invoke(ctx, "/netproto.AppApi/UpdateApp", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *appApiClient) AppOperUpdate(ctx context.Context, opts ...grpc.CallOption) (AppApi_AppOperUpdateClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_AppApi_serviceDesc.Streams[1], c.cc, "/netproto.AppApi/AppOperUpdate", opts...)
	if err != nil {
		return nil, err
	}
	x := &appApiAppOperUpdateClient{stream}
	return x, nil
}

type AppApi_AppOperUpdateClient interface {
	Send(*AppEvent) error
	CloseAndRecv() (*api.TypeMeta, error)
	grpc.ClientStream
}

type appApiAppOperUpdateClient struct {
	grpc.ClientStream
}

func (x *appApiAppOperUpdateClient) Send(m *AppEvent) error {
	return x.ClientStream.SendMsg(m)
}

func (x *appApiAppOperUpdateClient) CloseAndRecv() (*api.TypeMeta, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(api.TypeMeta)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for AppApi service

type AppApiServer interface {
	GetApp(context.Context, *api.ObjectMeta) (*App, error)
	ListApps(context.Context, *api.ObjectMeta) (*AppList, error)
	WatchApps(*api.ObjectMeta, AppApi_WatchAppsServer) error
	UpdateApp(context.Context, *App) (*App, error)
	AppOperUpdate(AppApi_AppOperUpdateServer) error
}

func RegisterAppApiServer(s *grpc.Server, srv AppApiServer) {
	s.RegisterService(&_AppApi_serviceDesc, srv)
}

func _AppApi_GetApp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(api.ObjectMeta)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AppApiServer).GetApp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/netproto.AppApi/GetApp",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AppApiServer).GetApp(ctx, req.(*api.ObjectMeta))
	}
	return interceptor(ctx, in, info, handler)
}

func _AppApi_ListApps_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(api.ObjectMeta)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AppApiServer).ListApps(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/netproto.AppApi/ListApps",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AppApiServer).ListApps(ctx, req.(*api.ObjectMeta))
	}
	return interceptor(ctx, in, info, handler)
}

func _AppApi_WatchApps_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(api.ObjectMeta)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AppApiServer).WatchApps(m, &appApiWatchAppsServer{stream})
}

type AppApi_WatchAppsServer interface {
	Send(*AppEventList) error
	grpc.ServerStream
}

type appApiWatchAppsServer struct {
	grpc.ServerStream
}

func (x *appApiWatchAppsServer) Send(m *AppEventList) error {
	return x.ServerStream.SendMsg(m)
}

func _AppApi_UpdateApp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(App)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AppApiServer).UpdateApp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/netproto.AppApi/UpdateApp",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AppApiServer).UpdateApp(ctx, req.(*App))
	}
	return interceptor(ctx, in, info, handler)
}

func _AppApi_AppOperUpdate_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(AppApiServer).AppOperUpdate(&appApiAppOperUpdateServer{stream})
}

type AppApi_AppOperUpdateServer interface {
	SendAndClose(*api.TypeMeta) error
	Recv() (*AppEvent, error)
	grpc.ServerStream
}

type appApiAppOperUpdateServer struct {
	grpc.ServerStream
}

func (x *appApiAppOperUpdateServer) SendAndClose(m *api.TypeMeta) error {
	return x.ServerStream.SendMsg(m)
}

func (x *appApiAppOperUpdateServer) Recv() (*AppEvent, error) {
	m := new(AppEvent)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _AppApi_serviceDesc = grpc.ServiceDesc{
	ServiceName: "netproto.AppApi",
	HandlerType: (*AppApiServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetApp",
			Handler:    _AppApi_GetApp_Handler,
		},
		{
			MethodName: "ListApps",
			Handler:    _AppApi_ListApps_Handler,
		},
		{
			MethodName: "UpdateApp",
			Handler:    _AppApi_UpdateApp_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "WatchApps",
			Handler:       _AppApi_WatchApps_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "AppOperUpdate",
			Handler:       _AppApi_AppOperUpdate_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "app.proto",
}

func (m *App) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *App) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintApp(dAtA, i, uint64(m.TypeMeta.Size()))
	n1, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n1
	dAtA[i] = 0x12
	i++
	i = encodeVarintApp(dAtA, i, uint64(m.ObjectMeta.Size()))
	n2, err := m.ObjectMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n2
	dAtA[i] = 0x1a
	i++
	i = encodeVarintApp(dAtA, i, uint64(m.Spec.Size()))
	n3, err := m.Spec.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n3
	dAtA[i] = 0x22
	i++
	i = encodeVarintApp(dAtA, i, uint64(m.Status.Size()))
	n4, err := m.Status.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n4
	return i, nil
}

func (m *AppSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ProtoPorts) > 0 {
		for _, s := range m.ProtoPorts {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.ALGType) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApp(dAtA, i, uint64(len(m.ALGType)))
		i += copy(dAtA[i:], m.ALGType)
	}
	if m.ALG != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintApp(dAtA, i, uint64(m.ALG.Size()))
		n5, err := m.ALG.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if len(m.AppIdleTimeout) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintApp(dAtA, i, uint64(len(m.AppIdleTimeout)))
		i += copy(dAtA[i:], m.AppIdleTimeout)
	}
	return i, nil
}

func (m *ALG) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ALG) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.DNS != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApp(dAtA, i, uint64(m.DNS.Size()))
		n6, err := m.DNS.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.SIP != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApp(dAtA, i, uint64(m.SIP.Size()))
		n7, err := m.SIP.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if len(m.SUNRPC) > 0 {
		for _, msg := range m.SUNRPC {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintApp(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.FTP != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintApp(dAtA, i, uint64(m.FTP.Size()))
		n8, err := m.FTP.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if len(m.MSRPC) > 0 {
		for _, msg := range m.MSRPC {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintApp(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.TFTP != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintApp(dAtA, i, uint64(m.TFTP.Size()))
		n9, err := m.TFTP.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.RTSP != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintApp(dAtA, i, uint64(m.RTSP.Size()))
		n10, err := m.RTSP.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.ICMP != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintApp(dAtA, i, uint64(m.ICMP.Size()))
		n11, err := m.ICMP.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	return i, nil
}

func (m *DNS) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DNS) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.DropMultiQuestionPackets {
		dAtA[i] = 0x8
		i++
		if m.DropMultiQuestionPackets {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DropLargeDomainPackets {
		dAtA[i] = 0x10
		i++
		if m.DropLargeDomainPackets {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DropLongLabelPackets {
		dAtA[i] = 0x18
		i++
		if m.DropLongLabelPackets {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DropMultiZonePackets {
		dAtA[i] = 0x20
		i++
		if m.DropMultiZonePackets {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.MaxMessageLength != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintApp(dAtA, i, uint64(m.MaxMessageLength))
	}
	if len(m.QueryResponseTimeout) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintApp(dAtA, i, uint64(len(m.QueryResponseTimeout)))
		i += copy(dAtA[i:], m.QueryResponseTimeout)
	}
	return i, nil
}

func (m *SIP) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SIP) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.MediaInactivityTimeout) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApp(dAtA, i, uint64(len(m.MediaInactivityTimeout)))
		i += copy(dAtA[i:], m.MediaInactivityTimeout)
	}
	if len(m.MaxCallDuration) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApp(dAtA, i, uint64(len(m.MaxCallDuration)))
		i += copy(dAtA[i:], m.MaxCallDuration)
	}
	if len(m.CTimeout) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintApp(dAtA, i, uint64(len(m.CTimeout)))
		i += copy(dAtA[i:], m.CTimeout)
	}
	if len(m.T1Timeout) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintApp(dAtA, i, uint64(len(m.T1Timeout)))
		i += copy(dAtA[i:], m.T1Timeout)
	}
	if len(m.T4Timeout) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintApp(dAtA, i, uint64(len(m.T4Timeout)))
		i += copy(dAtA[i:], m.T4Timeout)
	}
	if m.DSCPCodePoint != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintApp(dAtA, i, uint64(m.DSCPCodePoint))
	}
	return i, nil
}

func (m *RPC) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RPC) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ProgramID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApp(dAtA, i, uint64(len(m.ProgramID)))
		i += copy(dAtA[i:], m.ProgramID)
	}
	if len(m.ProgramIDTimeout) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApp(dAtA, i, uint64(len(m.ProgramIDTimeout)))
		i += copy(dAtA[i:], m.ProgramIDTimeout)
	}
	return i, nil
}

func (m *FTP) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FTP) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.AllowMismatchIPAddresses {
		dAtA[i] = 0x8
		i++
		if m.AllowMismatchIPAddresses {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *TFTP) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TFTP) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *RTSP) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RTSP) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *ICMP) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ICMP) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApp(dAtA, i, uint64(m.Type))
	}
	if m.Code != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApp(dAtA, i, uint64(m.Code))
	}
	return i, nil
}

func (m *AppStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.AppID != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintApp(dAtA, i, uint64(m.AppID))
	}
	return i, nil
}

func (m *AppList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Apps) > 0 {
		for _, msg := range m.Apps {
			dAtA[i] = 0xa
			i++
			i = encodeVarintApp(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *AppEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppEvent) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.EventType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApp(dAtA, i, uint64(m.EventType))
	}
	dAtA[i] = 0x12
	i++
	i = encodeVarintApp(dAtA, i, uint64(m.App.Size()))
	n12, err := m.App.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n12
	return i, nil
}

func (m *AppEventList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppEventList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AppEvents) > 0 {
		for _, msg := range m.AppEvents {
			dAtA[i] = 0xa
			i++
			i = encodeVarintApp(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func encodeVarintApp(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *App) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovApp(uint64(l))
	l = m.ObjectMeta.Size()
	n += 1 + l + sovApp(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovApp(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovApp(uint64(l))
	return n
}

func (m *AppSpec) Size() (n int) {
	var l int
	_ = l
	if len(m.ProtoPorts) > 0 {
		for _, s := range m.ProtoPorts {
			l = len(s)
			n += 1 + l + sovApp(uint64(l))
		}
	}
	l = len(m.ALGType)
	if l > 0 {
		n += 1 + l + sovApp(uint64(l))
	}
	if m.ALG != nil {
		l = m.ALG.Size()
		n += 1 + l + sovApp(uint64(l))
	}
	l = len(m.AppIdleTimeout)
	if l > 0 {
		n += 1 + l + sovApp(uint64(l))
	}
	return n
}

func (m *ALG) Size() (n int) {
	var l int
	_ = l
	if m.DNS != nil {
		l = m.DNS.Size()
		n += 1 + l + sovApp(uint64(l))
	}
	if m.SIP != nil {
		l = m.SIP.Size()
		n += 1 + l + sovApp(uint64(l))
	}
	if len(m.SUNRPC) > 0 {
		for _, e := range m.SUNRPC {
			l = e.Size()
			n += 1 + l + sovApp(uint64(l))
		}
	}
	if m.FTP != nil {
		l = m.FTP.Size()
		n += 1 + l + sovApp(uint64(l))
	}
	if len(m.MSRPC) > 0 {
		for _, e := range m.MSRPC {
			l = e.Size()
			n += 1 + l + sovApp(uint64(l))
		}
	}
	if m.TFTP != nil {
		l = m.TFTP.Size()
		n += 1 + l + sovApp(uint64(l))
	}
	if m.RTSP != nil {
		l = m.RTSP.Size()
		n += 1 + l + sovApp(uint64(l))
	}
	if m.ICMP != nil {
		l = m.ICMP.Size()
		n += 1 + l + sovApp(uint64(l))
	}
	return n
}

func (m *DNS) Size() (n int) {
	var l int
	_ = l
	if m.DropMultiQuestionPackets {
		n += 2
	}
	if m.DropLargeDomainPackets {
		n += 2
	}
	if m.DropLongLabelPackets {
		n += 2
	}
	if m.DropMultiZonePackets {
		n += 2
	}
	if m.MaxMessageLength != 0 {
		n += 1 + sovApp(uint64(m.MaxMessageLength))
	}
	l = len(m.QueryResponseTimeout)
	if l > 0 {
		n += 1 + l + sovApp(uint64(l))
	}
	return n
}

func (m *SIP) Size() (n int) {
	var l int
	_ = l
	l = len(m.MediaInactivityTimeout)
	if l > 0 {
		n += 1 + l + sovApp(uint64(l))
	}
	l = len(m.MaxCallDuration)
	if l > 0 {
		n += 1 + l + sovApp(uint64(l))
	}
	l = len(m.CTimeout)
	if l > 0 {
		n += 1 + l + sovApp(uint64(l))
	}
	l = len(m.T1Timeout)
	if l > 0 {
		n += 1 + l + sovApp(uint64(l))
	}
	l = len(m.T4Timeout)
	if l > 0 {
		n += 1 + l + sovApp(uint64(l))
	}
	if m.DSCPCodePoint != 0 {
		n += 1 + sovApp(uint64(m.DSCPCodePoint))
	}
	return n
}

func (m *RPC) Size() (n int) {
	var l int
	_ = l
	l = len(m.ProgramID)
	if l > 0 {
		n += 1 + l + sovApp(uint64(l))
	}
	l = len(m.ProgramIDTimeout)
	if l > 0 {
		n += 1 + l + sovApp(uint64(l))
	}
	return n
}

func (m *FTP) Size() (n int) {
	var l int
	_ = l
	if m.AllowMismatchIPAddresses {
		n += 2
	}
	return n
}

func (m *TFTP) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *RTSP) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *ICMP) Size() (n int) {
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovApp(uint64(m.Type))
	}
	if m.Code != 0 {
		n += 1 + sovApp(uint64(m.Code))
	}
	return n
}

func (m *AppStatus) Size() (n int) {
	var l int
	_ = l
	if m.AppID != 0 {
		n += 1 + sovApp(uint64(m.AppID))
	}
	return n
}

func (m *AppList) Size() (n int) {
	var l int
	_ = l
	if len(m.Apps) > 0 {
		for _, e := range m.Apps {
			l = e.Size()
			n += 1 + l + sovApp(uint64(l))
		}
	}
	return n
}

func (m *AppEvent) Size() (n int) {
	var l int
	_ = l
	if m.EventType != 0 {
		n += 1 + sovApp(uint64(m.EventType))
	}
	l = m.App.Size()
	n += 1 + l + sovApp(uint64(l))
	return n
}

func (m *AppEventList) Size() (n int) {
	var l int
	_ = l
	if len(m.AppEvents) > 0 {
		for _, e := range m.AppEvents {
			l = e.Size()
			n += 1 + l + sovApp(uint64(l))
		}
	}
	return n
}

func sovApp(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozApp(x uint64) (n int) {
	return sovApp(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *App) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: App: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: App: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProtoPorts", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProtoPorts = append(m.ProtoPorts, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ALGType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ALGType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ALG", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ALG == nil {
				m.ALG = &ALG{}
			}
			if err := m.ALG.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppIdleTimeout", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppIdleTimeout = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ALG) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ALG: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ALG: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DNS", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DNS == nil {
				m.DNS = &DNS{}
			}
			if err := m.DNS.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SIP", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SIP == nil {
				m.SIP = &SIP{}
			}
			if err := m.SIP.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SUNRPC", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SUNRPC = append(m.SUNRPC, &RPC{})
			if err := m.SUNRPC[len(m.SUNRPC)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FTP", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FTP == nil {
				m.FTP = &FTP{}
			}
			if err := m.FTP.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MSRPC", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MSRPC = append(m.MSRPC, &RPC{})
			if err := m.MSRPC[len(m.MSRPC)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TFTP", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TFTP == nil {
				m.TFTP = &TFTP{}
			}
			if err := m.TFTP.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RTSP", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RTSP == nil {
				m.RTSP = &RTSP{}
			}
			if err := m.RTSP.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ICMP", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ICMP == nil {
				m.ICMP = &ICMP{}
			}
			if err := m.ICMP.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DNS) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DNS: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DNS: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropMultiQuestionPackets", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DropMultiQuestionPackets = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropLargeDomainPackets", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DropLargeDomainPackets = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropLongLabelPackets", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DropLongLabelPackets = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropMultiZonePackets", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DropMultiZonePackets = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxMessageLength", wireType)
			}
			m.MaxMessageLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxMessageLength |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueryResponseTimeout", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QueryResponseTimeout = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SIP) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SIP: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SIP: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MediaInactivityTimeout", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MediaInactivityTimeout = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxCallDuration", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MaxCallDuration = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CTimeout", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CTimeout = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field T1Timeout", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.T1Timeout = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field T4Timeout", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.T4Timeout = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DSCPCodePoint", wireType)
			}
			m.DSCPCodePoint = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DSCPCodePoint |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RPC) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RPC: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RPC: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProgramID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProgramID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProgramIDTimeout", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProgramIDTimeout = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FTP) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FTP: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FTP: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowMismatchIPAddresses", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AllowMismatchIPAddresses = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipApp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TFTP) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TFTP: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TFTP: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipApp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RTSP) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RTSP: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RTSP: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipApp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ICMP) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ICMP: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ICMP: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppID", wireType)
			}
			m.AppID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AppID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Apps", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Apps = append(m.Apps, &App{})
			if err := m.Apps[len(m.Apps)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventType", wireType)
			}
			m.EventType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EventType |= (api.EventType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field App", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.App.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppEventList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppEventList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppEventList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppEvents", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppEvents = append(m.AppEvents, &AppEvent{})
			if err := m.AppEvents[len(m.AppEvents)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipApp(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowApp
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowApp
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowApp
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthApp
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowApp
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipApp(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthApp = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowApp   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("app.proto", fileDescriptorApp) }

var fileDescriptorApp = []byte{
	// 1400 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x74, 0x57, 0x4f, 0x73, 0xd3, 0x46,
	0x14, 0x8f, 0x62, 0xc7, 0xb1, 0xb7, 0x4d, 0x48, 0x97, 0x90, 0x1a, 0x43, 0x93, 0x20, 0x4a, 0x27,
	0x05, 0x14, 0x07, 0xca, 0x40, 0x87, 0x29, 0x6d, 0xed, 0x98, 0x64, 0xdc, 0xda, 0x41, 0xd8, 0xa6,
	0x9d, 0xe9, 0xb4, 0x87, 0x8d, 0xb4, 0x08, 0x15, 0xfd, 0x79, 0x58, 0x6b, 0x20, 0xed, 0x70, 0xea,
	0xad, 0xd7, 0x5e, 0xf8, 0x1c, 0x7c, 0x81, 0x5e, 0x39, 0xf2, 0x09, 0x32, 0x0c, 0xbd, 0x71, 0xec,
	0x07, 0xe8, 0x74, 0xf6, 0x69, 0x65, 0x4b, 0xb6, 0x72, 0xc2, 0xda, 0xf7, 0xfb, 0xf3, 0xf6, 0xed,
	0xf2, 0xf6, 0x85, 0x54, 0x18, 0xc0, 0x36, 0x0c, 0x43, 0x11, 0xd2, 0x72, 0xc0, 0x05, 0xfe, 0xaa,
	0x9d, 0x77, 0xc2, 0xd0, 0xf1, 0x78, 0x9d, 0x81, 0x5b, 0x67, 0x41, 0x10, 0x0a, 0x26, 0xdc, 0x30,
	0x88, 0x62, 0x5c, 0xed, 0xae, 0xe3, 0x8a, 0x47, 0xa3, 0xc3, 0x6d, 0x2b, 0xf4, 0xeb, 0xc0, 0x83,
	0x88, 0x05, 0x76, 0x58, 0x8f, 0x9e, 0xd5, 0x9f, 0xf2, 0xc0, 0xb5, 0x78, 0x7d, 0x24, 0x5c, 0x2f,
	0x92, 0x54, 0x87, 0x07, 0x69, 0x76, 0xdd, 0x0d, 0x2c, 0x6f, 0x64, 0xf3, 0x44, 0xc6, 0x48, 0xc9,
	0x38, 0xa1, 0x13, 0xd6, 0x71, 0xf9, 0x70, 0xf4, 0x10, 0xbf, 0xf0, 0x03, 0x7f, 0x29, 0xf8, 0xa5,
	0x13, 0x5c, 0x65, 0x8e, 0x3e, 0x17, 0x2c, 0x86, 0xe9, 0x2f, 0xe7, 0x49, 0xa1, 0x01, 0x40, 0xbf,
	0x26, 0xe5, 0xc1, 0x11, 0xf0, 0x2e, 0x17, 0xac, 0xaa, 0x6d, 0x6a, 0x5b, 0x1f, 0x5c, 0x5f, 0xda,
	0x66, 0xe0, 0x6e, 0x27, 0x8b, 0xcd, 0xd3, 0xaf, 0x8f, 0x37, 0xe6, 0xde, 0x1c, 0x6f, 0x68, 0xef,
	0x8f, 0x37, 0x16, 0xaf, 0xba, 0x81, 0xe7, 0x06, 0xbc, 0x37, 0xe6, 0xd0, 0xef, 0x09, 0xb9, 0x77,
	0xf8, 0x2b, 0xb7, 0x04, 0x2a, 0xcc, 0xa3, 0xc2, 0x29, 0x54, 0x98, 0x2c, 0x37, 0x6b, 0x29, 0x8d,
	0x65, 0x99, 0xc4, 0xd5, 0xd0, 0x77, 0x05, 0xf7, 0x41, 0x1c, 0xf5, 0x52, 0x74, 0x7a, 0x87, 0x14,
	0xfb, 0xc0, 0xad, 0x6a, 0x01, 0x65, 0x3e, 0xda, 0x4e, 0x0a, 0xbd, 0xdd, 0x00, 0x90, 0x81, 0xe6,
	0x9a, 0x14, 0x92, 0x22, 0x11, 0x70, 0x2b, 0x25, 0x82, 0x34, 0x7a, 0x97, 0x94, 0xfa, 0x82, 0x89,
	0x51, 0x54, 0x2d, 0xa2, 0xc0, 0xe9, 0xac, 0x00, 0x86, 0x9a, 0x55, 0x25, 0xb1, 0x12, 0xe1, 0x77,
	0x4a, 0x44, 0x91, 0xf5, 0xff, 0x34, 0xb2, 0xa8, 0x0c, 0xe9, 0x1d, 0x42, 0x4c, 0x29, 0x60, 0x86,
	0x43, 0x11, 0x55, 0xb5, 0xcd, 0xc2, 0x56, 0xa5, 0xf9, 0xc9, 0xeb, 0x78, 0x27, 0x67, 0x50, 0xda,
	0x00, 0x19, 0x4a, 0x6f, 0x68, 0x42, 0xa0, 0x3b, 0x64, 0xb1, 0xd1, 0xd9, 0x97, 0xc5, 0xc2, 0xd2,
	0x54, 0x9a, 0x6b, 0xef, 0x8f, 0x37, 0x28, 0xf3, 0x1c, 0x43, 0x1c, 0x01, 0x4f, 0x91, 0x12, 0x18,
	0xbd, 0x49, 0x0a, 0x8d, 0xce, 0xbe, 0xaa, 0xc0, 0x52, 0x6a, 0x03, 0x9d, 0xfd, 0xe6, 0x19, 0x65,
	0xbc, 0xc4, 0x3c, 0x27, 0xc5, 0x95, 0x04, 0xfa, 0x1d, 0x59, 0x6e, 0x00, 0xb4, 0x6d, 0x8f, 0x0f,
	0x5c, 0x9f, 0x87, 0x23, 0x81, 0x35, 0xa8, 0x34, 0x75, 0xc5, 0xa9, 0x31, 0x00, 0xc3, 0xb5, 0x3d,
	0x6e, 0x88, 0x38, 0x9e, 0x12, 0x98, 0x62, 0xea, 0x6f, 0x0b, 0x98, 0x84, 0xcc, 0xa5, 0x75, 0xd0,
	0x1f, 0x5f, 0x8b, 0x71, 0x2e, 0xad, 0x83, 0xfe, 0x24, 0x17, 0x3b, 0x48, 0x6f, 0x5e, 0x12, 0x24,
	0xaf, 0xdf, 0x36, 0xd5, 0x65, 0x48, 0xf1, 0xfa, 0x6d, 0x73, 0xc2, 0x8b, 0x5c, 0x48, 0xf3, 0xfa,
	0x6d, 0x93, 0x7e, 0x43, 0x4a, 0xfd, 0x07, 0x07, 0x3d, 0x73, 0xb7, 0x5a, 0xd8, 0x2c, 0x64, 0xa9,
	0x3d, 0x73, 0x17, 0x4f, 0x4e, 0xc3, 0x93, 0x1b, 0x05, 0x43, 0xb0, 0x32, 0x27, 0x87, 0x34, 0x69,
	0xbc, 0x37, 0x30, 0xd5, 0xe9, 0xa7, 0xd8, 0x7b, 0x83, 0x94, 0xf1, 0x43, 0x91, 0x31, 0xde, 0x1b,
	0x98, 0xf4, 0x2b, 0xb2, 0xd0, 0xed, 0x4b, 0xdf, 0x85, 0x3c, 0xdf, 0x8f, 0x15, 0xf3, 0x94, 0x1f,
	0x65, 0x6d, 0x63, 0x12, 0xbd, 0x4d, 0x8a, 0x03, 0x69, 0x5b, 0x42, 0xdb, 0xe5, 0x09, 0x59, 0xae,
	0xe2, 0x95, 0xc5, 0x7b, 0x2f, 0xb2, 0xc6, 0xc8, 0x91, 0xdc, 0xde, 0xa0, 0x6f, 0x56, 0x17, 0xa7,
	0xb9, 0x72, 0x75, 0xc2, 0x1d, 0x8a, 0x28, 0xc3, 0x95, 0x51, 0xc9, 0x6d, 0xef, 0x76, 0xcd, 0x6a,
	0x79, 0x9a, 0x2b, 0x57, 0x27, 0x5c, 0xd7, 0xf2, 0x33, 0x5c, 0x19, 0xd5, 0xff, 0x2e, 0xe2, 0xd9,
	0x52, 0x97, 0x54, 0x5b, 0xc3, 0x10, 0xba, 0x23, 0x4f, 0xb8, 0xf7, 0x47, 0x3c, 0x92, 0x1d, 0xc8,
	0x64, 0xd6, 0x63, 0x8e, 0xb7, 0x5d, 0xdb, 0x2a, 0x37, 0x0d, 0xa5, 0x73, 0xc9, 0x1e, 0x86, 0x60,
	0xf8, 0x12, 0x68, 0x3c, 0x51, 0x48, 0x03, 0x62, 0x68, 0x4a, 0xfe, 0x44, 0x39, 0x6a, 0x91, 0x35,
	0x19, 0xeb, 0xb0, 0xa1, 0xc3, 0x5b, 0xa1, 0xcf, 0xdc, 0xb1, 0xd1, 0x3c, 0x1a, 0x5d, 0x51, 0x46,
	0x17, 0xd1, 0xc8, 0x93, 0x30, 0xc3, 0x46, 0x5c, 0x8e, 0xcd, 0x09, 0x52, 0xf4, 0x17, 0xb2, 0x8a,
	0x91, 0x30, 0x70, 0x3a, 0xec, 0x90, 0x7b, 0x89, 0x45, 0x01, 0x2d, 0x3e, 0x57, 0x16, 0x17, 0x62,
	0x8b, 0x30, 0x70, 0x0c, 0x4f, 0xa2, 0x72, 0x0c, 0x72, 0x65, 0x12, 0x79, 0xdc, 0xdf, 0x4f, 0x61,
	0xc0, 0x13, 0xf9, 0x62, 0x8e, 0x7c, 0x5c, 0xaa, 0xdf, 0xc2, 0x80, 0x9f, 0x24, 0x3f, 0x2d, 0x43,
	0x3b, 0x64, 0xa5, 0xcb, 0x9e, 0x77, 0x79, 0x14, 0x31, 0x87, 0x77, 0x78, 0xe0, 0x88, 0x47, 0xd5,
	0x85, 0x4d, 0x6d, 0x6b, 0xa9, 0xb9, 0xa9, 0xa4, 0xab, 0x3e, 0x7b, 0x6e, 0xf8, 0x91, 0x63, 0x78,
	0x18, 0x4d, 0x29, 0xce, 0x30, 0xe9, 0xcf, 0x64, 0xf5, 0xfe, 0x88, 0x0f, 0x8f, 0x7a, 0x3c, 0x82,
	0x30, 0x88, 0xc6, 0x8d, 0xa1, 0x84, 0x8d, 0x61, 0x4b, 0x29, 0x6e, 0x3e, 0x91, 0x18, 0x63, 0xa8,
	0x40, 0x39, 0xed, 0x21, 0x57, 0x45, 0x7f, 0x55, 0xc0, 0xff, 0xe5, 0xf4, 0x90, 0xac, 0x75, 0xb9,
	0xed, 0xb2, 0x76, 0xc0, 0x2c, 0xe1, 0x3e, 0x75, 0xc5, 0x51, 0xe2, 0xa3, 0xa1, 0xcf, 0x65, 0xe5,
	0xa3, 0xfb, 0x12, 0x65, 0xb8, 0x63, 0x58, 0x8e, 0xd3, 0x09, 0x4a, 0xb4, 0x4b, 0x4e, 0x75, 0xd9,
	0xf3, 0x5d, 0xe6, 0x79, 0xad, 0xd1, 0x10, 0x5f, 0x49, 0xd5, 0x4e, 0x2f, 0x2a, 0xf1, 0x73, 0xb2,
	0x2c, 0x16, 0xf3, 0x3c, 0xc3, 0x56, 0x80, 0x94, 0xea, 0x34, 0x97, 0xde, 0x22, 0xe5, 0xdd, 0x24,
	0xc9, 0x02, 0xea, 0x9c, 0x53, 0x3a, 0xa7, 0xad, 0x9c, 0xac, 0xc6, 0x60, 0x7a, 0x9b, 0x54, 0x06,
	0xd7, 0xb2, 0xfd, 0xf5, 0xbc, 0x62, 0xae, 0x8a, 0x6b, 0x39, 0xd4, 0x09, 0x1c, 0xb9, 0x37, 0x12,
	0xee, 0xc2, 0x14, 0xf7, 0x46, 0x2e, 0x37, 0x81, 0xd3, 0x7d, 0xb2, 0xd4, 0xea, 0xef, 0x9a, 0xbb,
	0xa1, 0xcd, 0xcd, 0xd0, 0x0d, 0xe2, 0x23, 0x5c, 0x6a, 0x5e, 0x50, 0xfc, 0xb3, 0x76, 0x64, 0x81,
	0x61, 0x85, 0x36, 0x37, 0x40, 0x86, 0x53, 0x22, 0x59, 0x9e, 0xfe, 0x97, 0x46, 0x0a, 0x71, 0xcb,
	0xaa, 0x98, 0xc3, 0xd0, 0x19, 0x32, 0xbf, 0xdd, 0x52, 0xe7, 0x34, 0x4e, 0x06, 0xe2, 0x80, 0xe1,
	0xda, 0xe9, 0x64, 0xc6, 0x70, 0x6a, 0x92, 0x95, 0xf1, 0x47, 0xb2, 0x9f, 0xf8, 0x34, 0x3e, 0x55,
	0x12, 0xe7, 0x27, 0x12, 0x39, 0xfb, 0x9a, 0x61, 0xeb, 0x80, 0x6d, 0x5b, 0xf6, 0xa2, 0x86, 0xe7,
	0x85, 0xcf, 0xba, 0x6e, 0xe4, 0x33, 0x61, 0x3d, 0x6a, 0x9b, 0x0d, 0xdb, 0x1e, 0xf2, 0x28, 0xe2,
	0x33, 0xbd, 0x88, 0x49, 0x9c, 0xe1, 0x2b, 0xa0, 0xe1, 0x82, 0xc1, 0x12, 0x68, 0xba, 0x17, 0x9d,
	0x24, 0xa7, 0x97, 0xe2, 0x96, 0x2d, 0xff, 0x95, 0xad, 0x54, 0xff, 0x21, 0x6e, 0xa5, 0xf4, 0x33,
	0x52, 0xc4, 0xc7, 0x5a, 0xc3, 0xfa, 0x52, 0x6c, 0xdb, 0xd9, 0x87, 0x1a, 0xe3, 0x12, 0x27, 0x8b,
	0x8a, 0xfb, 0x56, 0x38, 0x59, 0xfe, 0x34, 0x4e, 0xc6, 0xf5, 0x5b, 0xa4, 0x32, 0x9e, 0x3c, 0xe8,
	0x65, 0xb2, 0x20, 0x1f, 0xda, 0x16, 0xde, 0xb9, 0x62, 0x73, 0x55, 0x3e, 0x65, 0xf1, 0xab, 0x9c,
	0x7e, 0x53, 0x10, 0xa2, 0x5f, 0xc5, 0x11, 0xa4, 0xe3, 0x46, 0x82, 0x5e, 0x20, 0x45, 0x06, 0x10,
	0x0f, 0x1f, 0xd9, 0x91, 0x00, 0xa0, 0x87, 0x21, 0xfd, 0x4f, 0x8d, 0x94, 0x1b, 0x00, 0x77, 0x9f,
	0xf2, 0x40, 0xd0, 0x3d, 0x52, 0xc1, 0x1f, 0xe3, 0x8d, 0x2c, 0x5f, 0x5f, 0xc6, 0x81, 0x6c, 0xbc,
	0xda, 0xac, 0xca, 0x73, 0xe6, 0xf2, 0x73, 0x7a, 0x0e, 0x99, 0x50, 0x71, 0x12, 0x01, 0x98, 0x7d,
	0xc5, 0x1b, 0x00, 0xf8, 0x98, 0xce, 0xe1, 0x24, 0x02, 0x99, 0xc7, 0xb4, 0x01, 0xa0, 0x7f, 0x4b,
	0x3e, 0x4c, 0x72, 0xc1, 0xfc, 0x77, 0xb0, 0x06, 0xf8, 0x9d, 0x6c, 0x82, 0x66, 0xd4, 0x30, 0xd4,
	0x9b, 0x80, 0xae, 0xff, 0x3b, 0x4f, 0x4a, 0x0d, 0x80, 0x06, 0xb8, 0xf4, 0x32, 0x29, 0xed, 0x73,
	0x21, 0x07, 0xd5, 0xe9, 0xa1, 0xb2, 0x96, 0x4d, 0x49, 0x9f, 0xa3, 0x3b, 0xa4, 0x2c, 0x0d, 0x1b,
	0x00, 0xd1, 0x2c, 0x3a, 0x3b, 0x4c, 0x4a, 0x9c, 0x3e, 0x47, 0xbf, 0x24, 0x95, 0x1f, 0xe5, 0xd5,
	0xc8, 0xa7, 0xac, 0xcd, 0x66, 0x19, 0xf3, 0x76, 0x34, 0x7a, 0x85, 0x54, 0x1e, 0x80, 0xcd, 0x04,
	0x97, 0xa9, 0x65, 0x33, 0x99, 0x4d, 0xec, 0x26, 0x59, 0x6a, 0x00, 0xdc, 0x03, 0x3e, 0x8c, 0x39,
	0x34, 0x67, 0xff, 0xb5, 0xec, 0xd8, 0xad, 0xcf, 0x6d, 0x69, 0xb5, 0xc7, 0xaf, 0xfe, 0x38, 0xeb,
	0xc4, 0x63, 0x7a, 0xd1, 0x93, 0xa5, 0x2c, 0x42, 0x18, 0x09, 0x5a, 0x80, 0x91, 0xa0, 0x25, 0x9b,
	0x7b, 0x5c, 0xf0, 0xda, 0x9d, 0xfa, 0xef, 0x93, 0x94, 0xb7, 0x07, 0x3c, 0x60, 0x81, 0x78, 0x91,
	0x59, 0x3b, 0x60, 0x3e, 0x8f, 0x80, 0x59, 0x7c, 0x76, 0xf9, 0x85, 0x5e, 0xc6, 0x3f, 0x5d, 0x00,
	0xa2, 0xe6, 0xca, 0xeb, 0x77, 0xeb, 0xda, 0x9b, 0x77, 0xeb, 0xda, 0xdb, 0x77, 0xeb, 0xda, 0xcb,
	0x7f, 0xd6, 0xe7, 0x4c, 0xed, 0xb0, 0x84, 0x39, 0x7e, 0xf1, 0x7f, 0x00, 0x00, 0x00, 0xff, 0xff,
	0x3b, 0xd2, 0x95, 0x64, 0xfd, 0x0c, 0x00, 0x00,
}
