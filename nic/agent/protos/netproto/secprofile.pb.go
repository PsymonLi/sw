// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: secprofile.proto

package netproto

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "google.golang.org/genproto/googleapis/api/annotations"
import _ "github.com/pensando/sw/venice/utils/apigen/annotations"
import _ "github.com/gogo/protobuf/gogoproto"
import api "github.com/pensando/sw/api"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// SecurityProfile object
type SecurityProfile struct {
	api.TypeMeta   `protobuf:"bytes,1,opt,name=TypeMeta,embedded=TypeMeta" json:",inline"`
	api.ObjectMeta `protobuf:"bytes,2,opt,name=ObjectMeta,embedded=ObjectMeta" json:"meta,omitempty"`
	Spec           SecurityProfileSpec   `protobuf:"bytes,3,opt,name=Spec" json:"spec,omitempty"`
	Status         SecurityProfileStatus `protobuf:"bytes,4,opt,name=Status" json:"status,omitempty"`
}

func (m *SecurityProfile) Reset()                    { *m = SecurityProfile{} }
func (m *SecurityProfile) String() string            { return proto.CompactTextString(m) }
func (*SecurityProfile) ProtoMessage()               {}
func (*SecurityProfile) Descriptor() ([]byte, []int) { return fileDescriptorSecprofile, []int{0} }

func (m *SecurityProfile) GetSpec() SecurityProfileSpec {
	if m != nil {
		return m.Spec
	}
	return SecurityProfileSpec{}
}

func (m *SecurityProfile) GetStatus() SecurityProfileStatus {
	if m != nil {
		return m.Status
	}
	return SecurityProfileStatus{}
}

// SecurityProfileSpec captures all the security profile configuration
type SecurityProfileSpec struct {
	// Vrfs the security profile is attached to
	AttachVrfs []string `protobuf:"bytes,1,rep,name=AttachVrfs" json:"attach-vrfs,omitempty"`
	// Timeouts for the security profile
	Timeouts *Timeouts `protobuf:"bytes,2,opt,name=Timeouts" json:"timeouts,omitempty"`
}

func (m *SecurityProfileSpec) Reset()                    { *m = SecurityProfileSpec{} }
func (m *SecurityProfileSpec) String() string            { return proto.CompactTextString(m) }
func (*SecurityProfileSpec) ProtoMessage()               {}
func (*SecurityProfileSpec) Descriptor() ([]byte, []int) { return fileDescriptorSecprofile, []int{1} }

func (m *SecurityProfileSpec) GetAttachVrfs() []string {
	if m != nil {
		return m.AttachVrfs
	}
	return nil
}

func (m *SecurityProfileSpec) GetTimeouts() *Timeouts {
	if m != nil {
		return m.Timeouts
	}
	return nil
}

// Timeouts for the security profile in seconds, minutes etc, 1m, 45s
type Timeouts struct {
	// SessionIdle Timeout.
	SessionIdle string `protobuf:"bytes,1,opt,name=SessionIdle,proto3" json:"session-idle,omitempty"`
	// TCP Timeout
	TCP string `protobuf:"bytes,2,opt,name=TCP,proto3" json:"tcp,omitempty"`
	// TCP Drop Timeout
	TCPDrop string `protobuf:"bytes,3,opt,name=TCPDrop,proto3" json:"tcp-drop,omitempty"`
	// TCP Connection Setup Timeout
	TCPConnectionSetup string `protobuf:"bytes,4,opt,name=TCPConnectionSetup,proto3" json:"tcp-connection-setup,omitempty"`
	// TCP Close timeout
	TCPClose string `protobuf:"bytes,5,opt,name=TCPClose,proto3" json:"tcp-close,omitempty"`
	// TCP Half Close timeout
	TCPHalfClose string `protobuf:"bytes,6,opt,name=TCPHalfClose,proto3" json:"tcp-half-close,omitempty"`
	// Drop timeout for non tcp, udp and icmp
	Drop string `protobuf:"bytes,7,opt,name=Drop,proto3" json:"drop,omitempty"`
	// UDP Timeout
	UDP string `protobuf:"bytes,8,opt,name=UDP,proto3" json:"udp,omitempty"`
	// UDP Drop Timeout
	UDPDrop string `protobuf:"bytes,9,opt,name=UDPDrop,proto3" json:"udp-drop,omitempty"`
	// ICMP Timeout
	ICMP string `protobuf:"bytes,10,opt,name=ICMP,proto3" json:"icmp,omitempty"`
	// ICMP Drop Timeout
	ICMPDrop string `protobuf:"bytes,11,opt,name=ICMPDrop,proto3" json:"icmp-drop,omitempty"`
}

func (m *Timeouts) Reset()                    { *m = Timeouts{} }
func (m *Timeouts) String() string            { return proto.CompactTextString(m) }
func (*Timeouts) ProtoMessage()               {}
func (*Timeouts) Descriptor() ([]byte, []int) { return fileDescriptorSecprofile, []int{2} }

func (m *Timeouts) GetSessionIdle() string {
	if m != nil {
		return m.SessionIdle
	}
	return ""
}

func (m *Timeouts) GetTCP() string {
	if m != nil {
		return m.TCP
	}
	return ""
}

func (m *Timeouts) GetTCPDrop() string {
	if m != nil {
		return m.TCPDrop
	}
	return ""
}

func (m *Timeouts) GetTCPConnectionSetup() string {
	if m != nil {
		return m.TCPConnectionSetup
	}
	return ""
}

func (m *Timeouts) GetTCPClose() string {
	if m != nil {
		return m.TCPClose
	}
	return ""
}

func (m *Timeouts) GetTCPHalfClose() string {
	if m != nil {
		return m.TCPHalfClose
	}
	return ""
}

func (m *Timeouts) GetDrop() string {
	if m != nil {
		return m.Drop
	}
	return ""
}

func (m *Timeouts) GetUDP() string {
	if m != nil {
		return m.UDP
	}
	return ""
}

func (m *Timeouts) GetUDPDrop() string {
	if m != nil {
		return m.UDPDrop
	}
	return ""
}

func (m *Timeouts) GetICMP() string {
	if m != nil {
		return m.ICMP
	}
	return ""
}

func (m *Timeouts) GetICMPDrop() string {
	if m != nil {
		return m.ICMPDrop
	}
	return ""
}

// SecurityProfileStatus captures the security profile status
type SecurityProfileStatus struct {
	SecurityProfileID uint64 `protobuf:"varint,1,opt,name=SecurityProfileID,proto3" json:"id,omitempty"`
}

func (m *SecurityProfileStatus) Reset()                    { *m = SecurityProfileStatus{} }
func (m *SecurityProfileStatus) String() string            { return proto.CompactTextString(m) }
func (*SecurityProfileStatus) ProtoMessage()               {}
func (*SecurityProfileStatus) Descriptor() ([]byte, []int) { return fileDescriptorSecprofile, []int{3} }

func (m *SecurityProfileStatus) GetSecurityProfileID() uint64 {
	if m != nil {
		return m.SecurityProfileID
	}
	return 0
}

type SecurityProfileList struct {
	SecurityProfiles []*SecurityProfile `protobuf:"bytes,1,rep,name=SecurityProfiles" json:"SecurityProfiles,omitempty"`
}

func (m *SecurityProfileList) Reset()                    { *m = SecurityProfileList{} }
func (m *SecurityProfileList) String() string            { return proto.CompactTextString(m) }
func (*SecurityProfileList) ProtoMessage()               {}
func (*SecurityProfileList) Descriptor() ([]byte, []int) { return fileDescriptorSecprofile, []int{4} }

func (m *SecurityProfileList) GetSecurityProfiles() []*SecurityProfile {
	if m != nil {
		return m.SecurityProfiles
	}
	return nil
}

// security profile watch event
type SecurityProfileEvent struct {
	EventType       api.EventType   `protobuf:"varint,1,opt,name=EventType,proto3,enum=api.EventType" json:"event-type,omitempty"`
	SecurityProfile SecurityProfile `protobuf:"bytes,2,opt,name=SecurityProfile" json:"sg-profile,omitempty"`
}

func (m *SecurityProfileEvent) Reset()                    { *m = SecurityProfileEvent{} }
func (m *SecurityProfileEvent) String() string            { return proto.CompactTextString(m) }
func (*SecurityProfileEvent) ProtoMessage()               {}
func (*SecurityProfileEvent) Descriptor() ([]byte, []int) { return fileDescriptorSecprofile, []int{5} }

func (m *SecurityProfileEvent) GetEventType() api.EventType {
	if m != nil {
		return m.EventType
	}
	return api.EventType_CreateEvent
}

func (m *SecurityProfileEvent) GetSecurityProfile() SecurityProfile {
	if m != nil {
		return m.SecurityProfile
	}
	return SecurityProfile{}
}

func init() {
	proto.RegisterType((*SecurityProfile)(nil), "netproto.SecurityProfile")
	proto.RegisterType((*SecurityProfileSpec)(nil), "netproto.SecurityProfileSpec")
	proto.RegisterType((*Timeouts)(nil), "netproto.Timeouts")
	proto.RegisterType((*SecurityProfileStatus)(nil), "netproto.SecurityProfileStatus")
	proto.RegisterType((*SecurityProfileList)(nil), "netproto.SecurityProfileList")
	proto.RegisterType((*SecurityProfileEvent)(nil), "netproto.SecurityProfileEvent")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for SecurityProfileApi service

type SecurityProfileApiClient interface {
	GetSecurityProfile(ctx context.Context, in *api.ObjectMeta, opts ...grpc.CallOption) (*SecurityProfile, error)
	ListSecurityProfiles(ctx context.Context, in *api.ObjectMeta, opts ...grpc.CallOption) (*SecurityProfileList, error)
	WatchSecurityProfiles(ctx context.Context, in *api.ObjectMeta, opts ...grpc.CallOption) (SecurityProfileApi_WatchSecurityProfilesClient, error)
	UpdateSecurityProfile(ctx context.Context, in *SecurityProfile, opts ...grpc.CallOption) (*SecurityProfile, error)
	SecurityProfileOperUpdate(ctx context.Context, opts ...grpc.CallOption) (SecurityProfileApi_SecurityProfileOperUpdateClient, error)
}

type securityProfileApiClient struct {
	cc *grpc.ClientConn
}

func NewSecurityProfileApiClient(cc *grpc.ClientConn) SecurityProfileApiClient {
	return &securityProfileApiClient{cc}
}

func (c *securityProfileApiClient) GetSecurityProfile(ctx context.Context, in *api.ObjectMeta, opts ...grpc.CallOption) (*SecurityProfile, error) {
	out := new(SecurityProfile)
	err := grpc.Invoke(ctx, "/netproto.SecurityProfileApi/GetSecurityProfile", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *securityProfileApiClient) ListSecurityProfiles(ctx context.Context, in *api.ObjectMeta, opts ...grpc.CallOption) (*SecurityProfileList, error) {
	out := new(SecurityProfileList)
	err := grpc.Invoke(ctx, "/netproto.SecurityProfileApi/ListSecurityProfiles", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *securityProfileApiClient) WatchSecurityProfiles(ctx context.Context, in *api.ObjectMeta, opts ...grpc.CallOption) (SecurityProfileApi_WatchSecurityProfilesClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_SecurityProfileApi_serviceDesc.Streams[0], c.cc, "/netproto.SecurityProfileApi/WatchSecurityProfiles", opts...)
	if err != nil {
		return nil, err
	}
	x := &securityProfileApiWatchSecurityProfilesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type SecurityProfileApi_WatchSecurityProfilesClient interface {
	Recv() (*SecurityProfileEvent, error)
	grpc.ClientStream
}

type securityProfileApiWatchSecurityProfilesClient struct {
	grpc.ClientStream
}

func (x *securityProfileApiWatchSecurityProfilesClient) Recv() (*SecurityProfileEvent, error) {
	m := new(SecurityProfileEvent)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *securityProfileApiClient) UpdateSecurityProfile(ctx context.Context, in *SecurityProfile, opts ...grpc.CallOption) (*SecurityProfile, error) {
	out := new(SecurityProfile)
	err := grpc.Invoke(ctx, "/netproto.SecurityProfileApi/UpdateSecurityProfile", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *securityProfileApiClient) SecurityProfileOperUpdate(ctx context.Context, opts ...grpc.CallOption) (SecurityProfileApi_SecurityProfileOperUpdateClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_SecurityProfileApi_serviceDesc.Streams[1], c.cc, "/netproto.SecurityProfileApi/SecurityProfileOperUpdate", opts...)
	if err != nil {
		return nil, err
	}
	x := &securityProfileApiSecurityProfileOperUpdateClient{stream}
	return x, nil
}

type SecurityProfileApi_SecurityProfileOperUpdateClient interface {
	Send(*SecurityProfileEvent) error
	CloseAndRecv() (*api.TypeMeta, error)
	grpc.ClientStream
}

type securityProfileApiSecurityProfileOperUpdateClient struct {
	grpc.ClientStream
}

func (x *securityProfileApiSecurityProfileOperUpdateClient) Send(m *SecurityProfileEvent) error {
	return x.ClientStream.SendMsg(m)
}

func (x *securityProfileApiSecurityProfileOperUpdateClient) CloseAndRecv() (*api.TypeMeta, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(api.TypeMeta)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for SecurityProfileApi service

type SecurityProfileApiServer interface {
	GetSecurityProfile(context.Context, *api.ObjectMeta) (*SecurityProfile, error)
	ListSecurityProfiles(context.Context, *api.ObjectMeta) (*SecurityProfileList, error)
	WatchSecurityProfiles(*api.ObjectMeta, SecurityProfileApi_WatchSecurityProfilesServer) error
	UpdateSecurityProfile(context.Context, *SecurityProfile) (*SecurityProfile, error)
	SecurityProfileOperUpdate(SecurityProfileApi_SecurityProfileOperUpdateServer) error
}

func RegisterSecurityProfileApiServer(s *grpc.Server, srv SecurityProfileApiServer) {
	s.RegisterService(&_SecurityProfileApi_serviceDesc, srv)
}

func _SecurityProfileApi_GetSecurityProfile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(api.ObjectMeta)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SecurityProfileApiServer).GetSecurityProfile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/netproto.SecurityProfileApi/GetSecurityProfile",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SecurityProfileApiServer).GetSecurityProfile(ctx, req.(*api.ObjectMeta))
	}
	return interceptor(ctx, in, info, handler)
}

func _SecurityProfileApi_ListSecurityProfiles_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(api.ObjectMeta)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SecurityProfileApiServer).ListSecurityProfiles(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/netproto.SecurityProfileApi/ListSecurityProfiles",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SecurityProfileApiServer).ListSecurityProfiles(ctx, req.(*api.ObjectMeta))
	}
	return interceptor(ctx, in, info, handler)
}

func _SecurityProfileApi_WatchSecurityProfiles_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(api.ObjectMeta)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(SecurityProfileApiServer).WatchSecurityProfiles(m, &securityProfileApiWatchSecurityProfilesServer{stream})
}

type SecurityProfileApi_WatchSecurityProfilesServer interface {
	Send(*SecurityProfileEvent) error
	grpc.ServerStream
}

type securityProfileApiWatchSecurityProfilesServer struct {
	grpc.ServerStream
}

func (x *securityProfileApiWatchSecurityProfilesServer) Send(m *SecurityProfileEvent) error {
	return x.ServerStream.SendMsg(m)
}

func _SecurityProfileApi_UpdateSecurityProfile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SecurityProfile)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SecurityProfileApiServer).UpdateSecurityProfile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/netproto.SecurityProfileApi/UpdateSecurityProfile",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SecurityProfileApiServer).UpdateSecurityProfile(ctx, req.(*SecurityProfile))
	}
	return interceptor(ctx, in, info, handler)
}

func _SecurityProfileApi_SecurityProfileOperUpdate_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(SecurityProfileApiServer).SecurityProfileOperUpdate(&securityProfileApiSecurityProfileOperUpdateServer{stream})
}

type SecurityProfileApi_SecurityProfileOperUpdateServer interface {
	SendAndClose(*api.TypeMeta) error
	Recv() (*SecurityProfileEvent, error)
	grpc.ServerStream
}

type securityProfileApiSecurityProfileOperUpdateServer struct {
	grpc.ServerStream
}

func (x *securityProfileApiSecurityProfileOperUpdateServer) SendAndClose(m *api.TypeMeta) error {
	return x.ServerStream.SendMsg(m)
}

func (x *securityProfileApiSecurityProfileOperUpdateServer) Recv() (*SecurityProfileEvent, error) {
	m := new(SecurityProfileEvent)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _SecurityProfileApi_serviceDesc = grpc.ServiceDesc{
	ServiceName: "netproto.SecurityProfileApi",
	HandlerType: (*SecurityProfileApiServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetSecurityProfile",
			Handler:    _SecurityProfileApi_GetSecurityProfile_Handler,
		},
		{
			MethodName: "ListSecurityProfiles",
			Handler:    _SecurityProfileApi_ListSecurityProfiles_Handler,
		},
		{
			MethodName: "UpdateSecurityProfile",
			Handler:    _SecurityProfileApi_UpdateSecurityProfile_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "WatchSecurityProfiles",
			Handler:       _SecurityProfileApi_WatchSecurityProfiles_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SecurityProfileOperUpdate",
			Handler:       _SecurityProfileApi_SecurityProfileOperUpdate_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "secprofile.proto",
}

func (m *SecurityProfile) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityProfile) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintSecprofile(dAtA, i, uint64(m.TypeMeta.Size()))
	n1, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n1
	dAtA[i] = 0x12
	i++
	i = encodeVarintSecprofile(dAtA, i, uint64(m.ObjectMeta.Size()))
	n2, err := m.ObjectMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n2
	dAtA[i] = 0x1a
	i++
	i = encodeVarintSecprofile(dAtA, i, uint64(m.Spec.Size()))
	n3, err := m.Spec.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n3
	dAtA[i] = 0x22
	i++
	i = encodeVarintSecprofile(dAtA, i, uint64(m.Status.Size()))
	n4, err := m.Status.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n4
	return i, nil
}

func (m *SecurityProfileSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityProfileSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AttachVrfs) > 0 {
		for _, s := range m.AttachVrfs {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.Timeouts != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSecprofile(dAtA, i, uint64(m.Timeouts.Size()))
		n5, err := m.Timeouts.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	return i, nil
}

func (m *Timeouts) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Timeouts) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.SessionIdle) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSecprofile(dAtA, i, uint64(len(m.SessionIdle)))
		i += copy(dAtA[i:], m.SessionIdle)
	}
	if len(m.TCP) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSecprofile(dAtA, i, uint64(len(m.TCP)))
		i += copy(dAtA[i:], m.TCP)
	}
	if len(m.TCPDrop) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSecprofile(dAtA, i, uint64(len(m.TCPDrop)))
		i += copy(dAtA[i:], m.TCPDrop)
	}
	if len(m.TCPConnectionSetup) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintSecprofile(dAtA, i, uint64(len(m.TCPConnectionSetup)))
		i += copy(dAtA[i:], m.TCPConnectionSetup)
	}
	if len(m.TCPClose) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintSecprofile(dAtA, i, uint64(len(m.TCPClose)))
		i += copy(dAtA[i:], m.TCPClose)
	}
	if len(m.TCPHalfClose) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintSecprofile(dAtA, i, uint64(len(m.TCPHalfClose)))
		i += copy(dAtA[i:], m.TCPHalfClose)
	}
	if len(m.Drop) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintSecprofile(dAtA, i, uint64(len(m.Drop)))
		i += copy(dAtA[i:], m.Drop)
	}
	if len(m.UDP) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintSecprofile(dAtA, i, uint64(len(m.UDP)))
		i += copy(dAtA[i:], m.UDP)
	}
	if len(m.UDPDrop) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintSecprofile(dAtA, i, uint64(len(m.UDPDrop)))
		i += copy(dAtA[i:], m.UDPDrop)
	}
	if len(m.ICMP) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintSecprofile(dAtA, i, uint64(len(m.ICMP)))
		i += copy(dAtA[i:], m.ICMP)
	}
	if len(m.ICMPDrop) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintSecprofile(dAtA, i, uint64(len(m.ICMPDrop)))
		i += copy(dAtA[i:], m.ICMPDrop)
	}
	return i, nil
}

func (m *SecurityProfileStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityProfileStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SecurityProfileID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintSecprofile(dAtA, i, uint64(m.SecurityProfileID))
	}
	return i, nil
}

func (m *SecurityProfileList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityProfileList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.SecurityProfiles) > 0 {
		for _, msg := range m.SecurityProfiles {
			dAtA[i] = 0xa
			i++
			i = encodeVarintSecprofile(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SecurityProfileEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityProfileEvent) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.EventType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintSecprofile(dAtA, i, uint64(m.EventType))
	}
	dAtA[i] = 0x12
	i++
	i = encodeVarintSecprofile(dAtA, i, uint64(m.SecurityProfile.Size()))
	n6, err := m.SecurityProfile.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n6
	return i, nil
}

func encodeVarintSecprofile(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *SecurityProfile) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovSecprofile(uint64(l))
	l = m.ObjectMeta.Size()
	n += 1 + l + sovSecprofile(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovSecprofile(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovSecprofile(uint64(l))
	return n
}

func (m *SecurityProfileSpec) Size() (n int) {
	var l int
	_ = l
	if len(m.AttachVrfs) > 0 {
		for _, s := range m.AttachVrfs {
			l = len(s)
			n += 1 + l + sovSecprofile(uint64(l))
		}
	}
	if m.Timeouts != nil {
		l = m.Timeouts.Size()
		n += 1 + l + sovSecprofile(uint64(l))
	}
	return n
}

func (m *Timeouts) Size() (n int) {
	var l int
	_ = l
	l = len(m.SessionIdle)
	if l > 0 {
		n += 1 + l + sovSecprofile(uint64(l))
	}
	l = len(m.TCP)
	if l > 0 {
		n += 1 + l + sovSecprofile(uint64(l))
	}
	l = len(m.TCPDrop)
	if l > 0 {
		n += 1 + l + sovSecprofile(uint64(l))
	}
	l = len(m.TCPConnectionSetup)
	if l > 0 {
		n += 1 + l + sovSecprofile(uint64(l))
	}
	l = len(m.TCPClose)
	if l > 0 {
		n += 1 + l + sovSecprofile(uint64(l))
	}
	l = len(m.TCPHalfClose)
	if l > 0 {
		n += 1 + l + sovSecprofile(uint64(l))
	}
	l = len(m.Drop)
	if l > 0 {
		n += 1 + l + sovSecprofile(uint64(l))
	}
	l = len(m.UDP)
	if l > 0 {
		n += 1 + l + sovSecprofile(uint64(l))
	}
	l = len(m.UDPDrop)
	if l > 0 {
		n += 1 + l + sovSecprofile(uint64(l))
	}
	l = len(m.ICMP)
	if l > 0 {
		n += 1 + l + sovSecprofile(uint64(l))
	}
	l = len(m.ICMPDrop)
	if l > 0 {
		n += 1 + l + sovSecprofile(uint64(l))
	}
	return n
}

func (m *SecurityProfileStatus) Size() (n int) {
	var l int
	_ = l
	if m.SecurityProfileID != 0 {
		n += 1 + sovSecprofile(uint64(m.SecurityProfileID))
	}
	return n
}

func (m *SecurityProfileList) Size() (n int) {
	var l int
	_ = l
	if len(m.SecurityProfiles) > 0 {
		for _, e := range m.SecurityProfiles {
			l = e.Size()
			n += 1 + l + sovSecprofile(uint64(l))
		}
	}
	return n
}

func (m *SecurityProfileEvent) Size() (n int) {
	var l int
	_ = l
	if m.EventType != 0 {
		n += 1 + sovSecprofile(uint64(m.EventType))
	}
	l = m.SecurityProfile.Size()
	n += 1 + l + sovSecprofile(uint64(l))
	return n
}

func sovSecprofile(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozSecprofile(x uint64) (n int) {
	return sovSecprofile(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *SecurityProfile) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSecprofile
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityProfile: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityProfile: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSecprofile
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSecprofile
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSecprofile
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSecprofile
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSecprofile
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSecprofile
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSecprofile
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSecprofile
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSecprofile(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSecprofile
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityProfileSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSecprofile
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityProfileSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityProfileSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttachVrfs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSecprofile
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSecprofile
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AttachVrfs = append(m.AttachVrfs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timeouts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSecprofile
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSecprofile
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Timeouts == nil {
				m.Timeouts = &Timeouts{}
			}
			if err := m.Timeouts.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSecprofile(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSecprofile
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Timeouts) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSecprofile
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Timeouts: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Timeouts: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionIdle", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSecprofile
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSecprofile
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionIdle = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TCP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSecprofile
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSecprofile
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TCP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TCPDrop", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSecprofile
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSecprofile
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TCPDrop = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TCPConnectionSetup", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSecprofile
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSecprofile
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TCPConnectionSetup = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TCPClose", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSecprofile
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSecprofile
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TCPClose = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TCPHalfClose", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSecprofile
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSecprofile
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TCPHalfClose = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Drop", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSecprofile
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSecprofile
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Drop = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UDP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSecprofile
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSecprofile
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UDP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UDPDrop", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSecprofile
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSecprofile
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UDPDrop = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ICMP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSecprofile
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSecprofile
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ICMP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ICMPDrop", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSecprofile
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSecprofile
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ICMPDrop = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSecprofile(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSecprofile
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityProfileStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSecprofile
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityProfileStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityProfileStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecurityProfileID", wireType)
			}
			m.SecurityProfileID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSecprofile
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SecurityProfileID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSecprofile(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSecprofile
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityProfileList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSecprofile
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityProfileList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityProfileList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecurityProfiles", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSecprofile
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSecprofile
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SecurityProfiles = append(m.SecurityProfiles, &SecurityProfile{})
			if err := m.SecurityProfiles[len(m.SecurityProfiles)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSecprofile(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSecprofile
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityProfileEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSecprofile
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityProfileEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityProfileEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventType", wireType)
			}
			m.EventType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSecprofile
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EventType |= (api.EventType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecurityProfile", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSecprofile
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSecprofile
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SecurityProfile.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSecprofile(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSecprofile
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipSecprofile(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowSecprofile
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSecprofile
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSecprofile
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthSecprofile
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowSecprofile
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipSecprofile(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthSecprofile = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowSecprofile   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("secprofile.proto", fileDescriptorSecprofile) }

var fileDescriptorSecprofile = []byte{
	// 940 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x84, 0x95, 0xc1, 0x6e, 0x1b, 0x45,
	0x18, 0xc7, 0xbd, 0x8d, 0x49, 0xec, 0x49, 0x9b, 0x9a, 0x49, 0x1c, 0x6d, 0x4c, 0x6b, 0x47, 0x2b,
	0x01, 0x11, 0xaa, 0xbd, 0x28, 0x20, 0x71, 0x6a, 0x45, 0xd7, 0x0e, 0x34, 0xd0, 0x36, 0x26, 0x76,
	0xda, 0x0b, 0x97, 0xcd, 0xee, 0x67, 0x67, 0xd0, 0x7a, 0x67, 0xe4, 0x99, 0x0d, 0x8a, 0x50, 0x25,
	0x24, 0xc4, 0x3b, 0xc0, 0x8d, 0x67, 0xe0, 0xcc, 0x85, 0x5b, 0x8e, 0x7d, 0x02, 0x0b, 0x85, 0x5b,
	0x8e, 0x3c, 0x01, 0x9a, 0xf1, 0xd8, 0x9e, 0xdd, 0x8d, 0x9b, 0x93, 0xbd, 0xdf, 0xfc, 0xff, 0xbf,
	0xf9, 0xe6, 0xbf, 0x3b, 0x33, 0xa8, 0xc2, 0x21, 0x60, 0x63, 0x3a, 0x20, 0x11, 0xb4, 0xd8, 0x98,
	0x0a, 0x8a, 0x4b, 0x31, 0x08, 0xf5, 0xaf, 0xf6, 0x60, 0x48, 0xe9, 0x30, 0x02, 0xd7, 0x67, 0xc4,
	0xf5, 0xe3, 0x98, 0x0a, 0x5f, 0x10, 0x1a, 0xf3, 0xa9, 0xae, 0x76, 0x30, 0x24, 0xe2, 0x2c, 0x39,
	0x6d, 0x05, 0x74, 0xe4, 0x32, 0x88, 0xb9, 0x1f, 0x87, 0xd4, 0xe5, 0x3f, 0xba, 0xe7, 0x10, 0x93,
	0x00, 0xdc, 0x44, 0x90, 0x88, 0x4b, 0xeb, 0x10, 0x62, 0xd3, 0xed, 0x92, 0x38, 0x88, 0x92, 0x10,
	0x66, 0x98, 0xa6, 0x81, 0x19, 0xd2, 0x21, 0x75, 0x55, 0xf9, 0x34, 0x19, 0xa8, 0x27, 0xf5, 0xa0,
	0xfe, 0x69, 0xf9, 0x87, 0x4b, 0x66, 0x95, 0x3d, 0x8e, 0x40, 0xf8, 0x53, 0x99, 0xf3, 0xd7, 0x1d,
	0x74, 0xbf, 0x07, 0x41, 0x32, 0x26, 0xe2, 0xa2, 0x3b, 0x5d, 0x1e, 0x7e, 0x82, 0x4a, 0xfd, 0x0b,
	0x06, 0x2f, 0x40, 0xf8, 0xb6, 0xb5, 0x6b, 0xed, 0xad, 0xef, 0xdf, 0x6b, 0xf9, 0x8c, 0xb4, 0x66,
	0x45, 0x6f, 0xf3, 0x72, 0xd2, 0x28, 0xbc, 0x9d, 0x34, 0xac, 0xeb, 0x49, 0x63, 0xed, 0x11, 0x89,
	0x23, 0x12, 0xc3, 0xf1, 0xdc, 0x83, 0xbf, 0x45, 0xe8, 0xe8, 0xf4, 0x07, 0x08, 0x84, 0x22, 0xdc,
	0x51, 0x84, 0xfb, 0x8a, 0xb0, 0x28, 0x7b, 0x35, 0x83, 0xb1, 0x21, 0x1b, 0x7a, 0x44, 0x47, 0x44,
	0xc0, 0x88, 0x89, 0x8b, 0x63, 0xc3, 0x8e, 0x0f, 0x51, 0xb1, 0xc7, 0x20, 0xb0, 0x57, 0x14, 0xe6,
	0x61, 0x6b, 0x16, 0x7a, 0x2b, 0xd3, 0xb5, 0x14, 0x79, 0xdb, 0x12, 0x2a, 0x81, 0x9c, 0x41, 0x60,
	0x00, 0x15, 0x02, 0x7f, 0x87, 0x56, 0x7b, 0xc2, 0x17, 0x09, 0xb7, 0x8b, 0x0a, 0xd6, 0x58, 0x0e,
	0x53, 0x32, 0xcf, 0xd6, 0xb8, 0x0a, 0x57, 0xcf, 0x06, 0x50, 0x83, 0x9c, 0x3f, 0x2c, 0xb4, 0x79,
	0x43, 0x23, 0xf8, 0x31, 0x42, 0x4f, 0x85, 0xf0, 0x83, 0xb3, 0x57, 0xe3, 0x01, 0xb7, 0xad, 0xdd,
	0x95, 0xbd, 0xb2, 0xf7, 0xf0, 0x72, 0xba, 0xda, 0xaa, 0xaf, 0x46, 0x9a, 0xe7, 0xe3, 0x81, 0x89,
	0x34, 0x0c, 0xf8, 0x1b, 0x54, 0xea, 0x93, 0x11, 0xd0, 0x44, 0x70, 0x9d, 0x1f, 0x5e, 0xf4, 0x3a,
	0x1b, 0x51, 0x11, 0x4a, 0x20, 0x16, 0xba, 0x62, 0xd0, 0xe6, 0x7e, 0xe7, 0xbf, 0xe2, 0x02, 0x86,
	0xbf, 0x44, 0xeb, 0x3d, 0xe0, 0x9c, 0xd0, 0xf8, 0x30, 0x8c, 0x40, 0xbd, 0xdd, 0xb2, 0x57, 0xd7,
	0x9c, 0x6d, 0x3e, 0x1d, 0x6a, 0x92, 0x30, 0x02, 0x83, 0x65, 0x5a, 0xf0, 0xc7, 0x68, 0xa5, 0xdf,
	0xee, 0xaa, 0xae, 0xca, 0x5e, 0x55, 0x3b, 0xef, 0x89, 0x80, 0x19, 0x06, 0xa9, 0xc0, 0x9f, 0xa3,
	0xb5, 0x7e, 0xbb, 0xdb, 0x19, 0x53, 0xa6, 0xde, 0x5d, 0xd9, 0x68, 0x37, 0x60, 0xcd, 0x70, 0x4c,
	0x4d, 0xc7, 0x4c, 0x8a, 0x5f, 0x21, 0xdc, 0x6f, 0x77, 0xdb, 0x34, 0x8e, 0x21, 0x90, 0xdb, 0xa0,
	0x07, 0x22, 0x61, 0xea, 0x7d, 0x95, 0xbd, 0x8f, 0x34, 0xa0, 0x2e, 0x01, 0xc1, 0x5c, 0xd2, 0xe4,
	0x52, 0x63, 0xc0, 0x6e, 0x20, 0xe0, 0x2f, 0x50, 0x49, 0x56, 0x23, 0xca, 0xc1, 0x7e, 0x4f, 0xd1,
	0x3e, 0xd0, 0xb4, 0x4d, 0x45, 0x93, 0x03, 0xa9, 0xf8, 0xb4, 0x18, 0x77, 0xd0, 0xdd, 0x7e, 0xbb,
	0xfb, 0xcc, 0x8f, 0x06, 0x53, 0xf3, 0xaa, 0x32, 0xef, 0x6a, 0xb3, 0x2d, 0xcd, 0x67, 0x7e, 0x34,
	0xc8, 0x11, 0x52, 0x2e, 0xfc, 0x09, 0x2a, 0xaa, 0x24, 0xd6, 0x94, 0x7b, 0x5b, 0xbb, 0x37, 0x32,
	0x29, 0x28, 0x8d, 0x4c, 0xf8, 0xa4, 0xd3, 0xb5, 0x4b, 0xe9, 0x84, 0x93, 0x30, 0x95, 0xf0, 0x49,
	0x47, 0x25, 0x7c, 0xd2, 0x99, 0x26, 0x5c, 0x4e, 0x27, 0x9c, 0x84, 0xf9, 0x84, 0xb5, 0x54, 0xb6,
	0x72, 0xd8, 0x7e, 0xd1, 0xb5, 0x51, 0xba, 0x15, 0x12, 0x8c, 0x52, 0xad, 0x48, 0x8d, 0x4c, 0x4d,
	0xfe, 0xaa, 0x29, 0xd6, 0xd3, 0xa9, 0x49, 0x7d, 0x76, 0x8e, 0xb9, 0xd8, 0x79, 0x8d, 0xaa, 0x37,
	0x6e, 0x29, 0xfc, 0x04, 0xbd, 0x9f, 0x19, 0x38, 0xec, 0xa8, 0xcf, 0xb0, 0xe8, 0x55, 0xae, 0x27,
	0x8d, 0xbb, 0x24, 0x34, 0x78, 0x79, 0xa9, 0xf3, 0x7d, 0x6e, 0xbf, 0x3d, 0x27, 0x5c, 0xe0, 0x03,
	0x54, 0xc9, 0x94, 0xa7, 0xbb, 0x6e, 0x7d, 0x7f, 0x67, 0xe9, 0x26, 0x3f, 0xce, 0x59, 0x9c, 0xbf,
	0x2d, 0xb4, 0x95, 0x29, 0x1e, 0x9c, 0x43, 0x2c, 0xf0, 0x57, 0xa8, 0xac, 0xfe, 0xc8, 0x33, 0x4e,
	0xb5, 0xbb, 0xb1, 0xbf, 0xa1, 0x4e, 0xb4, 0x79, 0xd5, 0xb3, 0xaf, 0x27, 0x8d, 0x2d, 0x90, 0x8f,
	0x4d, 0x71, 0xc1, 0xcc, 0x4f, 0x61, 0x61, 0xc5, 0x7e, 0xee, 0xb4, 0xd5, 0xfb, 0x7b, 0x79, 0x9b,
	0xde, 0x03, 0x7d, 0x0a, 0x6d, 0xf1, 0x61, 0x53, 0xdf, 0x40, 0x06, 0x3c, 0xcb, 0xdb, 0xff, 0xbd,
	0x88, 0x70, 0xa6, 0xf6, 0x94, 0x11, 0xec, 0x21, 0xfc, 0x35, 0x88, 0xec, 0x51, 0x9f, 0x3d, 0x96,
	0x6b, 0xcb, 0xfb, 0x70, 0x0a, 0xf8, 0x19, 0xda, 0x92, 0x69, 0x67, 0x63, 0xcb, 0x53, 0x96, 0x1f,
	0xd3, 0xd2, 0xef, 0x14, 0xf0, 0x73, 0x54, 0x7d, 0xed, 0x8b, 0xe0, 0xec, 0x76, 0x54, 0x7d, 0x29,
	0x4a, 0xa5, 0xea, 0x14, 0x3e, 0xb5, 0xf0, 0x11, 0xaa, 0x9e, 0xb0, 0xd0, 0x17, 0x90, 0x5d, 0xde,
	0xf2, 0xd5, 0xbc, 0x7b, 0xa1, 0x2f, 0xd1, 0x4e, 0xa6, 0x78, 0xc4, 0x60, 0x3c, 0x9d, 0x03, 0xdf,
	0xd2, 0x51, 0x2d, 0x7d, 0x59, 0x3a, 0x85, 0x3d, 0xab, 0xf6, 0xab, 0xf5, 0xe7, 0x2f, 0x3b, 0x3f,
	0x5b, 0xf9, 0xab, 0xb6, 0x18, 0xc9, 0xaf, 0xb7, 0xc8, 0x28, 0x17, 0x78, 0x35, 0x84, 0x08, 0x04,
	0xe0, 0x15, 0x96, 0x88, 0xda, 0x63, 0xf7, 0xa7, 0x45, 0x08, 0xad, 0x3e, 0xc4, 0x7e, 0x2c, 0xde,
	0xa4, 0x6a, 0x2f, 0xfd, 0x11, 0x70, 0xe6, 0x07, 0x90, 0x2f, 0xbf, 0x71, 0xaa, 0xf2, 0x9a, 0xe7,
	0x7a, 0x32, 0x57, 0x7f, 0x35, 0xdc, 0xab, 0x5c, 0x5e, 0xd5, 0xad, 0xb7, 0x57, 0x75, 0xeb, 0x9f,
	0xab, 0xba, 0xf5, 0xdb, 0xbf, 0xf5, 0x42, 0xd7, 0x3a, 0x5d, 0x55, 0x4b, 0xf9, 0xec, 0xff, 0x00,
	0x00, 0x00, 0xff, 0xff, 0x28, 0xd8, 0x0d, 0xe5, 0xe1, 0x08, 0x00, 0x00,
}
