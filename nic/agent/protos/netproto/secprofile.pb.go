// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: secprofile.proto

package netproto

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "google.golang.org/genproto/googleapis/api/annotations"
import _ "github.com/pensando/sw/venice/utils/apigen/annotations"
import _ "github.com/gogo/protobuf/gogoproto"
import api "github.com/pensando/sw/api"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// SecurityProfile object
type SecurityProfile struct {
	api.TypeMeta   `protobuf:"bytes,1,opt,name=TypeMeta,embedded=TypeMeta" json:",inline"`
	api.ObjectMeta `protobuf:"bytes,2,opt,name=ObjectMeta,embedded=ObjectMeta" json:"meta,omitempty"`
	Spec           SecurityProfileSpec   `protobuf:"bytes,3,opt,name=Spec" json:"spec,omitempty"`
	Status         SecurityProfileStatus `protobuf:"bytes,4,opt,name=Status" json:"status,omitempty"`
}

func (m *SecurityProfile) Reset()                    { *m = SecurityProfile{} }
func (m *SecurityProfile) String() string            { return proto.CompactTextString(m) }
func (*SecurityProfile) ProtoMessage()               {}
func (*SecurityProfile) Descriptor() ([]byte, []int) { return fileDescriptorSecprofile, []int{0} }

func (m *SecurityProfile) GetSpec() SecurityProfileSpec {
	if m != nil {
		return m.Spec
	}
	return SecurityProfileSpec{}
}

func (m *SecurityProfile) GetStatus() SecurityProfileStatus {
	if m != nil {
		return m.Status
	}
	return SecurityProfileStatus{}
}

// SecurityProfileSpec captures all the security profile configuration
type SecurityProfileSpec struct {
	// Vrfs the security profile is attached to
	AttachVrfs []string `protobuf:"bytes,1,rep,name=AttachVrfs" json:"attach-vrfs,omitempty"`
	// Timeouts for the security profile
	Timeouts *Timeouts `protobuf:"bytes,2,opt,name=Timeouts" json:"timeouts,omitempty"`
	// Rate limits for the security profile
	RateLimits *RateLimits `protobuf:"bytes,3,opt,name=RateLimits" json:"rate-limits"`
	DetectApp  bool        `protobuf:"varint,4,opt,name=DetectApp,proto3" json:"detect-app"`
}

func (m *SecurityProfileSpec) Reset()                    { *m = SecurityProfileSpec{} }
func (m *SecurityProfileSpec) String() string            { return proto.CompactTextString(m) }
func (*SecurityProfileSpec) ProtoMessage()               {}
func (*SecurityProfileSpec) Descriptor() ([]byte, []int) { return fileDescriptorSecprofile, []int{1} }

func (m *SecurityProfileSpec) GetAttachVrfs() []string {
	if m != nil {
		return m.AttachVrfs
	}
	return nil
}

func (m *SecurityProfileSpec) GetTimeouts() *Timeouts {
	if m != nil {
		return m.Timeouts
	}
	return nil
}

func (m *SecurityProfileSpec) GetRateLimits() *RateLimits {
	if m != nil {
		return m.RateLimits
	}
	return nil
}

func (m *SecurityProfileSpec) GetDetectApp() bool {
	if m != nil {
		return m.DetectApp
	}
	return false
}

// Timeouts for the security profile in seconds, minutes etc, 1m, 45s
type Timeouts struct {
	// SessionIdle Timeout.
	SessionIdle string `protobuf:"bytes,1,opt,name=SessionIdle,proto3" json:"session-idle,omitempty"`
	// TCP Timeout
	TCP string `protobuf:"bytes,2,opt,name=TCP,proto3" json:"tcp,omitempty"`
	// TCP Drop Timeout
	TCPDrop string `protobuf:"bytes,3,opt,name=TCPDrop,proto3" json:"tcp-drop,omitempty"`
	// TCP Connection Setup Timeout
	TCPConnectionSetup string `protobuf:"bytes,4,opt,name=TCPConnectionSetup,proto3" json:"tcp-connection-setup,omitempty"`
	// TCP Close timeout
	TCPClose string `protobuf:"bytes,5,opt,name=TCPClose,proto3" json:"tcp-close,omitempty"`
	// TCP Half Close timeout
	TCPHalfClose string `protobuf:"bytes,6,opt,name=TCPHalfClose,proto3" json:"tcp-half-close,omitempty"`
	// Drop timeout for non tcp, udp and icmp
	Drop string `protobuf:"bytes,7,opt,name=Drop,proto3" json:"drop,omitempty"`
	// UDP Timeout
	UDP string `protobuf:"bytes,8,opt,name=UDP,proto3" json:"udp,omitempty"`
	// UDP Drop Timeout
	UDPDrop string `protobuf:"bytes,9,opt,name=UDPDrop,proto3" json:"udp-drop,omitempty"`
	// ICMP Timeout
	ICMP string `protobuf:"bytes,10,opt,name=ICMP,proto3" json:"icmp,omitempty"`
	// ICMP Drop Timeout
	ICMPDrop string `protobuf:"bytes,11,opt,name=ICMPDrop,proto3" json:"icmp-drop,omitempty"`
}

func (m *Timeouts) Reset()                    { *m = Timeouts{} }
func (m *Timeouts) String() string            { return proto.CompactTextString(m) }
func (*Timeouts) ProtoMessage()               {}
func (*Timeouts) Descriptor() ([]byte, []int) { return fileDescriptorSecprofile, []int{2} }

func (m *Timeouts) GetSessionIdle() string {
	if m != nil {
		return m.SessionIdle
	}
	return ""
}

func (m *Timeouts) GetTCP() string {
	if m != nil {
		return m.TCP
	}
	return ""
}

func (m *Timeouts) GetTCPDrop() string {
	if m != nil {
		return m.TCPDrop
	}
	return ""
}

func (m *Timeouts) GetTCPConnectionSetup() string {
	if m != nil {
		return m.TCPConnectionSetup
	}
	return ""
}

func (m *Timeouts) GetTCPClose() string {
	if m != nil {
		return m.TCPClose
	}
	return ""
}

func (m *Timeouts) GetTCPHalfClose() string {
	if m != nil {
		return m.TCPHalfClose
	}
	return ""
}

func (m *Timeouts) GetDrop() string {
	if m != nil {
		return m.Drop
	}
	return ""
}

func (m *Timeouts) GetUDP() string {
	if m != nil {
		return m.UDP
	}
	return ""
}

func (m *Timeouts) GetUDPDrop() string {
	if m != nil {
		return m.UDPDrop
	}
	return ""
}

func (m *Timeouts) GetICMP() string {
	if m != nil {
		return m.ICMP
	}
	return ""
}

func (m *Timeouts) GetICMPDrop() string {
	if m != nil {
		return m.ICMPDrop
	}
	return ""
}

// RateLimits for security profile in x units
type RateLimits struct {
	// Tcp Half OpenSession Limit
	TcpHalfOpenSessionLimit uint32 `protobuf:"varint,1,opt,name=TcpHalfOpenSessionLimit,proto3" json:"tcp-half-open-session-limit"`
	// Udp Active Session Limit
	UdpActiveSessionLimit uint32 `protobuf:"varint,2,opt,name=UdpActiveSessionLimit,proto3" json:"udp-active-session-limit"`
	// Icmp Active Session Limit
	IcmpActiveSessionLimit uint32 `protobuf:"varint,3,opt,name=IcmpActiveSessionLimit,proto3" json:"icmp-active-session-limit"`
	// Other Active Session Limit
	OtherActiveSessionLimit uint32 `protobuf:"varint,4,opt,name=OtherActiveSessionLimit,proto3" json:"other-active-session-limit"`
}

func (m *RateLimits) Reset()                    { *m = RateLimits{} }
func (m *RateLimits) String() string            { return proto.CompactTextString(m) }
func (*RateLimits) ProtoMessage()               {}
func (*RateLimits) Descriptor() ([]byte, []int) { return fileDescriptorSecprofile, []int{3} }

func (m *RateLimits) GetTcpHalfOpenSessionLimit() uint32 {
	if m != nil {
		return m.TcpHalfOpenSessionLimit
	}
	return 0
}

func (m *RateLimits) GetUdpActiveSessionLimit() uint32 {
	if m != nil {
		return m.UdpActiveSessionLimit
	}
	return 0
}

func (m *RateLimits) GetIcmpActiveSessionLimit() uint32 {
	if m != nil {
		return m.IcmpActiveSessionLimit
	}
	return 0
}

func (m *RateLimits) GetOtherActiveSessionLimit() uint32 {
	if m != nil {
		return m.OtherActiveSessionLimit
	}
	return 0
}

// SecurityProfileStatus captures the security profile status
type SecurityProfileStatus struct {
	SecurityProfileID uint64 `protobuf:"varint,1,opt,name=SecurityProfileID,proto3" json:"id,omitempty"`
}

func (m *SecurityProfileStatus) Reset()                    { *m = SecurityProfileStatus{} }
func (m *SecurityProfileStatus) String() string            { return proto.CompactTextString(m) }
func (*SecurityProfileStatus) ProtoMessage()               {}
func (*SecurityProfileStatus) Descriptor() ([]byte, []int) { return fileDescriptorSecprofile, []int{4} }

func (m *SecurityProfileStatus) GetSecurityProfileID() uint64 {
	if m != nil {
		return m.SecurityProfileID
	}
	return 0
}

type SecurityProfileList struct {
	SecurityProfiles []*SecurityProfile `protobuf:"bytes,1,rep,name=SecurityProfiles" json:"SecurityProfiles,omitempty"`
}

func (m *SecurityProfileList) Reset()                    { *m = SecurityProfileList{} }
func (m *SecurityProfileList) String() string            { return proto.CompactTextString(m) }
func (*SecurityProfileList) ProtoMessage()               {}
func (*SecurityProfileList) Descriptor() ([]byte, []int) { return fileDescriptorSecprofile, []int{5} }

func (m *SecurityProfileList) GetSecurityProfiles() []*SecurityProfile {
	if m != nil {
		return m.SecurityProfiles
	}
	return nil
}

// security profile watch event
type SecurityProfileEvent struct {
	EventType       api.EventType   `protobuf:"varint,1,opt,name=EventType,proto3,enum=api.EventType" json:"event-type,omitempty"`
	SecurityProfile SecurityProfile `protobuf:"bytes,2,opt,name=SecurityProfile" json:"sg-profile,omitempty"`
}

func (m *SecurityProfileEvent) Reset()                    { *m = SecurityProfileEvent{} }
func (m *SecurityProfileEvent) String() string            { return proto.CompactTextString(m) }
func (*SecurityProfileEvent) ProtoMessage()               {}
func (*SecurityProfileEvent) Descriptor() ([]byte, []int) { return fileDescriptorSecprofile, []int{6} }

func (m *SecurityProfileEvent) GetEventType() api.EventType {
	if m != nil {
		return m.EventType
	}
	return api.EventType_CreateEvent
}

func (m *SecurityProfileEvent) GetSecurityProfile() SecurityProfile {
	if m != nil {
		return m.SecurityProfile
	}
	return SecurityProfile{}
}

// secprofile watch events batched
type SecurityProfileEventList struct {
	SecurityProfileEvents []*SecurityProfileEvent `protobuf:"bytes,1,rep,name=SecurityProfileEvents" json:"SecurityProfileEvents,omitempty"`
}

func (m *SecurityProfileEventList) Reset()         { *m = SecurityProfileEventList{} }
func (m *SecurityProfileEventList) String() string { return proto.CompactTextString(m) }
func (*SecurityProfileEventList) ProtoMessage()    {}
func (*SecurityProfileEventList) Descriptor() ([]byte, []int) {
	return fileDescriptorSecprofile, []int{7}
}

func (m *SecurityProfileEventList) GetSecurityProfileEvents() []*SecurityProfileEvent {
	if m != nil {
		return m.SecurityProfileEvents
	}
	return nil
}

func init() {
	proto.RegisterType((*SecurityProfile)(nil), "netproto.SecurityProfile")
	proto.RegisterType((*SecurityProfileSpec)(nil), "netproto.SecurityProfileSpec")
	proto.RegisterType((*Timeouts)(nil), "netproto.Timeouts")
	proto.RegisterType((*RateLimits)(nil), "netproto.RateLimits")
	proto.RegisterType((*SecurityProfileStatus)(nil), "netproto.SecurityProfileStatus")
	proto.RegisterType((*SecurityProfileList)(nil), "netproto.SecurityProfileList")
	proto.RegisterType((*SecurityProfileEvent)(nil), "netproto.SecurityProfileEvent")
	proto.RegisterType((*SecurityProfileEventList)(nil), "netproto.SecurityProfileEventList")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for SecurityProfileApiV1 service

type SecurityProfileApiV1Client interface {
	ListSecurityProfiles(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (*SecurityProfileList, error)
	WatchSecurityProfiles(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (SecurityProfileApiV1_WatchSecurityProfilesClient, error)
	SecurityProfileOperUpdate(ctx context.Context, opts ...grpc.CallOption) (SecurityProfileApiV1_SecurityProfileOperUpdateClient, error)
}

type securityProfileApiV1Client struct {
	cc *grpc.ClientConn
}

func NewSecurityProfileApiV1Client(cc *grpc.ClientConn) SecurityProfileApiV1Client {
	return &securityProfileApiV1Client{cc}
}

func (c *securityProfileApiV1Client) ListSecurityProfiles(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (*SecurityProfileList, error) {
	out := new(SecurityProfileList)
	err := grpc.Invoke(ctx, "/netproto.SecurityProfileApiV1/ListSecurityProfiles", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *securityProfileApiV1Client) WatchSecurityProfiles(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (SecurityProfileApiV1_WatchSecurityProfilesClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_SecurityProfileApiV1_serviceDesc.Streams[0], c.cc, "/netproto.SecurityProfileApiV1/WatchSecurityProfiles", opts...)
	if err != nil {
		return nil, err
	}
	x := &securityProfileApiV1WatchSecurityProfilesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type SecurityProfileApiV1_WatchSecurityProfilesClient interface {
	Recv() (*SecurityProfileEventList, error)
	grpc.ClientStream
}

type securityProfileApiV1WatchSecurityProfilesClient struct {
	grpc.ClientStream
}

func (x *securityProfileApiV1WatchSecurityProfilesClient) Recv() (*SecurityProfileEventList, error) {
	m := new(SecurityProfileEventList)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *securityProfileApiV1Client) SecurityProfileOperUpdate(ctx context.Context, opts ...grpc.CallOption) (SecurityProfileApiV1_SecurityProfileOperUpdateClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_SecurityProfileApiV1_serviceDesc.Streams[1], c.cc, "/netproto.SecurityProfileApiV1/SecurityProfileOperUpdate", opts...)
	if err != nil {
		return nil, err
	}
	x := &securityProfileApiV1SecurityProfileOperUpdateClient{stream}
	return x, nil
}

type SecurityProfileApiV1_SecurityProfileOperUpdateClient interface {
	Send(*SecurityProfileEvent) error
	CloseAndRecv() (*api.TypeMeta, error)
	grpc.ClientStream
}

type securityProfileApiV1SecurityProfileOperUpdateClient struct {
	grpc.ClientStream
}

func (x *securityProfileApiV1SecurityProfileOperUpdateClient) Send(m *SecurityProfileEvent) error {
	return x.ClientStream.SendMsg(m)
}

func (x *securityProfileApiV1SecurityProfileOperUpdateClient) CloseAndRecv() (*api.TypeMeta, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(api.TypeMeta)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for SecurityProfileApiV1 service

type SecurityProfileApiV1Server interface {
	ListSecurityProfiles(context.Context, *api.ListWatchOptions) (*SecurityProfileList, error)
	WatchSecurityProfiles(*api.ListWatchOptions, SecurityProfileApiV1_WatchSecurityProfilesServer) error
	SecurityProfileOperUpdate(SecurityProfileApiV1_SecurityProfileOperUpdateServer) error
}

func RegisterSecurityProfileApiV1Server(s *grpc.Server, srv SecurityProfileApiV1Server) {
	s.RegisterService(&_SecurityProfileApiV1_serviceDesc, srv)
}

func _SecurityProfileApiV1_ListSecurityProfiles_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(api.ListWatchOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SecurityProfileApiV1Server).ListSecurityProfiles(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/netproto.SecurityProfileApiV1/ListSecurityProfiles",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SecurityProfileApiV1Server).ListSecurityProfiles(ctx, req.(*api.ListWatchOptions))
	}
	return interceptor(ctx, in, info, handler)
}

func _SecurityProfileApiV1_WatchSecurityProfiles_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(api.ListWatchOptions)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(SecurityProfileApiV1Server).WatchSecurityProfiles(m, &securityProfileApiV1WatchSecurityProfilesServer{stream})
}

type SecurityProfileApiV1_WatchSecurityProfilesServer interface {
	Send(*SecurityProfileEventList) error
	grpc.ServerStream
}

type securityProfileApiV1WatchSecurityProfilesServer struct {
	grpc.ServerStream
}

func (x *securityProfileApiV1WatchSecurityProfilesServer) Send(m *SecurityProfileEventList) error {
	return x.ServerStream.SendMsg(m)
}

func _SecurityProfileApiV1_SecurityProfileOperUpdate_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(SecurityProfileApiV1Server).SecurityProfileOperUpdate(&securityProfileApiV1SecurityProfileOperUpdateServer{stream})
}

type SecurityProfileApiV1_SecurityProfileOperUpdateServer interface {
	SendAndClose(*api.TypeMeta) error
	Recv() (*SecurityProfileEvent, error)
	grpc.ServerStream
}

type securityProfileApiV1SecurityProfileOperUpdateServer struct {
	grpc.ServerStream
}

func (x *securityProfileApiV1SecurityProfileOperUpdateServer) SendAndClose(m *api.TypeMeta) error {
	return x.ServerStream.SendMsg(m)
}

func (x *securityProfileApiV1SecurityProfileOperUpdateServer) Recv() (*SecurityProfileEvent, error) {
	m := new(SecurityProfileEvent)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _SecurityProfileApiV1_serviceDesc = grpc.ServiceDesc{
	ServiceName: "netproto.SecurityProfileApiV1",
	HandlerType: (*SecurityProfileApiV1Server)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListSecurityProfiles",
			Handler:    _SecurityProfileApiV1_ListSecurityProfiles_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "WatchSecurityProfiles",
			Handler:       _SecurityProfileApiV1_WatchSecurityProfiles_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SecurityProfileOperUpdate",
			Handler:       _SecurityProfileApiV1_SecurityProfileOperUpdate_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "secprofile.proto",
}

func (m *SecurityProfile) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityProfile) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintSecprofile(dAtA, i, uint64(m.TypeMeta.Size()))
	n1, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n1
	dAtA[i] = 0x12
	i++
	i = encodeVarintSecprofile(dAtA, i, uint64(m.ObjectMeta.Size()))
	n2, err := m.ObjectMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n2
	dAtA[i] = 0x1a
	i++
	i = encodeVarintSecprofile(dAtA, i, uint64(m.Spec.Size()))
	n3, err := m.Spec.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n3
	dAtA[i] = 0x22
	i++
	i = encodeVarintSecprofile(dAtA, i, uint64(m.Status.Size()))
	n4, err := m.Status.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n4
	return i, nil
}

func (m *SecurityProfileSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityProfileSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AttachVrfs) > 0 {
		for _, s := range m.AttachVrfs {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.Timeouts != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSecprofile(dAtA, i, uint64(m.Timeouts.Size()))
		n5, err := m.Timeouts.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.RateLimits != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSecprofile(dAtA, i, uint64(m.RateLimits.Size()))
		n6, err := m.RateLimits.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.DetectApp {
		dAtA[i] = 0x20
		i++
		if m.DetectApp {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *Timeouts) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Timeouts) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.SessionIdle) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSecprofile(dAtA, i, uint64(len(m.SessionIdle)))
		i += copy(dAtA[i:], m.SessionIdle)
	}
	if len(m.TCP) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSecprofile(dAtA, i, uint64(len(m.TCP)))
		i += copy(dAtA[i:], m.TCP)
	}
	if len(m.TCPDrop) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSecprofile(dAtA, i, uint64(len(m.TCPDrop)))
		i += copy(dAtA[i:], m.TCPDrop)
	}
	if len(m.TCPConnectionSetup) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintSecprofile(dAtA, i, uint64(len(m.TCPConnectionSetup)))
		i += copy(dAtA[i:], m.TCPConnectionSetup)
	}
	if len(m.TCPClose) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintSecprofile(dAtA, i, uint64(len(m.TCPClose)))
		i += copy(dAtA[i:], m.TCPClose)
	}
	if len(m.TCPHalfClose) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintSecprofile(dAtA, i, uint64(len(m.TCPHalfClose)))
		i += copy(dAtA[i:], m.TCPHalfClose)
	}
	if len(m.Drop) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintSecprofile(dAtA, i, uint64(len(m.Drop)))
		i += copy(dAtA[i:], m.Drop)
	}
	if len(m.UDP) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintSecprofile(dAtA, i, uint64(len(m.UDP)))
		i += copy(dAtA[i:], m.UDP)
	}
	if len(m.UDPDrop) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintSecprofile(dAtA, i, uint64(len(m.UDPDrop)))
		i += copy(dAtA[i:], m.UDPDrop)
	}
	if len(m.ICMP) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintSecprofile(dAtA, i, uint64(len(m.ICMP)))
		i += copy(dAtA[i:], m.ICMP)
	}
	if len(m.ICMPDrop) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintSecprofile(dAtA, i, uint64(len(m.ICMPDrop)))
		i += copy(dAtA[i:], m.ICMPDrop)
	}
	return i, nil
}

func (m *RateLimits) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RateLimits) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TcpHalfOpenSessionLimit != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintSecprofile(dAtA, i, uint64(m.TcpHalfOpenSessionLimit))
	}
	if m.UdpActiveSessionLimit != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintSecprofile(dAtA, i, uint64(m.UdpActiveSessionLimit))
	}
	if m.IcmpActiveSessionLimit != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintSecprofile(dAtA, i, uint64(m.IcmpActiveSessionLimit))
	}
	if m.OtherActiveSessionLimit != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintSecprofile(dAtA, i, uint64(m.OtherActiveSessionLimit))
	}
	return i, nil
}

func (m *SecurityProfileStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityProfileStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SecurityProfileID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintSecprofile(dAtA, i, uint64(m.SecurityProfileID))
	}
	return i, nil
}

func (m *SecurityProfileList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityProfileList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.SecurityProfiles) > 0 {
		for _, msg := range m.SecurityProfiles {
			dAtA[i] = 0xa
			i++
			i = encodeVarintSecprofile(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SecurityProfileEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityProfileEvent) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.EventType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintSecprofile(dAtA, i, uint64(m.EventType))
	}
	dAtA[i] = 0x12
	i++
	i = encodeVarintSecprofile(dAtA, i, uint64(m.SecurityProfile.Size()))
	n7, err := m.SecurityProfile.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n7
	return i, nil
}

func (m *SecurityProfileEventList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityProfileEventList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.SecurityProfileEvents) > 0 {
		for _, msg := range m.SecurityProfileEvents {
			dAtA[i] = 0xa
			i++
			i = encodeVarintSecprofile(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func encodeVarintSecprofile(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *SecurityProfile) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovSecprofile(uint64(l))
	l = m.ObjectMeta.Size()
	n += 1 + l + sovSecprofile(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovSecprofile(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovSecprofile(uint64(l))
	return n
}

func (m *SecurityProfileSpec) Size() (n int) {
	var l int
	_ = l
	if len(m.AttachVrfs) > 0 {
		for _, s := range m.AttachVrfs {
			l = len(s)
			n += 1 + l + sovSecprofile(uint64(l))
		}
	}
	if m.Timeouts != nil {
		l = m.Timeouts.Size()
		n += 1 + l + sovSecprofile(uint64(l))
	}
	if m.RateLimits != nil {
		l = m.RateLimits.Size()
		n += 1 + l + sovSecprofile(uint64(l))
	}
	if m.DetectApp {
		n += 2
	}
	return n
}

func (m *Timeouts) Size() (n int) {
	var l int
	_ = l
	l = len(m.SessionIdle)
	if l > 0 {
		n += 1 + l + sovSecprofile(uint64(l))
	}
	l = len(m.TCP)
	if l > 0 {
		n += 1 + l + sovSecprofile(uint64(l))
	}
	l = len(m.TCPDrop)
	if l > 0 {
		n += 1 + l + sovSecprofile(uint64(l))
	}
	l = len(m.TCPConnectionSetup)
	if l > 0 {
		n += 1 + l + sovSecprofile(uint64(l))
	}
	l = len(m.TCPClose)
	if l > 0 {
		n += 1 + l + sovSecprofile(uint64(l))
	}
	l = len(m.TCPHalfClose)
	if l > 0 {
		n += 1 + l + sovSecprofile(uint64(l))
	}
	l = len(m.Drop)
	if l > 0 {
		n += 1 + l + sovSecprofile(uint64(l))
	}
	l = len(m.UDP)
	if l > 0 {
		n += 1 + l + sovSecprofile(uint64(l))
	}
	l = len(m.UDPDrop)
	if l > 0 {
		n += 1 + l + sovSecprofile(uint64(l))
	}
	l = len(m.ICMP)
	if l > 0 {
		n += 1 + l + sovSecprofile(uint64(l))
	}
	l = len(m.ICMPDrop)
	if l > 0 {
		n += 1 + l + sovSecprofile(uint64(l))
	}
	return n
}

func (m *RateLimits) Size() (n int) {
	var l int
	_ = l
	if m.TcpHalfOpenSessionLimit != 0 {
		n += 1 + sovSecprofile(uint64(m.TcpHalfOpenSessionLimit))
	}
	if m.UdpActiveSessionLimit != 0 {
		n += 1 + sovSecprofile(uint64(m.UdpActiveSessionLimit))
	}
	if m.IcmpActiveSessionLimit != 0 {
		n += 1 + sovSecprofile(uint64(m.IcmpActiveSessionLimit))
	}
	if m.OtherActiveSessionLimit != 0 {
		n += 1 + sovSecprofile(uint64(m.OtherActiveSessionLimit))
	}
	return n
}

func (m *SecurityProfileStatus) Size() (n int) {
	var l int
	_ = l
	if m.SecurityProfileID != 0 {
		n += 1 + sovSecprofile(uint64(m.SecurityProfileID))
	}
	return n
}

func (m *SecurityProfileList) Size() (n int) {
	var l int
	_ = l
	if len(m.SecurityProfiles) > 0 {
		for _, e := range m.SecurityProfiles {
			l = e.Size()
			n += 1 + l + sovSecprofile(uint64(l))
		}
	}
	return n
}

func (m *SecurityProfileEvent) Size() (n int) {
	var l int
	_ = l
	if m.EventType != 0 {
		n += 1 + sovSecprofile(uint64(m.EventType))
	}
	l = m.SecurityProfile.Size()
	n += 1 + l + sovSecprofile(uint64(l))
	return n
}

func (m *SecurityProfileEventList) Size() (n int) {
	var l int
	_ = l
	if len(m.SecurityProfileEvents) > 0 {
		for _, e := range m.SecurityProfileEvents {
			l = e.Size()
			n += 1 + l + sovSecprofile(uint64(l))
		}
	}
	return n
}

func sovSecprofile(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozSecprofile(x uint64) (n int) {
	return sovSecprofile(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *SecurityProfile) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSecprofile
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityProfile: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityProfile: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSecprofile
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSecprofile
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSecprofile
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSecprofile
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSecprofile
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSecprofile
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSecprofile
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSecprofile
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSecprofile(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSecprofile
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityProfileSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSecprofile
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityProfileSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityProfileSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttachVrfs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSecprofile
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSecprofile
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AttachVrfs = append(m.AttachVrfs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timeouts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSecprofile
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSecprofile
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Timeouts == nil {
				m.Timeouts = &Timeouts{}
			}
			if err := m.Timeouts.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RateLimits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSecprofile
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSecprofile
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RateLimits == nil {
				m.RateLimits = &RateLimits{}
			}
			if err := m.RateLimits.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DetectApp", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSecprofile
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DetectApp = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipSecprofile(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSecprofile
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Timeouts) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSecprofile
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Timeouts: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Timeouts: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionIdle", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSecprofile
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSecprofile
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionIdle = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TCP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSecprofile
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSecprofile
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TCP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TCPDrop", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSecprofile
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSecprofile
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TCPDrop = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TCPConnectionSetup", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSecprofile
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSecprofile
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TCPConnectionSetup = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TCPClose", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSecprofile
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSecprofile
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TCPClose = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TCPHalfClose", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSecprofile
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSecprofile
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TCPHalfClose = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Drop", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSecprofile
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSecprofile
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Drop = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UDP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSecprofile
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSecprofile
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UDP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UDPDrop", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSecprofile
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSecprofile
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UDPDrop = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ICMP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSecprofile
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSecprofile
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ICMP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ICMPDrop", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSecprofile
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSecprofile
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ICMPDrop = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSecprofile(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSecprofile
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RateLimits) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSecprofile
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RateLimits: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RateLimits: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpHalfOpenSessionLimit", wireType)
			}
			m.TcpHalfOpenSessionLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSecprofile
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpHalfOpenSessionLimit |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UdpActiveSessionLimit", wireType)
			}
			m.UdpActiveSessionLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSecprofile
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UdpActiveSessionLimit |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IcmpActiveSessionLimit", wireType)
			}
			m.IcmpActiveSessionLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSecprofile
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IcmpActiveSessionLimit |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OtherActiveSessionLimit", wireType)
			}
			m.OtherActiveSessionLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSecprofile
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OtherActiveSessionLimit |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSecprofile(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSecprofile
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityProfileStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSecprofile
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityProfileStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityProfileStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecurityProfileID", wireType)
			}
			m.SecurityProfileID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSecprofile
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SecurityProfileID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSecprofile(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSecprofile
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityProfileList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSecprofile
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityProfileList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityProfileList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecurityProfiles", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSecprofile
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSecprofile
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SecurityProfiles = append(m.SecurityProfiles, &SecurityProfile{})
			if err := m.SecurityProfiles[len(m.SecurityProfiles)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSecprofile(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSecprofile
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityProfileEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSecprofile
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityProfileEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityProfileEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventType", wireType)
			}
			m.EventType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSecprofile
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EventType |= (api.EventType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecurityProfile", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSecprofile
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSecprofile
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SecurityProfile.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSecprofile(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSecprofile
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityProfileEventList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSecprofile
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityProfileEventList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityProfileEventList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecurityProfileEvents", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSecprofile
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSecprofile
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SecurityProfileEvents = append(m.SecurityProfileEvents, &SecurityProfileEvent{})
			if err := m.SecurityProfileEvents[len(m.SecurityProfileEvents)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSecprofile(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSecprofile
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipSecprofile(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowSecprofile
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSecprofile
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSecprofile
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthSecprofile
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowSecprofile
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipSecprofile(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthSecprofile = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowSecprofile   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("secprofile.proto", fileDescriptorSecprofile) }

var fileDescriptorSecprofile = []byte{
	// 1244 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x96, 0xcf, 0x6e, 0xdb, 0xc6,
	0x13, 0xc7, 0x43, 0x49, 0xb1, 0xa5, 0x75, 0xec, 0x38, 0x6b, 0x29, 0xa1, 0x94, 0xc4, 0x0a, 0x08,
	0xfc, 0x00, 0xff, 0x0a, 0xeb, 0xaf, 0x5b, 0xa7, 0x41, 0x9b, 0xa0, 0xa6, 0x94, 0x20, 0x6a, 0x93,
	0x58, 0x95, 0x64, 0xe7, 0xd2, 0x43, 0xd7, 0xe4, 0x4a, 0x66, 0x41, 0x91, 0x1b, 0xed, 0xd2, 0xa9,
	0x51, 0xe4, 0xd4, 0xc2, 0x40, 0x5f, 0xa1, 0x0f, 0xd0, 0x43, 0x8e, 0x39, 0x16, 0xbd, 0xf4, 0x96,
	0x63, 0x9e, 0xc0, 0x28, 0x72, 0x2a, 0xfc, 0x14, 0xc5, 0x0e, 0x29, 0x8a, 0xfa, 0x67, 0xf5, 0x24,
	0x71, 0x76, 0xe6, 0xf3, 0x9d, 0x99, 0x5d, 0x72, 0x07, 0xad, 0x73, 0x6a, 0xb0, 0x81, 0xdb, 0xb5,
	0x6c, 0x5a, 0x64, 0x03, 0x57, 0xb8, 0x38, 0xe9, 0x50, 0x01, 0xff, 0x72, 0x77, 0x7a, 0xae, 0xdb,
	0xb3, 0x69, 0x89, 0x30, 0xab, 0x44, 0x1c, 0xc7, 0x15, 0x44, 0x58, 0xae, 0xc3, 0x7d, 0xbf, 0xdc,
	0xe3, 0x9e, 0x25, 0x8e, 0xbd, 0xa3, 0xa2, 0xe1, 0xf6, 0x4b, 0x8c, 0x3a, 0x9c, 0x38, 0xa6, 0x5b,
	0xe2, 0xaf, 0x4b, 0x27, 0xd4, 0xb1, 0x0c, 0x5a, 0xf2, 0x84, 0x65, 0x73, 0x19, 0xda, 0xa3, 0x4e,
	0x34, 0xba, 0x64, 0x39, 0x86, 0xed, 0x99, 0x74, 0x88, 0x29, 0x44, 0x30, 0x3d, 0xb7, 0xe7, 0x96,
	0xc0, 0x7c, 0xe4, 0x75, 0xe1, 0x09, 0x1e, 0xe0, 0x5f, 0xe0, 0xfe, 0xbf, 0x39, 0xaa, 0x32, 0xc7,
	0x3e, 0x15, 0xc4, 0x77, 0xd3, 0xfe, 0x8c, 0xa1, 0xeb, 0x6d, 0x6a, 0x78, 0x03, 0x4b, 0x9c, 0x36,
	0xfd, 0xf2, 0xf0, 0x23, 0x94, 0xec, 0x9c, 0x32, 0xfa, 0x9c, 0x0a, 0xa2, 0x2a, 0xf7, 0x94, 0xad,
	0x95, 0xea, 0x6a, 0x91, 0x30, 0xab, 0x38, 0x34, 0xea, 0x1b, 0xef, 0xcf, 0xf3, 0x57, 0x3e, 0x9c,
	0xe7, 0x95, 0x8b, 0xf3, 0xfc, 0xf2, 0xb6, 0xe5, 0xd8, 0x96, 0x43, 0x5b, 0x61, 0x0c, 0xfe, 0x06,
	0xa1, 0xfd, 0xa3, 0x1f, 0xa8, 0x21, 0x80, 0x10, 0x03, 0xc2, 0x75, 0x20, 0x8c, 0xcc, 0x7a, 0x2e,
	0xc2, 0x58, 0x93, 0x09, 0x6d, 0xbb, 0x7d, 0x4b, 0xd0, 0x3e, 0x13, 0xa7, 0xad, 0x48, 0x38, 0x6e,
	0xa0, 0x44, 0x9b, 0x51, 0x43, 0x8d, 0x03, 0xe6, 0x6e, 0x71, 0xd8, 0xf4, 0xe2, 0x44, 0xd6, 0xd2,
	0x49, 0xbf, 0x29, 0xa1, 0x12, 0xc8, 0x19, 0x35, 0x22, 0x40, 0x40, 0xe0, 0x6f, 0xd1, 0x52, 0x5b,
	0x10, 0xe1, 0x71, 0x35, 0x01, 0xb0, 0xfc, 0x7c, 0x18, 0xb8, 0xe9, 0x6a, 0x80, 0x5b, 0xe7, 0xf0,
	0x1c, 0x01, 0x06, 0x20, 0xed, 0xf7, 0x18, 0xda, 0x98, 0x91, 0x08, 0x7e, 0x88, 0xd0, 0x9e, 0x10,
	0xc4, 0x38, 0x3e, 0x1c, 0x74, 0xb9, 0xaa, 0xdc, 0x8b, 0x6f, 0xa5, 0xf4, 0xbb, 0xef, 0xfd, 0x6a,
	0x33, 0x04, 0x56, 0x0a, 0x27, 0x83, 0x6e, 0x14, 0x19, 0x09, 0xc0, 0x5f, 0xa3, 0x64, 0xc7, 0xea,
	0x53, 0xd7, 0x13, 0x3c, 0xe8, 0x1f, 0x1e, 0xe5, 0x3a, 0x5c, 0x81, 0x16, 0x4a, 0x20, 0x16, 0x81,
	0x25, 0x42, 0x0b, 0xe3, 0x71, 0x03, 0xa1, 0x16, 0x11, 0xf4, 0x99, 0xd5, 0xb7, 0x04, 0x0f, 0xda,
	0x98, 0x1e, 0xd1, 0x46, 0x6b, 0xb0, 0xad, 0x92, 0xb7, 0x32, 0x20, 0x82, 0x16, 0x6c, 0x30, 0xb6,
	0x22, 0xc1, 0xf8, 0x01, 0x4a, 0xd5, 0xa9, 0xa0, 0x86, 0xd8, 0x63, 0x0c, 0x7a, 0x98, 0xd4, 0x6f,
	0xbf, 0x3b, 0xcb, 0x5e, 0xed, 0x12, 0x9b, 0xd3, 0x20, 0x18, 0x99, 0xe0, 0x51, 0x20, 0x8c, 0xb5,
	0x46, 0xde, 0xda, 0x1f, 0xcb, 0xa3, 0x92, 0xf0, 0xf7, 0x68, 0xa5, 0x4d, 0x39, 0xb7, 0x5c, 0xa7,
	0x61, 0xda, 0x14, 0xce, 0x58, 0x4a, 0x7f, 0xf4, 0xf6, 0x2c, 0x9b, 0xa9, 0x7b, 0x03, 0x38, 0xfd,
	0x5b, 0x3b, 0x65, 0xbe, 0x5d, 0xb9, 0x5f, 0xfd, 0xbc, 0x5c, 0xe6, 0xff, 0x7f, 0x77, 0x96, 0x8d,
	0x3f, 0x28, 0xf3, 0x40, 0xe0, 0x26, 0xf7, 0x43, 0x0b, 0x96, 0x69, 0xd3, 0x48, 0xc5, 0x51, 0x24,
	0x7e, 0x8a, 0xe2, 0x9d, 0x5a, 0x13, 0x7a, 0x97, 0xd2, 0x77, 0xdf, 0x9e, 0x65, 0xd3, 0x21, 0xb9,
	0x32, 0x06, 0xbe, 0xba, 0xb3, 0x5b, 0x0e, 0xd1, 0xab, 0xc2, 0x60, 0x11, 0xa2, 0x44, 0xe0, 0x26,
	0x5a, 0xee, 0xd4, 0x9a, 0xf5, 0x81, 0xcb, 0xa0, 0x77, 0x3e, 0xed, 0x46, 0x94, 0xb6, 0x33, 0x9d,
	0x23, 0x16, 0x06, 0x2b, 0x98, 0x03, 0x37, 0x4a, 0x1b, 0x62, 0xf0, 0x2b, 0x84, 0x3b, 0xb5, 0x66,
	0xcd, 0x75, 0x1c, 0x6a, 0x48, 0x46, 0x9b, 0x0a, 0xcf, 0x6f, 0x67, 0x4a, 0xdf, 0x7b, 0x7b, 0x96,
	0x5d, 0x8f, 0xc2, 0x77, 0x03, 0xf6, 0x4e, 0xc8, 0xde, 0x94, 0x6c, 0x23, 0x8c, 0x2e, 0x70, 0x19,
	0x1e, 0xd1, 0x99, 0x01, 0xc7, 0x6d, 0x94, 0x94, 0x56, 0xdb, 0xe5, 0x54, 0xbd, 0x0a, 0x42, 0xf7,
	0xe7, 0x56, 0x51, 0xf9, 0x6c, 0xa8, 0xb4, 0x01, 0x4a, 0x32, 0x68, 0xec, 0x60, 0x05, 0x20, 0x6c,
	0xa2, 0x6b, 0x9d, 0x5a, 0xf3, 0x29, 0xb1, 0xbb, 0x3e, 0x78, 0x09, 0xc0, 0x5f, 0x5d, 0xd2, 0xec,
	0x44, 0xa5, 0x1a, 0x96, 0xa1, 0x4a, 0xf8, 0x31, 0xb1, 0xbb, 0x53, 0x0a, 0x63, 0x54, 0xfc, 0x04,
	0x25, 0xa0, 0xf9, 0xcb, 0x40, 0xaf, 0xce, 0x4d, 0x7b, 0x37, 0x24, 0xaf, 0x4d, 0x34, 0x1e, 0xe2,
	0xf1, 0x13, 0x14, 0x3f, 0xa8, 0x37, 0xd5, 0x24, 0x60, 0x3e, 0xbd, 0x24, 0xc9, 0x48, 0xab, 0x57,
	0x3d, 0x73, 0xec, 0x3c, 0x1c, 0xd4, 0x9b, 0xb8, 0x8d, 0x96, 0x0f, 0xea, 0xfe, 0x79, 0x48, 0x01,
	0xeb, 0xc1, 0x65, 0xac, 0x51, 0x56, 0xd8, 0x33, 0xa7, 0x8f, 0x44, 0x40, 0xc2, 0x4f, 0x51, 0xa2,
	0x51, 0x7b, 0xde, 0x54, 0xd1, 0xc2, 0xec, 0x62, 0xbb, 0x61, 0x99, 0x96, 0xd1, 0x1f, 0x2b, 0x53,
	0x12, 0xe4, 0x4e, 0xcb, 0x5f, 0xc8, 0x6f, 0x65, 0xc1, 0x4e, 0x8f, 0x92, 0xdb, 0x90, 0xac, 0xc9,
	0xec, 0x42, 0x90, 0xf6, 0x4f, 0x3c, 0xfa, 0x0d, 0xc1, 0x3f, 0xa2, 0x5b, 0x1d, 0x83, 0xc9, 0x2d,
	0xda, 0x67, 0xd4, 0x09, 0x5e, 0x3b, 0x58, 0x83, 0x57, 0x79, 0x15, 0x5e, 0x65, 0xdc, 0x70, 0x44,
	0x8b, 0x38, 0x3d, 0xba, 0x55, 0xde, 0xae, 0xc8, 0xf4, 0xcb, 0x52, 0x53, 0x29, 0x07, 0x8a, 0xb7,
	0xc3, 0xed, 0x77, 0x19, 0x95, 0x87, 0xd8, 0x7f, 0xa7, 0xe1, 0xa3, 0xd3, 0x9a, 0x87, 0xc7, 0xaf,
	0x50, 0xe6, 0xc0, 0x64, 0x7b, 0x86, 0xb0, 0x4e, 0xe8, 0x98, 0x6e, 0x0c, 0x74, 0xbf, 0x58, 0xac,
	0xab, 0xca, 0x6d, 0x20, 0x00, 0x98, 0x10, 0x9d, 0x4d, 0xc6, 0x02, 0xdd, 0x6c, 0x18, 0xfd, 0x59,
	0x9a, 0x71, 0xd0, 0xfc, 0x72, 0xb1, 0x66, 0x16, 0xba, 0x3b, 0x53, 0x74, 0x0e, 0x1b, 0xbf, 0x46,
	0xb7, 0xf6, 0xc5, 0x31, 0x1d, 0xcc, 0x90, 0x4d, 0x80, 0xec, 0xc3, 0xc5, 0xb2, 0x39, 0x57, 0x12,
	0x66, 0xeb, 0xce, 0xa3, 0x6b, 0x2f, 0x51, 0x66, 0xe6, 0x5d, 0x88, 0x1f, 0xa1, 0x1b, 0x13, 0x0b,
	0x8d, 0x3a, 0x6c, 0x77, 0x42, 0x5f, 0xbf, 0x38, 0xcf, 0x5f, 0xb3, 0xcc, 0xc8, 0xd1, 0x99, 0x76,
	0xd5, 0xbe, 0x9b, 0xba, 0x28, 0x9f, 0x59, 0x5c, 0xe0, 0xc7, 0x68, 0x7d, 0xc2, 0xec, 0x5f, 0x97,
	0x2b, 0xd5, 0xec, 0xdc, 0xdb, 0xb9, 0x35, 0x15, 0xa2, 0xfd, 0xa5, 0xa0, 0xf4, 0x84, 0xf1, 0xf1,
	0x09, 0x75, 0x04, 0x7e, 0x82, 0x52, 0xf0, 0x47, 0x0e, 0x27, 0x90, 0xee, 0x5a, 0x75, 0x0d, 0x46,
	0x91, 0xd0, 0xaa, 0xab, 0x17, 0xe7, 0xf9, 0x34, 0x95, 0x8f, 0x05, 0x71, 0xca, 0xa2, 0x5f, 0xa2,
	0x51, 0x28, 0x26, 0x53, 0x63, 0x52, 0x70, 0x31, 0xcf, 0x4f, 0x53, 0xbf, 0x13, 0x8c, 0x0f, 0x69,
	0xde, 0x2b, 0x04, 0xa3, 0x63, 0x04, 0x3e, 0xc9, 0xd3, 0x18, 0x52, 0x67, 0x95, 0x00, 0x6d, 0xea,
	0x4c, 0x6d, 0x0b, 0xac, 0x0d, 0x7b, 0xb5, 0x39, 0x37, 0x09, 0x70, 0x6b, 0xcd, 0x0e, 0xae, 0xfe,
	0x16, 0x9f, 0xea, 0xda, 0x1e, 0xb3, 0x0e, 0x2b, 0xf8, 0x05, 0x4a, 0x4b, 0xd9, 0xc9, 0x36, 0xe3,
	0x0c, 0xb4, 0x4e, 0x2e, 0xbd, 0x24, 0xc2, 0x38, 0xde, 0x67, 0x30, 0xa9, 0xe6, 0xe6, 0x4f, 0x65,
	0xd2, 0x55, 0xbb, 0x82, 0x0f, 0x51, 0x06, 0x02, 0xfe, 0x2b, 0x50, 0xbb, 0xbc, 0x1e, 0x9f, 0x5a,
	0x56, 0xf0, 0x0b, 0x94, 0x9d, 0x58, 0xdf, 0x67, 0x74, 0x70, 0xc0, 0x4c, 0x22, 0x28, 0x5e, 0xd0,
	0x94, 0xdc, 0xf8, 0x50, 0xab, 0x5d, 0xd9, 0x52, 0x72, 0xbf, 0x2a, 0xef, 0x7e, 0xce, 0xfe, 0xa2,
	0x4c, 0x8f, 0xc4, 0x09, 0x5b, 0xee, 0x42, 0x82, 0xb9, 0x5c, 0xe0, 0x25, 0x93, 0xda, 0x54, 0x50,
	0x1c, 0x67, 0x9e, 0xc8, 0x3d, 0x2c, 0xfd, 0x34, 0x1a, 0x56, 0x8b, 0x1d, 0xea, 0x10, 0x47, 0xbc,
	0x19, 0xb3, 0xbd, 0x20, 0x7d, 0xca, 0x19, 0x31, 0xe8, 0xb4, 0xf9, 0x8d, 0x96, 0x91, 0xe3, 0x38,
	0x0f, 0xc4, 0x4a, 0xc1, 0x21, 0xe1, 0x9f, 0xc4, 0x0e, 0x2b, 0xfa, 0xb5, 0xf7, 0x1f, 0x37, 0x95,
	0x0f, 0x1f, 0x37, 0x95, 0xbf, 0x3f, 0x6e, 0x2a, 0x4d, 0xe5, 0x68, 0x09, 0x4a, 0xd9, 0xf9, 0x37,
	0x00, 0x00, 0xff, 0xff, 0xfb, 0x44, 0x8c, 0x1a, 0x89, 0x0c, 0x00, 0x00,
}
