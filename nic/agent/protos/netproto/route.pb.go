// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: route.proto

package netproto

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "google.golang.org/genproto/googleapis/api/annotations"
import _ "github.com/pensando/sw/venice/utils/apigen/annotations"
import _ "github.com/gogo/protobuf/gogoproto"
import api "github.com/pensando/sw/api"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type BGPAddressFamily int32

const (
	BGPAddressFamily_IPv4Unicast BGPAddressFamily = 0
	BGPAddressFamily_L2vpnEvpn   BGPAddressFamily = 1
)

var BGPAddressFamily_name = map[int32]string{
	0: "IPv4Unicast",
	1: "L2vpnEvpn",
}
var BGPAddressFamily_value = map[string]int32{
	"IPv4Unicast": 0,
	"L2vpnEvpn":   1,
}

func (x BGPAddressFamily) String() string {
	return proto.EnumName(BGPAddressFamily_name, int32(x))
}
func (BGPAddressFamily) EnumDescriptor() ([]byte, []int) { return fileDescriptorRoute, []int{0} }

type RouteDistinguisher_RDType int32

const (
	RouteDistinguisher_Type0 RouteDistinguisher_RDType = 0
	RouteDistinguisher_Type1 RouteDistinguisher_RDType = 1
	RouteDistinguisher_Type2 RouteDistinguisher_RDType = 2
)

var RouteDistinguisher_RDType_name = map[int32]string{
	0: "Type0",
	1: "Type1",
	2: "Type2",
}
var RouteDistinguisher_RDType_value = map[string]int32{
	"Type0": 0,
	"Type1": 1,
	"Type2": 2,
}

func (x RouteDistinguisher_RDType) String() string {
	return proto.EnumName(RouteDistinguisher_RDType_name, int32(x))
}
func (RouteDistinguisher_RDType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorRoute, []int{0, 0}
}

type RouteDistinguisher struct {
	Type          string `protobuf:"bytes,1,opt,name=Type,proto3" json:"type,omitempty"`
	AdminValue    uint32 `protobuf:"varint,2,opt,name=AdminValue,proto3" json:"admin-value,omitempty"`
	AssignedValue uint32 `protobuf:"varint,3,opt,name=AssignedValue,proto3" json:"assigned-value,omitempty"`
}

func (m *RouteDistinguisher) Reset()                    { *m = RouteDistinguisher{} }
func (m *RouteDistinguisher) String() string            { return proto.CompactTextString(m) }
func (*RouteDistinguisher) ProtoMessage()               {}
func (*RouteDistinguisher) Descriptor() ([]byte, []int) { return fileDescriptorRoute, []int{0} }

func (m *RouteDistinguisher) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *RouteDistinguisher) GetAdminValue() uint32 {
	if m != nil {
		return m.AdminValue
	}
	return 0
}

func (m *RouteDistinguisher) GetAssignedValue() uint32 {
	if m != nil {
		return m.AssignedValue
	}
	return 0
}

type RDSpec struct {
	AddressFamily string                `protobuf:"bytes,1,opt,name=AddressFamily,proto3" json:"address-family,omitempty"`
	RDAuto        bool                  `protobuf:"varint,2,opt,name=RDAuto,proto3" json:"rd-auto,omitempty"`
	RD            *RouteDistinguisher   `protobuf:"bytes,3,opt,name=RD" json:"rd,omitempty"`
	ExportRTs     []*RouteDistinguisher `protobuf:"bytes,4,rep,name=ExportRTs" json:"rt-export,omitempty"`
	ImportRTs     []*RouteDistinguisher `protobuf:"bytes,5,rep,name=ImportRTs" json:"rt-import,omitempty"`
}

func (m *RDSpec) Reset()                    { *m = RDSpec{} }
func (m *RDSpec) String() string            { return proto.CompactTextString(m) }
func (*RDSpec) ProtoMessage()               {}
func (*RDSpec) Descriptor() ([]byte, []int) { return fileDescriptorRoute, []int{1} }

func (m *RDSpec) GetAddressFamily() string {
	if m != nil {
		return m.AddressFamily
	}
	return ""
}

func (m *RDSpec) GetRDAuto() bool {
	if m != nil {
		return m.RDAuto
	}
	return false
}

func (m *RDSpec) GetRD() *RouteDistinguisher {
	if m != nil {
		return m.RD
	}
	return nil
}

func (m *RDSpec) GetExportRTs() []*RouteDistinguisher {
	if m != nil {
		return m.ExportRTs
	}
	return nil
}

func (m *RDSpec) GetImportRTs() []*RouteDistinguisher {
	if m != nil {
		return m.ImportRTs
	}
	return nil
}

type Route struct {
	Prefix              string `protobuf:"bytes,1,opt,name=Prefix,proto3" json:"prefix,omitempty"`
	NexhHop             string `protobuf:"bytes,2,opt,name=NexhHop,proto3" json:"next-hop,omitempty"`
	TargetVirtualRouter string `protobuf:"bytes,3,opt,name=TargetVirtualRouter,proto3" json:"target-virtual-router,omitempty"`
}

func (m *Route) Reset()                    { *m = Route{} }
func (m *Route) String() string            { return proto.CompactTextString(m) }
func (*Route) ProtoMessage()               {}
func (*Route) Descriptor() ([]byte, []int) { return fileDescriptorRoute, []int{2} }

func (m *Route) GetPrefix() string {
	if m != nil {
		return m.Prefix
	}
	return ""
}

func (m *Route) GetNexhHop() string {
	if m != nil {
		return m.NexhHop
	}
	return ""
}

func (m *Route) GetTargetVirtualRouter() string {
	if m != nil {
		return m.TargetVirtualRouter
	}
	return ""
}

type RouteTableSpec struct {
}

func (m *RouteTableSpec) Reset()                    { *m = RouteTableSpec{} }
func (m *RouteTableSpec) String() string            { return proto.CompactTextString(m) }
func (*RouteTableSpec) ProtoMessage()               {}
func (*RouteTableSpec) Descriptor() ([]byte, []int) { return fileDescriptorRoute, []int{3} }

type RouteTableStatus struct {
	Routes []*Route `protobuf:"bytes,1,rep,name=Routes" json:"routes,omitempty"`
}

func (m *RouteTableStatus) Reset()                    { *m = RouteTableStatus{} }
func (m *RouteTableStatus) String() string            { return proto.CompactTextString(m) }
func (*RouteTableStatus) ProtoMessage()               {}
func (*RouteTableStatus) Descriptor() ([]byte, []int) { return fileDescriptorRoute, []int{4} }

func (m *RouteTableStatus) GetRoutes() []*Route {
	if m != nil {
		return m.Routes
	}
	return nil
}

type RouteTable struct {
	api.TypeMeta   `protobuf:"bytes,1,opt,name=TypeMeta,embedded=TypeMeta" json:",inline"`
	api.ObjectMeta `protobuf:"bytes,2,opt,name=ObjectMeta,embedded=ObjectMeta" json:"meta,omitempty"`
	Spec           RouteTableSpec   `protobuf:"bytes,3,opt,name=Spec" json:"spec,omitempty"`
	Status         RouteTableStatus `protobuf:"bytes,4,opt,name=Status" json:"status,omitempty"`
}

func (m *RouteTable) Reset()                    { *m = RouteTable{} }
func (m *RouteTable) String() string            { return proto.CompactTextString(m) }
func (*RouteTable) ProtoMessage()               {}
func (*RouteTable) Descriptor() ([]byte, []int) { return fileDescriptorRoute, []int{5} }

func (m *RouteTable) GetSpec() RouteTableSpec {
	if m != nil {
		return m.Spec
	}
	return RouteTableSpec{}
}

func (m *RouteTable) GetStatus() RouteTableStatus {
	if m != nil {
		return m.Status
	}
	return RouteTableStatus{}
}

type RouteTableEvent struct {
	EventType  api.EventType `protobuf:"varint,1,opt,name=EventType,proto3,enum=api.EventType" json:"event-type,omitempty"`
	RouteTable RouteTable    `protobuf:"bytes,2,opt,name=RouteTable" json:"route-table,omitempty"`
}

func (m *RouteTableEvent) Reset()                    { *m = RouteTableEvent{} }
func (m *RouteTableEvent) String() string            { return proto.CompactTextString(m) }
func (*RouteTableEvent) ProtoMessage()               {}
func (*RouteTableEvent) Descriptor() ([]byte, []int) { return fileDescriptorRoute, []int{6} }

func (m *RouteTableEvent) GetEventType() api.EventType {
	if m != nil {
		return m.EventType
	}
	return api.EventType_CreateEvent
}

func (m *RouteTableEvent) GetRouteTable() RouteTable {
	if m != nil {
		return m.RouteTable
	}
	return RouteTable{}
}

type RouteTableEventList struct {
	RouteTableEvents []*RouteTableEvent `protobuf:"bytes,1,rep,name=routeTableEvents" json:"routeTableEvents,omitempty"`
}

func (m *RouteTableEventList) Reset()                    { *m = RouteTableEventList{} }
func (m *RouteTableEventList) String() string            { return proto.CompactTextString(m) }
func (*RouteTableEventList) ProtoMessage()               {}
func (*RouteTableEventList) Descriptor() ([]byte, []int) { return fileDescriptorRoute, []int{7} }

func (m *RouteTableEventList) GetRouteTableEvents() []*RouteTableEvent {
	if m != nil {
		return m.RouteTableEvents
	}
	return nil
}

type RouteTableList struct {
	RouteTables []*RouteTable `protobuf:"bytes,1,rep,name=routeTables" json:"routeTables,omitempty"`
}

func (m *RouteTableList) Reset()                    { *m = RouteTableList{} }
func (m *RouteTableList) String() string            { return proto.CompactTextString(m) }
func (*RouteTableList) ProtoMessage()               {}
func (*RouteTableList) Descriptor() ([]byte, []int) { return fileDescriptorRoute, []int{8} }

func (m *RouteTableList) GetRouteTables() []*RouteTable {
	if m != nil {
		return m.RouteTables
	}
	return nil
}

type EVPNConfig struct {
	Shutdown bool `protobuf:"varint,1,opt,name=Shutdown,proto3" json:"shutdown,omitempty"`
}

func (m *EVPNConfig) Reset()                    { *m = EVPNConfig{} }
func (m *EVPNConfig) String() string            { return proto.CompactTextString(m) }
func (*EVPNConfig) ProtoMessage()               {}
func (*EVPNConfig) Descriptor() ([]byte, []int) { return fileDescriptorRoute, []int{9} }

func (m *EVPNConfig) GetShutdown() bool {
	if m != nil {
		return m.Shutdown
	}
	return false
}

type BGPNeighbor struct {
	Shutdown              bool     `protobuf:"varint,1,opt,name=Shutdown,proto3" json:"shutdown,omitempty"`
	IPAddress             string   `protobuf:"bytes,2,opt,name=IPAddress,proto3" json:"ip-address,omitempty"`
	RemoteAS              uint32   `protobuf:"varint,3,opt,name=RemoteAS,proto3" json:"remote-as,omitempty"`
	MultiHop              uint32   `protobuf:"varint,4,opt,name=MultiHop,proto3" json:"multi-hop,omitempty"`
	EnableAddressFamilies []string `protobuf:"bytes,5,rep,name=EnableAddressFamilies" json:"enable-address-families,omitempty"`
	Password              string   `protobuf:"bytes,6,opt,name=Password,proto3" json:"password,omitempty"`
	DSCAutoConfig         bool     `protobuf:"varint,7,opt,name=DSCAutoConfig,proto3" json:"dsc-auto-config,omitempty"`
}

func (m *BGPNeighbor) Reset()                    { *m = BGPNeighbor{} }
func (m *BGPNeighbor) String() string            { return proto.CompactTextString(m) }
func (*BGPNeighbor) ProtoMessage()               {}
func (*BGPNeighbor) Descriptor() ([]byte, []int) { return fileDescriptorRoute, []int{10} }

func (m *BGPNeighbor) GetShutdown() bool {
	if m != nil {
		return m.Shutdown
	}
	return false
}

func (m *BGPNeighbor) GetIPAddress() string {
	if m != nil {
		return m.IPAddress
	}
	return ""
}

func (m *BGPNeighbor) GetRemoteAS() uint32 {
	if m != nil {
		return m.RemoteAS
	}
	return 0
}

func (m *BGPNeighbor) GetMultiHop() uint32 {
	if m != nil {
		return m.MultiHop
	}
	return 0
}

func (m *BGPNeighbor) GetEnableAddressFamilies() []string {
	if m != nil {
		return m.EnableAddressFamilies
	}
	return nil
}

func (m *BGPNeighbor) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

func (m *BGPNeighbor) GetDSCAutoConfig() bool {
	if m != nil {
		return m.DSCAutoConfig
	}
	return false
}

type BGPConfig struct {
	RouterId          string         `protobuf:"bytes,1,opt,name=RouterId,proto3" json:"router-id,omitempty"`
	ASNumber          uint32         `protobuf:"varint,2,opt,name=ASNumber,proto3" json:"as-number,omitempty"`
	Neighbors         []*BGPNeighbor `protobuf:"bytes,3,rep,name=Neighbors" json:"neighbors,omitempty"`
	KeepaliveInterval uint32         `protobuf:"varint,4,opt,name=KeepaliveInterval,proto3" json:"keepalive-interval,omitempty"`
	Holdtime          uint32         `protobuf:"varint,5,opt,name=Holdtime,proto3" json:"holdtime,omitempty"`
	DSCAutoConfig     bool           `protobuf:"varint,6,opt,name=DSCAutoConfig,proto3" json:"dsc-auto-config,omitempty"`
}

func (m *BGPConfig) Reset()                    { *m = BGPConfig{} }
func (m *BGPConfig) String() string            { return proto.CompactTextString(m) }
func (*BGPConfig) ProtoMessage()               {}
func (*BGPConfig) Descriptor() ([]byte, []int) { return fileDescriptorRoute, []int{11} }

func (m *BGPConfig) GetRouterId() string {
	if m != nil {
		return m.RouterId
	}
	return ""
}

func (m *BGPConfig) GetASNumber() uint32 {
	if m != nil {
		return m.ASNumber
	}
	return 0
}

func (m *BGPConfig) GetNeighbors() []*BGPNeighbor {
	if m != nil {
		return m.Neighbors
	}
	return nil
}

func (m *BGPConfig) GetKeepaliveInterval() uint32 {
	if m != nil {
		return m.KeepaliveInterval
	}
	return 0
}

func (m *BGPConfig) GetHoldtime() uint32 {
	if m != nil {
		return m.Holdtime
	}
	return 0
}

func (m *BGPConfig) GetDSCAutoConfig() bool {
	if m != nil {
		return m.DSCAutoConfig
	}
	return false
}

type RoutingConfigSpec struct {
	BGPConfig  *BGPConfig  `protobuf:"bytes,1,opt,name=BGPConfig" json:"bgp-config,omitempty"`
	EVPNConfig *EVPNConfig `protobuf:"bytes,2,opt,name=EVPNConfig" json:"evpn-config,omitempty"`
}

func (m *RoutingConfigSpec) Reset()                    { *m = RoutingConfigSpec{} }
func (m *RoutingConfigSpec) String() string            { return proto.CompactTextString(m) }
func (*RoutingConfigSpec) ProtoMessage()               {}
func (*RoutingConfigSpec) Descriptor() ([]byte, []int) { return fileDescriptorRoute, []int{12} }

func (m *RoutingConfigSpec) GetBGPConfig() *BGPConfig {
	if m != nil {
		return m.BGPConfig
	}
	return nil
}

func (m *RoutingConfigSpec) GetEVPNConfig() *EVPNConfig {
	if m != nil {
		return m.EVPNConfig
	}
	return nil
}

type RoutingConfigStatus struct {
}

func (m *RoutingConfigStatus) Reset()                    { *m = RoutingConfigStatus{} }
func (m *RoutingConfigStatus) String() string            { return proto.CompactTextString(m) }
func (*RoutingConfigStatus) ProtoMessage()               {}
func (*RoutingConfigStatus) Descriptor() ([]byte, []int) { return fileDescriptorRoute, []int{13} }

type RoutingConfigEvent struct {
	EventType     api.EventType `protobuf:"varint,1,opt,name=EventType,proto3,enum=api.EventType" json:"event-type,omitempty"`
	RoutingConfig RoutingConfig `protobuf:"bytes,2,opt,name=RoutingConfig" json:"routing-config,omitempty"`
}

func (m *RoutingConfigEvent) Reset()                    { *m = RoutingConfigEvent{} }
func (m *RoutingConfigEvent) String() string            { return proto.CompactTextString(m) }
func (*RoutingConfigEvent) ProtoMessage()               {}
func (*RoutingConfigEvent) Descriptor() ([]byte, []int) { return fileDescriptorRoute, []int{14} }

func (m *RoutingConfigEvent) GetEventType() api.EventType {
	if m != nil {
		return m.EventType
	}
	return api.EventType_CreateEvent
}

func (m *RoutingConfigEvent) GetRoutingConfig() RoutingConfig {
	if m != nil {
		return m.RoutingConfig
	}
	return RoutingConfig{}
}

type RoutingConfigEventList struct {
	RoutingConfigEvents []*RoutingConfigEvent `protobuf:"bytes,1,rep,name=routingConfigEvents" json:"routingConfigEvents,omitempty"`
}

func (m *RoutingConfigEventList) Reset()                    { *m = RoutingConfigEventList{} }
func (m *RoutingConfigEventList) String() string            { return proto.CompactTextString(m) }
func (*RoutingConfigEventList) ProtoMessage()               {}
func (*RoutingConfigEventList) Descriptor() ([]byte, []int) { return fileDescriptorRoute, []int{15} }

func (m *RoutingConfigEventList) GetRoutingConfigEvents() []*RoutingConfigEvent {
	if m != nil {
		return m.RoutingConfigEvents
	}
	return nil
}

type RoutingConfigList struct {
	RoutingConfigs []*RoutingConfig `protobuf:"bytes,1,rep,name=routingConfigs" json:"routingConfigs,omitempty"`
}

func (m *RoutingConfigList) Reset()                    { *m = RoutingConfigList{} }
func (m *RoutingConfigList) String() string            { return proto.CompactTextString(m) }
func (*RoutingConfigList) ProtoMessage()               {}
func (*RoutingConfigList) Descriptor() ([]byte, []int) { return fileDescriptorRoute, []int{16} }

func (m *RoutingConfigList) GetRoutingConfigs() []*RoutingConfig {
	if m != nil {
		return m.RoutingConfigs
	}
	return nil
}

type RoutingConfig struct {
	api.TypeMeta   `protobuf:"bytes,1,opt,name=TypeMeta,embedded=TypeMeta" json:",inline"`
	api.ObjectMeta `protobuf:"bytes,2,opt,name=ObjectMeta,embedded=ObjectMeta" json:"meta,omitempty"`
	Spec           RoutingConfigSpec   `protobuf:"bytes,3,opt,name=Spec" json:"spec,omitempty"`
	Status         RoutingConfigStatus `protobuf:"bytes,4,opt,name=Status" json:"status,omitempty"`
}

func (m *RoutingConfig) Reset()                    { *m = RoutingConfig{} }
func (m *RoutingConfig) String() string            { return proto.CompactTextString(m) }
func (*RoutingConfig) ProtoMessage()               {}
func (*RoutingConfig) Descriptor() ([]byte, []int) { return fileDescriptorRoute, []int{17} }

func (m *RoutingConfig) GetSpec() RoutingConfigSpec {
	if m != nil {
		return m.Spec
	}
	return RoutingConfigSpec{}
}

func (m *RoutingConfig) GetStatus() RoutingConfigStatus {
	if m != nil {
		return m.Status
	}
	return RoutingConfigStatus{}
}

func init() {
	proto.RegisterType((*RouteDistinguisher)(nil), "netproto.RouteDistinguisher")
	proto.RegisterType((*RDSpec)(nil), "netproto.RDSpec")
	proto.RegisterType((*Route)(nil), "netproto.Route")
	proto.RegisterType((*RouteTableSpec)(nil), "netproto.RouteTableSpec")
	proto.RegisterType((*RouteTableStatus)(nil), "netproto.RouteTableStatus")
	proto.RegisterType((*RouteTable)(nil), "netproto.RouteTable")
	proto.RegisterType((*RouteTableEvent)(nil), "netproto.RouteTableEvent")
	proto.RegisterType((*RouteTableEventList)(nil), "netproto.RouteTableEventList")
	proto.RegisterType((*RouteTableList)(nil), "netproto.RouteTableList")
	proto.RegisterType((*EVPNConfig)(nil), "netproto.EVPNConfig")
	proto.RegisterType((*BGPNeighbor)(nil), "netproto.BGPNeighbor")
	proto.RegisterType((*BGPConfig)(nil), "netproto.BGPConfig")
	proto.RegisterType((*RoutingConfigSpec)(nil), "netproto.RoutingConfigSpec")
	proto.RegisterType((*RoutingConfigStatus)(nil), "netproto.RoutingConfigStatus")
	proto.RegisterType((*RoutingConfigEvent)(nil), "netproto.RoutingConfigEvent")
	proto.RegisterType((*RoutingConfigEventList)(nil), "netproto.RoutingConfigEventList")
	proto.RegisterType((*RoutingConfigList)(nil), "netproto.RoutingConfigList")
	proto.RegisterType((*RoutingConfig)(nil), "netproto.RoutingConfig")
	proto.RegisterEnum("netproto.BGPAddressFamily", BGPAddressFamily_name, BGPAddressFamily_value)
	proto.RegisterEnum("netproto.RouteDistinguisher_RDType", RouteDistinguisher_RDType_name, RouteDistinguisher_RDType_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for RoutingConfigApiV1 service

type RoutingConfigApiV1Client interface {
	ListRoutingConfigs(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (*RoutingConfigList, error)
	WatchRoutingConfigs(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (RoutingConfigApiV1_WatchRoutingConfigsClient, error)
	RoutingConfigOperUpdate(ctx context.Context, opts ...grpc.CallOption) (RoutingConfigApiV1_RoutingConfigOperUpdateClient, error)
}

type routingConfigApiV1Client struct {
	cc *grpc.ClientConn
}

func NewRoutingConfigApiV1Client(cc *grpc.ClientConn) RoutingConfigApiV1Client {
	return &routingConfigApiV1Client{cc}
}

func (c *routingConfigApiV1Client) ListRoutingConfigs(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (*RoutingConfigList, error) {
	out := new(RoutingConfigList)
	err := grpc.Invoke(ctx, "/netproto.RoutingConfigApiV1/ListRoutingConfigs", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routingConfigApiV1Client) WatchRoutingConfigs(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (RoutingConfigApiV1_WatchRoutingConfigsClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_RoutingConfigApiV1_serviceDesc.Streams[0], c.cc, "/netproto.RoutingConfigApiV1/WatchRoutingConfigs", opts...)
	if err != nil {
		return nil, err
	}
	x := &routingConfigApiV1WatchRoutingConfigsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type RoutingConfigApiV1_WatchRoutingConfigsClient interface {
	Recv() (*RoutingConfigEventList, error)
	grpc.ClientStream
}

type routingConfigApiV1WatchRoutingConfigsClient struct {
	grpc.ClientStream
}

func (x *routingConfigApiV1WatchRoutingConfigsClient) Recv() (*RoutingConfigEventList, error) {
	m := new(RoutingConfigEventList)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *routingConfigApiV1Client) RoutingConfigOperUpdate(ctx context.Context, opts ...grpc.CallOption) (RoutingConfigApiV1_RoutingConfigOperUpdateClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_RoutingConfigApiV1_serviceDesc.Streams[1], c.cc, "/netproto.RoutingConfigApiV1/RoutingConfigOperUpdate", opts...)
	if err != nil {
		return nil, err
	}
	x := &routingConfigApiV1RoutingConfigOperUpdateClient{stream}
	return x, nil
}

type RoutingConfigApiV1_RoutingConfigOperUpdateClient interface {
	Send(*RoutingConfigEvent) error
	CloseAndRecv() (*api.TypeMeta, error)
	grpc.ClientStream
}

type routingConfigApiV1RoutingConfigOperUpdateClient struct {
	grpc.ClientStream
}

func (x *routingConfigApiV1RoutingConfigOperUpdateClient) Send(m *RoutingConfigEvent) error {
	return x.ClientStream.SendMsg(m)
}

func (x *routingConfigApiV1RoutingConfigOperUpdateClient) CloseAndRecv() (*api.TypeMeta, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(api.TypeMeta)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for RoutingConfigApiV1 service

type RoutingConfigApiV1Server interface {
	ListRoutingConfigs(context.Context, *api.ListWatchOptions) (*RoutingConfigList, error)
	WatchRoutingConfigs(*api.ListWatchOptions, RoutingConfigApiV1_WatchRoutingConfigsServer) error
	RoutingConfigOperUpdate(RoutingConfigApiV1_RoutingConfigOperUpdateServer) error
}

func RegisterRoutingConfigApiV1Server(s *grpc.Server, srv RoutingConfigApiV1Server) {
	s.RegisterService(&_RoutingConfigApiV1_serviceDesc, srv)
}

func _RoutingConfigApiV1_ListRoutingConfigs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(api.ListWatchOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoutingConfigApiV1Server).ListRoutingConfigs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/netproto.RoutingConfigApiV1/ListRoutingConfigs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoutingConfigApiV1Server).ListRoutingConfigs(ctx, req.(*api.ListWatchOptions))
	}
	return interceptor(ctx, in, info, handler)
}

func _RoutingConfigApiV1_WatchRoutingConfigs_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(api.ListWatchOptions)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(RoutingConfigApiV1Server).WatchRoutingConfigs(m, &routingConfigApiV1WatchRoutingConfigsServer{stream})
}

type RoutingConfigApiV1_WatchRoutingConfigsServer interface {
	Send(*RoutingConfigEventList) error
	grpc.ServerStream
}

type routingConfigApiV1WatchRoutingConfigsServer struct {
	grpc.ServerStream
}

func (x *routingConfigApiV1WatchRoutingConfigsServer) Send(m *RoutingConfigEventList) error {
	return x.ServerStream.SendMsg(m)
}

func _RoutingConfigApiV1_RoutingConfigOperUpdate_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(RoutingConfigApiV1Server).RoutingConfigOperUpdate(&routingConfigApiV1RoutingConfigOperUpdateServer{stream})
}

type RoutingConfigApiV1_RoutingConfigOperUpdateServer interface {
	SendAndClose(*api.TypeMeta) error
	Recv() (*RoutingConfigEvent, error)
	grpc.ServerStream
}

type routingConfigApiV1RoutingConfigOperUpdateServer struct {
	grpc.ServerStream
}

func (x *routingConfigApiV1RoutingConfigOperUpdateServer) SendAndClose(m *api.TypeMeta) error {
	return x.ServerStream.SendMsg(m)
}

func (x *routingConfigApiV1RoutingConfigOperUpdateServer) Recv() (*RoutingConfigEvent, error) {
	m := new(RoutingConfigEvent)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _RoutingConfigApiV1_serviceDesc = grpc.ServiceDesc{
	ServiceName: "netproto.RoutingConfigApiV1",
	HandlerType: (*RoutingConfigApiV1Server)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListRoutingConfigs",
			Handler:    _RoutingConfigApiV1_ListRoutingConfigs_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "WatchRoutingConfigs",
			Handler:       _RoutingConfigApiV1_WatchRoutingConfigs_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "RoutingConfigOperUpdate",
			Handler:       _RoutingConfigApiV1_RoutingConfigOperUpdate_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "route.proto",
}

// Client API for RouteTableApiV1 service

type RouteTableApiV1Client interface {
	ListRouteTables(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (*RouteTableList, error)
	WatchRouteTables(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (RouteTableApiV1_WatchRouteTablesClient, error)
	RouteTableOperUpdate(ctx context.Context, opts ...grpc.CallOption) (RouteTableApiV1_RouteTableOperUpdateClient, error)
}

type routeTableApiV1Client struct {
	cc *grpc.ClientConn
}

func NewRouteTableApiV1Client(cc *grpc.ClientConn) RouteTableApiV1Client {
	return &routeTableApiV1Client{cc}
}

func (c *routeTableApiV1Client) ListRouteTables(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (*RouteTableList, error) {
	out := new(RouteTableList)
	err := grpc.Invoke(ctx, "/netproto.RouteTableApiV1/ListRouteTables", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routeTableApiV1Client) WatchRouteTables(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (RouteTableApiV1_WatchRouteTablesClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_RouteTableApiV1_serviceDesc.Streams[0], c.cc, "/netproto.RouteTableApiV1/WatchRouteTables", opts...)
	if err != nil {
		return nil, err
	}
	x := &routeTableApiV1WatchRouteTablesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type RouteTableApiV1_WatchRouteTablesClient interface {
	Recv() (*RouteTableEventList, error)
	grpc.ClientStream
}

type routeTableApiV1WatchRouteTablesClient struct {
	grpc.ClientStream
}

func (x *routeTableApiV1WatchRouteTablesClient) Recv() (*RouteTableEventList, error) {
	m := new(RouteTableEventList)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *routeTableApiV1Client) RouteTableOperUpdate(ctx context.Context, opts ...grpc.CallOption) (RouteTableApiV1_RouteTableOperUpdateClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_RouteTableApiV1_serviceDesc.Streams[1], c.cc, "/netproto.RouteTableApiV1/RouteTableOperUpdate", opts...)
	if err != nil {
		return nil, err
	}
	x := &routeTableApiV1RouteTableOperUpdateClient{stream}
	return x, nil
}

type RouteTableApiV1_RouteTableOperUpdateClient interface {
	Send(*RouteTableEvent) error
	CloseAndRecv() (*api.TypeMeta, error)
	grpc.ClientStream
}

type routeTableApiV1RouteTableOperUpdateClient struct {
	grpc.ClientStream
}

func (x *routeTableApiV1RouteTableOperUpdateClient) Send(m *RouteTableEvent) error {
	return x.ClientStream.SendMsg(m)
}

func (x *routeTableApiV1RouteTableOperUpdateClient) CloseAndRecv() (*api.TypeMeta, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(api.TypeMeta)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for RouteTableApiV1 service

type RouteTableApiV1Server interface {
	ListRouteTables(context.Context, *api.ListWatchOptions) (*RouteTableList, error)
	WatchRouteTables(*api.ListWatchOptions, RouteTableApiV1_WatchRouteTablesServer) error
	RouteTableOperUpdate(RouteTableApiV1_RouteTableOperUpdateServer) error
}

func RegisterRouteTableApiV1Server(s *grpc.Server, srv RouteTableApiV1Server) {
	s.RegisterService(&_RouteTableApiV1_serviceDesc, srv)
}

func _RouteTableApiV1_ListRouteTables_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(api.ListWatchOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RouteTableApiV1Server).ListRouteTables(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/netproto.RouteTableApiV1/ListRouteTables",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RouteTableApiV1Server).ListRouteTables(ctx, req.(*api.ListWatchOptions))
	}
	return interceptor(ctx, in, info, handler)
}

func _RouteTableApiV1_WatchRouteTables_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(api.ListWatchOptions)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(RouteTableApiV1Server).WatchRouteTables(m, &routeTableApiV1WatchRouteTablesServer{stream})
}

type RouteTableApiV1_WatchRouteTablesServer interface {
	Send(*RouteTableEventList) error
	grpc.ServerStream
}

type routeTableApiV1WatchRouteTablesServer struct {
	grpc.ServerStream
}

func (x *routeTableApiV1WatchRouteTablesServer) Send(m *RouteTableEventList) error {
	return x.ServerStream.SendMsg(m)
}

func _RouteTableApiV1_RouteTableOperUpdate_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(RouteTableApiV1Server).RouteTableOperUpdate(&routeTableApiV1RouteTableOperUpdateServer{stream})
}

type RouteTableApiV1_RouteTableOperUpdateServer interface {
	SendAndClose(*api.TypeMeta) error
	Recv() (*RouteTableEvent, error)
	grpc.ServerStream
}

type routeTableApiV1RouteTableOperUpdateServer struct {
	grpc.ServerStream
}

func (x *routeTableApiV1RouteTableOperUpdateServer) SendAndClose(m *api.TypeMeta) error {
	return x.ServerStream.SendMsg(m)
}

func (x *routeTableApiV1RouteTableOperUpdateServer) Recv() (*RouteTableEvent, error) {
	m := new(RouteTableEvent)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _RouteTableApiV1_serviceDesc = grpc.ServiceDesc{
	ServiceName: "netproto.RouteTableApiV1",
	HandlerType: (*RouteTableApiV1Server)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListRouteTables",
			Handler:    _RouteTableApiV1_ListRouteTables_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "WatchRouteTables",
			Handler:       _RouteTableApiV1_WatchRouteTables_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "RouteTableOperUpdate",
			Handler:       _RouteTableApiV1_RouteTableOperUpdate_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "route.proto",
}

func (m *RouteDistinguisher) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouteDistinguisher) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRoute(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if m.AdminValue != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRoute(dAtA, i, uint64(m.AdminValue))
	}
	if m.AssignedValue != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintRoute(dAtA, i, uint64(m.AssignedValue))
	}
	return i, nil
}

func (m *RDSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RDSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AddressFamily) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRoute(dAtA, i, uint64(len(m.AddressFamily)))
		i += copy(dAtA[i:], m.AddressFamily)
	}
	if m.RDAuto {
		dAtA[i] = 0x10
		i++
		if m.RDAuto {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.RD != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintRoute(dAtA, i, uint64(m.RD.Size()))
		n1, err := m.RD.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if len(m.ExportRTs) > 0 {
		for _, msg := range m.ExportRTs {
			dAtA[i] = 0x22
			i++
			i = encodeVarintRoute(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.ImportRTs) > 0 {
		for _, msg := range m.ImportRTs {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintRoute(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Route) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Route) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Prefix) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRoute(dAtA, i, uint64(len(m.Prefix)))
		i += copy(dAtA[i:], m.Prefix)
	}
	if len(m.NexhHop) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRoute(dAtA, i, uint64(len(m.NexhHop)))
		i += copy(dAtA[i:], m.NexhHop)
	}
	if len(m.TargetVirtualRouter) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintRoute(dAtA, i, uint64(len(m.TargetVirtualRouter)))
		i += copy(dAtA[i:], m.TargetVirtualRouter)
	}
	return i, nil
}

func (m *RouteTableSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouteTableSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *RouteTableStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouteTableStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Routes) > 0 {
		for _, msg := range m.Routes {
			dAtA[i] = 0xa
			i++
			i = encodeVarintRoute(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *RouteTable) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouteTable) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintRoute(dAtA, i, uint64(m.TypeMeta.Size()))
	n2, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n2
	dAtA[i] = 0x12
	i++
	i = encodeVarintRoute(dAtA, i, uint64(m.ObjectMeta.Size()))
	n3, err := m.ObjectMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n3
	dAtA[i] = 0x1a
	i++
	i = encodeVarintRoute(dAtA, i, uint64(m.Spec.Size()))
	n4, err := m.Spec.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n4
	dAtA[i] = 0x22
	i++
	i = encodeVarintRoute(dAtA, i, uint64(m.Status.Size()))
	n5, err := m.Status.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n5
	return i, nil
}

func (m *RouteTableEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouteTableEvent) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.EventType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRoute(dAtA, i, uint64(m.EventType))
	}
	dAtA[i] = 0x12
	i++
	i = encodeVarintRoute(dAtA, i, uint64(m.RouteTable.Size()))
	n6, err := m.RouteTable.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n6
	return i, nil
}

func (m *RouteTableEventList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouteTableEventList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RouteTableEvents) > 0 {
		for _, msg := range m.RouteTableEvents {
			dAtA[i] = 0xa
			i++
			i = encodeVarintRoute(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *RouteTableList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouteTableList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RouteTables) > 0 {
		for _, msg := range m.RouteTables {
			dAtA[i] = 0xa
			i++
			i = encodeVarintRoute(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *EVPNConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EVPNConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Shutdown {
		dAtA[i] = 0x8
		i++
		if m.Shutdown {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *BGPNeighbor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPNeighbor) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Shutdown {
		dAtA[i] = 0x8
		i++
		if m.Shutdown {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.IPAddress) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRoute(dAtA, i, uint64(len(m.IPAddress)))
		i += copy(dAtA[i:], m.IPAddress)
	}
	if m.RemoteAS != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintRoute(dAtA, i, uint64(m.RemoteAS))
	}
	if m.MultiHop != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintRoute(dAtA, i, uint64(m.MultiHop))
	}
	if len(m.EnableAddressFamilies) > 0 {
		for _, s := range m.EnableAddressFamilies {
			dAtA[i] = 0x2a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Password) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintRoute(dAtA, i, uint64(len(m.Password)))
		i += copy(dAtA[i:], m.Password)
	}
	if m.DSCAutoConfig {
		dAtA[i] = 0x38
		i++
		if m.DSCAutoConfig {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *BGPConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RouterId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRoute(dAtA, i, uint64(len(m.RouterId)))
		i += copy(dAtA[i:], m.RouterId)
	}
	if m.ASNumber != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRoute(dAtA, i, uint64(m.ASNumber))
	}
	if len(m.Neighbors) > 0 {
		for _, msg := range m.Neighbors {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintRoute(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.KeepaliveInterval != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintRoute(dAtA, i, uint64(m.KeepaliveInterval))
	}
	if m.Holdtime != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintRoute(dAtA, i, uint64(m.Holdtime))
	}
	if m.DSCAutoConfig {
		dAtA[i] = 0x30
		i++
		if m.DSCAutoConfig {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *RoutingConfigSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoutingConfigSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.BGPConfig != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRoute(dAtA, i, uint64(m.BGPConfig.Size()))
		n7, err := m.BGPConfig.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.EVPNConfig != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRoute(dAtA, i, uint64(m.EVPNConfig.Size()))
		n8, err := m.EVPNConfig.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	return i, nil
}

func (m *RoutingConfigStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoutingConfigStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *RoutingConfigEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoutingConfigEvent) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.EventType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRoute(dAtA, i, uint64(m.EventType))
	}
	dAtA[i] = 0x12
	i++
	i = encodeVarintRoute(dAtA, i, uint64(m.RoutingConfig.Size()))
	n9, err := m.RoutingConfig.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n9
	return i, nil
}

func (m *RoutingConfigEventList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoutingConfigEventList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RoutingConfigEvents) > 0 {
		for _, msg := range m.RoutingConfigEvents {
			dAtA[i] = 0xa
			i++
			i = encodeVarintRoute(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *RoutingConfigList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoutingConfigList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RoutingConfigs) > 0 {
		for _, msg := range m.RoutingConfigs {
			dAtA[i] = 0xa
			i++
			i = encodeVarintRoute(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *RoutingConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoutingConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintRoute(dAtA, i, uint64(m.TypeMeta.Size()))
	n10, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n10
	dAtA[i] = 0x12
	i++
	i = encodeVarintRoute(dAtA, i, uint64(m.ObjectMeta.Size()))
	n11, err := m.ObjectMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n11
	dAtA[i] = 0x1a
	i++
	i = encodeVarintRoute(dAtA, i, uint64(m.Spec.Size()))
	n12, err := m.Spec.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n12
	dAtA[i] = 0x22
	i++
	i = encodeVarintRoute(dAtA, i, uint64(m.Status.Size()))
	n13, err := m.Status.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n13
	return i, nil
}

func encodeVarintRoute(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *RouteDistinguisher) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovRoute(uint64(l))
	}
	if m.AdminValue != 0 {
		n += 1 + sovRoute(uint64(m.AdminValue))
	}
	if m.AssignedValue != 0 {
		n += 1 + sovRoute(uint64(m.AssignedValue))
	}
	return n
}

func (m *RDSpec) Size() (n int) {
	var l int
	_ = l
	l = len(m.AddressFamily)
	if l > 0 {
		n += 1 + l + sovRoute(uint64(l))
	}
	if m.RDAuto {
		n += 2
	}
	if m.RD != nil {
		l = m.RD.Size()
		n += 1 + l + sovRoute(uint64(l))
	}
	if len(m.ExportRTs) > 0 {
		for _, e := range m.ExportRTs {
			l = e.Size()
			n += 1 + l + sovRoute(uint64(l))
		}
	}
	if len(m.ImportRTs) > 0 {
		for _, e := range m.ImportRTs {
			l = e.Size()
			n += 1 + l + sovRoute(uint64(l))
		}
	}
	return n
}

func (m *Route) Size() (n int) {
	var l int
	_ = l
	l = len(m.Prefix)
	if l > 0 {
		n += 1 + l + sovRoute(uint64(l))
	}
	l = len(m.NexhHop)
	if l > 0 {
		n += 1 + l + sovRoute(uint64(l))
	}
	l = len(m.TargetVirtualRouter)
	if l > 0 {
		n += 1 + l + sovRoute(uint64(l))
	}
	return n
}

func (m *RouteTableSpec) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *RouteTableStatus) Size() (n int) {
	var l int
	_ = l
	if len(m.Routes) > 0 {
		for _, e := range m.Routes {
			l = e.Size()
			n += 1 + l + sovRoute(uint64(l))
		}
	}
	return n
}

func (m *RouteTable) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovRoute(uint64(l))
	l = m.ObjectMeta.Size()
	n += 1 + l + sovRoute(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovRoute(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovRoute(uint64(l))
	return n
}

func (m *RouteTableEvent) Size() (n int) {
	var l int
	_ = l
	if m.EventType != 0 {
		n += 1 + sovRoute(uint64(m.EventType))
	}
	l = m.RouteTable.Size()
	n += 1 + l + sovRoute(uint64(l))
	return n
}

func (m *RouteTableEventList) Size() (n int) {
	var l int
	_ = l
	if len(m.RouteTableEvents) > 0 {
		for _, e := range m.RouteTableEvents {
			l = e.Size()
			n += 1 + l + sovRoute(uint64(l))
		}
	}
	return n
}

func (m *RouteTableList) Size() (n int) {
	var l int
	_ = l
	if len(m.RouteTables) > 0 {
		for _, e := range m.RouteTables {
			l = e.Size()
			n += 1 + l + sovRoute(uint64(l))
		}
	}
	return n
}

func (m *EVPNConfig) Size() (n int) {
	var l int
	_ = l
	if m.Shutdown {
		n += 2
	}
	return n
}

func (m *BGPNeighbor) Size() (n int) {
	var l int
	_ = l
	if m.Shutdown {
		n += 2
	}
	l = len(m.IPAddress)
	if l > 0 {
		n += 1 + l + sovRoute(uint64(l))
	}
	if m.RemoteAS != 0 {
		n += 1 + sovRoute(uint64(m.RemoteAS))
	}
	if m.MultiHop != 0 {
		n += 1 + sovRoute(uint64(m.MultiHop))
	}
	if len(m.EnableAddressFamilies) > 0 {
		for _, s := range m.EnableAddressFamilies {
			l = len(s)
			n += 1 + l + sovRoute(uint64(l))
		}
	}
	l = len(m.Password)
	if l > 0 {
		n += 1 + l + sovRoute(uint64(l))
	}
	if m.DSCAutoConfig {
		n += 2
	}
	return n
}

func (m *BGPConfig) Size() (n int) {
	var l int
	_ = l
	l = len(m.RouterId)
	if l > 0 {
		n += 1 + l + sovRoute(uint64(l))
	}
	if m.ASNumber != 0 {
		n += 1 + sovRoute(uint64(m.ASNumber))
	}
	if len(m.Neighbors) > 0 {
		for _, e := range m.Neighbors {
			l = e.Size()
			n += 1 + l + sovRoute(uint64(l))
		}
	}
	if m.KeepaliveInterval != 0 {
		n += 1 + sovRoute(uint64(m.KeepaliveInterval))
	}
	if m.Holdtime != 0 {
		n += 1 + sovRoute(uint64(m.Holdtime))
	}
	if m.DSCAutoConfig {
		n += 2
	}
	return n
}

func (m *RoutingConfigSpec) Size() (n int) {
	var l int
	_ = l
	if m.BGPConfig != nil {
		l = m.BGPConfig.Size()
		n += 1 + l + sovRoute(uint64(l))
	}
	if m.EVPNConfig != nil {
		l = m.EVPNConfig.Size()
		n += 1 + l + sovRoute(uint64(l))
	}
	return n
}

func (m *RoutingConfigStatus) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *RoutingConfigEvent) Size() (n int) {
	var l int
	_ = l
	if m.EventType != 0 {
		n += 1 + sovRoute(uint64(m.EventType))
	}
	l = m.RoutingConfig.Size()
	n += 1 + l + sovRoute(uint64(l))
	return n
}

func (m *RoutingConfigEventList) Size() (n int) {
	var l int
	_ = l
	if len(m.RoutingConfigEvents) > 0 {
		for _, e := range m.RoutingConfigEvents {
			l = e.Size()
			n += 1 + l + sovRoute(uint64(l))
		}
	}
	return n
}

func (m *RoutingConfigList) Size() (n int) {
	var l int
	_ = l
	if len(m.RoutingConfigs) > 0 {
		for _, e := range m.RoutingConfigs {
			l = e.Size()
			n += 1 + l + sovRoute(uint64(l))
		}
	}
	return n
}

func (m *RoutingConfig) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovRoute(uint64(l))
	l = m.ObjectMeta.Size()
	n += 1 + l + sovRoute(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovRoute(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovRoute(uint64(l))
	return n
}

func sovRoute(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozRoute(x uint64) (n int) {
	return sovRoute(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *RouteDistinguisher) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RouteDistinguisher: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RouteDistinguisher: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdminValue", wireType)
			}
			m.AdminValue = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AdminValue |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssignedValue", wireType)
			}
			m.AssignedValue = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AssignedValue |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRoute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RDSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RDSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RDSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddressFamily", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AddressFamily = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RDAuto", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RDAuto = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RD", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RD == nil {
				m.RD = &RouteDistinguisher{}
			}
			if err := m.RD.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExportRTs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExportRTs = append(m.ExportRTs, &RouteDistinguisher{})
			if err := m.ExportRTs[len(m.ExportRTs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImportRTs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ImportRTs = append(m.ImportRTs, &RouteDistinguisher{})
			if err := m.ImportRTs[len(m.ImportRTs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Route) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Route: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Route: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Prefix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NexhHop", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NexhHop = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetVirtualRouter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TargetVirtualRouter = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RouteTableSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RouteTableSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RouteTableSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipRoute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RouteTableStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RouteTableStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RouteTableStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Routes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Routes = append(m.Routes, &Route{})
			if err := m.Routes[len(m.Routes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RouteTable) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RouteTable: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RouteTable: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RouteTableEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RouteTableEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RouteTableEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventType", wireType)
			}
			m.EventType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EventType |= (api.EventType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteTable", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RouteTable.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RouteTableEventList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RouteTableEventList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RouteTableEventList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteTableEvents", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RouteTableEvents = append(m.RouteTableEvents, &RouteTableEvent{})
			if err := m.RouteTableEvents[len(m.RouteTableEvents)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RouteTableList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RouteTableList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RouteTableList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteTables", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RouteTables = append(m.RouteTables, &RouteTable{})
			if err := m.RouteTables[len(m.RouteTables)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EVPNConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EVPNConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EVPNConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shutdown", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Shutdown = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipRoute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPNeighbor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPNeighbor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPNeighbor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shutdown", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Shutdown = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IPAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IPAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoteAS", wireType)
			}
			m.RemoteAS = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RemoteAS |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MultiHop", wireType)
			}
			m.MultiHop = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MultiHop |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableAddressFamilies", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EnableAddressFamilies = append(m.EnableAddressFamilies, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Password", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Password = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DSCAutoConfig", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DSCAutoConfig = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipRoute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouterId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RouterId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ASNumber", wireType)
			}
			m.ASNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ASNumber |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Neighbors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Neighbors = append(m.Neighbors, &BGPNeighbor{})
			if err := m.Neighbors[len(m.Neighbors)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeepaliveInterval", wireType)
			}
			m.KeepaliveInterval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeepaliveInterval |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Holdtime", wireType)
			}
			m.Holdtime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Holdtime |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DSCAutoConfig", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DSCAutoConfig = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipRoute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoutingConfigSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoutingConfigSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoutingConfigSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BGPConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BGPConfig == nil {
				m.BGPConfig = &BGPConfig{}
			}
			if err := m.BGPConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EVPNConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EVPNConfig == nil {
				m.EVPNConfig = &EVPNConfig{}
			}
			if err := m.EVPNConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoutingConfigStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoutingConfigStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoutingConfigStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipRoute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoutingConfigEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoutingConfigEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoutingConfigEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventType", wireType)
			}
			m.EventType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EventType |= (api.EventType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoutingConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RoutingConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoutingConfigEventList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoutingConfigEventList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoutingConfigEventList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoutingConfigEvents", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RoutingConfigEvents = append(m.RoutingConfigEvents, &RoutingConfigEvent{})
			if err := m.RoutingConfigEvents[len(m.RoutingConfigEvents)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoutingConfigList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoutingConfigList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoutingConfigList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoutingConfigs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RoutingConfigs = append(m.RoutingConfigs, &RoutingConfig{})
			if err := m.RoutingConfigs[len(m.RoutingConfigs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoutingConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoutingConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoutingConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipRoute(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthRoute
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowRoute
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipRoute(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthRoute = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowRoute   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("route.proto", fileDescriptorRoute) }

var fileDescriptorRoute = []byte{
	// 1708 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x57, 0xcf, 0x6f, 0xdb, 0xc8,
	0x15, 0x36, 0x25, 0x5b, 0x96, 0xc6, 0xb1, 0x2d, 0x8f, 0xac, 0x44, 0x52, 0x6d, 0x4b, 0x21, 0x5a,
	0xc0, 0x49, 0x4d, 0x29, 0x51, 0xd2, 0xa0, 0x29, 0x90, 0xb4, 0xa6, 0xa5, 0xd8, 0x4e, 0x1c, 0x5b,
	0x95, 0x1c, 0xe7, 0x52, 0x20, 0xa0, 0xa4, 0xb1, 0x34, 0x8d, 0x34, 0x24, 0xc8, 0xa1, 0x6c, 0xa3,
	0x08, 0x0a, 0x34, 0x85, 0x91, 0x02, 0xf9, 0x27, 0xda, 0xa3, 0x81, 0x2e, 0xb0, 0x7b, 0xd8, 0xdb,
	0xde, 0x73, 0xcc, 0x5f, 0x20, 0x2c, 0x7c, 0xd4, 0x6d, 0x2f, 0x39, 0x2f, 0x66, 0x48, 0x4a, 0x43,
	0xfd, 0x48, 0xb2, 0xc1, 0x2e, 0xb0, 0x27, 0x91, 0x6f, 0xbe, 0xef, 0x9b, 0x99, 0xef, 0x3d, 0xbe,
	0x19, 0x81, 0x39, 0x53, 0xb7, 0x29, 0xca, 0x1a, 0xa6, 0x4e, 0x75, 0x18, 0x26, 0x88, 0xf2, 0xa7,
	0xd4, 0x4a, 0x43, 0xd7, 0x1b, 0x2d, 0x94, 0xd3, 0x0c, 0x9c, 0xd3, 0x08, 0xd1, 0xa9, 0x46, 0xb1,
	0x4e, 0x2c, 0x07, 0x97, 0x2a, 0x36, 0x30, 0x6d, 0xda, 0xd5, 0x6c, 0x4d, 0x6f, 0xe7, 0x0c, 0x44,
	0x2c, 0x8d, 0xd4, 0xf5, 0x9c, 0x75, 0x92, 0xeb, 0x20, 0x82, 0x6b, 0x28, 0x67, 0x53, 0xdc, 0xb2,
	0x18, 0xb5, 0x81, 0x88, 0xc8, 0xce, 0x61, 0x52, 0x6b, 0xd9, 0x75, 0xe4, 0xc9, 0x28, 0x82, 0x4c,
	0x43, 0x6f, 0xe8, 0x39, 0x1e, 0xae, 0xda, 0xc7, 0xfc, 0x8d, 0xbf, 0xf0, 0x27, 0x17, 0xfe, 0xbb,
	0x09, 0xb3, 0xb2, 0x35, 0xb6, 0x11, 0xd5, 0x1c, 0x98, 0xfc, 0x36, 0x00, 0x60, 0x99, 0x6d, 0xaa,
	0x80, 0x2d, 0x8a, 0x49, 0xc3, 0xc6, 0x56, 0x13, 0x99, 0x70, 0x0f, 0x4c, 0x1f, 0x9e, 0x19, 0x28,
	0x21, 0x65, 0xa4, 0xf5, 0x88, 0xfa, 0xc7, 0x8b, 0xf3, 0xa4, 0x5c, 0xa1, 0x66, 0x91, 0xd8, 0xed,
	0xf5, 0x51, 0x74, 0xb6, 0x5c, 0x60, 0xe0, 0x1b, 0xbd, 0x6e, 0x7a, 0x81, 0x9e, 0x19, 0x68, 0x43,
	0x6f, 0x63, 0x8a, 0xda, 0x06, 0x3d, 0x2b, 0x73, 0x15, 0x78, 0x1f, 0x80, 0xcd, 0x7a, 0x1b, 0x93,
	0x23, 0xad, 0x65, 0xa3, 0x44, 0x20, 0x23, 0xad, 0xcf, 0xab, 0xc9, 0x5e, 0x37, 0x1d, 0xd7, 0x58,
	0x54, 0xe9, 0xb0, 0xb0, 0x40, 0x12, 0xc0, 0x50, 0x05, 0xf3, 0x9b, 0x96, 0x85, 0x1b, 0x04, 0xd5,
	0x1d, 0x76, 0x90, 0xb3, 0x57, 0x7a, 0xdd, 0x74, 0x42, 0x73, 0x07, 0x46, 0x04, 0xfc, 0x14, 0xf9,
	0x06, 0x08, 0x39, 0x2b, 0x84, 0x11, 0x30, 0xc3, 0x7e, 0x6f, 0x45, 0xa7, 0xbc, 0xc7, 0xdb, 0x51,
	0xc9, 0x7b, 0xcc, 0x47, 0x03, 0xf2, 0xbf, 0x82, 0x0c, 0x5b, 0x31, 0x50, 0x0d, 0xbe, 0x00, 0xf3,
	0x9b, 0xf5, 0xba, 0x89, 0x2c, 0xeb, 0x91, 0xd6, 0xc6, 0xad, 0x33, 0xd7, 0x8b, 0xfb, 0x17, 0xe7,
	0xc9, 0xa4, 0xe7, 0x85, 0xba, 0x5d, 0xf2, 0x61, 0x6e, 0xf0, 0x65, 0x39, 0x11, 0xe5, 0x98, 0x87,
	0x7c, 0xcb, 0x12, 0xb1, 0x50, 0x61, 0x53, 0x6d, 0xda, 0x54, 0xe7, 0x8e, 0x84, 0xd5, 0x78, 0xaf,
	0x9b, 0x5e, 0x32, 0xeb, 0x8a, 0x66, 0x53, 0x5d, 0x60, 0xb9, 0x20, 0xf8, 0x10, 0x04, 0xca, 0x05,
	0xbe, 0xfd, 0xb9, 0xfc, 0x4a, 0xd6, 0xab, 0xbd, 0xec, 0x68, 0x3a, 0xd4, 0x68, 0xaf, 0x9b, 0xbe,
	0x62, 0xd6, 0x05, 0x8d, 0x40, 0xb9, 0x00, 0x2b, 0x20, 0x52, 0x3c, 0x35, 0x74, 0x93, 0x96, 0x0f,
	0xad, 0xc4, 0x74, 0x26, 0xf8, 0x49, 0x99, 0x6b, 0xbd, 0x6e, 0x3a, 0x66, 0x52, 0x05, 0x71, 0x96,
	0xa0, 0x36, 0xd0, 0x61, 0xa2, 0xbb, 0x6d, 0x4f, 0x74, 0xe6, 0x27, 0x88, 0xe2, 0xf6, 0xb0, 0x68,
	0x5f, 0x47, 0xfe, 0x20, 0x81, 0x19, 0x4e, 0x85, 0xf7, 0x40, 0xa8, 0x64, 0xa2, 0x63, 0x7c, 0xea,
	0x9a, 0xbf, 0x76, 0x71, 0x9e, 0x0c, 0x6d, 0xed, 0x16, 0xca, 0xeb, 0xcc, 0xe9, 0xa8, 0xc1, 0xc7,
	0x44, 0xaf, 0x1c, 0x34, 0xfc, 0x13, 0x98, 0xdd, 0x47, 0xa7, 0xcd, 0x1d, 0xdd, 0xe0, 0xde, 0x46,
	0xd4, 0x8c, 0x8f, 0x08, 0x09, 0x3a, 0xa5, 0x4a, 0x53, 0x37, 0x04, 0xaa, 0x47, 0x80, 0x67, 0x20,
	0x76, 0xa8, 0x99, 0x0d, 0x44, 0x8f, 0xb0, 0x49, 0x6d, 0xad, 0xc5, 0x57, 0x62, 0x72, 0xe3, 0x23,
	0xea, 0xf6, 0xff, 0xce, 0x93, 0x19, 0x30, 0xfb, 0x1c, 0x69, 0x2f, 0xcb, 0xe8, 0x18, 0xc6, 0x09,
	0xa2, 0x27, 0xba, 0xf9, 0x32, 0xe7, 0xc3, 0xf6, 0xba, 0xe9, 0x34, 0xe5, 0x12, 0x4a, 0xc7, 0x89,
	0x2b, 0xbc, 0x6f, 0x98, 0xc2, 0x74, 0xe3, 0xe6, 0x90, 0xa3, 0x60, 0x81, 0x3f, 0x1d, 0x6a, 0xd5,
	0x16, 0x62, 0x45, 0x28, 0xff, 0x15, 0x44, 0x85, 0x08, 0xd5, 0xa8, 0x6d, 0xc1, 0x07, 0x20, 0xc4,
	0x63, 0x56, 0x42, 0xe2, 0x86, 0x2f, 0x0e, 0x19, 0xae, 0x2e, 0x33, 0x6f, 0xf8, 0x8c, 0x96, 0xaf,
	0x8e, 0x78, 0x44, 0xfe, 0x7f, 0x00, 0x80, 0x81, 0x26, 0x7c, 0x08, 0xc2, 0xac, 0xf8, 0x9f, 0x22,
	0xaa, 0x71, 0x93, 0xe7, 0xf2, 0xf3, 0x59, 0xcd, 0xc0, 0x59, 0x2f, 0xa8, 0xc6, 0xde, 0x75, 0xd3,
	0x53, 0xef, 0xbb, 0x69, 0xa9, 0xd7, 0x4d, 0xcf, 0x6e, 0x60, 0xd2, 0xc2, 0x04, 0x95, 0xfb, 0x1c,
	0xf8, 0x04, 0x80, 0x83, 0xea, 0xdf, 0x51, 0x8d, 0x72, 0x85, 0x00, 0x57, 0x58, 0xe4, 0x0a, 0x83,
	0xb0, 0x9a, 0x12, 0x34, 0x16, 0x58, 0xf7, 0x11, 0xbf, 0xf6, 0x01, 0x0e, 0x16, 0xc0, 0x34, 0xdb,
	0xb6, 0x5b, 0xe5, 0x89, 0xa1, 0x8d, 0xf5, 0x6d, 0x51, 0xaf, 0x32, 0x3d, 0xa6, 0x65, 0x19, 0xa8,
	0x26, 0xb6, 0x1b, 0xfe, 0xe5, 0xee, 0x81, 0x90, 0x63, 0x55, 0x62, 0x9a, 0xeb, 0xa4, 0xc6, 0xea,
	0x70, 0x84, 0x9a, 0x70, 0x95, 0xa2, 0x16, 0x7f, 0x17, 0xfd, 0x72, 0x10, 0xf2, 0x57, 0x12, 0x58,
	0x1c, 0xd0, 0x8a, 0x1d, 0x44, 0x28, 0x7c, 0x04, 0x22, 0xfc, 0xa1, 0xdf, 0x23, 0x17, 0xf2, 0x0b,
	0x7c, 0xcf, 0xfd, 0xa8, 0x9a, 0xe8, 0x75, 0xd3, 0xcb, 0x88, 0xbd, 0x2a, 0x43, 0x3d, 0x71, 0x40,
	0x85, 0x15, 0x31, 0x15, 0xae, 0x79, 0xcb, 0xe3, 0x56, 0xab, 0xae, 0xba, 0xeb, 0x8c, 0xf3, 0xbc,
	0x2a, 0x94, 0x05, 0x45, 0x13, 0x07, 0x50, 0xf9, 0x6f, 0x20, 0x36, 0xb4, 0xde, 0x3d, 0x6c, 0x51,
	0x58, 0x04, 0x4e, 0x4d, 0x0c, 0xc2, 0x5e, 0x01, 0x25, 0xc7, 0xcd, 0xc8, 0x11, 0xe5, 0x11, 0x8a,
	0xbc, 0x23, 0xd6, 0x28, 0x17, 0xbe, 0xe7, 0x1e, 0x8b, 0x3c, 0xe2, 0x69, 0x8e, 0xdd, 0x45, 0x59,
	0x04, 0xca, 0x7f, 0x01, 0xa0, 0x78, 0x54, 0xda, 0xdf, 0xd2, 0xc9, 0x31, 0x6e, 0xc0, 0x3c, 0x08,
	0x57, 0x9a, 0x36, 0xad, 0xeb, 0x27, 0x84, 0x3b, 0x1a, 0x56, 0xaf, 0xb2, 0x2f, 0xd5, 0x72, 0x63,
	0xc2, 0x5e, 0xfb, 0x38, 0xf9, 0x43, 0x10, 0xcc, 0xa9, 0xdb, 0xa5, 0x7d, 0x84, 0x1b, 0xcd, 0xaa,
	0x6e, 0x7e, 0x89, 0x06, 0x54, 0x41, 0x64, 0xd7, 0x6b, 0xe2, 0x6e, 0xb3, 0xf8, 0xed, 0xc5, 0x79,
	0x32, 0xec, 0x04, 0x79, 0xbb, 0x58, 0xc6, 0x86, 0xe2, 0x36, 0x75, 0x5f, 0xc3, 0xf2, 0x68, 0xf0,
	0x0e, 0x08, 0x97, 0x51, 0x5b, 0xa7, 0x68, 0xb3, 0xe2, 0x9e, 0x4f, 0x4e, 0x9b, 0xe3, 0x31, 0x45,
	0x13, 0x59, 0x7d, 0x20, 0xdc, 0x06, 0xe1, 0xa7, 0x76, 0x8b, 0x62, 0xd6, 0xa4, 0xa6, 0x39, 0xe9,
	0xf7, 0x17, 0xe7, 0xc9, 0xe8, 0x2e, 0xa1, 0x65, 0x8d, 0x34, 0xd0, 0xfa, 0xad, 0x8d, 0x4c, 0xfe,
	0x0f, 0xf7, 0xd8, 0xfc, 0xb1, 0x36, 0xc3, 0x0d, 0xf5, 0xab, 0x3e, 0x19, 0x9e, 0x82, 0x78, 0x91,
	0x30, 0x4b, 0xc5, 0xe3, 0x05, 0x23, 0xa7, 0x1f, 0x47, 0x54, 0xf5, 0x53, 0x07, 0xd6, 0x75, 0xc4,
	0xd9, 0x8a, 0xef, 0xdc, 0xc2, 0xbe, 0xde, 0x31, 0x7e, 0x02, 0xe6, 0x77, 0x49, 0xb3, 0xac, 0x13,
	0xdd, 0xac, 0x27, 0x42, 0xdc, 0x3a, 0xee, 0xb7, 0xe1, 0xc6, 0xc4, 0xd5, 0x7a, 0x38, 0xb8, 0x05,
	0xe6, 0x0b, 0x95, 0x2d, 0x76, 0xa2, 0x39, 0x89, 0x4f, 0xcc, 0xf2, 0x44, 0xad, 0xf6, 0xba, 0xe9,
	0x64, 0xdd, 0xaa, 0xf1, 0xd3, 0x4f, 0xa9, 0xf1, 0x21, 0xf1, 0xe8, 0xf4, 0x71, 0xe4, 0xff, 0x06,
	0x41, 0x44, 0xdd, 0x2e, 0xb9, 0xa5, 0xb3, 0x03, 0xc2, 0x4e, 0x03, 0xdd, 0xad, 0xbb, 0xe7, 0xc4,
	0xc6, 0xc5, 0x79, 0x72, 0xa9, 0xc8, 0x98, 0x07, 0xe6, 0xba, 0x97, 0x49, 0x6e, 0xa5, 0xd3, 0x88,
	0x15, 0xec, 0x5b, 0x9c, 0xc7, 0x66, 0x89, 0xdc, 0xac, 0xec, 0xdb, 0xed, 0x2a, 0x32, 0xdd, 0x6b,
	0x0a, 0x4f, 0xa4, 0x66, 0x29, 0x84, 0x07, 0x45, 0x92, 0x07, 0x84, 0x7b, 0x20, 0xe2, 0x55, 0xa0,
	0x95, 0x08, 0xf2, 0xea, 0x8f, 0x0f, 0xaa, 0x5f, 0xa8, 0x4f, 0x47, 0x8c, 0x78, 0x58, 0xb1, 0x96,
	0xfa, 0x02, 0x70, 0x1f, 0x2c, 0x3d, 0x41, 0xc8, 0xd0, 0x5a, 0xb8, 0x83, 0x76, 0x09, 0x45, 0x66,
	0x47, 0x6b, 0xb9, 0xf5, 0x91, 0xe9, 0x75, 0xd3, 0x2b, 0x2f, 0xbd, 0x41, 0x05, 0xbb, 0xa3, 0x82,
	0xce, 0x28, 0x95, 0xe5, 0x68, 0x47, 0x6f, 0xd5, 0x29, 0x6e, 0xa3, 0xc4, 0x0c, 0x97, 0xe1, 0x39,
	0x6a, 0xba, 0x31, 0x71, 0x47, 0x1e, 0x6e, 0x34, 0x47, 0xa1, 0x2f, 0xc8, 0xd1, 0xd7, 0x12, 0x58,
	0x62, 0xc6, 0x62, 0xd2, 0x70, 0x22, 0xbc, 0x37, 0x3f, 0x11, 0x12, 0xe7, 0x9e, 0x37, 0x31, 0x9f,
	0x59, 0xce, 0x90, 0xd3, 0x3e, 0xab, 0x0d, 0x63, 0x74, 0x1a, 0x21, 0xf1, 0x07, 0x62, 0x07, 0x19,
	0x6d, 0x9f, 0x83, 0x31, 0xe7, 0xb6, 0x89, 0x3a, 0x06, 0x19, 0xd5, 0x13, 0x24, 0xe4, 0xb8, 0xd3,
	0x3a, 0x07, 0x4b, 0x76, 0x8e, 0x80, 0xef, 0x24, 0xe7, 0x92, 0xdc, 0x8f, 0xff, 0xbc, 0xa7, 0xc0,
	0x0b, 0x30, 0xef, 0x53, 0x77, 0x77, 0x72, 0xcd, 0xdf, 0x42, 0xfb, 0xc3, 0x6a, 0xc6, 0x3d, 0x0b,
	0x12, 0xa6, 0x13, 0x1e, 0x93, 0x0a, 0x1f, 0x41, 0x6e, 0x82, 0xab, 0xa3, 0xcb, 0xe7, 0xbd, 0x7b,
	0x1f, 0xc4, 0xcc, 0x91, 0x11, 0xaf, 0x87, 0xaf, 0x4c, 0x58, 0x80, 0x73, 0x34, 0x8c, 0x23, 0xca,
	0x87, 0x43, 0x39, 0xe7, 0x93, 0xfc, 0x19, 0x2c, 0xf8, 0xb0, 0x9e, 0xfe, 0xa4, 0x0d, 0x96, 0x87,
	0xe0, 0xf2, 0xb7, 0x81, 0x21, 0x87, 0x7e, 0x5d, 0xb7, 0x96, 0x6d, 0xdf, 0xad, 0xe5, 0x37, 0x13,
	0x76, 0xf5, 0x19, 0x17, 0x97, 0x83, 0xa1, 0x8b, 0xcb, 0xea, 0x24, 0xa9, 0xcf, 0xbc, 0xbb, 0xdc,
	0x3c, 0x04, 0xd1, 0xe1, 0x8e, 0x0f, 0xaf, 0x83, 0xb9, 0xdd, 0x52, 0xe7, 0xee, 0x33, 0x82, 0x6b,
	0x9a, 0x45, 0xa3, 0x53, 0xa9, 0xe8, 0xe5, 0x9b, 0xe4, 0x15, 0x6c, 0x74, 0xee, 0x2a, 0xb6, 0x13,
	0x83, 0xab, 0x20, 0xb2, 0x97, 0xef, 0x18, 0xa4, 0xd8, 0x31, 0x48, 0x54, 0x4a, 0x2d, 0x5c, 0xbe,
	0x49, 0x82, 0x16, 0x0b, 0x28, 0xec, 0x13, 0xca, 0xbf, 0x0d, 0x0e, 0x7d, 0x0e, 0x9b, 0x06, 0x3e,
	0xba, 0x0d, 0x1f, 0x03, 0xc8, 0xd2, 0xed, 0x1b, 0xb1, 0x60, 0x9c, 0xbb, 0xca, 0x06, 0x9e, 0x6b,
	0xb4, 0xd6, 0x3c, 0x30, 0xf8, 0x9f, 0xdb, 0xd4, 0x24, 0x97, 0x18, 0x50, 0x9e, 0x82, 0x65, 0x10,
	0xe3, 0xf0, 0xcf, 0x13, 0xcb, 0x7c, 0xac, 0x50, 0x1d, 0xc5, 0x5b, 0x12, 0x7c, 0x0c, 0xae, 0xf9,
	0x46, 0x0f, 0x0c, 0x64, 0x3e, 0x33, 0xea, 0x1a, 0x45, 0xf0, 0xa3, 0x95, 0x9e, 0xf2, 0x97, 0x96,
	0x3c, 0xb5, 0x2e, 0xa5, 0xfe, 0x23, 0x7d, 0xf3, 0x3a, 0xf9, 0x6f, 0x69, 0xb8, 0x2c, 0xa7, 0x5b,
	0xac, 0xde, 0x83, 0x0d, 0x44, 0xe1, 0xb4, 0xa1, 0xb3, 0x47, 0xc3, 0xa6, 0x30, 0x54, 0x47, 0x2d,
	0x44, 0x51, 0xea, 0x41, 0xee, 0x1f, 0x83, 0xaa, 0xc9, 0x1e, 0x22, 0xa2, 0x11, 0xfa, 0xca, 0x17,
	0xdb, 0xd7, 0xda, 0xc8, 0x32, 0xb4, 0x1a, 0x1a, 0x0d, 0xbf, 0x92, 0x21, 0xfb, 0xeb, 0xee, 0x7e,
	0x19, 0xce, 0x17, 0x6f, 0xdd, 0x0c, 0x1c, 0xdd, 0xce, 0xff, 0x10, 0x10, 0x2f, 0xa8, 0x4e, 0x2e,
	0x0a, 0x60, 0xd1, 0xcb, 0x85, 0x7b, 0xdd, 0x9a, 0xe4, 0xdd, 0xd8, 0x4b, 0xb6, 0x9b, 0x85, 0x3d,
	0x10, 0xed, 0x67, 0xe1, 0x13, 0x32, 0xab, 0x13, 0xef, 0x90, 0x7d, 0xff, 0x0b, 0x60, 0x79, 0x30,
	0x24, 0x98, 0x3f, 0xf9, 0xfa, 0x39, 0xce, 0xf9, 0xd7, 0xcc, 0xf9, 0x7f, 0xfa, 0xfe, 0xc2, 0xfc,
	0xa2, 0xae, 0x47, 0x3d, 0xd7, 0xdd, 0x4b, 0x37, 0xf7, 0x5c, 0xbd, 0xf2, 0xee, 0x72, 0x4d, 0x7a,
	0x7f, 0xb9, 0x26, 0x7d, 0x7f, 0xb9, 0x26, 0x95, 0xa4, 0x6a, 0x88, 0xaf, 0xff, 0xce, 0x8f, 0x01,
	0x00, 0x00, 0xff, 0xff, 0x4d, 0xe7, 0xaa, 0x38, 0x21, 0x12, 0x00, 0x00,
}
