// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: interface.proto

package netproto

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "google.golang.org/genproto/googleapis/api/annotations"
import _ "github.com/pensando/sw/venice/utils/apigen/annotations"
import _ "github.com/gogo/protobuf/gogoproto"
import api "github.com/pensando/sw/api"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type InterfaceSpec_IFType int32

const (
	InterfaceSpec_NONE        InterfaceSpec_IFType = 0
	InterfaceSpec_ENIC        InterfaceSpec_IFType = 1
	InterfaceSpec_UPLINK_ETH  InterfaceSpec_IFType = 2
	InterfaceSpec_UPLINK_MGMT InterfaceSpec_IFType = 3
)

var InterfaceSpec_IFType_name = map[int32]string{
	0: "NONE",
	1: "ENIC",
	2: "UPLINK_ETH",
	3: "UPLINK_MGMT",
}
var InterfaceSpec_IFType_value = map[string]int32{
	"NONE":        0,
	"ENIC":        1,
	"UPLINK_ETH":  2,
	"UPLINK_MGMT": 3,
}

func (x InterfaceSpec_IFType) String() string {
	return proto.EnumName(InterfaceSpec_IFType_name, int32(x))
}
func (InterfaceSpec_IFType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorInterface, []int{1, 0}
}

type InterfaceStatus_IFStatus int32

const (
	InterfaceStatus_NONE InterfaceStatus_IFStatus = 0
	InterfaceStatus_UP   InterfaceStatus_IFStatus = 1
	InterfaceStatus_DOWN InterfaceStatus_IFStatus = 2
)

var InterfaceStatus_IFStatus_name = map[int32]string{
	0: "NONE",
	1: "UP",
	2: "DOWN",
}
var InterfaceStatus_IFStatus_value = map[string]int32{
	"NONE": 0,
	"UP":   1,
	"DOWN": 2,
}

func (x InterfaceStatus_IFStatus) String() string {
	return proto.EnumName(InterfaceStatus_IFStatus_name, int32(x))
}
func (InterfaceStatus_IFStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorInterface, []int{2, 0}
}

// Interface object
type Interface struct {
	api.TypeMeta   `protobuf:"bytes,1,opt,name=TypeMeta,embedded=TypeMeta" json:",inline"`
	api.ObjectMeta `protobuf:"bytes,2,opt,name=ObjectMeta,embedded=ObjectMeta" json:"meta,omitempty"`
	Spec           InterfaceSpec   `protobuf:"bytes,3,opt,name=Spec" json:"spec,omitempty"`
	Status         InterfaceStatus `protobuf:"bytes,4,opt,name=Status" json:"status,omitempty"`
}

func (m *Interface) Reset()                    { *m = Interface{} }
func (m *Interface) String() string            { return proto.CompactTextString(m) }
func (*Interface) ProtoMessage()               {}
func (*Interface) Descriptor() ([]byte, []int) { return fileDescriptorInterface, []int{0} }

func (m *Interface) GetSpec() InterfaceSpec {
	if m != nil {
		return m.Spec
	}
	return InterfaceSpec{}
}

func (m *Interface) GetStatus() InterfaceStatus {
	if m != nil {
		return m.Status
	}
	return InterfaceStatus{}
}

// InterfaceSpec captures all the interface level configuration
type InterfaceSpec struct {
	Type        string `protobuf:"bytes,1,opt,name=Type,proto3" json:"type,omitempty"`
	AdminStatus string `protobuf:"bytes,2,opt,name=AdminStatus,proto3" json:"admin-status,omitempty"`
	// VrfName specifies the name of the VRF that the current Interface belongs to
	VrfName string `protobuf:"bytes,3,opt,name=VrfName,proto3" json:"vrf-name,omitemtpy"`
}

func (m *InterfaceSpec) Reset()                    { *m = InterfaceSpec{} }
func (m *InterfaceSpec) String() string            { return proto.CompactTextString(m) }
func (*InterfaceSpec) ProtoMessage()               {}
func (*InterfaceSpec) Descriptor() ([]byte, []int) { return fileDescriptorInterface, []int{1} }

func (m *InterfaceSpec) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *InterfaceSpec) GetAdminStatus() string {
	if m != nil {
		return m.AdminStatus
	}
	return ""
}

func (m *InterfaceSpec) GetVrfName() string {
	if m != nil {
		return m.VrfName
	}
	return ""
}

// Interface Status
type InterfaceStatus struct {
	InterfaceID  uint64      `protobuf:"varint,1,opt,name=InterfaceID,proto3" json:"id,omitempty"`
	OperStatus   string      `protobuf:"bytes,2,opt,name=OperStatus,proto3" json:"oper-status,omitempty"`
	EnicStatus   *EnicStatus `protobuf:"bytes,3,opt,name=EnicStatus" json:"enic-status,omitempty"`
	UplinkPortID uint32      `protobuf:"varint,4,opt,name=UplinkPortID,proto3" json:"uplink-port-id,omitempty"`
}

func (m *InterfaceStatus) Reset()                    { *m = InterfaceStatus{} }
func (m *InterfaceStatus) String() string            { return proto.CompactTextString(m) }
func (*InterfaceStatus) ProtoMessage()               {}
func (*InterfaceStatus) Descriptor() ([]byte, []int) { return fileDescriptorInterface, []int{2} }

func (m *InterfaceStatus) GetInterfaceID() uint64 {
	if m != nil {
		return m.InterfaceID
	}
	return 0
}

func (m *InterfaceStatus) GetOperStatus() string {
	if m != nil {
		return m.OperStatus
	}
	return ""
}

func (m *InterfaceStatus) GetEnicStatus() *EnicStatus {
	if m != nil {
		return m.EnicStatus
	}
	return nil
}

func (m *InterfaceStatus) GetUplinkPortID() uint32 {
	if m != nil {
		return m.UplinkPortID
	}
	return 0
}

// EnicStatus captures enic configurations.
type EnicStatus struct {
	// List of endpoints that this ENIC is mapped to
	EpName []string `protobuf:"bytes,2,rep,name=EpName" json:"ep-name,omitempty"`
}

func (m *EnicStatus) Reset()                    { *m = EnicStatus{} }
func (m *EnicStatus) String() string            { return proto.CompactTextString(m) }
func (*EnicStatus) ProtoMessage()               {}
func (*EnicStatus) Descriptor() ([]byte, []int) { return fileDescriptorInterface, []int{3} }

func (m *EnicStatus) GetEpName() []string {
	if m != nil {
		return m.EpName
	}
	return nil
}

type InterfaceList struct {
	Interfaces []*Interface `protobuf:"bytes,1,rep,name=interfaces" json:"interfaces,omitempty"`
}

func (m *InterfaceList) Reset()                    { *m = InterfaceList{} }
func (m *InterfaceList) String() string            { return proto.CompactTextString(m) }
func (*InterfaceList) ProtoMessage()               {}
func (*InterfaceList) Descriptor() ([]byte, []int) { return fileDescriptorInterface, []int{4} }

func (m *InterfaceList) GetInterfaces() []*Interface {
	if m != nil {
		return m.Interfaces
	}
	return nil
}

// interaface watch event
type InterfaceEvent struct {
	EventType api.EventType `protobuf:"varint,1,opt,name=EventType,proto3,enum=api.EventType" json:"event-type,omitempty"`
	Interface Interface     `protobuf:"bytes,2,opt,name=Interface" json:"interface,omitempty"`
}

func (m *InterfaceEvent) Reset()                    { *m = InterfaceEvent{} }
func (m *InterfaceEvent) String() string            { return proto.CompactTextString(m) }
func (*InterfaceEvent) ProtoMessage()               {}
func (*InterfaceEvent) Descriptor() ([]byte, []int) { return fileDescriptorInterface, []int{5} }

func (m *InterfaceEvent) GetEventType() api.EventType {
	if m != nil {
		return m.EventType
	}
	return api.EventType_CreateEvent
}

func (m *InterfaceEvent) GetInterface() Interface {
	if m != nil {
		return m.Interface
	}
	return Interface{}
}

func init() {
	proto.RegisterType((*Interface)(nil), "netproto.Interface")
	proto.RegisterType((*InterfaceSpec)(nil), "netproto.InterfaceSpec")
	proto.RegisterType((*InterfaceStatus)(nil), "netproto.InterfaceStatus")
	proto.RegisterType((*EnicStatus)(nil), "netproto.EnicStatus")
	proto.RegisterType((*InterfaceList)(nil), "netproto.InterfaceList")
	proto.RegisterType((*InterfaceEvent)(nil), "netproto.InterfaceEvent")
	proto.RegisterEnum("netproto.InterfaceSpec_IFType", InterfaceSpec_IFType_name, InterfaceSpec_IFType_value)
	proto.RegisterEnum("netproto.InterfaceStatus_IFStatus", InterfaceStatus_IFStatus_name, InterfaceStatus_IFStatus_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for InterfaceApi service

type InterfaceApiClient interface {
	CreateInterface(ctx context.Context, in *Interface, opts ...grpc.CallOption) (*Interface, error)
	GetInterface(ctx context.Context, in *api.ObjectMeta, opts ...grpc.CallOption) (*Interface, error)
	ListInterfaces(ctx context.Context, in *api.ObjectMeta, opts ...grpc.CallOption) (*InterfaceList, error)
	DeleteInterface(ctx context.Context, in *Interface, opts ...grpc.CallOption) (*Interface, error)
	WatchInterfaces(ctx context.Context, in *api.ObjectMeta, opts ...grpc.CallOption) (InterfaceApi_WatchInterfacesClient, error)
	UpdateInterface(ctx context.Context, in *Interface, opts ...grpc.CallOption) (*Interface, error)
	InterfaceOperUpdate(ctx context.Context, opts ...grpc.CallOption) (InterfaceApi_InterfaceOperUpdateClient, error)
}

type interfaceApiClient struct {
	cc *grpc.ClientConn
}

func NewInterfaceApiClient(cc *grpc.ClientConn) InterfaceApiClient {
	return &interfaceApiClient{cc}
}

func (c *interfaceApiClient) CreateInterface(ctx context.Context, in *Interface, opts ...grpc.CallOption) (*Interface, error) {
	out := new(Interface)
	err := grpc.Invoke(ctx, "/netproto.InterfaceApi/CreateInterface", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *interfaceApiClient) GetInterface(ctx context.Context, in *api.ObjectMeta, opts ...grpc.CallOption) (*Interface, error) {
	out := new(Interface)
	err := grpc.Invoke(ctx, "/netproto.InterfaceApi/GetInterface", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *interfaceApiClient) ListInterfaces(ctx context.Context, in *api.ObjectMeta, opts ...grpc.CallOption) (*InterfaceList, error) {
	out := new(InterfaceList)
	err := grpc.Invoke(ctx, "/netproto.InterfaceApi/ListInterfaces", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *interfaceApiClient) DeleteInterface(ctx context.Context, in *Interface, opts ...grpc.CallOption) (*Interface, error) {
	out := new(Interface)
	err := grpc.Invoke(ctx, "/netproto.InterfaceApi/DeleteInterface", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *interfaceApiClient) WatchInterfaces(ctx context.Context, in *api.ObjectMeta, opts ...grpc.CallOption) (InterfaceApi_WatchInterfacesClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_InterfaceApi_serviceDesc.Streams[0], c.cc, "/netproto.InterfaceApi/WatchInterfaces", opts...)
	if err != nil {
		return nil, err
	}
	x := &interfaceApiWatchInterfacesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type InterfaceApi_WatchInterfacesClient interface {
	Recv() (*InterfaceEvent, error)
	grpc.ClientStream
}

type interfaceApiWatchInterfacesClient struct {
	grpc.ClientStream
}

func (x *interfaceApiWatchInterfacesClient) Recv() (*InterfaceEvent, error) {
	m := new(InterfaceEvent)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *interfaceApiClient) UpdateInterface(ctx context.Context, in *Interface, opts ...grpc.CallOption) (*Interface, error) {
	out := new(Interface)
	err := grpc.Invoke(ctx, "/netproto.InterfaceApi/UpdateInterface", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *interfaceApiClient) InterfaceOperUpdate(ctx context.Context, opts ...grpc.CallOption) (InterfaceApi_InterfaceOperUpdateClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_InterfaceApi_serviceDesc.Streams[1], c.cc, "/netproto.InterfaceApi/InterfaceOperUpdate", opts...)
	if err != nil {
		return nil, err
	}
	x := &interfaceApiInterfaceOperUpdateClient{stream}
	return x, nil
}

type InterfaceApi_InterfaceOperUpdateClient interface {
	Send(*InterfaceEvent) error
	CloseAndRecv() (*api.TypeMeta, error)
	grpc.ClientStream
}

type interfaceApiInterfaceOperUpdateClient struct {
	grpc.ClientStream
}

func (x *interfaceApiInterfaceOperUpdateClient) Send(m *InterfaceEvent) error {
	return x.ClientStream.SendMsg(m)
}

func (x *interfaceApiInterfaceOperUpdateClient) CloseAndRecv() (*api.TypeMeta, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(api.TypeMeta)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for InterfaceApi service

type InterfaceApiServer interface {
	CreateInterface(context.Context, *Interface) (*Interface, error)
	GetInterface(context.Context, *api.ObjectMeta) (*Interface, error)
	ListInterfaces(context.Context, *api.ObjectMeta) (*InterfaceList, error)
	DeleteInterface(context.Context, *Interface) (*Interface, error)
	WatchInterfaces(*api.ObjectMeta, InterfaceApi_WatchInterfacesServer) error
	UpdateInterface(context.Context, *Interface) (*Interface, error)
	InterfaceOperUpdate(InterfaceApi_InterfaceOperUpdateServer) error
}

func RegisterInterfaceApiServer(s *grpc.Server, srv InterfaceApiServer) {
	s.RegisterService(&_InterfaceApi_serviceDesc, srv)
}

func _InterfaceApi_CreateInterface_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Interface)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InterfaceApiServer).CreateInterface(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/netproto.InterfaceApi/CreateInterface",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InterfaceApiServer).CreateInterface(ctx, req.(*Interface))
	}
	return interceptor(ctx, in, info, handler)
}

func _InterfaceApi_GetInterface_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(api.ObjectMeta)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InterfaceApiServer).GetInterface(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/netproto.InterfaceApi/GetInterface",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InterfaceApiServer).GetInterface(ctx, req.(*api.ObjectMeta))
	}
	return interceptor(ctx, in, info, handler)
}

func _InterfaceApi_ListInterfaces_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(api.ObjectMeta)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InterfaceApiServer).ListInterfaces(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/netproto.InterfaceApi/ListInterfaces",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InterfaceApiServer).ListInterfaces(ctx, req.(*api.ObjectMeta))
	}
	return interceptor(ctx, in, info, handler)
}

func _InterfaceApi_DeleteInterface_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Interface)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InterfaceApiServer).DeleteInterface(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/netproto.InterfaceApi/DeleteInterface",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InterfaceApiServer).DeleteInterface(ctx, req.(*Interface))
	}
	return interceptor(ctx, in, info, handler)
}

func _InterfaceApi_WatchInterfaces_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(api.ObjectMeta)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(InterfaceApiServer).WatchInterfaces(m, &interfaceApiWatchInterfacesServer{stream})
}

type InterfaceApi_WatchInterfacesServer interface {
	Send(*InterfaceEvent) error
	grpc.ServerStream
}

type interfaceApiWatchInterfacesServer struct {
	grpc.ServerStream
}

func (x *interfaceApiWatchInterfacesServer) Send(m *InterfaceEvent) error {
	return x.ServerStream.SendMsg(m)
}

func _InterfaceApi_UpdateInterface_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Interface)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InterfaceApiServer).UpdateInterface(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/netproto.InterfaceApi/UpdateInterface",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InterfaceApiServer).UpdateInterface(ctx, req.(*Interface))
	}
	return interceptor(ctx, in, info, handler)
}

func _InterfaceApi_InterfaceOperUpdate_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(InterfaceApiServer).InterfaceOperUpdate(&interfaceApiInterfaceOperUpdateServer{stream})
}

type InterfaceApi_InterfaceOperUpdateServer interface {
	SendAndClose(*api.TypeMeta) error
	Recv() (*InterfaceEvent, error)
	grpc.ServerStream
}

type interfaceApiInterfaceOperUpdateServer struct {
	grpc.ServerStream
}

func (x *interfaceApiInterfaceOperUpdateServer) SendAndClose(m *api.TypeMeta) error {
	return x.ServerStream.SendMsg(m)
}

func (x *interfaceApiInterfaceOperUpdateServer) Recv() (*InterfaceEvent, error) {
	m := new(InterfaceEvent)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _InterfaceApi_serviceDesc = grpc.ServiceDesc{
	ServiceName: "netproto.InterfaceApi",
	HandlerType: (*InterfaceApiServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateInterface",
			Handler:    _InterfaceApi_CreateInterface_Handler,
		},
		{
			MethodName: "GetInterface",
			Handler:    _InterfaceApi_GetInterface_Handler,
		},
		{
			MethodName: "ListInterfaces",
			Handler:    _InterfaceApi_ListInterfaces_Handler,
		},
		{
			MethodName: "DeleteInterface",
			Handler:    _InterfaceApi_DeleteInterface_Handler,
		},
		{
			MethodName: "UpdateInterface",
			Handler:    _InterfaceApi_UpdateInterface_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "WatchInterfaces",
			Handler:       _InterfaceApi_WatchInterfaces_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "InterfaceOperUpdate",
			Handler:       _InterfaceApi_InterfaceOperUpdate_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "interface.proto",
}

func (m *Interface) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Interface) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintInterface(dAtA, i, uint64(m.TypeMeta.Size()))
	n1, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n1
	dAtA[i] = 0x12
	i++
	i = encodeVarintInterface(dAtA, i, uint64(m.ObjectMeta.Size()))
	n2, err := m.ObjectMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n2
	dAtA[i] = 0x1a
	i++
	i = encodeVarintInterface(dAtA, i, uint64(m.Spec.Size()))
	n3, err := m.Spec.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n3
	dAtA[i] = 0x22
	i++
	i = encodeVarintInterface(dAtA, i, uint64(m.Status.Size()))
	n4, err := m.Status.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n4
	return i, nil
}

func (m *InterfaceSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InterfaceSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintInterface(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.AdminStatus) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintInterface(dAtA, i, uint64(len(m.AdminStatus)))
		i += copy(dAtA[i:], m.AdminStatus)
	}
	if len(m.VrfName) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintInterface(dAtA, i, uint64(len(m.VrfName)))
		i += copy(dAtA[i:], m.VrfName)
	}
	return i, nil
}

func (m *InterfaceStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InterfaceStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.InterfaceID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintInterface(dAtA, i, uint64(m.InterfaceID))
	}
	if len(m.OperStatus) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintInterface(dAtA, i, uint64(len(m.OperStatus)))
		i += copy(dAtA[i:], m.OperStatus)
	}
	if m.EnicStatus != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintInterface(dAtA, i, uint64(m.EnicStatus.Size()))
		n5, err := m.EnicStatus.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.UplinkPortID != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintInterface(dAtA, i, uint64(m.UplinkPortID))
	}
	return i, nil
}

func (m *EnicStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EnicStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.EpName) > 0 {
		for _, s := range m.EpName {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *InterfaceList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InterfaceList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Interfaces) > 0 {
		for _, msg := range m.Interfaces {
			dAtA[i] = 0xa
			i++
			i = encodeVarintInterface(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *InterfaceEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InterfaceEvent) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.EventType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintInterface(dAtA, i, uint64(m.EventType))
	}
	dAtA[i] = 0x12
	i++
	i = encodeVarintInterface(dAtA, i, uint64(m.Interface.Size()))
	n6, err := m.Interface.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n6
	return i, nil
}

func encodeVarintInterface(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Interface) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovInterface(uint64(l))
	l = m.ObjectMeta.Size()
	n += 1 + l + sovInterface(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovInterface(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovInterface(uint64(l))
	return n
}

func (m *InterfaceSpec) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovInterface(uint64(l))
	}
	l = len(m.AdminStatus)
	if l > 0 {
		n += 1 + l + sovInterface(uint64(l))
	}
	l = len(m.VrfName)
	if l > 0 {
		n += 1 + l + sovInterface(uint64(l))
	}
	return n
}

func (m *InterfaceStatus) Size() (n int) {
	var l int
	_ = l
	if m.InterfaceID != 0 {
		n += 1 + sovInterface(uint64(m.InterfaceID))
	}
	l = len(m.OperStatus)
	if l > 0 {
		n += 1 + l + sovInterface(uint64(l))
	}
	if m.EnicStatus != nil {
		l = m.EnicStatus.Size()
		n += 1 + l + sovInterface(uint64(l))
	}
	if m.UplinkPortID != 0 {
		n += 1 + sovInterface(uint64(m.UplinkPortID))
	}
	return n
}

func (m *EnicStatus) Size() (n int) {
	var l int
	_ = l
	if len(m.EpName) > 0 {
		for _, s := range m.EpName {
			l = len(s)
			n += 1 + l + sovInterface(uint64(l))
		}
	}
	return n
}

func (m *InterfaceList) Size() (n int) {
	var l int
	_ = l
	if len(m.Interfaces) > 0 {
		for _, e := range m.Interfaces {
			l = e.Size()
			n += 1 + l + sovInterface(uint64(l))
		}
	}
	return n
}

func (m *InterfaceEvent) Size() (n int) {
	var l int
	_ = l
	if m.EventType != 0 {
		n += 1 + sovInterface(uint64(m.EventType))
	}
	l = m.Interface.Size()
	n += 1 + l + sovInterface(uint64(l))
	return n
}

func sovInterface(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozInterface(x uint64) (n int) {
	return sovInterface(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Interface) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Interface: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Interface: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InterfaceSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InterfaceSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InterfaceSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdminStatus", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AdminStatus = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VrfName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VrfName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InterfaceStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InterfaceStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InterfaceStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InterfaceID", wireType)
			}
			m.InterfaceID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InterfaceID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperStatus", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OperStatus = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnicStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EnicStatus == nil {
				m.EnicStatus = &EnicStatus{}
			}
			if err := m.EnicStatus.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UplinkPortID", wireType)
			}
			m.UplinkPortID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UplinkPortID |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EnicStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EnicStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EnicStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EpName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EpName = append(m.EpName, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InterfaceList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InterfaceList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InterfaceList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Interfaces", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Interfaces = append(m.Interfaces, &Interface{})
			if err := m.Interfaces[len(m.Interfaces)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InterfaceEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InterfaceEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InterfaceEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventType", wireType)
			}
			m.EventType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EventType |= (api.EventType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Interface", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Interface.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipInterface(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowInterface
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthInterface
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowInterface
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipInterface(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthInterface = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowInterface   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("interface.proto", fileDescriptorInterface) }

var fileDescriptorInterface = []byte{
	// 909 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x55, 0xdd, 0x6e, 0x1a, 0x47,
	0x14, 0x66, 0x17, 0x44, 0xcc, 0xc1, 0x86, 0xed, 0x38, 0x71, 0x81, 0xa6, 0xc6, 0x5d, 0xa9, 0x15,
	0x95, 0xc2, 0x6e, 0x84, 0xa5, 0xde, 0xb4, 0x4e, 0x93, 0x35, 0xd8, 0x45, 0x8e, 0xc1, 0xf2, 0x4f,
	0x73, 0xd7, 0x6a, 0xbc, 0x8c, 0xc9, 0xb4, 0x30, 0x3b, 0xda, 0x1d, 0x5c, 0x59, 0x55, 0xae, 0x2a,
	0xe5, 0x19, 0xfa, 0x08, 0x95, 0xd5, 0x8b, 0xaa, 0x4f, 0x91, 0xcb, 0x3c, 0x01, 0x8a, 0xdc, 0x3b,
	0x9e, 0xa2, 0x9a, 0x01, 0x96, 0xc1, 0xe0, 0xaa, 0xf2, 0xdd, 0x9c, 0x33, 0xdf, 0xf7, 0xcd, 0x37,
	0x67, 0xe7, 0x9c, 0x85, 0x3c, 0x65, 0x82, 0x84, 0x17, 0xd8, 0x27, 0x0e, 0x0f, 0x03, 0x11, 0xa0,
	0x15, 0x46, 0x84, 0x5a, 0x95, 0x1e, 0x77, 0x83, 0xa0, 0xdb, 0x23, 0x2e, 0xe6, 0xd4, 0xc5, 0x8c,
	0x05, 0x02, 0x0b, 0x1a, 0xb0, 0x68, 0x8c, 0x2b, 0x35, 0xba, 0x54, 0xbc, 0x1e, 0x9c, 0x3b, 0x7e,
	0xd0, 0x77, 0x39, 0x61, 0x11, 0x66, 0x9d, 0xc0, 0x8d, 0x7e, 0x71, 0x2f, 0x09, 0xa3, 0x3e, 0x71,
	0x07, 0x82, 0xf6, 0x22, 0x49, 0xed, 0x12, 0xa6, 0xb3, 0x5d, 0xca, 0xfc, 0xde, 0xa0, 0x43, 0xa6,
	0x32, 0x55, 0x4d, 0xa6, 0x1b, 0x74, 0x03, 0x57, 0xa5, 0xcf, 0x07, 0x17, 0x2a, 0x52, 0x81, 0x5a,
	0x4d, 0xe0, 0x9f, 0xdf, 0x71, 0xaa, 0xf4, 0xd8, 0x27, 0x02, 0x8f, 0x61, 0xf6, 0xb5, 0x09, 0x99,
	0xe6, 0xf4, 0x62, 0xe8, 0x19, 0xac, 0x9c, 0x5e, 0x71, 0x72, 0x48, 0x04, 0x2e, 0x18, 0x5b, 0x46,
	0x25, 0x5b, 0x5b, 0x73, 0x30, 0xa7, 0xce, 0x34, 0xe9, 0xad, 0xbf, 0x1b, 0x96, 0x13, 0xef, 0x87,
	0x65, 0x63, 0x34, 0x2c, 0x3f, 0x78, 0x42, 0x59, 0x8f, 0x32, 0x72, 0x1c, 0x73, 0xd0, 0x01, 0x40,
	0xfb, 0xfc, 0x27, 0xe2, 0x0b, 0xa5, 0x60, 0x2a, 0x85, 0xbc, 0x52, 0x98, 0xa5, 0xbd, 0x92, 0xa6,
	0x91, 0x93, 0x56, 0x9e, 0x04, 0x7d, 0x2a, 0x48, 0x9f, 0x8b, 0xab, 0x63, 0x8d, 0x8e, 0x76, 0x21,
	0x75, 0xc2, 0x89, 0x5f, 0x48, 0x2a, 0x99, 0x8f, 0x9d, 0x69, 0xb9, 0x9d, 0xd8, 0xaf, 0xdc, 0xf6,
	0x36, 0xa4, 0x9c, 0x94, 0x8a, 0x38, 0xf1, 0x35, 0x29, 0x45, 0x46, 0x07, 0x90, 0x3e, 0x11, 0x58,
	0x0c, 0xa2, 0x42, 0x4a, 0xc9, 0x14, 0x97, 0xc9, 0x28, 0x80, 0x57, 0x98, 0x08, 0x59, 0x91, 0x8a,
	0x35, 0xa9, 0x89, 0x84, 0xfd, 0xa7, 0x09, 0x6b, 0x73, 0x87, 0xa3, 0x7d, 0x48, 0xc9, 0xcb, 0xab,
	0x62, 0x65, 0xbc, 0xed, 0xeb, 0xb7, 0xc5, 0x4f, 0x4f, 0x44, 0xd8, 0x60, 0x83, 0x7e, 0x65, 0x0e,
	0xe8, 0x34, 0xf7, 0x24, 0xee, 0x4b, 0xe9, 0x53, 0x5c, 0x71, 0xa2, 0xfb, 0x94, 0x1b, 0x08, 0x43,
	0xf6, 0x45, 0xa7, 0x4f, 0xd9, 0xc4, 0xac, 0xa9, 0xf4, 0xbe, 0xbd, 0x7e, 0x5b, 0xfc, 0x6c, 0x51,
	0x4f, 0x41, 0x9c, 0xe6, 0xde, 0x78, 0x21, 0x35, 0x37, 0xb0, 0xe4, 0x56, 0x17, 0x8c, 0xeb, 0x9a,
	0xe8, 0x29, 0x3c, 0xf8, 0x3e, 0xbc, 0x68, 0xe1, 0x3e, 0x51, 0x25, 0xcd, 0x78, 0x1b, 0xa3, 0x61,
	0x19, 0x5d, 0x86, 0x17, 0x55, 0x86, 0xfb, 0x53, 0x47, 0x82, 0x5f, 0x1d, 0x4f, 0x61, 0xf6, 0x0e,
	0xa4, 0xc7, 0xbe, 0xd1, 0x0a, 0xa4, 0x5a, 0xed, 0x56, 0xc3, 0x4a, 0xc8, 0x55, 0xa3, 0xd5, 0xdc,
	0xb5, 0x0c, 0x94, 0x03, 0x38, 0x3b, 0x7a, 0xd9, 0x6c, 0x1d, 0xfc, 0xd8, 0x38, 0xfd, 0xce, 0x32,
	0x51, 0x1e, 0xb2, 0x93, 0xf8, 0x70, 0xff, 0xf0, 0xd4, 0x4a, 0xda, 0x1f, 0x4c, 0xc8, 0xdf, 0x72,
	0x8d, 0x6a, 0x90, 0x8d, 0x53, 0xcd, 0xba, 0xaa, 0x5b, 0xca, 0xb3, 0x46, 0xc3, 0xf2, 0x2a, 0xed,
	0xe8, 0xc6, 0x35, 0x10, 0xfa, 0x01, 0xa0, 0xcd, 0x49, 0x38, 0x57, 0x9a, 0x67, 0xff, 0xb7, 0x34,
	0x8f, 0x02, 0x4e, 0xc2, 0xc5, 0xca, 0x68, 0x8a, 0xa8, 0x0d, 0xd0, 0x60, 0xd4, 0x9f, 0xe8, 0x8f,
	0x9f, 0xdb, 0xc3, 0xd9, 0x3b, 0x99, 0xed, 0x79, 0x45, 0x29, 0x28, 0xdb, 0x76, 0x89, 0xe0, 0x0c,
	0x86, 0x9e, 0xc3, 0xea, 0x19, 0xef, 0x51, 0xf6, 0xf3, 0x51, 0x10, 0x8a, 0x66, 0x5d, 0x3d, 0xbd,
	0x35, 0xef, 0xf1, 0x68, 0x58, 0x2e, 0x0c, 0x54, 0xbe, 0xca, 0x83, 0x50, 0x54, 0xe7, 0x6e, 0x3c,
	0xc7, 0xb0, 0xbf, 0x80, 0x95, 0xe9, 0x25, 0xb4, 0xda, 0xa7, 0xc1, 0x3c, 0x3b, 0xb2, 0x0c, 0x99,
	0xa9, 0xb7, 0x5f, 0xb5, 0x2c, 0xd3, 0xfe, 0x5a, 0xb7, 0x8e, 0xaa, 0x90, 0x6e, 0x70, 0xf5, 0x81,
	0xcd, 0xad, 0x64, 0x25, 0xe3, 0x3d, 0x1a, 0x0d, 0xcb, 0x1f, 0x11, 0xae, 0x7f, 0x5f, 0xf5, 0x9c,
	0xc7, 0x20, 0xbb, 0xae, 0xbd, 0xe6, 0x97, 0x34, 0x12, 0x68, 0x1b, 0x20, 0x1e, 0x72, 0x51, 0xc1,
	0xd8, 0x4a, 0x56, 0xb2, 0xb5, 0xf5, 0x25, 0x0d, 0x73, 0xac, 0xc1, 0xec, 0x3f, 0x0c, 0xc8, 0xc5,
	0x3b, 0x8d, 0x4b, 0xc2, 0x04, 0xda, 0x83, 0x8c, 0x5a, 0xc4, 0xad, 0x91, 0xab, 0xe5, 0xd4, 0x14,
	0x88, 0xb3, 0x5e, 0x61, 0x34, 0x2c, 0x3f, 0x24, 0x32, 0xac, 0xde, 0xea, 0x87, 0x19, 0x15, 0xb5,
	0xb4, 0xd9, 0x34, 0x99, 0x26, 0xcb, 0xec, 0x78, 0x9f, 0x4c, 0x3a, 0x77, 0x3d, 0xb6, 0xa5, 0xeb,
	0xc5, 0xb8, 0xda, 0x5f, 0x29, 0x58, 0x8d, 0xa3, 0x17, 0x9c, 0xa2, 0x1d, 0xc8, 0xef, 0x86, 0x04,
	0x0b, 0x32, 0x1b, 0x81, 0xcb, 0x0e, 0x28, 0x2d, 0x4b, 0xda, 0x09, 0xf4, 0x15, 0xac, 0xee, 0x13,
	0x31, 0xe3, 0xde, 0x1e, 0x75, 0x77, 0xf1, 0xbe, 0x81, 0x9c, 0xac, 0x77, 0x9c, 0x8a, 0x16, 0x99,
	0xcb, 0xc6, 0x9d, 0xe4, 0xd8, 0x09, 0x69, 0xba, 0x4e, 0x7a, 0xe4, 0xbe, 0xa6, 0x9f, 0x43, 0xfe,
	0x15, 0x16, 0xfe, 0xeb, 0xff, 0x3a, 0xbd, 0xb0, 0x84, 0xaa, 0x3e, 0x8b, 0x9d, 0x78, 0x6a, 0x48,
	0x03, 0x67, 0xbc, 0x73, 0xef, 0xaa, 0x79, 0xb0, 0x1e, 0x87, 0xb2, 0x0b, 0xc7, 0x5a, 0xe8, 0xce,
	0x33, 0x4b, 0xf3, 0xff, 0x20, 0x3b, 0x51, 0x31, 0x4a, 0xdd, 0xbf, 0x7f, 0x2b, 0xfa, 0xfa, 0x9f,
	0x2b, 0xd5, 0x93, 0x0f, 0x38, 0xc5, 0x83, 0x48, 0xa0, 0x74, 0x47, 0x95, 0x07, 0x25, 0xf9, 0x40,
	0x94, 0x76, 0xdc, 0x5f, 0x67, 0x17, 0x73, 0x4e, 0x09, 0xc3, 0x4c, 0xbc, 0x99, 0xcb, 0xc9, 0x5e,
	0x88, 0x38, 0xf6, 0xc9, 0x62, 0xfa, 0x8d, 0x67, 0xbd, 0xbb, 0xd9, 0x34, 0xde, 0xdf, 0x6c, 0x1a,
	0x1f, 0x6e, 0x36, 0x8d, 0xdf, 0xff, 0xd9, 0x4c, 0x1c, 0x19, 0xe7, 0x69, 0xe5, 0x72, 0xfb, 0xdf,
	0x00, 0x00, 0x00, 0xff, 0xff, 0x91, 0xe2, 0xab, 0xdd, 0x12, 0x08, 0x00, 0x00,
}
