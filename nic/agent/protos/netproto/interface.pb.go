// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: interface.proto

package netproto

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "google.golang.org/genproto/googleapis/api/annotations"
import _ "github.com/pensando/sw/venice/utils/apigen/annotations"
import _ "github.com/gogo/protobuf/gogoproto"
import api "github.com/pensando/sw/api"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type PauseType int32

const (
	PauseType_DISABLE  PauseType = 0
	PauseType_LINK     PauseType = 1
	PauseType_PRIORITY PauseType = 2
)

var PauseType_name = map[int32]string{
	0: "DISABLE",
	1: "LINK",
	2: "PRIORITY",
}
var PauseType_value = map[string]int32{
	"DISABLE":  0,
	"LINK":     1,
	"PRIORITY": 2,
}

func (x PauseType) String() string {
	return proto.EnumName(PauseType_name, int32(x))
}
func (PauseType) EnumDescriptor() ([]byte, []int) { return fileDescriptorInterface, []int{0} }

type IFStatus int32

const (
	IFStatus_UP   IFStatus = 0
	IFStatus_DOWN IFStatus = 1
)

var IFStatus_name = map[int32]string{
	0: "UP",
	1: "DOWN",
}
var IFStatus_value = map[string]int32{
	"UP":   0,
	"DOWN": 1,
}

func (x IFStatus) String() string {
	return proto.EnumName(IFStatus_name, int32(x))
}
func (IFStatus) EnumDescriptor() ([]byte, []int) { return fileDescriptorInterface, []int{1} }

type InterfaceSpec_IFType int32

const (
	InterfaceSpec_NONE        InterfaceSpec_IFType = 0
	InterfaceSpec_HOST_PF     InterfaceSpec_IFType = 1
	InterfaceSpec_UPLINK_ETH  InterfaceSpec_IFType = 3
	InterfaceSpec_UPLINK_MGMT InterfaceSpec_IFType = 4
	InterfaceSpec_L3          InterfaceSpec_IFType = 5
	InterfaceSpec_LOOPBACK    InterfaceSpec_IFType = 6
)

var InterfaceSpec_IFType_name = map[int32]string{
	0: "NONE",
	1: "HOST_PF",
	3: "UPLINK_ETH",
	4: "UPLINK_MGMT",
	5: "L3",
	6: "LOOPBACK",
}
var InterfaceSpec_IFType_value = map[string]int32{
	"NONE":        0,
	"HOST_PF":     1,
	"UPLINK_ETH":  3,
	"UPLINK_MGMT": 4,
	"L3":          5,
	"LOOPBACK":    6,
}

func (x InterfaceSpec_IFType) String() string {
	return proto.EnumName(InterfaceSpec_IFType_name, int32(x))
}
func (InterfaceSpec_IFType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorInterface, []int{2, 0}
}

type TransceiverStatus_State int32

const (
	TransceiverStatus_STATE_NA             TransceiverStatus_State = 0
	TransceiverStatus_STATE_REMOVED        TransceiverStatus_State = 1
	TransceiverStatus_STATE_INSERTED       TransceiverStatus_State = 2
	TransceiverStatus_STATE_PENDING        TransceiverStatus_State = 3
	TransceiverStatus_STATE_SPROM_READ     TransceiverStatus_State = 4
	TransceiverStatus_STATE_SPROM_READ_ERR TransceiverStatus_State = 5
)

var TransceiverStatus_State_name = map[int32]string{
	0: "STATE_NA",
	1: "STATE_REMOVED",
	2: "STATE_INSERTED",
	3: "STATE_PENDING",
	4: "STATE_SPROM_READ",
	5: "STATE_SPROM_READ_ERR",
}
var TransceiverStatus_State_value = map[string]int32{
	"STATE_NA":             0,
	"STATE_REMOVED":        1,
	"STATE_INSERTED":       2,
	"STATE_PENDING":        3,
	"STATE_SPROM_READ":     4,
	"STATE_SPROM_READ_ERR": 5,
}

func (x TransceiverStatus_State) String() string {
	return proto.EnumName(TransceiverStatus_State_name, int32(x))
}
func (TransceiverStatus_State) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorInterface, []int{5, 0}
}

type TransceiverStatus_CableType int32

const (
	TransceiverStatus_NONE   TransceiverStatus_CableType = 0
	TransceiverStatus_COPPER TransceiverStatus_CableType = 1
	TransceiverStatus_FIBER  TransceiverStatus_CableType = 2
)

var TransceiverStatus_CableType_name = map[int32]string{
	0: "NONE",
	1: "COPPER",
	2: "FIBER",
}
var TransceiverStatus_CableType_value = map[string]int32{
	"NONE":   0,
	"COPPER": 1,
	"FIBER":  2,
}

func (x TransceiverStatus_CableType) String() string {
	return proto.EnumName(TransceiverStatus_CableType_name, int32(x))
}
func (TransceiverStatus_CableType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorInterface, []int{5, 1}
}

type TransceiverStatus_Pid int32

const (
	TransceiverStatus_UNKNOWN TransceiverStatus_Pid = 0
	// CU
	TransceiverStatus_QSFP_100G_CR4    TransceiverStatus_Pid = 1
	TransceiverStatus_QSFP_40GBASE_CR4 TransceiverStatus_Pid = 2
	TransceiverStatus_SFP_25GBASE_CR_S TransceiverStatus_Pid = 3
	TransceiverStatus_SFP_25GBASE_CR_L TransceiverStatus_Pid = 4
	TransceiverStatus_SFP_25GBASE_CR_N TransceiverStatus_Pid = 5
	// Fiber, grouping all together
	TransceiverStatus_QSFP_100G_AOC    TransceiverStatus_Pid = 50
	TransceiverStatus_QSFP_100G_ACC    TransceiverStatus_Pid = 51
	TransceiverStatus_QSFP_100G_SR4    TransceiverStatus_Pid = 52
	TransceiverStatus_QSFP_100G_LR4    TransceiverStatus_Pid = 53
	TransceiverStatus_QSFP_100G_ER4    TransceiverStatus_Pid = 54
	TransceiverStatus_QSFP_40GBASE_ER4 TransceiverStatus_Pid = 55
	TransceiverStatus_QSFP_40GBASE_SR4 TransceiverStatus_Pid = 56
	TransceiverStatus_QSFP_40GBASE_LR4 TransceiverStatus_Pid = 57
	TransceiverStatus_QSFP_40GBASE_AOC TransceiverStatus_Pid = 58
	TransceiverStatus_SFP_25GBASE_SR   TransceiverStatus_Pid = 59
	TransceiverStatus_SFP_25GBASE_LR   TransceiverStatus_Pid = 60
	TransceiverStatus_SFP_25GBASE_ER   TransceiverStatus_Pid = 61
	TransceiverStatus_SFP_25GBASE_AOC  TransceiverStatus_Pid = 62
	TransceiverStatus_SFP_10GBASE_SR   TransceiverStatus_Pid = 63
	TransceiverStatus_SFP_10GBASE_LR   TransceiverStatus_Pid = 64
	TransceiverStatus_SFP_10GBASE_LRM  TransceiverStatus_Pid = 65
	TransceiverStatus_SFP_10GBASE_ER   TransceiverStatus_Pid = 66
	TransceiverStatus_SFP_10GBASE_AOC  TransceiverStatus_Pid = 67
	TransceiverStatus_SFP_10GBASE_CU   TransceiverStatus_Pid = 68
	TransceiverStatus_QSFP_100G_CWDM4  TransceiverStatus_Pid = 69
	TransceiverStatus_QSFP_100G_PSM4   TransceiverStatus_Pid = 70
	TransceiverStatus_PID_NA           TransceiverStatus_Pid = 1000
)

var TransceiverStatus_Pid_name = map[int32]string{
	0:    "UNKNOWN",
	1:    "QSFP_100G_CR4",
	2:    "QSFP_40GBASE_CR4",
	3:    "SFP_25GBASE_CR_S",
	4:    "SFP_25GBASE_CR_L",
	5:    "SFP_25GBASE_CR_N",
	50:   "QSFP_100G_AOC",
	51:   "QSFP_100G_ACC",
	52:   "QSFP_100G_SR4",
	53:   "QSFP_100G_LR4",
	54:   "QSFP_100G_ER4",
	55:   "QSFP_40GBASE_ER4",
	56:   "QSFP_40GBASE_SR4",
	57:   "QSFP_40GBASE_LR4",
	58:   "QSFP_40GBASE_AOC",
	59:   "SFP_25GBASE_SR",
	60:   "SFP_25GBASE_LR",
	61:   "SFP_25GBASE_ER",
	62:   "SFP_25GBASE_AOC",
	63:   "SFP_10GBASE_SR",
	64:   "SFP_10GBASE_LR",
	65:   "SFP_10GBASE_LRM",
	66:   "SFP_10GBASE_ER",
	67:   "SFP_10GBASE_AOC",
	68:   "SFP_10GBASE_CU",
	69:   "QSFP_100G_CWDM4",
	70:   "QSFP_100G_PSM4",
	1000: "PID_NA",
}
var TransceiverStatus_Pid_value = map[string]int32{
	"UNKNOWN":          0,
	"QSFP_100G_CR4":    1,
	"QSFP_40GBASE_CR4": 2,
	"SFP_25GBASE_CR_S": 3,
	"SFP_25GBASE_CR_L": 4,
	"SFP_25GBASE_CR_N": 5,
	"QSFP_100G_AOC":    50,
	"QSFP_100G_ACC":    51,
	"QSFP_100G_SR4":    52,
	"QSFP_100G_LR4":    53,
	"QSFP_100G_ER4":    54,
	"QSFP_40GBASE_ER4": 55,
	"QSFP_40GBASE_SR4": 56,
	"QSFP_40GBASE_LR4": 57,
	"QSFP_40GBASE_AOC": 58,
	"SFP_25GBASE_SR":   59,
	"SFP_25GBASE_LR":   60,
	"SFP_25GBASE_ER":   61,
	"SFP_25GBASE_AOC":  62,
	"SFP_10GBASE_SR":   63,
	"SFP_10GBASE_LR":   64,
	"SFP_10GBASE_LRM":  65,
	"SFP_10GBASE_ER":   66,
	"SFP_10GBASE_AOC":  67,
	"SFP_10GBASE_CU":   68,
	"QSFP_100G_CWDM4":  69,
	"QSFP_100G_PSM4":   70,
	"PID_NA":           1000,
}

func (x TransceiverStatus_Pid) String() string {
	return proto.EnumName(TransceiverStatus_Pid_name, int32(x))
}
func (TransceiverStatus_Pid) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorInterface, []int{5, 2}
}

// Interface object
type Interface struct {
	api.TypeMeta   `protobuf:"bytes,1,opt,name=TypeMeta,embedded=TypeMeta" json:",inline"`
	api.ObjectMeta `protobuf:"bytes,2,opt,name=ObjectMeta,embedded=ObjectMeta" json:"meta,omitempty"`
	Spec           InterfaceSpec   `protobuf:"bytes,3,opt,name=Spec" json:"spec,omitempty"`
	Status         InterfaceStatus `protobuf:"bytes,4,opt,name=Status" json:"status,omitempty"`
}

func (m *Interface) Reset()                    { *m = Interface{} }
func (m *Interface) String() string            { return proto.CompactTextString(m) }
func (*Interface) ProtoMessage()               {}
func (*Interface) Descriptor() ([]byte, []int) { return fileDescriptorInterface, []int{0} }

func (m *Interface) GetSpec() InterfaceSpec {
	if m != nil {
		return m.Spec
	}
	return InterfaceSpec{}
}

func (m *Interface) GetStatus() InterfaceStatus {
	if m != nil {
		return m.Status
	}
	return InterfaceStatus{}
}

type PauseSpec struct {
	// Pause type
	Type string `protobuf:"bytes,1,opt,name=Type,proto3" json:"type,omitempty"`
	// TX Pause enabled
	TxPauseEnabled bool `protobuf:"varint,2,opt,name=TxPauseEnabled,proto3" json:"tx-pause-enabled,omitempty"`
	// RX Pause enabled
	RxPauseEnabled bool `protobuf:"varint,3,opt,name=RxPauseEnabled,proto3" json:"rx-pause-enabled,omitempty"`
}

func (m *PauseSpec) Reset()                    { *m = PauseSpec{} }
func (m *PauseSpec) String() string            { return proto.CompactTextString(m) }
func (*PauseSpec) ProtoMessage()               {}
func (*PauseSpec) Descriptor() ([]byte, []int) { return fileDescriptorInterface, []int{1} }

func (m *PauseSpec) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *PauseSpec) GetTxPauseEnabled() bool {
	if m != nil {
		return m.TxPauseEnabled
	}
	return false
}

func (m *PauseSpec) GetRxPauseEnabled() bool {
	if m != nil {
		return m.RxPauseEnabled
	}
	return false
}

// InterfaceSpec captures all the interface level configuration
type InterfaceSpec struct {
	Type        string `protobuf:"bytes,1,opt,name=Type,proto3" json:"type,omitempty"`
	AdminStatus string `protobuf:"bytes,2,opt,name=AdminStatus,proto3" json:"admin-status,omitempty"`
	// VrfName specifies the name of the VRF that the current Interface belongs to
	VrfName string `protobuf:"bytes,3,opt,name=VrfName,proto3" json:"vrf-name,omitemtpy"`
	// Inteface speed
	Speed string `protobuf:"bytes,4,opt,name=Speed,proto3" json:"speed,omitempty"`
	// Mtu of the interface
	MTU uint32 `protobuf:"varint,5,opt,name=MTU,proto3" json:"mtu,omitempty"`
	// Pause Spec
	Pause *PauseSpec `protobuf:"bytes,6,opt,name=Pause" json:"pause,omitempty"`
}

func (m *InterfaceSpec) Reset()                    { *m = InterfaceSpec{} }
func (m *InterfaceSpec) String() string            { return proto.CompactTextString(m) }
func (*InterfaceSpec) ProtoMessage()               {}
func (*InterfaceSpec) Descriptor() ([]byte, []int) { return fileDescriptorInterface, []int{2} }

func (m *InterfaceSpec) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *InterfaceSpec) GetAdminStatus() string {
	if m != nil {
		return m.AdminStatus
	}
	return ""
}

func (m *InterfaceSpec) GetVrfName() string {
	if m != nil {
		return m.VrfName
	}
	return ""
}

func (m *InterfaceSpec) GetSpeed() string {
	if m != nil {
		return m.Speed
	}
	return ""
}

func (m *InterfaceSpec) GetMTU() uint32 {
	if m != nil {
		return m.MTU
	}
	return 0
}

func (m *InterfaceSpec) GetPause() *PauseSpec {
	if m != nil {
		return m.Pause
	}
	return nil
}

// InterfaceHostStatus is populated for PF and VF
type InterfaceHostStatus struct {
	// interface name seen by the host driver
	HostIfName string `protobuf:"bytes,1,opt,name=HostIfName,proto3" json:"host-ifname,omitempty"`
}

func (m *InterfaceHostStatus) Reset()                    { *m = InterfaceHostStatus{} }
func (m *InterfaceHostStatus) String() string            { return proto.CompactTextString(m) }
func (*InterfaceHostStatus) ProtoMessage()               {}
func (*InterfaceHostStatus) Descriptor() ([]byte, []int) { return fileDescriptorInterface, []int{3} }

func (m *InterfaceHostStatus) GetHostIfName() string {
	if m != nil {
		return m.HostIfName
	}
	return ""
}

type InterfaceUplinkStatus struct {
	// LinkSpeed auto-negotiated
	LinkSpeed         string             `protobuf:"bytes,1,opt,name=LinkSpeed,proto3" json:"link-speed,omitempty"`
	TransceiverStatus *TransceiverStatus `protobuf:"bytes,2,opt,name=TransceiverStatus" json:"transceiver-status,omitempty"`
	PortID            uint32             `protobuf:"varint,3,opt,name=PortID,proto3" json:"uplink-port-id,omitempty"`
}

func (m *InterfaceUplinkStatus) Reset()                    { *m = InterfaceUplinkStatus{} }
func (m *InterfaceUplinkStatus) String() string            { return proto.CompactTextString(m) }
func (*InterfaceUplinkStatus) ProtoMessage()               {}
func (*InterfaceUplinkStatus) Descriptor() ([]byte, []int) { return fileDescriptorInterface, []int{4} }

func (m *InterfaceUplinkStatus) GetLinkSpeed() string {
	if m != nil {
		return m.LinkSpeed
	}
	return ""
}

func (m *InterfaceUplinkStatus) GetTransceiverStatus() *TransceiverStatus {
	if m != nil {
		return m.TransceiverStatus
	}
	return nil
}

func (m *InterfaceUplinkStatus) GetPortID() uint32 {
	if m != nil {
		return m.PortID
	}
	return 0
}

type TransceiverStatus struct {
	TransceiverState    string `protobuf:"bytes,1,opt,name=TransceiverState,proto3" json:"state,omitempty"`
	TranceiverCableType string `protobuf:"bytes,2,opt,name=TranceiverCableType,proto3" json:"cable-type,omitempty"`
	TranceiverPid       string `protobuf:"bytes,3,opt,name=TranceiverPid,proto3" json:"pid,omitempty"`
}

func (m *TransceiverStatus) Reset()                    { *m = TransceiverStatus{} }
func (m *TransceiverStatus) String() string            { return proto.CompactTextString(m) }
func (*TransceiverStatus) ProtoMessage()               {}
func (*TransceiverStatus) Descriptor() ([]byte, []int) { return fileDescriptorInterface, []int{5} }

func (m *TransceiverStatus) GetTransceiverState() string {
	if m != nil {
		return m.TransceiverState
	}
	return ""
}

func (m *TransceiverStatus) GetTranceiverCableType() string {
	if m != nil {
		return m.TranceiverCableType
	}
	return ""
}

func (m *TransceiverStatus) GetTranceiverPid() string {
	if m != nil {
		return m.TranceiverPid
	}
	return ""
}

// InterfaceStatus
type InterfaceStatus struct {
	Name           string                `protobuf:"bytes,1,opt,name=Name,proto3" json:"dsc,omitempty"`
	InterfaceID    uint64                `protobuf:"varint,2,opt,name=InterfaceID,proto3" json:"id,omitempty"`
	DSC            string                `protobuf:"bytes,3,opt,name=DSC,proto3" json:"dsc,omitempty"`
	OperStatus     string                `protobuf:"bytes,4,opt,name=OperStatus,proto3" json:"oper-status,omitempty"`
	PrimaryMac     string                `protobuf:"bytes,5,opt,name=PrimaryMac,proto3" json:"primary-mac,omitempty"`
	IFHostStatus   InterfaceHostStatus   `protobuf:"bytes,6,opt,name=IFHostStatus" json:"if-host-status,omitempty"`
	IFUplinkStatus InterfaceUplinkStatus `protobuf:"bytes,7,opt,name=IFUplinkStatus" json:"if-uplink-status,omitempty"`
	MirrorEnabled  bool                  `protobuf:"varint,8,opt,name=MirrorEnabled,proto3" json:"mirror-enabled,omitempty"`
}

func (m *InterfaceStatus) Reset()                    { *m = InterfaceStatus{} }
func (m *InterfaceStatus) String() string            { return proto.CompactTextString(m) }
func (*InterfaceStatus) ProtoMessage()               {}
func (*InterfaceStatus) Descriptor() ([]byte, []int) { return fileDescriptorInterface, []int{6} }

func (m *InterfaceStatus) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *InterfaceStatus) GetInterfaceID() uint64 {
	if m != nil {
		return m.InterfaceID
	}
	return 0
}

func (m *InterfaceStatus) GetDSC() string {
	if m != nil {
		return m.DSC
	}
	return ""
}

func (m *InterfaceStatus) GetOperStatus() string {
	if m != nil {
		return m.OperStatus
	}
	return ""
}

func (m *InterfaceStatus) GetPrimaryMac() string {
	if m != nil {
		return m.PrimaryMac
	}
	return ""
}

func (m *InterfaceStatus) GetIFHostStatus() InterfaceHostStatus {
	if m != nil {
		return m.IFHostStatus
	}
	return InterfaceHostStatus{}
}

func (m *InterfaceStatus) GetIFUplinkStatus() InterfaceUplinkStatus {
	if m != nil {
		return m.IFUplinkStatus
	}
	return InterfaceUplinkStatus{}
}

func (m *InterfaceStatus) GetMirrorEnabled() bool {
	if m != nil {
		return m.MirrorEnabled
	}
	return false
}

type InterfaceList struct {
	Interfaces []*Interface `protobuf:"bytes,1,rep,name=interfaces" json:"interfaces,omitempty"`
}

func (m *InterfaceList) Reset()                    { *m = InterfaceList{} }
func (m *InterfaceList) String() string            { return proto.CompactTextString(m) }
func (*InterfaceList) ProtoMessage()               {}
func (*InterfaceList) Descriptor() ([]byte, []int) { return fileDescriptorInterface, []int{7} }

func (m *InterfaceList) GetInterfaces() []*Interface {
	if m != nil {
		return m.Interfaces
	}
	return nil
}

// interaface watch event
type InterfaceEvent struct {
	EventType api.EventType `protobuf:"varint,1,opt,name=EventType,proto3,enum=api.EventType" json:"event-type,omitempty"`
	Interface Interface     `protobuf:"bytes,2,opt,name=Interface" json:"interface,omitempty"`
}

func (m *InterfaceEvent) Reset()                    { *m = InterfaceEvent{} }
func (m *InterfaceEvent) String() string            { return proto.CompactTextString(m) }
func (*InterfaceEvent) ProtoMessage()               {}
func (*InterfaceEvent) Descriptor() ([]byte, []int) { return fileDescriptorInterface, []int{8} }

func (m *InterfaceEvent) GetEventType() api.EventType {
	if m != nil {
		return m.EventType
	}
	return api.EventType_CreateEvent
}

func (m *InterfaceEvent) GetInterface() Interface {
	if m != nil {
		return m.Interface
	}
	return Interface{}
}

// interface watch events batched
type InterfaceEventList struct {
	InterfaceEvents []*InterfaceEvent `protobuf:"bytes,1,rep,name=InterfaceEvents" json:"InterfaceEvents,omitempty"`
}

func (m *InterfaceEventList) Reset()                    { *m = InterfaceEventList{} }
func (m *InterfaceEventList) String() string            { return proto.CompactTextString(m) }
func (*InterfaceEventList) ProtoMessage()               {}
func (*InterfaceEventList) Descriptor() ([]byte, []int) { return fileDescriptorInterface, []int{9} }

func (m *InterfaceEventList) GetInterfaceEvents() []*InterfaceEvent {
	if m != nil {
		return m.InterfaceEvents
	}
	return nil
}

func init() {
	proto.RegisterType((*Interface)(nil), "netproto.Interface")
	proto.RegisterType((*PauseSpec)(nil), "netproto.PauseSpec")
	proto.RegisterType((*InterfaceSpec)(nil), "netproto.InterfaceSpec")
	proto.RegisterType((*InterfaceHostStatus)(nil), "netproto.InterfaceHostStatus")
	proto.RegisterType((*InterfaceUplinkStatus)(nil), "netproto.InterfaceUplinkStatus")
	proto.RegisterType((*TransceiverStatus)(nil), "netproto.TransceiverStatus")
	proto.RegisterType((*InterfaceStatus)(nil), "netproto.InterfaceStatus")
	proto.RegisterType((*InterfaceList)(nil), "netproto.InterfaceList")
	proto.RegisterType((*InterfaceEvent)(nil), "netproto.InterfaceEvent")
	proto.RegisterType((*InterfaceEventList)(nil), "netproto.InterfaceEventList")
	proto.RegisterEnum("netproto.PauseType", PauseType_name, PauseType_value)
	proto.RegisterEnum("netproto.IFStatus", IFStatus_name, IFStatus_value)
	proto.RegisterEnum("netproto.InterfaceSpec_IFType", InterfaceSpec_IFType_name, InterfaceSpec_IFType_value)
	proto.RegisterEnum("netproto.TransceiverStatus_State", TransceiverStatus_State_name, TransceiverStatus_State_value)
	proto.RegisterEnum("netproto.TransceiverStatus_CableType", TransceiverStatus_CableType_name, TransceiverStatus_CableType_value)
	proto.RegisterEnum("netproto.TransceiverStatus_Pid", TransceiverStatus_Pid_name, TransceiverStatus_Pid_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for InterfaceApiV1 service

type InterfaceApiV1Client interface {
	ListInterfaces(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (*InterfaceList, error)
	WatchInterfaces(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (InterfaceApiV1_WatchInterfacesClient, error)
	InterfaceOperUpdate(ctx context.Context, opts ...grpc.CallOption) (InterfaceApiV1_InterfaceOperUpdateClient, error)
	CreateInterface(ctx context.Context, in *Interface, opts ...grpc.CallOption) (*Interface, error)
}

type interfaceApiV1Client struct {
	cc *grpc.ClientConn
}

func NewInterfaceApiV1Client(cc *grpc.ClientConn) InterfaceApiV1Client {
	return &interfaceApiV1Client{cc}
}

func (c *interfaceApiV1Client) ListInterfaces(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (*InterfaceList, error) {
	out := new(InterfaceList)
	err := grpc.Invoke(ctx, "/netproto.InterfaceApiV1/ListInterfaces", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *interfaceApiV1Client) WatchInterfaces(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (InterfaceApiV1_WatchInterfacesClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_InterfaceApiV1_serviceDesc.Streams[0], c.cc, "/netproto.InterfaceApiV1/WatchInterfaces", opts...)
	if err != nil {
		return nil, err
	}
	x := &interfaceApiV1WatchInterfacesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type InterfaceApiV1_WatchInterfacesClient interface {
	Recv() (*InterfaceEventList, error)
	grpc.ClientStream
}

type interfaceApiV1WatchInterfacesClient struct {
	grpc.ClientStream
}

func (x *interfaceApiV1WatchInterfacesClient) Recv() (*InterfaceEventList, error) {
	m := new(InterfaceEventList)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *interfaceApiV1Client) InterfaceOperUpdate(ctx context.Context, opts ...grpc.CallOption) (InterfaceApiV1_InterfaceOperUpdateClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_InterfaceApiV1_serviceDesc.Streams[1], c.cc, "/netproto.InterfaceApiV1/InterfaceOperUpdate", opts...)
	if err != nil {
		return nil, err
	}
	x := &interfaceApiV1InterfaceOperUpdateClient{stream}
	return x, nil
}

type InterfaceApiV1_InterfaceOperUpdateClient interface {
	Send(*InterfaceEvent) error
	CloseAndRecv() (*api.TypeMeta, error)
	grpc.ClientStream
}

type interfaceApiV1InterfaceOperUpdateClient struct {
	grpc.ClientStream
}

func (x *interfaceApiV1InterfaceOperUpdateClient) Send(m *InterfaceEvent) error {
	return x.ClientStream.SendMsg(m)
}

func (x *interfaceApiV1InterfaceOperUpdateClient) CloseAndRecv() (*api.TypeMeta, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(api.TypeMeta)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *interfaceApiV1Client) CreateInterface(ctx context.Context, in *Interface, opts ...grpc.CallOption) (*Interface, error) {
	out := new(Interface)
	err := grpc.Invoke(ctx, "/netproto.InterfaceApiV1/CreateInterface", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for InterfaceApiV1 service

type InterfaceApiV1Server interface {
	ListInterfaces(context.Context, *api.ListWatchOptions) (*InterfaceList, error)
	WatchInterfaces(*api.ListWatchOptions, InterfaceApiV1_WatchInterfacesServer) error
	InterfaceOperUpdate(InterfaceApiV1_InterfaceOperUpdateServer) error
	CreateInterface(context.Context, *Interface) (*Interface, error)
}

func RegisterInterfaceApiV1Server(s *grpc.Server, srv InterfaceApiV1Server) {
	s.RegisterService(&_InterfaceApiV1_serviceDesc, srv)
}

func _InterfaceApiV1_ListInterfaces_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(api.ListWatchOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InterfaceApiV1Server).ListInterfaces(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/netproto.InterfaceApiV1/ListInterfaces",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InterfaceApiV1Server).ListInterfaces(ctx, req.(*api.ListWatchOptions))
	}
	return interceptor(ctx, in, info, handler)
}

func _InterfaceApiV1_WatchInterfaces_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(api.ListWatchOptions)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(InterfaceApiV1Server).WatchInterfaces(m, &interfaceApiV1WatchInterfacesServer{stream})
}

type InterfaceApiV1_WatchInterfacesServer interface {
	Send(*InterfaceEventList) error
	grpc.ServerStream
}

type interfaceApiV1WatchInterfacesServer struct {
	grpc.ServerStream
}

func (x *interfaceApiV1WatchInterfacesServer) Send(m *InterfaceEventList) error {
	return x.ServerStream.SendMsg(m)
}

func _InterfaceApiV1_InterfaceOperUpdate_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(InterfaceApiV1Server).InterfaceOperUpdate(&interfaceApiV1InterfaceOperUpdateServer{stream})
}

type InterfaceApiV1_InterfaceOperUpdateServer interface {
	SendAndClose(*api.TypeMeta) error
	Recv() (*InterfaceEvent, error)
	grpc.ServerStream
}

type interfaceApiV1InterfaceOperUpdateServer struct {
	grpc.ServerStream
}

func (x *interfaceApiV1InterfaceOperUpdateServer) SendAndClose(m *api.TypeMeta) error {
	return x.ServerStream.SendMsg(m)
}

func (x *interfaceApiV1InterfaceOperUpdateServer) Recv() (*InterfaceEvent, error) {
	m := new(InterfaceEvent)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _InterfaceApiV1_CreateInterface_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Interface)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InterfaceApiV1Server).CreateInterface(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/netproto.InterfaceApiV1/CreateInterface",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InterfaceApiV1Server).CreateInterface(ctx, req.(*Interface))
	}
	return interceptor(ctx, in, info, handler)
}

var _InterfaceApiV1_serviceDesc = grpc.ServiceDesc{
	ServiceName: "netproto.InterfaceApiV1",
	HandlerType: (*InterfaceApiV1Server)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListInterfaces",
			Handler:    _InterfaceApiV1_ListInterfaces_Handler,
		},
		{
			MethodName: "CreateInterface",
			Handler:    _InterfaceApiV1_CreateInterface_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "WatchInterfaces",
			Handler:       _InterfaceApiV1_WatchInterfaces_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "InterfaceOperUpdate",
			Handler:       _InterfaceApiV1_InterfaceOperUpdate_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "interface.proto",
}

func (m *Interface) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Interface) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintInterface(dAtA, i, uint64(m.TypeMeta.Size()))
	n1, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n1
	dAtA[i] = 0x12
	i++
	i = encodeVarintInterface(dAtA, i, uint64(m.ObjectMeta.Size()))
	n2, err := m.ObjectMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n2
	dAtA[i] = 0x1a
	i++
	i = encodeVarintInterface(dAtA, i, uint64(m.Spec.Size()))
	n3, err := m.Spec.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n3
	dAtA[i] = 0x22
	i++
	i = encodeVarintInterface(dAtA, i, uint64(m.Status.Size()))
	n4, err := m.Status.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n4
	return i, nil
}

func (m *PauseSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PauseSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintInterface(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if m.TxPauseEnabled {
		dAtA[i] = 0x10
		i++
		if m.TxPauseEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.RxPauseEnabled {
		dAtA[i] = 0x18
		i++
		if m.RxPauseEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *InterfaceSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InterfaceSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintInterface(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.AdminStatus) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintInterface(dAtA, i, uint64(len(m.AdminStatus)))
		i += copy(dAtA[i:], m.AdminStatus)
	}
	if len(m.VrfName) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintInterface(dAtA, i, uint64(len(m.VrfName)))
		i += copy(dAtA[i:], m.VrfName)
	}
	if len(m.Speed) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintInterface(dAtA, i, uint64(len(m.Speed)))
		i += copy(dAtA[i:], m.Speed)
	}
	if m.MTU != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintInterface(dAtA, i, uint64(m.MTU))
	}
	if m.Pause != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintInterface(dAtA, i, uint64(m.Pause.Size()))
		n5, err := m.Pause.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	return i, nil
}

func (m *InterfaceHostStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InterfaceHostStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.HostIfName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintInterface(dAtA, i, uint64(len(m.HostIfName)))
		i += copy(dAtA[i:], m.HostIfName)
	}
	return i, nil
}

func (m *InterfaceUplinkStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InterfaceUplinkStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.LinkSpeed) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintInterface(dAtA, i, uint64(len(m.LinkSpeed)))
		i += copy(dAtA[i:], m.LinkSpeed)
	}
	if m.TransceiverStatus != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintInterface(dAtA, i, uint64(m.TransceiverStatus.Size()))
		n6, err := m.TransceiverStatus.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.PortID != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintInterface(dAtA, i, uint64(m.PortID))
	}
	return i, nil
}

func (m *TransceiverStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransceiverStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.TransceiverState) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintInterface(dAtA, i, uint64(len(m.TransceiverState)))
		i += copy(dAtA[i:], m.TransceiverState)
	}
	if len(m.TranceiverCableType) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintInterface(dAtA, i, uint64(len(m.TranceiverCableType)))
		i += copy(dAtA[i:], m.TranceiverCableType)
	}
	if len(m.TranceiverPid) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintInterface(dAtA, i, uint64(len(m.TranceiverPid)))
		i += copy(dAtA[i:], m.TranceiverPid)
	}
	return i, nil
}

func (m *InterfaceStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InterfaceStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintInterface(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.InterfaceID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintInterface(dAtA, i, uint64(m.InterfaceID))
	}
	if len(m.DSC) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintInterface(dAtA, i, uint64(len(m.DSC)))
		i += copy(dAtA[i:], m.DSC)
	}
	if len(m.OperStatus) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintInterface(dAtA, i, uint64(len(m.OperStatus)))
		i += copy(dAtA[i:], m.OperStatus)
	}
	if len(m.PrimaryMac) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintInterface(dAtA, i, uint64(len(m.PrimaryMac)))
		i += copy(dAtA[i:], m.PrimaryMac)
	}
	dAtA[i] = 0x32
	i++
	i = encodeVarintInterface(dAtA, i, uint64(m.IFHostStatus.Size()))
	n7, err := m.IFHostStatus.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n7
	dAtA[i] = 0x3a
	i++
	i = encodeVarintInterface(dAtA, i, uint64(m.IFUplinkStatus.Size()))
	n8, err := m.IFUplinkStatus.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n8
	if m.MirrorEnabled {
		dAtA[i] = 0x40
		i++
		if m.MirrorEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *InterfaceList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InterfaceList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Interfaces) > 0 {
		for _, msg := range m.Interfaces {
			dAtA[i] = 0xa
			i++
			i = encodeVarintInterface(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *InterfaceEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InterfaceEvent) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.EventType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintInterface(dAtA, i, uint64(m.EventType))
	}
	dAtA[i] = 0x12
	i++
	i = encodeVarintInterface(dAtA, i, uint64(m.Interface.Size()))
	n9, err := m.Interface.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n9
	return i, nil
}

func (m *InterfaceEventList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InterfaceEventList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.InterfaceEvents) > 0 {
		for _, msg := range m.InterfaceEvents {
			dAtA[i] = 0xa
			i++
			i = encodeVarintInterface(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func encodeVarintInterface(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Interface) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovInterface(uint64(l))
	l = m.ObjectMeta.Size()
	n += 1 + l + sovInterface(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovInterface(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovInterface(uint64(l))
	return n
}

func (m *PauseSpec) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovInterface(uint64(l))
	}
	if m.TxPauseEnabled {
		n += 2
	}
	if m.RxPauseEnabled {
		n += 2
	}
	return n
}

func (m *InterfaceSpec) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovInterface(uint64(l))
	}
	l = len(m.AdminStatus)
	if l > 0 {
		n += 1 + l + sovInterface(uint64(l))
	}
	l = len(m.VrfName)
	if l > 0 {
		n += 1 + l + sovInterface(uint64(l))
	}
	l = len(m.Speed)
	if l > 0 {
		n += 1 + l + sovInterface(uint64(l))
	}
	if m.MTU != 0 {
		n += 1 + sovInterface(uint64(m.MTU))
	}
	if m.Pause != nil {
		l = m.Pause.Size()
		n += 1 + l + sovInterface(uint64(l))
	}
	return n
}

func (m *InterfaceHostStatus) Size() (n int) {
	var l int
	_ = l
	l = len(m.HostIfName)
	if l > 0 {
		n += 1 + l + sovInterface(uint64(l))
	}
	return n
}

func (m *InterfaceUplinkStatus) Size() (n int) {
	var l int
	_ = l
	l = len(m.LinkSpeed)
	if l > 0 {
		n += 1 + l + sovInterface(uint64(l))
	}
	if m.TransceiverStatus != nil {
		l = m.TransceiverStatus.Size()
		n += 1 + l + sovInterface(uint64(l))
	}
	if m.PortID != 0 {
		n += 1 + sovInterface(uint64(m.PortID))
	}
	return n
}

func (m *TransceiverStatus) Size() (n int) {
	var l int
	_ = l
	l = len(m.TransceiverState)
	if l > 0 {
		n += 1 + l + sovInterface(uint64(l))
	}
	l = len(m.TranceiverCableType)
	if l > 0 {
		n += 1 + l + sovInterface(uint64(l))
	}
	l = len(m.TranceiverPid)
	if l > 0 {
		n += 1 + l + sovInterface(uint64(l))
	}
	return n
}

func (m *InterfaceStatus) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovInterface(uint64(l))
	}
	if m.InterfaceID != 0 {
		n += 1 + sovInterface(uint64(m.InterfaceID))
	}
	l = len(m.DSC)
	if l > 0 {
		n += 1 + l + sovInterface(uint64(l))
	}
	l = len(m.OperStatus)
	if l > 0 {
		n += 1 + l + sovInterface(uint64(l))
	}
	l = len(m.PrimaryMac)
	if l > 0 {
		n += 1 + l + sovInterface(uint64(l))
	}
	l = m.IFHostStatus.Size()
	n += 1 + l + sovInterface(uint64(l))
	l = m.IFUplinkStatus.Size()
	n += 1 + l + sovInterface(uint64(l))
	if m.MirrorEnabled {
		n += 2
	}
	return n
}

func (m *InterfaceList) Size() (n int) {
	var l int
	_ = l
	if len(m.Interfaces) > 0 {
		for _, e := range m.Interfaces {
			l = e.Size()
			n += 1 + l + sovInterface(uint64(l))
		}
	}
	return n
}

func (m *InterfaceEvent) Size() (n int) {
	var l int
	_ = l
	if m.EventType != 0 {
		n += 1 + sovInterface(uint64(m.EventType))
	}
	l = m.Interface.Size()
	n += 1 + l + sovInterface(uint64(l))
	return n
}

func (m *InterfaceEventList) Size() (n int) {
	var l int
	_ = l
	if len(m.InterfaceEvents) > 0 {
		for _, e := range m.InterfaceEvents {
			l = e.Size()
			n += 1 + l + sovInterface(uint64(l))
		}
	}
	return n
}

func sovInterface(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozInterface(x uint64) (n int) {
	return sovInterface(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Interface) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Interface: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Interface: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PauseSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PauseSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PauseSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxPauseEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TxPauseEnabled = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RxPauseEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RxPauseEnabled = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InterfaceSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InterfaceSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InterfaceSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdminStatus", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AdminStatus = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VrfName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VrfName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Speed", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Speed = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MTU", wireType)
			}
			m.MTU = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MTU |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pause", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pause == nil {
				m.Pause = &PauseSpec{}
			}
			if err := m.Pause.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InterfaceHostStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InterfaceHostStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InterfaceHostStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostIfName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostIfName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InterfaceUplinkStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InterfaceUplinkStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InterfaceUplinkStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LinkSpeed", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LinkSpeed = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransceiverStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TransceiverStatus == nil {
				m.TransceiverStatus = &TransceiverStatus{}
			}
			if err := m.TransceiverStatus.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortID", wireType)
			}
			m.PortID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PortID |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TransceiverStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TransceiverStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TransceiverStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransceiverState", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TransceiverState = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TranceiverCableType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TranceiverCableType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TranceiverPid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TranceiverPid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InterfaceStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InterfaceStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InterfaceStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InterfaceID", wireType)
			}
			m.InterfaceID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InterfaceID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DSC", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DSC = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperStatus", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OperStatus = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrimaryMac", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrimaryMac = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IFHostStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.IFHostStatus.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IFUplinkStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.IFUplinkStatus.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MirrorEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MirrorEnabled = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InterfaceList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InterfaceList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InterfaceList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Interfaces", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Interfaces = append(m.Interfaces, &Interface{})
			if err := m.Interfaces[len(m.Interfaces)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InterfaceEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InterfaceEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InterfaceEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventType", wireType)
			}
			m.EventType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EventType |= (api.EventType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Interface", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Interface.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InterfaceEventList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InterfaceEventList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InterfaceEventList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InterfaceEvents", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInterface
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InterfaceEvents = append(m.InterfaceEvents, &InterfaceEvent{})
			if err := m.InterfaceEvents[len(m.InterfaceEvents)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipInterface(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowInterface
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowInterface
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthInterface
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowInterface
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipInterface(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthInterface = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowInterface   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("interface.proto", fileDescriptorInterface) }

var fileDescriptorInterface = []byte{
	// 1741 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x84, 0x57, 0x4f, 0x73, 0xe2, 0xc8,
	0x15, 0xb7, 0x30, 0xc6, 0xf0, 0x30, 0xd0, 0xd3, 0x1e, 0xcf, 0x02, 0xeb, 0x35, 0x2e, 0x25, 0x5b,
	0xf1, 0x6c, 0x0d, 0xe0, 0xb1, 0xd9, 0xdd, 0x6c, 0xb2, 0xb3, 0x59, 0x04, 0xc2, 0xc3, 0x9a, 0x3f,
	0x5a, 0x81, 0x67, 0xb2, 0x27, 0x4a, 0x06, 0xd9, 0xa3, 0x0c, 0x48, 0x2a, 0x49, 0x4c, 0xd6, 0x95,
	0xda, 0xca, 0x21, 0x55, 0x2e, 0x9f, 0x73, 0xcc, 0x27, 0x48, 0xf9, 0x90, 0x43, 0xaa, 0xf2, 0x1d,
	0xe6, 0xb8, 0x9f, 0x80, 0x4a, 0x7c, 0x4a, 0xf9, 0x98, 0x5b, 0x6e, 0xa9, 0x6e, 0x09, 0xa9, 0x05,
	0x78, 0x73, 0x53, 0xff, 0xfa, 0xd7, 0xbf, 0xf7, 0xfa, 0x75, 0x3f, 0xbd, 0xd7, 0x90, 0xd1, 0x74,
	0x47, 0xb5, 0x2e, 0x94, 0xa1, 0x5a, 0x32, 0x2d, 0xc3, 0x31, 0x70, 0x5c, 0x57, 0x1d, 0xfa, 0x95,
	0xdf, 0xbd, 0x34, 0x8c, 0xcb, 0xb1, 0x5a, 0x56, 0x4c, 0xad, 0xac, 0xe8, 0xba, 0xe1, 0x28, 0x8e,
	0x66, 0xe8, 0xb6, 0xcb, 0xcb, 0x8b, 0x97, 0x9a, 0xf3, 0x66, 0x7a, 0x5e, 0x1a, 0x1a, 0x93, 0xb2,
	0xa9, 0xea, 0xb6, 0xa2, 0x8f, 0x8c, 0xb2, 0xfd, 0xfb, 0xf2, 0x3b, 0x55, 0xd7, 0x86, 0x6a, 0x79,
	0xea, 0x68, 0x63, 0x9b, 0x2c, 0xbd, 0x54, 0x75, 0x76, 0x75, 0x59, 0xd3, 0x87, 0xe3, 0xe9, 0x48,
	0x9d, 0xcb, 0x14, 0x19, 0x99, 0x4b, 0xe3, 0xd2, 0x28, 0x53, 0xf8, 0x7c, 0x7a, 0x41, 0x47, 0x74,
	0x40, 0xbf, 0x3c, 0xfa, 0xc7, 0x0f, 0x58, 0x25, 0x3e, 0x4e, 0x54, 0x47, 0x71, 0x69, 0xfc, 0x6d,
	0x04, 0x12, 0xcd, 0xf9, 0xc6, 0xf0, 0x57, 0x10, 0xef, 0x5f, 0x99, 0x6a, 0x5b, 0x75, 0x94, 0x2c,
	0xb7, 0xcf, 0x1d, 0x24, 0x8f, 0x52, 0x25, 0xc5, 0xd4, 0x4a, 0x73, 0x50, 0xd8, 0x7e, 0x3f, 0x2b,
	0xac, 0xfd, 0x38, 0x2b, 0x70, 0xf7, 0xb3, 0xc2, 0xe6, 0x33, 0x4d, 0x1f, 0x6b, 0xba, 0x2a, 0xfb,
	0x6b, 0xf0, 0x29, 0x40, 0xf7, 0xfc, 0x77, 0xea, 0xd0, 0xa1, 0x0a, 0x11, 0xaa, 0x90, 0xa1, 0x0a,
	0x01, 0x2c, 0xe4, 0x19, 0x8d, 0x34, 0x71, 0xe5, 0x99, 0x31, 0xd1, 0x1c, 0x75, 0x62, 0x3a, 0x57,
	0x32, 0xb3, 0x1c, 0xd7, 0x20, 0xda, 0x33, 0xd5, 0x61, 0x76, 0x9d, 0xca, 0x7c, 0x50, 0x9a, 0x87,
	0xbb, 0xe4, 0xfb, 0x4b, 0xa6, 0x85, 0x27, 0x44, 0x8e, 0x48, 0xd9, 0xa6, 0x3a, 0x64, 0xa4, 0xe8,
	0x62, 0x7c, 0x0a, 0xb1, 0x9e, 0xa3, 0x38, 0x53, 0x3b, 0x1b, 0xa5, 0x32, 0xb9, 0x55, 0x32, 0x94,
	0x20, 0x64, 0x3d, 0x21, 0x64, 0xd3, 0x31, 0x23, 0xe5, 0x49, 0xf0, 0xff, 0xe2, 0x20, 0x21, 0x29,
	0x53, 0x9b, 0x1a, 0xc6, 0x5f, 0x42, 0x94, 0x6c, 0x9c, 0x06, 0x2a, 0x21, 0x1c, 0xdc, 0x5e, 0xe7,
	0x70, 0xcf, 0xb1, 0x44, 0x7d, 0x3a, 0x39, 0xa0, 0x24, 0x32, 0xf9, 0x94, 0x38, 0xe6, 0x5c, 0x99,
	0x2a, 0xeb, 0x18, 0x99, 0xc0, 0xdf, 0x40, 0xba, 0xff, 0x3d, 0xe5, 0x89, 0xba, 0x72, 0x3e, 0x56,
	0x47, 0x34, 0x5c, 0x71, 0x81, 0x7f, 0xef, 0x46, 0x26, 0xef, 0x7c, 0x5f, 0x34, 0xc9, 0x74, 0x51,
	0x75, 0xe7, 0x19, 0x85, 0x85, 0x95, 0x44, 0x4b, 0x0e, 0x6b, 0xad, 0x87, 0xb5, 0xac, 0x9f, 0xd0,
	0x0a, 0xaf, 0xe4, 0xff, 0x1c, 0x85, 0x54, 0x28, 0xc0, 0xf8, 0x24, 0xb4, 0xcf, 0xe3, 0xdb, 0xeb,
	0xdc, 0x47, 0xf3, 0x7d, 0x86, 0x88, 0xa5, 0x66, 0xe3, 0xa7, 0xb7, 0xfc, 0x2d, 0x24, 0xab, 0xa3,
	0x89, 0xa6, 0x7b, 0x07, 0x12, 0xa1, 0x7a, 0xe5, 0xdb, 0xeb, 0xdc, 0x23, 0x5f, 0xaf, 0xe1, 0xce,
	0x11, 0x8d, 0x27, 0x0a, 0xe1, 0x16, 0x97, 0x0e, 0x83, 0xd5, 0xc0, 0x87, 0xb0, 0xf9, 0xca, 0xba,
	0xe8, 0x28, 0x13, 0x95, 0x6e, 0x39, 0x21, 0x3c, 0xb9, 0x9f, 0x15, 0xf0, 0x3b, 0xeb, 0xa2, 0xa8,
	0x2b, 0x93, 0xb9, 0x07, 0x8e, 0x79, 0x25, 0xcf, 0x69, 0xf8, 0x29, 0x6c, 0xf4, 0x4c, 0x55, 0x1d,
	0xd1, 0xfb, 0x90, 0x10, 0xb6, 0xef, 0x67, 0x85, 0x8c, 0x4d, 0x00, 0xc6, 0x84, 0xcb, 0xc0, 0xbf,
	0x80, 0xf5, 0x76, 0xff, 0x2c, 0xbb, 0xb1, 0xcf, 0x1d, 0xa4, 0x84, 0x1d, 0x2f, 0x96, 0xa9, 0x89,
	0x33, 0x65, 0xa8, 0x84, 0x81, 0x05, 0xd8, 0xa0, 0x31, 0xcc, 0xc6, 0xe8, 0x1d, 0xdb, 0x0e, 0xee,
	0x98, 0x7f, 0x5b, 0x84, 0x0f, 0xbc, 0xf5, 0x19, 0x7a, 0x10, 0xac, 0x31, 0xca, 0xe1, 0xff, 0xc2,
	0x41, 0xcc, 0x0d, 0x20, 0x8e, 0x43, 0xb4, 0xd3, 0xed, 0x88, 0x68, 0x0d, 0x67, 0x61, 0xf3, 0x65,
	0xb7, 0xd7, 0x1f, 0x48, 0x0d, 0xc4, 0xe5, 0x93, 0x77, 0x37, 0xb9, 0xcd, 0x37, 0x86, 0xed, 0x14,
	0xcd, 0x0b, 0xbc, 0x07, 0x70, 0x26, 0xb5, 0x9a, 0x9d, 0xd3, 0x81, 0xd8, 0x7f, 0x89, 0xd6, 0xf3,
	0xe9, 0xbb, 0x9b, 0x1c, 0x4c, 0xcd, 0xb1, 0xa6, 0xbf, 0x2d, 0xaa, 0xce, 0x1b, 0xbc, 0x0f, 0x49,
	0x6f, 0xbe, 0x7d, 0xd2, 0xee, 0xa3, 0x68, 0x3e, 0x73, 0x77, 0x93, 0x4b, 0x7a, 0x84, 0xc9, 0xe5,
	0xc4, 0xc1, 0x69, 0x88, 0xb4, 0x8e, 0xd1, 0x46, 0x3e, 0x76, 0x77, 0x93, 0x8b, 0x8c, 0x8f, 0x71,
	0x1e, 0xe2, 0xad, 0x6e, 0x57, 0x12, 0xaa, 0xb5, 0x53, 0x14, 0xcb, 0x6f, 0xdd, 0xdd, 0xe4, 0xe2,
	0x63, 0xc3, 0x30, 0xcf, 0x95, 0xe1, 0x5b, 0x5e, 0x82, 0x6d, 0xff, 0xa8, 0x5f, 0x1a, 0xb6, 0xe3,
	0x45, 0xff, 0x0b, 0x00, 0x32, 0x6a, 0xba, 0x07, 0xe0, 0xde, 0x8f, 0xdc, 0xfd, 0xac, 0xb0, 0x43,
	0xbd, 0xd4, 0x2e, 0x98, 0x33, 0xa0, 0xc9, 0x1d, 0x90, 0xf9, 0xff, 0x70, 0xb0, 0xe3, 0x4b, 0x9e,
	0x51, 0xb7, 0x3c, 0xd1, 0xcf, 0x20, 0xd1, 0x22, 0x23, 0x7a, 0x48, 0xae, 0x66, 0xf6, 0x7e, 0x56,
	0x78, 0x4c, 0x3d, 0x5f, 0x3c, 0xa9, 0x80, 0x8a, 0xdf, 0xc2, 0xa3, 0xbe, 0xa5, 0xe8, 0xf6, 0x50,
	0xd5, 0xde, 0xa9, 0x16, 0x73, 0xc7, 0x92, 0x47, 0x1f, 0x06, 0x07, 0xb2, 0x44, 0x11, 0xf6, 0xef,
	0x67, 0x85, 0x5d, 0x27, 0x80, 0x97, 0x6f, 0xdc, 0xb2, 0x2e, 0xae, 0x40, 0x4c, 0x32, 0x2c, 0xa7,
	0x59, 0xa7, 0xd7, 0x2e, 0x25, 0xec, 0xde, 0xcf, 0x0a, 0x59, 0x2f, 0xba, 0xa6, 0x61, 0x39, 0x45,
	0x8d, 0xf5, 0xd2, 0xe3, 0xf2, 0x7f, 0x8b, 0xaf, 0xf0, 0x11, 0x0f, 0x01, 0x2d, 0x80, 0xf3, 0x58,
	0x7e, 0x7e, 0x7b, 0x9d, 0xdb, 0x9f, 0xe7, 0xc6, 0xd2, 0xc2, 0x12, 0xa5, 0x3e, 0xa5, 0x17, 0x98,
	0x7c, 0x31, 0x06, 0x97, 0x04, 0xb1, 0x05, 0xdb, 0x04, 0x73, 0xa1, 0x1a, 0x49, 0x75, 0x9a, 0xd3,
	0x6e, 0x0e, 0x7e, 0x7d, 0x7b, 0x9d, 0xfb, 0xf9, 0xc3, 0x76, 0x7c, 0x3a, 0xb1, 0xf5, 0x78, 0x48,
	0x46, 0xc5, 0x85, 0x04, 0x5f, 0x25, 0x8e, 0xbf, 0x83, 0x54, 0x00, 0x4b, 0xda, 0xc8, 0x4b, 0x51,
	0xf2, 0x07, 0xd9, 0x7b, 0xd8, 0x9a, 0xa4, 0x8d, 0x88, 0x9d, 0x94, 0x19, 0x0a, 0x61, 0x58, 0x89,
	0xff, 0x23, 0x6c, 0xb8, 0xfb, 0xda, 0x82, 0x78, 0xaf, 0x5f, 0xed, 0x8b, 0x83, 0x4e, 0x15, 0xad,
	0xe1, 0x47, 0x90, 0x72, 0x47, 0xb2, 0xd8, 0xee, 0xbe, 0x12, 0xeb, 0x88, 0xc3, 0x18, 0xd2, 0x2e,
	0xd4, 0xec, 0xf4, 0x44, 0xb9, 0x2f, 0xd6, 0x51, 0x24, 0xa0, 0x49, 0x62, 0xa7, 0xde, 0xec, 0x9c,
	0xa0, 0x75, 0xfc, 0x18, 0x90, 0x0b, 0xf5, 0x24, 0xb9, 0xdb, 0x1e, 0xc8, 0x62, 0xb5, 0x8e, 0xa2,
	0x38, 0x0b, 0x8f, 0x17, 0xd1, 0x81, 0x28, 0xcb, 0x68, 0x83, 0x7f, 0x06, 0x89, 0x60, 0xa3, 0x41,
	0xc2, 0x02, 0xc4, 0x6a, 0x5d, 0x49, 0x12, 0x65, 0xc4, 0xe1, 0x04, 0x6c, 0x34, 0x9a, 0x82, 0x28,
	0xa3, 0x08, 0xff, 0x8f, 0x28, 0xac, 0x4b, 0xda, 0x08, 0x27, 0x61, 0xf3, 0xac, 0x73, 0xda, 0xe9,
	0xbe, 0xee, 0xb8, 0xce, 0x7e, 0xdb, 0x6b, 0x48, 0x83, 0xe7, 0x87, 0x87, 0x27, 0x83, 0x9a, 0x5c,
	0x41, 0x1c, 0xf1, 0x82, 0x42, 0x95, 0xc3, 0x13, 0xa1, 0xda, 0x13, 0x29, 0x1a, 0xa1, 0xbe, 0x35,
	0xa4, 0xc1, 0xd1, 0xa7, 0x73, 0x70, 0xd0, 0xf3, 0x3c, 0x0e, 0xa3, 0x2d, 0x14, 0x5d, 0x81, 0x76,
	0xd0, 0x46, 0xd8, 0x54, 0xb5, 0x5b, 0x43, 0x47, 0x0b, 0x50, 0xad, 0x86, 0x8e, 0xc3, 0x50, 0x4f,
	0xae, 0xa0, 0x4a, 0x18, 0x6a, 0xc9, 0x15, 0xf4, 0x69, 0x18, 0x12, 0xe5, 0x0a, 0xfa, 0x6c, 0xc9,
	0x6d, 0x82, 0x7e, 0xbe, 0x84, 0x12, 0xc5, 0x5f, 0x2e, 0xa1, 0x44, 0xf4, 0x8b, 0x25, 0x94, 0xf8,
	0xf8, 0x2b, 0x7a, 0x76, 0xcc, 0x66, 0x7a, 0x32, 0xfa, 0xf5, 0x22, 0xd6, 0x92, 0xd1, 0x97, 0x8b,
	0x98, 0x28, 0xa3, 0x17, 0x78, 0x1b, 0x32, 0x2c, 0x46, 0x04, 0xbf, 0x9a, 0x13, 0x9f, 0xfb, 0x1e,
	0xa1, 0xdf, 0x2c, 0x62, 0x2d, 0x19, 0x7d, 0x3d, 0x5f, 0x1c, 0x60, 0x6d, 0x54, 0x5d, 0x24, 0x8a,
	0x32, 0x12, 0x16, 0x89, 0xc4, 0x4a, 0x6d, 0x91, 0x58, 0x3b, 0x43, 0x75, 0x42, 0x64, 0x0e, 0xfb,
	0x75, 0xbd, 0x5d, 0x41, 0x22, 0x21, 0x06, 0xa0, 0xd4, 0x6b, 0x57, 0x50, 0x03, 0x27, 0x21, 0x26,
	0x35, 0xeb, 0xe4, 0x3a, 0xff, 0x7b, 0x93, 0x7f, 0x1f, 0x85, 0xcc, 0x42, 0x9b, 0x82, 0x3f, 0x86,
	0x28, 0xf3, 0xbb, 0x7d, 0x44, 0x52, 0x65, 0x64, 0x87, 0x1a, 0x1f, 0x5a, 0xe7, 0x8e, 0x20, 0xe9,
	0xaf, 0x6c, 0xd6, 0x69, 0xa2, 0x47, 0x05, 0x74, 0x3f, 0x2b, 0x6c, 0x85, 0xf2, 0x8a, 0x25, 0xe1,
	0x9f, 0xc1, 0x7a, 0xbd, 0x57, 0xf3, 0xd2, 0x74, 0x85, 0x32, 0x99, 0xc5, 0x1d, 0x80, 0xae, 0xe9,
	0xff, 0x60, 0xdd, 0x2a, 0x5a, 0x7a, 0xa8, 0x88, 0xef, 0x18, 0xe6, 0xaa, 0x3f, 0x2a, 0xa3, 0x80,
	0xbb, 0x00, 0x92, 0xa5, 0x4d, 0x14, 0xeb, 0xaa, 0xad, 0x0c, 0x69, 0xb1, 0x75, 0x9b, 0x02, 0x2c,
	0x12, 0x6a, 0xd7, 0x3a, 0x68, 0x2b, 0xc3, 0xea, 0x68, 0x64, 0x1d, 0x3c, 0xa5, 0x82, 0xa6, 0xcb,
	0x2d, 0x4e, 0x14, 0xd6, 0x33, 0x46, 0x02, 0x0f, 0x61, 0xab, 0xd9, 0x08, 0xaa, 0x94, 0x57, 0x94,
	0x3f, 0x5a, 0xd1, 0xf8, 0x05, 0x24, 0x61, 0xdf, 0x6b, 0xfe, 0xb2, 0xda, 0x45, 0x91, 0x56, 0xaf,
	0x25, 0x9f, 0x43, 0xa2, 0xf8, 0x2d, 0xa4, 0x9b, 0x0d, 0xb6, 0x6e, 0x65, 0x37, 0xa9, 0x99, 0xc2,
	0x0a, 0x33, 0x2c, 0x8d, 0xf6, 0x64, 0xc4, 0x50, 0x5e, 0xbb, 0x28, 0x7a, 0x05, 0x63, 0xc9, 0xd4,
	0x82, 0x34, 0x16, 0x20, 0xd5, 0xd6, 0x2c, 0xcb, 0xb0, 0xe6, 0xed, 0x5d, 0x9c, 0xb6, 0x77, 0xb4,
	0xe8, 0x4c, 0xe8, 0xc4, 0x8a, 0xc6, 0x2e, 0xbc, 0x84, 0xaf, 0x33, 0x6d, 0x5d, 0x4b, 0xb3, 0x1d,
	0x7c, 0x0c, 0xe0, 0xbf, 0x68, 0xec, 0x2c, 0xb7, 0xbf, 0x1e, 0xee, 0x5c, 0x7c, 0xb2, 0xcc, 0xd0,
	0xf8, 0xbf, 0x72, 0x90, 0xf6, 0x67, 0xc4, 0x77, 0xaa, 0xee, 0xe0, 0x06, 0x24, 0xe8, 0x87, 0xdf,
	0x23, 0xa6, 0x8f, 0xd2, 0xb4, 0xe5, 0xf7, 0x51, 0xb7, 0x7e, 0xab, 0x64, 0xb8, 0x58, 0x37, 0x82,
	0xa5, 0xb8, 0xc3, 0x3c, 0x44, 0xbc, 0xba, 0xbd, 0xca, 0x1d, 0xe1, 0x43, 0x2f, 0x80, 0xdb, 0xbe,
	0x5b, 0xac, 0x9e, 0xcf, 0xe3, 0x7f, 0x0b, 0x38, 0xec, 0x29, 0xdd, 0xb5, 0xc0, 0x24, 0x14, 0x45,
	0xe7, 0x5b, 0xcf, 0xae, 0xb0, 0x45, 0x09, 0xf2, 0xe2, 0x82, 0x4f, 0x0e, 0xbd, 0x57, 0x00, 0x75,
	0x3b, 0x09, 0x9b, 0xf5, 0x66, 0xaf, 0x2a, 0xb4, 0xc8, 0xef, 0x3f, 0x0e, 0x51, 0xd2, 0x73, 0x21,
	0x8e, 0xd4, 0x25, 0x49, 0x6e, 0x76, 0xe5, 0x66, 0xff, 0x3b, 0x14, 0xf9, 0x64, 0x17, 0xe2, 0xf3,
	0xac, 0xc0, 0x31, 0x88, 0x9c, 0x49, 0x2e, 0xb7, 0x4e, 0x0a, 0x01, 0x77, 0xf4, 0xdf, 0x08, 0x13,
	0xd4, 0xaa, 0xa9, 0xbd, 0x7a, 0x8e, 0x05, 0x48, 0x13, 0x77, 0x7d, 0xd4, 0xc6, 0x3b, 0x34, 0xa6,
	0x04, 0x7c, 0xad, 0x38, 0xc3, 0x37, 0x5d, 0x93, 0x3e, 0x12, 0xf3, 0xab, 0x9e, 0x45, 0x84, 0xc4,
	0xaf, 0xe1, 0x6f, 0x20, 0x43, 0xa9, 0xff, 0x5f, 0x64, 0xf7, 0xa1, 0xbd, 0xbb, 0x4a, 0x87, 0x1c,
	0x16, 0x98, 0x06, 0x90, 0xe4, 0xee, 0x99, 0x39, 0x22, 0xd5, 0xf7, 0xc1, 0xa0, 0xe5, 0xc3, 0xef,
	0x46, 0x7e, 0xed, 0x80, 0xc3, 0x2f, 0x20, 0x53, 0xb3, 0x54, 0xc5, 0x51, 0x83, 0xf7, 0xe6, 0xaa,
	0x03, 0xce, 0xaf, 0x02, 0xf9, 0xb5, 0x7c, 0xff, 0xef, 0x7f, 0xca, 0x49, 0xec, 0x63, 0x35, 0x3a,
	0xd6, 0x6c, 0x27, 0xff, 0xa2, 0xfc, 0x87, 0xe0, 0xcd, 0x58, 0xea, 0xab, 0xba, 0xa2, 0x3b, 0x3f,
	0x84, 0x30, 0xf2, 0x3b, 0xb4, 0x4d, 0x65, 0xa8, 0x2e, 0xc3, 0x3f, 0x08, 0x5b, 0xef, 0xef, 0xf6,
	0xb8, 0x1f, 0xef, 0xf6, 0xb8, 0x7f, 0xde, 0xed, 0x71, 0x12, 0x77, 0x1e, 0xa3, 0x86, 0x8f, 0xff,
	0x17, 0x00, 0x00, 0xff, 0xff, 0xd1, 0xf8, 0x05, 0x0c, 0xee, 0x0f, 0x00, 0x00,
}
