// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: flowexport.proto

package netproto

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "google.golang.org/genproto/googleapis/api/annotations"
import _ "github.com/pensando/sw/venice/utils/apigen/annotations"
import _ "github.com/gogo/protobuf/gogoproto"
import api "github.com/pensando/sw/api"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// FlowExportPolicy flow export Policy object
type FlowExportPolicy struct {
	api.TypeMeta   `protobuf:"bytes,1,opt,name=TypeMeta,embedded=TypeMeta" json:",inline"`
	api.ObjectMeta `protobuf:"bytes,2,opt,name=ObjectMeta,embedded=ObjectMeta" json:"meta,omitempty"`
	Spec           FlowExportPolicySpec   `protobuf:"bytes,3,opt,name=Spec" json:"spec,omitempty"`
	Status         FlowExportPolicyStatus `protobuf:"bytes,4,opt,name=Status" json:"status,omitempty"`
}

func (m *FlowExportPolicy) Reset()                    { *m = FlowExportPolicy{} }
func (m *FlowExportPolicy) String() string            { return proto.CompactTextString(m) }
func (*FlowExportPolicy) ProtoMessage()               {}
func (*FlowExportPolicy) Descriptor() ([]byte, []int) { return fileDescriptorFlowexport, []int{0} }

func (m *FlowExportPolicy) GetSpec() FlowExportPolicySpec {
	if m != nil {
		return m.Spec
	}
	return FlowExportPolicySpec{}
}

func (m *FlowExportPolicy) GetStatus() FlowExportPolicyStatus {
	if m != nil {
		return m.Status
	}
	return FlowExportPolicyStatus{}
}

type FlowExportPolicySpec struct {
	//  VrfName specifies the name of the VRF that the current Flow Export Policy belongs to
	VrfName string `protobuf:"bytes,1,opt,name=VrfName,proto3" json:"vrf-name,omitempty"`
	// Interval defines how often to push the records to an external or internal collector
	// The value is specified as a string format to be '10s', '20m', '20mins', '10secs', '10seconds'
	Interval string `protobuf:"bytes,2,opt,name=Interval,proto3" json:"interval,omitempty"`
	// TemplateInterval defines how often to send ipfix templates to an external collector
	// The value is specified as a string format, '3m', '10m'
	TemplateInterval string      `protobuf:"bytes,3,opt,name=TemplateInterval,proto3" json:"template-interval,omitempty"`
	Format           string      `protobuf:"bytes,4,opt,name=Format,proto3" json:"format,omitempty"`
	MatchRules       []MatchRule `protobuf:"bytes,5,rep,name=MatchRules" json:"match-rules,omitempty"`
	// Export contains export parameters.
	Exports []ExportConfig `protobuf:"bytes,6,rep,name=Exports" json:"exports,omitempty"`
}

func (m *FlowExportPolicySpec) Reset()                    { *m = FlowExportPolicySpec{} }
func (m *FlowExportPolicySpec) String() string            { return proto.CompactTextString(m) }
func (*FlowExportPolicySpec) ProtoMessage()               {}
func (*FlowExportPolicySpec) Descriptor() ([]byte, []int) { return fileDescriptorFlowexport, []int{1} }

func (m *FlowExportPolicySpec) GetVrfName() string {
	if m != nil {
		return m.VrfName
	}
	return ""
}

func (m *FlowExportPolicySpec) GetInterval() string {
	if m != nil {
		return m.Interval
	}
	return ""
}

func (m *FlowExportPolicySpec) GetTemplateInterval() string {
	if m != nil {
		return m.TemplateInterval
	}
	return ""
}

func (m *FlowExportPolicySpec) GetFormat() string {
	if m != nil {
		return m.Format
	}
	return ""
}

func (m *FlowExportPolicySpec) GetMatchRules() []MatchRule {
	if m != nil {
		return m.MatchRules
	}
	return nil
}

func (m *FlowExportPolicySpec) GetExports() []ExportConfig {
	if m != nil {
		return m.Exports
	}
	return nil
}

type ExportConfig struct {
	// IP address or URL of the collector/entity to which the data is to be exported
	Destination string `protobuf:"bytes,1,opt,name=Destination,proto3" json:"destination,omitempty"`
	// protocol and Port number where an external collector is gathering the data
	// example "TCP/2055"
	Transport *ProtoPort `protobuf:"bytes,2,opt,name=Transport" json:"proto-port,omitempty"`
}

func (m *ExportConfig) Reset()                    { *m = ExportConfig{} }
func (m *ExportConfig) String() string            { return proto.CompactTextString(m) }
func (*ExportConfig) ProtoMessage()               {}
func (*ExportConfig) Descriptor() ([]byte, []int) { return fileDescriptorFlowexport, []int{2} }

func (m *ExportConfig) GetDestination() string {
	if m != nil {
		return m.Destination
	}
	return ""
}

func (m *ExportConfig) GetTransport() *ProtoPort {
	if m != nil {
		return m.Transport
	}
	return nil
}

type FlowExportPolicyStatus struct {
	FlowExportPolicyID uint64 `protobuf:"varint,1,opt,name=FlowExportPolicyID,proto3" json:"id,omitempty"`
}

func (m *FlowExportPolicyStatus) Reset()                    { *m = FlowExportPolicyStatus{} }
func (m *FlowExportPolicyStatus) String() string            { return proto.CompactTextString(m) }
func (*FlowExportPolicyStatus) ProtoMessage()               {}
func (*FlowExportPolicyStatus) Descriptor() ([]byte, []int) { return fileDescriptorFlowexport, []int{3} }

func (m *FlowExportPolicyStatus) GetFlowExportPolicyID() uint64 {
	if m != nil {
		return m.FlowExportPolicyID
	}
	return 0
}

type FlowExportPolicyEvent struct {
	// event type create/update/delete
	EventType api.EventType `protobuf:"varint,1,opt,name=EventType,proto3,enum=api.EventType" json:"event-type,omitempty"`
	// flow export policy
	Policy *FlowExportPolicy `protobuf:"bytes,2,opt,name=Policy" json:"policy,omitempty"`
}

func (m *FlowExportPolicyEvent) Reset()                    { *m = FlowExportPolicyEvent{} }
func (m *FlowExportPolicyEvent) String() string            { return proto.CompactTextString(m) }
func (*FlowExportPolicyEvent) ProtoMessage()               {}
func (*FlowExportPolicyEvent) Descriptor() ([]byte, []int) { return fileDescriptorFlowexport, []int{4} }

func (m *FlowExportPolicyEvent) GetEventType() api.EventType {
	if m != nil {
		return m.EventType
	}
	return api.EventType_CreateEvent
}

func (m *FlowExportPolicyEvent) GetPolicy() *FlowExportPolicy {
	if m != nil {
		return m.Policy
	}
	return nil
}

type FlowExportPolicyEventList struct {
	FlowExportPolicyEvents []*FlowExportPolicyEvent `protobuf:"bytes,1,rep,name=FlowExportPolicyEvents" json:"event-list,omitempty"`
}

func (m *FlowExportPolicyEventList) Reset()         { *m = FlowExportPolicyEventList{} }
func (m *FlowExportPolicyEventList) String() string { return proto.CompactTextString(m) }
func (*FlowExportPolicyEventList) ProtoMessage()    {}
func (*FlowExportPolicyEventList) Descriptor() ([]byte, []int) {
	return fileDescriptorFlowexport, []int{5}
}

func (m *FlowExportPolicyEventList) GetFlowExportPolicyEvents() []*FlowExportPolicyEvent {
	if m != nil {
		return m.FlowExportPolicyEvents
	}
	return nil
}

func init() {
	proto.RegisterType((*FlowExportPolicy)(nil), "netproto.FlowExportPolicy")
	proto.RegisterType((*FlowExportPolicySpec)(nil), "netproto.FlowExportPolicySpec")
	proto.RegisterType((*ExportConfig)(nil), "netproto.ExportConfig")
	proto.RegisterType((*FlowExportPolicyStatus)(nil), "netproto.FlowExportPolicyStatus")
	proto.RegisterType((*FlowExportPolicyEvent)(nil), "netproto.FlowExportPolicyEvent")
	proto.RegisterType((*FlowExportPolicyEventList)(nil), "netproto.FlowExportPolicyEventList")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for FlowExportPolicyApiV1 service

type FlowExportPolicyApiV1Client interface {
	// TODO uncomment Oper update when TPM uses nimbus
	WatchFlowExportPolicy(ctx context.Context, in *api.ObjectMeta, opts ...grpc.CallOption) (FlowExportPolicyApiV1_WatchFlowExportPolicyClient, error)
	ListFlowExportPolicy(ctx context.Context, in *api.ObjectMeta, opts ...grpc.CallOption) (*FlowExportPolicyEventList, error)
}

type flowExportPolicyApiV1Client struct {
	cc *grpc.ClientConn
}

func NewFlowExportPolicyApiV1Client(cc *grpc.ClientConn) FlowExportPolicyApiV1Client {
	return &flowExportPolicyApiV1Client{cc}
}

func (c *flowExportPolicyApiV1Client) WatchFlowExportPolicy(ctx context.Context, in *api.ObjectMeta, opts ...grpc.CallOption) (FlowExportPolicyApiV1_WatchFlowExportPolicyClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_FlowExportPolicyApiV1_serviceDesc.Streams[0], c.cc, "/netproto.FlowExportPolicyApiV1/WatchFlowExportPolicy", opts...)
	if err != nil {
		return nil, err
	}
	x := &flowExportPolicyApiV1WatchFlowExportPolicyClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type FlowExportPolicyApiV1_WatchFlowExportPolicyClient interface {
	Recv() (*FlowExportPolicyEventList, error)
	grpc.ClientStream
}

type flowExportPolicyApiV1WatchFlowExportPolicyClient struct {
	grpc.ClientStream
}

func (x *flowExportPolicyApiV1WatchFlowExportPolicyClient) Recv() (*FlowExportPolicyEventList, error) {
	m := new(FlowExportPolicyEventList)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *flowExportPolicyApiV1Client) ListFlowExportPolicy(ctx context.Context, in *api.ObjectMeta, opts ...grpc.CallOption) (*FlowExportPolicyEventList, error) {
	out := new(FlowExportPolicyEventList)
	err := grpc.Invoke(ctx, "/netproto.FlowExportPolicyApiV1/ListFlowExportPolicy", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for FlowExportPolicyApiV1 service

type FlowExportPolicyApiV1Server interface {
	// TODO uncomment Oper update when TPM uses nimbus
	WatchFlowExportPolicy(*api.ObjectMeta, FlowExportPolicyApiV1_WatchFlowExportPolicyServer) error
	ListFlowExportPolicy(context.Context, *api.ObjectMeta) (*FlowExportPolicyEventList, error)
}

func RegisterFlowExportPolicyApiV1Server(s *grpc.Server, srv FlowExportPolicyApiV1Server) {
	s.RegisterService(&_FlowExportPolicyApiV1_serviceDesc, srv)
}

func _FlowExportPolicyApiV1_WatchFlowExportPolicy_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(api.ObjectMeta)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(FlowExportPolicyApiV1Server).WatchFlowExportPolicy(m, &flowExportPolicyApiV1WatchFlowExportPolicyServer{stream})
}

type FlowExportPolicyApiV1_WatchFlowExportPolicyServer interface {
	Send(*FlowExportPolicyEventList) error
	grpc.ServerStream
}

type flowExportPolicyApiV1WatchFlowExportPolicyServer struct {
	grpc.ServerStream
}

func (x *flowExportPolicyApiV1WatchFlowExportPolicyServer) Send(m *FlowExportPolicyEventList) error {
	return x.ServerStream.SendMsg(m)
}

func _FlowExportPolicyApiV1_ListFlowExportPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(api.ObjectMeta)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FlowExportPolicyApiV1Server).ListFlowExportPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/netproto.FlowExportPolicyApiV1/ListFlowExportPolicy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FlowExportPolicyApiV1Server).ListFlowExportPolicy(ctx, req.(*api.ObjectMeta))
	}
	return interceptor(ctx, in, info, handler)
}

var _FlowExportPolicyApiV1_serviceDesc = grpc.ServiceDesc{
	ServiceName: "netproto.FlowExportPolicyApiV1",
	HandlerType: (*FlowExportPolicyApiV1Server)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListFlowExportPolicy",
			Handler:    _FlowExportPolicyApiV1_ListFlowExportPolicy_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "WatchFlowExportPolicy",
			Handler:       _FlowExportPolicyApiV1_WatchFlowExportPolicy_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "flowexport.proto",
}

func (m *FlowExportPolicy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlowExportPolicy) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintFlowexport(dAtA, i, uint64(m.TypeMeta.Size()))
	n1, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n1
	dAtA[i] = 0x12
	i++
	i = encodeVarintFlowexport(dAtA, i, uint64(m.ObjectMeta.Size()))
	n2, err := m.ObjectMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n2
	dAtA[i] = 0x1a
	i++
	i = encodeVarintFlowexport(dAtA, i, uint64(m.Spec.Size()))
	n3, err := m.Spec.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n3
	dAtA[i] = 0x22
	i++
	i = encodeVarintFlowexport(dAtA, i, uint64(m.Status.Size()))
	n4, err := m.Status.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n4
	return i, nil
}

func (m *FlowExportPolicySpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlowExportPolicySpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.VrfName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintFlowexport(dAtA, i, uint64(len(m.VrfName)))
		i += copy(dAtA[i:], m.VrfName)
	}
	if len(m.Interval) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintFlowexport(dAtA, i, uint64(len(m.Interval)))
		i += copy(dAtA[i:], m.Interval)
	}
	if len(m.TemplateInterval) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintFlowexport(dAtA, i, uint64(len(m.TemplateInterval)))
		i += copy(dAtA[i:], m.TemplateInterval)
	}
	if len(m.Format) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintFlowexport(dAtA, i, uint64(len(m.Format)))
		i += copy(dAtA[i:], m.Format)
	}
	if len(m.MatchRules) > 0 {
		for _, msg := range m.MatchRules {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintFlowexport(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Exports) > 0 {
		for _, msg := range m.Exports {
			dAtA[i] = 0x32
			i++
			i = encodeVarintFlowexport(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ExportConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExportConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Destination) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintFlowexport(dAtA, i, uint64(len(m.Destination)))
		i += copy(dAtA[i:], m.Destination)
	}
	if m.Transport != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintFlowexport(dAtA, i, uint64(m.Transport.Size()))
		n5, err := m.Transport.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	return i, nil
}

func (m *FlowExportPolicyStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlowExportPolicyStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.FlowExportPolicyID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFlowexport(dAtA, i, uint64(m.FlowExportPolicyID))
	}
	return i, nil
}

func (m *FlowExportPolicyEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlowExportPolicyEvent) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.EventType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFlowexport(dAtA, i, uint64(m.EventType))
	}
	if m.Policy != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintFlowexport(dAtA, i, uint64(m.Policy.Size()))
		n6, err := m.Policy.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}

func (m *FlowExportPolicyEventList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlowExportPolicyEventList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.FlowExportPolicyEvents) > 0 {
		for _, msg := range m.FlowExportPolicyEvents {
			dAtA[i] = 0xa
			i++
			i = encodeVarintFlowexport(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func encodeVarintFlowexport(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *FlowExportPolicy) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovFlowexport(uint64(l))
	l = m.ObjectMeta.Size()
	n += 1 + l + sovFlowexport(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovFlowexport(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovFlowexport(uint64(l))
	return n
}

func (m *FlowExportPolicySpec) Size() (n int) {
	var l int
	_ = l
	l = len(m.VrfName)
	if l > 0 {
		n += 1 + l + sovFlowexport(uint64(l))
	}
	l = len(m.Interval)
	if l > 0 {
		n += 1 + l + sovFlowexport(uint64(l))
	}
	l = len(m.TemplateInterval)
	if l > 0 {
		n += 1 + l + sovFlowexport(uint64(l))
	}
	l = len(m.Format)
	if l > 0 {
		n += 1 + l + sovFlowexport(uint64(l))
	}
	if len(m.MatchRules) > 0 {
		for _, e := range m.MatchRules {
			l = e.Size()
			n += 1 + l + sovFlowexport(uint64(l))
		}
	}
	if len(m.Exports) > 0 {
		for _, e := range m.Exports {
			l = e.Size()
			n += 1 + l + sovFlowexport(uint64(l))
		}
	}
	return n
}

func (m *ExportConfig) Size() (n int) {
	var l int
	_ = l
	l = len(m.Destination)
	if l > 0 {
		n += 1 + l + sovFlowexport(uint64(l))
	}
	if m.Transport != nil {
		l = m.Transport.Size()
		n += 1 + l + sovFlowexport(uint64(l))
	}
	return n
}

func (m *FlowExportPolicyStatus) Size() (n int) {
	var l int
	_ = l
	if m.FlowExportPolicyID != 0 {
		n += 1 + sovFlowexport(uint64(m.FlowExportPolicyID))
	}
	return n
}

func (m *FlowExportPolicyEvent) Size() (n int) {
	var l int
	_ = l
	if m.EventType != 0 {
		n += 1 + sovFlowexport(uint64(m.EventType))
	}
	if m.Policy != nil {
		l = m.Policy.Size()
		n += 1 + l + sovFlowexport(uint64(l))
	}
	return n
}

func (m *FlowExportPolicyEventList) Size() (n int) {
	var l int
	_ = l
	if len(m.FlowExportPolicyEvents) > 0 {
		for _, e := range m.FlowExportPolicyEvents {
			l = e.Size()
			n += 1 + l + sovFlowexport(uint64(l))
		}
	}
	return n
}

func sovFlowexport(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozFlowexport(x uint64) (n int) {
	return sovFlowexport(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *FlowExportPolicy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlowexport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlowExportPolicy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlowExportPolicy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowexport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlowexport
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowexport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlowexport
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowexport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlowexport
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowexport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlowexport
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlowexport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFlowexport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlowExportPolicySpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlowexport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlowExportPolicySpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlowExportPolicySpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VrfName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowexport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlowexport
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VrfName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Interval", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowexport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlowexport
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Interval = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TemplateInterval", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowexport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlowexport
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TemplateInterval = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Format", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowexport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlowexport
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Format = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchRules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowexport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlowexport
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MatchRules = append(m.MatchRules, MatchRule{})
			if err := m.MatchRules[len(m.MatchRules)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exports", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowexport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlowexport
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Exports = append(m.Exports, ExportConfig{})
			if err := m.Exports[len(m.Exports)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlowexport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFlowexport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExportConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlowexport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExportConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExportConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Destination", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowexport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlowexport
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Destination = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Transport", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowexport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlowexport
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Transport == nil {
				m.Transport = &ProtoPort{}
			}
			if err := m.Transport.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlowexport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFlowexport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlowExportPolicyStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlowexport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlowExportPolicyStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlowExportPolicyStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlowExportPolicyID", wireType)
			}
			m.FlowExportPolicyID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowexport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FlowExportPolicyID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFlowexport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFlowexport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlowExportPolicyEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlowexport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlowExportPolicyEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlowExportPolicyEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventType", wireType)
			}
			m.EventType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowexport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EventType |= (api.EventType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Policy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowexport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlowexport
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Policy == nil {
				m.Policy = &FlowExportPolicy{}
			}
			if err := m.Policy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlowexport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFlowexport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlowExportPolicyEventList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlowexport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlowExportPolicyEventList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlowExportPolicyEventList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlowExportPolicyEvents", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowexport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlowexport
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FlowExportPolicyEvents = append(m.FlowExportPolicyEvents, &FlowExportPolicyEvent{})
			if err := m.FlowExportPolicyEvents[len(m.FlowExportPolicyEvents)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlowexport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFlowexport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipFlowexport(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowFlowexport
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFlowexport
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFlowexport
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthFlowexport
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowFlowexport
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipFlowexport(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthFlowexport = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowFlowexport   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("flowexport.proto", fileDescriptorFlowexport) }

var fileDescriptorFlowexport = []byte{
	// 855 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x94, 0x41, 0x6f, 0x1b, 0x45,
	0x14, 0xc7, 0xbb, 0xb1, 0x71, 0x92, 0x49, 0x08, 0x66, 0xea, 0x44, 0xb6, 0x29, 0x71, 0x64, 0x84,
	0xe4, 0x8a, 0xd8, 0x9b, 0x1a, 0x0e, 0x5c, 0x40, 0xb0, 0x34, 0x15, 0x6d, 0x9a, 0x36, 0x38, 0x51,
	0x91, 0xb8, 0x4d, 0xd6, 0xcf, 0xee, 0xa0, 0xdd, 0x99, 0x61, 0x67, 0x9c, 0x10, 0xa1, 0x9e, 0x90,
	0x7a, 0xe4, 0xcc, 0x67, 0xa8, 0x84, 0x90, 0xf8, 0x02, 0x48, 0x9c, 0x72, 0xec, 0x27, 0xb0, 0x50,
	0x8e, 0xf9, 0x14, 0x68, 0xde, 0xae, 0xbd, 0x43, 0x6c, 0xc3, 0xa5, 0x97, 0xd5, 0xcc, 0x9b, 0xff,
	0xff, 0x37, 0x6f, 0xde, 0xbe, 0x19, 0x52, 0x1e, 0x44, 0xf2, 0x1c, 0x7e, 0x54, 0x32, 0x31, 0x1d,
	0x95, 0x48, 0x23, 0xe9, 0x8a, 0x00, 0x83, 0xa3, 0xfa, 0x9d, 0xa1, 0x94, 0xc3, 0x08, 0x7c, 0xa6,
	0xb8, 0xcf, 0x84, 0x90, 0x86, 0x19, 0x2e, 0x85, 0x4e, 0x75, 0xf5, 0xfd, 0x21, 0x37, 0xcf, 0x47,
	0xa7, 0x9d, 0x50, 0xc6, 0xbe, 0x02, 0xa1, 0x99, 0xe8, 0x4b, 0x5f, 0x9f, 0xfb, 0x67, 0x20, 0x78,
	0x08, 0xfe, 0xc8, 0xf0, 0x48, 0x5b, 0xeb, 0x10, 0x84, 0xeb, 0xf6, 0xb9, 0x08, 0xa3, 0x51, 0x1f,
	0x26, 0x98, 0xb6, 0x83, 0x19, 0xca, 0xa1, 0xf4, 0x31, 0x7c, 0x3a, 0x1a, 0xe0, 0x0c, 0x27, 0x38,
	0xca, 0xe4, 0x1f, 0x2e, 0xd8, 0xd5, 0xe6, 0x18, 0x83, 0x61, 0x99, 0x6c, 0x2d, 0x66, 0x26, 0x7c,
	0x9e, 0x4d, 0xd6, 0x63, 0x9e, 0x24, 0x32, 0x49, 0x67, 0xcd, 0x3f, 0x97, 0x48, 0xf9, 0x41, 0x24,
	0xcf, 0xf7, 0xf1, 0xd0, 0x47, 0x32, 0xe2, 0xe1, 0x05, 0xfd, 0x9c, 0xac, 0x9c, 0x5c, 0x28, 0x38,
	0x04, 0xc3, 0xaa, 0xde, 0x8e, 0xd7, 0x5a, 0xeb, 0xbe, 0xdd, 0x61, 0x8a, 0x77, 0x26, 0xc1, 0xe0,
	0xf6, 0xe5, 0xb8, 0x71, 0xeb, 0xf5, 0xb8, 0xe1, 0x5d, 0x8f, 0x1b, 0xcb, 0xbb, 0x5c, 0x44, 0x5c,
	0x40, 0x6f, 0xea, 0xa1, 0x07, 0x84, 0x3c, 0x3d, 0xfd, 0x1e, 0x42, 0x83, 0x84, 0x25, 0x24, 0xbc,
	0x83, 0x84, 0x3c, 0x1c, 0xd4, 0x1d, 0xc6, 0x86, 0x4d, 0x76, 0x57, 0xc6, 0xdc, 0x40, 0xac, 0xcc,
	0x45, 0xcf, 0xb1, 0xd3, 0x47, 0xa4, 0x78, 0xac, 0x20, 0xac, 0x16, 0x10, 0xb3, 0xdd, 0x99, 0xfc,
	0x90, 0xce, 0xcd, 0xb4, 0xad, 0x2a, 0xd8, 0xb2, 0x54, 0x4b, 0xd4, 0x0a, 0x42, 0x87, 0x88, 0x0c,
	0xda, 0x23, 0xa5, 0x63, 0xc3, 0xcc, 0x48, 0x57, 0x8b, 0x48, 0xdb, 0xf9, 0x0f, 0x1a, 0xea, 0x82,
	0x6a, 0xc6, 0x2b, 0x6b, 0x9c, 0x3b, 0xc4, 0x8c, 0xd4, 0xfc, 0xb5, 0x40, 0x2a, 0xf3, 0x52, 0xa1,
	0x7b, 0x64, 0xf9, 0x59, 0x32, 0x78, 0xc2, 0x62, 0xc0, 0x22, 0xae, 0x06, 0x5b, 0xd7, 0xe3, 0x06,
	0x3d, 0x4b, 0x06, 0x6d, 0xc1, 0x62, 0x70, 0x48, 0x13, 0x19, 0xed, 0x92, 0x95, 0x87, 0xc2, 0x40,
	0x72, 0xc6, 0x22, 0xac, 0x5a, 0x66, 0xe1, 0x59, 0xcc, 0xb1, 0x4c, 0x75, 0xf4, 0x80, 0x94, 0x4f,
	0x20, 0x56, 0x11, 0x33, 0x30, 0xf5, 0x16, 0xd0, 0xdb, 0xb8, 0x1e, 0x37, 0xde, 0x33, 0xd9, 0x5a,
	0x7b, 0x0e, 0x64, 0xc6, 0x48, 0x77, 0x49, 0xe9, 0x81, 0x4c, 0x62, 0x66, 0xb0, 0x3e, 0xab, 0x41,
	0xc5, 0x9e, 0x7c, 0x80, 0x11, 0xf7, 0xe4, 0xa9, 0x86, 0xf6, 0x08, 0x39, 0xb4, 0x8d, 0xd5, 0x1b,
	0x45, 0xa0, 0xab, 0x6f, 0xed, 0x14, 0x5a, 0x6b, 0xdd, 0xdb, 0x79, 0x45, 0xa7, 0x6b, 0xc1, 0xfb,
	0x59, 0x11, 0x37, 0xb1, 0x0f, 0xdb, 0x89, 0xd5, 0xbb, 0x7f, 0x3b, 0xa7, 0xd0, 0x03, 0xb2, 0x9c,
	0x16, 0x52, 0x57, 0x4b, 0x08, 0xdc, 0xca, 0x81, 0xe9, 0xc2, 0x57, 0x52, 0x0c, 0xf8, 0x30, 0xa8,
	0x65, 0xcc, 0x77, 0xd3, 0xeb, 0xea, 0xf2, 0x26, 0x84, 0xe6, 0x5f, 0x1e, 0x59, 0x77, 0x4d, 0xf4,
	0x90, 0xac, 0xdd, 0x07, 0x6d, 0xb8, 0xc0, 0xdb, 0x97, 0xfd, 0x96, 0x8f, 0x5e, 0xbd, 0xac, 0x6d,
	0x1c, 0x9b, 0xe4, 0x31, 0x88, 0xd6, 0xbd, 0xdd, 0xee, 0xde, 0x27, 0x9f, 0xde, 0xb5, 0xb9, 0xf6,
	0x73, 0xa1, 0xc3, 0x76, 0xfd, 0x34, 0x24, 0xab, 0x27, 0x09, 0x13, 0xda, 0xee, 0x90, 0xb5, 0xb9,
	0x73, 0xfe, 0x23, 0xfb, 0x3d, 0x92, 0x89, 0x09, 0xf6, 0x5e, 0xbd, 0xac, 0x55, 0xf6, 0xad, 0xff,
	0x69, 0xd2, 0x9a, 0x86, 0x5b, 0x77, 0xed, 0x3e, 0x15, 0x14, 0xb7, 0x2d, 0xc2, 0xd9, 0x26, 0xe7,
	0x36, 0xbf, 0x23, 0x5b, 0xf3, 0x7b, 0x93, 0x7e, 0x41, 0xe8, 0xcd, 0x95, 0x87, 0xf7, 0xf1, 0x50,
	0xc5, 0xa0, 0x7c, 0x3d, 0x6e, 0xac, 0xf3, 0xbe, 0x83, 0x9c, 0xa3, 0x6d, 0xfe, 0xe6, 0x91, 0xcd,
	0x9b, 0xe1, 0xfd, 0x33, 0x10, 0x86, 0x3e, 0x22, 0xab, 0x38, 0xb0, 0x77, 0x1a, 0x91, 0x1b, 0xdd,
	0x0d, 0xbc, 0xc1, 0xd3, 0x68, 0x70, 0xe7, 0x32, 0xbd, 0xbc, 0x15, 0xb0, 0xa1, 0xb6, 0xb9, 0x50,
	0x6e, 0x53, 0xe7, 0x76, 0xfa, 0x35, 0x29, 0xa5, 0xe8, 0xac, 0x46, 0xf5, 0xc5, 0xb7, 0x2e, 0xed,
	0x38, 0x85, 0x63, 0xb7, 0xe3, 0xd2, 0xd5, 0xe6, 0x2f, 0x1e, 0xa9, 0xcd, 0xcd, 0xf7, 0x31, 0xd7,
	0x86, 0xfe, 0x30, 0x5b, 0x29, 0x5c, 0xd4, 0x55, 0x0f, 0x5b, 0xa9, 0xb1, 0x78, 0x5f, 0xd4, 0x05,
	0xd5, 0xfc, 0x34, 0x11, 0xd7, 0xee, 0xff, 0x58, 0x00, 0xee, 0xfe, 0xbe, 0x34, 0x5b, 0xc0, 0x2f,
	0x15, 0x7f, 0x76, 0x8f, 0x7e, 0x43, 0x36, 0xbf, 0xb5, 0x6d, 0x3d, 0xf3, 0xb8, 0xde, 0x7c, 0x08,
	0xeb, 0x1f, 0xfc, 0x4f, 0x5a, 0xf6, 0x6c, 0xcd, 0x5b, 0x7b, 0x1e, 0x7d, 0x42, 0x2a, 0x76, 0xfc,
	0xa6, 0x88, 0x75, 0xfd, 0xc7, 0xcf, 0x35, 0x39, 0xe7, 0xf9, 0x2f, 0x0c, 0xc1, 0xd0, 0xa2, 0xad,
	0x00, 0x2d, 0x2a, 0xa9, 0x0d, 0x2d, 0xf5, 0x21, 0x02, 0x03, 0xb4, 0xa0, 0x46, 0xa6, 0xfe, 0x99,
	0xff, 0x53, 0xbe, 0x55, 0xe7, 0x04, 0x04, 0x13, 0xe6, 0xc5, 0xbf, 0x62, 0xf6, 0x2d, 0xd3, 0x8a,
	0x85, 0x30, 0x1b, 0x7e, 0x11, 0xac, 0x5f, 0x5e, 0x6d, 0x7b, 0xaf, 0xaf, 0xb6, 0xbd, 0xbf, 0xaf,
	0xb6, 0xbd, 0x23, 0xef, 0xb4, 0x84, 0x79, 0x7e, 0xfc, 0x4f, 0x00, 0x00, 0x00, 0xff, 0xff, 0xf1,
	0xf0, 0x9f, 0x10, 0x7b, 0x07, 0x00, 0x00,
}
