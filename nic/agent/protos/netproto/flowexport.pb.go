// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: flowexport.proto

package netproto

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "google.golang.org/genproto/googleapis/api/annotations"
import _ "github.com/pensando/sw/venice/utils/apigen/annotations"
import _ "github.com/gogo/protobuf/gogoproto"
import api "github.com/pensando/sw/api"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// FlowExportPolicy flow export Policy object
type FlowExportPolicy struct {
	api.TypeMeta   `protobuf:"bytes,1,opt,name=TypeMeta,embedded=TypeMeta" json:",inline"`
	api.ObjectMeta `protobuf:"bytes,2,opt,name=ObjectMeta,embedded=ObjectMeta" json:"meta,omitempty"`
	Spec           FlowExportPolicySpec   `protobuf:"bytes,3,opt,name=Spec" json:"spec,omitempty"`
	Status         FlowExportPolicyStatus `protobuf:"bytes,4,opt,name=Status" json:"status,omitempty"`
}

func (m *FlowExportPolicy) Reset()                    { *m = FlowExportPolicy{} }
func (m *FlowExportPolicy) String() string            { return proto.CompactTextString(m) }
func (*FlowExportPolicy) ProtoMessage()               {}
func (*FlowExportPolicy) Descriptor() ([]byte, []int) { return fileDescriptorFlowexport, []int{0} }

func (m *FlowExportPolicy) GetSpec() FlowExportPolicySpec {
	if m != nil {
		return m.Spec
	}
	return FlowExportPolicySpec{}
}

func (m *FlowExportPolicy) GetStatus() FlowExportPolicyStatus {
	if m != nil {
		return m.Status
	}
	return FlowExportPolicyStatus{}
}

type FlowExportPolicySpec struct {
	//  VrfName specifies the name of the VRF that the current Flow Export Policy belongs to
	VrfName string `protobuf:"bytes,1,opt,name=VrfName,proto3" json:"vrf-name,omitempty"`
	// Interval defines how often to push the records to an external or internal collector
	// The value is specified as a string format to be '10s', '20m', '20mins', '10secs', '10seconds'
	Interval string `protobuf:"bytes,2,opt,name=Interval,proto3" json:"interval,omitempty"`
	// TemplateInterval defines how often to send ipfix templates to an external collector
	// The value is specified as a string format, '3m', '10m'
	TemplateInterval string      `protobuf:"bytes,3,opt,name=TemplateInterval,proto3" json:"template-interval,omitempty"`
	Format           string      `protobuf:"bytes,4,opt,name=Format,proto3" json:"format,omitempty"`
	MatchRules       []MatchRule `protobuf:"bytes,5,rep,name=MatchRules" json:"match-rules,omitempty"`
	// Export contains export parameters.
	Exports []ExportConfig `protobuf:"bytes,6,rep,name=Exports" json:"exports,omitempty"`
}

func (m *FlowExportPolicySpec) Reset()                    { *m = FlowExportPolicySpec{} }
func (m *FlowExportPolicySpec) String() string            { return proto.CompactTextString(m) }
func (*FlowExportPolicySpec) ProtoMessage()               {}
func (*FlowExportPolicySpec) Descriptor() ([]byte, []int) { return fileDescriptorFlowexport, []int{1} }

func (m *FlowExportPolicySpec) GetVrfName() string {
	if m != nil {
		return m.VrfName
	}
	return ""
}

func (m *FlowExportPolicySpec) GetInterval() string {
	if m != nil {
		return m.Interval
	}
	return ""
}

func (m *FlowExportPolicySpec) GetTemplateInterval() string {
	if m != nil {
		return m.TemplateInterval
	}
	return ""
}

func (m *FlowExportPolicySpec) GetFormat() string {
	if m != nil {
		return m.Format
	}
	return ""
}

func (m *FlowExportPolicySpec) GetMatchRules() []MatchRule {
	if m != nil {
		return m.MatchRules
	}
	return nil
}

func (m *FlowExportPolicySpec) GetExports() []ExportConfig {
	if m != nil {
		return m.Exports
	}
	return nil
}

type ExportConfig struct {
	// IP address of the collector/entity to which the data is to be exported
	Destination string `protobuf:"bytes,1,opt,name=Destination,proto3" json:"destination,omitempty"`
	// protocol and Port number where an external collector is gathering the data
	// example "UDP/2055"
	Transport *ProtoPort `protobuf:"bytes,2,opt,name=Transport" json:"proto-port,omitempty"`
	// Gateway of IP address or URL of the collector/entity to which the data is to be exported
	Gateway string `protobuf:"bytes,3,opt,name=Gateway,proto3" json:"gateway,omitempty"`
}

func (m *ExportConfig) Reset()                    { *m = ExportConfig{} }
func (m *ExportConfig) String() string            { return proto.CompactTextString(m) }
func (*ExportConfig) ProtoMessage()               {}
func (*ExportConfig) Descriptor() ([]byte, []int) { return fileDescriptorFlowexport, []int{2} }

func (m *ExportConfig) GetDestination() string {
	if m != nil {
		return m.Destination
	}
	return ""
}

func (m *ExportConfig) GetTransport() *ProtoPort {
	if m != nil {
		return m.Transport
	}
	return nil
}

func (m *ExportConfig) GetGateway() string {
	if m != nil {
		return m.Gateway
	}
	return ""
}

type FlowExportPolicyStatus struct {
	FlowExportPolicyID uint64   `protobuf:"varint,1,opt,name=FlowExportPolicyID,proto3" json:"id,omitempty"`
	ExportCollectorIDs []uint64 `protobuf:"varint,2,rep,packed,name=ExportCollectorIDs" json:"export-collector-ids,omitempty"`
	FlowMonitorIDs     []uint64 `protobuf:"varint,3,rep,packed,name=FlowMonitorIDs" json:"flow-monitor-ids,omitempty"`
}

func (m *FlowExportPolicyStatus) Reset()                    { *m = FlowExportPolicyStatus{} }
func (m *FlowExportPolicyStatus) String() string            { return proto.CompactTextString(m) }
func (*FlowExportPolicyStatus) ProtoMessage()               {}
func (*FlowExportPolicyStatus) Descriptor() ([]byte, []int) { return fileDescriptorFlowexport, []int{3} }

func (m *FlowExportPolicyStatus) GetFlowExportPolicyID() uint64 {
	if m != nil {
		return m.FlowExportPolicyID
	}
	return 0
}

func (m *FlowExportPolicyStatus) GetExportCollectorIDs() []uint64 {
	if m != nil {
		return m.ExportCollectorIDs
	}
	return nil
}

func (m *FlowExportPolicyStatus) GetFlowMonitorIDs() []uint64 {
	if m != nil {
		return m.FlowMonitorIDs
	}
	return nil
}

type FlowExportPolicyList struct {
	FlowExportPolicys []*FlowExportPolicy `protobuf:"bytes,1,rep,name=FlowExportPolicys" json:"FlowExportPolicys,omitempty"`
}

func (m *FlowExportPolicyList) Reset()                    { *m = FlowExportPolicyList{} }
func (m *FlowExportPolicyList) String() string            { return proto.CompactTextString(m) }
func (*FlowExportPolicyList) ProtoMessage()               {}
func (*FlowExportPolicyList) Descriptor() ([]byte, []int) { return fileDescriptorFlowexport, []int{4} }

func (m *FlowExportPolicyList) GetFlowExportPolicys() []*FlowExportPolicy {
	if m != nil {
		return m.FlowExportPolicys
	}
	return nil
}

type FlowExportPolicyEvent struct {
	// event type create/update/delete
	EventType api.EventType `protobuf:"varint,1,opt,name=EventType,proto3,enum=api.EventType" json:"event-type,omitempty"`
	// flow export policy
	Policy *FlowExportPolicy `protobuf:"bytes,2,opt,name=Policy" json:"flowexport-policy,omitempty"`
	// flow export policy (upgrade price!)
	FlowExportPolicy *FlowExportPolicy `protobuf:"bytes,3,opt,name=FlowExportPolicy" json:"flowexport-policy,omitempty"`
}

func (m *FlowExportPolicyEvent) Reset()                    { *m = FlowExportPolicyEvent{} }
func (m *FlowExportPolicyEvent) String() string            { return proto.CompactTextString(m) }
func (*FlowExportPolicyEvent) ProtoMessage()               {}
func (*FlowExportPolicyEvent) Descriptor() ([]byte, []int) { return fileDescriptorFlowexport, []int{5} }

func (m *FlowExportPolicyEvent) GetEventType() api.EventType {
	if m != nil {
		return m.EventType
	}
	return api.EventType_CreateEvent
}

func (m *FlowExportPolicyEvent) GetPolicy() *FlowExportPolicy {
	if m != nil {
		return m.Policy
	}
	return nil
}

func (m *FlowExportPolicyEvent) GetFlowExportPolicy() *FlowExportPolicy {
	if m != nil {
		return m.FlowExportPolicy
	}
	return nil
}

type FlowExportPolicyEventList struct {
	FlowExportPolicyEvents []*FlowExportPolicyEvent `protobuf:"bytes,1,rep,name=FlowExportPolicyEvents" json:"event-list,omitempty"`
}

func (m *FlowExportPolicyEventList) Reset()         { *m = FlowExportPolicyEventList{} }
func (m *FlowExportPolicyEventList) String() string { return proto.CompactTextString(m) }
func (*FlowExportPolicyEventList) ProtoMessage()    {}
func (*FlowExportPolicyEventList) Descriptor() ([]byte, []int) {
	return fileDescriptorFlowexport, []int{6}
}

func (m *FlowExportPolicyEventList) GetFlowExportPolicyEvents() []*FlowExportPolicyEvent {
	if m != nil {
		return m.FlowExportPolicyEvents
	}
	return nil
}

func init() {
	proto.RegisterType((*FlowExportPolicy)(nil), "netproto.FlowExportPolicy")
	proto.RegisterType((*FlowExportPolicySpec)(nil), "netproto.FlowExportPolicySpec")
	proto.RegisterType((*ExportConfig)(nil), "netproto.ExportConfig")
	proto.RegisterType((*FlowExportPolicyStatus)(nil), "netproto.FlowExportPolicyStatus")
	proto.RegisterType((*FlowExportPolicyList)(nil), "netproto.FlowExportPolicyList")
	proto.RegisterType((*FlowExportPolicyEvent)(nil), "netproto.FlowExportPolicyEvent")
	proto.RegisterType((*FlowExportPolicyEventList)(nil), "netproto.FlowExportPolicyEventList")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for FlowExportPolicyApiV1 service

type FlowExportPolicyApiV1Client interface {
	// TODO uncomment Oper update when TPM uses nimbus
	WatchFlowExportPolicy(ctx context.Context, in *api.ObjectMeta, opts ...grpc.CallOption) (FlowExportPolicyApiV1_WatchFlowExportPolicyClient, error)
	ListFlowExportPolicy(ctx context.Context, in *api.ObjectMeta, opts ...grpc.CallOption) (*FlowExportPolicyEventList, error)
}

type flowExportPolicyApiV1Client struct {
	cc *grpc.ClientConn
}

func NewFlowExportPolicyApiV1Client(cc *grpc.ClientConn) FlowExportPolicyApiV1Client {
	return &flowExportPolicyApiV1Client{cc}
}

func (c *flowExportPolicyApiV1Client) WatchFlowExportPolicy(ctx context.Context, in *api.ObjectMeta, opts ...grpc.CallOption) (FlowExportPolicyApiV1_WatchFlowExportPolicyClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_FlowExportPolicyApiV1_serviceDesc.Streams[0], c.cc, "/netproto.FlowExportPolicyApiV1/WatchFlowExportPolicy", opts...)
	if err != nil {
		return nil, err
	}
	x := &flowExportPolicyApiV1WatchFlowExportPolicyClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type FlowExportPolicyApiV1_WatchFlowExportPolicyClient interface {
	Recv() (*FlowExportPolicyEventList, error)
	grpc.ClientStream
}

type flowExportPolicyApiV1WatchFlowExportPolicyClient struct {
	grpc.ClientStream
}

func (x *flowExportPolicyApiV1WatchFlowExportPolicyClient) Recv() (*FlowExportPolicyEventList, error) {
	m := new(FlowExportPolicyEventList)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *flowExportPolicyApiV1Client) ListFlowExportPolicy(ctx context.Context, in *api.ObjectMeta, opts ...grpc.CallOption) (*FlowExportPolicyEventList, error) {
	out := new(FlowExportPolicyEventList)
	err := grpc.Invoke(ctx, "/netproto.FlowExportPolicyApiV1/ListFlowExportPolicy", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for FlowExportPolicyApiV1 service

type FlowExportPolicyApiV1Server interface {
	// TODO uncomment Oper update when TPM uses nimbus
	WatchFlowExportPolicy(*api.ObjectMeta, FlowExportPolicyApiV1_WatchFlowExportPolicyServer) error
	ListFlowExportPolicy(context.Context, *api.ObjectMeta) (*FlowExportPolicyEventList, error)
}

func RegisterFlowExportPolicyApiV1Server(s *grpc.Server, srv FlowExportPolicyApiV1Server) {
	s.RegisterService(&_FlowExportPolicyApiV1_serviceDesc, srv)
}

func _FlowExportPolicyApiV1_WatchFlowExportPolicy_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(api.ObjectMeta)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(FlowExportPolicyApiV1Server).WatchFlowExportPolicy(m, &flowExportPolicyApiV1WatchFlowExportPolicyServer{stream})
}

type FlowExportPolicyApiV1_WatchFlowExportPolicyServer interface {
	Send(*FlowExportPolicyEventList) error
	grpc.ServerStream
}

type flowExportPolicyApiV1WatchFlowExportPolicyServer struct {
	grpc.ServerStream
}

func (x *flowExportPolicyApiV1WatchFlowExportPolicyServer) Send(m *FlowExportPolicyEventList) error {
	return x.ServerStream.SendMsg(m)
}

func _FlowExportPolicyApiV1_ListFlowExportPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(api.ObjectMeta)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FlowExportPolicyApiV1Server).ListFlowExportPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/netproto.FlowExportPolicyApiV1/ListFlowExportPolicy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FlowExportPolicyApiV1Server).ListFlowExportPolicy(ctx, req.(*api.ObjectMeta))
	}
	return interceptor(ctx, in, info, handler)
}

var _FlowExportPolicyApiV1_serviceDesc = grpc.ServiceDesc{
	ServiceName: "netproto.FlowExportPolicyApiV1",
	HandlerType: (*FlowExportPolicyApiV1Server)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListFlowExportPolicy",
			Handler:    _FlowExportPolicyApiV1_ListFlowExportPolicy_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "WatchFlowExportPolicy",
			Handler:       _FlowExportPolicyApiV1_WatchFlowExportPolicy_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "flowexport.proto",
}

// Client API for FlowExportPolicyApiV2 service

type FlowExportPolicyApiV2Client interface {
	// TODO uncomment Oper update when TPM uses nimbus
	WatchFlowExportPolicys(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (FlowExportPolicyApiV2_WatchFlowExportPolicysClient, error)
	ListFlowExportPolicys(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (*FlowExportPolicyList, error)
	FlowExportPolicyOperUpdate(ctx context.Context, opts ...grpc.CallOption) (FlowExportPolicyApiV2_FlowExportPolicyOperUpdateClient, error)
}

type flowExportPolicyApiV2Client struct {
	cc *grpc.ClientConn
}

func NewFlowExportPolicyApiV2Client(cc *grpc.ClientConn) FlowExportPolicyApiV2Client {
	return &flowExportPolicyApiV2Client{cc}
}

func (c *flowExportPolicyApiV2Client) WatchFlowExportPolicys(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (FlowExportPolicyApiV2_WatchFlowExportPolicysClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_FlowExportPolicyApiV2_serviceDesc.Streams[0], c.cc, "/netproto.FlowExportPolicyApiV2/WatchFlowExportPolicys", opts...)
	if err != nil {
		return nil, err
	}
	x := &flowExportPolicyApiV2WatchFlowExportPolicysClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type FlowExportPolicyApiV2_WatchFlowExportPolicysClient interface {
	Recv() (*FlowExportPolicyEventList, error)
	grpc.ClientStream
}

type flowExportPolicyApiV2WatchFlowExportPolicysClient struct {
	grpc.ClientStream
}

func (x *flowExportPolicyApiV2WatchFlowExportPolicysClient) Recv() (*FlowExportPolicyEventList, error) {
	m := new(FlowExportPolicyEventList)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *flowExportPolicyApiV2Client) ListFlowExportPolicys(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (*FlowExportPolicyList, error) {
	out := new(FlowExportPolicyList)
	err := grpc.Invoke(ctx, "/netproto.FlowExportPolicyApiV2/ListFlowExportPolicys", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *flowExportPolicyApiV2Client) FlowExportPolicyOperUpdate(ctx context.Context, opts ...grpc.CallOption) (FlowExportPolicyApiV2_FlowExportPolicyOperUpdateClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_FlowExportPolicyApiV2_serviceDesc.Streams[1], c.cc, "/netproto.FlowExportPolicyApiV2/FlowExportPolicyOperUpdate", opts...)
	if err != nil {
		return nil, err
	}
	x := &flowExportPolicyApiV2FlowExportPolicyOperUpdateClient{stream}
	return x, nil
}

type FlowExportPolicyApiV2_FlowExportPolicyOperUpdateClient interface {
	Send(*FlowExportPolicyEvent) error
	CloseAndRecv() (*api.TypeMeta, error)
	grpc.ClientStream
}

type flowExportPolicyApiV2FlowExportPolicyOperUpdateClient struct {
	grpc.ClientStream
}

func (x *flowExportPolicyApiV2FlowExportPolicyOperUpdateClient) Send(m *FlowExportPolicyEvent) error {
	return x.ClientStream.SendMsg(m)
}

func (x *flowExportPolicyApiV2FlowExportPolicyOperUpdateClient) CloseAndRecv() (*api.TypeMeta, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(api.TypeMeta)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for FlowExportPolicyApiV2 service

type FlowExportPolicyApiV2Server interface {
	// TODO uncomment Oper update when TPM uses nimbus
	WatchFlowExportPolicys(*api.ListWatchOptions, FlowExportPolicyApiV2_WatchFlowExportPolicysServer) error
	ListFlowExportPolicys(context.Context, *api.ListWatchOptions) (*FlowExportPolicyList, error)
	FlowExportPolicyOperUpdate(FlowExportPolicyApiV2_FlowExportPolicyOperUpdateServer) error
}

func RegisterFlowExportPolicyApiV2Server(s *grpc.Server, srv FlowExportPolicyApiV2Server) {
	s.RegisterService(&_FlowExportPolicyApiV2_serviceDesc, srv)
}

func _FlowExportPolicyApiV2_WatchFlowExportPolicys_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(api.ListWatchOptions)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(FlowExportPolicyApiV2Server).WatchFlowExportPolicys(m, &flowExportPolicyApiV2WatchFlowExportPolicysServer{stream})
}

type FlowExportPolicyApiV2_WatchFlowExportPolicysServer interface {
	Send(*FlowExportPolicyEventList) error
	grpc.ServerStream
}

type flowExportPolicyApiV2WatchFlowExportPolicysServer struct {
	grpc.ServerStream
}

func (x *flowExportPolicyApiV2WatchFlowExportPolicysServer) Send(m *FlowExportPolicyEventList) error {
	return x.ServerStream.SendMsg(m)
}

func _FlowExportPolicyApiV2_ListFlowExportPolicys_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(api.ListWatchOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FlowExportPolicyApiV2Server).ListFlowExportPolicys(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/netproto.FlowExportPolicyApiV2/ListFlowExportPolicys",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FlowExportPolicyApiV2Server).ListFlowExportPolicys(ctx, req.(*api.ListWatchOptions))
	}
	return interceptor(ctx, in, info, handler)
}

func _FlowExportPolicyApiV2_FlowExportPolicyOperUpdate_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(FlowExportPolicyApiV2Server).FlowExportPolicyOperUpdate(&flowExportPolicyApiV2FlowExportPolicyOperUpdateServer{stream})
}

type FlowExportPolicyApiV2_FlowExportPolicyOperUpdateServer interface {
	SendAndClose(*api.TypeMeta) error
	Recv() (*FlowExportPolicyEvent, error)
	grpc.ServerStream
}

type flowExportPolicyApiV2FlowExportPolicyOperUpdateServer struct {
	grpc.ServerStream
}

func (x *flowExportPolicyApiV2FlowExportPolicyOperUpdateServer) SendAndClose(m *api.TypeMeta) error {
	return x.ServerStream.SendMsg(m)
}

func (x *flowExportPolicyApiV2FlowExportPolicyOperUpdateServer) Recv() (*FlowExportPolicyEvent, error) {
	m := new(FlowExportPolicyEvent)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _FlowExportPolicyApiV2_serviceDesc = grpc.ServiceDesc{
	ServiceName: "netproto.FlowExportPolicyApiV2",
	HandlerType: (*FlowExportPolicyApiV2Server)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListFlowExportPolicys",
			Handler:    _FlowExportPolicyApiV2_ListFlowExportPolicys_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "WatchFlowExportPolicys",
			Handler:       _FlowExportPolicyApiV2_WatchFlowExportPolicys_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "FlowExportPolicyOperUpdate",
			Handler:       _FlowExportPolicyApiV2_FlowExportPolicyOperUpdate_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "flowexport.proto",
}

func (m *FlowExportPolicy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlowExportPolicy) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintFlowexport(dAtA, i, uint64(m.TypeMeta.Size()))
	n1, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n1
	dAtA[i] = 0x12
	i++
	i = encodeVarintFlowexport(dAtA, i, uint64(m.ObjectMeta.Size()))
	n2, err := m.ObjectMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n2
	dAtA[i] = 0x1a
	i++
	i = encodeVarintFlowexport(dAtA, i, uint64(m.Spec.Size()))
	n3, err := m.Spec.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n3
	dAtA[i] = 0x22
	i++
	i = encodeVarintFlowexport(dAtA, i, uint64(m.Status.Size()))
	n4, err := m.Status.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n4
	return i, nil
}

func (m *FlowExportPolicySpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlowExportPolicySpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.VrfName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintFlowexport(dAtA, i, uint64(len(m.VrfName)))
		i += copy(dAtA[i:], m.VrfName)
	}
	if len(m.Interval) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintFlowexport(dAtA, i, uint64(len(m.Interval)))
		i += copy(dAtA[i:], m.Interval)
	}
	if len(m.TemplateInterval) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintFlowexport(dAtA, i, uint64(len(m.TemplateInterval)))
		i += copy(dAtA[i:], m.TemplateInterval)
	}
	if len(m.Format) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintFlowexport(dAtA, i, uint64(len(m.Format)))
		i += copy(dAtA[i:], m.Format)
	}
	if len(m.MatchRules) > 0 {
		for _, msg := range m.MatchRules {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintFlowexport(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Exports) > 0 {
		for _, msg := range m.Exports {
			dAtA[i] = 0x32
			i++
			i = encodeVarintFlowexport(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ExportConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExportConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Destination) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintFlowexport(dAtA, i, uint64(len(m.Destination)))
		i += copy(dAtA[i:], m.Destination)
	}
	if m.Transport != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintFlowexport(dAtA, i, uint64(m.Transport.Size()))
		n5, err := m.Transport.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if len(m.Gateway) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintFlowexport(dAtA, i, uint64(len(m.Gateway)))
		i += copy(dAtA[i:], m.Gateway)
	}
	return i, nil
}

func (m *FlowExportPolicyStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlowExportPolicyStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.FlowExportPolicyID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFlowexport(dAtA, i, uint64(m.FlowExportPolicyID))
	}
	if len(m.ExportCollectorIDs) > 0 {
		dAtA7 := make([]byte, len(m.ExportCollectorIDs)*10)
		var j6 int
		for _, num := range m.ExportCollectorIDs {
			for num >= 1<<7 {
				dAtA7[j6] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j6++
			}
			dAtA7[j6] = uint8(num)
			j6++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintFlowexport(dAtA, i, uint64(j6))
		i += copy(dAtA[i:], dAtA7[:j6])
	}
	if len(m.FlowMonitorIDs) > 0 {
		dAtA9 := make([]byte, len(m.FlowMonitorIDs)*10)
		var j8 int
		for _, num := range m.FlowMonitorIDs {
			for num >= 1<<7 {
				dAtA9[j8] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j8++
			}
			dAtA9[j8] = uint8(num)
			j8++
		}
		dAtA[i] = 0x1a
		i++
		i = encodeVarintFlowexport(dAtA, i, uint64(j8))
		i += copy(dAtA[i:], dAtA9[:j8])
	}
	return i, nil
}

func (m *FlowExportPolicyList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlowExportPolicyList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.FlowExportPolicys) > 0 {
		for _, msg := range m.FlowExportPolicys {
			dAtA[i] = 0xa
			i++
			i = encodeVarintFlowexport(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *FlowExportPolicyEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlowExportPolicyEvent) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.EventType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFlowexport(dAtA, i, uint64(m.EventType))
	}
	if m.Policy != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintFlowexport(dAtA, i, uint64(m.Policy.Size()))
		n10, err := m.Policy.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.FlowExportPolicy != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintFlowexport(dAtA, i, uint64(m.FlowExportPolicy.Size()))
		n11, err := m.FlowExportPolicy.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	return i, nil
}

func (m *FlowExportPolicyEventList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlowExportPolicyEventList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.FlowExportPolicyEvents) > 0 {
		for _, msg := range m.FlowExportPolicyEvents {
			dAtA[i] = 0xa
			i++
			i = encodeVarintFlowexport(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func encodeVarintFlowexport(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *FlowExportPolicy) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovFlowexport(uint64(l))
	l = m.ObjectMeta.Size()
	n += 1 + l + sovFlowexport(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovFlowexport(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovFlowexport(uint64(l))
	return n
}

func (m *FlowExportPolicySpec) Size() (n int) {
	var l int
	_ = l
	l = len(m.VrfName)
	if l > 0 {
		n += 1 + l + sovFlowexport(uint64(l))
	}
	l = len(m.Interval)
	if l > 0 {
		n += 1 + l + sovFlowexport(uint64(l))
	}
	l = len(m.TemplateInterval)
	if l > 0 {
		n += 1 + l + sovFlowexport(uint64(l))
	}
	l = len(m.Format)
	if l > 0 {
		n += 1 + l + sovFlowexport(uint64(l))
	}
	if len(m.MatchRules) > 0 {
		for _, e := range m.MatchRules {
			l = e.Size()
			n += 1 + l + sovFlowexport(uint64(l))
		}
	}
	if len(m.Exports) > 0 {
		for _, e := range m.Exports {
			l = e.Size()
			n += 1 + l + sovFlowexport(uint64(l))
		}
	}
	return n
}

func (m *ExportConfig) Size() (n int) {
	var l int
	_ = l
	l = len(m.Destination)
	if l > 0 {
		n += 1 + l + sovFlowexport(uint64(l))
	}
	if m.Transport != nil {
		l = m.Transport.Size()
		n += 1 + l + sovFlowexport(uint64(l))
	}
	l = len(m.Gateway)
	if l > 0 {
		n += 1 + l + sovFlowexport(uint64(l))
	}
	return n
}

func (m *FlowExportPolicyStatus) Size() (n int) {
	var l int
	_ = l
	if m.FlowExportPolicyID != 0 {
		n += 1 + sovFlowexport(uint64(m.FlowExportPolicyID))
	}
	if len(m.ExportCollectorIDs) > 0 {
		l = 0
		for _, e := range m.ExportCollectorIDs {
			l += sovFlowexport(uint64(e))
		}
		n += 1 + sovFlowexport(uint64(l)) + l
	}
	if len(m.FlowMonitorIDs) > 0 {
		l = 0
		for _, e := range m.FlowMonitorIDs {
			l += sovFlowexport(uint64(e))
		}
		n += 1 + sovFlowexport(uint64(l)) + l
	}
	return n
}

func (m *FlowExportPolicyList) Size() (n int) {
	var l int
	_ = l
	if len(m.FlowExportPolicys) > 0 {
		for _, e := range m.FlowExportPolicys {
			l = e.Size()
			n += 1 + l + sovFlowexport(uint64(l))
		}
	}
	return n
}

func (m *FlowExportPolicyEvent) Size() (n int) {
	var l int
	_ = l
	if m.EventType != 0 {
		n += 1 + sovFlowexport(uint64(m.EventType))
	}
	if m.Policy != nil {
		l = m.Policy.Size()
		n += 1 + l + sovFlowexport(uint64(l))
	}
	if m.FlowExportPolicy != nil {
		l = m.FlowExportPolicy.Size()
		n += 1 + l + sovFlowexport(uint64(l))
	}
	return n
}

func (m *FlowExportPolicyEventList) Size() (n int) {
	var l int
	_ = l
	if len(m.FlowExportPolicyEvents) > 0 {
		for _, e := range m.FlowExportPolicyEvents {
			l = e.Size()
			n += 1 + l + sovFlowexport(uint64(l))
		}
	}
	return n
}

func sovFlowexport(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozFlowexport(x uint64) (n int) {
	return sovFlowexport(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *FlowExportPolicy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlowexport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlowExportPolicy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlowExportPolicy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowexport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlowexport
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowexport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlowexport
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowexport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlowexport
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowexport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlowexport
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlowexport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFlowexport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlowExportPolicySpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlowexport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlowExportPolicySpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlowExportPolicySpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VrfName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowexport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlowexport
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VrfName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Interval", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowexport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlowexport
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Interval = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TemplateInterval", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowexport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlowexport
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TemplateInterval = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Format", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowexport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlowexport
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Format = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchRules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowexport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlowexport
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MatchRules = append(m.MatchRules, MatchRule{})
			if err := m.MatchRules[len(m.MatchRules)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exports", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowexport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlowexport
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Exports = append(m.Exports, ExportConfig{})
			if err := m.Exports[len(m.Exports)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlowexport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFlowexport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExportConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlowexport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExportConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExportConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Destination", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowexport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlowexport
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Destination = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Transport", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowexport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlowexport
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Transport == nil {
				m.Transport = &ProtoPort{}
			}
			if err := m.Transport.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gateway", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowexport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlowexport
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Gateway = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlowexport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFlowexport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlowExportPolicyStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlowexport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlowExportPolicyStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlowExportPolicyStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlowExportPolicyID", wireType)
			}
			m.FlowExportPolicyID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowexport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FlowExportPolicyID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFlowexport
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ExportCollectorIDs = append(m.ExportCollectorIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFlowexport
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFlowexport
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFlowexport
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ExportCollectorIDs = append(m.ExportCollectorIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ExportCollectorIDs", wireType)
			}
		case 3:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFlowexport
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.FlowMonitorIDs = append(m.FlowMonitorIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFlowexport
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFlowexport
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFlowexport
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.FlowMonitorIDs = append(m.FlowMonitorIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field FlowMonitorIDs", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFlowexport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFlowexport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlowExportPolicyList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlowexport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlowExportPolicyList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlowExportPolicyList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlowExportPolicys", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowexport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlowexport
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FlowExportPolicys = append(m.FlowExportPolicys, &FlowExportPolicy{})
			if err := m.FlowExportPolicys[len(m.FlowExportPolicys)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlowexport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFlowexport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlowExportPolicyEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlowexport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlowExportPolicyEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlowExportPolicyEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventType", wireType)
			}
			m.EventType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowexport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EventType |= (api.EventType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Policy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowexport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlowexport
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Policy == nil {
				m.Policy = &FlowExportPolicy{}
			}
			if err := m.Policy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlowExportPolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowexport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlowexport
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FlowExportPolicy == nil {
				m.FlowExportPolicy = &FlowExportPolicy{}
			}
			if err := m.FlowExportPolicy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlowexport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFlowexport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlowExportPolicyEventList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlowexport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlowExportPolicyEventList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlowExportPolicyEventList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlowExportPolicyEvents", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowexport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlowexport
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FlowExportPolicyEvents = append(m.FlowExportPolicyEvents, &FlowExportPolicyEvent{})
			if err := m.FlowExportPolicyEvents[len(m.FlowExportPolicyEvents)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlowexport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFlowexport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipFlowexport(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowFlowexport
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFlowexport
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFlowexport
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthFlowexport
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowFlowexport
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipFlowexport(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthFlowexport = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowFlowexport   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("flowexport.proto", fileDescriptorFlowexport) }

var fileDescriptorFlowexport = []byte{
	// 1050 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x96, 0x41, 0x6f, 0xe3, 0x44,
	0x14, 0xc7, 0xd7, 0x4d, 0x48, 0xdb, 0x69, 0x29, 0xed, 0x6c, 0x5a, 0x39, 0xde, 0x25, 0xae, 0x5c,
	0x21, 0xb2, 0xa8, 0x4e, 0xba, 0x61, 0x0f, 0x5c, 0x40, 0x5a, 0xd3, 0x16, 0xba, 0xdd, 0x6e, 0x43,
	0x5a, 0xba, 0x1c, 0x99, 0x3a, 0x93, 0xec, 0x80, 0x3d, 0x63, 0xec, 0x49, 0x43, 0x84, 0xf6, 0x84,
	0xd4, 0xe3, 0x9e, 0xf9, 0x0a, 0xf4, 0xc8, 0x91, 0x0b, 0xd7, 0x1e, 0xf7, 0x13, 0x44, 0xa8, 0xc7,
	0x7c, 0x02, 0x2e, 0x48, 0x68, 0xc6, 0x4e, 0x3c, 0x9b, 0x38, 0x5d, 0x24, 0xb8, 0x44, 0xf6, 0x7b,
	0xef, 0xff, 0x9b, 0x37, 0xef, 0x8d, 0xdf, 0x04, 0xac, 0xb6, 0x3d, 0xd6, 0xc3, 0x3f, 0x06, 0x2c,
	0xe4, 0xd5, 0x20, 0x64, 0x9c, 0xc1, 0x05, 0x8a, 0xb9, 0x7c, 0x32, 0xee, 0x77, 0x18, 0xeb, 0x78,
	0xb8, 0x86, 0x02, 0x52, 0x43, 0x94, 0x32, 0x8e, 0x38, 0x61, 0x34, 0x8a, 0xe3, 0x8c, 0xbd, 0x0e,
	0xe1, 0x2f, 0xba, 0xe7, 0x55, 0x97, 0xf9, 0xb5, 0x00, 0xd3, 0x08, 0xd1, 0x16, 0xab, 0x45, 0xbd,
	0xda, 0x05, 0xa6, 0xc4, 0xc5, 0xb5, 0x2e, 0x27, 0x5e, 0x24, 0xa4, 0x1d, 0x4c, 0x55, 0x75, 0x8d,
	0x50, 0xd7, 0xeb, 0xb6, 0xf0, 0x08, 0x63, 0x2b, 0x98, 0x0e, 0xeb, 0xb0, 0x9a, 0x34, 0x9f, 0x77,
	0xdb, 0xf2, 0x4d, 0xbe, 0xc8, 0xa7, 0x24, 0xfc, 0x83, 0x19, 0xab, 0x8a, 0x1c, 0x7d, 0xcc, 0x51,
	0x12, 0xb6, 0xe4, 0x23, 0xee, 0xbe, 0x88, 0x5f, 0xac, 0x3f, 0xe6, 0xc0, 0xea, 0xbe, 0xc7, 0x7a,
	0x7b, 0x72, 0x9b, 0x0d, 0xe6, 0x11, 0xb7, 0x0f, 0x3f, 0x03, 0x0b, 0xa7, 0xfd, 0x00, 0x1f, 0x61,
	0x8e, 0x74, 0x6d, 0x53, 0xab, 0x2c, 0xd5, 0xdf, 0xad, 0xa2, 0x80, 0x54, 0x47, 0x46, 0xe7, 0xee,
	0xf5, 0xc0, 0xbc, 0xf3, 0x7a, 0x60, 0x6a, 0xc3, 0x81, 0x39, 0xbf, 0x4d, 0xa8, 0x47, 0x28, 0x6e,
	0x8e, 0x35, 0xf0, 0x10, 0x80, 0xe3, 0xf3, 0xef, 0xb0, 0xcb, 0x25, 0x61, 0x4e, 0x12, 0xde, 0x93,
	0x84, 0xd4, 0xec, 0x18, 0x0a, 0x63, 0x45, 0xa4, 0xb7, 0xcd, 0x7c, 0xc2, 0xb1, 0x1f, 0xf0, 0x7e,
	0x53, 0x91, 0xc3, 0x27, 0x20, 0x7f, 0x12, 0x60, 0x57, 0xcf, 0x49, 0x4c, 0xb9, 0x3a, 0x6a, 0x41,
	0x75, 0x32, 0x6d, 0x11, 0xe5, 0x6c, 0x08, 0xaa, 0x20, 0x46, 0x01, 0x76, 0x15, 0xa2, 0x64, 0xc0,
	0x26, 0x28, 0x9c, 0x70, 0xc4, 0xbb, 0x91, 0x9e, 0x97, 0xb4, 0xcd, 0x5b, 0x68, 0x32, 0xce, 0xd1,
	0x13, 0xde, 0x6a, 0x24, 0xdf, 0x15, 0x62, 0x42, 0xb2, 0x7e, 0xc9, 0x81, 0x62, 0x56, 0x2a, 0x70,
	0x07, 0xcc, 0x9f, 0x85, 0xed, 0x67, 0xc8, 0xc7, 0xb2, 0x88, 0x8b, 0xce, 0xc6, 0x70, 0x60, 0xc2,
	0x8b, 0xb0, 0x6d, 0x53, 0xe4, 0x63, 0x85, 0x34, 0x0a, 0x83, 0x75, 0xb0, 0x70, 0x40, 0x39, 0x0e,
	0x2f, 0x90, 0x27, 0xab, 0x96, 0x48, 0x48, 0x62, 0x53, 0x24, 0xe3, 0x38, 0x78, 0x08, 0x56, 0x4f,
	0xb1, 0x1f, 0x78, 0x88, 0xe3, 0xb1, 0x36, 0x27, 0xb5, 0xe6, 0x70, 0x60, 0xde, 0xe3, 0x89, 0xcf,
	0xce, 0x80, 0x4c, 0x09, 0xe1, 0x36, 0x28, 0xec, 0xb3, 0xd0, 0x47, 0x5c, 0xd6, 0x67, 0xd1, 0x29,
	0x8a, 0x9d, 0xb7, 0xa5, 0x45, 0xdd, 0x79, 0x1c, 0x03, 0x9b, 0x00, 0x1c, 0x89, 0xa3, 0xd4, 0xec,
	0x7a, 0x38, 0xd2, 0xdf, 0xd9, 0xcc, 0x55, 0x96, 0xea, 0x77, 0xd3, 0x8a, 0x8e, 0x7d, 0xce, 0xfb,
	0x49, 0x11, 0xd7, 0xe5, 0xc9, 0xb3, 0x43, 0x11, 0xaf, 0x76, 0x3b, 0xa5, 0xc0, 0x43, 0x30, 0x1f,
	0x17, 0x32, 0xd2, 0x0b, 0x12, 0xb8, 0x91, 0x02, 0x63, 0xc7, 0xe7, 0x8c, 0xb6, 0x49, 0xc7, 0x29,
	0x25, 0xcc, 0xb5, 0xf8, 0x03, 0x55, 0x79, 0x23, 0x82, 0xf5, 0xb7, 0x06, 0x96, 0x55, 0x11, 0xdc,
	0x03, 0x4b, 0xbb, 0x38, 0xe2, 0x84, 0xca, 0xef, 0x2d, 0x69, 0xcb, 0xd6, 0xd5, 0x65, 0xa9, 0x70,
	0xd0, 0xb8, 0x78, 0x54, 0x79, 0x20, 0x72, 0x6c, 0xa5, 0x01, 0x0a, 0x53, 0xd5, 0x41, 0x17, 0x2c,
	0x9e, 0x86, 0x88, 0x46, 0x82, 0x9c, 0x1c, 0x6f, 0x65, 0xdf, 0x0d, 0xf1, 0xdb, 0x60, 0x21, 0x77,
	0x76, 0xae, 0x2e, 0x4b, 0xc5, 0x3d, 0xa1, 0x3f, 0x0e, 0x2b, 0x63, 0x73, 0xe5, 0x81, 0x58, 0xa7,
	0x28, 0x83, 0x6d, 0x81, 0x50, 0x96, 0x49, 0xb9, 0xf0, 0x31, 0x98, 0xff, 0x02, 0x71, 0xdc, 0x43,
	0xfd, 0xa4, 0x9f, 0x1f, 0x5e, 0x5d, 0x96, 0x56, 0x4e, 0x78, 0xf8, 0x14, 0xd3, 0xca, 0xc3, 0xed,
	0xfa, 0xce, 0xa3, 0x4f, 0x04, 0x67, 0xad, 0x13, 0x07, 0xa9, 0xfb, 0x4f, 0x74, 0xd6, 0x5f, 0x1a,
	0xd8, 0xc8, 0x3e, 0xd7, 0xd0, 0x01, 0x70, 0xd2, 0x73, 0xb0, 0x2b, 0x0b, 0x92, 0x77, 0xe0, 0x70,
	0x60, 0x2e, 0x93, 0x56, 0x4a, 0xd4, 0xb5, 0x66, 0x46, 0x34, 0x6c, 0x02, 0x38, 0xaa, 0xae, 0xe7,
	0x61, 0x97, 0xb3, 0xf0, 0x60, 0x37, 0xd2, 0xe7, 0x36, 0x73, 0x95, 0xbc, 0x63, 0x0d, 0x07, 0x66,
	0x39, 0x6e, 0x8d, 0xed, 0x8e, 0xdc, 0x36, 0x69, 0xa9, 0x7d, 0xca, 0x50, 0xc3, 0x7d, 0xb0, 0x22,
	0x56, 0x3a, 0x62, 0x94, 0x24, 0xbc, 0x9c, 0xe4, 0x95, 0x87, 0x03, 0xd3, 0x10, 0xf3, 0xd8, 0xf6,
	0x63, 0xd7, 0x04, 0x6b, 0x42, 0x65, 0x7d, 0x3b, 0xfd, 0x51, 0x3e, 0x25, 0x11, 0x87, 0x5f, 0x82,
	0xb5, 0x49, 0x7b, 0xa4, 0x6b, 0xf2, 0xa4, 0x19, 0xb3, 0x87, 0x41, 0x73, 0x5a, 0x64, 0xfd, 0x3a,
	0x07, 0xd6, 0x27, 0xad, 0x7b, 0x17, 0x98, 0x72, 0xf8, 0x04, 0x2c, 0xca, 0x07, 0x31, 0x0f, 0x65,
	0x49, 0x57, 0xea, 0x2b, 0x72, 0xfa, 0x8d, 0xad, 0xce, 0xfd, 0xeb, 0x78, 0xf0, 0x15, 0xb1, 0x30,
	0xd9, 0xbc, 0x1f, 0xa8, 0x03, 0x21, 0x95, 0xc3, 0xe7, 0xa0, 0x10, 0xa3, 0x93, 0x73, 0x76, 0x4b,
	0x92, 0xce, 0x56, 0x02, 0xbd, 0x97, 0xde, 0x5b, 0x76, 0x20, 0x5d, 0xea, 0xc7, 0x9b, 0xcc, 0xf8,
	0xef, 0xa7, 0xe7, 0x7e, 0x32, 0x62, 0xff, 0xf3, 0x12, 0x53, 0x60, 0xeb, 0x95, 0x06, 0x4a, 0x99,
	0xb5, 0x92, 0x3d, 0xf9, 0x61, 0xfa, 0x94, 0x4a, 0xe7, 0xa8, 0x31, 0xe6, 0xec, 0x84, 0x64, 0x9c,
	0xa3, 0xa7, 0x95, 0xf4, 0x48, 0xa4, 0x7e, 0x4f, 0x33, 0xc0, 0xf5, 0xdf, 0xb5, 0xe9, 0xe6, 0x3d,
	0x0e, 0xc8, 0xd9, 0x43, 0xf8, 0x15, 0x58, 0x7f, 0x2e, 0xc6, 0xd1, 0xd4, 0xa5, 0x38, 0x79, 0x81,
	0x19, 0x5b, 0x6f, 0x49, 0x4b, 0xec, 0xcd, 0xba, 0xb3, 0xa3, 0xc1, 0x67, 0xa0, 0x28, 0x9e, 0xff,
	0x2f, 0x62, 0xfd, 0x55, 0x2e, 0x3b, 0xf9, 0x3a, 0xfc, 0x06, 0x6c, 0x64, 0x26, 0x1f, 0xc1, 0x75,
	0xb9, 0x96, 0x00, 0xc8, 0x80, 0xe3, 0x40, 0xfe, 0xe1, 0xf8, 0xf7, 0x7b, 0x68, 0x80, 0xf5, 0xac,
	0x3d, 0xcc, 0x04, 0xdf, 0x72, 0x4f, 0xc7, 0x4c, 0xd8, 0x00, 0xc6, 0xa4, 0xe7, 0x38, 0xc0, 0xe1,
	0xd7, 0x41, 0x0b, 0x71, 0x0c, 0xdf, 0xd6, 0x73, 0xe3, 0xcd, 0x7f, 0x24, 0xd6, 0x9d, 0x8a, 0x66,
	0xf4, 0x7e, 0xfb, 0xb9, 0x14, 0x65, 0xfc, 0x9d, 0xc9, 0x75, 0x30, 0x87, 0x79, 0x71, 0x32, 0x60,
	0x3e, 0x60, 0x11, 0x87, 0x85, 0x16, 0xf6, 0x30, 0xc7, 0x30, 0x17, 0x74, 0xb9, 0xf1, 0x69, 0xed,
	0xa7, 0xb4, 0x05, 0xd5, 0x53, 0x4c, 0x11, 0xe5, 0x2f, 0xdf, 0xb0, 0x89, 0xbb, 0x39, 0x0a, 0x90,
	0x8b, 0xa7, 0xcd, 0x2f, 0x3f, 0x9a, 0x3b, 0xab, 0x3b, 0xcb, 0xd7, 0x37, 0x65, 0xed, 0xf5, 0x4d,
	0x59, 0xfb, 0xf3, 0xa6, 0xac, 0x35, 0xb4, 0xf3, 0x82, 0x4c, 0xfc, 0xe3, 0x7f, 0x02, 0x00, 0x00,
	0xff, 0xff, 0x27, 0x68, 0x50, 0xd8, 0x41, 0x0a, 0x00, 0x00,
}
