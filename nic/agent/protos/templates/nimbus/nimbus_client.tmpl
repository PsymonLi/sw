// Code generated by protoc-gen-grpc-pensando DO NOT EDIT.

/*
Package nimbus is a auto generated package.
Input file: {{.Name}}
*/

package nimbus

import (
	"context"
	"errors"
	"sync"
        "time"

	"github.com/pensando/sw/api"
	"github.com/gogo/protobuf/types"
	"github.com/pensando/sw/nic/agent/protos/netproto"
	"github.com/pensando/sw/venice/globals"
	"github.com/pensando/sw/venice/utils/log"
	"github.com/pensando/sw/venice/utils/memdb"
	"github.com/pensando/sw/venice/utils/rpckit"
    "github.com/pensando/sw/venice/utils/balancer"
    "github.com/pensando/sw/nic/agent/netagent/state"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/connectivity"
	"google.golang.org/grpc/status"
)

{{range .Services}}
    {{$svcname := .Name}}
    {{if (hasExtension "venice.naplesRestService" .)}}
       {{$params := (getRestSvcOptions .)}}
       {{range $params}}
            {{$crudObject := .CrudObject}}


type {{$crudObject}}Reactor interface {
	Create{{$crudObject}}({{lower $crudObject}}Obj *netproto.{{$crudObject}}) error                  // creates an {{$crudObject}}
	Find{{$crudObject}}(meta api.ObjectMeta) (*netproto.{{$crudObject}}, error) // finds an {{$crudObject}}
	List{{$crudObject}}() []*netproto.{{$crudObject}}                           // lists all {{$crudObject}}s
	Update{{$crudObject}}({{lower $crudObject}}Obj *netproto.{{$crudObject}}) error                  // updates an {{$crudObject}}
	Delete{{$crudObject}}({{lower $crudObject}}Obj, ns, name string) error               // deletes an {{$crudObject}}
	GetWatchOptions(cts context.Context, kind string) api.ObjectMeta
}
type {{$crudObject}}OStream struct {
	sync.Mutex
	stream netproto.{{$crudObject}}Api_{{$crudObject}}OperUpdateClient
}


// Watch{{$crudObject}}s runs {{$crudObject}} watcher loop
func (client *NimbusClient) Watch{{$crudObject}}s(ctx context.Context, reactor {{$crudObject}}Reactor) {
	// setup wait group
	client.waitGrp.Add(1)
	defer client.waitGrp.Done()
	client.debugStats.AddInt("Active{{$crudObject}}Watch", 1)

	// make sure rpc client is good
	if client.rpcClient == nil || client.rpcClient.ClientConn == nil || client.rpcClient.ClientConn.GetState() != connectivity.Ready {
		log.Errorf("RPC client is disconnected. Exiting watch")
		return
	}

	// start the watch
	ometa := reactor.GetWatchOptions(ctx, "{{$crudObject}}")
	{{lower $crudObject}}RPCClient := netproto.New{{$crudObject}}ApiClient(client.rpcClient.ClientConn)
	stream, err := {{lower $crudObject}}RPCClient.Watch{{$crudObject}}s(ctx, &ometa)
	if err != nil {
		log.Errorf("Error watching {{$crudObject}}. Err: %v", err)
		return
	}

	// start oper update stream
	opStream, err := {{lower $crudObject}}RPCClient.{{$crudObject}}OperUpdate(ctx)
	if err != nil {
		log.Errorf("Error starting {{$crudObject}} oper updates. Err: %v", err)
		return
	}

	ostream := &{{$crudObject}}OStream{stream : opStream}

	// get a list of objects
	objList, err := {{lower $crudObject}}RPCClient.List{{$crudObject}}s(ctx, &ometa)
	if err != nil {
		st, ok := status.FromError(err)
		if !ok || st.Code() == codes.Unavailable {
			log.Errorf("Error getting {{$crudObject}} list. Err: %v", err)
			return
		}
	} else {
		// perform a diff of the states
		client.diff{{$crudObject}}s(objList, reactor, ostream)
	}



	// start grpc stream recv
	recvCh := make(chan *netproto.{{$crudObject}}Event, evChanLength)
	go client.watch{{$crudObject}}RecvLoop(stream, recvCh)

	// loop till the end
	for {
		evtWork := func(evt *netproto.{{$crudObject}}Event)  {
			client.debugStats.AddInt("{{$crudObject}}WatchEvents", 1)
			log.Infof("Ctrlerif: agent %s got {{$crudObject}} watch event: Type: {%+v} {{$crudObject}}:{%+v}", client.clientName, evt.EventType, evt.{{$crudObject}}.ObjectMeta)
			client.lockObject(evt.{{$crudObject}}.GetObjectKind(), evt.{{$crudObject}}.ObjectMeta)
			go client.process{{$crudObject}}Event(*evt, reactor, ostream)
			//Give it some time to increment waitgrp
			time.Sleep(100 * time.Microsecond)
		}
		//Give priority to evnt work.
		select {
		case evt, ok := <-recvCh:
			if !ok {
				log.Warnf("{{$crudObject}} Watch channel closed. Exisint {{$crudObject}}Watch")
				return
			}
			evtWork(evt)
		// periodic resync (Disabling as we have aggregate watch support)
		/*case <-time.After(resyncInterval):
            //Give priority to evt work
            //Wait for batch interval for inflight work
            time.Sleep(5 * DefaultWatchHoldInterval)
            select {
            case evt, ok := <-recvCh:
                if !ok {
                    log.Warnf("{{$crudObject}} Watch channel closed. Exisint {{$crudObject}}Watch")
                    return
                }
                evtWork(evt)
				continue
            default:
            }
			// get a list of objects
			objList, err := {{lower $crudObject}}RPCClient.List{{$crudObject}}s(ctx, &ometa)
			if err != nil {
				st, ok := status.FromError(err)
				if !ok || st.Code() == codes.Unavailable {
					log.Errorf("Error getting {{$crudObject}} list. Err: %v", err)
					return
				}
			} else {
				client.debugStats.AddInt("{{$crudObject}}WatchResyncs", 1)
				// perform a diff of the states
				client.diff{{$crudObject}}s(objList, reactor, ostream)
			}
			*/
		}
	}
}


// watch{{$crudObject}}RecvLoop receives from stream and write it to a channel
func (client *NimbusClient) watch{{$crudObject}}RecvLoop(stream netproto.{{$crudObject}}Api_Watch{{$crudObject}}sClient, recvch chan<- *netproto.{{$crudObject}}Event) {
	defer close(recvch)
	client.waitGrp.Add(1)
	defer client.waitGrp.Done()

	// loop till the end
	for {
		// receive from stream
		objList, err := stream.Recv()
		if err != nil {
			log.Errorf("Error receiving from watch channel. Exiting {{$crudObject}} watch. Err: %v", err)
			return
		}
		for _, evt := range objList.{{$crudObject}}Events {
			recvch <- evt
		}
	}
}

// diff{{$crudObject}} diffs local state with controller state
// FIXME: this is not handling deletes today
func (client *NimbusClient) diff{{$crudObject}}s(objList *netproto.{{$crudObject}}List, reactor {{$crudObject}}Reactor, ostream *{{$crudObject}}OStream) {
	// build a map of objects
	objmap := make(map[string]*netproto.{{$crudObject}})
	for _, obj := range objList.{{$crudObject}}s {
		key := obj.ObjectMeta.GetKey()
		objmap[key] = obj
	}

	// see if we need to delete any locally found object
	localObjs := reactor.List{{$crudObject}}()
	for _, lobj := range localObjs {
		ctby, ok := lobj.ObjectMeta.Labels["CreatedBy"]
		if ok && ctby == "Venice" {
			key := lobj.ObjectMeta.GetKey()
			if _, ok := objmap[key]; !ok {
				evt := netproto.{{$crudObject}}Event{
					EventType: api.EventType_DeleteEvent,
					{{$crudObject}}:  *lobj,
				}
				log.Infof("diff{{$crudObject}}s(): Deleting object %+v", lobj.ObjectMeta)
				client.lockObject(evt.{{$crudObject}}.GetObjectKind(), evt.{{$crudObject}}.ObjectMeta)
				client.process{{$crudObject}}Event(evt, reactor, ostream)
			}
		} else {
			log.Infof("Not deleting non-venice object %+v", lobj.ObjectMeta)
		}
	}

	// add/update all new objects
	for _, obj := range objList.{{$crudObject}}s {
		evt := netproto.{{$crudObject}}Event{
			EventType: api.EventType_UpdateEvent,
			{{$crudObject}}:       *obj,
		}
		client.lockObject(evt.{{$crudObject}}.GetObjectKind(), evt.{{$crudObject}}.ObjectMeta)
		client.process{{$crudObject}}Event(evt, reactor, ostream)
	}
}

// process{{$crudObject}}Event handles {{$crudObject}} event
func (client *NimbusClient) process{{$crudObject}}Event(evt netproto.{{$crudObject}}Event, reactor {{$crudObject}}Reactor, ostream *{{$crudObject}}OStream) error {
	var err error
	client.waitGrp.Add(1)
	defer client.waitGrp.Done()

	// add venice label to the object
	evt.{{$crudObject}}.ObjectMeta.Labels = make(map[string]string)
	evt.{{$crudObject}}.ObjectMeta.Labels["CreatedBy"] = "Venice"

	// unlock the object once we are done
	defer client.unlockObject(evt.{{$crudObject}}.GetObjectKind(), evt.{{$crudObject}}.ObjectMeta)

	// retry till successful
	for iter := 0; iter < maxOpretry; iter++ {
		switch evt.EventType {
		case api.EventType_CreateEvent:
			fallthrough
		case api.EventType_UpdateEvent:
			_, err = reactor.Find{{$crudObject}}(evt.{{$crudObject}}.ObjectMeta)
			if err != nil {
				// create the {{$crudObject}}
				err = reactor.Create{{$crudObject}}(&evt.{{$crudObject}})
				if err != nil {
					log.Errorf("Error creating the {{$crudObject}} {%+v}. Err: %v", evt.{{$crudObject}}.ObjectMeta, err)
					client.debugStats.AddInt("Create{{$crudObject}}Error", 1)
				} else {
					client.debugStats.AddInt("Create{{$crudObject}}", 1)
				}
			} else {
				// update the {{$crudObject}}
				err = reactor.Update{{$crudObject}}(&evt.{{$crudObject}})
				if err != nil {
					log.Errorf("Error updating the {{$crudObject}} {%+v}. Err: %v", evt.{{$crudObject}}.GetKey(), err)
					client.debugStats.AddInt("Update{{$crudObject}}Error", 1)
				} else {
					client.debugStats.AddInt("Update{{$crudObject}}", 1)
				}
			}

		case api.EventType_DeleteEvent:
			// delete the object
			err = reactor.Delete{{$crudObject}}(evt.{{$crudObject}}.Tenant, evt.{{$crudObject}}.Namespace, evt.{{$crudObject}}.Name)
			if err == state.ErrObjectNotFound { // give idempotency to caller
				log.Debugf("{{$crudObject}} {%+v} not found", evt.{{$crudObject}}.ObjectMeta)
				err = nil
			}
			if err != nil {
				log.Errorf("Error deleting the {{$crudObject}} {%+v}. Err: %v", evt.{{$crudObject}}.ObjectMeta, err)
				client.debugStats.AddInt("Delete{{$crudObject}}Error", 1)
			} else {
				client.debugStats.AddInt("Delete{{$crudObject}}", 1)
			}
		}

		if ostream == nil {
			return err
		}
		// send oper status and return if there is no error
		if err == nil {
			robj := netproto.{{$crudObject}}Event{
				EventType:  evt.EventType,
				{{$crudObject}}: netproto.{{$crudObject}}{
					TypeMeta:   evt.{{$crudObject}}.TypeMeta,
					ObjectMeta: evt.{{$crudObject}}.ObjectMeta,
					Status:     evt.{{$crudObject}}.Status,
				},
			}

			// send oper status
			ostream.Lock()
			modificationTime, _ := types.TimestampProto(time.Now())
			robj.{{$crudObject}}.ObjectMeta.ModTime = api.Timestamp{Timestamp: *modificationTime}
			err := ostream.stream.Send(&robj)
			if err != nil {
				log.Errorf("failed to send {{$crudObject}} oper Status, %s", err)
				client.debugStats.AddInt("{{$crudObject}}OperSendError", 1)
			} else {
				client.debugStats.AddInt("{{$crudObject}}OperSent", 1)
			}
			ostream.Unlock()

			return err
		}

		// else, retry after some time, with backoff
		time.Sleep(time.Second * time.Duration(2 * iter))
	}

	return nil
}

func (client *NimbusClient) process{{$crudObject}}Dynamic(evt api.EventType,
	object *netproto.{{$crudObject}}, reactor {{$crudObject}}Reactor) error {

	{{lower $crudObject}}Evt := netproto.{{$crudObject}}Event{
		EventType: evt,
		{{$crudObject}}:  *object,
	}

	// add venice label to the object
	{{lower $crudObject}}Evt.{{$crudObject}}.ObjectMeta.Labels = make(map[string]string)
	{{lower $crudObject}}Evt.{{$crudObject}}.ObjectMeta.Labels["CreatedBy"] = "Venice"

	client.lockObject({{lower $crudObject}}Evt.{{$crudObject}}.GetObjectKind(), {{lower $crudObject}}Evt.{{$crudObject}}.ObjectMeta)

	err := client.process{{$crudObject}}Event({{lower $crudObject}}Evt, reactor, nil)
	modificationTime, _ := types.TimestampProto(time.Now())
	object.ObjectMeta.ModTime = api.Timestamp{Timestamp: *modificationTime}

	return err
}


       {{end}}
    {{end}}
{{end}}
