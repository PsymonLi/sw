// Code generated by protoc-gen-grpc-pensando DO NOT EDIT.

package nimbus

{{$manifest := (getNimbusManifest "../generated/nimbus/manifest")}}

import (
	"context"
	"errors"
	"io"
	"sync"
	"time"

	"github.com/gogo/protobuf/types"
	"github.com/pensando/sw/api"
	apiintf "github.com/pensando/sw/api/interfaces"
	"github.com/pensando/sw/venice/globals"
	"github.com/pensando/sw/nic/agent/protos/netproto"
	"github.com/pensando/sw/venice/utils/log"
	memdb "github.com/pensando/sw/venice/utils/memdb"
	"github.com/pensando/sw/venice/utils/netutils"
	"github.com/pensando/sw/venice/utils/rpckit"
	"github.com/pensando/sw/venice/utils/tsdb"
	"github.com/pensando/sw/venice/utils/memdb/objReceiver"
)

var (
	// ErrIncorrectObjectType is returned when type deferencing from memdb.Object is of invalid type
	ErrIncorrectObjectType = errors.New("incorrect object type")
)

const (
	// DefaultWatchBatchSize is the max batch size for watch events
	DefaultWatchBatchSize = 100
	// DefaultWatchHoldInterval is the time that the batching logic waits to accumulate events
	DefaultWatchHoldInterval = time.Millisecond * 10

	LatencyMeasurementEnabled = false
)

type EventStatus struct {
	LastObjectMeta *api.ObjectMeta
}

// MbusServer is the message bus server
type MbusServer struct {
	svcName    string              // service name
	grpcServer *rpckit.RPCServer   // gRPC server instance
	listenURL  string              // URL to listen on
	memDB      *memdb.Memdb        // database of all objects
	stats      map[string]tsdb.Obj // nimbus stats
}

// AddObject adds object to mbus
func (ms *MbusServer) AddObject(obj memdb.Object) error {
	ms.Stats(obj.GetObjectKind(), "AddEvent").Inc()
	ms.Stats(obj.GetObjectKind(), "ObjectCount").Inc()

	return ms.memDB.AddObject(obj)
}

func (ms *MbusServer) RegisterKind(kind string) {

	ms.memDB.RegisterKind(kind)
}

// AddObjectWithReferences adds object to mbus with refs
func (ms *MbusServer) AddObjectWithReferences(key string, obj memdb.Object, refs map[string]apiintf.ReferenceObj) error {
	ms.Stats(obj.GetObjectKind(), "AddEvent").Inc()
	ms.Stats(obj.GetObjectKind(), "ObjectCount").Inc()

	return ms.memDB.AddObjectWithReferences(key, obj, refs)
}


// UpdateObject updates an object in mbus
func (ms *MbusServer) UpdateObject(obj memdb.Object) error {
	ms.Stats(obj.GetObjectKind(), "UpdateEvent").Inc()

	return ms.memDB.UpdateObject(obj)
}

// UpdateObjectWithReferences updates an object in mbus
func (ms *MbusServer) UpdateObjectWithReferences(key string, obj memdb.Object,
     refs map[string]apiintf.ReferenceObj) error {
	ms.Stats(obj.GetObjectKind(), "UpdateEvent").Inc()

	return ms.memDB.UpdateObjectWithReferences(key, obj, refs)
}

// FindObject finds the memdb object
func (ms *MbusServer) FindObject(obj memdb.Object) (memdb.Object, error) {
	return ms.memDB.FindObject(obj.GetObjectKind(), obj.GetObjectMeta())
}

// DeleteObject deletes an object from mbus
func (ms *MbusServer) DeleteObject(obj memdb.Object) error {
	ms.Stats(obj.GetObjectKind(), "DeleteEvent").Inc()
	ms.Stats(obj.GetObjectKind(), "ObjectCount").Dec()

	return ms.memDB.DeleteObject(obj)
}

// DeleteObject deletes an object from mbus
func (ms *MbusServer) DeleteObjectWithReferences(key string, obj memdb.Object,
    refs map[string]apiintf.ReferenceObj) error {
	ms.Stats(obj.GetObjectKind(), "DeleteEvent").Inc()
	ms.Stats(obj.GetObjectKind(), "ObjectCount").Dec()
	return ms.memDB.DeleteObjectWithReferences(key, obj, refs)
}

// AddObjectWithReferences adds object to mbus with refs
func (ms *MbusServer) AddPushObject(key string, obj memdb.Object, refs map[string]apiintf.ReferenceObj, receivers []objReceiver.Receiver) (memdb.PushObjectHandle, error) {

	return ms.memDB.AddPushObject(key, obj, refs, receivers)
}

// FindPushObject finds push object
func (ms *MbusServer) FindPushObject(key string, ometa *api.ObjectMeta) (memdb.Object, error) {

	return ms.memDB.FindPushObject(key, ometa)
}

func (ms *MbusServer) AddReceiver(ID string) (objReceiver.Receiver, error) {
	return ms.memDB.AddReceiver(ID)
}

func (ms *MbusServer) DeleteReceiver(recv objReceiver.Receiver) error {
	return ms.memDB.DeleteReceiver(recv)
}

func (ms *MbusServer) FindReceiver(ID string) (objReceiver.Receiver, error) {
	return ms.memDB.FindReceiver(ID)
}

//Exposing watch objects for unit testing
func (ms *MbusServer) WatchObjects(kind string, watcher *memdb.Watcher) error {
	return ms.memDB.WatchObjects(kind, watcher)
}

func (ms *MbusServer) EnableSelectivePushForKind(kind string) error {
	return ms.memDB.EnableSelctivePush(kind)
}

func (ms *MbusServer) DisableSelectivePushForKind(kind string) error {
	return ms.memDB.DisableKindPushFilter(kind)
}


// AddNodeState adds node state to an object
func (ms *MbusServer) AddNodeState(nodeID string, obj memdb.Object) error {
	return ms.memDB.AddNodeState(nodeID, obj)
}

// DelNodeState deletes node state from an object
func (ms *MbusServer) DelNodeState(nodeID string, obj memdb.Object) error {
	return ms.memDB.DelNodeState(nodeID, obj)
}

// Stats returns a counter for stats
func (ms *MbusServer) Stats(kind, cname string) api.Counter {
	var err error
	tsdbObj, ok := ms.stats[kind]
	if !ok {
		keyTags := map[string]string{"node": "venice", "module": ms.svcName, "kind": kind}
		tsdbObj, err = tsdb.NewObj("NimbusStats", keyTags, nil, nil)
		if err != nil {
			log.Fatalf("unable to create tsdb object, keys %+v", keyTags)
			return nil
		}
	}

	return tsdbObj.Counter(cname)
}

// DumpDatabase dumps the entire database as json
func (ms *MbusServer) DumpDatabase() ([]byte, error) {
	return ms.memDB.MarshalJSON()
}

// GetDBWatchers gets DB watchers
func (ms *MbusServer) GetDBWatchers(kind string) (*memdb.DBWatchers, error) {
	return ms.memDB.GetDBWatchers(kind)
}

// NewMbusServer creates a new instance of message bus server
func NewMbusServer(svcName string, grpcServer *rpckit.RPCServer) *MbusServer {
	mbusServer := MbusServer{
		svcName: svcName,
		memDB:   memdb.NewMemdb(),
		stats:   make(map[string]tsdb.Obj),
		grpcServer: grpcServer,
	}
	return &mbusServer
}

//Does not implement, will dynamically validate when watch is called
type AggStatusReactor interface {
}

//Each kind status
type KindStatus struct {
	kind          string
	opSentStatus  map[api.EventType]*EventStatus
	opAckedStatus map[api.EventType]*EventStatus
}

//Map of kind and its status
type NodeKindStatus struct {
	kindStatus map[string]*KindStatus
	//same watcher for all
	watcher *memdb.Watcher
}

//Map of node and its kind status
type NodesStatus struct {
	nodesStatus map[string]*NodeKindStatus
}

// AggregateTopic is the Aggregate topic on message bus
type AggregateTopic struct {
	sync.Mutex
	grpcServer    *rpckit.RPCServer // gRPC server instance
	server        *MbusServer
	statusReactor AggStatusReactor // status event reactor
	aggStatus     map[string]*NodesStatus
}

// AddAggregateTopic returns a network RPC server
func AddAggregateTopic(server *MbusServer, reactor AggStatusReactor) (*AggregateTopic, error) {
	// RPC handler instance
	handler := AggregateTopic{
		grpcServer:    server.grpcServer,
		server:        server,
		statusReactor: reactor,
		aggStatus:    make(map[string]*NodesStatus),
	}

	// register the RPC handlers
	if server.grpcServer != nil {
		netproto.RegisterAggWatchApiV1Server(server.grpcServer.GrpcServer, &handler)
	}

	return &handler, nil
}

func (eh *AggregateTopic) ListObjects(ctx context.Context, kinds *api.AggWatchOptions) (*netproto.AggObjectList, error) {
	nodeID := netutils.GetNodeUUIDFromCtx(ctx)
	filters := []memdb.FilterFn{}

	kindStrings := []string{}
	for _, aggKind := range kinds.WatchOptions {
		kindStrings = append(kindStrings, aggKind.Kind)
	}
	aggKey := strings.Join(kindStrings, "-")

	objList := &netproto.AggObjectList{}
	// walk all associated kinds objects
	for _, kind := range kinds.WatchOptions {

		addAggObjectEvent := func(mobj *types.Any, meta *api.ObjectMeta) {
			aggObj := &netproto.AggObject{Kind: kind.Kind, Object: &api.Any{}}
			aggObj.Object.Any = *mobj
			eh.updateSentObjStatus(aggKey, nodeID, kind.Kind, api.EventType_UpdateEvent, meta)
			objList.Objects = append(objList.Objects, aggObj)
		}

		switch kind.Kind {
		{{range $key, $value := $manifest}}
			case "{{$value.Object}}":

				if _, ok := eh.statusReactor.({{$value.Object}}StatusReactor); ok {
					filters = eh.statusReactor.({{$value.Object}}StatusReactor).GetWatchFilter(kind.Group+"."+kind.Kind, &kind.Options)
				} 
				
				objlist, err := eh.server.List{{$value.Object}}s(context.Background(), nodeID, filters)
				if err != nil {
					log.Errorf("Error getting a list of objects. Err: %v", err)
					return nil, err
				}
				for _, obj := range objlist {
					mobj, err := types.MarshalAny(obj)
					if err != nil {
						log.Errorf("Error  marshalling any object. Err: %v", err)
						return nil, err
					}
					addAggObjectEvent(mobj, obj.GetObjectMeta())
				}

			{{end}}
		}
	}

	return objList, nil
}

func (eh *AggregateTopic) ObjectOperUpdate(stream netproto.AggWatchApiV1_ObjectOperUpdateServer) error {
	ctx := stream.Context()
	nodeID := netutils.GetNodeUUIDFromCtx(ctx)

	if eh.statusReactor == nil {
		return nil
	}

	for {
		oper, err := stream.Recv()
		if err == io.EOF {
			log.Errorf("%v AppOperUpdate stream ended. closing..", nodeID)
			return stream.SendAndClose(&api.TypeMeta{})
		} else if err != nil {
			log.Errorf("Error receiving from %v AppOperUpdate stream. Err: %v", nodeID, err)
			return err
		}

		object, err := GetObject(&oper.AggObj)
		if err != nil {
			log.Errorf("Invalid object for get %v", err)
			return err
		}

		switch oper.EventType {
		case api.EventType_CreateEvent:
			fallthrough
		case api.EventType_UpdateEvent:
			switch oper.AggObj.Kind {
			{{range $key, $value := $manifest}}
			case "{{$value.Object}}":
				if _, ok := eh.statusReactor.({{$value.Object}}StatusReactor); ok {
					err = eh.statusReactor.({{$value.Object}}StatusReactor).On{{$value.Object}}OperUpdate(nodeID,
						object.Message.(*netproto.{{$value.Object}}))
					if err != nil {
						log.Errorf("Error updating {{$value.Object}} oper state. Err: %v", err)
					}
				}
				eh.updateAckedObjStatus(nodeID, oper.AggObj.Kind, oper.EventType, object.Message.(*netproto.{{$value.Object}}).GetObjectMeta())
			{{end}}
			}
		case api.EventType_DeleteEvent:
			switch oper.AggObj.Kind {
			{{range $key, $value := $manifest}}
			case "{{$value.Object}}":
				if _, ok := eh.statusReactor.({{$value.Object}}StatusReactor); ok {
					err = eh.statusReactor.({{$value.Object}}StatusReactor).On{{$value.Object}}OperDelete(nodeID,
						object.Message.(*netproto.{{$value.Object}}))
					if err != nil {
						log.Errorf("Error updating {{$value.Object}} oper state. Err: %v", err)
					}
				}
				eh.updateAckedObjStatus(nodeID, oper.AggObj.Kind, oper.EventType, object.Message.(*netproto.{{$value.Object}}).GetObjectMeta())
			{{end}}
			}
		}

	}
}

func (eh *AggregateTopic) registerAggWatcher(aggkey, nodeID string, kinds []string, watcher *memdb.Watcher) {
	eh.Lock()
	defer eh.Unlock()

	if _, ok := eh.aggStatus[aggkey]; !ok {
		eh.aggStatus[aggkey] = &NodesStatus{nodesStatus: make(map[string]*NodeKindStatus)}
	}

	eh.aggStatus[aggkey].nodesStatus[nodeID] = &NodeKindStatus{watcher: watcher,
		kindStatus: make(map[string]*KindStatus)}
	for _, kind := range kinds {
		eh.aggStatus[aggkey].nodesStatus[nodeID].kindStatus[kind] =
			&KindStatus{kind: kind, opAckedStatus: make(map[api.EventType]*EventStatus),
				opSentStatus: make(map[api.EventType]*EventStatus)}
	}
}

func (eh *AggregateTopic) unRegisterAggWatcher(aggKey, nodeID string) {
	eh.Lock()
	defer eh.Unlock()

	if _, ok := eh.aggStatus[aggKey]; ok {
		delete(eh.aggStatus[aggKey].nodesStatus, nodeID)
	}

	if len(eh.aggStatus) == 0 {
		delete(eh.aggStatus, aggKey)
	}
}

//update recv object status
func (eh *AggregateTopic) updateSentObjStatus(aggKey, nodeID, kind string, event api.EventType, objMeta *api.ObjectMeta) {

	eh.Lock()
	defer eh.Unlock()
	var evStatus *EventStatus

	if _, ok := eh.aggStatus[aggKey]; !ok {
		//Watcher already unregistered.
		return
	}

	nodeStatus, ok := eh.aggStatus[aggKey].nodesStatus[nodeID]
	if !ok {
		//Watcher already unregistered.
		return
	}

	kindStatus, ok := nodeStatus.kindStatus[kind]
	if !ok {
		nodeStatus.kindStatus[kind] = &KindStatus{}
		kindStatus = nodeStatus.kindStatus[kind]
	}

	evStatus, ok = kindStatus.opSentStatus[event]
	if !ok {
		kindStatus.opSentStatus[event] = &EventStatus{}
		evStatus = kindStatus.opSentStatus[event]
	}

	new, _ := strconv.Atoi(objMeta.ResourceVersion)
	//for create/delete keep track of last one sent to, this may not be full proof
	//  Create could be processed asynchoronusly by client and can come out of order.
	//  For now should be ok as at least we make sure all messages are processed.
	//For update keep track of only last one as nimbus client periodically pulls
	if evStatus.LastObjectMeta != nil {
		current, _ := strconv.Atoi(evStatus.LastObjectMeta.ResourceVersion)
		if current > new {
			return
		}
	}
	evStatus.LastObjectMeta = objMeta
}

//update recv object status
func (eh *AggregateTopic) updateAckedObjStatus(nodeID, kind string, event api.EventType, objMeta *api.ObjectMeta) {

	eh.Lock()
	defer eh.Unlock()
	var evStatus *EventStatus

	for _, nodesStatus := range eh.aggStatus {
		nodeStatus, ok := nodesStatus.nodesStatus[nodeID]
		if !ok {
			//Watcher already unregistered.
			continue
		}

		kindStatus, ok := nodeStatus.kindStatus[kind]
		if !ok {
			//This watch not interested in this kind
			continue
		}

		evStatus, ok = kindStatus.opAckedStatus[event]
		if !ok {
			kindStatus.opAckedStatus[event] = &EventStatus{}
			evStatus = kindStatus.opAckedStatus[event]
		}

		new, _ := strconv.Atoi(objMeta.ResourceVersion)
		//for create/delete keep track of last one sent to, this may not be full proof
		//  Create could be processed asynchoronusly by client and can come out of order.
		//  For now should be ok as at least we make sure all messages are processed.
		//For update keep track of only last one as nimbus client periodically pulls
		if evStatus.LastObjectMeta != nil {
			current, _ := strconv.Atoi(evStatus.LastObjectMeta.ResourceVersion)
			if current > new {
				return
			}
		}
		evStatus.LastObjectMeta = objMeta
	}

}


//update recv object status
func (eh *AggregateTopic) WatcherInConfigSync(nodeID string, kind string, event api.EventType) bool {

	var ok bool
	var evStatus *EventStatus
	var evAckStatus *EventStatus

	eh.Lock()
	defer eh.Unlock()

	var nodeStatus *NodeKindStatus
	for aggKey, nodesStatus := range eh.aggStatus {
		if strings.Contains(aggKey, kind) {
			nodeStatus, ok = nodesStatus.nodesStatus[nodeID]
			if !ok {
				return true
			}
			break
		}
	}


	//This node already unregistered
	if nodeStatus == nil {
		return true
	}

	kindStatus, ok := nodeStatus.kindStatus[kind]
	if !ok {
		//nothing sent, so insync
		return true
	}

	//In-flight object still exists
	if len(nodeStatus.watcher.Channel) != 0 {
		log.Infof("watcher %v still has objects in in-flight %v(%v)", nodeID, "App", event)
		return false
	}

	evStatus, ok = kindStatus.opSentStatus[event]
	if !ok {
		return true
	}

	evAckStatus, ok = kindStatus.opAckedStatus[event]
	if !ok {
		//nothing received, failed.
		return false
	}

	if evAckStatus.LastObjectMeta.ResourceVersion != evStatus.LastObjectMeta.ResourceVersion {
		log.Infof("watcher %v resource version mismatch for %v(%v)  sent %v: recived %v",
			nodeID, kind, event, evStatus.LastObjectMeta.ResourceVersion,
			evAckStatus.LastObjectMeta.ResourceVersion)
		return false
	}

	return true
}

// WatchObjects watches aggregate  and sends streaming resp
func (eh *AggregateTopic) WatchObjects(kinds *api.AggWatchOptions, stream netproto.AggWatchApiV1_WatchObjectsServer) error {
	ctx := stream.Context()
	nodeID := netutils.GetNodeUUIDFromCtx(ctx)
	watcher := memdb.Watcher{}
	watcher.Name = nodeID
	watcher.Channel = make(chan memdb.Event, memdb.WatchLen)
	watcher.Filters = make(map[string][]memdb.FilterFn)
	defer close(watcher.Channel)

	kindStrings := []string{}
	for _, kind := range kinds.WatchOptions {
		kindStrings = append(kindStrings, kind.Kind)
		switch kind.Kind {
		{{range $key, $value := $manifest}}
		case "{{$value.Object}}":
			if _, ok := eh.statusReactor.({{$value.Object}}StatusReactor); ok {
				watcher.Filters[kind.Kind] = eh.statusReactor.({{$value.Object}}StatusReactor).GetWatchFilter(kind.Group+"."+kind.Kind, &kind.Options)
			} else {
				filt := func(obj, prev memdb.Object) bool {
					return true
				}
				watcher.Filters[kind.Kind] = append(watcher.Filters[kind.Kind], filt)
			}
		{{end}}
		}
	}

	aggKey := strings.Join(kindStrings, "-")
	eh.registerAggWatcher(aggKey, nodeID, kindStrings, &watcher)
	defer eh.unRegisterAggWatcher(aggKey, nodeID)
	for _, kind := range kindStrings {
		err := eh.server.memDB.WatchObjects(kind, &watcher)
		if err != nil {
			log.Errorf("Error Starting watch for kind %v Err: %v", kind, err)
			return err
		}
		defer eh.server.memDB.StopWatchObjects(kind, &watcher)

		watchEvts := netproto.AggObjectEventList{}
		addAggObjectEvent := func(mobj *types.Any, meta *api.ObjectMeta) {
			watchEvt := netproto.AggObjectEvent{
				EventType: api.EventType_CreateEvent,
				AggObj:    netproto.AggObject{Kind: kind, Object: &api.Any{}},
			}

			watchEvt.AggObj.Object.Any = *mobj
			watchEvts.AggObjectEvents = append(watchEvts.AggObjectEvents, &watchEvt)
			eh.updateSentObjStatus(aggKey, nodeID, kind, watchEvt.EventType, meta)
		}
		switch kind {
		{{range $key, $value := $manifest}}
		case "{{$value.Object}}":
			objlist, err := eh.server.List{{$value.Object}}s(context.Background(), nodeID, watcher.Filters[kind])
			if err != nil {
				log.Errorf("Error getting a list of objects. Err: %v", err)
				return err
			}
			for _, obj := range objlist {
				mobj, err := types.MarshalAny(obj)
				if err != nil {
					log.Errorf("Error  marshalling any object. Err: %v", err)
					return err
				}
				addAggObjectEvent(mobj,obj.GetObjectMeta())
			}
		{{end}}
		}

		// walk all objects and send it out

		if len(watchEvts.AggObjectEvents) > 0 {
			err := stream.Send(&watchEvts)
			if err != nil {
				log.Errorf("Error sending Aggregate to stream. Err: %v", err)
				return err
			}
		}
	}

	timer := time.NewTimer(DefaultWatchHoldInterval)
	if !timer.Stop() {
		<-timer.C
	}

	running := false
	watchEvts := netproto.AggObjectEventList{}
	sendToStream := func() error {
		err := stream.Send(&watchEvts)
		if err != nil {
			log.Errorf("Error sending Agg to stream. Err: %v", err)
			return err
		}
		watchEvts = netproto.AggObjectEventList{}
		return nil
	}

	// loop forever on watch channel
	for {
		select {
		// read from channel
		case evt, ok := <-watcher.Channel:
			if !ok {
				log.Errorf("Error reading from channel. Closing watch")
				return errors.New("Error reading from channel")
			}

			// convert the events
			var etype api.EventType
			switch evt.EventType {
			case memdb.CreateEvent:
				etype = api.EventType_CreateEvent
			case memdb.UpdateEvent:
				etype = api.EventType_UpdateEvent
			case memdb.DeleteEvent:
				etype = api.EventType_DeleteEvent
			}

			// get the object
			kind := evt.Obj.GetObjectKind()
			watchEvt := netproto.AggObjectEvent{
				EventType: etype,
				AggObj:    netproto.AggObject{Kind: kind, Object: &api.Any{}},
			}
			var mobj *types.Any
			switch kind {
			{{range $key, $value := $manifest}}
			case "{{$value.Object}}":
				obj, err := {{$value.Object}}FromObj(evt.Obj)
				if err != nil {
					return err
				}
				mobj, err = types.MarshalAny(obj)
				if err != nil {
					log.Errorf("Error  marshalling any object. Err: %v", err)
					return err
				}
			{{end}}
			}
			watchEvt.AggObj.Object.Any = *mobj
			watchEvts.AggObjectEvents = append(watchEvts.AggObjectEvents, &watchEvt)

			// convert to netproto format
			if !running {
				running = true
				timer.Reset(DefaultWatchHoldInterval)
			}
			if len(watchEvts.AggObjectEvents) >= DefaultWatchBatchSize {
				if err := sendToStream(); err != nil {
					return err
				}
				if !timer.Stop() {
					<-timer.C
				}
				timer.Reset(DefaultWatchHoldInterval)
			}
			eh.updateSentObjStatus(aggKey, nodeID, kind, etype, evt.Obj.GetObjectMeta())
		case <-timer.C:
			running = false
			if err := sendToStream(); err != nil {
				return err
			}
		case <-ctx.Done():
			return ctx.Err()
		}
	}
}
