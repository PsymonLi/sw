// Code generated by protoc-gen-grpc-pensando DO NOT EDIT.

/*
Package nimbus is a auto generated package.
Input file: {{.Name}}
*/

package nimbus

import (
	"context"
	"errors"

	"github.com/pensando/sw/api"
	"github.com/pensando/sw/nic/agent/protos/netproto"
	"github.com/pensando/sw/venice/globals"
	"github.com/pensando/sw/venice/utils/log"
	"github.com/pensando/sw/venice/utils/memdb"
	"github.com/pensando/sw/venice/utils/rpckit"
)

{{range .Services}}
    {{$svcname := .Name}}
    {{if (hasExtension "venice.naplesRestService" .)}}
       {{$params := (getRestSvcOptions .)}}
       {{range $params}}
            {{$crudObject := .CrudObject}}

// Find{{$crudObject}} finds an {{$crudObject}} by object meta
func (ms *MbusServer) Find{{$crudObject}}(objmeta *api.ObjectMeta) (*netproto.{{$crudObject}}, error) {
	// find the object
	obj, err := ms.memDB.FindObject("{{$crudObject}}", objmeta)
	if err != nil {
		return nil, err
	}

	return {{$crudObject}}FromObj(obj)
}

// List{{$crudObject}}s lists all {{$crudObject}}s in the mbus
func (ms *MbusServer) List{{$crudObject}}s(ctx context.Context) ([]*netproto.{{$crudObject}}, error) {
	var objlist []*netproto.{{$crudObject}}

	// walk all objects
	objs := ms.memDB.ListObjects("{{$crudObject}}")
	for _, oo := range objs {
		obj, err := {{$crudObject}}FromObj(oo)
		if err == nil {
			objlist = append(objlist, obj)
		}
	}

	return objlist, nil
}

// {{$crudObject}}StatusReactor is the reactor interface implemented by controllers
type {{$crudObject}}StatusReactor interface {
	On{{$crudObject}}CreateReq(nodeID string, objinfo *netproto.{{$crudObject}}) error
	On{{$crudObject}}UpdateReq(nodeID string, objinfo *netproto.{{$crudObject}}) error
	On{{$crudObject}}DeleteReq(nodeID string, objinfo *netproto.{{$crudObject}}) error
	On{{$crudObject}}OperUpdate(nodeID string, objinfo *netproto.{{$crudObject}}) error
	On{{$crudObject}}OperDelete(nodeID string, objinfo *netproto.{{$crudObject}}) error
	GetWatchFilter(kind string, ometa *api.ObjectMeta) func(api.EventType, memdb.Object) bool
}

// {{$crudObject}}Topic is the {{$crudObject}} topic on message bus
type {{$crudObject}}Topic struct {
	grpcServer    *rpckit.RPCServer // gRPC server instance
	server        *MbusServer
	statusReactor {{$crudObject}}StatusReactor // status event reactor
}

// Add{{$crudObject}}Topic returns a network RPC server
func Add{{$crudObject}}Topic(server *MbusServer, reactor {{$crudObject}}StatusReactor) (*{{$crudObject}}Topic, error) {
	// RPC handler instance
	handler := {{$crudObject}}Topic{
		grpcServer: server.grpcServer,
		server:     server,
		statusReactor: reactor,
	}

	// register the RPC handlers
	if server.grpcServer != nil {
		netproto.Register{{$svcname}}Server(server.grpcServer.GrpcServer, &handler)
	}
	
	return &handler, nil
}

// Create{{$crudObject}} creates {{$crudObject}}
func (eh *{{$crudObject}}Topic) Create{{$crudObject}}(ctx context.Context, objinfo *netproto.{{$crudObject}}) (*netproto.{{$crudObject}}, error) {
	nodeID := netutils.GetNodeUUIDFromCtx(ctx)
	log.Infof("Received Create{{$crudObject}} from node %v: {%+v}", nodeID, objinfo)

	// trigger callbacks. we allow creates to happen before it exists in memdb
	if eh.statusReactor != nil {
		eh.statusReactor.On{{$crudObject}}CreateReq(nodeID, objinfo)
	}

	// increment stats
	eh.server.Stats("{{$crudObject}}", "AgentCreate").Inc()

	return objinfo, nil
}

// Update{{$crudObject}} updates {{$crudObject}}
func (eh *{{$crudObject}}Topic) Update{{$crudObject}}(ctx context.Context, objinfo *netproto.{{$crudObject}}) (*netproto.{{$crudObject}}, error) {
	nodeID := netutils.GetNodeUUIDFromCtx(ctx)
	log.Infof("Received Update{{$crudObject}} from node %v: {%+v}", nodeID, objinfo)

	// incr stats
	eh.server.Stats("{{$crudObject}}", "AgentUpdate").Inc()

	// trigger callbacks
	if eh.statusReactor != nil {
		eh.statusReactor.On{{$crudObject}}UpdateReq(nodeID, objinfo)
	}

	return objinfo, nil
}

// Delete{{$crudObject}} deletes an {{$crudObject}}
func (eh *{{$crudObject}}Topic) Delete{{$crudObject}}(ctx context.Context, objinfo *netproto.{{$crudObject}}) (*netproto.{{$crudObject}}, error) {
	nodeID := netutils.GetNodeUUIDFromCtx(ctx)
	log.Infof("Received Delete{{$crudObject}} from node %v: {%+v}", nodeID, objinfo)

	// incr stats
	eh.server.Stats("{{$crudObject}}", "AgentDelete").Inc()

	// trigger callbacks
	if eh.statusReactor != nil {
		eh.statusReactor.On{{$crudObject}}DeleteReq(nodeID, objinfo)
	}

	return objinfo, nil
}

// {{$crudObject}}FromObj converts memdb object to {{$crudObject}}
func {{$crudObject}}FromObj(obj memdb.Object) (*netproto.{{$crudObject}}, error) {
	switch obj.(type) {
	case *netproto.{{$crudObject}}:
		eobj := obj.(*netproto.{{$crudObject}})
		return eobj, nil
	default:
		return nil, ErrIncorrectObjectType
	}
}

// Get{{$crudObject}} returns a specific {{$crudObject}}
func (eh *{{$crudObject}}Topic) Get{{$crudObject}}(ctx context.Context, objmeta *api.ObjectMeta) (*netproto.{{$crudObject}}, error) {
	// find the object
	obj, err := eh.server.memDB.FindObject("{{$crudObject}}", objmeta)
	if err != nil {
		return nil, err
	}

	return {{$crudObject}}FromObj(obj)
}

// List{{$crudObject}}s lists all {{$crudObject}}s matching object selector
func (eh *{{$crudObject}}Topic) List{{$crudObject}}s(ctx context.Context, objsel *api.ObjectMeta) (*netproto.{{$crudObject}}List, error) {
	var objlist netproto.{{$crudObject}}List

	// walk all objects
	objs := eh.server.memDB.ListObjects("{{$crudObject}}")
	for _, oo := range objs {
		obj, err := {{$crudObject}}FromObj(oo)
		if err == nil {
			objlist.{{$crudObject}}s = append(objlist.{{$crudObject}}s, obj)
		}
	}

	return &objlist, nil
}

// Watch{{$crudObject}}s watches {{$crudObject}}s and sends streaming resp
func (eh *{{$crudObject}}Topic) Watch{{$crudObject}}s(ometa *api.ObjectMeta, stream netproto.{{$svcname}}_Watch{{$crudObject}}sServer) error {
	// watch for changes
	watchChan := make(chan memdb.Event, memdb.WatchLen)
	defer close(watchChan)
	eh.server.memDB.WatchObjects("{{$crudObject}}", watchChan)
	defer eh.server.memDB.StopWatchObjects("{{$crudObject}}", watchChan)

     filterFn := func(api.EventType, memdb.Object) bool {
		return true
	}
	if  eh.statusReactor != nil {
		filterFn = eh.statusReactor.GetWatchFilter("{{$crudObject}}", ometa)
	}
	// get a list of all {{$crudObject}}s
	objlist, err := eh.List{{$crudObject}}s(context.Background(), ometa)
	if err != nil {
		log.Errorf("Error getting a list of objects. Err: %v", err)
		return err
	}

	// increment stats
	eh.server.Stats("{{$crudObject}}", "ActiveWatch").Inc()
	eh.server.Stats("{{$crudObject}}", "WatchConnect").Inc()
	defer eh.server.Stats("{{$crudObject}}", "ActiveWatch").Dec()
	defer eh.server.Stats("{{$crudObject}}", "WatchDisconnect").Inc()

	ctx := stream.Context()

	// walk all {{$crudObject}}s and send it out
	for _, obj := range objlist.{{$crudObject}}s {
		watchEvt := netproto.{{$crudObject}}Event{
			EventType: api.EventType_CreateEvent,
			{{$crudObject}}:  *obj,
		}
		if filterFn(api.EventType_CreateEvent, obj) {
			err = stream.Send(&watchEvt)
			if err != nil {
				log.Errorf("Error sending {{$crudObject}} to stream. Err: %v", err)
				return err
			}
		} else {
			log.Infof("Endpoint [%v] filtered from sending", obj)
		}
	}

	// loop forever on watch channel
	for {
		select {
		// read from channel
		case evt, ok := <-watchChan:
			if !ok {
				log.Errorf("Error reading from channel. Closing watch")
				return errors.New("Error reading from channel")
			}

			// convert the events
			var etype api.EventType
			switch evt.EventType {
			case memdb.CreateEvent:
				etype = api.EventType_CreateEvent
			case memdb.UpdateEvent:
				etype = api.EventType_UpdateEvent
			case memdb.DeleteEvent:
				etype = api.EventType_DeleteEvent
			}

			// get the object
			obj, err := {{$crudObject}}FromObj(evt.Obj)
			if err != nil {
				return err
			}

			// convert to netproto format
			watchEvt := netproto.{{$crudObject}}Event{
				EventType: etype,
				{{$crudObject}}:  *obj,
			}
            if filterFn(etype, obj) {
				// streaming send
				err = stream.Send(&watchEvt)
				if err != nil {
					log.Errorf("Error sending {{$crudObject}} to stream. Err: %v", err)
					return err
				}
			} else {
				log.Infof("Endpoint [%v] filtered from sending", obj)
			}
		case <-ctx.Done():
			return ctx.Err()
		}
	}

	// done
}


// update{{$crudObject}}Oper triggers oper update callbacks
func (eh *{{$crudObject}}Topic) update{{$crudObject}}Oper(oper *netproto.{{$crudObject}}Event, nodeID string) error {
	switch oper.EventType {
	case api.EventType_CreateEvent:
		fallthrough 
	case api.EventType_UpdateEvent:
		// incr stats
		eh.server.Stats("{{$crudObject}}", "AgentUpdate").Inc()

		// trigger callbacks
		if eh.statusReactor != nil {
			return eh.statusReactor.On{{$crudObject}}OperUpdate(nodeID, &oper.{{$crudObject}})
		}
	case api.EventType_DeleteEvent:
		// incr stats
		eh.server.Stats("{{$crudObject}}", "AgentDelete").Inc()

		// trigger callbacks
		if eh.statusReactor != nil {
			eh.statusReactor.On{{$crudObject}}OperDelete(nodeID, &oper.{{$crudObject}})
		}
	}

	return nil
}

func (eh *{{$crudObject}}Topic) {{$crudObject}}OperUpdate(stream netproto.{{$crudObject}}Api_{{$crudObject}}OperUpdateServer) error {
	ctx := stream.Context()
	nodeID := netutils.GetNodeUUIDFromCtx(ctx)

	for {
		oper, err := stream.Recv()
		if err == io.EOF {
			log.Errorf("{{$crudObject}}OperUpdate stream ended. closing..")
			return stream.SendAndClose(&api.TypeMeta{})
		} else if err != nil {
			log.Errorf("Error receiving from {{$crudObject}}OperUpdate stream. Err: %v", err)
			return err
		}

		err = eh.update{{$crudObject}}Oper(oper, nodeID)
		if err != nil {
			log.Errorf("Error updating {{$crudObject}} oper state. Err: %v", err)
		}
	}
}

       {{end}}       
    {{end}}
{{end}}
