// Code generated by protoc-gen-grpc-pensando DO NOT EDIT.

/*
Package nimbus is a auto generated package.
Input file: {{.Name}}
*/

package nimbus

import (
    "context"
    "errors"
    "strconv"
    "time"

    "github.com/pensando/sw/api"
	"github.com/gogo/protobuf/types"
    "github.com/pensando/sw/nic/agent/protos/netproto"
	hdr "github.com/pensando/sw/venice/utils/histogram"
    "github.com/pensando/sw/venice/globals"
    "github.com/pensando/sw/venice/utils/log"
    memdb "github.com/pensando/sw/venice/utils/memdb"
    "github.com/pensando/sw/venice/utils/rpckit"
)

{{range .Services}}
    {{$svcname := .Name}}
    {{if (hasExtension "venice.naplesRestService" .)}}
       {{$params := (getRestSvcOptions .)}}
       {{range $params}}
            {{$crudObject := .CrudObject}}
            {{$version := .Version}}

// Find{{$crudObject}} finds an {{$crudObject}} by object meta
func (ms *MbusServer) Find{{$crudObject}}(objmeta *api.ObjectMeta) (*netproto.{{$crudObject}}, error) {
    // find the object
    obj, err := ms.memDB.FindObject("{{$crudObject}}", objmeta)
    if err != nil {
        return nil, err
    }

    return {{$crudObject}}FromObj(obj)
}

// List{{$crudObject}}s lists all {{$crudObject}}s in the mbus
func (ms *MbusServer) List{{$crudObject}}s(ctx context.Context, nodeID string, filters []memdb.FilterFn) ([]*netproto.{{$crudObject}}, error) {
    var objlist []*netproto.{{$crudObject}}

    // walk all objects
    objs := ms.memDB.ListObjectsForReceiver("{{$crudObject}}", nodeID, filters)
    for _, oo := range objs {
        obj, err := {{$crudObject}}FromObj(oo)
        if err == nil {
            objlist = append(objlist, obj)
        }
    }

    return objlist, nil
}

// List{{$crudObject}}sNoFilter lists all {{$crudObject}}s in the mbus without applying a watch filter
func (ms *MbusServer) List{{$crudObject}}sNoFilter(ctx context.Context) ([]*netproto.{{$crudObject}}, error) {
    var objlist []*netproto.{{$crudObject}}

    // walk all objects
    objs := ms.memDB.ListObjects("{{$crudObject}}", nil)
    for _, oo := range objs {
        obj, err := {{$crudObject}}FromObj(oo)
        if err == nil {
            objlist = append(objlist, obj)
        }
    }

    return objlist, nil
}

// {{$crudObject}}StatusReactor is the reactor interface implemented by controllers
type {{$crudObject}}StatusReactor interface {
    On{{$crudObject}}CreateReq(nodeID string, objinfo *netproto.{{$crudObject}}) error
    On{{$crudObject}}UpdateReq(nodeID string, objinfo *netproto.{{$crudObject}}) error
    On{{$crudObject}}DeleteReq(nodeID string, objinfo *netproto.{{$crudObject}}) error
    On{{$crudObject}}OperUpdate(nodeID string, objinfo *netproto.{{$crudObject}}) error
    On{{$crudObject}}OperDelete(nodeID string, objinfo *netproto.{{$crudObject}}) error
    GetAgentWatchFilter(ctx context.Context, kind string, watchOptions *api.ListWatchOptions) []memdb.FilterFn
}

type {{$crudObject}}NodeStatus struct {
    nodeID        string
    watcher       *memdb.Watcher
    opSentStatus  map[api.EventType]*EventStatus
    opAckedStatus map[api.EventType]*EventStatus
}

// {{$crudObject}}Topic is the {{$crudObject}} topic on message bus
type {{$crudObject}}Topic struct {
    sync.Mutex
    grpcServer      *rpckit.RPCServer // gRPC server instance
    server          *MbusServer
    statusReactor   {{$crudObject}}StatusReactor // status event reactor
    nodeStatus       map[string]*{{$crudObject}}NodeStatus
}

// Add{{$crudObject}}Topic returns a network RPC server
func Add{{$crudObject}}Topic(server *MbusServer, reactor {{$crudObject}}StatusReactor) (*{{$crudObject}}Topic, error) {
    // RPC handler instance
    handler := {{$crudObject}}Topic{
        grpcServer: server.grpcServer,
        server:     server,
        statusReactor: reactor,
        nodeStatus: make(map[string]*{{$crudObject}}NodeStatus),
    }

    // register the RPC handlers
    if server.grpcServer != nil {
        netproto.Register{{$svcname}}Server(server.grpcServer.GrpcServer, &handler)
    }

    return &handler, nil
}

func (eh *{{$crudObject}}Topic) registerWatcher(nodeID string, watcher *memdb.Watcher) {
    eh.Lock()
    defer eh.Unlock()

    eh.nodeStatus[nodeID] = &{{$crudObject}}NodeStatus{nodeID: nodeID, watcher: watcher}
    eh.nodeStatus[nodeID].opSentStatus = make(map[api.EventType]*EventStatus)
    eh.nodeStatus[nodeID].opAckedStatus = make(map[api.EventType]*EventStatus)
}

func (eh *{{$crudObject}}Topic) unRegisterWatcher(nodeID string) {
    eh.Lock()
    defer eh.Unlock()

    delete(eh.nodeStatus, nodeID)
}

//update recv object status
func (eh *{{$crudObject}}Topic) updateAckedObjStatus(nodeID string, event api.EventType, objMeta *api.ObjectMeta) {

    eh.Lock()
    defer eh.Unlock()
    var evStatus *EventStatus

    nodeStatus, ok := eh.nodeStatus[nodeID]
    if !ok {
        //Watcher already unregistered.
        return
    }

    evStatus, ok = nodeStatus.opAckedStatus[event]
    if !ok {
        nodeStatus.opAckedStatus[event] = &EventStatus{}
        evStatus = nodeStatus.opAckedStatus[event]
    }

    if LatencyMeasurementEnabled {
	    rcvdTime, _ := objMeta.ModTime.Time()
    	sendTime, _ := objMeta.CreationTime.Time()
    	delta := rcvdTime.Sub(sendTime)

    	hdr.Record(nodeID+ "_" + "{{$crudObject}}", delta)
    	hdr.Record("{{$crudObject}}", delta)
    	hdr.Record(nodeID, delta)
    }

    new, _  := strconv.Atoi(objMeta.ResourceVersion)
    //for create/delete keep track of last one sent to, this may not be full proof
    //  Create could be processed asynchoronusly by client and can come out of order.
    //  For now should be ok as at least we make sure all messages are processed.
    //For update keep track of only last one as nimbus client periodically pulls
    if evStatus.LastObjectMeta != nil {
        current, _  := strconv.Atoi(evStatus.LastObjectMeta.ResourceVersion)
        if current > new {
            return
        }
    }
    evStatus.LastObjectMeta = objMeta
}

//update recv object status
func (eh *{{$crudObject}}Topic) updateSentObjStatus(nodeID string, event api.EventType, objMeta *api.ObjectMeta) {

    eh.Lock()
    defer eh.Unlock()
    var evStatus *EventStatus

    nodeStatus, ok := eh.nodeStatus[nodeID]
    if !ok {
        //Watcher already unregistered.
        return
    }

    evStatus, ok = nodeStatus.opSentStatus[event]
    if !ok {
        nodeStatus.opSentStatus[event] = &EventStatus{}
        evStatus = nodeStatus.opSentStatus[event]
    }

    new, _  := strconv.Atoi(objMeta.ResourceVersion)
    //for create/delete keep track of last one sent to, this may not be full proof
    //  Create could be processed asynchoronusly by client and can come out of order.
    //  For now should be ok as at least we make sure all messages are processed.
    //For update keep track of only last one as nimbus client periodically pulls
    if evStatus.LastObjectMeta != nil {
        current, _  := strconv.Atoi(evStatus.LastObjectMeta.ResourceVersion)
        if current > new {
            return
        }
    }
    evStatus.LastObjectMeta = objMeta
}

//update recv object status
func (eh *{{$crudObject}}Topic) WatcherInConfigSync(nodeID string, event api.EventType) bool {


    var ok bool
    var evStatus *EventStatus
    var evAckStatus *EventStatus

    eh.Lock()
    defer eh.Unlock()

    nodeStatus, ok := eh.nodeStatus[nodeID]
    if !ok {
        return true
    }

    evStatus, ok = nodeStatus.opSentStatus[event]
    if !ok {
        //nothing sent, so insync
        return true
     }

    //In-flight object still exists
    if len(nodeStatus.watcher.Channel) != 0 {
        log.Infof("watcher %v still has objects in in-flight %v(%v)", nodeID, "{{$crudObject}}", event)
        return false
    }

    evAckStatus, ok = nodeStatus.opAckedStatus[event]
    if !ok {
        //nothing received, failed.
        log.Infof("watcher %v still has not received anything %v(%v)", nodeID, "{{$crudObject}}", event)
        return false
     }

    if evAckStatus.LastObjectMeta.ResourceVersion < evStatus.LastObjectMeta.ResourceVersion {
        log.Infof("watcher %v resource version mismatch for %v(%v)  sent %v: recived %v",
             nodeID, "{{$crudObject}}", event, evStatus.LastObjectMeta.ResourceVersion,
             evAckStatus.LastObjectMeta.ResourceVersion)
        return false
    }

    return true
}

/*
//GetSentEventStatus
func (eh *{{$crudObject}}Topic) GetSentEventStatus(nodeID string, event api.EventType) *EventStatus {

    eh.Lock()
    defer eh.Unlock()
    var evStatus *EventStatus

    objStatus, ok := eh.opSentStatus[nodeID]
    if ok {
        evStatus, ok = objStatus.opStatus[event]
        if ok {
            return evStatus
        }
    }
    return nil
}


//GetAckedEventStatus
func (eh *{{$crudObject}}Topic) GetAckedEventStatus(nodeID string, event api.EventType) *EventStatus {

    eh.Lock()
    defer eh.Unlock()
    var evStatus *EventStatus

    objStatus, ok := eh.opAckedStatus[nodeID]
    if ok {
        evStatus, ok = objStatus.opStatus[event]
        if ok {
            return evStatus
        }
    }
    return nil
}

*/

// Create{{$crudObject}} creates {{$crudObject}}
func (eh *{{$crudObject}}Topic) Create{{$crudObject}}(ctx context.Context, objinfo *netproto.{{$crudObject}}) (*netproto.{{$crudObject}}, error) {
    var err error
    nodeID := netutils.GetNodeUUIDFromCtx(ctx)
 // log.Infof("Received Create{{$crudObject}} from node %v: {%+v}", nodeID, objinfo)

    // trigger callbacks. we allow creates to happen before it exists in memdb
    if eh.statusReactor != nil {
        err = eh.statusReactor.On{{$crudObject}}CreateReq(nodeID, objinfo)
        if err != nil {
            log.Errorf("Create{{$crudObject}} for obj: {%+v} failed, err: %v", objinfo, err)
            return objinfo, err
        }
    }

    // increment stats
    eh.server.Stats("{{$crudObject}}", "AgentCreate").Inc()

    return objinfo, nil
}

// Update{{$crudObject}} updates {{$crudObject}}
func (eh *{{$crudObject}}Topic) Update{{$crudObject}}(ctx context.Context, objinfo *netproto.{{$crudObject}}) (*netproto.{{$crudObject}}, error) {
    nodeID := netutils.GetNodeUUIDFromCtx(ctx)
    log.Infof("Received Update{{$crudObject}} from node %v: {%+v}", nodeID, objinfo)

    // incr stats
    eh.server.Stats("{{$crudObject}}", "AgentUpdate").Inc()

    // trigger callbacks
    if eh.statusReactor != nil {
        eh.statusReactor.On{{$crudObject}}UpdateReq(nodeID, objinfo)
    }

    return objinfo, nil
}

// Delete{{$crudObject}} deletes an {{$crudObject}}
func (eh *{{$crudObject}}Topic) Delete{{$crudObject}}(ctx context.Context, objinfo *netproto.{{$crudObject}}) (*netproto.{{$crudObject}}, error) {
    nodeID := netutils.GetNodeUUIDFromCtx(ctx)
    log.Infof("Received Delete{{$crudObject}} from node %v: {%+v}", nodeID, objinfo)

    // incr stats
    eh.server.Stats("{{$crudObject}}", "AgentDelete").Inc()

    // trigger callbacks
    if eh.statusReactor != nil {
        eh.statusReactor.On{{$crudObject}}DeleteReq(nodeID, objinfo)
    }

    return objinfo, nil
}

// {{$crudObject}}FromObj converts memdb object to {{$crudObject}}
func {{$crudObject}}FromObj(obj memdb.Object) (*netproto.{{$crudObject}}, error) {
    switch obj.(type) {
    case *netproto.{{$crudObject}}:
        eobj := obj.(*netproto.{{$crudObject}})
        return eobj, nil
    default:
        return nil, ErrIncorrectObjectType
    }
}

// Get{{$crudObject}} returns a specific {{$crudObject}}
func (eh *{{$crudObject}}Topic) Get{{$crudObject}}(ctx context.Context, objmeta *api.ObjectMeta) (*netproto.{{$crudObject}}, error) {
    // find the object
    obj, err := eh.server.memDB.FindObject("{{$crudObject}}", objmeta)
    if err != nil {
        return nil, err
    }

    return {{$crudObject}}FromObj(obj)
}

// List{{$crudObject}}s lists all {{$crudObject}}s matching object selector
func (eh *{{$crudObject}}Topic) List{{$crudObject}}s(ctx context.Context, objsel *api.ListWatchOptions) (*netproto.{{$crudObject}}List, error) {
    var objlist netproto.{{$crudObject}}List
    nodeID := netutils.GetNodeUUIDFromCtx(ctx)
    filters := []memdb.FilterFn{}

    filterFn := func(obj, prev memdb.Object) bool {
            return true
    }

    if  eh.statusReactor != nil {
        filters = eh.statusReactor.GetAgentWatchFilter(ctx, "netproto.{{$crudObject}}", objsel)
    } else {
        filters = append(filters, filterFn)
    }

    // walk all objects
    objs := eh.server.memDB.ListObjectsForReceiver("{{$crudObject}}", nodeID, filters)
	//creationTime, _ := types.TimestampProto(time.Now())
    for _, oo := range objs {
        obj, err := {{$crudObject}}FromObj(oo)
        if err == nil {
			//obj.CreationTime = api.Timestamp{Timestamp: *creationTime}
            objlist.{{$crudObject}}s = append(objlist.{{$crudObject}}s, obj)
            //record the last object sent to check config sync
            eh.updateSentObjStatus(nodeID, api.EventType_UpdateEvent, &obj.ObjectMeta)
        }
    }

    return &objlist, nil
}

// Watch{{$crudObject}}s watches {{$crudObject}}s and sends streaming resp
func (eh *{{$crudObject}}Topic) Watch{{$crudObject}}s(watchOptions *api.ListWatchOptions, stream netproto.{{$svcname}}_Watch{{$crudObject}}sServer) error {
    // watch for changes
    watcher := memdb.Watcher{}
    watcher.Channel = make(chan memdb.Event, memdb.WatchLen)
    watcher.Filters = make(map[string][]memdb.FilterFn)
    defer close(watcher.Channel)

    ctx := stream.Context()
    nodeID := netutils.GetNodeUUIDFromCtx(ctx)

    if  eh.statusReactor != nil {
        watcher.Filters["{{$crudObject}}"] = eh.statusReactor.GetAgentWatchFilter(ctx, "{{$crudObject}}", watchOptions)
    } else {
        filt := func(obj, prev memdb.Object) bool {
            return true
        }
        watcher.Filters["{{$crudObject}}"] = append(watcher.Filters["{{$crudObject}}"], filt)
    }

    watcher.Name = nodeID
    err := eh.server.memDB.WatchObjects("{{$crudObject}}", &watcher)
    if err != nil {
		log.Errorf("Error Starting watch for kind %v Err: %v", "{{$crudObject}}", err)
		return err
	}
    defer eh.server.memDB.StopWatchObjects("{{$crudObject}}", &watcher)

    // get a list of all {{$crudObject}}s
    objlist, err := eh.List{{$crudObject}}s(context.Background(), watchOptions)
    if err != nil {
        log.Errorf("Error getting a list of objects. Err: %v", err)
        return err
    }

    eh.registerWatcher(nodeID, &watcher)
    defer eh.unRegisterWatcher(nodeID)

    // increment stats
    eh.server.Stats("{{$crudObject}}", "ActiveWatch").Inc()
    eh.server.Stats("{{$crudObject}}", "WatchConnect").Inc()
    defer eh.server.Stats("{{$crudObject}}", "ActiveWatch").Dec()
    defer eh.server.Stats("{{$crudObject}}", "WatchDisconnect").Inc()



    // walk all {{$crudObject}}s and send it out
	watchEvts := netproto.{{$crudObject}}EventList{}
	for _, obj := range objlist.{{$crudObject}}s {
		watchEvt := netproto.{{$crudObject}}Event{
			EventType: api.EventType_CreateEvent,
            {{if (eq $version "V2")}}
			    {{$crudObject}}:  obj,
            {{else}}
			    {{$crudObject}}:  *obj,
            {{end}}
		}
		watchEvts.{{$crudObject}}Events = append(watchEvts.{{$crudObject}}Events, &watchEvt)
	}
	if len(watchEvts.{{$crudObject}}Events) > 0 {
		err = stream.Send(&watchEvts)
		if err != nil {
			log.Errorf("Error sending {{$crudObject}} to stream. Err: %v", err)
			return err
		}
	}
	timer := time.NewTimer(DefaultWatchHoldInterval)
	if !timer.Stop() {
		<-timer.C
	}

	running := false
	watchEvts = netproto.{{$crudObject}}EventList{}
	sendToStream := func() error {
		err = stream.Send(&watchEvts)
		if err != nil {
			log.Errorf("Error sending {{$crudObject}} to stream. Err: %v", err)
			return err
		}
		watchEvts = netproto.{{$crudObject}}EventList{}
		return nil
	}

    // loop forever on watch channel
    for {
        select {
        // read from channel
        case evt, ok := <-watcher.Channel:
            if !ok {
                log.Errorf("Error reading from channel. Closing watch")
                return errors.New("Error reading from channel")
            }

            // convert the events
            var etype api.EventType
            switch evt.EventType {
            case memdb.CreateEvent:
                etype = api.EventType_CreateEvent
            case memdb.UpdateEvent:
                etype = api.EventType_UpdateEvent
            case memdb.DeleteEvent:
                etype = api.EventType_DeleteEvent
            }

            // get the object
            obj, err := {{$crudObject}}FromObj(evt.Obj)
            if err != nil {
                return err
            }

            // convert to netproto format
            watchEvt := netproto.{{$crudObject}}Event{
                EventType: etype,
                {{if (eq $version "V2")}}
                    {{$crudObject}}:  obj,
                {{else}}
                    {{$crudObject}}:  *obj,
                {{end}}
            }
            watchEvts.{{$crudObject}}Events = append(watchEvts.{{$crudObject}}Events, &watchEvt)
		    if !running {
			    running = true
			    timer.Reset(DefaultWatchHoldInterval)
		    }
		    if len(watchEvts.{{$crudObject}}Events) >= DefaultWatchBatchSize {
			    if err = sendToStream(); err != nil {
				    return err
			    }
			    if !timer.Stop() {
				    <-timer.C
			    }
			    timer.Reset(DefaultWatchHoldInterval)
		    }
		eh.updateSentObjStatus(nodeID, etype, &obj.ObjectMeta)
        case <-timer.C:
	        running = false
	        if err = sendToStream(); err != nil {
		       return err
	        }
        case <-ctx.Done():
            return ctx.Err()
        }
    }

    // done
}


// update{{$crudObject}}Oper triggers oper update callbacks
func (eh *{{$crudObject}}Topic) update{{$crudObject}}Oper(oper *netproto.{{$crudObject}}Event, nodeID string) error {
    eh.updateAckedObjStatus(nodeID, oper.EventType, &oper.{{$crudObject}}.ObjectMeta)
	switch oper.EventType {
	case api.EventType_CreateEvent:
		fallthrough
	case api.EventType_UpdateEvent:
		// incr stats
		eh.server.Stats("{{$crudObject}}", "AgentUpdate").Inc()

		// trigger callbacks
		if eh.statusReactor != nil {
            {{if (eq $version "V2")}}
			    return eh.statusReactor.On{{$crudObject}}OperUpdate(nodeID, oper.{{$crudObject}})
            {{else}}
			    return eh.statusReactor.On{{$crudObject}}OperUpdate(nodeID, &oper.{{$crudObject}})
            {{end}}
		}
	case api.EventType_DeleteEvent:
		// incr stats
		eh.server.Stats("{{$crudObject}}", "AgentDelete").Inc()

		// trigger callbacks
		if eh.statusReactor != nil {
            {{if (eq $version "V2")}}
			    eh.statusReactor.On{{$crudObject}}OperDelete(nodeID, oper.{{$crudObject}})
            {{else}}
			    eh.statusReactor.On{{$crudObject}}OperDelete(nodeID, &oper.{{$crudObject}})
            {{end}}
		}
	}

	return nil
}

func (eh *{{$crudObject}}Topic) {{$crudObject}}OperUpdate(stream netproto.{{$svcname}}_{{$crudObject}}OperUpdateServer) error {
    ctx := stream.Context()
    nodeID := netutils.GetNodeUUIDFromCtx(ctx)

    for {
        oper, err := stream.Recv()
        if err == io.EOF {
            log.Errorf("%v {{$crudObject}}OperUpdate stream ended. closing..", nodeID)
            return stream.SendAndClose(&api.TypeMeta{})
        } else if err != nil {
            log.Errorf("Error receiving from %v {{$crudObject}}OperUpdate stream. Err: %v", nodeID, err)
            return err
        }

        err = eh.update{{$crudObject}}Oper(oper, nodeID)
        if err != nil {
            log.Errorf("Error updating {{$crudObject}} oper state. Err: %v", err)
        }
    }
}

       {{end}}
    {{end}}
{{end}}
