// Code generated by protoc-gen-grpc-pensando DO NOT EDIT.

package nimbus

{{$manifest := (getNimbusManifest "../generated/nimbus/manifest")}}

import (
	"sync"
	"github.com/pensando/sw/api"
	protoTypes "github.com/gogo/protobuf/types"
	"github.com/pkg/errors"
	"github.com/pensando/sw/nic/agent/protos/netproto"
	debugStats "github.com/pensando/sw/venice/utils/debug/stats"
	"github.com/pensando/sw/venice/utils/log"
	"github.com/pensando/sw/venice/utils/rpckit"
	context "golang.org/x/net/context"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/connectivity"
	"google.golang.org/grpc/status"
)

const maxOpretry = 10
const evChanLength = 10000
const resyncInterval = time.Minute * 5
const DefaultRPCTimeout = time.Second * 30

// NimbusClient is the nimbus client
type NimbusClient struct {
	sync.Mutex                                    // lock the npm client
    clientName      string                        // client's name
	srvURL          string                        // rpc server URL
	waitGrp         sync.WaitGroup                // wait group to wait on all go routines to exit
	rpcClient       *rpckit.RPCClient             // grpc client for watch
	objlocks        map[string]*sync.Mutex // object level locks
	debugStats      *debugStats.Stats
}

// NewNimbusClient creates a new nimbus client
func NewNimbusClient(clientName, srvURL string, rpcClient *rpckit.RPCClient) (*NimbusClient, error) {
	// create NimbusClient object
	client := NimbusClient{
        clientName:      clientName,
		srvURL:          srvURL,
		rpcClient:       rpcClient,
		objlocks:        make(map[string]*sync.Mutex),
	}

	client.debugStats = debugStats.New(clientName).Tsdb().Kind("nimbusClientStats").TsdbPeriod(5 * time.Second).Build()

	return &client, nil
}


// Wait waits for all watchers to exit
func (client *NimbusClient) Wait() {
	client.debugStats.Close()
	client.waitGrp.Wait()
}

//Does not implement, will dynamically validate when watch is called
type AggReactor interface {
}

type AggWatchOStream struct {
	sync.Mutex
	stream netproto.AggWatchApiV1_ObjectOperUpdateClient
}

// lockObject locks an object
func (client *NimbusClient) lockObject(kind string, ometa api.ObjectMeta) {
	objkey := fmt.Sprintf("%s/%s", kind, ometa.GetKey())

	client.Lock()
	objlock, ok := client.objlocks[objkey]
	if !ok {
		client.objlocks[objkey] = &sync.Mutex{}
		objlock = client.objlocks[objkey]
	}
	client.Unlock()
	objlock.Lock()
}

// unlockObject unlocks an object
func (client *NimbusClient) unlockObject(kind string, ometa api.ObjectMeta) {
	objkey := fmt.Sprintf("%s/%s", kind, ometa.GetKey())
	client.Lock()
	objlock, ok := client.objlocks[objkey]
	if ok {
		objlock.Unlock()
	}
	client.Unlock()
}
// watchAggWatchRecvLoop receives from stream and write it to a channel
func (client *NimbusClient) watchAggWatchRecvLoop(stream netproto.AggWatchApiV1_WatchObjectsClient, recvch chan<- *netproto.AggObjectEvent) {
	defer close(recvch)
	client.waitGrp.Add(1)
	defer client.waitGrp.Done()

	// loop till the end
	for {
		// receive from stream
		objList, err := stream.Recv()
		if err != nil {
			log.Errorf("Error receiving from watch channel. Exiting Agg watch. Err: %v", err)
			return
		}
		for _, evt := range objList.AggObjectEvents {
			recvch <- evt
		}
	}
}

// GetObject retrieves the runtime.Object from a svc watch event
func GetObject(obj *netproto.AggObject) (*protoTypes.DynamicAny, error) {
	robj := &protoTypes.DynamicAny{}
	err := protoTypes.UnmarshalAny(&obj.Object.Any, robj)
	if err != nil {
		return nil, err
	}
	return robj, nil
}


// processAggObjectWatchEvent handle agg watch event
func (client *NimbusClient) processAggObjectWatchEvent(evt netproto.AggObjectEvent, reactor AggReactor, ostream *AggWatchOStream) {
	client.waitGrp.Add(1)
	defer client.waitGrp.Done()

	object, err := GetObject(&evt.AggObj)
	if err != nil {
		log.Errorf("Invalid object for get %v", err)
		return
	}

	switch evt.AggObj.Kind {
	{{range $key, $value := $manifest}}
	case "{{$value.Object}}":
		err = client.process{{$value.Object}}Dynamic(evt.EventType, object.Message.(*netproto.{{$value.Object}}), reactor.({{$value.Object}}Reactor))
	{{end}}
	}
	if err == nil {
		robj := netproto.AggObjectEvent{
			EventType: evt.EventType,
			AggObj:    evt.AggObj,
		}
		// send oper status
		ostream.Lock()
		err := ostream.stream.Send(&robj)
		if err != nil {
			log.Errorf("failed to send Agg oper Status, %s", err)
			client.debugStats.AddInt("AggOperSendError", 1)
		} else {
			client.debugStats.AddInt("AggOperSent", 1)
		}
		ostream.Unlock()
	}

}

{{range $key, $value := $manifest}}
// diff{{$value.Object}}sDynamic diffs local state with controller state
func (client *NimbusClient) diff{{$value.Object}}sDynamic(objList *netproto.{{$value.Object}}List, reactor {{$value.Object}}Reactor,
	ostream *AggWatchOStream) {
	// build a map of objects
	objmap := make(map[string]*netproto.{{$value.Object}})
	for _, obj := range objList.{{$value.Object}}s {
		key := obj.ObjectMeta.GetKey()
		objmap[key] = obj
	}

	// see if we need to delete any locally found object
	o := netproto.{{$value.Object}} {
		TypeMeta: api.TypeMeta{Kind: "{{$value.Object}}"},
	}

	localObjs, err := reactor.Handle{{$value.Object}}(types.List, o)
	if err != nil {
		log.Error(errors.Wrapf(types.ErrNimbusHandling, "Op: %s | Kind: {{$value.Object}} | Err: %v", types.Operation(types.List), err))
	}
	//localObjs := reactor.List{{$value.Object}}()
	for _, lobj := range localObjs {
		ctby, ok := lobj.ObjectMeta.Labels["CreatedBy"]
		if ok && ctby == "Venice" {
			key := lobj.ObjectMeta.GetKey()
			if _, ok := objmap[key]; !ok {
				evt := netproto.{{$value.Object}}Event{
					EventType: api.EventType_DeleteEvent,
					{{if (eq $value.Version "V2")}}
						{{$value.Object}}:  &lobj,
					{{else}}
						{{$value.Object}}:  lobj,
					{{end}}
				}
				log.Infof("diff{{$value.Object}}s(): Deleting object %+v", lobj.ObjectMeta)
				client.lockObject(evt.{{$value.Object}}.GetObjectKind(), evt.{{$value.Object}}.ObjectMeta)
				client.process{{$value.Object}}Event(evt, reactor, nil)
			}
		} else {
			log.Infof("Not deleting non-venice object %+v", lobj.ObjectMeta)
		}
	}

	// add/update all new objects
	for _, obj := range objList.{{$value.Object}}s {
		evt := netproto.{{$value.Object}}Event{
			EventType: api.EventType_UpdateEvent,
			{{if (eq $value.Version "V2")}}
				{{$value.Object}}:  obj,
			{{else}}
				{{$value.Object}}:  *obj,
			{{end}}
		}
		client.lockObject(evt.{{$value.Object}}.GetObjectKind(), evt.{{$value.Object}}.ObjectMeta)
		err := client.process{{$value.Object}}Event(evt, reactor, nil)

		if err == nil {
			mobj, err := protoTypes.MarshalAny(obj)
			aggObj := netproto.AggObject{Kind: "{{$value.Object}}", Object: &api.Any{}}
			aggObj.Object.Any = *mobj
			robj := netproto.AggObjectEvent{
				EventType: api.EventType_UpdateEvent,
				AggObj:    aggObj,
			}
			// send oper status
			ostream.Lock()
			err = ostream.stream.Send(&robj)
			if err != nil {
				log.Errorf("failed to send Agg oper Status, %s", err)
				client.debugStats.AddInt("AggOperSendError", 1)
			} else {
				client.debugStats.AddInt("AggOperSent", 1)
			}
			ostream.Unlock()
		}
	}
}
{{end}}


// diffApp diffs local state with controller state
// FIXME: this is not handling deletes today
func (client *NimbusClient) diffAggWatchObjects(objList *netproto.AggObjectList, reactor AggReactor, ostream *AggWatchOStream) {

	type listObject struct {
		kind    string
		objects interface{}
	}

	//This will order be diffed
	listOrderObjects := []*listObject{}

	addToListOrder := func(kind string, obj *protoTypes.DynamicAny) {
		for _, lobj := range listOrderObjects {
			if lobj.kind == kind {
				switch kind {
				{{range $key, $value := $manifest}}
				case "{{$value.Object}}":
					msglist := lobj.objects.(*netproto.{{$value.Object}}List)
					msglist.{{$value.Object}}s = append(msglist.{{$value.Object}}s, obj.Message.(*netproto.{{$value.Object}}))
					return
				{{end}}
				}
			}
		}
		//This kind not added, create a new one
		listObj := &listObject{kind: kind}
		switch kind {
		{{range $key, $value := $manifest}}
		case "{{$value.Object}}":
			listObj.objects = &netproto.{{$value.Object}}List{}
			msglist := listObj.objects.(*netproto.{{$value.Object}}List)
			msglist.{{$value.Object}}s = append(msglist.{{$value.Object}}s, obj.Message.(*netproto.{{$value.Object}}))
		{{end}}

		}
		listOrderObjects = append(listOrderObjects, listObj)
	}

	for _, obj := range objList.Objects {
		object, err := GetObject(obj)
		if err != nil {
			log.Errorf("Invalid object for get %v", err)
			return
		}
		addToListOrder(obj.Kind, object)
	}

	for _, lobj := range listOrderObjects {
		switch lobj.kind {
		{{range $key, $value := $manifest}}
		case "{{$value.Object}}":
			client.diff{{$value.Object}}sDynamic(lobj.objects.(*netproto.{{$value.Object}}List), reactor.({{$value.Object}}Reactor), ostream)
		{{end}}
		}
	}

}

func (client *NimbusClient) WatchAggregate(ctx context.Context, kinds []string, reactor AggReactor) error {

	// setup wait group
	client.waitGrp.Add(1)
	defer client.waitGrp.Done()
	client.debugStats.AddInt("ActiveAggWatch", 1)

	//Make sure all kinds are implemented by the reactor

	// make sure rpc client is good
	if client.rpcClient == nil || client.rpcClient.ClientConn == nil || client.rpcClient.ClientConn.GetState() != connectivity.Ready {
		log.Errorf("RPC client is disconnected. Exiting watch")
		if client.rpcClient != nil && client.rpcClient.ClientConn != nil {
			log.Errorf("RPC client  state %v %v", client.rpcClient, client.rpcClient.ClientConn.GetState())
		}
		if client.rpcClient != nil  && client.rpcClient.ClientConn != nil {
				log.Errorf("RPC client Connection %v", client.rpcClient.ClientConn)
		} else {
				log.Errorf("RPC client Connection is nil")
		}

		return fmt.Errorf("RPC client disconnected")
	}

	aggKinds := api.AggWatchOptions{}
	for _, kind := range kinds {
		switch kind {
		{{range $key, $value := $manifest}}
		case "{{$value.Object}}":
			//Make sure all kinds are implemented by the reactor to avoid later failures
			if _, ok := reactor.({{$value.Object}}Reactor); !ok {
				return fmt.Errorf("Reactor does not implement %v", "{{$value.Object}}Reactor")
			}
			aggKind := api.KindWatchOptions{}
			aggKind.Kind = kind
			aggKind.Group = "netproto"
			listWatchOptions := reactor.({{$value.Object}}Reactor).GetWatchOptions(ctx, "{{$value.Object}}")
			aggKind.Options = listWatchOptions
			aggKinds.WatchOptions = append(aggKinds.WatchOptions, aggKind)
        {{end}}
		}
	}

	// start the watch
	aggRPCClient := netproto.NewAggWatchApiV1Client(client.rpcClient.ClientConn)
	stream, err := aggRPCClient.WatchObjects(ctx, &aggKinds)
	if err != nil {
		log.Errorf("Error watching Aggregate watch for . Err: %v", err)
		return nil
	}

	// start oper update stream
	opStream, err := aggRPCClient.ObjectOperUpdate(ctx)
	if err != nil {
		log.Errorf("Error starting Aggregate oper updates. Err: %v", err)
		return nil
	}

	ostream := &AggWatchOStream{stream: opStream}

	// get a list of objects
	objList, err := aggRPCClient.ListObjects(ctx, &aggKinds)
	if err != nil {
		st, ok := status.FromError(err)
		if !ok || st.Code() == codes.Unavailable {
			log.Errorf("Error getting Aggregate list. Err: %v", err)
			return nil
		}
	} else {
		// perform a diff of the states
		client.diffAggWatchObjects(objList, reactor, ostream)

	}

	// start grpc stream recv
	recvCh := make(chan *netproto.AggObjectEvent, evChanLength)
	go client.watchAggWatchRecvLoop(stream, recvCh)

	// loop till the end
	for {
		evtWork := func(evt *netproto.AggObjectEvent) {
			client.debugStats.AddInt("AggWatchEvents", 1)
			client.processAggObjectWatchEvent(*evt, reactor, ostream)
		}
		//Give priority to evnt work.
		select {
		case evt, ok := <-recvCh:
			if !ok {
				log.Warnf("Agg Watch channel closed. Exisint AggWatch")
				return nil
			}
			evtWork(evt)
		case <-time.After(resyncInterval):
			//Give priority to evt work
			//Wait for batch interval for inflight work
			time.Sleep(5 * DefaultWatchHoldInterval)
			select {
			case evt, ok := <-recvCh:
				if !ok {
					log.Warnf("NetworkSecurityPolicy Watch channel closed. Exisint NetworkSecurityPolicyWatch")
					return nil
				}
				evtWork(evt)
				continue
			default:
			}

			// get a list of objects
			objList, err := aggRPCClient.ListObjects(ctx, &aggKinds)
			if err != nil {
				st, ok := status.FromError(err)
				if !ok || st.Code() == codes.Unavailable {
					log.Errorf("Error getting Aggregate list. Err: %v", err)
					return err
				}
			} else {
				// perform a diff of the states
				client.diffAggWatchObjects(objList, reactor, ostream)
			}
		}
	}
}
