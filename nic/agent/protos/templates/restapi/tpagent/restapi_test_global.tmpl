// Code generated by protoc-gen-grpc-pensando DO NOT EDIT.

/*
Package {{.GoPkg.Name}} is a auto generated package.
Input file: {{.Name}}
*/
package restapi_test


import (
	"flag"
	"os"
	"testing"

	"github.com/golang/mock/gomock"

	"github.com/pensando/sw/api"
	"github.com/pensando/sw/nic/agent/netagent/ctrlerif/restapi"
	"github.com/pensando/sw/nic/agent/netagent/datapath"
	"github.com/pensando/sw/nic/agent/netagent/state"
	"github.com/pensando/sw/nic/agent/protos/netproto"
	tpdatapath "github.com/pensando/sw/nic/agent/tpa/datapath"
	tpstate "github.com/pensando/sw/nic/agent/tpa/state"
	tsdatapath "github.com/pensando/sw/nic/agent/troubleshooting/datapath/hal"
	tpdatapath "github.com/pensando/sw/nic/agent/tpa/datapath"
	tsstate "github.com/pensando/sw/nic/agent/troubleshooting/state"
	"github.com/pensando/sw/venice/utils/log"
)

func getMgmtIP() string {
	return "10.10.10.10"
}

const (
	agentRestURL      = "localhost:1337"
	agentDatapathKind = "mock"
)

// Response captures the HTTP Response sent by Agent REST Server
type Response struct {
	StatusCode int      `json:"status-code,omitempty"`
	Error      string   `json:"error,omitempty"`
	References []string `json:"references,omitempty"`
}

func TestMain(m *testing.M) {
	srv, err := setup()
	if err != nil {
		log.Fatalf("Test set up failed. Error: %v", err)
	}
	testCode := m.Run()
	srv.Stop()
	os.Exit(testCode)
}

var datapathKind = flag.String("datapath", agentDatapathKind, "Specify the datapath type. mock | hal")

func setup() (*restapi.RestServer, error) {

	dp, err := datapath.NewHalDatapath(datapath.Kind(*datapathKind))
	if err != nil {
		log.Errorf("Could not create HAL datapath. Kind: %v, Error %v", datapathKind, err)
		return nil, err
	}

	// Set tenant creation expectation
	if dp.Kind.String() == "mock" {
		dp.Hal.MockClients.MockTnclient.EXPECT().VrfCreate(gomock.Any(), gomock.Any()).Return(nil, nil)
	}

	nagent, err := state.NewNetAgent(dp, "")
	if err != nil {
		log.Errorf("Could not create net agent")
		return nil, err
	}

	tsdp, err := tsdatapath.NewHalDatapath(tsdatapath.Kind("mock"))
	if err != nil {
		log.Errorf("Could not create troubleshooting HAL datapath. Kind: %v, Error %v", datapathKind, err)
		return nil, err
	}
	tsagent, err := tsstate.NewTsAgent(tsdp, "dummy-node-uuid", nagent, getMgmtIP)
	if err != nil {
		log.Errorf("Could not create ts troubleshooting agent")
		return nil, err
	}

	tpa, err := tpstate.NewTpAgent(nagent, func() string { return "192.168.100.101" }, tpdatapath.MockHal())
	if err != nil {
		log.Fatalf("Error creating telemetry policy agent. Err: %v", err)
	}
	log.Printf("telemetry policy agent {%+v} instantiated", tpa)

	err = populatePreTestData(nagent)
	if err != nil {
		log.Errorf("Could not meet prerequisites for testing Endpoint CRUD Methods")
		return nil, err
	}
	
	
	return restapi.NewRestServer(nagent, tsagent, tpa, agentRestURL)

}


func populatePreTestData(nagent *state.Nagent) (err error) {
	vrf := netproto.Vrf{
			TypeMeta: api.TypeMeta{Kind: "Vrf"},
			ObjectMeta: api.ObjectMeta{
					Tenant:    "default",
					Namespace: "default",
					Name:      "preCreatedVrf",
			},
			Spec: netproto.VrfSpec{
					VrfType: "CUSTOMER",
			},
	}
	err = nagent.CreateVrf(&vrf)
	if err != nil {
			log.Errorf("Failed to create vrf. {%v}", vrf)
			return
	}

	nt := netproto.Network{
		TypeMeta: api.TypeMeta{Kind: "Network"},
		ObjectMeta: api.ObjectMeta{
			Tenant:    "default",
			Namespace: "default",
			Name:      "preCreatedNetwork",
		},
		Spec: netproto.NetworkSpec{
			IPv4Subnet:  "10.1.2.0/24",
			IPv4Gateway: "10.1.1.254",
		},
	}
	err = nagent.CreateNetwork(&nt)
	if err != nil {
		log.Errorf("Failed to create network. {%v}", nt)
		return
	}

	ep := netproto.Endpoint{
		TypeMeta: api.TypeMeta{Kind: "Endpoint"},
		ObjectMeta: api.ObjectMeta{
			Tenant:    "default",
			Namespace: "default",
			Name:      "preCreatedEndpoint",
		},
		Spec: netproto.EndpointSpec{
			EndpointUUID: "testEndpointUUID",
			WorkloadUUID: "testWorkloadUUID",
			NetworkName:  "preCreatedNetwork",
			NodeUUID:     "dummy-node-uuid",
			IPv4Address:  "10.1.1.0/24",
			MacAddress:   "42:42:42:42:42:42",
		},
	}
	_, err = nagent.CreateEndpoint(&ep)
	if err != nil {
		log.Errorf("Failed to create endpoint. {%v}", ep)
		return
	}

	sg := netproto.SecurityGroup{
		TypeMeta: api.TypeMeta{Kind: "SecurityGroup"},
		ObjectMeta: api.ObjectMeta{
			Tenant:    "default",
			Namespace: "default",
			Name:      "preCreatedSecurityGroup",
		},
		Spec: netproto.SecurityGroupSpec{
			SecurityProfile: "unknown",
		},
	}
	err = nagent.CreateSecurityGroup(&sg)
	if err != nil {
		log.Errorf("Failed to create security group. {%v}", sg)
		return
	}

	natPool := netproto.NatPool{
		TypeMeta: api.TypeMeta{Kind: "NatPool"},
		ObjectMeta: api.ObjectMeta{
			Tenant:    "default",
			Namespace: "default",
			Name:      "preCreatedNatPool",
		},
		Spec: netproto.NatPoolSpec{
			IPRange: "10.1.2.1-10.1.2.200",
		},
	}
	err = nagent.CreateNatPool(&natPool)
	if err != nil {
		log.Errorf("Failed to create nat pool. {%v}", sg)
		return
	}

	natPolicy := netproto.NatPolicy{
		TypeMeta: api.TypeMeta{Kind: "NatPolicy"},
		ObjectMeta: api.ObjectMeta{
			Tenant:    "default",
			Namespace: "default",
			Name:      "preCreatedNatPolicy",
		},
		Spec: netproto.NatPolicySpec{
			Rules: []netproto.NatRule{
				{
					Src: &netproto.MatchSelector{
						Addresses: []string{"10.0.0.0 - 10.0.1.0"},
					},
					Dst: &netproto.MatchSelector{
						Addresses: []string{"192.168.0.0 - 192.168.1.1"},
					},
					NatPool: "preCreatedNatPool",
					Action:  "SNAT",
				},
			},
		},
	}

	err = nagent.CreateNatPolicy(&natPolicy)
	if err != nil {
		log.Errorf("Failed to create nat policy. {%v}", sg)
		return
	}

	tn := netproto.Tenant{
		TypeMeta: api.TypeMeta{Kind: "Tenant"},
		ObjectMeta: api.ObjectMeta{
			Tenant:    "preCreatedTenant",
			Name:      "preCreatedTenant",
			Namespace: "preCreatedTenant",
		},
	}

	err = nagent.CreateTenant(&tn)
	if err != nil {
		log.Errorf("Failed to create tenant. {%v}", tn)
		return
	}

	ns := netproto.Namespace{
		TypeMeta: api.TypeMeta{Kind: "Namespace"},
		ObjectMeta: api.ObjectMeta{
			Tenant: "preCreatedTenant",
			Name:   "preCreatedNamespace",
		},
	}

	err = nagent.CreateNamespace(&ns)
	if err != nil {
		log.Errorf("Failed to create Namespace. {%v}", ns)
		return
	}

	rt := netproto.Route{
		TypeMeta: api.TypeMeta{Kind: "Route"},
		ObjectMeta: api.ObjectMeta{
			Tenant:    "preCreatedTenant",
			Name:      "preCreatedRoute",
			Namespace: "preCreatedNamespace",
		},
		Spec: netproto.RouteSpec{
			IPPrefix:  "192.168.1.0/24",
			GatewayIP: "192.168.1.1",
			Interface: "uplink-2",
		},
	}

	err = nagent.CreateRoute(&rt)
	if err != nil {
		log.Errorf("Failed to create Route. {%v}", rt)
		return

	}

	nb := netproto.NatBinding{
		TypeMeta: api.TypeMeta{Kind: "NatBinding"},
		ObjectMeta: api.ObjectMeta{
			Tenant:    "default",
			Name:      "preCreatedNatBinding",
			Namespace: "default",
		},
		Spec: netproto.NatBindingSpec{
			NatPoolName: "preCreatedNatPool",
			IPAddress:   "10.1.1.1",
		},
	}

	err = nagent.CreateNatBinding(&nb)
	if err != nil {
		log.Errorf("Failed to create Nat Binding. {%v}", ns)
		return
	}

	ipSecEncrypt := netproto.IPSecSAEncrypt{
		TypeMeta: api.TypeMeta{Kind: "IPSecSAEncrypt"},
		ObjectMeta: api.ObjectMeta{
			Tenant:    "default",
			Namespace: "default",
			Name:      "preCreatedIPSecSAEncrypt",
		},
		Spec: netproto.IPSecSAEncryptSpec{
			Protocol:      "ESP",
			AuthAlgo:      "AES_GCM",
			AuthKey:       "someRandomString",
			EncryptAlgo:   "AES_GCM_256",
			EncryptionKey: "someRandomKey",
			LocalGwIP:     "10.0.0.1",
			RemoteGwIP:    "192.168.1.1",
			TepVrf:         "default",
		},
	}
	err = nagent.CreateIPSecSAEncrypt(&ipSecEncrypt)
	if err != nil {
		log.Errorf("Failed to create IPSec Encrypt SA. {%v}", ns)
		return
	}

	ipSecDecrypt := netproto.IPSecSADecrypt{
		TypeMeta: api.TypeMeta{Kind: "IPSecSADecrypt"},
		ObjectMeta: api.ObjectMeta{
			Tenant:    "default",
			Namespace: "default",
			Name:      "preCreatedIPSecSADecrypt",
		},
		Spec: netproto.IPSecSADecryptSpec{
			Protocol:      "ESP",
			AuthAlgo:      "AES_GCM",
			AuthKey:       "someRandomString",
			DecryptAlgo:   "AES_GCM_256",
			DecryptionKey: "someRandomKey",
			LocalGwIP:     "10.0.0.1",
			RemoteGwIP:    "192.168.1.1",
			TepVrf:         "default",
		},
	}
	err = nagent.CreateIPSecSADecrypt(&ipSecDecrypt)
	if err != nil {
		log.Errorf("Failed to create IPSec Decrypt SA. {%v}", ns)
		return
	}

	ipSecPolicy := netproto.IPSecPolicy{
		TypeMeta: api.TypeMeta{Kind: "IPSecPolicy"},
		ObjectMeta: api.ObjectMeta{
			Tenant:    "default",
			Namespace: "default",
			Name:      "preCreatedIPSecPolicy",
		},
		Spec: netproto.IPSecPolicySpec{
			Rules: []netproto.IPSecRule{
				{
					Src: &netproto.MatchSelector{
						Addresses: []string{"10.0.0.0 - 10.0.1.0"},
					},
					Dst: &netproto.MatchSelector{
						Addresses: []string{"192.168.0.1 - 192.168.1.0"},
					},
					SAName: "preCreatedIPSecSAEncrypt",
					SAType: "ENCRYPT",
				},
				{
					Src: &netproto.MatchSelector{
						Addresses: []string{"10.0.0.0 - 10.0.1.0"},
					},
					Dst: &netproto.MatchSelector{
						Addresses: []string{"192.168.0.1 - 192.168.1.0"},
					},
					SAName: "preCreatedIPSecSADecrypt",
					SAType: "DECRYPT",
				},
			},
		},
	}
	err = nagent.CreateIPSecPolicy(&ipSecPolicy)
	if err != nil {
		log.Errorf("Failed to create IPSec Policy. {%v}", ns)
		return
	}

	sgPolicy := netproto.SGPolicy{
		TypeMeta: api.TypeMeta{Kind: "SGPolicy"},
		ObjectMeta: api.ObjectMeta{
			Tenant:    "default",
			Namespace: "default",
			Name:      "preCreatedSGPolicy",
		},
		Spec: netproto.SGPolicySpec{
			AttachGroup:  []string{"preCreatedSecurityGroup"},
			AttachTenant: false,
			Rules: []netproto.PolicyRule{
				{
					Action: "PERMIT",
					Src: &netproto.MatchSelector{
						Addresses: []string{"10.0.0.0 - 10.0.1.0"},
						AppConfigs: []*netproto.AppConfig{
							{
								Port:     "80",
								Protocol: "tcp",
							},
						},
					},
					Dst: &netproto.MatchSelector{
						Addresses: []string{"192.168.0.1 - 192.168.1.0"},
					},
				},
			},
		},
	}

	err = nagent.CreateSGPolicy(&sgPolicy)
	if err != nil {
		log.Errorf("Failed to create SG policy. {%v}", sg)
		return
	}

	tunnel := netproto.Tunnel{
		TypeMeta: api.TypeMeta{Kind: "Tunnel"},
		ObjectMeta: api.ObjectMeta{
			Tenant:    "default",
			Namespace: "default",
			Name:      "preCreatedTunnel",
		},
		Spec: netproto.TunnelSpec{
			Type:        "VXLAN",
			AdminStatus: "UP",
			Src:         "10.1.1.1",
			Dst:         "192.168.1.1",
		},
	}

	err = nagent.CreateTunnel(&tunnel)
	if err != nil {
		log.Errorf("Failed to create tunnel. {%v}", tunnel)
		return
	}

	tcpProxy := netproto.TCPProxyPolicy{
		TypeMeta: api.TypeMeta{Kind: "TCPProxyPolicy"},
		ObjectMeta: api.ObjectMeta{
			Tenant:    "default",
			Namespace: "default",
			Name:      "preCreatedTCPProxyPolicy",
		},
		Spec: netproto.TCPProxyPolicySpec{
			Rules: []netproto.TCPProxyRule{
				{
					Src: &netproto.MatchSelector{
						Addresses: []string{"64.0.0.1"},
					},

					Dst: &netproto.MatchSelector{
						Addresses: []string{"100.0.0.1"},
					},
					Action: "ENABLE",
				},
			},
		},
	}

	err = nagent.CreateTCPProxyPolicy(&tcpProxy)
	if err != nil {
		log.Errorf("Failed to create tcp proxy policy. {%v}", tcpProxy)
		return
	}

	enic := netproto.Interface{
		TypeMeta: api.TypeMeta{Kind: "Interface"},
		ObjectMeta: api.ObjectMeta{
			Tenant:    "default",
			Namespace: "default",
			Name:      "preCreatedInterface",
		},
		Spec: netproto.InterfaceSpec{
			Type:        "ENIC",
			AdminStatus: "UP",
		},
		Status: netproto.InterfaceStatus{
			OperStatus: "UP",
		},
	}

	err = nagent.CreateInterface(&enic)
	if err != nil {
		log.Errorf("Failed to create ENIC. {%v}", enic)
		return
	}

	port := netproto.Port{
		TypeMeta: api.TypeMeta{Kind: "Port"},
		ObjectMeta: api.ObjectMeta{
			Tenant:    "default",
			Namespace: "default",
			Name:      "preCreatedPort",
		},
		Spec: netproto.PortSpec{
			Speed:        "SPEED_100G",
			Type:         "TYPE_ETHERNET",
			AdminStatus:  "UP",
			BreakoutMode: "BREAKOUT_NONE",
			Lanes:        4,
		},
	}

	err = nagent.CreatePort(&port)
	if err != nil {
		log.Errorf("Failed to create port. {%v}", enic)
		return
	}

	secProfile := netproto.SecurityProfile{
		TypeMeta: api.TypeMeta{Kind: "SecurityProfile"},
		ObjectMeta: api.ObjectMeta{
			Tenant:    "default",
			Namespace: "default",
			Name:      "preCreatedSecurityProfile",
		},
		Spec: netproto.SecurityProfileSpec{
			Timeouts: &netproto.Timeouts{
				SessionIdle:        "10s",
				TCP:                "1m",
				TCPDrop:            "5s",
				TCPConnectionSetup: "300ms",
				TCPClose:           "1h",
				Drop:               "30s",
				UDP:                "5s",
				UDPDrop:            "1s",
				ICMP:               "100ms",
				ICMPDrop:           "1h10m15s",
			},
		},
	}

	err = nagent.CreateSecurityProfile(&secProfile)
	if err != nil {
		log.Errorf("Failed to create security profile. {%v}", secProfile)
		return
	}

	app := netproto.App{
		TypeMeta: api.TypeMeta{Kind: "App"},
		ObjectMeta: api.ObjectMeta{
			Tenant:    "default",
			Namespace: "default",
			Name:      "preCreatedApp",
		},
		Spec: netproto.AppSpec{
			ProtoPorts: []string{"udp/53"},
			ALG: &netproto.ALG{
				DNS: &netproto.DNS{
					DropLargeDomainPackets: true,
					QueryResponseTimeout:   "30s",
				},
			},
		},
	}

	err = nagent.CreateApp(&app)
	if err != nil {
		log.Errorf("Failed to create app. %v", app)
	}

	return nil
}

func TestRestServerStartStop(t *testing.T) {
	t.Parallel()
	// Don't need agent
	restSrv, err := restapi.NewRestServer(nil, nil, nil, ":0")
	if err != nil {
		t.Errorf("Could not start REST Server. Error: %v", err)
	}

	restURL := restSrv.GetListenURL()
	if len(restURL) == 0 {
		t.Errorf("Could not get the REST URL. URL: %s", restURL)
	}

	err = restSrv.Stop()
	if err != nil {
		t.Errorf("Failed to stop the REST Server. Error: %v", err)
	}
}

func TestRestServerListenFailures(t *testing.T) {
	t.Parallel()
	restSrv, err := restapi.NewRestServer(nil, nil, nil, "")
	if err != nil {
		t.Errorf("Could not start RestServer")
	}
	restSrv.Stop()

	_, err = restapi.NewRestServer(nil, nil, nil, ":65536")
	if err == nil {
		t.Errorf("Should see listener errors for the invalid port: %v", err)
	}
}
