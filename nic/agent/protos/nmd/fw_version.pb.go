// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: fw_version.proto

/*
	Package nmd is a generated protocol buffer package.

	Service name

	It is generated from these files:
		fw_version.proto

	It has these top-level messages:
		ImageInfo
		UbootFw
		GoldFw
		FwVersion
		DSCInstalledSoftware
		DSCRunningSoftware
		DSCSoftwareVersionInfo
*/
package nmd

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "google.golang.org/genproto/googleapis/api/annotations"
import _ "github.com/pensando/sw/venice/utils/apigen/annotations"
import _ "github.com/gogo/protobuf/gogoproto"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type ImageInfo struct {
	BuildDate            string `protobuf:"bytes,1,opt,name=BuildDate,proto3" json:"build_date,omitempty"`
	BuildUser            string `protobuf:"bytes,2,opt,name=BuildUser,proto3" json:"build_user,omitempty"`
	BaseVersion          string `protobuf:"bytes,3,opt,name=BaseVersion,proto3" json:"base_version,omitempty"`
	SoftwareVersion      string `protobuf:"bytes,4,opt,name=SoftwareVersion,proto3" json:"software_version,omitempty"`
	NicmgrCompatVersion  string `protobuf:"bytes,5,opt,name=NicmgrCompatVersion,proto3" json:"nicmgr_compat_version,omitempty"`
	KernelCompatVersion  string `protobuf:"bytes,6,opt,name=KernelCompatVersion,proto3" json:"kernel_compat_version,omitempty"`
	PcieCompatVersion    string `protobuf:"bytes,7,opt,name=PcieCompatVersion,proto3" json:"pcie_compat_version,omitempty"`
	DevConfCompatVersion string `protobuf:"bytes,8,opt,name=DevConfCompatVersion,proto3" json:"dev_conf_compat_version,omitempty"`
	// Field needed for Boot0 added in release A
	ImageVersion int32 `protobuf:"varint,9,opt,name=ImageVersion,proto3" json:"image_version,omitempty"`
}

func (m *ImageInfo) Reset()                    { *m = ImageInfo{} }
func (m *ImageInfo) String() string            { return proto.CompactTextString(m) }
func (*ImageInfo) ProtoMessage()               {}
func (*ImageInfo) Descriptor() ([]byte, []int) { return fileDescriptorFwVersion, []int{0} }

func (m *ImageInfo) GetBuildDate() string {
	if m != nil {
		return m.BuildDate
	}
	return ""
}

func (m *ImageInfo) GetBuildUser() string {
	if m != nil {
		return m.BuildUser
	}
	return ""
}

func (m *ImageInfo) GetBaseVersion() string {
	if m != nil {
		return m.BaseVersion
	}
	return ""
}

func (m *ImageInfo) GetSoftwareVersion() string {
	if m != nil {
		return m.SoftwareVersion
	}
	return ""
}

func (m *ImageInfo) GetNicmgrCompatVersion() string {
	if m != nil {
		return m.NicmgrCompatVersion
	}
	return ""
}

func (m *ImageInfo) GetKernelCompatVersion() string {
	if m != nil {
		return m.KernelCompatVersion
	}
	return ""
}

func (m *ImageInfo) GetPcieCompatVersion() string {
	if m != nil {
		return m.PcieCompatVersion
	}
	return ""
}

func (m *ImageInfo) GetDevConfCompatVersion() string {
	if m != nil {
		return m.DevConfCompatVersion
	}
	return ""
}

func (m *ImageInfo) GetImageVersion() int32 {
	if m != nil {
		return m.ImageVersion
	}
	return 0
}

type UbootFw struct {
	Image *ImageInfo `protobuf:"bytes,1,opt,name=Image" json:"image,omitempty"`
}

func (m *UbootFw) Reset()                    { *m = UbootFw{} }
func (m *UbootFw) String() string            { return proto.CompactTextString(m) }
func (*UbootFw) ProtoMessage()               {}
func (*UbootFw) Descriptor() ([]byte, []int) { return fileDescriptorFwVersion, []int{1} }

func (m *UbootFw) GetImage() *ImageInfo {
	if m != nil {
		return m.Image
	}
	return nil
}

type GoldFw struct {
	Image *ImageInfo `protobuf:"bytes,1,opt,name=Image" json:"kernel_fit,omitempty"`
	Uboot *ImageInfo `protobuf:"bytes,2,opt,name=Uboot" json:"uboot,omitempty"`
}

func (m *GoldFw) Reset()                    { *m = GoldFw{} }
func (m *GoldFw) String() string            { return proto.CompactTextString(m) }
func (*GoldFw) ProtoMessage()               {}
func (*GoldFw) Descriptor() ([]byte, []int) { return fileDescriptorFwVersion, []int{2} }

func (m *GoldFw) GetImage() *ImageInfo {
	if m != nil {
		return m.Image
	}
	return nil
}

func (m *GoldFw) GetUboot() *ImageInfo {
	if m != nil {
		return m.Uboot
	}
	return nil
}

type FwVersion struct {
	SystemImage *ImageInfo `protobuf:"bytes,1,opt,name=SystemImage" json:"system_image,omitempty"`
	KernelFit   *ImageInfo `protobuf:"bytes,2,opt,name=KernelFit" json:"kernel_fit,omitempty"`
	Uboot       *ImageInfo `protobuf:"bytes,3,opt,name=Uboot" json:"uboot,omitempty"`
}

func (m *FwVersion) Reset()                    { *m = FwVersion{} }
func (m *FwVersion) String() string            { return proto.CompactTextString(m) }
func (*FwVersion) ProtoMessage()               {}
func (*FwVersion) Descriptor() ([]byte, []int) { return fileDescriptorFwVersion, []int{3} }

func (m *FwVersion) GetSystemImage() *ImageInfo {
	if m != nil {
		return m.SystemImage
	}
	return nil
}

func (m *FwVersion) GetKernelFit() *ImageInfo {
	if m != nil {
		return m.KernelFit
	}
	return nil
}

func (m *FwVersion) GetUboot() *ImageInfo {
	if m != nil {
		return m.Uboot
	}
	return nil
}

// DSC Software object
type DSCInstalledSoftware struct {
	Uboot   *UbootFw   `protobuf:"bytes,1,opt,name=Uboot" json:"uboot,omitempty"`
	MainFwA *FwVersion `protobuf:"bytes,2,opt,name=MainFwA" json:"mainfwa,omitempty"`
	MainFwB *FwVersion `protobuf:"bytes,3,opt,name=MainFwB" json:"mainfwb,omitempty"`
	GoldFw  *GoldFw    `protobuf:"bytes,4,opt,name=GoldFw" json:"goldfw,omitempty"`
	DiagFw  *FwVersion `protobuf:"bytes,5,opt,name=DiagFw" json:"diagfw,omitempty"`
	// Needed for release A
	Boot0 *UbootFw `protobuf:"bytes,6,opt,name=Boot0" json:"boot0,omitempty"`
}

func (m *DSCInstalledSoftware) Reset()                    { *m = DSCInstalledSoftware{} }
func (m *DSCInstalledSoftware) String() string            { return proto.CompactTextString(m) }
func (*DSCInstalledSoftware) ProtoMessage()               {}
func (*DSCInstalledSoftware) Descriptor() ([]byte, []int) { return fileDescriptorFwVersion, []int{4} }

func (m *DSCInstalledSoftware) GetUboot() *UbootFw {
	if m != nil {
		return m.Uboot
	}
	return nil
}

func (m *DSCInstalledSoftware) GetMainFwA() *FwVersion {
	if m != nil {
		return m.MainFwA
	}
	return nil
}

func (m *DSCInstalledSoftware) GetMainFwB() *FwVersion {
	if m != nil {
		return m.MainFwB
	}
	return nil
}

func (m *DSCInstalledSoftware) GetGoldFw() *GoldFw {
	if m != nil {
		return m.GoldFw
	}
	return nil
}

func (m *DSCInstalledSoftware) GetDiagFw() *FwVersion {
	if m != nil {
		return m.DiagFw
	}
	return nil
}

func (m *DSCInstalledSoftware) GetBoot0() *UbootFw {
	if m != nil {
		return m.Boot0
	}
	return nil
}

type DSCRunningSoftware struct {
	Uboot   *UbootFw   `protobuf:"bytes,1,opt,name=Uboot" json:"uboot,omitempty"`
	MainFwA *FwVersion `protobuf:"bytes,2,opt,name=MainFwA" json:"mainfwa,omitempty"`
	MainFwB *FwVersion `protobuf:"bytes,3,opt,name=MainFwB" json:"mainfwb,omitempty"`
	Boot0   *UbootFw   `protobuf:"bytes,4,opt,name=Boot0" json:"boot0,omitempty"`
}

func (m *DSCRunningSoftware) Reset()                    { *m = DSCRunningSoftware{} }
func (m *DSCRunningSoftware) String() string            { return proto.CompactTextString(m) }
func (*DSCRunningSoftware) ProtoMessage()               {}
func (*DSCRunningSoftware) Descriptor() ([]byte, []int) { return fileDescriptorFwVersion, []int{5} }

func (m *DSCRunningSoftware) GetUboot() *UbootFw {
	if m != nil {
		return m.Uboot
	}
	return nil
}

func (m *DSCRunningSoftware) GetMainFwA() *FwVersion {
	if m != nil {
		return m.MainFwA
	}
	return nil
}

func (m *DSCRunningSoftware) GetMainFwB() *FwVersion {
	if m != nil {
		return m.MainFwB
	}
	return nil
}

func (m *DSCRunningSoftware) GetBoot0() *UbootFw {
	if m != nil {
		return m.Boot0
	}
	return nil
}

type DSCSoftwareVersionInfo struct {
	RunningFw           string                `protobuf:"bytes,1,opt,name=RunningFw,proto3" json:"running-fw,omitempty"`
	RunningFwVersion    string                `protobuf:"bytes,2,opt,name=RunningFwVersion,proto3" json:"running-fw-version,omitempty"`
	StartupFw           string                `protobuf:"bytes,3,opt,name=StartupFw,proto3" json:"startup-fw,omitempty"`
	StartupFwVersion    string                `protobuf:"bytes,4,opt,name=StartupFwVersion,proto3" json:"startup-fw-version,omitempty"`
	RunningUbootVersion string                `protobuf:"bytes,6,opt,name=RunningUbootVersion,proto3" json:"running-uboot,omitempty"`
	StartupUbootVersion string                `protobuf:"bytes,7,opt,name=StartupUbootVersion,proto3" json:"startup-uboot,omitempty"`
	InstalledImages     *DSCInstalledSoftware `protobuf:"bytes,8,opt,name=InstalledImages" json:"all-installed-fw,omitempty"`
}

func (m *DSCSoftwareVersionInfo) Reset()                    { *m = DSCSoftwareVersionInfo{} }
func (m *DSCSoftwareVersionInfo) String() string            { return proto.CompactTextString(m) }
func (*DSCSoftwareVersionInfo) ProtoMessage()               {}
func (*DSCSoftwareVersionInfo) Descriptor() ([]byte, []int) { return fileDescriptorFwVersion, []int{6} }

func (m *DSCSoftwareVersionInfo) GetRunningFw() string {
	if m != nil {
		return m.RunningFw
	}
	return ""
}

func (m *DSCSoftwareVersionInfo) GetRunningFwVersion() string {
	if m != nil {
		return m.RunningFwVersion
	}
	return ""
}

func (m *DSCSoftwareVersionInfo) GetStartupFw() string {
	if m != nil {
		return m.StartupFw
	}
	return ""
}

func (m *DSCSoftwareVersionInfo) GetStartupFwVersion() string {
	if m != nil {
		return m.StartupFwVersion
	}
	return ""
}

func (m *DSCSoftwareVersionInfo) GetRunningUbootVersion() string {
	if m != nil {
		return m.RunningUbootVersion
	}
	return ""
}

func (m *DSCSoftwareVersionInfo) GetStartupUbootVersion() string {
	if m != nil {
		return m.StartupUbootVersion
	}
	return ""
}

func (m *DSCSoftwareVersionInfo) GetInstalledImages() *DSCInstalledSoftware {
	if m != nil {
		return m.InstalledImages
	}
	return nil
}

func init() {
	proto.RegisterType((*ImageInfo)(nil), "nmd.ImageInfo")
	proto.RegisterType((*UbootFw)(nil), "nmd.UbootFw")
	proto.RegisterType((*GoldFw)(nil), "nmd.GoldFw")
	proto.RegisterType((*FwVersion)(nil), "nmd.FwVersion")
	proto.RegisterType((*DSCInstalledSoftware)(nil), "nmd.DSCInstalledSoftware")
	proto.RegisterType((*DSCRunningSoftware)(nil), "nmd.DSCRunningSoftware")
	proto.RegisterType((*DSCSoftwareVersionInfo)(nil), "nmd.DSCSoftwareVersionInfo")
}
func (m *ImageInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ImageInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.BuildDate) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintFwVersion(dAtA, i, uint64(len(m.BuildDate)))
		i += copy(dAtA[i:], m.BuildDate)
	}
	if len(m.BuildUser) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintFwVersion(dAtA, i, uint64(len(m.BuildUser)))
		i += copy(dAtA[i:], m.BuildUser)
	}
	if len(m.BaseVersion) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintFwVersion(dAtA, i, uint64(len(m.BaseVersion)))
		i += copy(dAtA[i:], m.BaseVersion)
	}
	if len(m.SoftwareVersion) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintFwVersion(dAtA, i, uint64(len(m.SoftwareVersion)))
		i += copy(dAtA[i:], m.SoftwareVersion)
	}
	if len(m.NicmgrCompatVersion) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintFwVersion(dAtA, i, uint64(len(m.NicmgrCompatVersion)))
		i += copy(dAtA[i:], m.NicmgrCompatVersion)
	}
	if len(m.KernelCompatVersion) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintFwVersion(dAtA, i, uint64(len(m.KernelCompatVersion)))
		i += copy(dAtA[i:], m.KernelCompatVersion)
	}
	if len(m.PcieCompatVersion) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintFwVersion(dAtA, i, uint64(len(m.PcieCompatVersion)))
		i += copy(dAtA[i:], m.PcieCompatVersion)
	}
	if len(m.DevConfCompatVersion) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintFwVersion(dAtA, i, uint64(len(m.DevConfCompatVersion)))
		i += copy(dAtA[i:], m.DevConfCompatVersion)
	}
	if m.ImageVersion != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintFwVersion(dAtA, i, uint64(m.ImageVersion))
	}
	return i, nil
}

func (m *UbootFw) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UbootFw) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Image != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintFwVersion(dAtA, i, uint64(m.Image.Size()))
		n1, err := m.Image.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	return i, nil
}

func (m *GoldFw) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GoldFw) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Image != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintFwVersion(dAtA, i, uint64(m.Image.Size()))
		n2, err := m.Image.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.Uboot != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintFwVersion(dAtA, i, uint64(m.Uboot.Size()))
		n3, err := m.Uboot.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}

func (m *FwVersion) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FwVersion) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SystemImage != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintFwVersion(dAtA, i, uint64(m.SystemImage.Size()))
		n4, err := m.SystemImage.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.KernelFit != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintFwVersion(dAtA, i, uint64(m.KernelFit.Size()))
		n5, err := m.KernelFit.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.Uboot != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintFwVersion(dAtA, i, uint64(m.Uboot.Size()))
		n6, err := m.Uboot.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}

func (m *DSCInstalledSoftware) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DSCInstalledSoftware) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uboot != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintFwVersion(dAtA, i, uint64(m.Uboot.Size()))
		n7, err := m.Uboot.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.MainFwA != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintFwVersion(dAtA, i, uint64(m.MainFwA.Size()))
		n8, err := m.MainFwA.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.MainFwB != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintFwVersion(dAtA, i, uint64(m.MainFwB.Size()))
		n9, err := m.MainFwB.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.GoldFw != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintFwVersion(dAtA, i, uint64(m.GoldFw.Size()))
		n10, err := m.GoldFw.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.DiagFw != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintFwVersion(dAtA, i, uint64(m.DiagFw.Size()))
		n11, err := m.DiagFw.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if m.Boot0 != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintFwVersion(dAtA, i, uint64(m.Boot0.Size()))
		n12, err := m.Boot0.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	return i, nil
}

func (m *DSCRunningSoftware) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DSCRunningSoftware) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uboot != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintFwVersion(dAtA, i, uint64(m.Uboot.Size()))
		n13, err := m.Uboot.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if m.MainFwA != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintFwVersion(dAtA, i, uint64(m.MainFwA.Size()))
		n14, err := m.MainFwA.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	if m.MainFwB != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintFwVersion(dAtA, i, uint64(m.MainFwB.Size()))
		n15, err := m.MainFwB.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	if m.Boot0 != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintFwVersion(dAtA, i, uint64(m.Boot0.Size()))
		n16, err := m.Boot0.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	return i, nil
}

func (m *DSCSoftwareVersionInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DSCSoftwareVersionInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RunningFw) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintFwVersion(dAtA, i, uint64(len(m.RunningFw)))
		i += copy(dAtA[i:], m.RunningFw)
	}
	if len(m.RunningFwVersion) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintFwVersion(dAtA, i, uint64(len(m.RunningFwVersion)))
		i += copy(dAtA[i:], m.RunningFwVersion)
	}
	if len(m.StartupFw) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintFwVersion(dAtA, i, uint64(len(m.StartupFw)))
		i += copy(dAtA[i:], m.StartupFw)
	}
	if len(m.StartupFwVersion) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintFwVersion(dAtA, i, uint64(len(m.StartupFwVersion)))
		i += copy(dAtA[i:], m.StartupFwVersion)
	}
	if len(m.RunningUbootVersion) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintFwVersion(dAtA, i, uint64(len(m.RunningUbootVersion)))
		i += copy(dAtA[i:], m.RunningUbootVersion)
	}
	if len(m.StartupUbootVersion) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintFwVersion(dAtA, i, uint64(len(m.StartupUbootVersion)))
		i += copy(dAtA[i:], m.StartupUbootVersion)
	}
	if m.InstalledImages != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintFwVersion(dAtA, i, uint64(m.InstalledImages.Size()))
		n17, err := m.InstalledImages.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	return i, nil
}

func encodeVarintFwVersion(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *ImageInfo) Size() (n int) {
	var l int
	_ = l
	l = len(m.BuildDate)
	if l > 0 {
		n += 1 + l + sovFwVersion(uint64(l))
	}
	l = len(m.BuildUser)
	if l > 0 {
		n += 1 + l + sovFwVersion(uint64(l))
	}
	l = len(m.BaseVersion)
	if l > 0 {
		n += 1 + l + sovFwVersion(uint64(l))
	}
	l = len(m.SoftwareVersion)
	if l > 0 {
		n += 1 + l + sovFwVersion(uint64(l))
	}
	l = len(m.NicmgrCompatVersion)
	if l > 0 {
		n += 1 + l + sovFwVersion(uint64(l))
	}
	l = len(m.KernelCompatVersion)
	if l > 0 {
		n += 1 + l + sovFwVersion(uint64(l))
	}
	l = len(m.PcieCompatVersion)
	if l > 0 {
		n += 1 + l + sovFwVersion(uint64(l))
	}
	l = len(m.DevConfCompatVersion)
	if l > 0 {
		n += 1 + l + sovFwVersion(uint64(l))
	}
	if m.ImageVersion != 0 {
		n += 1 + sovFwVersion(uint64(m.ImageVersion))
	}
	return n
}

func (m *UbootFw) Size() (n int) {
	var l int
	_ = l
	if m.Image != nil {
		l = m.Image.Size()
		n += 1 + l + sovFwVersion(uint64(l))
	}
	return n
}

func (m *GoldFw) Size() (n int) {
	var l int
	_ = l
	if m.Image != nil {
		l = m.Image.Size()
		n += 1 + l + sovFwVersion(uint64(l))
	}
	if m.Uboot != nil {
		l = m.Uboot.Size()
		n += 1 + l + sovFwVersion(uint64(l))
	}
	return n
}

func (m *FwVersion) Size() (n int) {
	var l int
	_ = l
	if m.SystemImage != nil {
		l = m.SystemImage.Size()
		n += 1 + l + sovFwVersion(uint64(l))
	}
	if m.KernelFit != nil {
		l = m.KernelFit.Size()
		n += 1 + l + sovFwVersion(uint64(l))
	}
	if m.Uboot != nil {
		l = m.Uboot.Size()
		n += 1 + l + sovFwVersion(uint64(l))
	}
	return n
}

func (m *DSCInstalledSoftware) Size() (n int) {
	var l int
	_ = l
	if m.Uboot != nil {
		l = m.Uboot.Size()
		n += 1 + l + sovFwVersion(uint64(l))
	}
	if m.MainFwA != nil {
		l = m.MainFwA.Size()
		n += 1 + l + sovFwVersion(uint64(l))
	}
	if m.MainFwB != nil {
		l = m.MainFwB.Size()
		n += 1 + l + sovFwVersion(uint64(l))
	}
	if m.GoldFw != nil {
		l = m.GoldFw.Size()
		n += 1 + l + sovFwVersion(uint64(l))
	}
	if m.DiagFw != nil {
		l = m.DiagFw.Size()
		n += 1 + l + sovFwVersion(uint64(l))
	}
	if m.Boot0 != nil {
		l = m.Boot0.Size()
		n += 1 + l + sovFwVersion(uint64(l))
	}
	return n
}

func (m *DSCRunningSoftware) Size() (n int) {
	var l int
	_ = l
	if m.Uboot != nil {
		l = m.Uboot.Size()
		n += 1 + l + sovFwVersion(uint64(l))
	}
	if m.MainFwA != nil {
		l = m.MainFwA.Size()
		n += 1 + l + sovFwVersion(uint64(l))
	}
	if m.MainFwB != nil {
		l = m.MainFwB.Size()
		n += 1 + l + sovFwVersion(uint64(l))
	}
	if m.Boot0 != nil {
		l = m.Boot0.Size()
		n += 1 + l + sovFwVersion(uint64(l))
	}
	return n
}

func (m *DSCSoftwareVersionInfo) Size() (n int) {
	var l int
	_ = l
	l = len(m.RunningFw)
	if l > 0 {
		n += 1 + l + sovFwVersion(uint64(l))
	}
	l = len(m.RunningFwVersion)
	if l > 0 {
		n += 1 + l + sovFwVersion(uint64(l))
	}
	l = len(m.StartupFw)
	if l > 0 {
		n += 1 + l + sovFwVersion(uint64(l))
	}
	l = len(m.StartupFwVersion)
	if l > 0 {
		n += 1 + l + sovFwVersion(uint64(l))
	}
	l = len(m.RunningUbootVersion)
	if l > 0 {
		n += 1 + l + sovFwVersion(uint64(l))
	}
	l = len(m.StartupUbootVersion)
	if l > 0 {
		n += 1 + l + sovFwVersion(uint64(l))
	}
	if m.InstalledImages != nil {
		l = m.InstalledImages.Size()
		n += 1 + l + sovFwVersion(uint64(l))
	}
	return n
}

func sovFwVersion(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozFwVersion(x uint64) (n int) {
	return sovFwVersion(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ImageInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFwVersion
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ImageInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ImageInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildDate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFwVersion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFwVersion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BuildDate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildUser", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFwVersion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFwVersion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BuildUser = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFwVersion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFwVersion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BaseVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SoftwareVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFwVersion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFwVersion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SoftwareVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NicmgrCompatVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFwVersion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFwVersion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NicmgrCompatVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KernelCompatVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFwVersion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFwVersion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KernelCompatVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PcieCompatVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFwVersion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFwVersion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PcieCompatVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DevConfCompatVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFwVersion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFwVersion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DevConfCompatVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImageVersion", wireType)
			}
			m.ImageVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFwVersion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ImageVersion |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFwVersion(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFwVersion
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UbootFw) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFwVersion
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UbootFw: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UbootFw: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFwVersion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFwVersion
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Image == nil {
				m.Image = &ImageInfo{}
			}
			if err := m.Image.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFwVersion(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFwVersion
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GoldFw) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFwVersion
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GoldFw: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GoldFw: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFwVersion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFwVersion
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Image == nil {
				m.Image = &ImageInfo{}
			}
			if err := m.Image.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uboot", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFwVersion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFwVersion
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Uboot == nil {
				m.Uboot = &ImageInfo{}
			}
			if err := m.Uboot.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFwVersion(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFwVersion
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FwVersion) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFwVersion
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FwVersion: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FwVersion: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SystemImage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFwVersion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFwVersion
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SystemImage == nil {
				m.SystemImage = &ImageInfo{}
			}
			if err := m.SystemImage.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KernelFit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFwVersion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFwVersion
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KernelFit == nil {
				m.KernelFit = &ImageInfo{}
			}
			if err := m.KernelFit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uboot", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFwVersion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFwVersion
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Uboot == nil {
				m.Uboot = &ImageInfo{}
			}
			if err := m.Uboot.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFwVersion(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFwVersion
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DSCInstalledSoftware) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFwVersion
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DSCInstalledSoftware: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DSCInstalledSoftware: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uboot", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFwVersion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFwVersion
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Uboot == nil {
				m.Uboot = &UbootFw{}
			}
			if err := m.Uboot.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MainFwA", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFwVersion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFwVersion
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MainFwA == nil {
				m.MainFwA = &FwVersion{}
			}
			if err := m.MainFwA.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MainFwB", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFwVersion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFwVersion
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MainFwB == nil {
				m.MainFwB = &FwVersion{}
			}
			if err := m.MainFwB.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GoldFw", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFwVersion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFwVersion
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GoldFw == nil {
				m.GoldFw = &GoldFw{}
			}
			if err := m.GoldFw.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiagFw", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFwVersion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFwVersion
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DiagFw == nil {
				m.DiagFw = &FwVersion{}
			}
			if err := m.DiagFw.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Boot0", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFwVersion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFwVersion
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Boot0 == nil {
				m.Boot0 = &UbootFw{}
			}
			if err := m.Boot0.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFwVersion(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFwVersion
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DSCRunningSoftware) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFwVersion
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DSCRunningSoftware: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DSCRunningSoftware: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uboot", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFwVersion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFwVersion
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Uboot == nil {
				m.Uboot = &UbootFw{}
			}
			if err := m.Uboot.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MainFwA", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFwVersion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFwVersion
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MainFwA == nil {
				m.MainFwA = &FwVersion{}
			}
			if err := m.MainFwA.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MainFwB", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFwVersion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFwVersion
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MainFwB == nil {
				m.MainFwB = &FwVersion{}
			}
			if err := m.MainFwB.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Boot0", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFwVersion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFwVersion
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Boot0 == nil {
				m.Boot0 = &UbootFw{}
			}
			if err := m.Boot0.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFwVersion(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFwVersion
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DSCSoftwareVersionInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFwVersion
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DSCSoftwareVersionInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DSCSoftwareVersionInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RunningFw", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFwVersion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFwVersion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RunningFw = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RunningFwVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFwVersion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFwVersion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RunningFwVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartupFw", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFwVersion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFwVersion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartupFw = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartupFwVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFwVersion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFwVersion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartupFwVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RunningUbootVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFwVersion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFwVersion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RunningUbootVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartupUbootVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFwVersion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFwVersion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartupUbootVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstalledImages", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFwVersion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFwVersion
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InstalledImages == nil {
				m.InstalledImages = &DSCInstalledSoftware{}
			}
			if err := m.InstalledImages.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFwVersion(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFwVersion
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipFwVersion(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowFwVersion
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFwVersion
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFwVersion
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthFwVersion
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowFwVersion
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipFwVersion(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthFwVersion = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowFwVersion   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("fw_version.proto", fileDescriptorFwVersion) }

var fileDescriptorFwVersion = []byte{
	// 856 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xdc, 0x96, 0xdd, 0x8e, 0xdb, 0x44,
	0x14, 0xc7, 0xe5, 0xee, 0x17, 0x99, 0xac, 0xd8, 0xed, 0xec, 0x52, 0x42, 0x28, 0xf1, 0x36, 0x08,
	0xa9, 0x17, 0x24, 0xae, 0x16, 0x09, 0x54, 0xa9, 0xa2, 0xc2, 0x09, 0x86, 0x15, 0x2d, 0x54, 0x8d,
	0x16, 0x89, 0xab, 0x68, 0x62, 0x8f, 0xcd, 0x08, 0x7b, 0x26, 0xb2, 0xc7, 0xb1, 0x7a, 0xdd, 0x1b,
	0x9e, 0x82, 0x5b, 0x5e, 0x85, 0x4b, 0x1e, 0x00, 0x59, 0x68, 0x2f, 0xfd, 0x14, 0xc8, 0xc7, 0xf1,
	0xb7, 0x13, 0xa9, 0xb7, 0xdc, 0x79, 0x66, 0xce, 0xff, 0xe7, 0x73, 0xce, 0x1c, 0x9f, 0x63, 0x74,
	0x6e, 0x47, 0xcb, 0x0d, 0xf5, 0x03, 0x26, 0xf8, 0x74, 0xed, 0x0b, 0x29, 0xf0, 0x01, 0xf7, 0xac,
	0xe1, 0x43, 0x47, 0x08, 0xc7, 0xa5, 0x1a, 0x59, 0x33, 0x8d, 0x70, 0x2e, 0x24, 0x91, 0x4c, 0xf0,
	0x20, 0x33, 0x19, 0x7e, 0xeb, 0x30, 0xf9, 0x6b, 0xb8, 0x9a, 0x9a, 0xc2, 0xd3, 0xd6, 0x94, 0x07,
	0x84, 0x5b, 0x42, 0x0b, 0x22, 0x6d, 0x43, 0x39, 0x33, 0xa9, 0x16, 0x4a, 0xe6, 0x06, 0xa9, 0xd4,
	0xa1, 0xbc, 0xaa, 0xd6, 0x18, 0x37, 0xdd, 0xd0, 0xa2, 0x39, 0x66, 0x52, 0xc1, 0x38, 0xc2, 0x11,
	0x1a, 0x6c, 0xaf, 0x42, 0x1b, 0x56, 0xb0, 0x80, 0xa7, 0xcc, 0x7c, 0xfc, 0xc7, 0x11, 0xea, 0xdd,
	0x78, 0xc4, 0xa1, 0x37, 0xdc, 0x16, 0xf8, 0x4b, 0xd4, 0xd3, 0x43, 0xe6, 0x5a, 0x73, 0x22, 0xe9,
	0x40, 0xb9, 0x52, 0x1e, 0xf7, 0xf4, 0x41, 0x12, 0xab, 0x97, 0xab, 0x74, 0x73, 0x69, 0x11, 0x49,
	0x3f, 0x17, 0x1e, 0x93, 0xd4, 0x5b, 0xcb, 0x37, 0xaf, 0x4b, 0xd3, 0x42, 0x77, 0x1b, 0x50, 0x7f,
	0x70, 0xaf, 0xa9, 0x0b, 0x03, 0xea, 0xb7, 0x74, 0xa9, 0x29, 0x7e, 0x86, 0xfa, 0x3a, 0x09, 0xe8,
	0xcf, 0x59, 0xae, 0x06, 0x07, 0xa0, 0x1c, 0x26, 0xb1, 0xfa, 0x60, 0x45, 0x02, 0x9a, 0xe7, 0xb0,
	0xa2, 0xad, 0x9a, 0xe3, 0xef, 0xd1, 0xd9, 0x42, 0xd8, 0x32, 0x22, 0x7e, 0x41, 0x38, 0x04, 0xc2,
	0x28, 0x89, 0xd5, 0x61, 0xb0, 0x3d, 0xea, 0xa0, 0x34, 0x65, 0xf8, 0x16, 0x5d, 0xfc, 0xc8, 0x4c,
	0xcf, 0xf1, 0x67, 0xc2, 0x5b, 0x13, 0x99, 0xd3, 0x8e, 0x80, 0xf6, 0x69, 0x12, 0xab, 0x2a, 0x87,
	0xe3, 0xa5, 0x09, 0xe7, 0x1d, 0xc8, 0x2e, 0x7d, 0x8a, 0xfd, 0x81, 0xfa, 0x9c, 0xba, 0x75, 0xec,
	0x71, 0x89, 0xfd, 0x0d, 0x8e, 0xf7, 0x60, 0x3b, 0xf4, 0xf8, 0x27, 0x74, 0xff, 0x95, 0xc9, 0x68,
	0x1d, 0x7a, 0x02, 0xd0, 0x47, 0x49, 0xac, 0x7e, 0xb2, 0x36, 0x19, 0xdd, 0x8d, 0x6c, 0x6b, 0xf1,
	0x2f, 0xe8, 0x72, 0x4e, 0x37, 0x33, 0xc1, 0xed, 0x3a, 0xf3, 0x3d, 0x60, 0x7e, 0x96, 0xc4, 0xea,
	0x23, 0x8b, 0x6e, 0x96, 0xa6, 0xe0, 0xf6, 0x6e, 0x6e, 0x27, 0x02, 0x3f, 0x47, 0xa7, 0x50, 0x5e,
	0x39, 0xb2, 0x77, 0xa5, 0x3c, 0x3e, 0xd2, 0x3f, 0x4e, 0x62, 0xf5, 0x43, 0x96, 0xee, 0x77, 0x80,
	0x6a, 0x82, 0xf1, 0x1c, 0x9d, 0xdc, 0xae, 0x84, 0x90, 0x46, 0x84, 0x9f, 0xa2, 0x23, 0x38, 0x82,
	0xca, 0xec, 0x5f, 0xbf, 0x3f, 0xe5, 0x9e, 0x35, 0x2d, 0x8a, 0x57, 0xbf, 0x48, 0x62, 0xf5, 0x0c,
	0xa0, 0x15, 0x58, 0xa6, 0x18, 0xbf, 0x55, 0xd0, 0xf1, 0x77, 0xc2, 0xb5, 0x8c, 0x08, 0x7f, 0xbd,
	0x9f, 0x02, 0x75, 0xbb, 0xbd, 0x16, 0x9b, 0xc9, 0x16, 0x2a, 0xf5, 0x02, 0x1c, 0x82, 0x3a, 0xdf,
	0xe1, 0x45, 0x98, 0x1a, 0x54, 0xa5, 0xa0, 0x18, 0xff, 0xa3, 0xa0, 0x9e, 0x11, 0xe5, 0xa9, 0x79,
	0x81, 0xfa, 0x8b, 0x37, 0x81, 0xa4, 0xde, 0x3e, 0x77, 0xe0, 0x63, 0x08, 0xc0, 0x6c, 0xd9, 0x8c,
	0xad, 0x2a, 0xc7, 0x06, 0xea, 0x65, 0xb5, 0x62, 0xb0, 0x5d, 0xae, 0xed, 0x0e, 0xad, 0x94, 0x96,
	0xe1, 0x1d, 0xbc, 0x73, 0x78, 0x6f, 0x0f, 0xd0, 0xe5, 0x7c, 0x31, 0xbb, 0xe1, 0x81, 0x24, 0xae,
	0x4b, 0xad, 0xfc, 0x2b, 0xc3, 0x5f, 0xe5, 0xcc, 0x2c, 0xc6, 0x53, 0x60, 0x6e, 0x6f, 0x75, 0x1f,
	0x11, 0x3f, 0x47, 0x27, 0x2f, 0x09, 0xe3, 0x46, 0xf4, 0x4d, 0x2d, 0xa4, 0x22, 0x87, 0xfa, 0x07,
	0x49, 0xac, 0xde, 0xf7, 0x08, 0xe3, 0x76, 0x44, 0x2a, 0xf2, 0x5c, 0x55, 0x02, 0xf4, 0x5a, 0x3c,
	0x9d, 0x80, 0x55, 0x1b, 0xa0, 0xe3, 0xa7, 0x79, 0xdd, 0x40, 0x6b, 0xe9, 0x5f, 0xf7, 0x41, 0x9f,
	0x6d, 0xe9, 0x97, 0x49, 0xac, 0x9e, 0x3b, 0xc2, 0xb5, 0xec, 0xa8, 0xa2, 0xcd, 0x0b, 0xed, 0x19,
	0x3a, 0x9e, 0x33, 0xe2, 0x18, 0x11, 0xf4, 0x91, 0xf6, 0xab, 0x41, 0x6d, 0x31, 0xe2, 0xd4, 0xd5,
	0x99, 0x26, 0xcd, 0x99, 0x2e, 0x84, 0x7c, 0x02, 0xdd, 0xa2, 0x33, 0x67, 0xe9, 0xf3, 0x93, 0x6a,
	0xce, 0xc0, 0x7e, 0xfc, 0xfb, 0x3d, 0x84, 0xe7, 0x8b, 0xd9, 0xeb, 0x90, 0x73, 0xc6, 0x9d, 0xff,
	0xc3, 0x1d, 0x14, 0xa9, 0x38, 0x7c, 0xc7, 0x54, 0xfc, 0x79, 0x88, 0x1e, 0xcc, 0x17, 0xb3, 0x46,
	0xb7, 0xcf, 0x27, 0xdd, 0x36, 0x43, 0x46, 0x54, 0x9d, 0x74, 0x7e, 0xb6, 0x39, 0xa9, 0xdd, 0x49,
	0x69, 0x8a, 0x5f, 0xa0, 0xf3, 0x62, 0x91, 0xf7, 0xb4, 0x6c, 0xe0, 0x5d, 0x25, 0xb1, 0xfa, 0xb0,
	0x94, 0x4f, 0xda, 0x8d, 0xad, 0xa5, 0x4c, 0xbd, 0x58, 0x48, 0xe2, 0xcb, 0x70, 0x6d, 0x44, 0xdb,
	0xe9, 0x07, 0x5e, 0x04, 0xd9, 0x66, 0xc3, 0x8b, 0xc2, 0x34, 0xf5, 0xa2, 0x58, 0xd4, 0x47, 0x1f,
	0x78, 0x51, 0xca, 0xbb, 0xbc, 0x68, 0x2a, 0xf1, 0x4b, 0x74, 0xb1, 0xf5, 0x0c, 0x92, 0x5a, 0x1f,
	0x53, 0xd0, 0xaa, 0xf3, 0xb0, 0x9a, 0x25, 0xd2, 0xa5, 0x4b, 0x71, 0xdb, 0x57, 0xd4, 0x70, 0x27,
	0x25, 0x2e, 0xf7, 0xaf, 0x85, 0xeb, 0xd0, 0x61, 0x13, 0x9d, 0x15, 0x1d, 0x05, 0xfa, 0x50, 0x00,
	0x73, 0xa9, 0x7f, 0xfd, 0x11, 0xd4, 0x41, 0x57, 0xc3, 0xc9, 0x7e, 0x00, 0x88, 0xeb, 0x4e, 0x58,
	0x7e, 0x54, 0x4f, 0x65, 0x93, 0xa8, 0x9f, 0xfe, 0x75, 0x37, 0x52, 0xfe, 0xbe, 0x1b, 0x29, 0xff,
	0xde, 0x8d, 0x94, 0x57, 0xca, 0xea, 0x18, 0xfe, 0x8e, 0xbe, 0xf8, 0x2f, 0x00, 0x00, 0xff, 0xff,
	0xd0, 0x15, 0x24, 0xe0, 0xca, 0x09, 0x00, 0x00,
}
