// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: nmd.proto

/*
	Package nmd is a generated protocol buffer package.

	Service name

	It is generated from these files:
		nmd.proto

	It has these top-level messages:
		DistributedServiceCardFru
		DistributedServiceCard
		DistributedServiceCardSpec
		DistributedServiceCardStatus
		DistributedServiceCardCmdExecute
*/
package nmd

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "google.golang.org/genproto/googleapis/api/annotations"
import _ "github.com/pensando/sw/venice/utils/apigen/annotations"
import _ "github.com/gogo/protobuf/gogoproto"
import api "github.com/pensando/sw/api"
import cluster2 "github.com/pensando/sw/api/generated/cluster"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// Operational mode of a DistributedServiceCard
type MgmtMode int32

const (
	MgmtMode_HOST    MgmtMode = 0
	MgmtMode_NETWORK MgmtMode = 1
)

var MgmtMode_name = map[int32]string{
	0: "HOST",
	1: "NETWORK",
}
var MgmtMode_value = map[string]int32{
	"HOST":    0,
	"NETWORK": 1,
}

func (x MgmtMode) String() string {
	return proto.EnumName(MgmtMode_name, int32(x))
}
func (MgmtMode) EnumDescriptor() ([]byte, []int) { return fileDescriptorNmd, []int{0} }

// Network Connectivity Mode (only if network managed)
type NetworkMode int32

const (
	NetworkMode_NONE   NetworkMode = 0
	NetworkMode_OOB    NetworkMode = 1
	NetworkMode_INBAND NetworkMode = 2
)

var NetworkMode_name = map[int32]string{
	0: "NONE",
	1: "OOB",
	2: "INBAND",
}
var NetworkMode_value = map[string]int32{
	"NONE":   0,
	"OOB":    1,
	"INBAND": 2,
}

func (x NetworkMode) String() string {
	return proto.EnumName(NetworkMode_name, int32(x))
}
func (NetworkMode) EnumDescriptor() ([]byte, []int) { return fileDescriptorNmd, []int{1} }

type DistributedServiceCardStatus_Transition int32

const (
	DistributedServiceCardStatus_NONE                                DistributedServiceCardStatus_Transition = 0
	DistributedServiceCardStatus_DHCP_SENT                           DistributedServiceCardStatus_Transition = 1
	DistributedServiceCardStatus_DHCP_DONE                           DistributedServiceCardStatus_Transition = 2
	DistributedServiceCardStatus_DHCP_TIMEDOUT                       DistributedServiceCardStatus_Transition = 3
	DistributedServiceCardStatus_MISSING_VENDOR_SPECIFIED_ATTRIBUTES DistributedServiceCardStatus_Transition = 4
	DistributedServiceCardStatus_VENICE_REGISTRATION_SENT            DistributedServiceCardStatus_Transition = 5
	DistributedServiceCardStatus_VENICE_REGISTRATION_DONE            DistributedServiceCardStatus_Transition = 6
	DistributedServiceCardStatus_VENICE_UNREACHABLE                  DistributedServiceCardStatus_Transition = 7
	DistributedServiceCardStatus_REBOOT_PENDING                      DistributedServiceCardStatus_Transition = 8
)

var DistributedServiceCardStatus_Transition_name = map[int32]string{
	0: "NONE",
	1: "DHCP_SENT",
	2: "DHCP_DONE",
	3: "DHCP_TIMEDOUT",
	4: "MISSING_VENDOR_SPECIFIED_ATTRIBUTES",
	5: "VENICE_REGISTRATION_SENT",
	6: "VENICE_REGISTRATION_DONE",
	7: "VENICE_UNREACHABLE",
	8: "REBOOT_PENDING",
}
var DistributedServiceCardStatus_Transition_value = map[string]int32{
	"NONE":                                0,
	"DHCP_SENT":                           1,
	"DHCP_DONE":                           2,
	"DHCP_TIMEDOUT":                       3,
	"MISSING_VENDOR_SPECIFIED_ATTRIBUTES": 4,
	"VENICE_REGISTRATION_SENT":            5,
	"VENICE_REGISTRATION_DONE":            6,
	"VENICE_UNREACHABLE":                  7,
	"REBOOT_PENDING":                      8,
}

func (x DistributedServiceCardStatus_Transition) String() string {
	return proto.EnumName(DistributedServiceCardStatus_Transition_name, int32(x))
}
func (DistributedServiceCardStatus_Transition) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorNmd, []int{3, 0}
}

// DistributedServiceCard Fru object
type DistributedServiceCardFru struct {
	ManufacturingDate string `protobuf:"bytes,1,opt,name=ManufacturingDate,proto3" json:"manufacturing-date,omitempty"`
	Manufacturer      string `protobuf:"bytes,2,opt,name=Manufacturer,proto3" json:"manufacturer,omitempty"`
	ProductName       string `protobuf:"bytes,3,opt,name=ProductName,proto3" json:"product-name,omitempty"`
	SerialNum         string `protobuf:"bytes,4,opt,name=SerialNum,proto3" json:"serial-number,omitempty"`
	PartNum           string `protobuf:"bytes,5,opt,name=PartNum,proto3" json:"part-number,omitempty"`
	BoardId           string `protobuf:"bytes,6,opt,name=BoardId,proto3" json:"board-id,omitempty"`
	EngChangeLevel    string `protobuf:"bytes,7,opt,name=EngChangeLevel,proto3" json:"change-level,omitempty"`
	NumMacAddr        string `protobuf:"bytes,8,opt,name=NumMacAddr,proto3" json:"number-mac-addresses,omitempty"`
	MacStr            string `protobuf:"bytes,9,opt,name=MacStr,proto3" json:"mac-string,omitempty"`
}

func (m *DistributedServiceCardFru) Reset()                    { *m = DistributedServiceCardFru{} }
func (m *DistributedServiceCardFru) String() string            { return proto.CompactTextString(m) }
func (*DistributedServiceCardFru) ProtoMessage()               {}
func (*DistributedServiceCardFru) Descriptor() ([]byte, []int) { return fileDescriptorNmd, []int{0} }

func (m *DistributedServiceCardFru) GetManufacturingDate() string {
	if m != nil {
		return m.ManufacturingDate
	}
	return ""
}

func (m *DistributedServiceCardFru) GetManufacturer() string {
	if m != nil {
		return m.Manufacturer
	}
	return ""
}

func (m *DistributedServiceCardFru) GetProductName() string {
	if m != nil {
		return m.ProductName
	}
	return ""
}

func (m *DistributedServiceCardFru) GetSerialNum() string {
	if m != nil {
		return m.SerialNum
	}
	return ""
}

func (m *DistributedServiceCardFru) GetPartNum() string {
	if m != nil {
		return m.PartNum
	}
	return ""
}

func (m *DistributedServiceCardFru) GetBoardId() string {
	if m != nil {
		return m.BoardId
	}
	return ""
}

func (m *DistributedServiceCardFru) GetEngChangeLevel() string {
	if m != nil {
		return m.EngChangeLevel
	}
	return ""
}

func (m *DistributedServiceCardFru) GetNumMacAddr() string {
	if m != nil {
		return m.NumMacAddr
	}
	return ""
}

func (m *DistributedServiceCardFru) GetMacStr() string {
	if m != nil {
		return m.MacStr
	}
	return ""
}

// DistributedServiceCard config object
type DistributedServiceCard struct {
	api.TypeMeta   `protobuf:"bytes,1,opt,name=T,embedded=T" json:",inline"`
	api.ObjectMeta `protobuf:"bytes,2,opt,name=O,embedded=O" json:"meta,omitempty"`
	// Spec contains the configuration of the NIC.
	Spec DistributedServiceCardSpec `protobuf:"bytes,3,opt,name=Spec" json:"spec,omitempty"`
	// Status contains the current state of the NIC.
	Status DistributedServiceCardStatus `protobuf:"bytes,4,opt,name=Status" json:"status,omitempty"`
}

func (m *DistributedServiceCard) Reset()                    { *m = DistributedServiceCard{} }
func (m *DistributedServiceCard) String() string            { return proto.CompactTextString(m) }
func (*DistributedServiceCard) ProtoMessage()               {}
func (*DistributedServiceCard) Descriptor() ([]byte, []int) { return fileDescriptorNmd, []int{1} }

func (m *DistributedServiceCard) GetSpec() DistributedServiceCardSpec {
	if m != nil {
		return m.Spec
	}
	return DistributedServiceCardSpec{}
}

func (m *DistributedServiceCard) GetStatus() DistributedServiceCardStatus {
	if m != nil {
		return m.Status
	}
	return DistributedServiceCardStatus{}
}

// DistributedServiceCardSpec contains initial bootstrap configuration of the DistributedServiceCard I/O subsystem
type DistributedServiceCardSpec struct {
	// PrimaryMAC is the MAC address of the primary PF exposed by DSC
	PrimaryMAC string `protobuf:"bytes,1,opt,name=PrimaryMAC,proto3" json:"primary-mac,omitempty"`
	// ID is used as a user friendly identifier in logs/events
	ID string `protobuf:"bytes,2,opt,name=ID,proto3" json:"ID,omitempty"`
	// IPConfig defines the static IP configuration. If not specified, DHCP will be attempted
	IPConfig *cluster2.IPConfig `protobuf:"bytes,3,opt,name=IPConfig" json:"ip-config,omitempty"`
	// Operational mode of the NIC
	Mode string `protobuf:"bytes,4,opt,name=Mode,proto3" json:"mode"`
	// Operational mode of the NIC
	NetworkMode string `protobuf:"bytes,5,opt,name=NetworkMode,proto3" json:"network-mode"`
	// MgmtVlan defines the vlan to be used in network managed mode. The default of 0
	// implies OOB 1G mgmt port is used for management. A non 0 vlan switches the
	// management port to a vlan on data ports.
	MgmtVlan uint32 `protobuf:"varint,6,opt,name=MgmtVlan,proto3" json:"vlan,omitempty"`
	// Controllers contains the list of controller IPs or Hostnames
	Controllers []string `protobuf:"bytes,7,rep,name=Controllers" json:"controllers,omitempty"`
	// DSCProfile captures the profile that is associated with this DistributedServiceCard
	DSCProfile string `protobuf:"bytes,8,opt,name=DSCProfile,proto3" json:"device-profile,omitempty"`
	// IP of bond0 interface for mirroring applications
	InbandIPConfig *cluster2.IPConfig `protobuf:"bytes,9,opt,name=InbandIPConfig" json:"inband-ip-config,omitempty"`
}

func (m *DistributedServiceCardSpec) Reset()                    { *m = DistributedServiceCardSpec{} }
func (m *DistributedServiceCardSpec) String() string            { return proto.CompactTextString(m) }
func (*DistributedServiceCardSpec) ProtoMessage()               {}
func (*DistributedServiceCardSpec) Descriptor() ([]byte, []int) { return fileDescriptorNmd, []int{2} }

func (m *DistributedServiceCardSpec) GetPrimaryMAC() string {
	if m != nil {
		return m.PrimaryMAC
	}
	return ""
}

func (m *DistributedServiceCardSpec) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

func (m *DistributedServiceCardSpec) GetIPConfig() *cluster2.IPConfig {
	if m != nil {
		return m.IPConfig
	}
	return nil
}

func (m *DistributedServiceCardSpec) GetMode() string {
	if m != nil {
		return m.Mode
	}
	return ""
}

func (m *DistributedServiceCardSpec) GetNetworkMode() string {
	if m != nil {
		return m.NetworkMode
	}
	return ""
}

func (m *DistributedServiceCardSpec) GetMgmtVlan() uint32 {
	if m != nil {
		return m.MgmtVlan
	}
	return 0
}

func (m *DistributedServiceCardSpec) GetControllers() []string {
	if m != nil {
		return m.Controllers
	}
	return nil
}

func (m *DistributedServiceCardSpec) GetDSCProfile() string {
	if m != nil {
		return m.DSCProfile
	}
	return ""
}

func (m *DistributedServiceCardSpec) GetInbandIPConfig() *cluster2.IPConfig {
	if m != nil {
		return m.InbandIPConfig
	}
	return nil
}

// DistributedServiceCardStatus contains current status of a DistributedServiceCard I/O subsystem
type DistributedServiceCardStatus struct {
	// Current phase of the NIC adapter in the system
	AdmissionPhase string             `protobuf:"bytes,1,opt,name=AdmissionPhase,proto3" json:"phase,omitempty"`
	IPConfig       *cluster2.IPConfig `protobuf:"bytes,2,opt,name=IPConfig" json:"ip-config,omitempty"`
	// Resolved Controllers/Venice IPs
	Controllers     []string `protobuf:"bytes,3,rep,name=Controllers" json:"controllers,omitempty"`
	TransitionPhase string   `protobuf:"bytes,4,opt,name=TransitionPhase,proto3" json:"transition-phase,omitempty"`
	// Operational mode of the NIC
	Mode string `protobuf:"bytes,5,opt,name=Mode,proto3" json:"mode"`
	// FRU information read from FRU.json
	Fru *DistributedServiceCardFru `protobuf:"bytes,7,opt,name=Fru" json:"fru,omitempty"`
	// DistributedServiceCard generated DSC name which should be used as UUID for DistributedServiceCard
	DSCName string `protobuf:"bytes,8,opt,name=DSCName,proto3" json:"dsc-name,omitempty"`
	// TimeZone
	TimeZone string `protobuf:"bytes,9,opt,name=TimeZone,proto3" json:"timezone,omitempty"`
	// The reason why the DSC is not in admitted phase, if known
	AdmissionPhaseReason string `protobuf:"bytes,10,opt,name=AdmissionPhaseReason,proto3" json:"adm-phase-reason,omitempty"`
	// ManagementInterface where Venice was discovered
	ManagementInterface string `protobuf:"bytes,11,opt,name=ManagementInterface,proto3" json:"management-interface,omitempty"`
	// IP of bond0 interface for mirroring applications
	InbandIPConfig *cluster2.IPConfig `protobuf:"bytes,12,opt,name=InbandIPConfig" json:"inband-ip-config,omitempty"`
}

func (m *DistributedServiceCardStatus) Reset()                    { *m = DistributedServiceCardStatus{} }
func (m *DistributedServiceCardStatus) String() string            { return proto.CompactTextString(m) }
func (*DistributedServiceCardStatus) ProtoMessage()               {}
func (*DistributedServiceCardStatus) Descriptor() ([]byte, []int) { return fileDescriptorNmd, []int{3} }

func (m *DistributedServiceCardStatus) GetAdmissionPhase() string {
	if m != nil {
		return m.AdmissionPhase
	}
	return ""
}

func (m *DistributedServiceCardStatus) GetIPConfig() *cluster2.IPConfig {
	if m != nil {
		return m.IPConfig
	}
	return nil
}

func (m *DistributedServiceCardStatus) GetControllers() []string {
	if m != nil {
		return m.Controllers
	}
	return nil
}

func (m *DistributedServiceCardStatus) GetTransitionPhase() string {
	if m != nil {
		return m.TransitionPhase
	}
	return ""
}

func (m *DistributedServiceCardStatus) GetMode() string {
	if m != nil {
		return m.Mode
	}
	return ""
}

func (m *DistributedServiceCardStatus) GetFru() *DistributedServiceCardFru {
	if m != nil {
		return m.Fru
	}
	return nil
}

func (m *DistributedServiceCardStatus) GetDSCName() string {
	if m != nil {
		return m.DSCName
	}
	return ""
}

func (m *DistributedServiceCardStatus) GetTimeZone() string {
	if m != nil {
		return m.TimeZone
	}
	return ""
}

func (m *DistributedServiceCardStatus) GetAdmissionPhaseReason() string {
	if m != nil {
		return m.AdmissionPhaseReason
	}
	return ""
}

func (m *DistributedServiceCardStatus) GetManagementInterface() string {
	if m != nil {
		return m.ManagementInterface
	}
	return ""
}

func (m *DistributedServiceCardStatus) GetInbandIPConfig() *cluster2.IPConfig {
	if m != nil {
		return m.InbandIPConfig
	}
	return nil
}

// DistributedServiceCardCmdExecute contains information on what command to execute
type DistributedServiceCardCmdExecute struct {
	// Executable to run on DSC side
	Executable string `protobuf:"bytes,1,opt,name=Executable,proto3" json:"executable,omitempty"`
	// Flags for the executable to run on DSC side
	Opts string `protobuf:"bytes,2,opt,name=Opts,proto3" json:"opts,omitempty"`
	// Environment variables to set on DSC side to execute the command
	Env string `protobuf:"bytes,3,opt,name=Env,proto3" json:"env,omitempty"`
}

func (m *DistributedServiceCardCmdExecute) Reset()         { *m = DistributedServiceCardCmdExecute{} }
func (m *DistributedServiceCardCmdExecute) String() string { return proto.CompactTextString(m) }
func (*DistributedServiceCardCmdExecute) ProtoMessage()    {}
func (*DistributedServiceCardCmdExecute) Descriptor() ([]byte, []int) {
	return fileDescriptorNmd, []int{4}
}

func (m *DistributedServiceCardCmdExecute) GetExecutable() string {
	if m != nil {
		return m.Executable
	}
	return ""
}

func (m *DistributedServiceCardCmdExecute) GetOpts() string {
	if m != nil {
		return m.Opts
	}
	return ""
}

func (m *DistributedServiceCardCmdExecute) GetEnv() string {
	if m != nil {
		return m.Env
	}
	return ""
}

func init() {
	proto.RegisterType((*DistributedServiceCardFru)(nil), "nmd.DistributedServiceCardFru")
	proto.RegisterType((*DistributedServiceCard)(nil), "nmd.DistributedServiceCard")
	proto.RegisterType((*DistributedServiceCardSpec)(nil), "nmd.DistributedServiceCardSpec")
	proto.RegisterType((*DistributedServiceCardStatus)(nil), "nmd.DistributedServiceCardStatus")
	proto.RegisterType((*DistributedServiceCardCmdExecute)(nil), "nmd.DistributedServiceCardCmdExecute")
	proto.RegisterEnum("nmd.MgmtMode", MgmtMode_name, MgmtMode_value)
	proto.RegisterEnum("nmd.NetworkMode", NetworkMode_name, NetworkMode_value)
	proto.RegisterEnum("nmd.DistributedServiceCardStatus_Transition", DistributedServiceCardStatus_Transition_name, DistributedServiceCardStatus_Transition_value)
}
func (m *DistributedServiceCardFru) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DistributedServiceCardFru) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ManufacturingDate) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNmd(dAtA, i, uint64(len(m.ManufacturingDate)))
		i += copy(dAtA[i:], m.ManufacturingDate)
	}
	if len(m.Manufacturer) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNmd(dAtA, i, uint64(len(m.Manufacturer)))
		i += copy(dAtA[i:], m.Manufacturer)
	}
	if len(m.ProductName) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintNmd(dAtA, i, uint64(len(m.ProductName)))
		i += copy(dAtA[i:], m.ProductName)
	}
	if len(m.SerialNum) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintNmd(dAtA, i, uint64(len(m.SerialNum)))
		i += copy(dAtA[i:], m.SerialNum)
	}
	if len(m.PartNum) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintNmd(dAtA, i, uint64(len(m.PartNum)))
		i += copy(dAtA[i:], m.PartNum)
	}
	if len(m.BoardId) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintNmd(dAtA, i, uint64(len(m.BoardId)))
		i += copy(dAtA[i:], m.BoardId)
	}
	if len(m.EngChangeLevel) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintNmd(dAtA, i, uint64(len(m.EngChangeLevel)))
		i += copy(dAtA[i:], m.EngChangeLevel)
	}
	if len(m.NumMacAddr) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintNmd(dAtA, i, uint64(len(m.NumMacAddr)))
		i += copy(dAtA[i:], m.NumMacAddr)
	}
	if len(m.MacStr) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintNmd(dAtA, i, uint64(len(m.MacStr)))
		i += copy(dAtA[i:], m.MacStr)
	}
	return i, nil
}

func (m *DistributedServiceCard) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DistributedServiceCard) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintNmd(dAtA, i, uint64(m.TypeMeta.Size()))
	n1, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n1
	dAtA[i] = 0x12
	i++
	i = encodeVarintNmd(dAtA, i, uint64(m.ObjectMeta.Size()))
	n2, err := m.ObjectMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n2
	dAtA[i] = 0x1a
	i++
	i = encodeVarintNmd(dAtA, i, uint64(m.Spec.Size()))
	n3, err := m.Spec.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n3
	dAtA[i] = 0x22
	i++
	i = encodeVarintNmd(dAtA, i, uint64(m.Status.Size()))
	n4, err := m.Status.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n4
	return i, nil
}

func (m *DistributedServiceCardSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DistributedServiceCardSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PrimaryMAC) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNmd(dAtA, i, uint64(len(m.PrimaryMAC)))
		i += copy(dAtA[i:], m.PrimaryMAC)
	}
	if len(m.ID) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNmd(dAtA, i, uint64(len(m.ID)))
		i += copy(dAtA[i:], m.ID)
	}
	if m.IPConfig != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintNmd(dAtA, i, uint64(m.IPConfig.Size()))
		n5, err := m.IPConfig.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if len(m.Mode) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintNmd(dAtA, i, uint64(len(m.Mode)))
		i += copy(dAtA[i:], m.Mode)
	}
	if len(m.NetworkMode) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintNmd(dAtA, i, uint64(len(m.NetworkMode)))
		i += copy(dAtA[i:], m.NetworkMode)
	}
	if m.MgmtVlan != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintNmd(dAtA, i, uint64(m.MgmtVlan))
	}
	if len(m.Controllers) > 0 {
		for _, s := range m.Controllers {
			dAtA[i] = 0x3a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.DSCProfile) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintNmd(dAtA, i, uint64(len(m.DSCProfile)))
		i += copy(dAtA[i:], m.DSCProfile)
	}
	if m.InbandIPConfig != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintNmd(dAtA, i, uint64(m.InbandIPConfig.Size()))
		n6, err := m.InbandIPConfig.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}

func (m *DistributedServiceCardStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DistributedServiceCardStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AdmissionPhase) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNmd(dAtA, i, uint64(len(m.AdmissionPhase)))
		i += copy(dAtA[i:], m.AdmissionPhase)
	}
	if m.IPConfig != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNmd(dAtA, i, uint64(m.IPConfig.Size()))
		n7, err := m.IPConfig.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if len(m.Controllers) > 0 {
		for _, s := range m.Controllers {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.TransitionPhase) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintNmd(dAtA, i, uint64(len(m.TransitionPhase)))
		i += copy(dAtA[i:], m.TransitionPhase)
	}
	if len(m.Mode) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintNmd(dAtA, i, uint64(len(m.Mode)))
		i += copy(dAtA[i:], m.Mode)
	}
	if m.Fru != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintNmd(dAtA, i, uint64(m.Fru.Size()))
		n8, err := m.Fru.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if len(m.DSCName) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintNmd(dAtA, i, uint64(len(m.DSCName)))
		i += copy(dAtA[i:], m.DSCName)
	}
	if len(m.TimeZone) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintNmd(dAtA, i, uint64(len(m.TimeZone)))
		i += copy(dAtA[i:], m.TimeZone)
	}
	if len(m.AdmissionPhaseReason) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintNmd(dAtA, i, uint64(len(m.AdmissionPhaseReason)))
		i += copy(dAtA[i:], m.AdmissionPhaseReason)
	}
	if len(m.ManagementInterface) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintNmd(dAtA, i, uint64(len(m.ManagementInterface)))
		i += copy(dAtA[i:], m.ManagementInterface)
	}
	if m.InbandIPConfig != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintNmd(dAtA, i, uint64(m.InbandIPConfig.Size()))
		n9, err := m.InbandIPConfig.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	return i, nil
}

func (m *DistributedServiceCardCmdExecute) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DistributedServiceCardCmdExecute) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Executable) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNmd(dAtA, i, uint64(len(m.Executable)))
		i += copy(dAtA[i:], m.Executable)
	}
	if len(m.Opts) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNmd(dAtA, i, uint64(len(m.Opts)))
		i += copy(dAtA[i:], m.Opts)
	}
	if len(m.Env) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintNmd(dAtA, i, uint64(len(m.Env)))
		i += copy(dAtA[i:], m.Env)
	}
	return i, nil
}

func encodeVarintNmd(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *DistributedServiceCardFru) Size() (n int) {
	var l int
	_ = l
	l = len(m.ManufacturingDate)
	if l > 0 {
		n += 1 + l + sovNmd(uint64(l))
	}
	l = len(m.Manufacturer)
	if l > 0 {
		n += 1 + l + sovNmd(uint64(l))
	}
	l = len(m.ProductName)
	if l > 0 {
		n += 1 + l + sovNmd(uint64(l))
	}
	l = len(m.SerialNum)
	if l > 0 {
		n += 1 + l + sovNmd(uint64(l))
	}
	l = len(m.PartNum)
	if l > 0 {
		n += 1 + l + sovNmd(uint64(l))
	}
	l = len(m.BoardId)
	if l > 0 {
		n += 1 + l + sovNmd(uint64(l))
	}
	l = len(m.EngChangeLevel)
	if l > 0 {
		n += 1 + l + sovNmd(uint64(l))
	}
	l = len(m.NumMacAddr)
	if l > 0 {
		n += 1 + l + sovNmd(uint64(l))
	}
	l = len(m.MacStr)
	if l > 0 {
		n += 1 + l + sovNmd(uint64(l))
	}
	return n
}

func (m *DistributedServiceCard) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovNmd(uint64(l))
	l = m.ObjectMeta.Size()
	n += 1 + l + sovNmd(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovNmd(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovNmd(uint64(l))
	return n
}

func (m *DistributedServiceCardSpec) Size() (n int) {
	var l int
	_ = l
	l = len(m.PrimaryMAC)
	if l > 0 {
		n += 1 + l + sovNmd(uint64(l))
	}
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovNmd(uint64(l))
	}
	if m.IPConfig != nil {
		l = m.IPConfig.Size()
		n += 1 + l + sovNmd(uint64(l))
	}
	l = len(m.Mode)
	if l > 0 {
		n += 1 + l + sovNmd(uint64(l))
	}
	l = len(m.NetworkMode)
	if l > 0 {
		n += 1 + l + sovNmd(uint64(l))
	}
	if m.MgmtVlan != 0 {
		n += 1 + sovNmd(uint64(m.MgmtVlan))
	}
	if len(m.Controllers) > 0 {
		for _, s := range m.Controllers {
			l = len(s)
			n += 1 + l + sovNmd(uint64(l))
		}
	}
	l = len(m.DSCProfile)
	if l > 0 {
		n += 1 + l + sovNmd(uint64(l))
	}
	if m.InbandIPConfig != nil {
		l = m.InbandIPConfig.Size()
		n += 1 + l + sovNmd(uint64(l))
	}
	return n
}

func (m *DistributedServiceCardStatus) Size() (n int) {
	var l int
	_ = l
	l = len(m.AdmissionPhase)
	if l > 0 {
		n += 1 + l + sovNmd(uint64(l))
	}
	if m.IPConfig != nil {
		l = m.IPConfig.Size()
		n += 1 + l + sovNmd(uint64(l))
	}
	if len(m.Controllers) > 0 {
		for _, s := range m.Controllers {
			l = len(s)
			n += 1 + l + sovNmd(uint64(l))
		}
	}
	l = len(m.TransitionPhase)
	if l > 0 {
		n += 1 + l + sovNmd(uint64(l))
	}
	l = len(m.Mode)
	if l > 0 {
		n += 1 + l + sovNmd(uint64(l))
	}
	if m.Fru != nil {
		l = m.Fru.Size()
		n += 1 + l + sovNmd(uint64(l))
	}
	l = len(m.DSCName)
	if l > 0 {
		n += 1 + l + sovNmd(uint64(l))
	}
	l = len(m.TimeZone)
	if l > 0 {
		n += 1 + l + sovNmd(uint64(l))
	}
	l = len(m.AdmissionPhaseReason)
	if l > 0 {
		n += 1 + l + sovNmd(uint64(l))
	}
	l = len(m.ManagementInterface)
	if l > 0 {
		n += 1 + l + sovNmd(uint64(l))
	}
	if m.InbandIPConfig != nil {
		l = m.InbandIPConfig.Size()
		n += 1 + l + sovNmd(uint64(l))
	}
	return n
}

func (m *DistributedServiceCardCmdExecute) Size() (n int) {
	var l int
	_ = l
	l = len(m.Executable)
	if l > 0 {
		n += 1 + l + sovNmd(uint64(l))
	}
	l = len(m.Opts)
	if l > 0 {
		n += 1 + l + sovNmd(uint64(l))
	}
	l = len(m.Env)
	if l > 0 {
		n += 1 + l + sovNmd(uint64(l))
	}
	return n
}

func sovNmd(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozNmd(x uint64) (n int) {
	return sovNmd(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *DistributedServiceCardFru) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNmd
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DistributedServiceCardFru: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DistributedServiceCardFru: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ManufacturingDate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ManufacturingDate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Manufacturer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Manufacturer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProductName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProductName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SerialNum", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SerialNum = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartNum", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PartNum = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BoardId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BoardId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EngChangeLevel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EngChangeLevel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumMacAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NumMacAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MacStr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MacStr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNmd(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNmd
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DistributedServiceCard) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNmd
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DistributedServiceCard: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DistributedServiceCard: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNmd(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNmd
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DistributedServiceCardSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNmd
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DistributedServiceCardSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DistributedServiceCardSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrimaryMAC", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrimaryMAC = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IPConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IPConfig == nil {
				m.IPConfig = &cluster2.IPConfig{}
			}
			if err := m.IPConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkMode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NetworkMode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MgmtVlan", wireType)
			}
			m.MgmtVlan = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MgmtVlan |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Controllers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Controllers = append(m.Controllers, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DSCProfile", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DSCProfile = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InbandIPConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InbandIPConfig == nil {
				m.InbandIPConfig = &cluster2.IPConfig{}
			}
			if err := m.InbandIPConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNmd(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNmd
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DistributedServiceCardStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNmd
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DistributedServiceCardStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DistributedServiceCardStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdmissionPhase", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AdmissionPhase = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IPConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IPConfig == nil {
				m.IPConfig = &cluster2.IPConfig{}
			}
			if err := m.IPConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Controllers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Controllers = append(m.Controllers, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransitionPhase", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TransitionPhase = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fru", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Fru == nil {
				m.Fru = &DistributedServiceCardFru{}
			}
			if err := m.Fru.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DSCName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DSCName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeZone", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TimeZone = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdmissionPhaseReason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AdmissionPhaseReason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ManagementInterface", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ManagementInterface = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InbandIPConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNmd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InbandIPConfig == nil {
				m.InbandIPConfig = &cluster2.IPConfig{}
			}
			if err := m.InbandIPConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNmd(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNmd
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DistributedServiceCardCmdExecute) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNmd
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DistributedServiceCardCmdExecute: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DistributedServiceCardCmdExecute: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Executable", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Executable = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Opts", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Opts = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Env", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Env = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNmd(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNmd
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipNmd(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowNmd
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowNmd
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowNmd
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthNmd
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowNmd
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipNmd(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthNmd = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowNmd   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("nmd.proto", fileDescriptorNmd) }

var fileDescriptorNmd = []byte{
	// 1418 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x56, 0xc1, 0x6e, 0xdb, 0x46,
	0x13, 0x0e, 0x2d, 0xc5, 0x92, 0x57, 0xb6, 0x23, 0x6f, 0x12, 0x47, 0xf2, 0xef, 0xdf, 0x74, 0x5c,
	0x14, 0x71, 0xd2, 0x48, 0x32, 0x9c, 0x5e, 0xdc, 0x06, 0x2d, 0x44, 0x89, 0x8e, 0xd9, 0x44, 0xa4,
	0x20, 0xd2, 0x29, 0xda, 0x8b, 0xb1, 0x22, 0xd7, 0x0a, 0x5b, 0x71, 0x49, 0x2c, 0x97, 0x4e, 0x53,
	0xf4, 0x5a, 0x3f, 0x8c, 0x8f, 0x05, 0xf2, 0x0e, 0x39, 0x06, 0x3d, 0x15, 0x28, 0x40, 0x14, 0x39,
	0xea, 0x56, 0xa0, 0x0f, 0x50, 0x70, 0x49, 0x49, 0x6b, 0x47, 0x76, 0x51, 0xa4, 0x37, 0xee, 0xcc,
	0xf7, 0x7d, 0x3b, 0xbb, 0x33, 0xb3, 0x43, 0xb0, 0x40, 0x3c, 0xa7, 0x1e, 0x50, 0x9f, 0xf9, 0x30,
	0x47, 0x3c, 0x67, 0x6d, 0x7d, 0xe0, 0xfb, 0x83, 0x21, 0x6e, 0xa0, 0xc0, 0x6d, 0x20, 0x42, 0x7c,
	0x86, 0x98, 0xeb, 0x93, 0x30, 0x85, 0xac, 0xa9, 0x03, 0x97, 0xbd, 0x88, 0xfa, 0x75, 0xdb, 0xf7,
	0x1a, 0x01, 0x26, 0x21, 0x22, 0x8e, 0xdf, 0x08, 0x5f, 0x36, 0x4e, 0x30, 0x71, 0x6d, 0xdc, 0x88,
	0x98, 0x3b, 0x0c, 0x13, 0xea, 0x00, 0x13, 0x91, 0xdd, 0x70, 0x89, 0x3d, 0x8c, 0x1c, 0x3c, 0x96,
	0xa9, 0x09, 0x32, 0x03, 0x7f, 0xe0, 0x37, 0xb8, 0xb9, 0x1f, 0x1d, 0xf3, 0x15, 0x5f, 0xf0, 0xaf,
	0x0c, 0xfe, 0xf1, 0x25, 0xbb, 0x26, 0x31, 0x7a, 0x98, 0xa1, 0x0c, 0xb6, 0x73, 0x05, 0x8c, 0x23,
	0xc2, 0x46, 0xe8, 0x21, 0xca, 0x88, 0x6b, 0xa7, 0x8c, 0xad, 0xdf, 0xf3, 0xa0, 0xda, 0x76, 0x43,
	0x46, 0xdd, 0x7e, 0xc4, 0xb0, 0x63, 0x62, 0x7a, 0xe2, 0xda, 0xb8, 0x85, 0xa8, 0xb3, 0x4f, 0x23,
	0xa8, 0x83, 0x95, 0x0e, 0x22, 0xd1, 0x31, 0xb2, 0x59, 0x44, 0x5d, 0x32, 0x68, 0x23, 0x86, 0x2b,
	0xd2, 0xa6, 0xb4, 0xbd, 0xa0, 0x6c, 0x8e, 0x62, 0x79, 0xdd, 0x13, 0x9d, 0x35, 0x07, 0x31, 0xfc,
	0xd0, 0xf7, 0x5c, 0x86, 0xbd, 0x80, 0xbd, 0xea, 0xbd, 0x4f, 0x85, 0x5f, 0x80, 0xc5, 0xa9, 0x11,
	0xd3, 0xca, 0x1c, 0x97, 0x5a, 0x1b, 0xc5, 0xf2, 0xaa, 0x27, 0xd8, 0x05, 0x91, 0x73, 0x78, 0xf8,
	0x18, 0x94, 0xba, 0xd4, 0x77, 0x22, 0x9b, 0xe9, 0xc8, 0xc3, 0x95, 0xdc, 0x94, 0x1e, 0xa4, 0xe6,
	0x1a, 0x41, 0x9e, 0x18, 0x83, 0x08, 0x87, 0x7b, 0x60, 0xc1, 0xc4, 0xd4, 0x45, 0x43, 0x3d, 0xf2,
	0x2a, 0x79, 0xce, 0xfd, 0xdf, 0x28, 0x96, 0xef, 0x84, 0xdc, 0x58, 0x23, 0x91, 0xd7, 0x3f, 0xb7,
	0xf7, 0x14, 0x0d, 0x1f, 0x81, 0x42, 0x17, 0x51, 0x96, 0x10, 0xaf, 0x73, 0x62, 0x75, 0x14, 0xcb,
	0xb7, 0x03, 0x44, 0xd9, 0xfb, 0xb4, 0x31, 0x12, 0xee, 0x80, 0x82, 0xe2, 0x23, 0xea, 0x68, 0x4e,
	0x65, 0x9e, 0x93, 0x56, 0x47, 0xb1, 0x0c, 0xfb, 0x89, 0xa9, 0xe6, 0x3a, 0x22, 0x23, 0x83, 0x41,
	0x05, 0x2c, 0xab, 0x64, 0xd0, 0x7a, 0x81, 0xc8, 0x00, 0x3f, 0xc3, 0x27, 0x78, 0x58, 0x29, 0x4c,
	0x8f, 0x68, 0x73, 0x73, 0x6d, 0x98, 0xd8, 0x05, 0xf2, 0x05, 0x06, 0x54, 0x00, 0xd0, 0x23, 0xaf,
	0x83, 0xec, 0xa6, 0xe3, 0xd0, 0x4a, 0x91, 0xf3, 0xb7, 0x46, 0xb1, 0xbc, 0x91, 0x06, 0x5a, 0xf3,
	0x90, 0x5d, 0x43, 0x8e, 0x43, 0x71, 0x18, 0xe2, 0x50, 0xd0, 0x11, 0x58, 0x70, 0x1f, 0xcc, 0x77,
	0x90, 0x6d, 0x32, 0x5a, 0x59, 0xe0, 0xfc, 0xfa, 0xd9, 0x69, 0x15, 0xaa, 0x09, 0xcc, 0xa0, 0xdb,
	0x19, 0x68, 0xfb, 0xfe, 0xfd, 0x51, 0x2c, 0xdf, 0x4a, 0xe4, 0x92, 0xf2, 0x21, 0x03, 0x41, 0x2b,
	0x63, 0x6f, 0xbd, 0x9e, 0x03, 0xab, 0xb3, 0xab, 0x0b, 0xee, 0x00, 0xc9, 0xe2, 0xa5, 0x54, 0xda,
	0x5d, 0xaa, 0xa3, 0xc0, 0xad, 0x5b, 0xaf, 0x02, 0xdc, 0xc1, 0x0c, 0x29, 0x37, 0xdf, 0xc4, 0xf2,
	0xb5, 0xb7, 0xb1, 0x2c, 0x8d, 0x62, 0xb9, 0xf0, 0xd0, 0x25, 0x43, 0x97, 0xe0, 0x9e, 0x64, 0xc1,
	0x3d, 0x20, 0x19, 0xbc, 0x62, 0x4a, 0xbb, 0x37, 0x38, 0xc3, 0xe8, 0x7f, 0x87, 0x6d, 0xc6, 0x39,
	0x6b, 0x02, 0x67, 0x39, 0x69, 0x08, 0x21, 0x18, 0xc9, 0x80, 0x4f, 0x41, 0xde, 0x0c, 0xb0, 0xcd,
	0x0b, 0xa6, 0xb4, 0x2b, 0xd7, 0x93, 0x8e, 0x9f, 0x1d, 0x57, 0x02, 0x53, 0x56, 0x13, 0xb5, 0x44,
	0x29, 0x0c, 0xb0, 0x2d, 0x28, 0x71, 0x11, 0x68, 0x82, 0x79, 0x93, 0x21, 0x16, 0x85, 0xbc, 0x86,
	0x4a, 0xbb, 0x77, 0xaf, 0x92, 0xe3, 0x40, 0xa5, 0x92, 0x09, 0x96, 0x43, 0xbe, 0x16, 0x6f, 0x2a,
	0x45, 0x7c, 0xb6, 0xf8, 0xeb, 0xcf, 0xd5, 0x22, 0x9c, 0xb7, 0x7d, 0x72, 0xec, 0x0e, 0xb6, 0xfe,
	0xca, 0x83, 0xb5, 0xcb, 0xe3, 0x83, 0x7b, 0x00, 0x74, 0xa9, 0xeb, 0x21, 0xfa, 0xaa, 0xd3, 0x6c,
	0x65, 0xfd, 0x98, 0x16, 0x64, 0x6a, 0x4d, 0x72, 0x2c, 0x66, 0x76, 0x0a, 0x86, 0x9b, 0x60, 0x4e,
	0x6b, 0x67, 0x7d, 0x57, 0x1e, 0xc5, 0xf2, 0xa2, 0xd6, 0x16, 0x90, 0x73, 0x5a, 0x1b, 0xee, 0x83,
	0xa2, 0xd6, 0x6d, 0xf1, 0x38, 0xb2, 0xfb, 0x5a, 0xa9, 0xdb, 0xc3, 0x28, 0x64, 0x98, 0xd6, 0xc7,
	0x0e, 0xe5, 0xce, 0x28, 0x96, 0x6f, 0xba, 0x41, 0x2d, 0x8d, 0x57, 0x50, 0x98, 0x70, 0xe1, 0x01,
	0xc8, 0x77, 0x7c, 0x07, 0x67, 0x8d, 0xf6, 0xe9, 0xd9, 0x69, 0x75, 0xdb, 0x64, 0x54, 0x25, 0x91,
	0xb7, 0x3d, 0xfb, 0x68, 0xf5, 0xce, 0xc0, 0x63, 0x09, 0x25, 0xa9, 0xab, 0xbc, 0xe7, 0x3b, 0xb8,
	0xc7, 0x15, 0x20, 0x02, 0x25, 0x1d, 0xb3, 0x97, 0x3e, 0xfd, 0x9e, 0x0b, 0xa6, 0x0d, 0xf8, 0xe5,
	0xd9, 0x69, 0xf5, 0x93, 0x7f, 0x10, 0x14, 0x58, 0x89, 0xe6, 0x22, 0x49, 0xd7, 0x35, 0xae, 0x2d,
	0x6a, 0xc2, 0x3a, 0x28, 0x26, 0xbb, 0x3f, 0x1f, 0x22, 0xc2, 0x7b, 0x75, 0x49, 0x81, 0x49, 0xfe,
	0x4f, 0x86, 0x88, 0x88, 0x87, 0x1b, 0x63, 0xe0, 0xe7, 0xa0, 0xd4, 0xf2, 0x09, 0xa3, 0xfe, 0x70,
	0x88, 0x69, 0x58, 0x29, 0x6c, 0xe6, 0xc6, 0x29, 0xb0, 0xa7, 0x66, 0xf1, 0x1d, 0x12, 0xd0, 0xf0,
	0x31, 0x00, 0x6d, 0xb3, 0xd5, 0xa5, 0xfe, 0xb1, 0x3b, 0xc4, 0x59, 0x87, 0xae, 0x8f, 0x62, 0xb9,
	0xe2, 0xe0, 0x24, 0xf4, 0x5a, 0x90, 0x7a, 0xc4, 0x0c, 0x4e, 0xf1, 0xf0, 0x1b, 0xb0, 0xac, 0x91,
	0x3e, 0x22, 0xce, 0x24, 0x4b, 0x0b, 0x97, 0x65, 0x69, 0x63, 0x14, 0xcb, 0x6b, 0x2e, 0x07, 0xd7,
	0x66, 0x25, 0xeb, 0x82, 0xd0, 0xd6, 0x9f, 0x45, 0xb0, 0x7e, 0x55, 0x1d, 0x43, 0x0a, 0x96, 0x9b,
	0x8e, 0xe7, 0x86, 0xa1, 0xeb, 0x93, 0xee, 0x0b, 0x14, 0x8e, 0x87, 0xc1, 0x57, 0x67, 0xa7, 0xd5,
	0x47, 0xe3, 0x64, 0x8c, 0xc3, 0xb8, 0x4a, 0xa9, 0xce, 0xd9, 0x49, 0x52, 0x6e, 0x04, 0xc9, 0x97,
	0x18, 0xd4, 0xf9, 0x1d, 0xce, 0xd5, 0xe3, 0xdc, 0x07, 0xd4, 0xe3, 0x85, 0x94, 0xe5, 0xfe, 0x55,
	0xca, 0x7e, 0x02, 0x37, 0x2c, 0x8a, 0x48, 0xe8, 0xb2, 0xc9, 0xc9, 0xd3, 0xba, 0xee, 0x9d, 0x9d,
	0x56, 0x77, 0xae, 0x2e, 0xc3, 0xec, 0xc4, 0x53, 0x7e, 0x72, 0xec, 0x35, 0x36, 0x59, 0xd6, 0x2e,
	0xde, 0xc0, 0xc5, 0xad, 0x26, 0xad, 0x74, 0xfd, 0x83, 0x5b, 0xa9, 0x05, 0x72, 0xfb, 0x34, 0xe2,
	0x53, 0xa5, 0xb4, 0xbb, 0x71, 0xc5, 0xc3, 0xb5, 0x4f, 0x23, 0x65, 0x65, 0x14, 0xcb, 0x4b, 0xc7,
	0x34, 0x12, 0x42, 0x4b, 0xd8, 0xc9, 0x5c, 0x6b, 0x9b, 0x2d, 0x3e, 0x81, 0x8b, 0xd3, 0xb9, 0xe6,
	0x84, 0xf6, 0xc5, 0xe9, 0x3b, 0x86, 0xc1, 0x3d, 0x50, 0xb4, 0x5c, 0x0f, 0x7f, 0xeb, 0x13, 0x9c,
	0x4d, 0x94, 0xff, 0xff, 0x72, 0x5a, 0xcd, 0x1d, 0x5a, 0xad, 0x84, 0xc9, 0x5c, 0x0f, 0xff, 0xe8,
	0x13, 0x91, 0x39, 0x81, 0xc3, 0x1e, 0xb8, 0x75, 0xbe, 0x20, 0x7a, 0x18, 0x85, 0x3e, 0xa9, 0x00,
	0x2e, 0xc3, 0x2b, 0x1c, 0x39, 0x5e, 0x7a, 0x87, 0x35, 0xca, 0x7d, 0x82, 0xce, 0x4c, 0x2e, 0xb4,
	0xc0, 0xcd, 0x0e, 0x22, 0x68, 0x80, 0x3d, 0x4c, 0x98, 0x46, 0x18, 0xa6, 0xc7, 0xc8, 0xc6, 0x95,
	0xd2, 0x74, 0x56, 0x7a, 0x13, 0x77, 0xcd, 0x1d, 0xfb, 0x05, 0xd9, 0x59, 0xf4, 0x19, 0x8d, 0xb9,
	0xf8, 0x5f, 0x35, 0xe6, 0x6f, 0x12, 0x00, 0xd3, 0xa2, 0x80, 0x45, 0x90, 0xd7, 0x0d, 0x5d, 0x2d,
	0x5f, 0x83, 0x4b, 0x60, 0xa1, 0x7d, 0xd0, 0xea, 0x1e, 0x99, 0xaa, 0x6e, 0x95, 0xa5, 0xc9, 0xb2,
	0x9d, 0x78, 0xe7, 0xe0, 0x0a, 0x58, 0xe2, 0x4b, 0x4b, 0xeb, 0xa8, 0x6d, 0xe3, 0xd0, 0x2a, 0xe7,
	0xe0, 0x3d, 0xf0, 0x51, 0x47, 0x33, 0x4d, 0x4d, 0x7f, 0x72, 0xf4, 0x5c, 0xd5, 0xdb, 0x46, 0xef,
	0xc8, 0xec, 0xaa, 0x2d, 0x6d, 0x5f, 0x53, 0xdb, 0x47, 0x4d, 0xcb, 0xea, 0x69, 0xca, 0xa1, 0xa5,
	0x9a, 0xe5, 0x3c, 0x5c, 0x07, 0x95, 0xe7, 0xaa, 0xae, 0xb5, 0xd4, 0xa3, 0x9e, 0xfa, 0x44, 0x33,
	0xad, 0x5e, 0xd3, 0xd2, 0x0c, 0x3d, 0xdd, 0xe8, 0xfa, 0x65, 0x5e, 0xbe, 0xef, 0x3c, 0x5c, 0x05,
	0x30, 0xf3, 0x1e, 0xea, 0x3d, 0xb5, 0xd9, 0x3a, 0x68, 0x2a, 0xcf, 0xd4, 0x72, 0x01, 0x42, 0xb0,
	0xdc, 0x53, 0x15, 0xc3, 0xb0, 0x8e, 0xba, 0xaa, 0xde, 0xd6, 0xf4, 0x27, 0xe5, 0xe2, 0xd6, 0x6b,
	0x09, 0x6c, 0xce, 0x2e, 0xc1, 0x96, 0xe7, 0xa8, 0x3f, 0x60, 0x3b, 0x62, 0x38, 0x79, 0x31, 0xd3,
	0x4f, 0xd4, 0x1f, 0x8e, 0xdf, 0x9c, 0xf5, 0x37, 0xe9, 0xb8, 0xbf, 0x85, 0x27, 0x1e, 0xf1, 0xc5,
	0x9c, 0xe2, 0xe1, 0x03, 0x90, 0x37, 0x02, 0x16, 0x66, 0x53, 0x6f, 0x35, 0xe3, 0x2d, 0xfb, 0x01,
	0x13, 0xfb, 0x9d, 0x63, 0xe0, 0x3d, 0x90, 0x53, 0xc9, 0x49, 0xf6, 0x67, 0x79, 0x3b, 0x83, 0x2e,
	0x61, 0x72, 0x22, 0x36, 0x81, 0x4a, 0x4e, 0x1e, 0xdc, 0x4d, 0x27, 0x06, 0xef, 0xaa, 0x22, 0xc8,
	0x1f, 0x18, 0xa6, 0x55, 0xbe, 0x06, 0x4b, 0xa0, 0xa0, 0xab, 0xd6, 0xd7, 0x46, 0xef, 0x69, 0x59,
	0x7a, 0xf0, 0xf0, 0xdc, 0xdc, 0x12, 0xb2, 0x56, 0x00, 0x39, 0xc3, 0x50, 0xca, 0x12, 0x04, 0x60,
	0x5e, 0xd3, 0x95, 0xa6, 0xde, 0x2e, 0xcf, 0x29, 0x8b, 0x6f, 0xde, 0x6d, 0x48, 0x6f, 0xdf, 0x6d,
	0x48, 0x7f, 0xbc, 0xdb, 0x90, 0xba, 0x52, 0x7f, 0x9e, 0xff, 0xa0, 0x3f, 0xfa, 0x3b, 0x00, 0x00,
	0xff, 0xff, 0xb1, 0xa8, 0x24, 0x76, 0x9f, 0x0c, 0x00, 0x00,
}
