// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: nat.proto.draft

package halproto

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import encoding_binary "encoding/binary"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// types of NAT actions supported
type NatAction int32

const (
	NatAction_NAT_TYPE_NONE                 NatAction = 0
	NatAction_NAT_TYPE_STATIC_ADDRESS       NatAction = 1
	NatAction_NAT_TYPE_DYNAMIC_ADDRESS      NatAction = 2
	NatAction_NAT_TYPE_DYNAMIC_ADDRESS_PORT NatAction = 3
)

var NatAction_name = map[int32]string{
	0: "NAT_TYPE_NONE",
	1: "NAT_TYPE_STATIC_ADDRESS",
	2: "NAT_TYPE_DYNAMIC_ADDRESS",
	3: "NAT_TYPE_DYNAMIC_ADDRESS_PORT",
}
var NatAction_value = map[string]int32{
	"NAT_TYPE_NONE":                 0,
	"NAT_TYPE_STATIC_ADDRESS":       1,
	"NAT_TYPE_DYNAMIC_ADDRESS":      2,
	"NAT_TYPE_DYNAMIC_ADDRESS_PORT": 3,
}

func (x NatAction) String() string {
	return proto.EnumName(NatAction_name, int32(x))
}
func (NatAction) EnumDescriptor() ([]byte, []int) { return fileDescriptorNatDraft, []int{0} }

// NAT pool definition
// NOTE: addresses inside the NAT pool are "owned" by the device, so device is
// expected to advertise the routes for the same and respond to ARP requests
type NatPool struct {
	Address   []*Address   `protobuf:"bytes,1,rep,name=address" json:"address,omitempty"`
	PortRange *L4PortRange `protobuf:"bytes,2,opt,name=port_range,json=portRange" json:"port_range,omitempty"`
}

func (m *NatPool) Reset()                    { *m = NatPool{} }
func (m *NatPool) String() string            { return proto.CompactTextString(m) }
func (*NatPool) ProtoMessage()               {}
func (*NatPool) Descriptor() ([]byte, []int) { return fileDescriptorNatDraft, []int{0} }

func (m *NatPool) GetAddress() []*Address {
	if m != nil {
		return m.Address
	}
	return nil
}

func (m *NatPool) GetPortRange() *L4PortRange {
	if m != nil {
		return m.PortRange
	}
	return nil
}

// NatRuleSpec is the user intent for the NAT rule
type NatRuleSpec struct {
	Meta        *ObjectMeta       `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	KeyOrHandle *NatRuleKeyHandle `protobuf:"bytes,2,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty" venice:"key"`
	// NAT rule match conditions
	SrcAddress   []*IPAddressObj `protobuf:"bytes,3,rep,name=src_address,json=srcAddress" json:"src_address,omitempty"`
	SrcSg        []uint32        `protobuf:"varint,4,rep,packed,name=src_sg,json=srcSg" json:"src_sg,omitempty"`
	DstAddress   []*IPAddressObj `protobuf:"bytes,5,rep,name=dst_address,json=dstAddress" json:"dst_address,omitempty"`
	DstSg        []uint32        `protobuf:"varint,6,rep,packed,name=dst_sg,json=dstSg" json:"dst_sg,omitempty"`
	DstPortRange []*L4PortRange  `protobuf:"bytes,7,rep,name=dst_port_range,json=dstPortRange" json:"dst_port_range,omitempty"`
	SrcPortRange []*L4PortRange  `protobuf:"bytes,8,rep,name=src_port_range,json=srcPortRange" json:"src_port_range,omitempty"`
	// NAT rule action related attributes
	SrcNatAction NatAction `protobuf:"varint,9,opt,name=src_nat_action,json=srcNatAction,proto3,enum=nat.NatAction" json:"src_nat_action,omitempty"`
	DstNatAction NatAction `protobuf:"varint,10,opt,name=dst_nat_action,json=dstNatAction,proto3,enum=nat.NatAction" json:"dst_nat_action,omitempty"`
	SrcNatPool   *NatPool  `protobuf:"bytes,11,opt,name=src_nat_pool,json=srcNatPool" json:"src_nat_pool,omitempty"`
	DstNatPool   *NatPool  `protobuf:"bytes,12,opt,name=dst_nat_pool,json=dstNatPool" json:"dst_nat_pool,omitempty"`
}

func (m *NatRuleSpec) Reset()                    { *m = NatRuleSpec{} }
func (m *NatRuleSpec) String() string            { return proto.CompactTextString(m) }
func (*NatRuleSpec) ProtoMessage()               {}
func (*NatRuleSpec) Descriptor() ([]byte, []int) { return fileDescriptorNatDraft, []int{1} }

func (m *NatRuleSpec) GetMeta() *ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *NatRuleSpec) GetKeyOrHandle() *NatRuleKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

func (m *NatRuleSpec) GetSrcAddress() []*IPAddressObj {
	if m != nil {
		return m.SrcAddress
	}
	return nil
}

func (m *NatRuleSpec) GetSrcSg() []uint32 {
	if m != nil {
		return m.SrcSg
	}
	return nil
}

func (m *NatRuleSpec) GetDstAddress() []*IPAddressObj {
	if m != nil {
		return m.DstAddress
	}
	return nil
}

func (m *NatRuleSpec) GetDstSg() []uint32 {
	if m != nil {
		return m.DstSg
	}
	return nil
}

func (m *NatRuleSpec) GetDstPortRange() []*L4PortRange {
	if m != nil {
		return m.DstPortRange
	}
	return nil
}

func (m *NatRuleSpec) GetSrcPortRange() []*L4PortRange {
	if m != nil {
		return m.SrcPortRange
	}
	return nil
}

func (m *NatRuleSpec) GetSrcNatAction() NatAction {
	if m != nil {
		return m.SrcNatAction
	}
	return NatAction_NAT_TYPE_NONE
}

func (m *NatRuleSpec) GetDstNatAction() NatAction {
	if m != nil {
		return m.DstNatAction
	}
	return NatAction_NAT_TYPE_NONE
}

func (m *NatRuleSpec) GetSrcNatPool() *NatPool {
	if m != nil {
		return m.SrcNatPool
	}
	return nil
}

func (m *NatRuleSpec) GetDstNatPool() *NatPool {
	if m != nil {
		return m.DstNatPool
	}
	return nil
}

// NatRuleRequestMsg is the batched add or modify of NAT rule request
type NatRuleRequestMsg struct {
	Request []*NatRuleSpec `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *NatRuleRequestMsg) Reset()                    { *m = NatRuleRequestMsg{} }
func (m *NatRuleRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*NatRuleRequestMsg) ProtoMessage()               {}
func (*NatRuleRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptorNatDraft, []int{2} }

func (m *NatRuleRequestMsg) GetRequest() []*NatRuleSpec {
	if m != nil {
		return m.Request
	}
	return nil
}

// NatRuleStatus reflects the current operational status of the NAT rule
type NatRuleStatus struct {
	Handle uint64 `protobuf:"fixed64,1,opt,name=handle,proto3" json:"handle,omitempty"`
}

func (m *NatRuleStatus) Reset()                    { *m = NatRuleStatus{} }
func (m *NatRuleStatus) String() string            { return proto.CompactTextString(m) }
func (*NatRuleStatus) ProtoMessage()               {}
func (*NatRuleStatus) Descriptor() ([]byte, []int) { return fileDescriptorNatDraft, []int{3} }

func (m *NatRuleStatus) GetHandle() uint64 {
	if m != nil {
		return m.Handle
	}
	return 0
}

// NatRuleResponse is the response to NatRuleSpec
type NatRuleResponse struct {
	ApiStatus ApiStatus      `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status"`
	Status    *NatRuleStatus `protobuf:"bytes,2,opt,name=status" json:"status,omitempty"`
}

func (m *NatRuleResponse) Reset()                    { *m = NatRuleResponse{} }
func (m *NatRuleResponse) String() string            { return proto.CompactTextString(m) }
func (*NatRuleResponse) ProtoMessage()               {}
func (*NatRuleResponse) Descriptor() ([]byte, []int) { return fileDescriptorNatDraft, []int{4} }

func (m *NatRuleResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *NatRuleResponse) GetStatus() *NatRuleStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

// NatRuleResponseMsg is batched response to NatRuleRequestMsg
type NatRuleResponseMsg struct {
	Response []*NatRuleResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *NatRuleResponseMsg) Reset()                    { *m = NatRuleResponseMsg{} }
func (m *NatRuleResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*NatRuleResponseMsg) ProtoMessage()               {}
func (*NatRuleResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptorNatDraft, []int{5} }

func (m *NatRuleResponseMsg) GetResponse() []*NatRuleResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

// NatRuleGetRequest is used to get information about a NAT rule
type NatRuleGetRequest struct {
	Meta        *ObjectMeta       `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	KeyOrHandle *NatRuleKeyHandle `protobuf:"bytes,2,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty" venice:"key"`
}

func (m *NatRuleGetRequest) Reset()                    { *m = NatRuleGetRequest{} }
func (m *NatRuleGetRequest) String() string            { return proto.CompactTextString(m) }
func (*NatRuleGetRequest) ProtoMessage()               {}
func (*NatRuleGetRequest) Descriptor() ([]byte, []int) { return fileDescriptorNatDraft, []int{6} }

func (m *NatRuleGetRequest) GetMeta() *ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *NatRuleGetRequest) GetKeyOrHandle() *NatRuleKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

// NatRuleGetRequestMsg is batched GET request for NAT rules
type NatRuleGetRequestMsg struct {
	Request []*NatRuleGetRequest `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *NatRuleGetRequestMsg) Reset()                    { *m = NatRuleGetRequestMsg{} }
func (m *NatRuleGetRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*NatRuleGetRequestMsg) ProtoMessage()               {}
func (*NatRuleGetRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptorNatDraft, []int{7} }

func (m *NatRuleGetRequestMsg) GetRequest() []*NatRuleGetRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

// NatRuleStats is the statistics object for each NAT rule
type NatRuleStats struct {
	NumTcpSessions   uint32 `protobuf:"varint,1,opt,name=num_tcp_sessions,json=numTcpSessions,proto3" json:"num_tcp_sessions,omitempty"`
	NumUdpSessions   uint32 `protobuf:"varint,2,opt,name=num_udp_sessions,json=numUdpSessions,proto3" json:"num_udp_sessions,omitempty"`
	NumOtherSessions uint32 `protobuf:"varint,3,opt,name=num_other_sessions,json=numOtherSessions,proto3" json:"num_other_sessions,omitempty"`
}

func (m *NatRuleStats) Reset()                    { *m = NatRuleStats{} }
func (m *NatRuleStats) String() string            { return proto.CompactTextString(m) }
func (*NatRuleStats) ProtoMessage()               {}
func (*NatRuleStats) Descriptor() ([]byte, []int) { return fileDescriptorNatDraft, []int{8} }

func (m *NatRuleStats) GetNumTcpSessions() uint32 {
	if m != nil {
		return m.NumTcpSessions
	}
	return 0
}

func (m *NatRuleStats) GetNumUdpSessions() uint32 {
	if m != nil {
		return m.NumUdpSessions
	}
	return 0
}

func (m *NatRuleStats) GetNumOtherSessions() uint32 {
	if m != nil {
		return m.NumOtherSessions
	}
	return 0
}

// NatRuleGetResponse reflects all the information about a NAT rule
type NatRuleGetResponse struct {
	ApiStatus ApiStatus      `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty" venice:api_status`
	Spec      *NatRuleSpec   `protobuf:"bytes,2,opt,name=spec" json:"spec,omitempty"`
	Status    *NatRuleStatus `protobuf:"bytes,3,opt,name=status" json:"status,omitempty"`
	Stats     *NatRuleStats  `protobuf:"bytes,4,opt,name=stats" json:"stats,omitempty"`
}

func (m *NatRuleGetResponse) Reset()                    { *m = NatRuleGetResponse{} }
func (m *NatRuleGetResponse) String() string            { return proto.CompactTextString(m) }
func (*NatRuleGetResponse) ProtoMessage()               {}
func (*NatRuleGetResponse) Descriptor() ([]byte, []int) { return fileDescriptorNatDraft, []int{9} }

func (m *NatRuleGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *NatRuleGetResponse) GetSpec() *NatRuleSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *NatRuleGetResponse) GetStatus() *NatRuleStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *NatRuleGetResponse) GetStats() *NatRuleStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

// NatRuleGetResponseMsg is batched response to NatRuleGetRequestMsg
type NatRuleGetResponseMsg struct {
	ApiStatus ApiStatus             `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty" venice:api_status`
	Response  []*NatRuleGetResponse `protobuf:"bytes,2,rep,name=response" json:"response,omitempty"`
}

func (m *NatRuleGetResponseMsg) Reset()                    { *m = NatRuleGetResponseMsg{} }
func (m *NatRuleGetResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*NatRuleGetResponseMsg) ProtoMessage()               {}
func (*NatRuleGetResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptorNatDraft, []int{10} }

func (m *NatRuleGetResponseMsg) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *NatRuleGetResponseMsg) GetResponse() []*NatRuleGetResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

// NatVpnMappingSpec is the user intent for the NAT-VPN mapping
type NatVpnMappingSpec struct {
	Meta        *ObjectMeta             `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	KeyOrHandle *NatVpnMappingKeyHandle `protobuf:"bytes,2,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty" venice:"key"`
}

func (m *NatVpnMappingSpec) Reset()                    { *m = NatVpnMappingSpec{} }
func (m *NatVpnMappingSpec) String() string            { return proto.CompactTextString(m) }
func (*NatVpnMappingSpec) ProtoMessage()               {}
func (*NatVpnMappingSpec) Descriptor() ([]byte, []int) { return fileDescriptorNatDraft, []int{11} }

func (m *NatVpnMappingSpec) GetMeta() *ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *NatVpnMappingSpec) GetKeyOrHandle() *NatVpnMappingKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

// NatVpnMappingRequestMsg is the batched add or modify of NAT VPN mapping request
type NatVpnMappingRequestMsg struct {
	Request []*NatVpnMappingSpec `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *NatVpnMappingRequestMsg) Reset()                    { *m = NatVpnMappingRequestMsg{} }
func (m *NatVpnMappingRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*NatVpnMappingRequestMsg) ProtoMessage()               {}
func (*NatVpnMappingRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptorNatDraft, []int{12} }

func (m *NatVpnMappingRequestMsg) GetRequest() []*NatVpnMappingSpec {
	if m != nil {
		return m.Request
	}
	return nil
}

// NatVpnMappingStatus reflects the current operational status of a NAT VPN mapping
type NatVpnMappingStatus struct {
	Handle     uint64 `protobuf:"fixed64,1,opt,name=handle,proto3" json:"handle,omitempty"`
	SvcMapping *Svc   `protobuf:"bytes,2,opt,name=svc_mapping,json=svcMapping" json:"svc_mapping,omitempty"`
}

func (m *NatVpnMappingStatus) Reset()                    { *m = NatVpnMappingStatus{} }
func (m *NatVpnMappingStatus) String() string            { return proto.CompactTextString(m) }
func (*NatVpnMappingStatus) ProtoMessage()               {}
func (*NatVpnMappingStatus) Descriptor() ([]byte, []int) { return fileDescriptorNatDraft, []int{13} }

func (m *NatVpnMappingStatus) GetHandle() uint64 {
	if m != nil {
		return m.Handle
	}
	return 0
}

func (m *NatVpnMappingStatus) GetSvcMapping() *Svc {
	if m != nil {
		return m.SvcMapping
	}
	return nil
}

// NatVpnMappingResponse is the response to NatVpnMappingSpec
type NatVpnMappingResponse struct {
	ApiStatus ApiStatus            `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status"`
	Status    *NatVpnMappingStatus `protobuf:"bytes,2,opt,name=status" json:"status,omitempty"`
}

func (m *NatVpnMappingResponse) Reset()                    { *m = NatVpnMappingResponse{} }
func (m *NatVpnMappingResponse) String() string            { return proto.CompactTextString(m) }
func (*NatVpnMappingResponse) ProtoMessage()               {}
func (*NatVpnMappingResponse) Descriptor() ([]byte, []int) { return fileDescriptorNatDraft, []int{14} }

func (m *NatVpnMappingResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *NatVpnMappingResponse) GetStatus() *NatVpnMappingStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

// NatVpnMappingResponseMsg is batched response to NatVpnMappingRequestMsg
type NatVpnMappingResponseMsg struct {
	Response []*NatVpnMappingResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *NatVpnMappingResponseMsg) Reset()         { *m = NatVpnMappingResponseMsg{} }
func (m *NatVpnMappingResponseMsg) String() string { return proto.CompactTextString(m) }
func (*NatVpnMappingResponseMsg) ProtoMessage()    {}
func (*NatVpnMappingResponseMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorNatDraft, []int{15}
}

func (m *NatVpnMappingResponseMsg) GetResponse() []*NatVpnMappingResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

// NatVpnMappingGetRequest is used to get information about a NAT VPN mapping
type NatVpnMappingGetRequest struct {
	Meta        *ObjectMeta             `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	KeyOrHandle *NatVpnMappingKeyHandle `protobuf:"bytes,2,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty" venice:"key"`
}

func (m *NatVpnMappingGetRequest) Reset()                    { *m = NatVpnMappingGetRequest{} }
func (m *NatVpnMappingGetRequest) String() string            { return proto.CompactTextString(m) }
func (*NatVpnMappingGetRequest) ProtoMessage()               {}
func (*NatVpnMappingGetRequest) Descriptor() ([]byte, []int) { return fileDescriptorNatDraft, []int{16} }

func (m *NatVpnMappingGetRequest) GetMeta() *ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *NatVpnMappingGetRequest) GetKeyOrHandle() *NatVpnMappingKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

// NatVpnMappingGetRequestMsg is batched GET request for NAT VPN mappings
type NatVpnMappingGetRequestMsg struct {
	Request []*NatVpnMappingGetRequest `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *NatVpnMappingGetRequestMsg) Reset()         { *m = NatVpnMappingGetRequestMsg{} }
func (m *NatVpnMappingGetRequestMsg) String() string { return proto.CompactTextString(m) }
func (*NatVpnMappingGetRequestMsg) ProtoMessage()    {}
func (*NatVpnMappingGetRequestMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorNatDraft, []int{17}
}

func (m *NatVpnMappingGetRequestMsg) GetRequest() []*NatVpnMappingGetRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

// NatVpnMappingStats is the statistics object for each NAT VPN mapping
type NatVpnMappingStats struct {
	RxBytes              uint64 `protobuf:"varint,1,opt,name=rx_bytes,json=rxBytes,proto3" json:"rx_bytes,omitempty"`
	RxPackets            uint64 `protobuf:"varint,2,opt,name=rx_packets,json=rxPackets,proto3" json:"rx_packets,omitempty"`
	TxBytes              uint64 `protobuf:"varint,3,opt,name=tx_bytes,json=txBytes,proto3" json:"tx_bytes,omitempty"`
	TxPackets            uint64 `protobuf:"varint,4,opt,name=tx_packets,json=txPackets,proto3" json:"tx_packets,omitempty"`
	RxBytesDropped       uint64 `protobuf:"varint,5,opt,name=rx_bytes_dropped,json=rxBytesDropped,proto3" json:"rx_bytes_dropped,omitempty"`
	RxPacketsDropped     uint64 `protobuf:"varint,6,opt,name=rx_packets_dropped,json=rxPacketsDropped,proto3" json:"rx_packets_dropped,omitempty"`
	TxBytesDropped       uint64 `protobuf:"varint,7,opt,name=tx_bytes_dropped,json=txBytesDropped,proto3" json:"tx_bytes_dropped,omitempty"`
	TxPacketsDropped     uint64 `protobuf:"varint,8,opt,name=tx_packets_dropped,json=txPacketsDropped,proto3" json:"tx_packets_dropped,omitempty"`
	NumTcpSessions       uint32 `protobuf:"varint,9,opt,name=num_tcp_sessions,json=numTcpSessions,proto3" json:"num_tcp_sessions,omitempty"`
	NumUdpSessions       uint32 `protobuf:"varint,10,opt,name=num_udp_sessions,json=numUdpSessions,proto3" json:"num_udp_sessions,omitempty"`
	NumOtherSessions     uint32 `protobuf:"varint,11,opt,name=num_other_sessions,json=numOtherSessions,proto3" json:"num_other_sessions,omitempty"`
	NumActiveConnections uint32 `protobuf:"varint,12,opt,name=num_active_connections,json=numActiveConnections,proto3" json:"num_active_connections,omitempty"`
}

func (m *NatVpnMappingStats) Reset()                    { *m = NatVpnMappingStats{} }
func (m *NatVpnMappingStats) String() string            { return proto.CompactTextString(m) }
func (*NatVpnMappingStats) ProtoMessage()               {}
func (*NatVpnMappingStats) Descriptor() ([]byte, []int) { return fileDescriptorNatDraft, []int{18} }

func (m *NatVpnMappingStats) GetRxBytes() uint64 {
	if m != nil {
		return m.RxBytes
	}
	return 0
}

func (m *NatVpnMappingStats) GetRxPackets() uint64 {
	if m != nil {
		return m.RxPackets
	}
	return 0
}

func (m *NatVpnMappingStats) GetTxBytes() uint64 {
	if m != nil {
		return m.TxBytes
	}
	return 0
}

func (m *NatVpnMappingStats) GetTxPackets() uint64 {
	if m != nil {
		return m.TxPackets
	}
	return 0
}

func (m *NatVpnMappingStats) GetRxBytesDropped() uint64 {
	if m != nil {
		return m.RxBytesDropped
	}
	return 0
}

func (m *NatVpnMappingStats) GetRxPacketsDropped() uint64 {
	if m != nil {
		return m.RxPacketsDropped
	}
	return 0
}

func (m *NatVpnMappingStats) GetTxBytesDropped() uint64 {
	if m != nil {
		return m.TxBytesDropped
	}
	return 0
}

func (m *NatVpnMappingStats) GetTxPacketsDropped() uint64 {
	if m != nil {
		return m.TxPacketsDropped
	}
	return 0
}

func (m *NatVpnMappingStats) GetNumTcpSessions() uint32 {
	if m != nil {
		return m.NumTcpSessions
	}
	return 0
}

func (m *NatVpnMappingStats) GetNumUdpSessions() uint32 {
	if m != nil {
		return m.NumUdpSessions
	}
	return 0
}

func (m *NatVpnMappingStats) GetNumOtherSessions() uint32 {
	if m != nil {
		return m.NumOtherSessions
	}
	return 0
}

func (m *NatVpnMappingStats) GetNumActiveConnections() uint32 {
	if m != nil {
		return m.NumActiveConnections
	}
	return 0
}

// NatVpnMappingGetResponse reflects all the information about a NAT VPN mapping
type NatVpnMappingGetResponse struct {
	ApiStatus ApiStatus            `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty" venice:api_status`
	Spec      *NatVpnMappingSpec   `protobuf:"bytes,2,opt,name=spec" json:"spec,omitempty"`
	Status    *NatVpnMappingStatus `protobuf:"bytes,3,opt,name=status" json:"status,omitempty"`
	Stats     *NatVpnMappingStats  `protobuf:"bytes,4,opt,name=stats" json:"stats,omitempty"`
}

func (m *NatVpnMappingGetResponse) Reset()         { *m = NatVpnMappingGetResponse{} }
func (m *NatVpnMappingGetResponse) String() string { return proto.CompactTextString(m) }
func (*NatVpnMappingGetResponse) ProtoMessage()    {}
func (*NatVpnMappingGetResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorNatDraft, []int{19}
}

func (m *NatVpnMappingGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *NatVpnMappingGetResponse) GetSpec() *NatVpnMappingSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *NatVpnMappingGetResponse) GetStatus() *NatVpnMappingStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *NatVpnMappingGetResponse) GetStats() *NatVpnMappingStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

// NatVpnMappingGetResponseMsg is batched response to NatVpnMappingGetRequestMsg
type NatVpnMappingGetResponseMsg struct {
	ApiStatus ApiStatus                   `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty" venice:api_status`
	Response  []*NatVpnMappingGetResponse `protobuf:"bytes,2,rep,name=response" json:"response,omitempty"`
}

func (m *NatVpnMappingGetResponseMsg) Reset()         { *m = NatVpnMappingGetResponseMsg{} }
func (m *NatVpnMappingGetResponseMsg) String() string { return proto.CompactTextString(m) }
func (*NatVpnMappingGetResponseMsg) ProtoMessage()    {}
func (*NatVpnMappingGetResponseMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorNatDraft, []int{20}
}

func (m *NatVpnMappingGetResponseMsg) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *NatVpnMappingGetResponseMsg) GetResponse() []*NatVpnMappingGetResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

func init() {
	proto.RegisterType((*NatPool)(nil), "nat.NatPool")
	proto.RegisterType((*NatRuleSpec)(nil), "nat.NatRuleSpec")
	proto.RegisterType((*NatRuleRequestMsg)(nil), "nat.NatRuleRequestMsg")
	proto.RegisterType((*NatRuleStatus)(nil), "nat.NatRuleStatus")
	proto.RegisterType((*NatRuleResponse)(nil), "nat.NatRuleResponse")
	proto.RegisterType((*NatRuleResponseMsg)(nil), "nat.NatRuleResponseMsg")
	proto.RegisterType((*NatRuleGetRequest)(nil), "nat.NatRuleGetRequest")
	proto.RegisterType((*NatRuleGetRequestMsg)(nil), "nat.NatRuleGetRequestMsg")
	proto.RegisterType((*NatRuleStats)(nil), "nat.NatRuleStats")
	proto.RegisterType((*NatRuleGetResponse)(nil), "nat.NatRuleGetResponse")
	proto.RegisterType((*NatRuleGetResponseMsg)(nil), "nat.NatRuleGetResponseMsg")
	proto.RegisterType((*NatVpnMappingSpec)(nil), "nat.NatVpnMappingSpec")
	proto.RegisterType((*NatVpnMappingRequestMsg)(nil), "nat.NatVpnMappingRequestMsg")
	proto.RegisterType((*NatVpnMappingStatus)(nil), "nat.NatVpnMappingStatus")
	proto.RegisterType((*NatVpnMappingResponse)(nil), "nat.NatVpnMappingResponse")
	proto.RegisterType((*NatVpnMappingResponseMsg)(nil), "nat.NatVpnMappingResponseMsg")
	proto.RegisterType((*NatVpnMappingGetRequest)(nil), "nat.NatVpnMappingGetRequest")
	proto.RegisterType((*NatVpnMappingGetRequestMsg)(nil), "nat.NatVpnMappingGetRequestMsg")
	proto.RegisterType((*NatVpnMappingStats)(nil), "nat.NatVpnMappingStats")
	proto.RegisterType((*NatVpnMappingGetResponse)(nil), "nat.NatVpnMappingGetResponse")
	proto.RegisterType((*NatVpnMappingGetResponseMsg)(nil), "nat.NatVpnMappingGetResponseMsg")
	proto.RegisterEnum("nat.NatAction", NatAction_name, NatAction_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Nat service

type NatClient interface {
	// NAT related APIs
	NatRuleCreate(ctx context.Context, in *NatRuleRequestMsg, opts ...grpc.CallOption) (*NatRuleResponseMsg, error)
	NatRuleGet(ctx context.Context, in *NatRuleGetRequestMsg, opts ...grpc.CallOption) (*NatRuleGetResponseMsg, error)
	// NAT-VPN mappings related APIs
	NatVpnMappingCreate(ctx context.Context, in *NatVpnMappingRequestMsg, opts ...grpc.CallOption) (*NatVpnMappingResponseMsg, error)
	NatVpnMappingGet(ctx context.Context, in *NatVpnMappingGetRequestMsg, opts ...grpc.CallOption) (*NatVpnMappingGetResponseMsg, error)
}

type natClient struct {
	cc *grpc.ClientConn
}

func NewNatClient(cc *grpc.ClientConn) NatClient {
	return &natClient{cc}
}

func (c *natClient) NatRuleCreate(ctx context.Context, in *NatRuleRequestMsg, opts ...grpc.CallOption) (*NatRuleResponseMsg, error) {
	out := new(NatRuleResponseMsg)
	err := grpc.Invoke(ctx, "/nat.Nat/NatRuleCreate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *natClient) NatRuleGet(ctx context.Context, in *NatRuleGetRequestMsg, opts ...grpc.CallOption) (*NatRuleGetResponseMsg, error) {
	out := new(NatRuleGetResponseMsg)
	err := grpc.Invoke(ctx, "/nat.Nat/NatRuleGet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *natClient) NatVpnMappingCreate(ctx context.Context, in *NatVpnMappingRequestMsg, opts ...grpc.CallOption) (*NatVpnMappingResponseMsg, error) {
	out := new(NatVpnMappingResponseMsg)
	err := grpc.Invoke(ctx, "/nat.Nat/NatVpnMappingCreate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *natClient) NatVpnMappingGet(ctx context.Context, in *NatVpnMappingGetRequestMsg, opts ...grpc.CallOption) (*NatVpnMappingGetResponseMsg, error) {
	out := new(NatVpnMappingGetResponseMsg)
	err := grpc.Invoke(ctx, "/nat.Nat/NatVpnMappingGet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Nat service

type NatServer interface {
	// NAT related APIs
	NatRuleCreate(context.Context, *NatRuleRequestMsg) (*NatRuleResponseMsg, error)
	NatRuleGet(context.Context, *NatRuleGetRequestMsg) (*NatRuleGetResponseMsg, error)
	// NAT-VPN mappings related APIs
	NatVpnMappingCreate(context.Context, *NatVpnMappingRequestMsg) (*NatVpnMappingResponseMsg, error)
	NatVpnMappingGet(context.Context, *NatVpnMappingGetRequestMsg) (*NatVpnMappingGetResponseMsg, error)
}

func RegisterNatServer(s *grpc.Server, srv NatServer) {
	s.RegisterService(&_Nat_serviceDesc, srv)
}

func _Nat_NatRuleCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NatRuleRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NatServer).NatRuleCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nat.Nat/NatRuleCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NatServer).NatRuleCreate(ctx, req.(*NatRuleRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Nat_NatRuleGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NatRuleGetRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NatServer).NatRuleGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nat.Nat/NatRuleGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NatServer).NatRuleGet(ctx, req.(*NatRuleGetRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Nat_NatVpnMappingCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NatVpnMappingRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NatServer).NatVpnMappingCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nat.Nat/NatVpnMappingCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NatServer).NatVpnMappingCreate(ctx, req.(*NatVpnMappingRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Nat_NatVpnMappingGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NatVpnMappingGetRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NatServer).NatVpnMappingGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nat.Nat/NatVpnMappingGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NatServer).NatVpnMappingGet(ctx, req.(*NatVpnMappingGetRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

var _Nat_serviceDesc = grpc.ServiceDesc{
	ServiceName: "nat.Nat",
	HandlerType: (*NatServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "NatRuleCreate",
			Handler:    _Nat_NatRuleCreate_Handler,
		},
		{
			MethodName: "NatRuleGet",
			Handler:    _Nat_NatRuleGet_Handler,
		},
		{
			MethodName: "NatVpnMappingCreate",
			Handler:    _Nat_NatVpnMappingCreate_Handler,
		},
		{
			MethodName: "NatVpnMappingGet",
			Handler:    _Nat_NatVpnMappingGet_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "nat.proto.draft",
}

func (m *NatPool) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatPool) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Address) > 0 {
		for _, msg := range m.Address {
			dAtA[i] = 0xa
			i++
			i = encodeVarintNatDraft(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.PortRange != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNatDraft(dAtA, i, uint64(m.PortRange.Size()))
		n1, err := m.PortRange.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	return i, nil
}

func (m *NatRuleSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatRuleSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNatDraft(dAtA, i, uint64(m.Meta.Size()))
		n2, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.KeyOrHandle != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNatDraft(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n3, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if len(m.SrcAddress) > 0 {
		for _, msg := range m.SrcAddress {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintNatDraft(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.SrcSg) > 0 {
		dAtA5 := make([]byte, len(m.SrcSg)*10)
		var j4 int
		for _, num := range m.SrcSg {
			for num >= 1<<7 {
				dAtA5[j4] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j4++
			}
			dAtA5[j4] = uint8(num)
			j4++
		}
		dAtA[i] = 0x22
		i++
		i = encodeVarintNatDraft(dAtA, i, uint64(j4))
		i += copy(dAtA[i:], dAtA5[:j4])
	}
	if len(m.DstAddress) > 0 {
		for _, msg := range m.DstAddress {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintNatDraft(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.DstSg) > 0 {
		dAtA7 := make([]byte, len(m.DstSg)*10)
		var j6 int
		for _, num := range m.DstSg {
			for num >= 1<<7 {
				dAtA7[j6] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j6++
			}
			dAtA7[j6] = uint8(num)
			j6++
		}
		dAtA[i] = 0x32
		i++
		i = encodeVarintNatDraft(dAtA, i, uint64(j6))
		i += copy(dAtA[i:], dAtA7[:j6])
	}
	if len(m.DstPortRange) > 0 {
		for _, msg := range m.DstPortRange {
			dAtA[i] = 0x3a
			i++
			i = encodeVarintNatDraft(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.SrcPortRange) > 0 {
		for _, msg := range m.SrcPortRange {
			dAtA[i] = 0x42
			i++
			i = encodeVarintNatDraft(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.SrcNatAction != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintNatDraft(dAtA, i, uint64(m.SrcNatAction))
	}
	if m.DstNatAction != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintNatDraft(dAtA, i, uint64(m.DstNatAction))
	}
	if m.SrcNatPool != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintNatDraft(dAtA, i, uint64(m.SrcNatPool.Size()))
		n8, err := m.SrcNatPool.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.DstNatPool != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintNatDraft(dAtA, i, uint64(m.DstNatPool.Size()))
		n9, err := m.DstNatPool.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	return i, nil
}

func (m *NatRuleRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatRuleRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintNatDraft(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *NatRuleStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatRuleStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Handle != 0 {
		dAtA[i] = 0x9
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.Handle))
		i += 8
	}
	return i, nil
}

func (m *NatRuleResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatRuleResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNatDraft(dAtA, i, uint64(m.ApiStatus))
	}
	if m.Status != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNatDraft(dAtA, i, uint64(m.Status.Size()))
		n10, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	return i, nil
}

func (m *NatRuleResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatRuleResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintNatDraft(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *NatRuleGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatRuleGetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNatDraft(dAtA, i, uint64(m.Meta.Size()))
		n11, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if m.KeyOrHandle != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNatDraft(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n12, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	return i, nil
}

func (m *NatRuleGetRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatRuleGetRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintNatDraft(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *NatRuleStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatRuleStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.NumTcpSessions != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNatDraft(dAtA, i, uint64(m.NumTcpSessions))
	}
	if m.NumUdpSessions != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintNatDraft(dAtA, i, uint64(m.NumUdpSessions))
	}
	if m.NumOtherSessions != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintNatDraft(dAtA, i, uint64(m.NumOtherSessions))
	}
	return i, nil
}

func (m *NatRuleGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatRuleGetResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNatDraft(dAtA, i, uint64(m.ApiStatus))
	}
	if m.Spec != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNatDraft(dAtA, i, uint64(m.Spec.Size()))
		n13, err := m.Spec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if m.Status != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintNatDraft(dAtA, i, uint64(m.Status.Size()))
		n14, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	if m.Stats != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintNatDraft(dAtA, i, uint64(m.Stats.Size()))
		n15, err := m.Stats.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	return i, nil
}

func (m *NatRuleGetResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatRuleGetResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNatDraft(dAtA, i, uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0x12
			i++
			i = encodeVarintNatDraft(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *NatVpnMappingSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatVpnMappingSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNatDraft(dAtA, i, uint64(m.Meta.Size()))
		n16, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	if m.KeyOrHandle != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNatDraft(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n17, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	return i, nil
}

func (m *NatVpnMappingRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatVpnMappingRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintNatDraft(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *NatVpnMappingStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatVpnMappingStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Handle != 0 {
		dAtA[i] = 0x9
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.Handle))
		i += 8
	}
	if m.SvcMapping != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNatDraft(dAtA, i, uint64(m.SvcMapping.Size()))
		n18, err := m.SvcMapping.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	return i, nil
}

func (m *NatVpnMappingResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatVpnMappingResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNatDraft(dAtA, i, uint64(m.ApiStatus))
	}
	if m.Status != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNatDraft(dAtA, i, uint64(m.Status.Size()))
		n19, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	return i, nil
}

func (m *NatVpnMappingResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatVpnMappingResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintNatDraft(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *NatVpnMappingGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatVpnMappingGetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNatDraft(dAtA, i, uint64(m.Meta.Size()))
		n20, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	if m.KeyOrHandle != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNatDraft(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n21, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	return i, nil
}

func (m *NatVpnMappingGetRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatVpnMappingGetRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintNatDraft(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *NatVpnMappingStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatVpnMappingStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RxBytes != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNatDraft(dAtA, i, uint64(m.RxBytes))
	}
	if m.RxPackets != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintNatDraft(dAtA, i, uint64(m.RxPackets))
	}
	if m.TxBytes != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintNatDraft(dAtA, i, uint64(m.TxBytes))
	}
	if m.TxPackets != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintNatDraft(dAtA, i, uint64(m.TxPackets))
	}
	if m.RxBytesDropped != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintNatDraft(dAtA, i, uint64(m.RxBytesDropped))
	}
	if m.RxPacketsDropped != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintNatDraft(dAtA, i, uint64(m.RxPacketsDropped))
	}
	if m.TxBytesDropped != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintNatDraft(dAtA, i, uint64(m.TxBytesDropped))
	}
	if m.TxPacketsDropped != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintNatDraft(dAtA, i, uint64(m.TxPacketsDropped))
	}
	if m.NumTcpSessions != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintNatDraft(dAtA, i, uint64(m.NumTcpSessions))
	}
	if m.NumUdpSessions != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintNatDraft(dAtA, i, uint64(m.NumUdpSessions))
	}
	if m.NumOtherSessions != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintNatDraft(dAtA, i, uint64(m.NumOtherSessions))
	}
	if m.NumActiveConnections != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintNatDraft(dAtA, i, uint64(m.NumActiveConnections))
	}
	return i, nil
}

func (m *NatVpnMappingGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatVpnMappingGetResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNatDraft(dAtA, i, uint64(m.ApiStatus))
	}
	if m.Spec != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNatDraft(dAtA, i, uint64(m.Spec.Size()))
		n22, err := m.Spec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	if m.Status != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintNatDraft(dAtA, i, uint64(m.Status.Size()))
		n23, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	if m.Stats != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintNatDraft(dAtA, i, uint64(m.Stats.Size()))
		n24, err := m.Stats.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	return i, nil
}

func (m *NatVpnMappingGetResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NatVpnMappingGetResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNatDraft(dAtA, i, uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0x12
			i++
			i = encodeVarintNatDraft(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func encodeVarintNatDraft(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *NatPool) Size() (n int) {
	var l int
	_ = l
	if len(m.Address) > 0 {
		for _, e := range m.Address {
			l = e.Size()
			n += 1 + l + sovNatDraft(uint64(l))
		}
	}
	if m.PortRange != nil {
		l = m.PortRange.Size()
		n += 1 + l + sovNatDraft(uint64(l))
	}
	return n
}

func (m *NatRuleSpec) Size() (n int) {
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovNatDraft(uint64(l))
	}
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovNatDraft(uint64(l))
	}
	if len(m.SrcAddress) > 0 {
		for _, e := range m.SrcAddress {
			l = e.Size()
			n += 1 + l + sovNatDraft(uint64(l))
		}
	}
	if len(m.SrcSg) > 0 {
		l = 0
		for _, e := range m.SrcSg {
			l += sovNatDraft(uint64(e))
		}
		n += 1 + sovNatDraft(uint64(l)) + l
	}
	if len(m.DstAddress) > 0 {
		for _, e := range m.DstAddress {
			l = e.Size()
			n += 1 + l + sovNatDraft(uint64(l))
		}
	}
	if len(m.DstSg) > 0 {
		l = 0
		for _, e := range m.DstSg {
			l += sovNatDraft(uint64(e))
		}
		n += 1 + sovNatDraft(uint64(l)) + l
	}
	if len(m.DstPortRange) > 0 {
		for _, e := range m.DstPortRange {
			l = e.Size()
			n += 1 + l + sovNatDraft(uint64(l))
		}
	}
	if len(m.SrcPortRange) > 0 {
		for _, e := range m.SrcPortRange {
			l = e.Size()
			n += 1 + l + sovNatDraft(uint64(l))
		}
	}
	if m.SrcNatAction != 0 {
		n += 1 + sovNatDraft(uint64(m.SrcNatAction))
	}
	if m.DstNatAction != 0 {
		n += 1 + sovNatDraft(uint64(m.DstNatAction))
	}
	if m.SrcNatPool != nil {
		l = m.SrcNatPool.Size()
		n += 1 + l + sovNatDraft(uint64(l))
	}
	if m.DstNatPool != nil {
		l = m.DstNatPool.Size()
		n += 1 + l + sovNatDraft(uint64(l))
	}
	return n
}

func (m *NatRuleRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovNatDraft(uint64(l))
		}
	}
	return n
}

func (m *NatRuleStatus) Size() (n int) {
	var l int
	_ = l
	if m.Handle != 0 {
		n += 9
	}
	return n
}

func (m *NatRuleResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovNatDraft(uint64(m.ApiStatus))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovNatDraft(uint64(l))
	}
	return n
}

func (m *NatRuleResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovNatDraft(uint64(l))
		}
	}
	return n
}

func (m *NatRuleGetRequest) Size() (n int) {
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovNatDraft(uint64(l))
	}
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovNatDraft(uint64(l))
	}
	return n
}

func (m *NatRuleGetRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovNatDraft(uint64(l))
		}
	}
	return n
}

func (m *NatRuleStats) Size() (n int) {
	var l int
	_ = l
	if m.NumTcpSessions != 0 {
		n += 1 + sovNatDraft(uint64(m.NumTcpSessions))
	}
	if m.NumUdpSessions != 0 {
		n += 1 + sovNatDraft(uint64(m.NumUdpSessions))
	}
	if m.NumOtherSessions != 0 {
		n += 1 + sovNatDraft(uint64(m.NumOtherSessions))
	}
	return n
}

func (m *NatRuleGetResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovNatDraft(uint64(m.ApiStatus))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovNatDraft(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovNatDraft(uint64(l))
	}
	if m.Stats != nil {
		l = m.Stats.Size()
		n += 1 + l + sovNatDraft(uint64(l))
	}
	return n
}

func (m *NatRuleGetResponseMsg) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovNatDraft(uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovNatDraft(uint64(l))
		}
	}
	return n
}

func (m *NatVpnMappingSpec) Size() (n int) {
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovNatDraft(uint64(l))
	}
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovNatDraft(uint64(l))
	}
	return n
}

func (m *NatVpnMappingRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovNatDraft(uint64(l))
		}
	}
	return n
}

func (m *NatVpnMappingStatus) Size() (n int) {
	var l int
	_ = l
	if m.Handle != 0 {
		n += 9
	}
	if m.SvcMapping != nil {
		l = m.SvcMapping.Size()
		n += 1 + l + sovNatDraft(uint64(l))
	}
	return n
}

func (m *NatVpnMappingResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovNatDraft(uint64(m.ApiStatus))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovNatDraft(uint64(l))
	}
	return n
}

func (m *NatVpnMappingResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovNatDraft(uint64(l))
		}
	}
	return n
}

func (m *NatVpnMappingGetRequest) Size() (n int) {
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovNatDraft(uint64(l))
	}
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovNatDraft(uint64(l))
	}
	return n
}

func (m *NatVpnMappingGetRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovNatDraft(uint64(l))
		}
	}
	return n
}

func (m *NatVpnMappingStats) Size() (n int) {
	var l int
	_ = l
	if m.RxBytes != 0 {
		n += 1 + sovNatDraft(uint64(m.RxBytes))
	}
	if m.RxPackets != 0 {
		n += 1 + sovNatDraft(uint64(m.RxPackets))
	}
	if m.TxBytes != 0 {
		n += 1 + sovNatDraft(uint64(m.TxBytes))
	}
	if m.TxPackets != 0 {
		n += 1 + sovNatDraft(uint64(m.TxPackets))
	}
	if m.RxBytesDropped != 0 {
		n += 1 + sovNatDraft(uint64(m.RxBytesDropped))
	}
	if m.RxPacketsDropped != 0 {
		n += 1 + sovNatDraft(uint64(m.RxPacketsDropped))
	}
	if m.TxBytesDropped != 0 {
		n += 1 + sovNatDraft(uint64(m.TxBytesDropped))
	}
	if m.TxPacketsDropped != 0 {
		n += 1 + sovNatDraft(uint64(m.TxPacketsDropped))
	}
	if m.NumTcpSessions != 0 {
		n += 1 + sovNatDraft(uint64(m.NumTcpSessions))
	}
	if m.NumUdpSessions != 0 {
		n += 1 + sovNatDraft(uint64(m.NumUdpSessions))
	}
	if m.NumOtherSessions != 0 {
		n += 1 + sovNatDraft(uint64(m.NumOtherSessions))
	}
	if m.NumActiveConnections != 0 {
		n += 1 + sovNatDraft(uint64(m.NumActiveConnections))
	}
	return n
}

func (m *NatVpnMappingGetResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovNatDraft(uint64(m.ApiStatus))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovNatDraft(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovNatDraft(uint64(l))
	}
	if m.Stats != nil {
		l = m.Stats.Size()
		n += 1 + l + sovNatDraft(uint64(l))
	}
	return n
}

func (m *NatVpnMappingGetResponseMsg) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovNatDraft(uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovNatDraft(uint64(l))
		}
	}
	return n
}

func sovNatDraft(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozNatDraft(x uint64) (n int) {
	return sovNatDraft(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *NatPool) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNatDraft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatPool: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatPool: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNatDraft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNatDraft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = append(m.Address, &Address{})
			if err := m.Address[len(m.Address)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNatDraft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNatDraft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PortRange == nil {
				m.PortRange = &L4PortRange{}
			}
			if err := m.PortRange.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNatDraft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNatDraft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatRuleSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNatDraft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatRuleSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatRuleSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNatDraft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNatDraft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &ObjectMeta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNatDraft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNatDraft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &NatRuleKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcAddress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNatDraft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNatDraft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SrcAddress = append(m.SrcAddress, &IPAddressObj{})
			if err := m.SrcAddress[len(m.SrcAddress)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNatDraft
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SrcSg = append(m.SrcSg, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNatDraft
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthNatDraft
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNatDraft
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SrcSg = append(m.SrcSg, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcSg", wireType)
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstAddress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNatDraft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNatDraft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DstAddress = append(m.DstAddress, &IPAddressObj{})
			if err := m.DstAddress[len(m.DstAddress)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNatDraft
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.DstSg = append(m.DstSg, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNatDraft
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthNatDraft
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNatDraft
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.DstSg = append(m.DstSg, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field DstSg", wireType)
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstPortRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNatDraft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNatDraft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DstPortRange = append(m.DstPortRange, &L4PortRange{})
			if err := m.DstPortRange[len(m.DstPortRange)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcPortRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNatDraft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNatDraft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SrcPortRange = append(m.SrcPortRange, &L4PortRange{})
			if err := m.SrcPortRange[len(m.SrcPortRange)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcNatAction", wireType)
			}
			m.SrcNatAction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNatDraft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SrcNatAction |= (NatAction(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstNatAction", wireType)
			}
			m.DstNatAction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNatDraft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DstNatAction |= (NatAction(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcNatPool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNatDraft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNatDraft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SrcNatPool == nil {
				m.SrcNatPool = &NatPool{}
			}
			if err := m.SrcNatPool.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstNatPool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNatDraft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNatDraft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DstNatPool == nil {
				m.DstNatPool = &NatPool{}
			}
			if err := m.DstNatPool.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNatDraft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNatDraft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatRuleRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNatDraft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatRuleRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatRuleRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNatDraft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNatDraft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &NatRuleSpec{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNatDraft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNatDraft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatRuleStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNatDraft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatRuleStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatRuleStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Handle", wireType)
			}
			m.Handle = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.Handle = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		default:
			iNdEx = preIndex
			skippy, err := skipNatDraft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNatDraft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatRuleResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNatDraft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatRuleResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatRuleResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNatDraft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNatDraft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNatDraft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &NatRuleStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNatDraft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNatDraft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatRuleResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNatDraft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatRuleResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatRuleResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNatDraft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNatDraft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &NatRuleResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNatDraft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNatDraft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatRuleGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNatDraft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatRuleGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatRuleGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNatDraft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNatDraft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &ObjectMeta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNatDraft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNatDraft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &NatRuleKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNatDraft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNatDraft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatRuleGetRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNatDraft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatRuleGetRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatRuleGetRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNatDraft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNatDraft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &NatRuleGetRequest{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNatDraft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNatDraft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatRuleStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNatDraft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatRuleStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatRuleStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumTcpSessions", wireType)
			}
			m.NumTcpSessions = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNatDraft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumTcpSessions |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumUdpSessions", wireType)
			}
			m.NumUdpSessions = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNatDraft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumUdpSessions |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumOtherSessions", wireType)
			}
			m.NumOtherSessions = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNatDraft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumOtherSessions |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNatDraft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNatDraft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatRuleGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNatDraft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatRuleGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatRuleGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNatDraft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNatDraft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNatDraft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &NatRuleSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNatDraft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNatDraft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &NatRuleStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNatDraft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNatDraft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = &NatRuleStats{}
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNatDraft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNatDraft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatRuleGetResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNatDraft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatRuleGetResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatRuleGetResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNatDraft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNatDraft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNatDraft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &NatRuleGetResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNatDraft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNatDraft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatVpnMappingSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNatDraft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatVpnMappingSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatVpnMappingSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNatDraft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNatDraft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &ObjectMeta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNatDraft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNatDraft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &NatVpnMappingKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNatDraft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNatDraft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatVpnMappingRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNatDraft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatVpnMappingRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatVpnMappingRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNatDraft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNatDraft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &NatVpnMappingSpec{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNatDraft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNatDraft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatVpnMappingStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNatDraft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatVpnMappingStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatVpnMappingStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Handle", wireType)
			}
			m.Handle = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.Handle = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SvcMapping", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNatDraft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNatDraft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SvcMapping == nil {
				m.SvcMapping = &Svc{}
			}
			if err := m.SvcMapping.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNatDraft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNatDraft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatVpnMappingResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNatDraft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatVpnMappingResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatVpnMappingResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNatDraft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNatDraft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNatDraft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &NatVpnMappingStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNatDraft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNatDraft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatVpnMappingResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNatDraft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatVpnMappingResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatVpnMappingResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNatDraft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNatDraft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &NatVpnMappingResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNatDraft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNatDraft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatVpnMappingGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNatDraft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatVpnMappingGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatVpnMappingGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNatDraft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNatDraft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &ObjectMeta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNatDraft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNatDraft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &NatVpnMappingKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNatDraft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNatDraft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatVpnMappingGetRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNatDraft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatVpnMappingGetRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatVpnMappingGetRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNatDraft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNatDraft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &NatVpnMappingGetRequest{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNatDraft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNatDraft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatVpnMappingStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNatDraft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatVpnMappingStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatVpnMappingStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RxBytes", wireType)
			}
			m.RxBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNatDraft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RxBytes |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RxPackets", wireType)
			}
			m.RxPackets = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNatDraft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RxPackets |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxBytes", wireType)
			}
			m.TxBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNatDraft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TxBytes |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxPackets", wireType)
			}
			m.TxPackets = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNatDraft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TxPackets |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RxBytesDropped", wireType)
			}
			m.RxBytesDropped = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNatDraft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RxBytesDropped |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RxPacketsDropped", wireType)
			}
			m.RxPacketsDropped = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNatDraft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RxPacketsDropped |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxBytesDropped", wireType)
			}
			m.TxBytesDropped = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNatDraft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TxBytesDropped |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxPacketsDropped", wireType)
			}
			m.TxPacketsDropped = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNatDraft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TxPacketsDropped |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumTcpSessions", wireType)
			}
			m.NumTcpSessions = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNatDraft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumTcpSessions |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumUdpSessions", wireType)
			}
			m.NumUdpSessions = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNatDraft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumUdpSessions |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumOtherSessions", wireType)
			}
			m.NumOtherSessions = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNatDraft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumOtherSessions |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumActiveConnections", wireType)
			}
			m.NumActiveConnections = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNatDraft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumActiveConnections |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNatDraft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNatDraft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatVpnMappingGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNatDraft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatVpnMappingGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatVpnMappingGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNatDraft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNatDraft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNatDraft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &NatVpnMappingSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNatDraft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNatDraft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &NatVpnMappingStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNatDraft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNatDraft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = &NatVpnMappingStats{}
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNatDraft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNatDraft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NatVpnMappingGetResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNatDraft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NatVpnMappingGetResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NatVpnMappingGetResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNatDraft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNatDraft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNatDraft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &NatVpnMappingGetResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNatDraft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNatDraft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipNatDraft(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowNatDraft
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowNatDraft
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowNatDraft
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthNatDraft
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowNatDraft
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipNatDraft(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthNatDraft = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowNatDraft   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("nat.proto.draft", fileDescriptorNatDraft) }

var fileDescriptorNatDraft = []byte{
	// 1253 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x57, 0xcf, 0x6f, 0x1b, 0x45,
	0x14, 0xee, 0xc6, 0x8e, 0x9d, 0x3c, 0x3b, 0xae, 0x33, 0x4d, 0x93, 0xad, 0xdb, 0xfc, 0x60, 0x05,
	0xaa, 0x15, 0x81, 0x55, 0xd2, 0x08, 0x01, 0x97, 0xca, 0x69, 0x52, 0x5a, 0x4a, 0x6c, 0x6b, 0x6d,
	0xa8, 0xca, 0x65, 0xb5, 0xd9, 0x9d, 0x3a, 0xae, 0x93, 0xdd, 0x65, 0x67, 0x1c, 0xc5, 0x12, 0xe2,
	0xc8, 0x01, 0x71, 0x40, 0x88, 0x03, 0x47, 0xfe, 0x13, 0xae, 0x1c, 0xb9, 0x21, 0x71, 0xa8, 0x50,
	0xb9, 0x71, 0x01, 0xf5, 0x2f, 0x40, 0xf3, 0x63, 0x7f, 0x78, 0x77, 0x9d, 0x26, 0x52, 0x10, 0xa7,
	0x78, 0xe6, 0x7d, 0xdf, 0x37, 0xf3, 0x66, 0xbe, 0x7d, 0x6f, 0x02, 0x57, 0x1d, 0x93, 0x36, 0x3c,
	0xdf, 0xa5, 0x6e, 0xc3, 0xf6, 0xcd, 0x67, 0x14, 0xe5, 0x1c, 0x93, 0xd6, 0x4a, 0x74, 0xec, 0x61,
	0x22, 0xe6, 0x6b, 0x73, 0xc3, 0x43, 0xf1, 0x4b, 0x7b, 0x06, 0xc5, 0x96, 0x49, 0x3b, 0xae, 0x7b,
	0x84, 0xea, 0x50, 0x34, 0x6d, 0xdb, 0xc7, 0x84, 0xa8, 0xca, 0x46, 0xae, 0x5e, 0xda, 0xaa, 0x34,
	0x04, 0xa7, 0x29, 0x66, 0xf5, 0x20, 0x8c, 0xde, 0x05, 0xf0, 0x5c, 0x9f, 0x1a, 0xbe, 0xe9, 0xf4,
	0xb1, 0x3a, 0xb3, 0xa1, 0xd4, 0x4b, 0x5b, 0x48, 0x82, 0x3f, 0xd9, 0xee, 0xb8, 0x3e, 0xd5, 0x59,
	0x44, 0x9f, 0xf7, 0x82, 0x9f, 0xda, 0xef, 0x79, 0x28, 0xb5, 0x4c, 0xaa, 0x8f, 0x8e, 0x70, 0xd7,
	0xc3, 0x16, 0x7a, 0x0b, 0xf2, 0xc7, 0x98, 0x9a, 0xaa, 0xc2, 0xc9, 0x8b, 0x92, 0xdc, 0x3e, 0x78,
	0x8e, 0x2d, 0xba, 0x8f, 0xa9, 0xa9, 0xf3, 0x30, 0xfa, 0x18, 0x16, 0x86, 0x78, 0x6c, 0xb8, 0xbe,
	0x71, 0x68, 0x3a, 0xf6, 0x51, 0xb0, 0xd8, 0x52, 0x63, 0x78, 0xd8, 0x90, 0x72, 0x8f, 0xf1, 0xf8,
	0x21, 0x8f, 0xed, 0x54, 0x5f, 0xbd, 0x58, 0x2f, 0x9f, 0x60, 0x67, 0x60, 0xe1, 0x0f, 0xb5, 0x21,
	0x1e, 0x6b, 0x7a, 0x69, 0x88, 0xc7, 0x6d, 0x5f, 0x84, 0xd1, 0x36, 0x94, 0x88, 0x6f, 0x19, 0x41,
	0x8e, 0x39, 0x9e, 0xe3, 0x35, 0xb9, 0xf2, 0xa3, 0x8e, 0xcc, 0xb2, 0x7d, 0xf0, 0x5c, 0x07, 0xe2,
	0x5b, 0x72, 0x88, 0xae, 0x43, 0x81, 0xb1, 0x48, 0x5f, 0xcd, 0x6f, 0xe4, 0xea, 0x0b, 0xfa, 0x2c,
	0xf1, 0xad, 0x6e, 0x9f, 0x89, 0xd9, 0x84, 0x86, 0x62, 0xb3, 0x67, 0x88, 0xd9, 0x84, 0xc6, 0xc4,
	0x18, 0x8b, 0xf4, 0xd5, 0x82, 0x10, 0xb3, 0x09, 0xed, 0xf6, 0xd1, 0xfb, 0x50, 0x61, 0xd3, 0xb1,
	0x33, 0x2d, 0x72, 0xbd, 0xac, 0x33, 0x2d, 0xdb, 0x84, 0x86, 0x23, 0xc6, 0x64, 0xbb, 0x8b, 0x31,
	0xe7, 0xa6, 0x33, 0x89, 0x6f, 0x45, 0xcc, 0x6d, 0xc1, 0x74, 0x4c, 0x6a, 0x98, 0x16, 0x1d, 0xb8,
	0x8e, 0x3a, 0xbf, 0xa1, 0xd4, 0x2b, 0x5b, 0x95, 0x06, 0xb3, 0x4f, 0xcb, 0xa4, 0x4d, 0x3e, 0xcb,
	0x59, 0xe1, 0x88, 0xb1, 0xd8, 0x4e, 0x63, 0x2c, 0xc8, 0x66, 0xd9, 0x84, 0x46, 0xac, 0x06, 0x94,
	0x83, 0xb5, 0x3c, 0xd7, 0x3d, 0x52, 0x4b, 0xfc, 0x12, 0xcb, 0x01, 0x87, 0xb9, 0x8f, 0x9f, 0x79,
	0xe0, 0xc4, 0x06, 0x94, 0x83, 0x55, 0x38, 0xbe, 0x9c, 0x85, 0x17, 0x2b, 0xb0, 0xdf, 0xda, 0x3d,
	0x58, 0x94, 0x66, 0xd0, 0xf1, 0x17, 0x23, 0x4c, 0xe8, 0x3e, 0xe9, 0xa3, 0x4d, 0x28, 0xfa, 0x62,
	0x24, 0xed, 0x5c, 0x0d, 0xf8, 0x81, 0x09, 0xf5, 0x00, 0xa0, 0xdd, 0x86, 0x85, 0x60, 0x9e, 0x9a,
	0x74, 0x44, 0xd0, 0x32, 0x14, 0xa4, 0xe1, 0x98, 0x41, 0x0b, 0xba, 0x1c, 0x69, 0x5f, 0xc1, 0xd5,
	0x70, 0x25, 0xe2, 0xb9, 0x0e, 0xc1, 0xe8, 0x1e, 0x80, 0xe9, 0x0d, 0x0c, 0xc2, 0x89, 0x1c, 0x5e,
	0xd9, 0xaa, 0x06, 0x5f, 0x8e, 0x37, 0x10, 0x82, 0x3b, 0x95, 0xbf, 0x5e, 0xac, 0xc7, 0x70, 0xfa,
	0xbc, 0x19, 0x84, 0xd0, 0x26, 0x14, 0x24, 0x39, 0xf8, 0x92, 0xe2, 0xfb, 0x14, 0x70, 0x89, 0xd0,
	0x1e, 0x00, 0x4a, 0xac, 0xcf, 0x52, 0xbd, 0x03, 0x73, 0xbe, 0x1c, 0xca, 0x5c, 0x97, 0xe2, 0x1a,
	0x01, 0x54, 0x0f, 0x51, 0xda, 0xd7, 0x4a, 0x78, 0x64, 0x1f, 0x61, 0x2a, 0x4f, 0xed, 0x7f, 0xf8,
	0x28, 0xb5, 0x87, 0xb0, 0x94, 0xda, 0x87, 0x48, 0x29, 0x71, 0x7b, 0xcb, 0xf1, 0x8c, 0x22, 0x6c,
	0x74, 0x87, 0xdf, 0x29, 0x50, 0x8e, 0x1d, 0x1a, 0x41, 0x75, 0xa8, 0x3a, 0xa3, 0x63, 0x83, 0x5a,
	0x9e, 0x41, 0x30, 0x21, 0x03, 0xd7, 0x11, 0xd7, 0xb3, 0xa0, 0x57, 0x9c, 0xd1, 0x71, 0xcf, 0xf2,
	0xba, 0x72, 0x36, 0x40, 0x8e, 0xec, 0x18, 0x72, 0x26, 0x44, 0x7e, 0x6a, 0x47, 0xc8, 0xb7, 0x01,
	0x31, 0xa4, 0x4b, 0x0f, 0xb1, 0x1f, 0x61, 0x73, 0x1c, 0xcb, 0x34, 0xda, 0x2c, 0x10, 0xa0, 0xb5,
	0xdf, 0x94, 0xf0, 0xba, 0xf8, 0x8e, 0xa5, 0x63, 0x1e, 0x9c, 0xcb, 0x31, 0xd7, 0x5f, 0xbd, 0x58,
	0x5f, 0x94, 0x07, 0x97, 0x6d, 0x9c, 0x37, 0x21, 0x4f, 0x3c, 0x6c, 0xc9, 0xe3, 0x4f, 0xdb, 0x9b,
	0x47, 0x63, 0xf6, 0xca, 0xbd, 0xce, 0x5e, 0xe8, 0x36, 0xcc, 0xb2, 0x5f, 0x44, 0xcd, 0x4b, 0x07,
	0x24, 0xa0, 0x44, 0x17, 0x71, 0xed, 0x07, 0x05, 0xae, 0xa7, 0x33, 0x63, 0x17, 0x77, 0x59, 0xc9,
	0xdd, 0x8d, 0x79, 0x7a, 0x86, 0x3b, 0x60, 0x25, 0xe5, 0x80, 0x94, 0xad, 0xbf, 0x15, 0xb6, 0xfe,
	0xcc, 0x73, 0xf6, 0x4d, 0xcf, 0x1b, 0x38, 0xfd, 0x8b, 0xf4, 0x9a, 0x4e, 0xb6, 0xad, 0x6b, 0xd2,
	0xd6, 0x91, 0xe8, 0xb9, 0xcd, 0xfd, 0x18, 0x56, 0x26, 0x88, 0xe7, 0xf2, 0xf7, 0xe4, 0xe6, 0x23,
	0x7f, 0x3f, 0x81, 0x6b, 0x93, 0xd1, 0x33, 0x2b, 0x15, 0xaa, 0x43, 0x89, 0x9c, 0x58, 0xc6, 0xb1,
	0x00, 0xcb, 0x5c, 0x8a, 0x2c, 0x97, 0xee, 0x89, 0xa5, 0x03, 0x39, 0xb1, 0xa4, 0x8e, 0xf6, 0x8d,
	0xb8, 0xcb, 0xf8, 0x36, 0x2f, 0xab, 0xb4, 0xdd, 0x49, 0x94, 0x36, 0x35, 0x23, 0xc9, 0xc9, 0x02,
	0xa7, 0x83, 0x9a, 0xb9, 0x17, 0x76, 0x66, 0xef, 0xa5, 0xca, 0x5c, 0x2d, 0xad, 0x97, 0xe1, 0x8a,
	0xef, 0x95, 0xc4, 0x3d, 0x5c, 0xbc, 0xe4, 0x5d, 0xbe, 0x37, 0x7a, 0x50, 0x9b, 0xb2, 0x27, 0x91,
	0x6a, 0xc2, 0x1e, 0xb7, 0xd2, 0x99, 0x66, 0x15, 0xc1, 0x7f, 0x72, 0xbc, 0xe2, 0x4c, 0x1e, 0x2f,
	0x41, 0x37, 0x60, 0xce, 0x3f, 0x35, 0x0e, 0xc6, 0x14, 0x8b, 0x6b, 0xcc, 0xeb, 0x45, 0xff, 0x74,
	0x87, 0x0d, 0xd1, 0x2a, 0x80, 0x7f, 0x6a, 0x78, 0xa6, 0x35, 0xc4, 0x54, 0x5c, 0x53, 0x5e, 0x9f,
	0xf7, 0x4f, 0x3b, 0x62, 0x82, 0x31, 0x69, 0xc0, 0xcc, 0x09, 0x26, 0x8d, 0x98, 0x34, 0x62, 0xe6,
	0x05, 0x93, 0x86, 0xcc, 0x3a, 0x54, 0x83, 0x35, 0x0d, 0xdb, 0x77, 0x3d, 0x0f, 0xdb, 0xea, 0x2c,
	0x07, 0x55, 0xe4, 0xda, 0xbb, 0x62, 0x96, 0x15, 0xd5, 0x68, 0x0b, 0x21, 0xb6, 0xc0, 0xb1, 0xd5,
	0x70, 0x2b, 0x01, 0xba, 0x0e, 0x55, 0x9a, 0xd4, 0x2d, 0x0a, 0x5d, 0x9a, 0xd2, 0xa5, 0x69, 0xdd,
	0x39, 0xa1, 0x4b, 0x33, 0x74, 0x53, 0xed, 0x62, 0xfe, 0xdc, 0xed, 0x02, 0x2e, 0xd0, 0x2e, 0x4a,
	0xd9, 0xed, 0x02, 0x6d, 0xc3, 0x32, 0x43, 0xb3, 0x87, 0xd5, 0x09, 0x36, 0x2c, 0xd7, 0x71, 0x30,
	0x7f, 0x3f, 0x11, 0xfe, 0x00, 0x5a, 0xd0, 0x97, 0x9c, 0xd1, 0x71, 0x93, 0x07, 0xef, 0x47, 0x31,
	0xed, 0x6f, 0x25, 0xf1, 0xc9, 0xfc, 0x17, 0xad, 0x66, 0x73, 0xa2, 0xd5, 0x4c, 0xab, 0x55, 0xa2,
	0xe1, 0xdc, 0x49, 0x34, 0x9c, 0xd7, 0x7e, 0xf4, 0xe8, 0x9d, 0xc9, 0xb6, 0xb3, 0x92, 0x4d, 0x08,
	0x9b, 0xcf, 0x4f, 0x0a, 0xdc, 0x9c, 0x96, 0xf1, 0x65, 0xb6, 0xa0, 0x0f, 0x52, 0x2d, 0x68, 0x75,
	0xca, 0x57, 0x98, 0x2c, 0x39, 0x9b, 0x5f, 0xc2, 0x7c, 0xf4, 0xfc, 0x5d, 0x84, 0x85, 0x56, 0xb3,
	0x67, 0xf4, 0x9e, 0x76, 0xf6, 0x8c, 0x56, 0xbb, 0xb5, 0x57, 0xbd, 0x82, 0x6e, 0xc2, 0x4a, 0x38,
	0xd5, 0xed, 0x35, 0x7b, 0x8f, 0xee, 0x1b, 0xcd, 0xdd, 0x5d, 0x7d, 0xaf, 0xdb, 0xad, 0x2a, 0xe8,
	0x16, 0xa8, 0x61, 0x70, 0xf7, 0x69, 0xab, 0xb9, 0x1f, 0x8b, 0xce, 0xa0, 0x37, 0x60, 0x75, 0x5a,
	0xd4, 0xe8, 0xb4, 0xf5, 0x5e, 0x35, 0xb7, 0xf5, 0xf3, 0x0c, 0xe4, 0x5a, 0x26, 0x45, 0x3b, 0xe1,
	0xb3, 0xf6, 0xbe, 0x8f, 0x4d, 0x8a, 0xd1, 0xf2, 0xe4, 0xb3, 0x30, 0x28, 0x37, 0xb5, 0x95, 0xac,
	0xe7, 0xe2, 0x3e, 0xe9, 0x6b, 0x57, 0xd0, 0x1e, 0x40, 0xd4, 0x72, 0xd1, 0x8d, 0xec, 0x57, 0x18,
	0xd3, 0xa8, 0x4d, 0x69, 0xcf, 0x42, 0xa6, 0x97, 0xe8, 0x5e, 0x72, 0x43, 0xb7, 0xb2, 0x0a, 0x78,
	0x28, 0xb9, 0x3a, 0xbd, 0xbc, 0x0b, 0xd5, 0x27, 0x50, 0x4d, 0x5e, 0x06, 0x5a, 0x3f, 0xab, 0x52,
	0x32, 0xd5, 0x8d, 0x33, 0x2f, 0x91, 0x0b, 0xef, 0xd4, 0x7e, 0x79, 0xb9, 0xa6, 0xfc, 0xfa, 0x72,
	0x4d, 0xf9, 0xe3, 0xe5, 0x9a, 0xf2, 0xe3, 0x9f, 0x6b, 0x57, 0x3e, 0x9f, 0x3b, 0x34, 0x8f, 0xf8,
	0xbf, 0xcc, 0x07, 0x05, 0xfe, 0xe7, 0xee, 0xbf, 0x01, 0x00, 0x00, 0xff, 0xff, 0xa8, 0x8f, 0xae,
	0xf9, 0x68, 0x0f, 0x00, 0x00,
}
