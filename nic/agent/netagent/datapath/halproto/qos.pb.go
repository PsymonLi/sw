// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: qos.proto

package halproto

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import encoding_binary "encoding/binary"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// QosGroup identifier
type QosGroup int32

const (
	QosGroup_DEFAULT                   QosGroup = 0
	QosGroup_USER_DEFINED_1            QosGroup = 1
	QosGroup_USER_DEFINED_2            QosGroup = 2
	QosGroup_USER_DEFINED_3            QosGroup = 3
	QosGroup_USER_DEFINED_4            QosGroup = 4
	QosGroup_USER_DEFINED_5            QosGroup = 5
	QosGroup_USER_DEFINED_6            QosGroup = 6
	QosGroup_CONTROL                   QosGroup = 7
	QosGroup_SPAN                      QosGroup = 8
	QosGroup_INTERNAL_RX_PROXY_NO_DROP QosGroup = 9
	QosGroup_INTERNAL_RX_PROXY_DROP    QosGroup = 10
	QosGroup_INTERNAL_TX_PROXY_NO_DROP QosGroup = 11
	QosGroup_INTERNAL_TX_PROXY_DROP    QosGroup = 12
	QosGroup_INTERNAL_CPU_COPY         QosGroup = 13
)

var QosGroup_name = map[int32]string{
	0:  "DEFAULT",
	1:  "USER_DEFINED_1",
	2:  "USER_DEFINED_2",
	3:  "USER_DEFINED_3",
	4:  "USER_DEFINED_4",
	5:  "USER_DEFINED_5",
	6:  "USER_DEFINED_6",
	7:  "CONTROL",
	8:  "SPAN",
	9:  "INTERNAL_RX_PROXY_NO_DROP",
	10: "INTERNAL_RX_PROXY_DROP",
	11: "INTERNAL_TX_PROXY_NO_DROP",
	12: "INTERNAL_TX_PROXY_DROP",
	13: "INTERNAL_CPU_COPY",
}
var QosGroup_value = map[string]int32{
	"DEFAULT":        0,
	"USER_DEFINED_1": 1,
	"USER_DEFINED_2": 2,
	"USER_DEFINED_3": 3,
	"USER_DEFINED_4": 4,
	"USER_DEFINED_5": 5,
	"USER_DEFINED_6": 6,
	"CONTROL":        7,
	"SPAN":           8,
	"INTERNAL_RX_PROXY_NO_DROP": 9,
	"INTERNAL_RX_PROXY_DROP":    10,
	"INTERNAL_TX_PROXY_NO_DROP": 11,
	"INTERNAL_TX_PROXY_DROP":    12,
	"INTERNAL_CPU_COPY":         13,
}

func (x QosGroup) String() string {
	return proto.EnumName(QosGroup_name, int32(x))
}
func (QosGroup) EnumDescriptor() ([]byte, []int) { return fileDescriptorQos, []int{0} }

// CoppType identifies the type of traffic for the copp policy
type CoppType int32

const (
	CoppType_COPP_TYPE_FLOW_MISS CoppType = 0
	CoppType_COPP_TYPE_ARP       CoppType = 1
	CoppType_COPP_TYPE_DHCP      CoppType = 2
)

var CoppType_name = map[int32]string{
	0: "COPP_TYPE_FLOW_MISS",
	1: "COPP_TYPE_ARP",
	2: "COPP_TYPE_DHCP",
}
var CoppType_value = map[string]int32{
	"COPP_TYPE_FLOW_MISS": 0,
	"COPP_TYPE_ARP":       1,
	"COPP_TYPE_DHCP":      2,
}

func (x CoppType) String() string {
	return proto.EnumName(CoppType_name, int32(x))
}
func (CoppType) EnumDescriptor() ([]byte, []int) { return fileDescriptorQos, []int{1} }

// Specifications of a policer
type PolicerSpec struct {
	BpsRate   uint32 `protobuf:"varint,1,opt,name=bps_rate,json=bpsRate,proto3" json:"bps_rate,omitempty"`
	BurstSize uint32 `protobuf:"varint,2,opt,name=burst_size,json=burstSize,proto3" json:"burst_size,omitempty"`
}

func (m *PolicerSpec) Reset()                    { *m = PolicerSpec{} }
func (m *PolicerSpec) String() string            { return proto.CompactTextString(m) }
func (*PolicerSpec) ProtoMessage()               {}
func (*PolicerSpec) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{0} }

func (m *PolicerSpec) GetBpsRate() uint32 {
	if m != nil {
		return m.BpsRate
	}
	return 0
}

func (m *PolicerSpec) GetBurstSize() uint32 {
	if m != nil {
		return m.BurstSize
	}
	return 0
}

// PolicerStats captures all the statistics of a policer
type PolicerStats struct {
	PermittedPackets uint64 `protobuf:"varint,1,opt,name=permitted_packets,json=permittedPackets,proto3" json:"permitted_packets,omitempty"`
	PermittedBytes   uint64 `protobuf:"varint,2,opt,name=permitted_bytes,json=permittedBytes,proto3" json:"permitted_bytes,omitempty"`
	DroppedPackets   uint64 `protobuf:"varint,3,opt,name=dropped_packets,json=droppedPackets,proto3" json:"dropped_packets,omitempty"`
	DroppedBytes     uint64 `protobuf:"varint,4,opt,name=dropped_bytes,json=droppedBytes,proto3" json:"dropped_bytes,omitempty"`
}

func (m *PolicerStats) Reset()                    { *m = PolicerStats{} }
func (m *PolicerStats) String() string            { return proto.CompactTextString(m) }
func (*PolicerStats) ProtoMessage()               {}
func (*PolicerStats) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{1} }

func (m *PolicerStats) GetPermittedPackets() uint64 {
	if m != nil {
		return m.PermittedPackets
	}
	return 0
}

func (m *PolicerStats) GetPermittedBytes() uint64 {
	if m != nil {
		return m.PermittedBytes
	}
	return 0
}

func (m *PolicerStats) GetDroppedPackets() uint64 {
	if m != nil {
		return m.DroppedPackets
	}
	return 0
}

func (m *PolicerStats) GetDroppedBytes() uint64 {
	if m != nil {
		return m.DroppedBytes
	}
	return 0
}

// QosClassKeyHandle uniquely identifies a QosClass
type QosClassKeyHandle struct {
	// Types that are valid to be assigned to KeyOrHandle:
	//	*QosClassKeyHandle_QosGroup
	//	*QosClassKeyHandle_QosClassHandle
	KeyOrHandle isQosClassKeyHandle_KeyOrHandle `protobuf_oneof:"key_or_handle"`
}

func (m *QosClassKeyHandle) Reset()                    { *m = QosClassKeyHandle{} }
func (m *QosClassKeyHandle) String() string            { return proto.CompactTextString(m) }
func (*QosClassKeyHandle) ProtoMessage()               {}
func (*QosClassKeyHandle) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{2} }

type isQosClassKeyHandle_KeyOrHandle interface {
	isQosClassKeyHandle_KeyOrHandle()
	MarshalTo([]byte) (int, error)
	Size() int
}

type QosClassKeyHandle_QosGroup struct {
	QosGroup QosGroup `protobuf:"varint,1,opt,name=qos_group,json=qosGroup,proto3,enum=qos.QosGroup,oneof"`
}
type QosClassKeyHandle_QosClassHandle struct {
	QosClassHandle uint64 `protobuf:"fixed64,2,opt,name=qos_class_handle,json=qosClassHandle,proto3,oneof"`
}

func (*QosClassKeyHandle_QosGroup) isQosClassKeyHandle_KeyOrHandle()       {}
func (*QosClassKeyHandle_QosClassHandle) isQosClassKeyHandle_KeyOrHandle() {}

func (m *QosClassKeyHandle) GetKeyOrHandle() isQosClassKeyHandle_KeyOrHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

func (m *QosClassKeyHandle) GetQosGroup() QosGroup {
	if x, ok := m.GetKeyOrHandle().(*QosClassKeyHandle_QosGroup); ok {
		return x.QosGroup
	}
	return QosGroup_DEFAULT
}

func (m *QosClassKeyHandle) GetQosClassHandle() uint64 {
	if x, ok := m.GetKeyOrHandle().(*QosClassKeyHandle_QosClassHandle); ok {
		return x.QosClassHandle
	}
	return 0
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*QosClassKeyHandle) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _QosClassKeyHandle_OneofMarshaler, _QosClassKeyHandle_OneofUnmarshaler, _QosClassKeyHandle_OneofSizer, []interface{}{
		(*QosClassKeyHandle_QosGroup)(nil),
		(*QosClassKeyHandle_QosClassHandle)(nil),
	}
}

func _QosClassKeyHandle_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*QosClassKeyHandle)
	// key_or_handle
	switch x := m.KeyOrHandle.(type) {
	case *QosClassKeyHandle_QosGroup:
		_ = b.EncodeVarint(1<<3 | proto.WireVarint)
		_ = b.EncodeVarint(uint64(x.QosGroup))
	case *QosClassKeyHandle_QosClassHandle:
		_ = b.EncodeVarint(2<<3 | proto.WireFixed64)
		_ = b.EncodeFixed64(uint64(x.QosClassHandle))
	case nil:
	default:
		return fmt.Errorf("QosClassKeyHandle.KeyOrHandle has unexpected type %T", x)
	}
	return nil
}

func _QosClassKeyHandle_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*QosClassKeyHandle)
	switch tag {
	case 1: // key_or_handle.qos_group
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.KeyOrHandle = &QosClassKeyHandle_QosGroup{QosGroup(x)}
		return true, err
	case 2: // key_or_handle.qos_class_handle
		if wire != proto.WireFixed64 {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeFixed64()
		m.KeyOrHandle = &QosClassKeyHandle_QosClassHandle{x}
		return true, err
	default:
		return false, nil
	}
}

func _QosClassKeyHandle_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*QosClassKeyHandle)
	// key_or_handle
	switch x := m.KeyOrHandle.(type) {
	case *QosClassKeyHandle_QosGroup:
		n += proto.SizeVarint(1<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.QosGroup))
	case *QosClassKeyHandle_QosClassHandle:
		n += proto.SizeVarint(2<<3 | proto.WireFixed64)
		n += 8
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// QosBuffer specifies the buffer parameters
type QosBuffer struct {
	XonThreshold uint32 `protobuf:"varint,1,opt,name=xon_threshold,json=xonThreshold,proto3" json:"xon_threshold,omitempty"`
	// max occupancy at which to clear the xoff
	XoffClearLimit uint32 `protobuf:"varint,2,opt,name=xoff_clear_limit,json=xoffClearLimit,proto3" json:"xoff_clear_limit,omitempty"`
}

func (m *QosBuffer) Reset()                    { *m = QosBuffer{} }
func (m *QosBuffer) String() string            { return proto.CompactTextString(m) }
func (*QosBuffer) ProtoMessage()               {}
func (*QosBuffer) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{3} }

func (m *QosBuffer) GetXonThreshold() uint32 {
	if m != nil {
		return m.XonThreshold
	}
	return 0
}

func (m *QosBuffer) GetXoffClearLimit() uint32 {
	if m != nil {
		return m.XoffClearLimit
	}
	return 0
}

// QosPFC specifies the pfc cos to respond to
type QosPFC struct {
	PfcCos uint32 `protobuf:"varint,1,opt,name=pfc_cos,json=pfcCos,proto3" json:"pfc_cos,omitempty"`
}

func (m *QosPFC) Reset()                    { *m = QosPFC{} }
func (m *QosPFC) String() string            { return proto.CompactTextString(m) }
func (*QosPFC) ProtoMessage()               {}
func (*QosPFC) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{4} }

func (m *QosPFC) GetPfcCos() uint32 {
	if m != nil {
		return m.PfcCos
	}
	return 0
}

// QosSched specifies the QosClass scheduling configuration
type QosSched struct {
	// Types that are valid to be assigned to SchedType:
	//	*QosSched_Dwrr
	//	*QosSched_Strict
	SchedType isQosSched_SchedType `protobuf_oneof:"SchedType"`
}

func (m *QosSched) Reset()                    { *m = QosSched{} }
func (m *QosSched) String() string            { return proto.CompactTextString(m) }
func (*QosSched) ProtoMessage()               {}
func (*QosSched) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{5} }

type isQosSched_SchedType interface {
	isQosSched_SchedType()
	MarshalTo([]byte) (int, error)
	Size() int
}

type QosSched_Dwrr struct {
	Dwrr *QosSched_DWRRInfo `protobuf:"bytes,1,opt,name=dwrr,oneof"`
}
type QosSched_Strict struct {
	Strict *QosSched_StrictPriorityInfo `protobuf:"bytes,2,opt,name=strict,oneof"`
}

func (*QosSched_Dwrr) isQosSched_SchedType()   {}
func (*QosSched_Strict) isQosSched_SchedType() {}

func (m *QosSched) GetSchedType() isQosSched_SchedType {
	if m != nil {
		return m.SchedType
	}
	return nil
}

func (m *QosSched) GetDwrr() *QosSched_DWRRInfo {
	if x, ok := m.GetSchedType().(*QosSched_Dwrr); ok {
		return x.Dwrr
	}
	return nil
}

func (m *QosSched) GetStrict() *QosSched_StrictPriorityInfo {
	if x, ok := m.GetSchedType().(*QosSched_Strict); ok {
		return x.Strict
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*QosSched) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _QosSched_OneofMarshaler, _QosSched_OneofUnmarshaler, _QosSched_OneofSizer, []interface{}{
		(*QosSched_Dwrr)(nil),
		(*QosSched_Strict)(nil),
	}
}

func _QosSched_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*QosSched)
	// SchedType
	switch x := m.SchedType.(type) {
	case *QosSched_Dwrr:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Dwrr); err != nil {
			return err
		}
	case *QosSched_Strict:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Strict); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("QosSched.SchedType has unexpected type %T", x)
	}
	return nil
}

func _QosSched_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*QosSched)
	switch tag {
	case 1: // SchedType.dwrr
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(QosSched_DWRRInfo)
		err := b.DecodeMessage(msg)
		m.SchedType = &QosSched_Dwrr{msg}
		return true, err
	case 2: // SchedType.strict
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(QosSched_StrictPriorityInfo)
		err := b.DecodeMessage(msg)
		m.SchedType = &QosSched_Strict{msg}
		return true, err
	default:
		return false, nil
	}
}

func _QosSched_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*QosSched)
	// SchedType
	switch x := m.SchedType.(type) {
	case *QosSched_Dwrr:
		s := proto.Size(x.Dwrr)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *QosSched_Strict:
		s := proto.Size(x.Strict)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// DWRR specific information
type QosSched_DWRRInfo struct {
	BwPercentage uint32 `protobuf:"varint,1,opt,name=bw_percentage,json=bwPercentage,proto3" json:"bw_percentage,omitempty"`
}

func (m *QosSched_DWRRInfo) Reset()                    { *m = QosSched_DWRRInfo{} }
func (m *QosSched_DWRRInfo) String() string            { return proto.CompactTextString(m) }
func (*QosSched_DWRRInfo) ProtoMessage()               {}
func (*QosSched_DWRRInfo) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{5, 0} }

func (m *QosSched_DWRRInfo) GetBwPercentage() uint32 {
	if m != nil {
		return m.BwPercentage
	}
	return 0
}

// Strict Priority specific information for the class
type QosSched_StrictPriorityInfo struct {
	Bps uint32 `protobuf:"varint,1,opt,name=bps,proto3" json:"bps,omitempty"`
}

func (m *QosSched_StrictPriorityInfo) Reset()         { *m = QosSched_StrictPriorityInfo{} }
func (m *QosSched_StrictPriorityInfo) String() string { return proto.CompactTextString(m) }
func (*QosSched_StrictPriorityInfo) ProtoMessage()    {}
func (*QosSched_StrictPriorityInfo) Descriptor() ([]byte, []int) {
	return fileDescriptorQos, []int{5, 1}
}

func (m *QosSched_StrictPriorityInfo) GetBps() uint32 {
	if m != nil {
		return m.Bps
	}
	return 0
}

// QosUplinkClassMap specifies the policy with which traffic from network
// is classified
type QosUplinkClassMap struct {
	Dot1QPcp uint32   `protobuf:"varint,1,opt,name=dot1q_pcp,json=dot1qPcp,proto3" json:"dot1q_pcp,omitempty"`
	IpDscp   []uint32 `protobuf:"varint,2,rep,packed,name=ip_dscp,json=ipDscp" json:"ip_dscp,omitempty"`
}

func (m *QosUplinkClassMap) Reset()                    { *m = QosUplinkClassMap{} }
func (m *QosUplinkClassMap) String() string            { return proto.CompactTextString(m) }
func (*QosUplinkClassMap) ProtoMessage()               {}
func (*QosUplinkClassMap) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{6} }

func (m *QosUplinkClassMap) GetDot1QPcp() uint32 {
	if m != nil {
		return m.Dot1QPcp
	}
	return 0
}

func (m *QosUplinkClassMap) GetIpDscp() []uint32 {
	if m != nil {
		return m.IpDscp
	}
	return nil
}

// QosMarking specifies the policy to mark the host-to-network traffic
type QosMarking struct {
	Dot1QPcpRewriteEn bool   `protobuf:"varint,1,opt,name=dot1q_pcp_rewrite_en,json=dot1qPcpRewriteEn,proto3" json:"dot1q_pcp_rewrite_en,omitempty"`
	Dot1QPcp          uint32 `protobuf:"varint,2,opt,name=dot1q_pcp,json=dot1qPcp,proto3" json:"dot1q_pcp,omitempty"`
	IpDscpRewriteEn   bool   `protobuf:"varint,3,opt,name=ip_dscp_rewrite_en,json=ipDscpRewriteEn,proto3" json:"ip_dscp_rewrite_en,omitempty"`
	IpDscp            uint32 `protobuf:"varint,4,opt,name=ip_dscp,json=ipDscp,proto3" json:"ip_dscp,omitempty"`
}

func (m *QosMarking) Reset()                    { *m = QosMarking{} }
func (m *QosMarking) String() string            { return proto.CompactTextString(m) }
func (*QosMarking) ProtoMessage()               {}
func (*QosMarking) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{7} }

func (m *QosMarking) GetDot1QPcpRewriteEn() bool {
	if m != nil {
		return m.Dot1QPcpRewriteEn
	}
	return false
}

func (m *QosMarking) GetDot1QPcp() uint32 {
	if m != nil {
		return m.Dot1QPcp
	}
	return 0
}

func (m *QosMarking) GetIpDscpRewriteEn() bool {
	if m != nil {
		return m.IpDscpRewriteEn
	}
	return false
}

func (m *QosMarking) GetIpDscp() uint32 {
	if m != nil {
		return m.IpDscp
	}
	return 0
}

// QosClass specification
type QosClassSpec struct {
	Meta *ObjectMeta `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	// key_or_handle is QosClass's key or handle
	KeyOrHandle    *QosClassKeyHandle `protobuf:"bytes,2,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty" venice:"key"`
	Mtu            uint32             `protobuf:"varint,3,opt,name=mtu,proto3" json:"mtu,omitempty"`
	Buffer         *QosBuffer         `protobuf:"bytes,4,opt,name=buffer" json:"buffer,omitempty"`
	Pfc            *QosPFC            `protobuf:"bytes,5,opt,name=pfc" json:"pfc,omitempty"`
	Sched          *QosSched          `protobuf:"bytes,6,opt,name=sched" json:"sched,omitempty"`
	UplinkClassMap *QosUplinkClassMap `protobuf:"bytes,7,opt,name=uplink_class_map,json=uplinkClassMap" json:"uplink_class_map,omitempty"`
	Marking        *QosMarking        `protobuf:"bytes,8,opt,name=marking" json:"marking,omitempty"`
}

func (m *QosClassSpec) Reset()                    { *m = QosClassSpec{} }
func (m *QosClassSpec) String() string            { return proto.CompactTextString(m) }
func (*QosClassSpec) ProtoMessage()               {}
func (*QosClassSpec) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{8} }

func (m *QosClassSpec) GetMeta() *ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *QosClassSpec) GetKeyOrHandle() *QosClassKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

func (m *QosClassSpec) GetMtu() uint32 {
	if m != nil {
		return m.Mtu
	}
	return 0
}

func (m *QosClassSpec) GetBuffer() *QosBuffer {
	if m != nil {
		return m.Buffer
	}
	return nil
}

func (m *QosClassSpec) GetPfc() *QosPFC {
	if m != nil {
		return m.Pfc
	}
	return nil
}

func (m *QosClassSpec) GetSched() *QosSched {
	if m != nil {
		return m.Sched
	}
	return nil
}

func (m *QosClassSpec) GetUplinkClassMap() *QosUplinkClassMap {
	if m != nil {
		return m.UplinkClassMap
	}
	return nil
}

func (m *QosClassSpec) GetMarking() *QosMarking {
	if m != nil {
		return m.Marking
	}
	return nil
}

// QosClassRequestMsg is batched request to create/update the QosClasss
type QosClassRequestMsg struct {
	Request []*QosClassSpec `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *QosClassRequestMsg) Reset()                    { *m = QosClassRequestMsg{} }
func (m *QosClassRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*QosClassRequestMsg) ProtoMessage()               {}
func (*QosClassRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{9} }

func (m *QosClassRequestMsg) GetRequest() []*QosClassSpec {
	if m != nil {
		return m.Request
	}
	return nil
}

// QosClassStatus represents the operational status of QosClass
type QosClassStatus struct {
	QosClassHandle uint64 `protobuf:"fixed64,1,opt,name=qos_class_handle,json=qosClassHandle,proto3" json:"qos_class_handle,omitempty"`
}

func (m *QosClassStatus) Reset()                    { *m = QosClassStatus{} }
func (m *QosClassStatus) String() string            { return proto.CompactTextString(m) }
func (*QosClassStatus) ProtoMessage()               {}
func (*QosClassStatus) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{10} }

func (m *QosClassStatus) GetQosClassHandle() uint64 {
	if m != nil {
		return m.QosClassHandle
	}
	return 0
}

// QosClassResponse is response to one QosClassSpec
type QosClassResponse struct {
	ApiStatus ApiStatus       `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty"`
	Status    *QosClassStatus `protobuf:"bytes,2,opt,name=status" json:"status,omitempty"`
}

func (m *QosClassResponse) Reset()                    { *m = QosClassResponse{} }
func (m *QosClassResponse) String() string            { return proto.CompactTextString(m) }
func (*QosClassResponse) ProtoMessage()               {}
func (*QosClassResponse) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{11} }

func (m *QosClassResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *QosClassResponse) GetStatus() *QosClassStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

// QosClassResponseMsg is response to QosClassRequestMsg
type QosClassResponseMsg struct {
	Response []*QosClassResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *QosClassResponseMsg) Reset()                    { *m = QosClassResponseMsg{} }
func (m *QosClassResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*QosClassResponseMsg) ProtoMessage()               {}
func (*QosClassResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{12} }

func (m *QosClassResponseMsg) GetResponse() []*QosClassResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

// QosClassDeleteRequest  is used to delete a QosClass object
type QosClassDeleteRequest struct {
	Meta *ObjectMeta `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	// key_or_handle is to identify QosClass being deleted
	KeyOrHandle *QosClassKeyHandle `protobuf:"bytes,2,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty" venice:"key"`
}

func (m *QosClassDeleteRequest) Reset()                    { *m = QosClassDeleteRequest{} }
func (m *QosClassDeleteRequest) String() string            { return proto.CompactTextString(m) }
func (*QosClassDeleteRequest) ProtoMessage()               {}
func (*QosClassDeleteRequest) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{13} }

func (m *QosClassDeleteRequest) GetMeta() *ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *QosClassDeleteRequest) GetKeyOrHandle() *QosClassKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

// QosClassDeleteRequestMsg is used to delete a batch of QosClasss
type QosClassDeleteRequestMsg struct {
	Request []*QosClassDeleteRequest `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *QosClassDeleteRequestMsg) Reset()                    { *m = QosClassDeleteRequestMsg{} }
func (m *QosClassDeleteRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*QosClassDeleteRequestMsg) ProtoMessage()               {}
func (*QosClassDeleteRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{14} }

func (m *QosClassDeleteRequestMsg) GetRequest() []*QosClassDeleteRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

// QosClassDeleteResponse is response to QosClass delete request
type QosClassDeleteResponse struct {
	ApiStatus ApiStatus `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty" venice:api_status`
}

func (m *QosClassDeleteResponse) Reset()                    { *m = QosClassDeleteResponse{} }
func (m *QosClassDeleteResponse) String() string            { return proto.CompactTextString(m) }
func (*QosClassDeleteResponse) ProtoMessage()               {}
func (*QosClassDeleteResponse) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{15} }

func (m *QosClassDeleteResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

// QosClassDeleteResponseMsg is batched response to QosClassDeleteRequestMsg
type QosClassDeleteResponseMsg struct {
	Response []*QosClassDeleteResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *QosClassDeleteResponseMsg) Reset()                    { *m = QosClassDeleteResponseMsg{} }
func (m *QosClassDeleteResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*QosClassDeleteResponseMsg) ProtoMessage()               {}
func (*QosClassDeleteResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{16} }

func (m *QosClassDeleteResponseMsg) GetResponse() []*QosClassDeleteResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

// QosClassStats captures all the statistics of given QosClass
type QosClassStats struct {
}

func (m *QosClassStats) Reset()                    { *m = QosClassStats{} }
func (m *QosClassStats) String() string            { return proto.CompactTextString(m) }
func (*QosClassStats) ProtoMessage()               {}
func (*QosClassStats) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{17} }

// QosClassGetRequest is used to get information about a QosClass
type QosClassGetRequest struct {
	Meta *ObjectMeta `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	// key_or_handle is to identify QosClass being deleted
	KeyOrHandle *QosClassKeyHandle `protobuf:"bytes,2,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty" venice:"key"`
}

func (m *QosClassGetRequest) Reset()                    { *m = QosClassGetRequest{} }
func (m *QosClassGetRequest) String() string            { return proto.CompactTextString(m) }
func (*QosClassGetRequest) ProtoMessage()               {}
func (*QosClassGetRequest) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{18} }

func (m *QosClassGetRequest) GetMeta() *ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *QosClassGetRequest) GetKeyOrHandle() *QosClassKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

// Batched request message to get the stats about a batch of QosClasss
type QosClassGetRequestMsg struct {
	Request []*QosClassGetRequest `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *QosClassGetRequestMsg) Reset()                    { *m = QosClassGetRequestMsg{} }
func (m *QosClassGetRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*QosClassGetRequestMsg) ProtoMessage()               {}
func (*QosClassGetRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{19} }

func (m *QosClassGetRequestMsg) GetRequest() []*QosClassGetRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

// QosClassGetResponse captures all the information about a QosClass
type QosClassGetResponse struct {
	Spec   *QosClassSpec   `protobuf:"bytes,1,opt,name=spec" json:"spec,omitempty"`
	Status *QosClassStatus `protobuf:"bytes,2,opt,name=status" json:"status,omitempty"`
	Stats  *QosClassStats  `protobuf:"bytes,3,opt,name=stats" json:"stats,omitempty"`
}

func (m *QosClassGetResponse) Reset()                    { *m = QosClassGetResponse{} }
func (m *QosClassGetResponse) String() string            { return proto.CompactTextString(m) }
func (*QosClassGetResponse) ProtoMessage()               {}
func (*QosClassGetResponse) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{20} }

func (m *QosClassGetResponse) GetSpec() *QosClassSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *QosClassGetResponse) GetStatus() *QosClassStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *QosClassGetResponse) GetStats() *QosClassStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

// QosClassGetResponseMsg is response to QosClassGetRequestMsg
type QosClassGetResponseMsg struct {
	Response []*QosClassGetResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *QosClassGetResponseMsg) Reset()                    { *m = QosClassGetResponseMsg{} }
func (m *QosClassGetResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*QosClassGetResponseMsg) ProtoMessage()               {}
func (*QosClassGetResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{21} }

func (m *QosClassGetResponseMsg) GetResponse() []*QosClassGetResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

// CoppKeyHandle uniquely identifies a Copp
type CoppKeyHandle struct {
	// Types that are valid to be assigned to KeyOrHandle:
	//	*CoppKeyHandle_CoppType
	//	*CoppKeyHandle_CoppHandle
	KeyOrHandle isCoppKeyHandle_KeyOrHandle `protobuf_oneof:"key_or_handle"`
}

func (m *CoppKeyHandle) Reset()                    { *m = CoppKeyHandle{} }
func (m *CoppKeyHandle) String() string            { return proto.CompactTextString(m) }
func (*CoppKeyHandle) ProtoMessage()               {}
func (*CoppKeyHandle) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{22} }

type isCoppKeyHandle_KeyOrHandle interface {
	isCoppKeyHandle_KeyOrHandle()
	MarshalTo([]byte) (int, error)
	Size() int
}

type CoppKeyHandle_CoppType struct {
	CoppType CoppType `protobuf:"varint,1,opt,name=copp_type,json=coppType,proto3,enum=qos.CoppType,oneof"`
}
type CoppKeyHandle_CoppHandle struct {
	CoppHandle uint64 `protobuf:"fixed64,2,opt,name=copp_handle,json=coppHandle,proto3,oneof"`
}

func (*CoppKeyHandle_CoppType) isCoppKeyHandle_KeyOrHandle()   {}
func (*CoppKeyHandle_CoppHandle) isCoppKeyHandle_KeyOrHandle() {}

func (m *CoppKeyHandle) GetKeyOrHandle() isCoppKeyHandle_KeyOrHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

func (m *CoppKeyHandle) GetCoppType() CoppType {
	if x, ok := m.GetKeyOrHandle().(*CoppKeyHandle_CoppType); ok {
		return x.CoppType
	}
	return CoppType_COPP_TYPE_FLOW_MISS
}

func (m *CoppKeyHandle) GetCoppHandle() uint64 {
	if x, ok := m.GetKeyOrHandle().(*CoppKeyHandle_CoppHandle); ok {
		return x.CoppHandle
	}
	return 0
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*CoppKeyHandle) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _CoppKeyHandle_OneofMarshaler, _CoppKeyHandle_OneofUnmarshaler, _CoppKeyHandle_OneofSizer, []interface{}{
		(*CoppKeyHandle_CoppType)(nil),
		(*CoppKeyHandle_CoppHandle)(nil),
	}
}

func _CoppKeyHandle_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*CoppKeyHandle)
	// key_or_handle
	switch x := m.KeyOrHandle.(type) {
	case *CoppKeyHandle_CoppType:
		_ = b.EncodeVarint(1<<3 | proto.WireVarint)
		_ = b.EncodeVarint(uint64(x.CoppType))
	case *CoppKeyHandle_CoppHandle:
		_ = b.EncodeVarint(2<<3 | proto.WireFixed64)
		_ = b.EncodeFixed64(uint64(x.CoppHandle))
	case nil:
	default:
		return fmt.Errorf("CoppKeyHandle.KeyOrHandle has unexpected type %T", x)
	}
	return nil
}

func _CoppKeyHandle_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*CoppKeyHandle)
	switch tag {
	case 1: // key_or_handle.copp_type
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.KeyOrHandle = &CoppKeyHandle_CoppType{CoppType(x)}
		return true, err
	case 2: // key_or_handle.copp_handle
		if wire != proto.WireFixed64 {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeFixed64()
		m.KeyOrHandle = &CoppKeyHandle_CoppHandle{x}
		return true, err
	default:
		return false, nil
	}
}

func _CoppKeyHandle_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*CoppKeyHandle)
	// key_or_handle
	switch x := m.KeyOrHandle.(type) {
	case *CoppKeyHandle_CoppType:
		n += proto.SizeVarint(1<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.CoppType))
	case *CoppKeyHandle_CoppHandle:
		n += proto.SizeVarint(2<<3 | proto.WireFixed64)
		n += 8
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Specifications of a Copp
type CoppSpec struct {
	Meta *ObjectMeta `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	// key_or_handle is Copp's unique identifier
	KeyOrHandle *CoppKeyHandle `protobuf:"bytes,2,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty" venice:"key"`
	Policer     *PolicerSpec   `protobuf:"bytes,3,opt,name=policer" json:"policer,omitempty"`
}

func (m *CoppSpec) Reset()                    { *m = CoppSpec{} }
func (m *CoppSpec) String() string            { return proto.CompactTextString(m) }
func (*CoppSpec) ProtoMessage()               {}
func (*CoppSpec) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{23} }

func (m *CoppSpec) GetMeta() *ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *CoppSpec) GetKeyOrHandle() *CoppKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

func (m *CoppSpec) GetPolicer() *PolicerSpec {
	if m != nil {
		return m.Policer
	}
	return nil
}

// Batched requests to create/update Copps
type CoppRequestMsg struct {
	Request []*CoppSpec `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *CoppRequestMsg) Reset()                    { *m = CoppRequestMsg{} }
func (m *CoppRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*CoppRequestMsg) ProtoMessage()               {}
func (*CoppRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{24} }

func (m *CoppRequestMsg) GetRequest() []*CoppSpec {
	if m != nil {
		return m.Request
	}
	return nil
}

type CoppStatus struct {
	CoppHandle uint64 `protobuf:"fixed64,1,opt,name=copp_handle,json=coppHandle,proto3" json:"copp_handle,omitempty"`
}

func (m *CoppStatus) Reset()                    { *m = CoppStatus{} }
func (m *CoppStatus) String() string            { return proto.CompactTextString(m) }
func (*CoppStatus) ProtoMessage()               {}
func (*CoppStatus) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{25} }

func (m *CoppStatus) GetCoppHandle() uint64 {
	if m != nil {
		return m.CoppHandle
	}
	return 0
}

// CoppResponse is response to one Copp
type CoppResponse struct {
	ApiStatus ApiStatus   `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty"`
	Status    *CoppStatus `protobuf:"bytes,2,opt,name=status" json:"status,omitempty"`
}

func (m *CoppResponse) Reset()                    { *m = CoppResponse{} }
func (m *CoppResponse) String() string            { return proto.CompactTextString(m) }
func (*CoppResponse) ProtoMessage()               {}
func (*CoppResponse) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{26} }

func (m *CoppResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *CoppResponse) GetStatus() *CoppStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

// Batched responses to create/update Copps
type CoppResponseMsg struct {
	Response []*CoppResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *CoppResponseMsg) Reset()                    { *m = CoppResponseMsg{} }
func (m *CoppResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*CoppResponseMsg) ProtoMessage()               {}
func (*CoppResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{27} }

func (m *CoppResponseMsg) GetResponse() []*CoppResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

// CoppGetRequest is used to get information about a Copp
type CoppGetRequest struct {
	Meta *ObjectMeta `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	// key_or_handle is Copp's unique identifier
	KeyOrHandle *CoppKeyHandle `protobuf:"bytes,2,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty" venice:"key"`
}

func (m *CoppGetRequest) Reset()                    { *m = CoppGetRequest{} }
func (m *CoppGetRequest) String() string            { return proto.CompactTextString(m) }
func (*CoppGetRequest) ProtoMessage()               {}
func (*CoppGetRequest) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{28} }

func (m *CoppGetRequest) GetMeta() *ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *CoppGetRequest) GetKeyOrHandle() *CoppKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

type CoppGetRequestMsg struct {
	Request []*CoppGetRequest `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *CoppGetRequestMsg) Reset()                    { *m = CoppGetRequestMsg{} }
func (m *CoppGetRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*CoppGetRequestMsg) ProtoMessage()               {}
func (*CoppGetRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{29} }

func (m *CoppGetRequestMsg) GetRequest() []*CoppGetRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

// CoppGetResponse captures all the information about a Copp
type CoppGetResponse struct {
	ApiStatus ApiStatus     `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty" venice:api_status`
	Spec      *CoppSpec     `protobuf:"bytes,2,opt,name=spec" json:"spec,omitempty"`
	Status    *CoppStatus   `protobuf:"bytes,3,opt,name=status" json:"status,omitempty"`
	Stats     *PolicerStats `protobuf:"bytes,4,opt,name=stats" json:"stats,omitempty"`
}

func (m *CoppGetResponse) Reset()                    { *m = CoppGetResponse{} }
func (m *CoppGetResponse) String() string            { return proto.CompactTextString(m) }
func (*CoppGetResponse) ProtoMessage()               {}
func (*CoppGetResponse) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{30} }

func (m *CoppGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *CoppGetResponse) GetSpec() *CoppSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *CoppGetResponse) GetStatus() *CoppStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *CoppGetResponse) GetStats() *PolicerStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

// CoppGetResponseMsg is response to CoppGetRequestMsg
type CoppGetResponseMsg struct {
	Response []*CoppGetResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *CoppGetResponseMsg) Reset()                    { *m = CoppGetResponseMsg{} }
func (m *CoppGetResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*CoppGetResponseMsg) ProtoMessage()               {}
func (*CoppGetResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{31} }

func (m *CoppGetResponseMsg) GetResponse() []*CoppGetResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

func init() {
	proto.RegisterType((*PolicerSpec)(nil), "qos.PolicerSpec")
	proto.RegisterType((*PolicerStats)(nil), "qos.PolicerStats")
	proto.RegisterType((*QosClassKeyHandle)(nil), "qos.QosClassKeyHandle")
	proto.RegisterType((*QosBuffer)(nil), "qos.QosBuffer")
	proto.RegisterType((*QosPFC)(nil), "qos.QosPFC")
	proto.RegisterType((*QosSched)(nil), "qos.QosSched")
	proto.RegisterType((*QosSched_DWRRInfo)(nil), "qos.QosSched.DWRRInfo")
	proto.RegisterType((*QosSched_StrictPriorityInfo)(nil), "qos.QosSched.StrictPriorityInfo")
	proto.RegisterType((*QosUplinkClassMap)(nil), "qos.QosUplinkClassMap")
	proto.RegisterType((*QosMarking)(nil), "qos.QosMarking")
	proto.RegisterType((*QosClassSpec)(nil), "qos.QosClassSpec")
	proto.RegisterType((*QosClassRequestMsg)(nil), "qos.QosClassRequestMsg")
	proto.RegisterType((*QosClassStatus)(nil), "qos.QosClassStatus")
	proto.RegisterType((*QosClassResponse)(nil), "qos.QosClassResponse")
	proto.RegisterType((*QosClassResponseMsg)(nil), "qos.QosClassResponseMsg")
	proto.RegisterType((*QosClassDeleteRequest)(nil), "qos.QosClassDeleteRequest")
	proto.RegisterType((*QosClassDeleteRequestMsg)(nil), "qos.QosClassDeleteRequestMsg")
	proto.RegisterType((*QosClassDeleteResponse)(nil), "qos.QosClassDeleteResponse")
	proto.RegisterType((*QosClassDeleteResponseMsg)(nil), "qos.QosClassDeleteResponseMsg")
	proto.RegisterType((*QosClassStats)(nil), "qos.QosClassStats")
	proto.RegisterType((*QosClassGetRequest)(nil), "qos.QosClassGetRequest")
	proto.RegisterType((*QosClassGetRequestMsg)(nil), "qos.QosClassGetRequestMsg")
	proto.RegisterType((*QosClassGetResponse)(nil), "qos.QosClassGetResponse")
	proto.RegisterType((*QosClassGetResponseMsg)(nil), "qos.QosClassGetResponseMsg")
	proto.RegisterType((*CoppKeyHandle)(nil), "qos.CoppKeyHandle")
	proto.RegisterType((*CoppSpec)(nil), "qos.CoppSpec")
	proto.RegisterType((*CoppRequestMsg)(nil), "qos.CoppRequestMsg")
	proto.RegisterType((*CoppStatus)(nil), "qos.CoppStatus")
	proto.RegisterType((*CoppResponse)(nil), "qos.CoppResponse")
	proto.RegisterType((*CoppResponseMsg)(nil), "qos.CoppResponseMsg")
	proto.RegisterType((*CoppGetRequest)(nil), "qos.CoppGetRequest")
	proto.RegisterType((*CoppGetRequestMsg)(nil), "qos.CoppGetRequestMsg")
	proto.RegisterType((*CoppGetResponse)(nil), "qos.CoppGetResponse")
	proto.RegisterType((*CoppGetResponseMsg)(nil), "qos.CoppGetResponseMsg")
	proto.RegisterEnum("qos.QosGroup", QosGroup_name, QosGroup_value)
	proto.RegisterEnum("qos.CoppType", CoppType_name, CoppType_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for QOS service

type QOSClient interface {
	// QOS class related APIs
	QosClassCreate(ctx context.Context, in *QosClassRequestMsg, opts ...grpc.CallOption) (*QosClassResponseMsg, error)
	QosClassUpdate(ctx context.Context, in *QosClassRequestMsg, opts ...grpc.CallOption) (*QosClassResponseMsg, error)
	QosClassDelete(ctx context.Context, in *QosClassDeleteRequestMsg, opts ...grpc.CallOption) (*QosClassDeleteResponseMsg, error)
	QosClassGet(ctx context.Context, in *QosClassGetRequestMsg, opts ...grpc.CallOption) (*QosClassGetResponseMsg, error)
	// Copp related APIs
	CoppUpdate(ctx context.Context, in *CoppRequestMsg, opts ...grpc.CallOption) (*CoppResponseMsg, error)
	CoppGet(ctx context.Context, in *CoppGetRequestMsg, opts ...grpc.CallOption) (*CoppGetResponseMsg, error)
}

type qOSClient struct {
	cc *grpc.ClientConn
}

func NewQOSClient(cc *grpc.ClientConn) QOSClient {
	return &qOSClient{cc}
}

func (c *qOSClient) QosClassCreate(ctx context.Context, in *QosClassRequestMsg, opts ...grpc.CallOption) (*QosClassResponseMsg, error) {
	out := new(QosClassResponseMsg)
	err := grpc.Invoke(ctx, "/qos.QOS/QosClassCreate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *qOSClient) QosClassUpdate(ctx context.Context, in *QosClassRequestMsg, opts ...grpc.CallOption) (*QosClassResponseMsg, error) {
	out := new(QosClassResponseMsg)
	err := grpc.Invoke(ctx, "/qos.QOS/QosClassUpdate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *qOSClient) QosClassDelete(ctx context.Context, in *QosClassDeleteRequestMsg, opts ...grpc.CallOption) (*QosClassDeleteResponseMsg, error) {
	out := new(QosClassDeleteResponseMsg)
	err := grpc.Invoke(ctx, "/qos.QOS/QosClassDelete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *qOSClient) QosClassGet(ctx context.Context, in *QosClassGetRequestMsg, opts ...grpc.CallOption) (*QosClassGetResponseMsg, error) {
	out := new(QosClassGetResponseMsg)
	err := grpc.Invoke(ctx, "/qos.QOS/QosClassGet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *qOSClient) CoppUpdate(ctx context.Context, in *CoppRequestMsg, opts ...grpc.CallOption) (*CoppResponseMsg, error) {
	out := new(CoppResponseMsg)
	err := grpc.Invoke(ctx, "/qos.QOS/CoppUpdate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *qOSClient) CoppGet(ctx context.Context, in *CoppGetRequestMsg, opts ...grpc.CallOption) (*CoppGetResponseMsg, error) {
	out := new(CoppGetResponseMsg)
	err := grpc.Invoke(ctx, "/qos.QOS/CoppGet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for QOS service

type QOSServer interface {
	// QOS class related APIs
	QosClassCreate(context.Context, *QosClassRequestMsg) (*QosClassResponseMsg, error)
	QosClassUpdate(context.Context, *QosClassRequestMsg) (*QosClassResponseMsg, error)
	QosClassDelete(context.Context, *QosClassDeleteRequestMsg) (*QosClassDeleteResponseMsg, error)
	QosClassGet(context.Context, *QosClassGetRequestMsg) (*QosClassGetResponseMsg, error)
	// Copp related APIs
	CoppUpdate(context.Context, *CoppRequestMsg) (*CoppResponseMsg, error)
	CoppGet(context.Context, *CoppGetRequestMsg) (*CoppGetResponseMsg, error)
}

func RegisterQOSServer(s *grpc.Server, srv QOSServer) {
	s.RegisterService(&_QOS_serviceDesc, srv)
}

func _QOS_QosClassCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QosClassRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QOSServer).QosClassCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/qos.QOS/QosClassCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QOSServer).QosClassCreate(ctx, req.(*QosClassRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _QOS_QosClassUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QosClassRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QOSServer).QosClassUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/qos.QOS/QosClassUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QOSServer).QosClassUpdate(ctx, req.(*QosClassRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _QOS_QosClassDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QosClassDeleteRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QOSServer).QosClassDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/qos.QOS/QosClassDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QOSServer).QosClassDelete(ctx, req.(*QosClassDeleteRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _QOS_QosClassGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QosClassGetRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QOSServer).QosClassGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/qos.QOS/QosClassGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QOSServer).QosClassGet(ctx, req.(*QosClassGetRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _QOS_CoppUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CoppRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QOSServer).CoppUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/qos.QOS/CoppUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QOSServer).CoppUpdate(ctx, req.(*CoppRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _QOS_CoppGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CoppGetRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QOSServer).CoppGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/qos.QOS/CoppGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QOSServer).CoppGet(ctx, req.(*CoppGetRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

var _QOS_serviceDesc = grpc.ServiceDesc{
	ServiceName: "qos.QOS",
	HandlerType: (*QOSServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "QosClassCreate",
			Handler:    _QOS_QosClassCreate_Handler,
		},
		{
			MethodName: "QosClassUpdate",
			Handler:    _QOS_QosClassUpdate_Handler,
		},
		{
			MethodName: "QosClassDelete",
			Handler:    _QOS_QosClassDelete_Handler,
		},
		{
			MethodName: "QosClassGet",
			Handler:    _QOS_QosClassGet_Handler,
		},
		{
			MethodName: "CoppUpdate",
			Handler:    _QOS_CoppUpdate_Handler,
		},
		{
			MethodName: "CoppGet",
			Handler:    _QOS_CoppGet_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "qos.proto",
}

func (m *PolicerSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PolicerSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.BpsRate != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.BpsRate))
	}
	if m.BurstSize != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.BurstSize))
	}
	return i, nil
}

func (m *PolicerStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PolicerStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PermittedPackets != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.PermittedPackets))
	}
	if m.PermittedBytes != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.PermittedBytes))
	}
	if m.DroppedPackets != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.DroppedPackets))
	}
	if m.DroppedBytes != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.DroppedBytes))
	}
	return i, nil
}

func (m *QosClassKeyHandle) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosClassKeyHandle) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.KeyOrHandle != nil {
		nn1, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn1
	}
	return i, nil
}

func (m *QosClassKeyHandle_QosGroup) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x8
	i++
	i = encodeVarintQos(dAtA, i, uint64(m.QosGroup))
	return i, nil
}
func (m *QosClassKeyHandle_QosClassHandle) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x11
	i++
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.QosClassHandle))
	i += 8
	return i, nil
}
func (m *QosBuffer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosBuffer) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XonThreshold != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.XonThreshold))
	}
	if m.XoffClearLimit != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.XoffClearLimit))
	}
	return i, nil
}

func (m *QosPFC) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosPFC) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PfcCos != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.PfcCos))
	}
	return i, nil
}

func (m *QosSched) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosSched) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SchedType != nil {
		nn2, err := m.SchedType.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn2
	}
	return i, nil
}

func (m *QosSched_Dwrr) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Dwrr != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.Dwrr.Size()))
		n3, err := m.Dwrr.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}
func (m *QosSched_Strict) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Strict != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.Strict.Size()))
		n4, err := m.Strict.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	return i, nil
}
func (m *QosSched_DWRRInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosSched_DWRRInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.BwPercentage != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.BwPercentage))
	}
	return i, nil
}

func (m *QosSched_StrictPriorityInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosSched_StrictPriorityInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Bps != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.Bps))
	}
	return i, nil
}

func (m *QosUplinkClassMap) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosUplinkClassMap) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Dot1QPcp != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.Dot1QPcp))
	}
	if len(m.IpDscp) > 0 {
		dAtA6 := make([]byte, len(m.IpDscp)*10)
		var j5 int
		for _, num := range m.IpDscp {
			for num >= 1<<7 {
				dAtA6[j5] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j5++
			}
			dAtA6[j5] = uint8(num)
			j5++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintQos(dAtA, i, uint64(j5))
		i += copy(dAtA[i:], dAtA6[:j5])
	}
	return i, nil
}

func (m *QosMarking) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosMarking) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Dot1QPcpRewriteEn {
		dAtA[i] = 0x8
		i++
		if m.Dot1QPcpRewriteEn {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Dot1QPcp != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.Dot1QPcp))
	}
	if m.IpDscpRewriteEn {
		dAtA[i] = 0x18
		i++
		if m.IpDscpRewriteEn {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IpDscp != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.IpDscp))
	}
	return i, nil
}

func (m *QosClassSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosClassSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.Meta.Size()))
		n7, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.KeyOrHandle != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n8, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.Mtu != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.Mtu))
	}
	if m.Buffer != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.Buffer.Size()))
		n9, err := m.Buffer.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.Pfc != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.Pfc.Size()))
		n10, err := m.Pfc.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.Sched != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.Sched.Size()))
		n11, err := m.Sched.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if m.UplinkClassMap != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.UplinkClassMap.Size()))
		n12, err := m.UplinkClassMap.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if m.Marking != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.Marking.Size()))
		n13, err := m.Marking.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	return i, nil
}

func (m *QosClassRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosClassRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintQos(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *QosClassStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosClassStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.QosClassHandle != 0 {
		dAtA[i] = 0x9
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.QosClassHandle))
		i += 8
	}
	return i, nil
}

func (m *QosClassResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosClassResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.ApiStatus))
	}
	if m.Status != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.Status.Size()))
		n14, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	return i, nil
}

func (m *QosClassResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosClassResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintQos(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *QosClassDeleteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosClassDeleteRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.Meta.Size()))
		n15, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	if m.KeyOrHandle != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n16, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	return i, nil
}

func (m *QosClassDeleteRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosClassDeleteRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintQos(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *QosClassDeleteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosClassDeleteResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.ApiStatus))
	}
	return i, nil
}

func (m *QosClassDeleteResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosClassDeleteResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintQos(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *QosClassStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosClassStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *QosClassGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosClassGetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.Meta.Size()))
		n17, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	if m.KeyOrHandle != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n18, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	return i, nil
}

func (m *QosClassGetRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosClassGetRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintQos(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *QosClassGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosClassGetResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Spec != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.Spec.Size()))
		n19, err := m.Spec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	if m.Status != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.Status.Size()))
		n20, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	if m.Stats != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.Stats.Size()))
		n21, err := m.Stats.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	return i, nil
}

func (m *QosClassGetResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosClassGetResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintQos(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CoppKeyHandle) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CoppKeyHandle) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.KeyOrHandle != nil {
		nn22, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn22
	}
	return i, nil
}

func (m *CoppKeyHandle_CoppType) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x8
	i++
	i = encodeVarintQos(dAtA, i, uint64(m.CoppType))
	return i, nil
}
func (m *CoppKeyHandle_CoppHandle) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x11
	i++
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.CoppHandle))
	i += 8
	return i, nil
}
func (m *CoppSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CoppSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.Meta.Size()))
		n23, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	if m.KeyOrHandle != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n24, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	if m.Policer != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.Policer.Size()))
		n25, err := m.Policer.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	return i, nil
}

func (m *CoppRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CoppRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintQos(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CoppStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CoppStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CoppHandle != 0 {
		dAtA[i] = 0x9
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.CoppHandle))
		i += 8
	}
	return i, nil
}

func (m *CoppResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CoppResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.ApiStatus))
	}
	if m.Status != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.Status.Size()))
		n26, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n26
	}
	return i, nil
}

func (m *CoppResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CoppResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintQos(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CoppGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CoppGetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.Meta.Size()))
		n27, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n27
	}
	if m.KeyOrHandle != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n28, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n28
	}
	return i, nil
}

func (m *CoppGetRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CoppGetRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintQos(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CoppGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CoppGetResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.ApiStatus))
	}
	if m.Spec != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.Spec.Size()))
		n29, err := m.Spec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n29
	}
	if m.Status != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.Status.Size()))
		n30, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n30
	}
	if m.Stats != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.Stats.Size()))
		n31, err := m.Stats.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n31
	}
	return i, nil
}

func (m *CoppGetResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CoppGetResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintQos(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func encodeVarintQos(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *PolicerSpec) Size() (n int) {
	var l int
	_ = l
	if m.BpsRate != 0 {
		n += 1 + sovQos(uint64(m.BpsRate))
	}
	if m.BurstSize != 0 {
		n += 1 + sovQos(uint64(m.BurstSize))
	}
	return n
}

func (m *PolicerStats) Size() (n int) {
	var l int
	_ = l
	if m.PermittedPackets != 0 {
		n += 1 + sovQos(uint64(m.PermittedPackets))
	}
	if m.PermittedBytes != 0 {
		n += 1 + sovQos(uint64(m.PermittedBytes))
	}
	if m.DroppedPackets != 0 {
		n += 1 + sovQos(uint64(m.DroppedPackets))
	}
	if m.DroppedBytes != 0 {
		n += 1 + sovQos(uint64(m.DroppedBytes))
	}
	return n
}

func (m *QosClassKeyHandle) Size() (n int) {
	var l int
	_ = l
	if m.KeyOrHandle != nil {
		n += m.KeyOrHandle.Size()
	}
	return n
}

func (m *QosClassKeyHandle_QosGroup) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovQos(uint64(m.QosGroup))
	return n
}
func (m *QosClassKeyHandle_QosClassHandle) Size() (n int) {
	var l int
	_ = l
	n += 9
	return n
}
func (m *QosBuffer) Size() (n int) {
	var l int
	_ = l
	if m.XonThreshold != 0 {
		n += 1 + sovQos(uint64(m.XonThreshold))
	}
	if m.XoffClearLimit != 0 {
		n += 1 + sovQos(uint64(m.XoffClearLimit))
	}
	return n
}

func (m *QosPFC) Size() (n int) {
	var l int
	_ = l
	if m.PfcCos != 0 {
		n += 1 + sovQos(uint64(m.PfcCos))
	}
	return n
}

func (m *QosSched) Size() (n int) {
	var l int
	_ = l
	if m.SchedType != nil {
		n += m.SchedType.Size()
	}
	return n
}

func (m *QosSched_Dwrr) Size() (n int) {
	var l int
	_ = l
	if m.Dwrr != nil {
		l = m.Dwrr.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	return n
}
func (m *QosSched_Strict) Size() (n int) {
	var l int
	_ = l
	if m.Strict != nil {
		l = m.Strict.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	return n
}
func (m *QosSched_DWRRInfo) Size() (n int) {
	var l int
	_ = l
	if m.BwPercentage != 0 {
		n += 1 + sovQos(uint64(m.BwPercentage))
	}
	return n
}

func (m *QosSched_StrictPriorityInfo) Size() (n int) {
	var l int
	_ = l
	if m.Bps != 0 {
		n += 1 + sovQos(uint64(m.Bps))
	}
	return n
}

func (m *QosUplinkClassMap) Size() (n int) {
	var l int
	_ = l
	if m.Dot1QPcp != 0 {
		n += 1 + sovQos(uint64(m.Dot1QPcp))
	}
	if len(m.IpDscp) > 0 {
		l = 0
		for _, e := range m.IpDscp {
			l += sovQos(uint64(e))
		}
		n += 1 + sovQos(uint64(l)) + l
	}
	return n
}

func (m *QosMarking) Size() (n int) {
	var l int
	_ = l
	if m.Dot1QPcpRewriteEn {
		n += 2
	}
	if m.Dot1QPcp != 0 {
		n += 1 + sovQos(uint64(m.Dot1QPcp))
	}
	if m.IpDscpRewriteEn {
		n += 2
	}
	if m.IpDscp != 0 {
		n += 1 + sovQos(uint64(m.IpDscp))
	}
	return n
}

func (m *QosClassSpec) Size() (n int) {
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	if m.Mtu != 0 {
		n += 1 + sovQos(uint64(m.Mtu))
	}
	if m.Buffer != nil {
		l = m.Buffer.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	if m.Pfc != nil {
		l = m.Pfc.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	if m.Sched != nil {
		l = m.Sched.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	if m.UplinkClassMap != nil {
		l = m.UplinkClassMap.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	if m.Marking != nil {
		l = m.Marking.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	return n
}

func (m *QosClassRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovQos(uint64(l))
		}
	}
	return n
}

func (m *QosClassStatus) Size() (n int) {
	var l int
	_ = l
	if m.QosClassHandle != 0 {
		n += 9
	}
	return n
}

func (m *QosClassResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovQos(uint64(m.ApiStatus))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	return n
}

func (m *QosClassResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovQos(uint64(l))
		}
	}
	return n
}

func (m *QosClassDeleteRequest) Size() (n int) {
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	return n
}

func (m *QosClassDeleteRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovQos(uint64(l))
		}
	}
	return n
}

func (m *QosClassDeleteResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovQos(uint64(m.ApiStatus))
	}
	return n
}

func (m *QosClassDeleteResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovQos(uint64(l))
		}
	}
	return n
}

func (m *QosClassStats) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *QosClassGetRequest) Size() (n int) {
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	return n
}

func (m *QosClassGetRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovQos(uint64(l))
		}
	}
	return n
}

func (m *QosClassGetResponse) Size() (n int) {
	var l int
	_ = l
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	if m.Stats != nil {
		l = m.Stats.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	return n
}

func (m *QosClassGetResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovQos(uint64(l))
		}
	}
	return n
}

func (m *CoppKeyHandle) Size() (n int) {
	var l int
	_ = l
	if m.KeyOrHandle != nil {
		n += m.KeyOrHandle.Size()
	}
	return n
}

func (m *CoppKeyHandle_CoppType) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovQos(uint64(m.CoppType))
	return n
}
func (m *CoppKeyHandle_CoppHandle) Size() (n int) {
	var l int
	_ = l
	n += 9
	return n
}
func (m *CoppSpec) Size() (n int) {
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	if m.Policer != nil {
		l = m.Policer.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	return n
}

func (m *CoppRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovQos(uint64(l))
		}
	}
	return n
}

func (m *CoppStatus) Size() (n int) {
	var l int
	_ = l
	if m.CoppHandle != 0 {
		n += 9
	}
	return n
}

func (m *CoppResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovQos(uint64(m.ApiStatus))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	return n
}

func (m *CoppResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovQos(uint64(l))
		}
	}
	return n
}

func (m *CoppGetRequest) Size() (n int) {
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	return n
}

func (m *CoppGetRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovQos(uint64(l))
		}
	}
	return n
}

func (m *CoppGetResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovQos(uint64(m.ApiStatus))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	if m.Stats != nil {
		l = m.Stats.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	return n
}

func (m *CoppGetResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovQos(uint64(l))
		}
	}
	return n
}

func sovQos(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozQos(x uint64) (n int) {
	return sovQos(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *PolicerSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PolicerSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PolicerSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BpsRate", wireType)
			}
			m.BpsRate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BpsRate |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BurstSize", wireType)
			}
			m.BurstSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BurstSize |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PolicerStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PolicerStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PolicerStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PermittedPackets", wireType)
			}
			m.PermittedPackets = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PermittedPackets |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PermittedBytes", wireType)
			}
			m.PermittedBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PermittedBytes |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DroppedPackets", wireType)
			}
			m.DroppedPackets = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DroppedPackets |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DroppedBytes", wireType)
			}
			m.DroppedBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DroppedBytes |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosClassKeyHandle) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QosClassKeyHandle: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QosClassKeyHandle: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field QosGroup", wireType)
			}
			var v QosGroup
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (QosGroup(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.KeyOrHandle = &QosClassKeyHandle_QosGroup{v}
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field QosClassHandle", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.KeyOrHandle = &QosClassKeyHandle_QosClassHandle{v}
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosBuffer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QosBuffer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QosBuffer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field XonThreshold", wireType)
			}
			m.XonThreshold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.XonThreshold |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field XoffClearLimit", wireType)
			}
			m.XoffClearLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.XoffClearLimit |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosPFC) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QosPFC: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QosPFC: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PfcCos", wireType)
			}
			m.PfcCos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PfcCos |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosSched) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QosSched: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QosSched: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dwrr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &QosSched_DWRRInfo{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.SchedType = &QosSched_Dwrr{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Strict", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &QosSched_StrictPriorityInfo{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.SchedType = &QosSched_Strict{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosSched_DWRRInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DWRRInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DWRRInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BwPercentage", wireType)
			}
			m.BwPercentage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BwPercentage |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosSched_StrictPriorityInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StrictPriorityInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StrictPriorityInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bps", wireType)
			}
			m.Bps = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Bps |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosUplinkClassMap) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QosUplinkClassMap: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QosUplinkClassMap: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dot1QPcp", wireType)
			}
			m.Dot1QPcp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Dot1QPcp |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowQos
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.IpDscp = append(m.IpDscp, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowQos
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthQos
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowQos
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.IpDscp = append(m.IpDscp, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field IpDscp", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosMarking) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QosMarking: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QosMarking: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dot1QPcpRewriteEn", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Dot1QPcpRewriteEn = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dot1QPcp", wireType)
			}
			m.Dot1QPcp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Dot1QPcp |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpDscpRewriteEn", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IpDscpRewriteEn = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpDscp", wireType)
			}
			m.IpDscp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IpDscp |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosClassSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QosClassSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QosClassSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &ObjectMeta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &QosClassKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mtu", wireType)
			}
			m.Mtu = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mtu |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Buffer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Buffer == nil {
				m.Buffer = &QosBuffer{}
			}
			if err := m.Buffer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pfc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pfc == nil {
				m.Pfc = &QosPFC{}
			}
			if err := m.Pfc.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sched", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Sched == nil {
				m.Sched = &QosSched{}
			}
			if err := m.Sched.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UplinkClassMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UplinkClassMap == nil {
				m.UplinkClassMap = &QosUplinkClassMap{}
			}
			if err := m.UplinkClassMap.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Marking", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Marking == nil {
				m.Marking = &QosMarking{}
			}
			if err := m.Marking.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosClassRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QosClassRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QosClassRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &QosClassSpec{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosClassStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QosClassStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QosClassStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field QosClassHandle", wireType)
			}
			m.QosClassHandle = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.QosClassHandle = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosClassResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QosClassResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QosClassResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &QosClassStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosClassResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QosClassResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QosClassResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &QosClassResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosClassDeleteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QosClassDeleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QosClassDeleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &ObjectMeta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &QosClassKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosClassDeleteRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QosClassDeleteRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QosClassDeleteRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &QosClassDeleteRequest{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosClassDeleteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QosClassDeleteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QosClassDeleteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosClassDeleteResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QosClassDeleteResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QosClassDeleteResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &QosClassDeleteResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosClassStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QosClassStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QosClassStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosClassGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QosClassGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QosClassGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &ObjectMeta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &QosClassKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosClassGetRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QosClassGetRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QosClassGetRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &QosClassGetRequest{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosClassGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QosClassGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QosClassGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &QosClassSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &QosClassStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = &QosClassStats{}
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosClassGetResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QosClassGetResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QosClassGetResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &QosClassGetResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CoppKeyHandle) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CoppKeyHandle: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CoppKeyHandle: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CoppType", wireType)
			}
			var v CoppType
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (CoppType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.KeyOrHandle = &CoppKeyHandle_CoppType{v}
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CoppHandle", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.KeyOrHandle = &CoppKeyHandle_CoppHandle{v}
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CoppSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CoppSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CoppSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &ObjectMeta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &CoppKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Policer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Policer == nil {
				m.Policer = &PolicerSpec{}
			}
			if err := m.Policer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CoppRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CoppRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CoppRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &CoppSpec{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CoppStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CoppStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CoppStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CoppHandle", wireType)
			}
			m.CoppHandle = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.CoppHandle = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CoppResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CoppResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CoppResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &CoppStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CoppResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CoppResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CoppResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &CoppResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CoppGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CoppGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CoppGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &ObjectMeta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &CoppKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CoppGetRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CoppGetRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CoppGetRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &CoppGetRequest{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CoppGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CoppGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CoppGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &CoppSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &CoppStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = &PolicerStats{}
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CoppGetResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CoppGetResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CoppGetResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &CoppGetResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipQos(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowQos
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowQos
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowQos
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthQos
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowQos
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipQos(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthQos = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowQos   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("qos.proto", fileDescriptorQos) }

var fileDescriptorQos = []byte{
	// 1604 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x58, 0xcd, 0x6f, 0x1b, 0xc7,
	0x15, 0xd7, 0x8a, 0x34, 0x49, 0x3d, 0x8a, 0xd4, 0x72, 0x64, 0x5b, 0xb4, 0x0c, 0xcb, 0xf6, 0x06,
	0x89, 0x5d, 0x3b, 0xb1, 0x6b, 0x25, 0x6d, 0x11, 0xa3, 0x87, 0x88, 0x1f, 0x32, 0x95, 0x4a, 0xe2,
	0x72, 0x48, 0x21, 0x71, 0x2e, 0xdb, 0xe5, 0x72, 0x28, 0x6d, 0x45, 0x71, 0x47, 0x3b, 0xcb, 0xda,
	0xcc, 0xa1, 0x40, 0x8f, 0x05, 0x7a, 0xeb, 0xa5, 0xc7, 0xde, 0x8a, 0x5e, 0xdb, 0x7f, 0xa2, 0xa7,
	0xa2, 0xe7, 0x1e, 0x82, 0xc2, 0xbd, 0xf7, 0x90, 0xbf, 0x20, 0x98, 0x8f, 0xe5, 0x7e, 0x51, 0x41,
	0x1c, 0x04, 0xc8, 0x49, 0xcb, 0xf7, 0x7e, 0xf3, 0x9b, 0x37, 0xef, 0xf7, 0xe6, 0xed, 0x5b, 0xc1,
	0xda, 0xa5, 0xc7, 0x9e, 0x50, 0xdf, 0x0b, 0x3c, 0x94, 0xbb, 0xf4, 0xd8, 0x76, 0x39, 0x98, 0x53,
	0xa2, 0x2c, 0xc6, 0x0b, 0x28, 0x9b, 0xde, 0xc4, 0x75, 0x88, 0xdf, 0xa7, 0xc4, 0x41, 0xb7, 0xa0,
	0x34, 0xa4, 0xcc, 0xf2, 0xed, 0x80, 0xd4, 0xb5, 0x7b, 0xda, 0xc3, 0x0a, 0x2e, 0x0e, 0x29, 0xc3,
	0x76, 0x40, 0xd0, 0x1d, 0x80, 0xe1, 0xcc, 0x67, 0x81, 0xc5, 0xdc, 0x2f, 0x49, 0x7d, 0x55, 0x38,
	0xd7, 0x84, 0xa5, 0xef, 0x7e, 0x49, 0x8c, 0xbf, 0x6b, 0xb0, 0x1e, 0x32, 0x05, 0x76, 0xc0, 0xd0,
	0x63, 0xa8, 0x51, 0xe2, 0x5f, 0xb8, 0x41, 0x40, 0x46, 0x16, 0xb5, 0x9d, 0x73, 0x12, 0x30, 0xc1,
	0x99, 0xc7, 0xfa, 0xc2, 0x61, 0x4a, 0x3b, 0x7a, 0x00, 0x1b, 0x11, 0x78, 0x38, 0x0f, 0x08, 0x13,
	0x3b, 0xe4, 0x71, 0x75, 0x61, 0x6e, 0x70, 0x2b, 0x07, 0x8e, 0x7c, 0x8f, 0xd2, 0x18, 0x67, 0x4e,
	0x02, 0x95, 0x39, 0x64, 0x7c, 0x07, 0x2a, 0x21, 0x50, 0xf2, 0xe5, 0x05, 0x6c, 0x5d, 0x19, 0x05,
	0x9b, 0xf1, 0x3b, 0xa8, 0xf5, 0x3c, 0xd6, 0x9c, 0xd8, 0x8c, 0xfd, 0x8a, 0xcc, 0x3b, 0xf6, 0x74,
	0x34, 0x21, 0xe8, 0x7d, 0x91, 0x31, 0xeb, 0xd4, 0xf7, 0x66, 0x54, 0x04, 0x5c, 0xdd, 0xad, 0x3c,
	0xe1, 0x39, 0xec, 0x79, 0xec, 0x05, 0x37, 0x76, 0x56, 0x70, 0xe9, 0x52, 0x3d, 0xa3, 0x47, 0xa0,
	0x73, 0xb4, 0xc3, 0x39, 0xac, 0x33, 0xc1, 0x20, 0x42, 0x2f, 0x74, 0x56, 0x70, 0xf5, 0x52, 0x91,
	0x4b, 0xe6, 0xc6, 0x06, 0x54, 0xce, 0xc9, 0xdc, 0xf2, 0x7c, 0x05, 0x34, 0xbe, 0x80, 0xb5, 0x9e,
	0xc7, 0x1a, 0xb3, 0xf1, 0x98, 0xf8, 0x3c, 0xe2, 0xd7, 0xde, 0xd4, 0x0a, 0xce, 0x7c, 0xc2, 0xce,
	0xbc, 0xc9, 0x48, 0x09, 0xb0, 0xfe, 0xda, 0x9b, 0x0e, 0x42, 0x1b, 0x7a, 0x08, 0xfa, 0x6b, 0x6f,
	0x3c, 0xb6, 0x9c, 0x09, 0xb1, 0x7d, 0x6b, 0xe2, 0x5e, 0xb8, 0x81, 0xd2, 0xa2, 0xca, 0xed, 0x4d,
	0x6e, 0x3e, 0xe4, 0x56, 0xe3, 0x3e, 0x14, 0x7a, 0x1e, 0x33, 0xf7, 0x9b, 0x68, 0x0b, 0x8a, 0x74,
	0xec, 0x58, 0x8e, 0xc7, 0x14, 0x65, 0x81, 0x8e, 0x9d, 0xa6, 0xc7, 0x8c, 0xff, 0x68, 0x50, 0xea,
	0x79, 0xac, 0xef, 0x9c, 0x91, 0x11, 0x7a, 0x1f, 0xf2, 0xa3, 0x57, 0xbe, 0x2f, 0x20, 0xe5, 0xdd,
	0x9b, 0xe1, 0x89, 0x85, 0xf3, 0x49, 0xeb, 0x33, 0x8c, 0x0f, 0xa6, 0x63, 0xaf, 0xb3, 0x82, 0x05,
	0x0a, 0x3d, 0x87, 0x02, 0x0b, 0x7c, 0xd7, 0x91, 0xbb, 0x97, 0x77, 0xef, 0x25, 0xf1, 0x7d, 0xe1,
	0x33, 0x7d, 0xd7, 0xf3, 0xdd, 0x60, 0xae, 0x56, 0xaa, 0x15, 0xdb, 0x4f, 0xa1, 0x14, 0xf2, 0xf1,
	0x43, 0x0f, 0x5f, 0x59, 0x94, 0xf8, 0x0e, 0x99, 0x06, 0xf6, 0x69, 0x58, 0x75, 0xeb, 0xc3, 0x57,
	0xe6, 0xc2, 0xb6, 0xfd, 0x1e, 0xa0, 0x2c, 0x21, 0xd2, 0x21, 0x37, 0xa4, 0xe1, 0x91, 0xf8, 0x63,
	0xa3, 0x0c, 0x6b, 0x62, 0xfb, 0xc1, 0x9c, 0x12, 0xe3, 0x40, 0x68, 0x7b, 0x42, 0x27, 0xee, 0xf4,
	0x5c, 0x88, 0x70, 0x64, 0x53, 0x74, 0x1b, 0xd6, 0x46, 0x5e, 0xf0, 0xec, 0xd2, 0xa2, 0x0e, 0x55,
	0x2b, 0x4b, 0xc2, 0x60, 0x3a, 0x94, 0xe7, 0xc9, 0xa5, 0xd6, 0x88, 0x39, 0xb4, 0xbe, 0x7a, 0x2f,
	0xc7, 0xf3, 0xe4, 0xd2, 0x16, 0x73, 0xa8, 0xf1, 0x17, 0x0d, 0xa0, 0xe7, 0xb1, 0x23, 0xdb, 0x3f,
	0x77, 0xa7, 0xa7, 0xe8, 0x29, 0x5c, 0x5f, 0x90, 0x58, 0x3e, 0x79, 0xe5, 0xbb, 0x01, 0xb1, 0xc8,
	0x54, 0xf0, 0x95, 0x70, 0x2d, 0xe4, 0xc3, 0xd2, 0xd3, 0x9e, 0x26, 0x77, 0x5d, 0x4d, 0xed, 0xfa,
	0x18, 0x90, 0xda, 0x35, 0xce, 0x95, 0x13, 0x5c, 0x1b, 0x32, 0x80, 0x88, 0x29, 0x16, 0x62, 0x5e,
	0x4a, 0xa9, 0x42, 0xfc, 0xff, 0x2a, 0xac, 0x87, 0xa5, 0x2c, 0x6e, 0xf2, 0xbb, 0x90, 0xbf, 0x20,
	0x81, 0xad, 0xe4, 0xac, 0x3d, 0x91, 0x97, 0xbe, 0x3b, 0xfc, 0x0d, 0x71, 0x82, 0x23, 0x12, 0xd8,
	0x58, 0xb8, 0xd1, 0x61, 0xaa, 0x24, 0x95, 0x9c, 0x0b, 0xf9, 0x93, 0x77, 0xa3, 0xa1, 0x7f, 0xfd,
	0xd5, 0xdd, 0xf5, 0xdf, 0x92, 0xa9, 0xeb, 0x90, 0xe7, 0xc6, 0x39, 0x99, 0x1b, 0xb8, 0x7c, 0x4e,
	0xe6, 0x5d, 0x5f, 0x5d, 0x1d, 0x1d, 0x72, 0x17, 0xc1, 0x4c, 0x04, 0x5f, 0xc1, 0xfc, 0x11, 0xbd,
	0x07, 0x85, 0xa1, 0x28, 0x6f, 0x11, 0x6f, 0x79, 0xb7, 0x1a, 0x12, 0xcb, 0xa2, 0xc7, 0xca, 0x8b,
	0xee, 0x40, 0x8e, 0x8e, 0x9d, 0xfa, 0x35, 0x01, 0x2a, 0x87, 0x20, 0x73, 0xbf, 0x89, 0xb9, 0x1d,
	0xbd, 0x03, 0xd7, 0x18, 0x57, 0xb6, 0x5e, 0x10, 0x80, 0x4a, 0xa2, 0xda, 0xb0, 0xf4, 0xa1, 0x4f,
	0x40, 0x9f, 0x09, 0xb9, 0xd5, 0x6d, 0xbc, 0xb0, 0x69, 0xbd, 0x98, 0x3c, 0x4e, 0xb2, 0x1c, 0x70,
	0x75, 0x96, 0x2c, 0x8f, 0x9f, 0x40, 0xf1, 0x42, 0x8a, 0x5c, 0x2f, 0x89, 0x85, 0x1b, 0xe1, 0x42,
	0xa5, 0x3d, 0x0e, 0xfd, 0xc6, 0x1e, 0xa0, 0x30, 0x3d, 0x98, 0x5c, 0xce, 0x08, 0x0b, 0x8e, 0xd8,
	0x29, 0x7a, 0x0c, 0x45, 0x5f, 0xfe, 0xaa, 0x6b, 0xf7, 0x72, 0x22, 0xf1, 0xf1, 0x44, 0x72, 0x65,
	0x70, 0x88, 0x30, 0x9e, 0x43, 0x75, 0xe1, 0x08, 0xec, 0x60, 0xc6, 0xf8, 0xed, 0xce, 0x34, 0x13,
	0x2e, 0x60, 0x21, 0xdd, 0x4a, 0x0c, 0x0a, 0x7a, 0xb4, 0x3d, 0xa3, 0xde, 0x94, 0x11, 0xf4, 0x14,
	0xc0, 0xa6, 0xae, 0xc5, 0x04, 0x97, 0xea, 0x5c, 0xba, 0x12, 0x7e, 0x8f, 0xba, 0x72, 0x0f, 0xbc,
	0x66, 0x87, 0x8f, 0xe8, 0x31, 0xbf, 0xc4, 0x02, 0x2c, 0x55, 0xdf, 0x4c, 0x06, 0x2b, 0xf1, 0x0a,
	0x62, 0x74, 0x60, 0x33, 0xbd, 0x23, 0x3f, 0xf1, 0x33, 0x28, 0xf9, 0xea, 0xa7, 0x3a, 0xf2, 0x8d,
	0x04, 0x4b, 0x88, 0xc5, 0x0b, 0x98, 0xf1, 0x47, 0x0d, 0x6e, 0x84, 0xee, 0x16, 0x99, 0x90, 0x80,
	0xa8, 0x0c, 0xfe, 0x28, 0x45, 0x6b, 0x98, 0x50, 0x5f, 0x1a, 0x0d, 0x3f, 0xdd, 0x47, 0x69, 0x3d,
	0xb7, 0x13, 0x7b, 0x24, 0xf0, 0x91, 0xb0, 0xbf, 0x86, 0x9b, 0x69, 0x84, 0x92, 0x68, 0xff, 0xbb,
	0x48, 0xd4, 0xb8, 0xf1, 0xf5, 0x57, 0x77, 0x6b, 0x2a, 0xe0, 0x08, 0x1e, 0x53, 0xce, 0x18, 0xc0,
	0xad, 0xe5, 0x3b, 0xf0, 0xa0, 0x7f, 0x91, 0x91, 0xe4, 0xf6, 0xd2, 0xa8, 0x33, 0xc2, 0x6c, 0x40,
	0x25, 0x2e, 0x3e, 0x33, 0xfe, 0xa0, 0x45, 0x55, 0xfe, 0x82, 0x04, 0x3f, 0xaa, 0x4c, 0x9f, 0x46,
	0x45, 0x13, 0x85, 0x22, 0x2b, 0x30, 0xa5, 0xd1, 0x56, 0x62, 0x83, 0x08, 0x1c, 0x09, 0xf4, 0x27,
	0x2d, 0x2a, 0x66, 0xe1, 0x57, 0xf2, 0xbc, 0x0b, 0x79, 0x46, 0x89, 0xb3, 0x38, 0x58, 0xe6, 0xee,
	0x0a, 0xf7, 0x5b, 0xdd, 0x1b, 0xf4, 0x10, 0xae, 0xf1, 0x27, 0x39, 0xa7, 0x94, 0x77, 0x51, 0x06,
	0xcb, 0xb0, 0x04, 0x18, 0xc7, 0x51, 0xd9, 0xc4, 0x82, 0x92, 0x65, 0x98, 0x56, 0xb4, 0x9e, 0x3d,
	0x63, 0x46, 0xce, 0x4b, 0xa8, 0x34, 0x3d, 0x4a, 0x13, 0x93, 0x8d, 0xe3, 0x51, 0x6a, 0x71, 0xbd,
	0x12, 0x93, 0x0d, 0x87, 0xf1, 0x97, 0x26, 0x9f, 0x6c, 0x1c, 0xf5, 0x8c, 0xee, 0x43, 0x59, 0xa0,
	0x53, 0x43, 0x0d, 0x70, 0xe3, 0x55, 0x03, 0xcd, 0x5f, 0x35, 0x28, 0x71, 0xb2, 0xb7, 0x79, 0x05,
	0x75, 0x96, 0x97, 0x09, 0x5a, 0x44, 0xf6, 0x9d, 0x5f, 0x3f, 0x8f, 0xa0, 0x48, 0xe5, 0x08, 0xaa,
	0x92, 0xad, 0x0b, 0x8e, 0xd8, 0x80, 0x8b, 0x43, 0x80, 0xf1, 0x31, 0x54, 0x39, 0x77, 0xac, 0x8e,
	0x1e, 0xa4, 0xeb, 0x28, 0xca, 0x4d, 0xb2, 0x6f, 0x7f, 0x00, 0x20, 0x8c, 0x52, 0xdf, 0xbb, 0xc9,
	0x34, 0xc9, 0x76, 0x1d, 0x4b, 0x92, 0x71, 0x06, 0xeb, 0x72, 0xa7, 0xef, 0xdb, 0xa6, 0x1f, 0xa4,
	0xca, 0x6d, 0x23, 0x8a, 0x2b, 0xd9, 0xa2, 0x3f, 0x81, 0x8d, 0xf8, 0x4e, 0xfc, 0x50, 0x1f, 0x64,
	0x2a, 0xa7, 0xb6, 0x58, 0xbd, 0xa4, 0x64, 0x7e, 0xaf, 0xc9, 0xb4, 0xbc, 0xfd, 0x65, 0xff, 0xc1,
	0x54, 0x34, 0x1a, 0x50, 0x4b, 0x86, 0x20, 0xcf, 0x91, 0x12, 0x67, 0x73, 0x41, 0xbc, 0xec, 0x82,
	0xff, 0x4b, 0x93, 0xa9, 0x88, 0x5f, 0xee, 0x1f, 0xa8, 0xf7, 0xa2, 0xfb, 0xaa, 0x49, 0xac, 0xc6,
	0x46, 0x91, 0x45, 0x91, 0xc8, 0x06, 0x11, 0x29, 0x96, 0xfb, 0x56, 0xc5, 0xd0, 0x83, 0xb0, 0x39,
	0xe4, 0x63, 0x1d, 0x27, 0xfe, 0x19, 0x15, 0xf6, 0x86, 0x7d, 0x40, 0xa9, 0xf3, 0xf0, 0xac, 0xfc,
	0x34, 0xa3, 0xee, 0xf5, 0x64, 0x5a, 0xd2, 0x02, 0x3f, 0xfa, 0xc7, 0xaa, 0x18, 0xf9, 0xe5, 0xb7,
	0x4b, 0x19, 0x8a, 0xad, 0xf6, 0xfe, 0xde, 0xc9, 0xe1, 0x40, 0x5f, 0x41, 0x08, 0xaa, 0x27, 0xfd,
	0x36, 0xb6, 0x5a, 0xed, 0xfd, 0x83, 0xe3, 0x76, 0xcb, 0x7a, 0xa6, 0x6b, 0x19, 0xdb, 0xae, 0xbe,
	0x9a, 0xb1, 0x7d, 0xa8, 0xe7, 0x32, 0xb6, 0x8f, 0xf4, 0x7c, 0xc6, 0xf6, 0x33, 0xfd, 0x5a, 0xc6,
	0xf6, 0x73, 0xbd, 0xc0, 0x83, 0x68, 0x76, 0x8f, 0x07, 0xb8, 0x7b, 0xa8, 0x17, 0x51, 0x09, 0xf2,
	0x7d, 0x73, 0xef, 0x58, 0x2f, 0xa1, 0x3b, 0x70, 0xeb, 0xe0, 0x78, 0xd0, 0xc6, 0xc7, 0x7b, 0x87,
	0x16, 0xfe, 0xdc, 0x32, 0x71, 0xf7, 0xf3, 0x97, 0xd6, 0x71, 0xd7, 0x6a, 0xe1, 0xae, 0xa9, 0xaf,
	0xa1, 0x6d, 0xb8, 0x99, 0x75, 0x0b, 0x1f, 0x24, 0x96, 0x0e, 0xd2, 0x4b, 0xcb, 0x89, 0xa5, 0x83,
	0xc4, 0xd2, 0x75, 0x74, 0x03, 0x6a, 0x0b, 0x5f, 0xd3, 0x3c, 0xb1, 0x9a, 0x5d, 0xf3, 0xa5, 0x5e,
	0x79, 0xf4, 0xa9, 0xec, 0x6a, 0xa2, 0x2d, 0x6e, 0xc1, 0x66, 0xb3, 0x6b, 0x9a, 0xd6, 0xe0, 0xa5,
	0xd9, 0xb6, 0xf6, 0x0f, 0xbb, 0x9f, 0x59, 0x47, 0x07, 0xfd, 0xbe, 0xbe, 0x82, 0x6a, 0x50, 0x89,
	0x1c, 0x7b, 0xd8, 0x94, 0xf9, 0x8b, 0x4c, 0xad, 0x4e, 0xd3, 0xd4, 0x57, 0x77, 0xff, 0x96, 0x83,
	0x5c, 0xaf, 0xdb, 0x47, 0xed, 0x68, 0xfa, 0x6b, 0xfa, 0x84, 0x7f, 0x61, 0x6f, 0xa5, 0x06, 0xa7,
	0xb0, 0xf8, 0xb7, 0xeb, 0x4b, 0x27, 0xaa, 0x23, 0x76, 0x6a, 0xac, 0xc4, 0x69, 0x4e, 0xe8, 0xe8,
	0x7b, 0xd3, 0xf4, 0x22, 0x1a, 0x39, 0x1e, 0xa0, 0x3b, 0x57, 0x4f, 0x3a, 0x9c, 0x6c, 0xe7, 0x5b,
	0x46, 0x0a, 0x49, 0xd9, 0x81, 0x72, 0xec, 0xfd, 0x84, 0xb6, 0xaf, 0x78, 0x2b, 0x73, 0xb2, 0xdb,
	0x57, 0xbd, 0xcd, 0x24, 0xd3, 0xc7, 0xb2, 0xe1, 0xaa, 0xf3, 0x6d, 0xc6, 0x1a, 0xd8, 0x82, 0xe1,
	0x7a, 0xa6, 0xab, 0xc9, 0xa5, 0xbf, 0x84, 0xa2, 0xba, 0x0c, 0xe8, 0xe6, 0x92, 0x8e, 0xc1, 0x97,
	0x6e, 0x2d, 0xbb, 0x32, 0x62, 0x75, 0x63, 0xfb, 0x9f, 0x6f, 0x76, 0xb4, 0x7f, 0xbf, 0xd9, 0xd1,
	0xfe, 0xfb, 0x66, 0x47, 0xfb, 0xf3, 0xff, 0x76, 0x56, 0xbe, 0x28, 0x9d, 0xd9, 0x13, 0xf1, 0x9f,
	0x93, 0x61, 0x41, 0xfc, 0xf9, 0xf0, 0x9b, 0x00, 0x00, 0x00, 0xff, 0xff, 0x0e, 0xb7, 0x54, 0x2b,
	0x5f, 0x11, 0x00, 0x00,
}
