// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: qos.proto

package halproto

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import encoding_binary "encoding/binary"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type QosPauseType int32

const (
	QosPauseType_QOS_PAUSE_TYPE_NONE       QosPauseType = 0
	QosPauseType_QOS_PAUSE_TYPE_LINK_LEVEL QosPauseType = 1
	QosPauseType_QOS_PAUSE_TYPE_PFC        QosPauseType = 2
)

var QosPauseType_name = map[int32]string{
	0: "QOS_PAUSE_TYPE_NONE",
	1: "QOS_PAUSE_TYPE_LINK_LEVEL",
	2: "QOS_PAUSE_TYPE_PFC",
}
var QosPauseType_value = map[string]int32{
	"QOS_PAUSE_TYPE_NONE":       0,
	"QOS_PAUSE_TYPE_LINK_LEVEL": 1,
	"QOS_PAUSE_TYPE_PFC":        2,
}

func (x QosPauseType) String() string {
	return proto.EnumName(QosPauseType_name, int32(x))
}
func (QosPauseType) EnumDescriptor() ([]byte, []int) { return fileDescriptorQos, []int{0} }

type QosClassMapType int32

const (
	QosClassMapType_QOS_CLASS_MAP_TYPE_NONE     QosClassMapType = 0
	QosClassMapType_QOS_CLASS_MAP_TYPE_PCP      QosClassMapType = 1
	QosClassMapType_QOS_CLASS_MAP_TYPE_DSCP     QosClassMapType = 2
	QosClassMapType_QOS_CLASS_MAP_TYPE_PCP_DSCP QosClassMapType = 3
)

var QosClassMapType_name = map[int32]string{
	0: "QOS_CLASS_MAP_TYPE_NONE",
	1: "QOS_CLASS_MAP_TYPE_PCP",
	2: "QOS_CLASS_MAP_TYPE_DSCP",
	3: "QOS_CLASS_MAP_TYPE_PCP_DSCP",
}
var QosClassMapType_value = map[string]int32{
	"QOS_CLASS_MAP_TYPE_NONE":     0,
	"QOS_CLASS_MAP_TYPE_PCP":      1,
	"QOS_CLASS_MAP_TYPE_DSCP":     2,
	"QOS_CLASS_MAP_TYPE_PCP_DSCP": 3,
}

func (x QosClassMapType) String() string {
	return proto.EnumName(QosClassMapType_name, int32(x))
}
func (QosClassMapType) EnumDescriptor() ([]byte, []int) { return fileDescriptorQos, []int{1} }

type PacketBufferPortType int32

const (
	PacketBufferPortType_PACKET_BUFFER_PORT_TYPE_DMA    PacketBufferPortType = 0
	PacketBufferPortType_PACKET_BUFFER_PORT_TYPE_P4IG   PacketBufferPortType = 1
	PacketBufferPortType_PACKET_BUFFER_PORT_TYPE_P4EG   PacketBufferPortType = 2
	PacketBufferPortType_PACKET_BUFFER_PORT_TYPE_UPLINK PacketBufferPortType = 3
)

var PacketBufferPortType_name = map[int32]string{
	0: "PACKET_BUFFER_PORT_TYPE_DMA",
	1: "PACKET_BUFFER_PORT_TYPE_P4IG",
	2: "PACKET_BUFFER_PORT_TYPE_P4EG",
	3: "PACKET_BUFFER_PORT_TYPE_UPLINK",
}
var PacketBufferPortType_value = map[string]int32{
	"PACKET_BUFFER_PORT_TYPE_DMA":    0,
	"PACKET_BUFFER_PORT_TYPE_P4IG":   1,
	"PACKET_BUFFER_PORT_TYPE_P4EG":   2,
	"PACKET_BUFFER_PORT_TYPE_UPLINK": 3,
}

func (x PacketBufferPortType) String() string {
	return proto.EnumName(PacketBufferPortType_name, int32(x))
}
func (PacketBufferPortType) EnumDescriptor() ([]byte, []int) { return fileDescriptorQos, []int{2} }

type PolicerPPSSpec struct {
	PacketsPerSec uint32 `protobuf:"varint,1,opt,name=packets_per_sec,json=packetsPerSec,proto3" json:"packets_per_sec,omitempty" venice:mandatory,venice:constraints={range:4000-2000000000}`
	BurstPackets  uint32 `protobuf:"varint,2,opt,name=burst_packets,json=burstPackets,proto3" json:"burst_packets,omitempty" venice:mandatory,venice:constraints={range:0-2000000000}`
}

func (m *PolicerPPSSpec) Reset()                    { *m = PolicerPPSSpec{} }
func (m *PolicerPPSSpec) String() string            { return proto.CompactTextString(m) }
func (*PolicerPPSSpec) ProtoMessage()               {}
func (*PolicerPPSSpec) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{0} }

func (m *PolicerPPSSpec) GetPacketsPerSec() uint32 {
	if m != nil {
		return m.PacketsPerSec
	}
	return 0
}

func (m *PolicerPPSSpec) GetBurstPackets() uint32 {
	if m != nil {
		return m.BurstPackets
	}
	return 0
}

type PolicerBPSSpec struct {
	BytesPerSec uint64 `protobuf:"varint,1,opt,name=bytes_per_sec,json=bytesPerSec,proto3" json:"bytes_per_sec,omitempty" venice:mandatory,venice:constraints={range:4000-125000000000}`
	BurstBytes  uint64 `protobuf:"varint,2,opt,name=burst_bytes,json=burstBytes,proto3" json:"burst_bytes,omitempty" venice:mandatory,venice:constraints={range:0-125000000000}`
}

func (m *PolicerBPSSpec) Reset()                    { *m = PolicerBPSSpec{} }
func (m *PolicerBPSSpec) String() string            { return proto.CompactTextString(m) }
func (*PolicerBPSSpec) ProtoMessage()               {}
func (*PolicerBPSSpec) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{1} }

func (m *PolicerBPSSpec) GetBytesPerSec() uint64 {
	if m != nil {
		return m.BytesPerSec
	}
	return 0
}

func (m *PolicerBPSSpec) GetBurstBytes() uint64 {
	if m != nil {
		return m.BurstBytes
	}
	return 0
}

// Specifications of a policer
type PolicerSpec struct {
	// Types that are valid to be assigned to PolicerType:
	//	*PolicerSpec_PpsPolicer
	//	*PolicerSpec_BpsPolicer
	PolicerType isPolicerSpec_PolicerType `protobuf_oneof:"policer_type"`
}

func (m *PolicerSpec) Reset()                    { *m = PolicerSpec{} }
func (m *PolicerSpec) String() string            { return proto.CompactTextString(m) }
func (*PolicerSpec) ProtoMessage()               {}
func (*PolicerSpec) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{2} }

type isPolicerSpec_PolicerType interface {
	isPolicerSpec_PolicerType()
	MarshalTo([]byte) (int, error)
	Size() int
}

type PolicerSpec_PpsPolicer struct {
	PpsPolicer *PolicerPPSSpec `protobuf:"bytes,1,opt,name=pps_policer,json=ppsPolicer,oneof"`
}
type PolicerSpec_BpsPolicer struct {
	BpsPolicer *PolicerBPSSpec `protobuf:"bytes,2,opt,name=bps_policer,json=bpsPolicer,oneof"`
}

func (*PolicerSpec_PpsPolicer) isPolicerSpec_PolicerType() {}
func (*PolicerSpec_BpsPolicer) isPolicerSpec_PolicerType() {}

func (m *PolicerSpec) GetPolicerType() isPolicerSpec_PolicerType {
	if m != nil {
		return m.PolicerType
	}
	return nil
}

func (m *PolicerSpec) GetPpsPolicer() *PolicerPPSSpec {
	if x, ok := m.GetPolicerType().(*PolicerSpec_PpsPolicer); ok {
		return x.PpsPolicer
	}
	return nil
}

func (m *PolicerSpec) GetBpsPolicer() *PolicerBPSSpec {
	if x, ok := m.GetPolicerType().(*PolicerSpec_BpsPolicer); ok {
		return x.BpsPolicer
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*PolicerSpec) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _PolicerSpec_OneofMarshaler, _PolicerSpec_OneofUnmarshaler, _PolicerSpec_OneofSizer, []interface{}{
		(*PolicerSpec_PpsPolicer)(nil),
		(*PolicerSpec_BpsPolicer)(nil),
	}
}

func _PolicerSpec_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*PolicerSpec)
	// policer_type
	switch x := m.PolicerType.(type) {
	case *PolicerSpec_PpsPolicer:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.PpsPolicer); err != nil {
			return err
		}
	case *PolicerSpec_BpsPolicer:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.BpsPolicer); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("PolicerSpec.PolicerType has unexpected type %T", x)
	}
	return nil
}

func _PolicerSpec_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*PolicerSpec)
	switch tag {
	case 1: // policer_type.pps_policer
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(PolicerPPSSpec)
		err := b.DecodeMessage(msg)
		m.PolicerType = &PolicerSpec_PpsPolicer{msg}
		return true, err
	case 2: // policer_type.bps_policer
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(PolicerBPSSpec)
		err := b.DecodeMessage(msg)
		m.PolicerType = &PolicerSpec_BpsPolicer{msg}
		return true, err
	default:
		return false, nil
	}
}

func _PolicerSpec_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*PolicerSpec)
	// policer_type
	switch x := m.PolicerType.(type) {
	case *PolicerSpec_PpsPolicer:
		s := proto.Size(x.PpsPolicer)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *PolicerSpec_BpsPolicer:
		s := proto.Size(x.BpsPolicer)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// PolicerStats captures all the statistics of a policer
type PolicerStats struct {
	PermittedPackets uint64 `protobuf:"varint,1,opt,name=permitted_packets,json=permittedPackets,proto3" json:"permitted_packets,omitempty"`
	PermittedBytes   uint64 `protobuf:"varint,2,opt,name=permitted_bytes,json=permittedBytes,proto3" json:"permitted_bytes,omitempty"`
	DroppedPackets   uint64 `protobuf:"varint,3,opt,name=dropped_packets,json=droppedPackets,proto3" json:"dropped_packets,omitempty"`
	DroppedBytes     uint64 `protobuf:"varint,4,opt,name=dropped_bytes,json=droppedBytes,proto3" json:"dropped_bytes,omitempty"`
}

func (m *PolicerStats) Reset()                    { *m = PolicerStats{} }
func (m *PolicerStats) String() string            { return proto.CompactTextString(m) }
func (*PolicerStats) ProtoMessage()               {}
func (*PolicerStats) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{3} }

func (m *PolicerStats) GetPermittedPackets() uint64 {
	if m != nil {
		return m.PermittedPackets
	}
	return 0
}

func (m *PolicerStats) GetPermittedBytes() uint64 {
	if m != nil {
		return m.PermittedBytes
	}
	return 0
}

func (m *PolicerStats) GetDroppedPackets() uint64 {
	if m != nil {
		return m.DroppedPackets
	}
	return 0
}

func (m *PolicerStats) GetDroppedBytes() uint64 {
	if m != nil {
		return m.DroppedBytes
	}
	return 0
}

// QosPause specifies the link-level or PFC configuration
type QosPause struct {
	XonThreshold  uint32       `protobuf:"varint,1,opt,name=xon_threshold,json=xonThreshold,proto3" json:"xon_threshold,omitempty"`
	XoffThreshold uint32       `protobuf:"varint,2,opt,name=xoff_threshold,json=xoffThreshold,proto3" json:"xoff_threshold,omitempty"`
	Type          QosPauseType `protobuf:"varint,3,opt,name=type,proto3,enum=qos.QosPauseType" json:"type,omitempty"`
	PfcCos        uint32       `protobuf:"varint,4,opt,name=pfc_cos,json=pfcCos,proto3" json:"pfc_cos,omitempty" venice:constraints={range:0-7}`
}

func (m *QosPause) Reset()                    { *m = QosPause{} }
func (m *QosPause) String() string            { return proto.CompactTextString(m) }
func (*QosPause) ProtoMessage()               {}
func (*QosPause) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{4} }

func (m *QosPause) GetXonThreshold() uint32 {
	if m != nil {
		return m.XonThreshold
	}
	return 0
}

func (m *QosPause) GetXoffThreshold() uint32 {
	if m != nil {
		return m.XoffThreshold
	}
	return 0
}

func (m *QosPause) GetType() QosPauseType {
	if m != nil {
		return m.Type
	}
	return QosPauseType_QOS_PAUSE_TYPE_NONE
}

func (m *QosPause) GetPfcCos() uint32 {
	if m != nil {
		return m.PfcCos
	}
	return 0
}

// QosSched specifies the QosClass scheduling configuration
type QosSched struct {
	// Types that are valid to be assigned to SchedType:
	//	*QosSched_Dwrr
	//	*QosSched_Strict
	SchedType isQosSched_SchedType `protobuf_oneof:"SchedType"`
}

func (m *QosSched) Reset()                    { *m = QosSched{} }
func (m *QosSched) String() string            { return proto.CompactTextString(m) }
func (*QosSched) ProtoMessage()               {}
func (*QosSched) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{5} }

type isQosSched_SchedType interface {
	isQosSched_SchedType()
	MarshalTo([]byte) (int, error)
	Size() int
}

type QosSched_Dwrr struct {
	Dwrr *QosSched_DWRRInfo `protobuf:"bytes,1,opt,name=dwrr,oneof"`
}
type QosSched_Strict struct {
	Strict *QosSched_StrictPriorityInfo `protobuf:"bytes,2,opt,name=strict,oneof"`
}

func (*QosSched_Dwrr) isQosSched_SchedType()   {}
func (*QosSched_Strict) isQosSched_SchedType() {}

func (m *QosSched) GetSchedType() isQosSched_SchedType {
	if m != nil {
		return m.SchedType
	}
	return nil
}

func (m *QosSched) GetDwrr() *QosSched_DWRRInfo {
	if x, ok := m.GetSchedType().(*QosSched_Dwrr); ok {
		return x.Dwrr
	}
	return nil
}

func (m *QosSched) GetStrict() *QosSched_StrictPriorityInfo {
	if x, ok := m.GetSchedType().(*QosSched_Strict); ok {
		return x.Strict
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*QosSched) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _QosSched_OneofMarshaler, _QosSched_OneofUnmarshaler, _QosSched_OneofSizer, []interface{}{
		(*QosSched_Dwrr)(nil),
		(*QosSched_Strict)(nil),
	}
}

func _QosSched_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*QosSched)
	// SchedType
	switch x := m.SchedType.(type) {
	case *QosSched_Dwrr:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Dwrr); err != nil {
			return err
		}
	case *QosSched_Strict:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Strict); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("QosSched.SchedType has unexpected type %T", x)
	}
	return nil
}

func _QosSched_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*QosSched)
	switch tag {
	case 1: // SchedType.dwrr
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(QosSched_DWRRInfo)
		err := b.DecodeMessage(msg)
		m.SchedType = &QosSched_Dwrr{msg}
		return true, err
	case 2: // SchedType.strict
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(QosSched_StrictPriorityInfo)
		err := b.DecodeMessage(msg)
		m.SchedType = &QosSched_Strict{msg}
		return true, err
	default:
		return false, nil
	}
}

func _QosSched_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*QosSched)
	// SchedType
	switch x := m.SchedType.(type) {
	case *QosSched_Dwrr:
		s := proto.Size(x.Dwrr)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *QosSched_Strict:
		s := proto.Size(x.Strict)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// DWRR specific information
type QosSched_DWRRInfo struct {
	BwPercentage uint32 `protobuf:"varint,1,opt,name=bw_percentage,json=bwPercentage,proto3" json:"bw_percentage,omitempty" venice:constraints={range:0-100}`
}

func (m *QosSched_DWRRInfo) Reset()                    { *m = QosSched_DWRRInfo{} }
func (m *QosSched_DWRRInfo) String() string            { return proto.CompactTextString(m) }
func (*QosSched_DWRRInfo) ProtoMessage()               {}
func (*QosSched_DWRRInfo) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{5, 0} }

func (m *QosSched_DWRRInfo) GetBwPercentage() uint32 {
	if m != nil {
		return m.BwPercentage
	}
	return 0
}

// Strict Priority specific information for the class
type QosSched_StrictPriorityInfo struct {
	Bps uint64 `protobuf:"varint,1,opt,name=bps,proto3" json:"bps,omitempty"`
}

func (m *QosSched_StrictPriorityInfo) Reset()         { *m = QosSched_StrictPriorityInfo{} }
func (m *QosSched_StrictPriorityInfo) String() string { return proto.CompactTextString(m) }
func (*QosSched_StrictPriorityInfo) ProtoMessage()    {}
func (*QosSched_StrictPriorityInfo) Descriptor() ([]byte, []int) {
	return fileDescriptorQos, []int{5, 1}
}

func (m *QosSched_StrictPriorityInfo) GetBps() uint64 {
	if m != nil {
		return m.Bps
	}
	return 0
}

// QosClassMap specifies the policy with which traffic from network
// is classified
type QosClassMap struct {
	Type     QosClassMapType `protobuf:"varint,1,opt,name=type,proto3,enum=qos.QosClassMapType" json:"type,omitempty"`
	Dot1QPcp uint32          `protobuf:"varint,2,opt,name=dot1q_pcp,json=dot1qPcp,proto3" json:"dot1q_pcp,omitempty" venice:constraints={range:0-7}`
	IpDscp   []uint32        `protobuf:"varint,3,rep,packed,name=ip_dscp,json=ipDscp" json:"ip_dscp,omitempty" venice:constraints={range:0-63}`
}

func (m *QosClassMap) Reset()                    { *m = QosClassMap{} }
func (m *QosClassMap) String() string            { return proto.CompactTextString(m) }
func (*QosClassMap) ProtoMessage()               {}
func (*QosClassMap) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{6} }

func (m *QosClassMap) GetType() QosClassMapType {
	if m != nil {
		return m.Type
	}
	return QosClassMapType_QOS_CLASS_MAP_TYPE_NONE
}

func (m *QosClassMap) GetDot1QPcp() uint32 {
	if m != nil {
		return m.Dot1QPcp
	}
	return 0
}

func (m *QosClassMap) GetIpDscp() []uint32 {
	if m != nil {
		return m.IpDscp
	}
	return nil
}

// QosMarking specifies the policy to mark the host-to-network traffic
type QosMarking struct {
	Dot1QPcpRewriteEn bool   `protobuf:"varint,1,opt,name=dot1q_pcp_rewrite_en,json=dot1qPcpRewriteEn,proto3" json:"dot1q_pcp_rewrite_en,omitempty"`
	Dot1QPcp          uint32 `protobuf:"varint,2,opt,name=dot1q_pcp,json=dot1qPcp,proto3" json:"dot1q_pcp,omitempty" venice:constraints={range:0-7}`
	IpDscpRewriteEn   bool   `protobuf:"varint,3,opt,name=ip_dscp_rewrite_en,json=ipDscpRewriteEn,proto3" json:"ip_dscp_rewrite_en,omitempty"`
	IpDscp            uint32 `protobuf:"varint,4,opt,name=ip_dscp,json=ipDscp,proto3" json:"ip_dscp,omitempty" venice:constraints={range:0-63}`
}

func (m *QosMarking) Reset()                    { *m = QosMarking{} }
func (m *QosMarking) String() string            { return proto.CompactTextString(m) }
func (*QosMarking) ProtoMessage()               {}
func (*QosMarking) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{7} }

func (m *QosMarking) GetDot1QPcpRewriteEn() bool {
	if m != nil {
		return m.Dot1QPcpRewriteEn
	}
	return false
}

func (m *QosMarking) GetDot1QPcp() uint32 {
	if m != nil {
		return m.Dot1QPcp
	}
	return 0
}

func (m *QosMarking) GetIpDscpRewriteEn() bool {
	if m != nil {
		return m.IpDscpRewriteEn
	}
	return false
}

func (m *QosMarking) GetIpDscp() uint32 {
	if m != nil {
		return m.IpDscp
	}
	return 0
}

// QosClass specification
type QosClassSpec struct {
	// key_or_handle is QosClass's key or handle
	KeyOrHandle *QosClassKeyHandle `protobuf:"bytes,1,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty" venice:key`
	Mtu         uint32             `protobuf:"varint,2,opt,name=mtu,proto3" json:"mtu,omitempty" venice:mandatory,venice:constraints={range:1500-9216}`
	Pause       *QosPause          `protobuf:"bytes,3,opt,name=pause" json:"pause,omitempty"`
	Sched       *QosSched          `protobuf:"bytes,4,opt,name=sched" json:"sched,omitempty" venice:mandatory`
	ClassMap    *QosClassMap       `protobuf:"bytes,5,opt,name=class_map,json=classMap" json:"class_map,omitempty"`
	Marking     *QosMarking        `protobuf:"bytes,6,opt,name=marking" json:"marking,omitempty"`
	NoDrop      bool               `protobuf:"varint,7,opt,name=no_drop,json=noDrop,proto3" json:"no_drop,omitempty"`
}

func (m *QosClassSpec) Reset()                    { *m = QosClassSpec{} }
func (m *QosClassSpec) String() string            { return proto.CompactTextString(m) }
func (*QosClassSpec) ProtoMessage()               {}
func (*QosClassSpec) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{8} }

func (m *QosClassSpec) GetKeyOrHandle() *QosClassKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

func (m *QosClassSpec) GetMtu() uint32 {
	if m != nil {
		return m.Mtu
	}
	return 0
}

func (m *QosClassSpec) GetPause() *QosPause {
	if m != nil {
		return m.Pause
	}
	return nil
}

func (m *QosClassSpec) GetSched() *QosSched {
	if m != nil {
		return m.Sched
	}
	return nil
}

func (m *QosClassSpec) GetClassMap() *QosClassMap {
	if m != nil {
		return m.ClassMap
	}
	return nil
}

func (m *QosClassSpec) GetMarking() *QosMarking {
	if m != nil {
		return m.Marking
	}
	return nil
}

func (m *QosClassSpec) GetNoDrop() bool {
	if m != nil {
		return m.NoDrop
	}
	return false
}

// QosClassRequestMsg is batched request to create/update the QosClasss
type QosClassRequestMsg struct {
	Request []*QosClassSpec `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *QosClassRequestMsg) Reset()                    { *m = QosClassRequestMsg{} }
func (m *QosClassRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*QosClassRequestMsg) ProtoMessage()               {}
func (*QosClassRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{9} }

func (m *QosClassRequestMsg) GetRequest() []*QosClassSpec {
	if m != nil {
		return m.Request
	}
	return nil
}

type PacketBufferPort struct {
	PortType PacketBufferPortType `protobuf:"varint,1,opt,name=port_type,json=portType,proto3,enum=qos.PacketBufferPortType" json:"port_type,omitempty"`
	PortNum  uint32               `protobuf:"varint,2,opt,name=port_num,json=portNum,proto3" json:"port_num,omitempty"`
}

func (m *PacketBufferPort) Reset()                    { *m = PacketBufferPort{} }
func (m *PacketBufferPort) String() string            { return proto.CompactTextString(m) }
func (*PacketBufferPort) ProtoMessage()               {}
func (*PacketBufferPort) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{10} }

func (m *PacketBufferPort) GetPortType() PacketBufferPortType {
	if m != nil {
		return m.PortType
	}
	return PacketBufferPortType_PACKET_BUFFER_PORT_TYPE_DMA
}

func (m *PacketBufferPort) GetPortNum() uint32 {
	if m != nil {
		return m.PortNum
	}
	return 0
}

type QosClassPortStatus struct {
	PacketBufferPort *PacketBufferPort `protobuf:"bytes,1,opt,name=packet_buffer_port,json=packetBufferPort" json:"packet_buffer_port,omitempty"`
	InputQueues      []uint32          `protobuf:"varint,2,rep,packed,name=input_queues,json=inputQueues" json:"input_queues,omitempty"`
	OutputQueues     []uint32          `protobuf:"varint,3,rep,packed,name=output_queues,json=outputQueues" json:"output_queues,omitempty"`
}

func (m *QosClassPortStatus) Reset()                    { *m = QosClassPortStatus{} }
func (m *QosClassPortStatus) String() string            { return proto.CompactTextString(m) }
func (*QosClassPortStatus) ProtoMessage()               {}
func (*QosClassPortStatus) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{11} }

func (m *QosClassPortStatus) GetPacketBufferPort() *PacketBufferPort {
	if m != nil {
		return m.PacketBufferPort
	}
	return nil
}

func (m *QosClassPortStatus) GetInputQueues() []uint32 {
	if m != nil {
		return m.InputQueues
	}
	return nil
}

func (m *QosClassPortStatus) GetOutputQueues() []uint32 {
	if m != nil {
		return m.OutputQueues
	}
	return nil
}

// QosClass oper state for enterprise pipeline
type QosClassStatusEpd struct {
	PortStatus          []*QosClassPortStatus `protobuf:"bytes,1,rep,name=port_status,json=portStatus" json:"port_status,omitempty"`
	TxTrafficClassCoses []uint32              `protobuf:"varint,2,rep,packed,name=tx_traffic_class_coses,json=txTrafficClassCoses" json:"tx_traffic_class_coses,omitempty"`
}

func (m *QosClassStatusEpd) Reset()                    { *m = QosClassStatusEpd{} }
func (m *QosClassStatusEpd) String() string            { return proto.CompactTextString(m) }
func (*QosClassStatusEpd) ProtoMessage()               {}
func (*QosClassStatusEpd) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{12} }

func (m *QosClassStatusEpd) GetPortStatus() []*QosClassPortStatus {
	if m != nil {
		return m.PortStatus
	}
	return nil
}

func (m *QosClassStatusEpd) GetTxTrafficClassCoses() []uint32 {
	if m != nil {
		return m.TxTrafficClassCoses
	}
	return nil
}

// QosClass oper state for cloud pipeline
type QosClassStatusCpd struct {
}

func (m *QosClassStatusCpd) Reset()                    { *m = QosClassStatusCpd{} }
func (m *QosClassStatusCpd) String() string            { return proto.CompactTextString(m) }
func (*QosClassStatusCpd) ProtoMessage()               {}
func (*QosClassStatusCpd) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{13} }

// QosClassStatus represents the operational status of QosClass
type QosClassStatus struct {
	QosClassHandle uint64 `protobuf:"fixed64,1,opt,name=qos_class_handle,json=qosClassHandle,proto3" json:"qos_class_handle,omitempty"`
	// Types that are valid to be assigned to QosClassPdStatus:
	//	*QosClassStatus_EpdStatus
	//	*QosClassStatus_CpdStatus
	QosClassPdStatus isQosClassStatus_QosClassPdStatus `protobuf_oneof:"qos_class_pd_status"`
}

func (m *QosClassStatus) Reset()                    { *m = QosClassStatus{} }
func (m *QosClassStatus) String() string            { return proto.CompactTextString(m) }
func (*QosClassStatus) ProtoMessage()               {}
func (*QosClassStatus) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{14} }

type isQosClassStatus_QosClassPdStatus interface {
	isQosClassStatus_QosClassPdStatus()
	MarshalTo([]byte) (int, error)
	Size() int
}

type QosClassStatus_EpdStatus struct {
	EpdStatus *QosClassStatusEpd `protobuf:"bytes,2,opt,name=epd_status,json=epdStatus,oneof"`
}
type QosClassStatus_CpdStatus struct {
	CpdStatus *QosClassStatusCpd `protobuf:"bytes,3,opt,name=cpd_status,json=cpdStatus,oneof"`
}

func (*QosClassStatus_EpdStatus) isQosClassStatus_QosClassPdStatus() {}
func (*QosClassStatus_CpdStatus) isQosClassStatus_QosClassPdStatus() {}

func (m *QosClassStatus) GetQosClassPdStatus() isQosClassStatus_QosClassPdStatus {
	if m != nil {
		return m.QosClassPdStatus
	}
	return nil
}

func (m *QosClassStatus) GetQosClassHandle() uint64 {
	if m != nil {
		return m.QosClassHandle
	}
	return 0
}

func (m *QosClassStatus) GetEpdStatus() *QosClassStatusEpd {
	if x, ok := m.GetQosClassPdStatus().(*QosClassStatus_EpdStatus); ok {
		return x.EpdStatus
	}
	return nil
}

func (m *QosClassStatus) GetCpdStatus() *QosClassStatusCpd {
	if x, ok := m.GetQosClassPdStatus().(*QosClassStatus_CpdStatus); ok {
		return x.CpdStatus
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*QosClassStatus) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _QosClassStatus_OneofMarshaler, _QosClassStatus_OneofUnmarshaler, _QosClassStatus_OneofSizer, []interface{}{
		(*QosClassStatus_EpdStatus)(nil),
		(*QosClassStatus_CpdStatus)(nil),
	}
}

func _QosClassStatus_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*QosClassStatus)
	// qos_class_pd_status
	switch x := m.QosClassPdStatus.(type) {
	case *QosClassStatus_EpdStatus:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.EpdStatus); err != nil {
			return err
		}
	case *QosClassStatus_CpdStatus:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.CpdStatus); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("QosClassStatus.QosClassPdStatus has unexpected type %T", x)
	}
	return nil
}

func _QosClassStatus_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*QosClassStatus)
	switch tag {
	case 2: // qos_class_pd_status.epd_status
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(QosClassStatusEpd)
		err := b.DecodeMessage(msg)
		m.QosClassPdStatus = &QosClassStatus_EpdStatus{msg}
		return true, err
	case 3: // qos_class_pd_status.cpd_status
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(QosClassStatusCpd)
		err := b.DecodeMessage(msg)
		m.QosClassPdStatus = &QosClassStatus_CpdStatus{msg}
		return true, err
	default:
		return false, nil
	}
}

func _QosClassStatus_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*QosClassStatus)
	// qos_class_pd_status
	switch x := m.QosClassPdStatus.(type) {
	case *QosClassStatus_EpdStatus:
		s := proto.Size(x.EpdStatus)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *QosClassStatus_CpdStatus:
		s := proto.Size(x.CpdStatus)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// QosClassResponse is response to one QosClassSpec
type QosClassResponse struct {
	ApiStatus ApiStatus       `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty" venice:api_status`
	Status    *QosClassStatus `protobuf:"bytes,2,opt,name=status" json:"status,omitempty"`
}

func (m *QosClassResponse) Reset()                    { *m = QosClassResponse{} }
func (m *QosClassResponse) String() string            { return proto.CompactTextString(m) }
func (*QosClassResponse) ProtoMessage()               {}
func (*QosClassResponse) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{15} }

func (m *QosClassResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *QosClassResponse) GetStatus() *QosClassStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

// QosClassResponseMsg is response to QosClassRequestMsg
type QosClassResponseMsg struct {
	Response []*QosClassResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *QosClassResponseMsg) Reset()                    { *m = QosClassResponseMsg{} }
func (m *QosClassResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*QosClassResponseMsg) ProtoMessage()               {}
func (*QosClassResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{16} }

func (m *QosClassResponseMsg) GetResponse() []*QosClassResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

// QosClassDeleteRequest  is used to delete a QosClass object
type QosClassDeleteRequest struct {
	// key_or_handle is to identify QosClass being deleted
	KeyOrHandle *QosClassKeyHandle `protobuf:"bytes,1,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty" venice:key`
	ClearStats  bool               `protobuf:"varint,2,opt,name=clear_stats,json=clearStats,proto3" json:"clear_stats,omitempty"`
}

func (m *QosClassDeleteRequest) Reset()                    { *m = QosClassDeleteRequest{} }
func (m *QosClassDeleteRequest) String() string            { return proto.CompactTextString(m) }
func (*QosClassDeleteRequest) ProtoMessage()               {}
func (*QosClassDeleteRequest) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{17} }

func (m *QosClassDeleteRequest) GetKeyOrHandle() *QosClassKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

func (m *QosClassDeleteRequest) GetClearStats() bool {
	if m != nil {
		return m.ClearStats
	}
	return false
}

// QosClassDeleteRequestMsg is used to delete a batch of QosClasss
type QosClassDeleteRequestMsg struct {
	Request []*QosClassDeleteRequest `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *QosClassDeleteRequestMsg) Reset()                    { *m = QosClassDeleteRequestMsg{} }
func (m *QosClassDeleteRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*QosClassDeleteRequestMsg) ProtoMessage()               {}
func (*QosClassDeleteRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{18} }

func (m *QosClassDeleteRequestMsg) GetRequest() []*QosClassDeleteRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

// QosClassDeleteResponse is response to QosClass delete request
type QosClassDeleteResponse struct {
	ApiStatus ApiStatus `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty" venice:api_status`
}

func (m *QosClassDeleteResponse) Reset()                    { *m = QosClassDeleteResponse{} }
func (m *QosClassDeleteResponse) String() string            { return proto.CompactTextString(m) }
func (*QosClassDeleteResponse) ProtoMessage()               {}
func (*QosClassDeleteResponse) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{19} }

func (m *QosClassDeleteResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

// QosClassDeleteResponseMsg is batched response to QosClassDeleteRequestMsg
type QosClassDeleteResponseMsg struct {
	Response []*QosClassDeleteResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *QosClassDeleteResponseMsg) Reset()                    { *m = QosClassDeleteResponseMsg{} }
func (m *QosClassDeleteResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*QosClassDeleteResponseMsg) ProtoMessage()               {}
func (*QosClassDeleteResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{20} }

func (m *QosClassDeleteResponseMsg) GetResponse() []*QosClassDeleteResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

// QosClearStatsRequest  is used to clear port mon stats for a given port
type QosClearStatsRequest struct {
	PortNum        uint32 `protobuf:"varint,1,opt,name=port_num,json=portNum,proto3" json:"port_num,omitempty"`
	QosGroupBitmap uint32 `protobuf:"varint,2,opt,name=qos_group_bitmap,json=qosGroupBitmap,proto3" json:"qos_group_bitmap,omitempty"`
}

func (m *QosClearStatsRequest) Reset()                    { *m = QosClearStatsRequest{} }
func (m *QosClearStatsRequest) String() string            { return proto.CompactTextString(m) }
func (*QosClearStatsRequest) ProtoMessage()               {}
func (*QosClearStatsRequest) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{21} }

func (m *QosClearStatsRequest) GetPortNum() uint32 {
	if m != nil {
		return m.PortNum
	}
	return 0
}

func (m *QosClearStatsRequest) GetQosGroupBitmap() uint32 {
	if m != nil {
		return m.QosGroupBitmap
	}
	return 0
}

// QosClearStatsRequestMsg is used to clear port mon stats for a bunch of ports
type QosClearStatsRequestMsg struct {
	Request []*QosClearStatsRequest `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *QosClearStatsRequestMsg) Reset()                    { *m = QosClearStatsRequestMsg{} }
func (m *QosClearStatsRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*QosClearStatsRequestMsg) ProtoMessage()               {}
func (*QosClearStatsRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{22} }

func (m *QosClearStatsRequestMsg) GetRequest() []*QosClearStatsRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

// QosClearStatsResponse is response to QosClearStatsRequest
type QosClearStatsResponse struct {
	ApiStatus ApiStatus `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty" venice:api_status`
}

func (m *QosClearStatsResponse) Reset()                    { *m = QosClearStatsResponse{} }
func (m *QosClearStatsResponse) String() string            { return proto.CompactTextString(m) }
func (*QosClearStatsResponse) ProtoMessage()               {}
func (*QosClearStatsResponse) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{23} }

func (m *QosClearStatsResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

// QosClearStatsResponseMsg is batched response to QosClearStatsRequestMsg
type QosClearStatsResponseMsg struct {
	Response []*QosClearStatsResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *QosClearStatsResponseMsg) Reset()                    { *m = QosClearStatsResponseMsg{} }
func (m *QosClearStatsResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*QosClearStatsResponseMsg) ProtoMessage()               {}
func (*QosClearStatsResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{24} }

func (m *QosClearStatsResponseMsg) GetResponse() []*QosClearStatsResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

type QosClassInputOflowQueueStats struct {
	GoodPktsIn    uint64 `protobuf:"varint,1,opt,name=good_pkts_in,json=goodPktsIn,proto3" json:"good_pkts_in,omitempty"`
	GoodPktsOut   uint64 `protobuf:"varint,2,opt,name=good_pkts_out,json=goodPktsOut,proto3" json:"good_pkts_out,omitempty"`
	ErroredPktsIn uint64 `protobuf:"varint,3,opt,name=errored_pkts_in,json=erroredPktsIn,proto3" json:"errored_pkts_in,omitempty"`
	FifoDepth     uint32 `protobuf:"varint,4,opt,name=fifo_depth,json=fifoDepth,proto3" json:"fifo_depth,omitempty"`
	MaxFifoDepth  uint32 `protobuf:"varint,5,opt,name=max_fifo_depth,json=maxFifoDepth,proto3" json:"max_fifo_depth,omitempty"`
}

func (m *QosClassInputOflowQueueStats) Reset()                    { *m = QosClassInputOflowQueueStats{} }
func (m *QosClassInputOflowQueueStats) String() string            { return proto.CompactTextString(m) }
func (*QosClassInputOflowQueueStats) ProtoMessage()               {}
func (*QosClassInputOflowQueueStats) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{25} }

func (m *QosClassInputOflowQueueStats) GetGoodPktsIn() uint64 {
	if m != nil {
		return m.GoodPktsIn
	}
	return 0
}

func (m *QosClassInputOflowQueueStats) GetGoodPktsOut() uint64 {
	if m != nil {
		return m.GoodPktsOut
	}
	return 0
}

func (m *QosClassInputOflowQueueStats) GetErroredPktsIn() uint64 {
	if m != nil {
		return m.ErroredPktsIn
	}
	return 0
}

func (m *QosClassInputOflowQueueStats) GetFifoDepth() uint32 {
	if m != nil {
		return m.FifoDepth
	}
	return 0
}

func (m *QosClassInputOflowQueueStats) GetMaxFifoDepth() uint32 {
	if m != nil {
		return m.MaxFifoDepth
	}
	return 0
}

type QosClassInputQueueStats struct {
	InputQueueIdx   uint32                        `protobuf:"varint,1,opt,name=input_queue_idx,json=inputQueueIdx,proto3" json:"input_queue_idx,omitempty"`
	OflowFifoStats  *QosClassInputOflowQueueStats `protobuf:"bytes,2,opt,name=oflow_fifo_stats,json=oflowFifoStats" json:"oflow_fifo_stats,omitempty"`
	BufferOccupancy uint32                        `protobuf:"varint,3,opt,name=buffer_occupancy,json=bufferOccupancy,proto3" json:"buffer_occupancy,omitempty"`
	PeakOccupancy   uint32                        `protobuf:"varint,4,opt,name=peak_occupancy,json=peakOccupancy,proto3" json:"peak_occupancy,omitempty"`
	PortMonitor     uint64                        `protobuf:"varint,5,opt,name=port_monitor,json=portMonitor,proto3" json:"port_monitor,omitempty"`
	QosGroupIdx     uint64                        `protobuf:"varint,6,opt,name=qos_group_idx,json=qosGroupIdx,proto3" json:"qos_group_idx,omitempty"`
}

func (m *QosClassInputQueueStats) Reset()                    { *m = QosClassInputQueueStats{} }
func (m *QosClassInputQueueStats) String() string            { return proto.CompactTextString(m) }
func (*QosClassInputQueueStats) ProtoMessage()               {}
func (*QosClassInputQueueStats) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{26} }

func (m *QosClassInputQueueStats) GetInputQueueIdx() uint32 {
	if m != nil {
		return m.InputQueueIdx
	}
	return 0
}

func (m *QosClassInputQueueStats) GetOflowFifoStats() *QosClassInputOflowQueueStats {
	if m != nil {
		return m.OflowFifoStats
	}
	return nil
}

func (m *QosClassInputQueueStats) GetBufferOccupancy() uint32 {
	if m != nil {
		return m.BufferOccupancy
	}
	return 0
}

func (m *QosClassInputQueueStats) GetPeakOccupancy() uint32 {
	if m != nil {
		return m.PeakOccupancy
	}
	return 0
}

func (m *QosClassInputQueueStats) GetPortMonitor() uint64 {
	if m != nil {
		return m.PortMonitor
	}
	return 0
}

func (m *QosClassInputQueueStats) GetQosGroupIdx() uint64 {
	if m != nil {
		return m.QosGroupIdx
	}
	return 0
}

type QosClassOutputQueueStats struct {
	OutputQueueIdx uint32 `protobuf:"varint,1,opt,name=output_queue_idx,json=outputQueueIdx,proto3" json:"output_queue_idx,omitempty"`
	QueueDepth     uint32 `protobuf:"varint,2,opt,name=queue_depth,json=queueDepth,proto3" json:"queue_depth,omitempty"`
	PortMonitor    uint64 `protobuf:"varint,3,opt,name=port_monitor,json=portMonitor,proto3" json:"port_monitor,omitempty"`
	QosGroupIdx    uint64 `protobuf:"varint,6,opt,name=qos_group_idx,json=qosGroupIdx,proto3" json:"qos_group_idx,omitempty"`
}

func (m *QosClassOutputQueueStats) Reset()                    { *m = QosClassOutputQueueStats{} }
func (m *QosClassOutputQueueStats) String() string            { return proto.CompactTextString(m) }
func (*QosClassOutputQueueStats) ProtoMessage()               {}
func (*QosClassOutputQueueStats) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{27} }

func (m *QosClassOutputQueueStats) GetOutputQueueIdx() uint32 {
	if m != nil {
		return m.OutputQueueIdx
	}
	return 0
}

func (m *QosClassOutputQueueStats) GetQueueDepth() uint32 {
	if m != nil {
		return m.QueueDepth
	}
	return 0
}

func (m *QosClassOutputQueueStats) GetPortMonitor() uint64 {
	if m != nil {
		return m.PortMonitor
	}
	return 0
}

func (m *QosClassOutputQueueStats) GetQosGroupIdx() uint64 {
	if m != nil {
		return m.QosGroupIdx
	}
	return 0
}

type QosClassQueueStats struct {
	InputQueueStats  []*QosClassInputQueueStats  `protobuf:"bytes,1,rep,name=input_queue_stats,json=inputQueueStats" json:"input_queue_stats,omitempty"`
	OutputQueueStats []*QosClassOutputQueueStats `protobuf:"bytes,2,rep,name=output_queue_stats,json=outputQueueStats" json:"output_queue_stats,omitempty"`
}

func (m *QosClassQueueStats) Reset()                    { *m = QosClassQueueStats{} }
func (m *QosClassQueueStats) String() string            { return proto.CompactTextString(m) }
func (*QosClassQueueStats) ProtoMessage()               {}
func (*QosClassQueueStats) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{28} }

func (m *QosClassQueueStats) GetInputQueueStats() []*QosClassInputQueueStats {
	if m != nil {
		return m.InputQueueStats
	}
	return nil
}

func (m *QosClassQueueStats) GetOutputQueueStats() []*QosClassOutputQueueStats {
	if m != nil {
		return m.OutputQueueStats
	}
	return nil
}

type QosClassPortStats struct {
	PacketBufferPort *PacketBufferPort   `protobuf:"bytes,1,opt,name=packet_buffer_port,json=packetBufferPort" json:"packet_buffer_port,omitempty"`
	QosQueueStats    *QosClassQueueStats `protobuf:"bytes,2,opt,name=qos_queue_stats,json=qosQueueStats" json:"qos_queue_stats,omitempty"`
}

func (m *QosClassPortStats) Reset()                    { *m = QosClassPortStats{} }
func (m *QosClassPortStats) String() string            { return proto.CompactTextString(m) }
func (*QosClassPortStats) ProtoMessage()               {}
func (*QosClassPortStats) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{29} }

func (m *QosClassPortStats) GetPacketBufferPort() *PacketBufferPort {
	if m != nil {
		return m.PacketBufferPort
	}
	return nil
}

func (m *QosClassPortStats) GetQosQueueStats() *QosClassQueueStats {
	if m != nil {
		return m.QosQueueStats
	}
	return nil
}

// QosClassStats captures all the statistics of given QosClass
type QosClassStats struct {
	NumLifsTx uint32               `protobuf:"varint,1,opt,name=num_lifs_tx,json=numLifsTx,proto3" json:"num_lifs_tx,omitempty"`
	NumLifsRx uint32               `protobuf:"varint,2,opt,name=num_lifs_rx,json=numLifsRx,proto3" json:"num_lifs_rx,omitempty"`
	PortStats []*QosClassPortStats `protobuf:"bytes,3,rep,name=port_stats,json=portStats" json:"port_stats,omitempty"`
}

func (m *QosClassStats) Reset()                    { *m = QosClassStats{} }
func (m *QosClassStats) String() string            { return proto.CompactTextString(m) }
func (*QosClassStats) ProtoMessage()               {}
func (*QosClassStats) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{30} }

func (m *QosClassStats) GetNumLifsTx() uint32 {
	if m != nil {
		return m.NumLifsTx
	}
	return 0
}

func (m *QosClassStats) GetNumLifsRx() uint32 {
	if m != nil {
		return m.NumLifsRx
	}
	return 0
}

func (m *QosClassStats) GetPortStats() []*QosClassPortStats {
	if m != nil {
		return m.PortStats
	}
	return nil
}

// QosClassGetRequest is used to get information about a QosClass
type QosClassGetRequest struct {
	// key_or_handle is to identify QosClass being deleted
	KeyOrHandle *QosClassKeyHandle `protobuf:"bytes,1,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty" venice:key`
}

func (m *QosClassGetRequest) Reset()                    { *m = QosClassGetRequest{} }
func (m *QosClassGetRequest) String() string            { return proto.CompactTextString(m) }
func (*QosClassGetRequest) ProtoMessage()               {}
func (*QosClassGetRequest) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{31} }

func (m *QosClassGetRequest) GetKeyOrHandle() *QosClassKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

// Batched request message to get the stats about a batch of QosClasss
type QosClassGetRequestMsg struct {
	Request []*QosClassGetRequest `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *QosClassGetRequestMsg) Reset()                    { *m = QosClassGetRequestMsg{} }
func (m *QosClassGetRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*QosClassGetRequestMsg) ProtoMessage()               {}
func (*QosClassGetRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{32} }

func (m *QosClassGetRequestMsg) GetRequest() []*QosClassGetRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

// QosClassGetResponse captures all the information about a QosClass
type QosClassGetResponse struct {
	ApiStatus ApiStatus       `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty" venice:api_status`
	Spec      *QosClassSpec   `protobuf:"bytes,2,opt,name=spec" json:"spec,omitempty"`
	Status    *QosClassStatus `protobuf:"bytes,3,opt,name=status" json:"status,omitempty"`
	Stats     *QosClassStats  `protobuf:"bytes,4,opt,name=stats" json:"stats,omitempty"`
}

func (m *QosClassGetResponse) Reset()                    { *m = QosClassGetResponse{} }
func (m *QosClassGetResponse) String() string            { return proto.CompactTextString(m) }
func (*QosClassGetResponse) ProtoMessage()               {}
func (*QosClassGetResponse) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{33} }

func (m *QosClassGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *QosClassGetResponse) GetSpec() *QosClassSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *QosClassGetResponse) GetStatus() *QosClassStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *QosClassGetResponse) GetStats() *QosClassStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

type OccupancyPerQueue struct {
	QueueIdx  uint32 `protobuf:"varint,1,opt,name=queue_idx,json=queueIdx,proto3" json:"queue_idx,omitempty"`
	Occupancy uint32 `protobuf:"varint,2,opt,name=occupancy,proto3" json:"occupancy,omitempty"`
}

func (m *OccupancyPerQueue) Reset()                    { *m = OccupancyPerQueue{} }
func (m *OccupancyPerQueue) String() string            { return proto.CompactTextString(m) }
func (*OccupancyPerQueue) ProtoMessage()               {}
func (*OccupancyPerQueue) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{34} }

func (m *OccupancyPerQueue) GetQueueIdx() uint32 {
	if m != nil {
		return m.QueueIdx
	}
	return 0
}

func (m *OccupancyPerQueue) GetOccupancy() uint32 {
	if m != nil {
		return m.Occupancy
	}
	return 0
}

type PortOccupancy struct {
	PortNum   uint32               `protobuf:"varint,1,opt,name=port_num,json=portNum,proto3" json:"port_num,omitempty"`
	Occupancy []*OccupancyPerQueue `protobuf:"bytes,2,rep,name=occupancy" json:"occupancy,omitempty"`
}

func (m *PortOccupancy) Reset()                    { *m = PortOccupancy{} }
func (m *PortOccupancy) String() string            { return proto.CompactTextString(m) }
func (*PortOccupancy) ProtoMessage()               {}
func (*PortOccupancy) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{35} }

func (m *PortOccupancy) GetPortNum() uint32 {
	if m != nil {
		return m.PortNum
	}
	return 0
}

func (m *PortOccupancy) GetOccupancy() []*OccupancyPerQueue {
	if m != nil {
		return m.Occupancy
	}
	return nil
}

type Thresholds struct {
	HbmContext    uint32 `protobuf:"varint,1,opt,name=hbm_context,json=hbmContext,proto3" json:"hbm_context,omitempty"`
	XonThreshold  uint32 `protobuf:"varint,2,opt,name=xon_threshold,json=xonThreshold,proto3" json:"xon_threshold,omitempty"`
	XoffThreshold uint32 `protobuf:"varint,3,opt,name=xoff_threshold,json=xoffThreshold,proto3" json:"xoff_threshold,omitempty"`
}

func (m *Thresholds) Reset()                    { *m = Thresholds{} }
func (m *Thresholds) String() string            { return proto.CompactTextString(m) }
func (*Thresholds) ProtoMessage()               {}
func (*Thresholds) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{36} }

func (m *Thresholds) GetHbmContext() uint32 {
	if m != nil {
		return m.HbmContext
	}
	return 0
}

func (m *Thresholds) GetXonThreshold() uint32 {
	if m != nil {
		return m.XonThreshold
	}
	return 0
}

func (m *Thresholds) GetXoffThreshold() uint32 {
	if m != nil {
		return m.XoffThreshold
	}
	return 0
}

type QosClassThresholdsGetResponse struct {
	ApiStatus     ApiStatus        `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty" venice:api_status`
	PortOccupancy []*PortOccupancy `protobuf:"bytes,2,rep,name=port_occupancy,json=portOccupancy" json:"port_occupancy,omitempty"`
	Thresholds    []*Thresholds    `protobuf:"bytes,3,rep,name=thresholds" json:"thresholds,omitempty"`
}

func (m *QosClassThresholdsGetResponse) Reset()         { *m = QosClassThresholdsGetResponse{} }
func (m *QosClassThresholdsGetResponse) String() string { return proto.CompactTextString(m) }
func (*QosClassThresholdsGetResponse) ProtoMessage()    {}
func (*QosClassThresholdsGetResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorQos, []int{37}
}

func (m *QosClassThresholdsGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *QosClassThresholdsGetResponse) GetPortOccupancy() []*PortOccupancy {
	if m != nil {
		return m.PortOccupancy
	}
	return nil
}

func (m *QosClassThresholdsGetResponse) GetThresholds() []*Thresholds {
	if m != nil {
		return m.Thresholds
	}
	return nil
}

type QosClassThresholdsGetResponseMsg struct {
	Response []*QosClassThresholdsGetResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *QosClassThresholdsGetResponseMsg) Reset()         { *m = QosClassThresholdsGetResponseMsg{} }
func (m *QosClassThresholdsGetResponseMsg) String() string { return proto.CompactTextString(m) }
func (*QosClassThresholdsGetResponseMsg) ProtoMessage()    {}
func (*QosClassThresholdsGetResponseMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorQos, []int{38}
}

func (m *QosClassThresholdsGetResponseMsg) GetResponse() []*QosClassThresholdsGetResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

type QosClassThresholdsGetRequest struct {
}

func (m *QosClassThresholdsGetRequest) Reset()                    { *m = QosClassThresholdsGetRequest{} }
func (m *QosClassThresholdsGetRequest) String() string            { return proto.CompactTextString(m) }
func (*QosClassThresholdsGetRequest) ProtoMessage()               {}
func (*QosClassThresholdsGetRequest) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{39} }

type QosClassThresholdsGetRequestMsg struct {
	Request []*QosClassThresholdsGetRequest `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *QosClassThresholdsGetRequestMsg) Reset()         { *m = QosClassThresholdsGetRequestMsg{} }
func (m *QosClassThresholdsGetRequestMsg) String() string { return proto.CompactTextString(m) }
func (*QosClassThresholdsGetRequestMsg) ProtoMessage()    {}
func (*QosClassThresholdsGetRequestMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorQos, []int{40}
}

func (m *QosClassThresholdsGetRequestMsg) GetRequest() []*QosClassThresholdsGetRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

// QosClassGetResponseMsg is response to QosClassGetRequestMsg
type QosClassGetResponseMsg struct {
	Response []*QosClassGetResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *QosClassGetResponseMsg) Reset()                    { *m = QosClassGetResponseMsg{} }
func (m *QosClassGetResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*QosClassGetResponseMsg) ProtoMessage()               {}
func (*QosClassGetResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{41} }

func (m *QosClassGetResponseMsg) GetResponse() []*QosClassGetResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

type QosClassSetGlobalPauseTypeRequest struct {
	PauseType QosPauseType `protobuf:"varint,1,opt,name=pause_type,json=pauseType,proto3,enum=qos.QosPauseType" json:"pause_type,omitempty"`
}

func (m *QosClassSetGlobalPauseTypeRequest) Reset()         { *m = QosClassSetGlobalPauseTypeRequest{} }
func (m *QosClassSetGlobalPauseTypeRequest) String() string { return proto.CompactTextString(m) }
func (*QosClassSetGlobalPauseTypeRequest) ProtoMessage()    {}
func (*QosClassSetGlobalPauseTypeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptorQos, []int{42}
}

func (m *QosClassSetGlobalPauseTypeRequest) GetPauseType() QosPauseType {
	if m != nil {
		return m.PauseType
	}
	return QosPauseType_QOS_PAUSE_TYPE_NONE
}

type QosClassSetGlobalPauseTypeRequestMsg struct {
	Request []*QosClassSetGlobalPauseTypeRequest `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *QosClassSetGlobalPauseTypeRequestMsg) Reset()         { *m = QosClassSetGlobalPauseTypeRequestMsg{} }
func (m *QosClassSetGlobalPauseTypeRequestMsg) String() string { return proto.CompactTextString(m) }
func (*QosClassSetGlobalPauseTypeRequestMsg) ProtoMessage()    {}
func (*QosClassSetGlobalPauseTypeRequestMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorQos, []int{43}
}

func (m *QosClassSetGlobalPauseTypeRequestMsg) GetRequest() []*QosClassSetGlobalPauseTypeRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

type QosClassSetGlobalPauseTypeResponseMsg struct {
}

func (m *QosClassSetGlobalPauseTypeResponseMsg) Reset()         { *m = QosClassSetGlobalPauseTypeResponseMsg{} }
func (m *QosClassSetGlobalPauseTypeResponseMsg) String() string { return proto.CompactTextString(m) }
func (*QosClassSetGlobalPauseTypeResponseMsg) ProtoMessage()    {}
func (*QosClassSetGlobalPauseTypeResponseMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorQos, []int{44}
}

type QosResetRequest struct {
	Group uint32 `protobuf:"varint,1,opt,name=group,proto3" json:"group,omitempty"`
}

func (m *QosResetRequest) Reset()                    { *m = QosResetRequest{} }
func (m *QosResetRequest) String() string            { return proto.CompactTextString(m) }
func (*QosResetRequest) ProtoMessage()               {}
func (*QosResetRequest) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{45} }

func (m *QosResetRequest) GetGroup() uint32 {
	if m != nil {
		return m.Group
	}
	return 0
}

type QosResetRequestMsg struct {
	Request []*QosResetRequest `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *QosResetRequestMsg) Reset()                    { *m = QosResetRequestMsg{} }
func (m *QosResetRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*QosResetRequestMsg) ProtoMessage()               {}
func (*QosResetRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{46} }

func (m *QosResetRequestMsg) GetRequest() []*QosResetRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

type QosResetResponseMsg struct {
}

func (m *QosResetResponseMsg) Reset()                    { *m = QosResetResponseMsg{} }
func (m *QosResetResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*QosResetResponseMsg) ProtoMessage()               {}
func (*QosResetResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{47} }

// Specifications of a Copp
type CoppSpec struct {
	// key_or_handle is Copp's unique identifier
	KeyOrHandle *CoppKeyHandle `protobuf:"bytes,1,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty" venice:key`
	Policer     *PolicerSpec   `protobuf:"bytes,3,opt,name=policer" json:"policer,omitempty" venice:mandatory`
}

func (m *CoppSpec) Reset()                    { *m = CoppSpec{} }
func (m *CoppSpec) String() string            { return proto.CompactTextString(m) }
func (*CoppSpec) ProtoMessage()               {}
func (*CoppSpec) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{48} }

func (m *CoppSpec) GetKeyOrHandle() *CoppKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

func (m *CoppSpec) GetPolicer() *PolicerSpec {
	if m != nil {
		return m.Policer
	}
	return nil
}

// Batched requests to create/update Copps
type CoppRequestMsg struct {
	Request []*CoppSpec `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *CoppRequestMsg) Reset()                    { *m = CoppRequestMsg{} }
func (m *CoppRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*CoppRequestMsg) ProtoMessage()               {}
func (*CoppRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{49} }

func (m *CoppRequestMsg) GetRequest() []*CoppSpec {
	if m != nil {
		return m.Request
	}
	return nil
}

// Copp oper state for enterprise pipeline
type CoppStatusEpd struct {
	HwPolicerIdx uint32 `protobuf:"varint,1,opt,name=hw_policer_idx,json=hwPolicerIdx,proto3" json:"hw_policer_idx,omitempty"`
}

func (m *CoppStatusEpd) Reset()                    { *m = CoppStatusEpd{} }
func (m *CoppStatusEpd) String() string            { return proto.CompactTextString(m) }
func (*CoppStatusEpd) ProtoMessage()               {}
func (*CoppStatusEpd) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{50} }

func (m *CoppStatusEpd) GetHwPolicerIdx() uint32 {
	if m != nil {
		return m.HwPolicerIdx
	}
	return 0
}

// Copp oper state for cloud pipeline
type CoppStatusCpd struct {
}

func (m *CoppStatusCpd) Reset()                    { *m = CoppStatusCpd{} }
func (m *CoppStatusCpd) String() string            { return proto.CompactTextString(m) }
func (*CoppStatusCpd) ProtoMessage()               {}
func (*CoppStatusCpd) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{51} }

type CoppStatus struct {
	CoppHandle uint64 `protobuf:"fixed64,1,opt,name=copp_handle,json=coppHandle,proto3" json:"copp_handle,omitempty"`
	// Types that are valid to be assigned to QosClassPdStatus:
	//	*CoppStatus_EpdStatus
	//	*CoppStatus_CpdStatus
	QosClassPdStatus isCoppStatus_QosClassPdStatus `protobuf_oneof:"qos_class_pd_status"`
}

func (m *CoppStatus) Reset()                    { *m = CoppStatus{} }
func (m *CoppStatus) String() string            { return proto.CompactTextString(m) }
func (*CoppStatus) ProtoMessage()               {}
func (*CoppStatus) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{52} }

type isCoppStatus_QosClassPdStatus interface {
	isCoppStatus_QosClassPdStatus()
	MarshalTo([]byte) (int, error)
	Size() int
}

type CoppStatus_EpdStatus struct {
	EpdStatus *CoppStatusEpd `protobuf:"bytes,2,opt,name=epd_status,json=epdStatus,oneof"`
}
type CoppStatus_CpdStatus struct {
	CpdStatus *CoppStatusCpd `protobuf:"bytes,3,opt,name=cpd_status,json=cpdStatus,oneof"`
}

func (*CoppStatus_EpdStatus) isCoppStatus_QosClassPdStatus() {}
func (*CoppStatus_CpdStatus) isCoppStatus_QosClassPdStatus() {}

func (m *CoppStatus) GetQosClassPdStatus() isCoppStatus_QosClassPdStatus {
	if m != nil {
		return m.QosClassPdStatus
	}
	return nil
}

func (m *CoppStatus) GetCoppHandle() uint64 {
	if m != nil {
		return m.CoppHandle
	}
	return 0
}

func (m *CoppStatus) GetEpdStatus() *CoppStatusEpd {
	if x, ok := m.GetQosClassPdStatus().(*CoppStatus_EpdStatus); ok {
		return x.EpdStatus
	}
	return nil
}

func (m *CoppStatus) GetCpdStatus() *CoppStatusCpd {
	if x, ok := m.GetQosClassPdStatus().(*CoppStatus_CpdStatus); ok {
		return x.CpdStatus
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*CoppStatus) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _CoppStatus_OneofMarshaler, _CoppStatus_OneofUnmarshaler, _CoppStatus_OneofSizer, []interface{}{
		(*CoppStatus_EpdStatus)(nil),
		(*CoppStatus_CpdStatus)(nil),
	}
}

func _CoppStatus_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*CoppStatus)
	// qos_class_pd_status
	switch x := m.QosClassPdStatus.(type) {
	case *CoppStatus_EpdStatus:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.EpdStatus); err != nil {
			return err
		}
	case *CoppStatus_CpdStatus:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.CpdStatus); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("CoppStatus.QosClassPdStatus has unexpected type %T", x)
	}
	return nil
}

func _CoppStatus_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*CoppStatus)
	switch tag {
	case 2: // qos_class_pd_status.epd_status
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(CoppStatusEpd)
		err := b.DecodeMessage(msg)
		m.QosClassPdStatus = &CoppStatus_EpdStatus{msg}
		return true, err
	case 3: // qos_class_pd_status.cpd_status
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(CoppStatusCpd)
		err := b.DecodeMessage(msg)
		m.QosClassPdStatus = &CoppStatus_CpdStatus{msg}
		return true, err
	default:
		return false, nil
	}
}

func _CoppStatus_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*CoppStatus)
	// qos_class_pd_status
	switch x := m.QosClassPdStatus.(type) {
	case *CoppStatus_EpdStatus:
		s := proto.Size(x.EpdStatus)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *CoppStatus_CpdStatus:
		s := proto.Size(x.CpdStatus)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// CoppResponse is response to one Copp
type CoppResponse struct {
	ApiStatus ApiStatus   `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty" venice:api_status`
	Status    *CoppStatus `protobuf:"bytes,2,opt,name=status" json:"status,omitempty"`
}

func (m *CoppResponse) Reset()                    { *m = CoppResponse{} }
func (m *CoppResponse) String() string            { return proto.CompactTextString(m) }
func (*CoppResponse) ProtoMessage()               {}
func (*CoppResponse) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{53} }

func (m *CoppResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *CoppResponse) GetStatus() *CoppStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

// Batched responses to create/update Copps
type CoppResponseMsg struct {
	Response []*CoppResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *CoppResponseMsg) Reset()                    { *m = CoppResponseMsg{} }
func (m *CoppResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*CoppResponseMsg) ProtoMessage()               {}
func (*CoppResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{54} }

func (m *CoppResponseMsg) GetResponse() []*CoppResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

// CoppDeleteRequest  is used to delete a Copp object
type CoppDeleteRequest struct {
	// key_or_handle is to identify Copp being deleted
	KeyOrHandle *CoppKeyHandle `protobuf:"bytes,1,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty" venice:key`
}

func (m *CoppDeleteRequest) Reset()                    { *m = CoppDeleteRequest{} }
func (m *CoppDeleteRequest) String() string            { return proto.CompactTextString(m) }
func (*CoppDeleteRequest) ProtoMessage()               {}
func (*CoppDeleteRequest) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{55} }

func (m *CoppDeleteRequest) GetKeyOrHandle() *CoppKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

// CoppDeleteRequestMsg is used to delete a batch of Copps
type CoppDeleteRequestMsg struct {
	Request []*CoppDeleteRequest `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *CoppDeleteRequestMsg) Reset()                    { *m = CoppDeleteRequestMsg{} }
func (m *CoppDeleteRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*CoppDeleteRequestMsg) ProtoMessage()               {}
func (*CoppDeleteRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{56} }

func (m *CoppDeleteRequestMsg) GetRequest() []*CoppDeleteRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

// CoppDeleteResponse is response to Copp delete request
type CoppDeleteResponse struct {
	ApiStatus ApiStatus `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty" venice:api_status`
}

func (m *CoppDeleteResponse) Reset()                    { *m = CoppDeleteResponse{} }
func (m *CoppDeleteResponse) String() string            { return proto.CompactTextString(m) }
func (*CoppDeleteResponse) ProtoMessage()               {}
func (*CoppDeleteResponse) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{57} }

func (m *CoppDeleteResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

// CoppDeleteResponseMsg is batched response to CoppDeleteRequestMsg
type CoppDeleteResponseMsg struct {
	Response []*CoppDeleteResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *CoppDeleteResponseMsg) Reset()                    { *m = CoppDeleteResponseMsg{} }
func (m *CoppDeleteResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*CoppDeleteResponseMsg) ProtoMessage()               {}
func (*CoppDeleteResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{58} }

func (m *CoppDeleteResponseMsg) GetResponse() []*CoppDeleteResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

// CoppStats captures all the statistics of given Copp
type CoppStats struct {
	PolicerStats *PolicerStats `protobuf:"bytes,1,opt,name=policer_stats,json=policerStats" json:"policer_stats,omitempty"`
	NumAcls      uint32        `protobuf:"varint,2,opt,name=num_acls,json=numAcls,proto3" json:"num_acls,omitempty"`
}

func (m *CoppStats) Reset()                    { *m = CoppStats{} }
func (m *CoppStats) String() string            { return proto.CompactTextString(m) }
func (*CoppStats) ProtoMessage()               {}
func (*CoppStats) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{59} }

func (m *CoppStats) GetPolicerStats() *PolicerStats {
	if m != nil {
		return m.PolicerStats
	}
	return nil
}

func (m *CoppStats) GetNumAcls() uint32 {
	if m != nil {
		return m.NumAcls
	}
	return 0
}

// CoppGetRequest is used to get information about a Copp
type CoppGetRequest struct {
	// key_or_handle is Copp's unique identifier
	KeyOrHandle *CoppKeyHandle `protobuf:"bytes,1,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty" venice:key`
}

func (m *CoppGetRequest) Reset()                    { *m = CoppGetRequest{} }
func (m *CoppGetRequest) String() string            { return proto.CompactTextString(m) }
func (*CoppGetRequest) ProtoMessage()               {}
func (*CoppGetRequest) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{60} }

func (m *CoppGetRequest) GetKeyOrHandle() *CoppKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

type CoppGetRequestMsg struct {
	Request []*CoppGetRequest `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *CoppGetRequestMsg) Reset()                    { *m = CoppGetRequestMsg{} }
func (m *CoppGetRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*CoppGetRequestMsg) ProtoMessage()               {}
func (*CoppGetRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{61} }

func (m *CoppGetRequestMsg) GetRequest() []*CoppGetRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

// CoppGetResponse captures all the information about a Copp
type CoppGetResponse struct {
	ApiStatus ApiStatus   `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty" venice:api_status`
	Spec      *CoppSpec   `protobuf:"bytes,2,opt,name=spec" json:"spec,omitempty"`
	Status    *CoppStatus `protobuf:"bytes,3,opt,name=status" json:"status,omitempty"`
	Stats     *CoppStats  `protobuf:"bytes,4,opt,name=stats" json:"stats,omitempty"`
}

func (m *CoppGetResponse) Reset()                    { *m = CoppGetResponse{} }
func (m *CoppGetResponse) String() string            { return proto.CompactTextString(m) }
func (*CoppGetResponse) ProtoMessage()               {}
func (*CoppGetResponse) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{62} }

func (m *CoppGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *CoppGetResponse) GetSpec() *CoppSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *CoppGetResponse) GetStatus() *CoppStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *CoppGetResponse) GetStats() *CoppStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

// CoppGetResponseMsg is response to CoppGetRequestMsg
type CoppGetResponseMsg struct {
	Response []*CoppGetResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *CoppGetResponseMsg) Reset()                    { *m = CoppGetResponseMsg{} }
func (m *CoppGetResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*CoppGetResponseMsg) ProtoMessage()               {}
func (*CoppGetResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{63} }

func (m *CoppGetResponseMsg) GetResponse() []*CoppGetResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

func init() {
	proto.RegisterType((*PolicerPPSSpec)(nil), "qos.PolicerPPSSpec")
	proto.RegisterType((*PolicerBPSSpec)(nil), "qos.PolicerBPSSpec")
	proto.RegisterType((*PolicerSpec)(nil), "qos.PolicerSpec")
	proto.RegisterType((*PolicerStats)(nil), "qos.PolicerStats")
	proto.RegisterType((*QosPause)(nil), "qos.QosPause")
	proto.RegisterType((*QosSched)(nil), "qos.QosSched")
	proto.RegisterType((*QosSched_DWRRInfo)(nil), "qos.QosSched.DWRRInfo")
	proto.RegisterType((*QosSched_StrictPriorityInfo)(nil), "qos.QosSched.StrictPriorityInfo")
	proto.RegisterType((*QosClassMap)(nil), "qos.QosClassMap")
	proto.RegisterType((*QosMarking)(nil), "qos.QosMarking")
	proto.RegisterType((*QosClassSpec)(nil), "qos.QosClassSpec")
	proto.RegisterType((*QosClassRequestMsg)(nil), "qos.QosClassRequestMsg")
	proto.RegisterType((*PacketBufferPort)(nil), "qos.PacketBufferPort")
	proto.RegisterType((*QosClassPortStatus)(nil), "qos.QosClassPortStatus")
	proto.RegisterType((*QosClassStatusEpd)(nil), "qos.QosClassStatusEpd")
	proto.RegisterType((*QosClassStatusCpd)(nil), "qos.QosClassStatusCpd")
	proto.RegisterType((*QosClassStatus)(nil), "qos.QosClassStatus")
	proto.RegisterType((*QosClassResponse)(nil), "qos.QosClassResponse")
	proto.RegisterType((*QosClassResponseMsg)(nil), "qos.QosClassResponseMsg")
	proto.RegisterType((*QosClassDeleteRequest)(nil), "qos.QosClassDeleteRequest")
	proto.RegisterType((*QosClassDeleteRequestMsg)(nil), "qos.QosClassDeleteRequestMsg")
	proto.RegisterType((*QosClassDeleteResponse)(nil), "qos.QosClassDeleteResponse")
	proto.RegisterType((*QosClassDeleteResponseMsg)(nil), "qos.QosClassDeleteResponseMsg")
	proto.RegisterType((*QosClearStatsRequest)(nil), "qos.QosClearStatsRequest")
	proto.RegisterType((*QosClearStatsRequestMsg)(nil), "qos.QosClearStatsRequestMsg")
	proto.RegisterType((*QosClearStatsResponse)(nil), "qos.QosClearStatsResponse")
	proto.RegisterType((*QosClearStatsResponseMsg)(nil), "qos.QosClearStatsResponseMsg")
	proto.RegisterType((*QosClassInputOflowQueueStats)(nil), "qos.QosClassInputOflowQueueStats")
	proto.RegisterType((*QosClassInputQueueStats)(nil), "qos.QosClassInputQueueStats")
	proto.RegisterType((*QosClassOutputQueueStats)(nil), "qos.QosClassOutputQueueStats")
	proto.RegisterType((*QosClassQueueStats)(nil), "qos.QosClassQueueStats")
	proto.RegisterType((*QosClassPortStats)(nil), "qos.QosClassPortStats")
	proto.RegisterType((*QosClassStats)(nil), "qos.QosClassStats")
	proto.RegisterType((*QosClassGetRequest)(nil), "qos.QosClassGetRequest")
	proto.RegisterType((*QosClassGetRequestMsg)(nil), "qos.QosClassGetRequestMsg")
	proto.RegisterType((*QosClassGetResponse)(nil), "qos.QosClassGetResponse")
	proto.RegisterType((*OccupancyPerQueue)(nil), "qos.OccupancyPerQueue")
	proto.RegisterType((*PortOccupancy)(nil), "qos.PortOccupancy")
	proto.RegisterType((*Thresholds)(nil), "qos.Thresholds")
	proto.RegisterType((*QosClassThresholdsGetResponse)(nil), "qos.QosClassThresholdsGetResponse")
	proto.RegisterType((*QosClassThresholdsGetResponseMsg)(nil), "qos.QosClassThresholdsGetResponseMsg")
	proto.RegisterType((*QosClassThresholdsGetRequest)(nil), "qos.QosClassThresholdsGetRequest")
	proto.RegisterType((*QosClassThresholdsGetRequestMsg)(nil), "qos.QosClassThresholdsGetRequestMsg")
	proto.RegisterType((*QosClassGetResponseMsg)(nil), "qos.QosClassGetResponseMsg")
	proto.RegisterType((*QosClassSetGlobalPauseTypeRequest)(nil), "qos.QosClassSetGlobalPauseTypeRequest")
	proto.RegisterType((*QosClassSetGlobalPauseTypeRequestMsg)(nil), "qos.QosClassSetGlobalPauseTypeRequestMsg")
	proto.RegisterType((*QosClassSetGlobalPauseTypeResponseMsg)(nil), "qos.QosClassSetGlobalPauseTypeResponseMsg")
	proto.RegisterType((*QosResetRequest)(nil), "qos.QosResetRequest")
	proto.RegisterType((*QosResetRequestMsg)(nil), "qos.QosResetRequestMsg")
	proto.RegisterType((*QosResetResponseMsg)(nil), "qos.QosResetResponseMsg")
	proto.RegisterType((*CoppSpec)(nil), "qos.CoppSpec")
	proto.RegisterType((*CoppRequestMsg)(nil), "qos.CoppRequestMsg")
	proto.RegisterType((*CoppStatusEpd)(nil), "qos.CoppStatusEpd")
	proto.RegisterType((*CoppStatusCpd)(nil), "qos.CoppStatusCpd")
	proto.RegisterType((*CoppStatus)(nil), "qos.CoppStatus")
	proto.RegisterType((*CoppResponse)(nil), "qos.CoppResponse")
	proto.RegisterType((*CoppResponseMsg)(nil), "qos.CoppResponseMsg")
	proto.RegisterType((*CoppDeleteRequest)(nil), "qos.CoppDeleteRequest")
	proto.RegisterType((*CoppDeleteRequestMsg)(nil), "qos.CoppDeleteRequestMsg")
	proto.RegisterType((*CoppDeleteResponse)(nil), "qos.CoppDeleteResponse")
	proto.RegisterType((*CoppDeleteResponseMsg)(nil), "qos.CoppDeleteResponseMsg")
	proto.RegisterType((*CoppStats)(nil), "qos.CoppStats")
	proto.RegisterType((*CoppGetRequest)(nil), "qos.CoppGetRequest")
	proto.RegisterType((*CoppGetRequestMsg)(nil), "qos.CoppGetRequestMsg")
	proto.RegisterType((*CoppGetResponse)(nil), "qos.CoppGetResponse")
	proto.RegisterType((*CoppGetResponseMsg)(nil), "qos.CoppGetResponseMsg")
	proto.RegisterEnum("qos.QosPauseType", QosPauseType_name, QosPauseType_value)
	proto.RegisterEnum("qos.QosClassMapType", QosClassMapType_name, QosClassMapType_value)
	proto.RegisterEnum("qos.PacketBufferPortType", PacketBufferPortType_name, PacketBufferPortType_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for QOS service

type QOSClient interface {
	// QOS class related APIs
	QosClassCreate(ctx context.Context, in *QosClassRequestMsg, opts ...grpc.CallOption) (*QosClassResponseMsg, error)
	QosClassUpdate(ctx context.Context, in *QosClassRequestMsg, opts ...grpc.CallOption) (*QosClassResponseMsg, error)
	QosClassDelete(ctx context.Context, in *QosClassDeleteRequestMsg, opts ...grpc.CallOption) (*QosClassDeleteResponseMsg, error)
	QosClassGet(ctx context.Context, in *QosClassGetRequestMsg, opts ...grpc.CallOption) (*QosClassGetResponseMsg, error)
	QosClassThresholdsGet(ctx context.Context, in *QosClassThresholdsGetRequestMsg, opts ...grpc.CallOption) (*QosClassThresholdsGetResponseMsg, error)
	QosClassSetGlobalPauseType(ctx context.Context, in *QosClassSetGlobalPauseTypeRequestMsg, opts ...grpc.CallOption) (*QosClassSetGlobalPauseTypeResponseMsg, error)
	QosClearStats(ctx context.Context, in *QosClearStatsRequestMsg, opts ...grpc.CallOption) (*QosClearStatsResponseMsg, error)
	QosReset(ctx context.Context, in *QosResetRequestMsg, opts ...grpc.CallOption) (*QosResetResponseMsg, error)
	// Copp related APIs
	CoppUpdate(ctx context.Context, in *CoppRequestMsg, opts ...grpc.CallOption) (*CoppResponseMsg, error)
	CoppGet(ctx context.Context, in *CoppGetRequestMsg, opts ...grpc.CallOption) (*CoppGetResponseMsg, error)
}

type qOSClient struct {
	cc *grpc.ClientConn
}

func NewQOSClient(cc *grpc.ClientConn) QOSClient {
	return &qOSClient{cc}
}

func (c *qOSClient) QosClassCreate(ctx context.Context, in *QosClassRequestMsg, opts ...grpc.CallOption) (*QosClassResponseMsg, error) {
	out := new(QosClassResponseMsg)
	err := grpc.Invoke(ctx, "/qos.QOS/QosClassCreate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *qOSClient) QosClassUpdate(ctx context.Context, in *QosClassRequestMsg, opts ...grpc.CallOption) (*QosClassResponseMsg, error) {
	out := new(QosClassResponseMsg)
	err := grpc.Invoke(ctx, "/qos.QOS/QosClassUpdate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *qOSClient) QosClassDelete(ctx context.Context, in *QosClassDeleteRequestMsg, opts ...grpc.CallOption) (*QosClassDeleteResponseMsg, error) {
	out := new(QosClassDeleteResponseMsg)
	err := grpc.Invoke(ctx, "/qos.QOS/QosClassDelete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *qOSClient) QosClassGet(ctx context.Context, in *QosClassGetRequestMsg, opts ...grpc.CallOption) (*QosClassGetResponseMsg, error) {
	out := new(QosClassGetResponseMsg)
	err := grpc.Invoke(ctx, "/qos.QOS/QosClassGet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *qOSClient) QosClassThresholdsGet(ctx context.Context, in *QosClassThresholdsGetRequestMsg, opts ...grpc.CallOption) (*QosClassThresholdsGetResponseMsg, error) {
	out := new(QosClassThresholdsGetResponseMsg)
	err := grpc.Invoke(ctx, "/qos.QOS/QosClassThresholdsGet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *qOSClient) QosClassSetGlobalPauseType(ctx context.Context, in *QosClassSetGlobalPauseTypeRequestMsg, opts ...grpc.CallOption) (*QosClassSetGlobalPauseTypeResponseMsg, error) {
	out := new(QosClassSetGlobalPauseTypeResponseMsg)
	err := grpc.Invoke(ctx, "/qos.QOS/QosClassSetGlobalPauseType", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *qOSClient) QosClearStats(ctx context.Context, in *QosClearStatsRequestMsg, opts ...grpc.CallOption) (*QosClearStatsResponseMsg, error) {
	out := new(QosClearStatsResponseMsg)
	err := grpc.Invoke(ctx, "/qos.QOS/QosClearStats", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *qOSClient) QosReset(ctx context.Context, in *QosResetRequestMsg, opts ...grpc.CallOption) (*QosResetResponseMsg, error) {
	out := new(QosResetResponseMsg)
	err := grpc.Invoke(ctx, "/qos.QOS/QosReset", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *qOSClient) CoppUpdate(ctx context.Context, in *CoppRequestMsg, opts ...grpc.CallOption) (*CoppResponseMsg, error) {
	out := new(CoppResponseMsg)
	err := grpc.Invoke(ctx, "/qos.QOS/CoppUpdate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *qOSClient) CoppGet(ctx context.Context, in *CoppGetRequestMsg, opts ...grpc.CallOption) (*CoppGetResponseMsg, error) {
	out := new(CoppGetResponseMsg)
	err := grpc.Invoke(ctx, "/qos.QOS/CoppGet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for QOS service

type QOSServer interface {
	// QOS class related APIs
	QosClassCreate(context.Context, *QosClassRequestMsg) (*QosClassResponseMsg, error)
	QosClassUpdate(context.Context, *QosClassRequestMsg) (*QosClassResponseMsg, error)
	QosClassDelete(context.Context, *QosClassDeleteRequestMsg) (*QosClassDeleteResponseMsg, error)
	QosClassGet(context.Context, *QosClassGetRequestMsg) (*QosClassGetResponseMsg, error)
	QosClassThresholdsGet(context.Context, *QosClassThresholdsGetRequestMsg) (*QosClassThresholdsGetResponseMsg, error)
	QosClassSetGlobalPauseType(context.Context, *QosClassSetGlobalPauseTypeRequestMsg) (*QosClassSetGlobalPauseTypeResponseMsg, error)
	QosClearStats(context.Context, *QosClearStatsRequestMsg) (*QosClearStatsResponseMsg, error)
	QosReset(context.Context, *QosResetRequestMsg) (*QosResetResponseMsg, error)
	// Copp related APIs
	CoppUpdate(context.Context, *CoppRequestMsg) (*CoppResponseMsg, error)
	CoppGet(context.Context, *CoppGetRequestMsg) (*CoppGetResponseMsg, error)
}

func RegisterQOSServer(s *grpc.Server, srv QOSServer) {
	s.RegisterService(&_QOS_serviceDesc, srv)
}

func _QOS_QosClassCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QosClassRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QOSServer).QosClassCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/qos.QOS/QosClassCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QOSServer).QosClassCreate(ctx, req.(*QosClassRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _QOS_QosClassUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QosClassRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QOSServer).QosClassUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/qos.QOS/QosClassUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QOSServer).QosClassUpdate(ctx, req.(*QosClassRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _QOS_QosClassDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QosClassDeleteRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QOSServer).QosClassDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/qos.QOS/QosClassDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QOSServer).QosClassDelete(ctx, req.(*QosClassDeleteRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _QOS_QosClassGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QosClassGetRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QOSServer).QosClassGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/qos.QOS/QosClassGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QOSServer).QosClassGet(ctx, req.(*QosClassGetRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _QOS_QosClassThresholdsGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QosClassThresholdsGetRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QOSServer).QosClassThresholdsGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/qos.QOS/QosClassThresholdsGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QOSServer).QosClassThresholdsGet(ctx, req.(*QosClassThresholdsGetRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _QOS_QosClassSetGlobalPauseType_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QosClassSetGlobalPauseTypeRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QOSServer).QosClassSetGlobalPauseType(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/qos.QOS/QosClassSetGlobalPauseType",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QOSServer).QosClassSetGlobalPauseType(ctx, req.(*QosClassSetGlobalPauseTypeRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _QOS_QosClearStats_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QosClearStatsRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QOSServer).QosClearStats(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/qos.QOS/QosClearStats",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QOSServer).QosClearStats(ctx, req.(*QosClearStatsRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _QOS_QosReset_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QosResetRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QOSServer).QosReset(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/qos.QOS/QosReset",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QOSServer).QosReset(ctx, req.(*QosResetRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _QOS_CoppUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CoppRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QOSServer).CoppUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/qos.QOS/CoppUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QOSServer).CoppUpdate(ctx, req.(*CoppRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _QOS_CoppGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CoppGetRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QOSServer).CoppGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/qos.QOS/CoppGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QOSServer).CoppGet(ctx, req.(*CoppGetRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

var _QOS_serviceDesc = grpc.ServiceDesc{
	ServiceName: "qos.QOS",
	HandlerType: (*QOSServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "QosClassCreate",
			Handler:    _QOS_QosClassCreate_Handler,
		},
		{
			MethodName: "QosClassUpdate",
			Handler:    _QOS_QosClassUpdate_Handler,
		},
		{
			MethodName: "QosClassDelete",
			Handler:    _QOS_QosClassDelete_Handler,
		},
		{
			MethodName: "QosClassGet",
			Handler:    _QOS_QosClassGet_Handler,
		},
		{
			MethodName: "QosClassThresholdsGet",
			Handler:    _QOS_QosClassThresholdsGet_Handler,
		},
		{
			MethodName: "QosClassSetGlobalPauseType",
			Handler:    _QOS_QosClassSetGlobalPauseType_Handler,
		},
		{
			MethodName: "QosClearStats",
			Handler:    _QOS_QosClearStats_Handler,
		},
		{
			MethodName: "QosReset",
			Handler:    _QOS_QosReset_Handler,
		},
		{
			MethodName: "CoppUpdate",
			Handler:    _QOS_CoppUpdate_Handler,
		},
		{
			MethodName: "CoppGet",
			Handler:    _QOS_CoppGet_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "qos.proto",
}

func (m *PolicerPPSSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PolicerPPSSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PacketsPerSec != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.PacketsPerSec))
	}
	if m.BurstPackets != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.BurstPackets))
	}
	return i, nil
}

func (m *PolicerBPSSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PolicerBPSSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.BytesPerSec != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.BytesPerSec))
	}
	if m.BurstBytes != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.BurstBytes))
	}
	return i, nil
}

func (m *PolicerSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PolicerSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PolicerType != nil {
		nn1, err := m.PolicerType.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn1
	}
	return i, nil
}

func (m *PolicerSpec_PpsPolicer) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.PpsPolicer != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.PpsPolicer.Size()))
		n2, err := m.PpsPolicer.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}
func (m *PolicerSpec_BpsPolicer) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.BpsPolicer != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.BpsPolicer.Size()))
		n3, err := m.BpsPolicer.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}
func (m *PolicerStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PolicerStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PermittedPackets != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.PermittedPackets))
	}
	if m.PermittedBytes != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.PermittedBytes))
	}
	if m.DroppedPackets != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.DroppedPackets))
	}
	if m.DroppedBytes != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.DroppedBytes))
	}
	return i, nil
}

func (m *QosPause) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosPause) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XonThreshold != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.XonThreshold))
	}
	if m.XoffThreshold != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.XoffThreshold))
	}
	if m.Type != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.Type))
	}
	if m.PfcCos != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.PfcCos))
	}
	return i, nil
}

func (m *QosSched) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosSched) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SchedType != nil {
		nn4, err := m.SchedType.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn4
	}
	return i, nil
}

func (m *QosSched_Dwrr) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Dwrr != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.Dwrr.Size()))
		n5, err := m.Dwrr.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	return i, nil
}
func (m *QosSched_Strict) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Strict != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.Strict.Size()))
		n6, err := m.Strict.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}
func (m *QosSched_DWRRInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosSched_DWRRInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.BwPercentage != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.BwPercentage))
	}
	return i, nil
}

func (m *QosSched_StrictPriorityInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosSched_StrictPriorityInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Bps != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.Bps))
	}
	return i, nil
}

func (m *QosClassMap) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosClassMap) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.Type))
	}
	if m.Dot1QPcp != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.Dot1QPcp))
	}
	if len(m.IpDscp) > 0 {
		dAtA8 := make([]byte, len(m.IpDscp)*10)
		var j7 int
		for _, num := range m.IpDscp {
			for num >= 1<<7 {
				dAtA8[j7] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j7++
			}
			dAtA8[j7] = uint8(num)
			j7++
		}
		dAtA[i] = 0x1a
		i++
		i = encodeVarintQos(dAtA, i, uint64(j7))
		i += copy(dAtA[i:], dAtA8[:j7])
	}
	return i, nil
}

func (m *QosMarking) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosMarking) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Dot1QPcpRewriteEn {
		dAtA[i] = 0x8
		i++
		if m.Dot1QPcpRewriteEn {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Dot1QPcp != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.Dot1QPcp))
	}
	if m.IpDscpRewriteEn {
		dAtA[i] = 0x18
		i++
		if m.IpDscpRewriteEn {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IpDscp != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.IpDscp))
	}
	return i, nil
}

func (m *QosClassSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosClassSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.KeyOrHandle != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n9, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.Mtu != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.Mtu))
	}
	if m.Pause != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.Pause.Size()))
		n10, err := m.Pause.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.Sched != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.Sched.Size()))
		n11, err := m.Sched.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if m.ClassMap != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.ClassMap.Size()))
		n12, err := m.ClassMap.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if m.Marking != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.Marking.Size()))
		n13, err := m.Marking.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if m.NoDrop {
		dAtA[i] = 0x38
		i++
		if m.NoDrop {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *QosClassRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosClassRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintQos(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *PacketBufferPort) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PacketBufferPort) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PortType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.PortType))
	}
	if m.PortNum != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.PortNum))
	}
	return i, nil
}

func (m *QosClassPortStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosClassPortStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PacketBufferPort != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.PacketBufferPort.Size()))
		n14, err := m.PacketBufferPort.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	if len(m.InputQueues) > 0 {
		dAtA16 := make([]byte, len(m.InputQueues)*10)
		var j15 int
		for _, num := range m.InputQueues {
			for num >= 1<<7 {
				dAtA16[j15] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j15++
			}
			dAtA16[j15] = uint8(num)
			j15++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintQos(dAtA, i, uint64(j15))
		i += copy(dAtA[i:], dAtA16[:j15])
	}
	if len(m.OutputQueues) > 0 {
		dAtA18 := make([]byte, len(m.OutputQueues)*10)
		var j17 int
		for _, num := range m.OutputQueues {
			for num >= 1<<7 {
				dAtA18[j17] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j17++
			}
			dAtA18[j17] = uint8(num)
			j17++
		}
		dAtA[i] = 0x1a
		i++
		i = encodeVarintQos(dAtA, i, uint64(j17))
		i += copy(dAtA[i:], dAtA18[:j17])
	}
	return i, nil
}

func (m *QosClassStatusEpd) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosClassStatusEpd) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PortStatus) > 0 {
		for _, msg := range m.PortStatus {
			dAtA[i] = 0xa
			i++
			i = encodeVarintQos(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.TxTrafficClassCoses) > 0 {
		dAtA20 := make([]byte, len(m.TxTrafficClassCoses)*10)
		var j19 int
		for _, num := range m.TxTrafficClassCoses {
			for num >= 1<<7 {
				dAtA20[j19] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j19++
			}
			dAtA20[j19] = uint8(num)
			j19++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintQos(dAtA, i, uint64(j19))
		i += copy(dAtA[i:], dAtA20[:j19])
	}
	return i, nil
}

func (m *QosClassStatusCpd) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosClassStatusCpd) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *QosClassStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosClassStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.QosClassHandle != 0 {
		dAtA[i] = 0x9
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.QosClassHandle))
		i += 8
	}
	if m.QosClassPdStatus != nil {
		nn21, err := m.QosClassPdStatus.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn21
	}
	return i, nil
}

func (m *QosClassStatus_EpdStatus) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.EpdStatus != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.EpdStatus.Size()))
		n22, err := m.EpdStatus.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	return i, nil
}
func (m *QosClassStatus_CpdStatus) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.CpdStatus != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.CpdStatus.Size()))
		n23, err := m.CpdStatus.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	return i, nil
}
func (m *QosClassResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosClassResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.ApiStatus))
	}
	if m.Status != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.Status.Size()))
		n24, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	return i, nil
}

func (m *QosClassResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosClassResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintQos(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *QosClassDeleteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosClassDeleteRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.KeyOrHandle != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n25, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	if m.ClearStats {
		dAtA[i] = 0x10
		i++
		if m.ClearStats {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *QosClassDeleteRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosClassDeleteRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintQos(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *QosClassDeleteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosClassDeleteResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.ApiStatus))
	}
	return i, nil
}

func (m *QosClassDeleteResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosClassDeleteResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintQos(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *QosClearStatsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosClearStatsRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PortNum != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.PortNum))
	}
	if m.QosGroupBitmap != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.QosGroupBitmap))
	}
	return i, nil
}

func (m *QosClearStatsRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosClearStatsRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintQos(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *QosClearStatsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosClearStatsResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.ApiStatus))
	}
	return i, nil
}

func (m *QosClearStatsResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosClearStatsResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintQos(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *QosClassInputOflowQueueStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosClassInputOflowQueueStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.GoodPktsIn != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.GoodPktsIn))
	}
	if m.GoodPktsOut != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.GoodPktsOut))
	}
	if m.ErroredPktsIn != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.ErroredPktsIn))
	}
	if m.FifoDepth != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.FifoDepth))
	}
	if m.MaxFifoDepth != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.MaxFifoDepth))
	}
	return i, nil
}

func (m *QosClassInputQueueStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosClassInputQueueStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.InputQueueIdx != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.InputQueueIdx))
	}
	if m.OflowFifoStats != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.OflowFifoStats.Size()))
		n26, err := m.OflowFifoStats.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n26
	}
	if m.BufferOccupancy != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.BufferOccupancy))
	}
	if m.PeakOccupancy != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.PeakOccupancy))
	}
	if m.PortMonitor != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.PortMonitor))
	}
	if m.QosGroupIdx != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.QosGroupIdx))
	}
	return i, nil
}

func (m *QosClassOutputQueueStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosClassOutputQueueStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.OutputQueueIdx != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.OutputQueueIdx))
	}
	if m.QueueDepth != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.QueueDepth))
	}
	if m.PortMonitor != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.PortMonitor))
	}
	if m.QosGroupIdx != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.QosGroupIdx))
	}
	return i, nil
}

func (m *QosClassQueueStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosClassQueueStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.InputQueueStats) > 0 {
		for _, msg := range m.InputQueueStats {
			dAtA[i] = 0xa
			i++
			i = encodeVarintQos(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.OutputQueueStats) > 0 {
		for _, msg := range m.OutputQueueStats {
			dAtA[i] = 0x12
			i++
			i = encodeVarintQos(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *QosClassPortStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosClassPortStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PacketBufferPort != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.PacketBufferPort.Size()))
		n27, err := m.PacketBufferPort.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n27
	}
	if m.QosQueueStats != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.QosQueueStats.Size()))
		n28, err := m.QosQueueStats.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n28
	}
	return i, nil
}

func (m *QosClassStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosClassStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.NumLifsTx != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.NumLifsTx))
	}
	if m.NumLifsRx != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.NumLifsRx))
	}
	if len(m.PortStats) > 0 {
		for _, msg := range m.PortStats {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintQos(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *QosClassGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosClassGetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.KeyOrHandle != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n29, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n29
	}
	return i, nil
}

func (m *QosClassGetRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosClassGetRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintQos(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *QosClassGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosClassGetResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.ApiStatus))
	}
	if m.Spec != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.Spec.Size()))
		n30, err := m.Spec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n30
	}
	if m.Status != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.Status.Size()))
		n31, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n31
	}
	if m.Stats != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.Stats.Size()))
		n32, err := m.Stats.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n32
	}
	return i, nil
}

func (m *OccupancyPerQueue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OccupancyPerQueue) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.QueueIdx != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.QueueIdx))
	}
	if m.Occupancy != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.Occupancy))
	}
	return i, nil
}

func (m *PortOccupancy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PortOccupancy) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PortNum != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.PortNum))
	}
	if len(m.Occupancy) > 0 {
		for _, msg := range m.Occupancy {
			dAtA[i] = 0x12
			i++
			i = encodeVarintQos(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Thresholds) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Thresholds) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.HbmContext != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.HbmContext))
	}
	if m.XonThreshold != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.XonThreshold))
	}
	if m.XoffThreshold != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.XoffThreshold))
	}
	return i, nil
}

func (m *QosClassThresholdsGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosClassThresholdsGetResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.ApiStatus))
	}
	if len(m.PortOccupancy) > 0 {
		for _, msg := range m.PortOccupancy {
			dAtA[i] = 0x12
			i++
			i = encodeVarintQos(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Thresholds) > 0 {
		for _, msg := range m.Thresholds {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintQos(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *QosClassThresholdsGetResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosClassThresholdsGetResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintQos(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *QosClassThresholdsGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosClassThresholdsGetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *QosClassThresholdsGetRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosClassThresholdsGetRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintQos(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *QosClassGetResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosClassGetResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintQos(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *QosClassSetGlobalPauseTypeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosClassSetGlobalPauseTypeRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PauseType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.PauseType))
	}
	return i, nil
}

func (m *QosClassSetGlobalPauseTypeRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosClassSetGlobalPauseTypeRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintQos(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *QosClassSetGlobalPauseTypeResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosClassSetGlobalPauseTypeResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *QosResetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosResetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Group != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.Group))
	}
	return i, nil
}

func (m *QosResetRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosResetRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintQos(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *QosResetResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosResetResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *CoppSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CoppSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.KeyOrHandle != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n33, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n33
	}
	if m.Policer != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.Policer.Size()))
		n34, err := m.Policer.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n34
	}
	return i, nil
}

func (m *CoppRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CoppRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintQos(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CoppStatusEpd) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CoppStatusEpd) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.HwPolicerIdx != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.HwPolicerIdx))
	}
	return i, nil
}

func (m *CoppStatusCpd) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CoppStatusCpd) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *CoppStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CoppStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CoppHandle != 0 {
		dAtA[i] = 0x9
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.CoppHandle))
		i += 8
	}
	if m.QosClassPdStatus != nil {
		nn35, err := m.QosClassPdStatus.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn35
	}
	return i, nil
}

func (m *CoppStatus_EpdStatus) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.EpdStatus != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.EpdStatus.Size()))
		n36, err := m.EpdStatus.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n36
	}
	return i, nil
}
func (m *CoppStatus_CpdStatus) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.CpdStatus != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.CpdStatus.Size()))
		n37, err := m.CpdStatus.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n37
	}
	return i, nil
}
func (m *CoppResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CoppResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.ApiStatus))
	}
	if m.Status != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.Status.Size()))
		n38, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n38
	}
	return i, nil
}

func (m *CoppResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CoppResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintQos(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CoppDeleteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CoppDeleteRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.KeyOrHandle != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n39, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n39
	}
	return i, nil
}

func (m *CoppDeleteRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CoppDeleteRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintQos(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CoppDeleteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CoppDeleteResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.ApiStatus))
	}
	return i, nil
}

func (m *CoppDeleteResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CoppDeleteResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintQos(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CoppStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CoppStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PolicerStats != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.PolicerStats.Size()))
		n40, err := m.PolicerStats.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n40
	}
	if m.NumAcls != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.NumAcls))
	}
	return i, nil
}

func (m *CoppGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CoppGetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.KeyOrHandle != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n41, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n41
	}
	return i, nil
}

func (m *CoppGetRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CoppGetRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintQos(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CoppGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CoppGetResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.ApiStatus))
	}
	if m.Spec != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.Spec.Size()))
		n42, err := m.Spec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n42
	}
	if m.Status != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.Status.Size()))
		n43, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n43
	}
	if m.Stats != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.Stats.Size()))
		n44, err := m.Stats.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n44
	}
	return i, nil
}

func (m *CoppGetResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CoppGetResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintQos(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func encodeVarintQos(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *PolicerPPSSpec) Size() (n int) {
	var l int
	_ = l
	if m.PacketsPerSec != 0 {
		n += 1 + sovQos(uint64(m.PacketsPerSec))
	}
	if m.BurstPackets != 0 {
		n += 1 + sovQos(uint64(m.BurstPackets))
	}
	return n
}

func (m *PolicerBPSSpec) Size() (n int) {
	var l int
	_ = l
	if m.BytesPerSec != 0 {
		n += 1 + sovQos(uint64(m.BytesPerSec))
	}
	if m.BurstBytes != 0 {
		n += 1 + sovQos(uint64(m.BurstBytes))
	}
	return n
}

func (m *PolicerSpec) Size() (n int) {
	var l int
	_ = l
	if m.PolicerType != nil {
		n += m.PolicerType.Size()
	}
	return n
}

func (m *PolicerSpec_PpsPolicer) Size() (n int) {
	var l int
	_ = l
	if m.PpsPolicer != nil {
		l = m.PpsPolicer.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	return n
}
func (m *PolicerSpec_BpsPolicer) Size() (n int) {
	var l int
	_ = l
	if m.BpsPolicer != nil {
		l = m.BpsPolicer.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	return n
}
func (m *PolicerStats) Size() (n int) {
	var l int
	_ = l
	if m.PermittedPackets != 0 {
		n += 1 + sovQos(uint64(m.PermittedPackets))
	}
	if m.PermittedBytes != 0 {
		n += 1 + sovQos(uint64(m.PermittedBytes))
	}
	if m.DroppedPackets != 0 {
		n += 1 + sovQos(uint64(m.DroppedPackets))
	}
	if m.DroppedBytes != 0 {
		n += 1 + sovQos(uint64(m.DroppedBytes))
	}
	return n
}

func (m *QosPause) Size() (n int) {
	var l int
	_ = l
	if m.XonThreshold != 0 {
		n += 1 + sovQos(uint64(m.XonThreshold))
	}
	if m.XoffThreshold != 0 {
		n += 1 + sovQos(uint64(m.XoffThreshold))
	}
	if m.Type != 0 {
		n += 1 + sovQos(uint64(m.Type))
	}
	if m.PfcCos != 0 {
		n += 1 + sovQos(uint64(m.PfcCos))
	}
	return n
}

func (m *QosSched) Size() (n int) {
	var l int
	_ = l
	if m.SchedType != nil {
		n += m.SchedType.Size()
	}
	return n
}

func (m *QosSched_Dwrr) Size() (n int) {
	var l int
	_ = l
	if m.Dwrr != nil {
		l = m.Dwrr.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	return n
}
func (m *QosSched_Strict) Size() (n int) {
	var l int
	_ = l
	if m.Strict != nil {
		l = m.Strict.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	return n
}
func (m *QosSched_DWRRInfo) Size() (n int) {
	var l int
	_ = l
	if m.BwPercentage != 0 {
		n += 1 + sovQos(uint64(m.BwPercentage))
	}
	return n
}

func (m *QosSched_StrictPriorityInfo) Size() (n int) {
	var l int
	_ = l
	if m.Bps != 0 {
		n += 1 + sovQos(uint64(m.Bps))
	}
	return n
}

func (m *QosClassMap) Size() (n int) {
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovQos(uint64(m.Type))
	}
	if m.Dot1QPcp != 0 {
		n += 1 + sovQos(uint64(m.Dot1QPcp))
	}
	if len(m.IpDscp) > 0 {
		l = 0
		for _, e := range m.IpDscp {
			l += sovQos(uint64(e))
		}
		n += 1 + sovQos(uint64(l)) + l
	}
	return n
}

func (m *QosMarking) Size() (n int) {
	var l int
	_ = l
	if m.Dot1QPcpRewriteEn {
		n += 2
	}
	if m.Dot1QPcp != 0 {
		n += 1 + sovQos(uint64(m.Dot1QPcp))
	}
	if m.IpDscpRewriteEn {
		n += 2
	}
	if m.IpDscp != 0 {
		n += 1 + sovQos(uint64(m.IpDscp))
	}
	return n
}

func (m *QosClassSpec) Size() (n int) {
	var l int
	_ = l
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	if m.Mtu != 0 {
		n += 1 + sovQos(uint64(m.Mtu))
	}
	if m.Pause != nil {
		l = m.Pause.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	if m.Sched != nil {
		l = m.Sched.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	if m.ClassMap != nil {
		l = m.ClassMap.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	if m.Marking != nil {
		l = m.Marking.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	if m.NoDrop {
		n += 2
	}
	return n
}

func (m *QosClassRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovQos(uint64(l))
		}
	}
	return n
}

func (m *PacketBufferPort) Size() (n int) {
	var l int
	_ = l
	if m.PortType != 0 {
		n += 1 + sovQos(uint64(m.PortType))
	}
	if m.PortNum != 0 {
		n += 1 + sovQos(uint64(m.PortNum))
	}
	return n
}

func (m *QosClassPortStatus) Size() (n int) {
	var l int
	_ = l
	if m.PacketBufferPort != nil {
		l = m.PacketBufferPort.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	if len(m.InputQueues) > 0 {
		l = 0
		for _, e := range m.InputQueues {
			l += sovQos(uint64(e))
		}
		n += 1 + sovQos(uint64(l)) + l
	}
	if len(m.OutputQueues) > 0 {
		l = 0
		for _, e := range m.OutputQueues {
			l += sovQos(uint64(e))
		}
		n += 1 + sovQos(uint64(l)) + l
	}
	return n
}

func (m *QosClassStatusEpd) Size() (n int) {
	var l int
	_ = l
	if len(m.PortStatus) > 0 {
		for _, e := range m.PortStatus {
			l = e.Size()
			n += 1 + l + sovQos(uint64(l))
		}
	}
	if len(m.TxTrafficClassCoses) > 0 {
		l = 0
		for _, e := range m.TxTrafficClassCoses {
			l += sovQos(uint64(e))
		}
		n += 1 + sovQos(uint64(l)) + l
	}
	return n
}

func (m *QosClassStatusCpd) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *QosClassStatus) Size() (n int) {
	var l int
	_ = l
	if m.QosClassHandle != 0 {
		n += 9
	}
	if m.QosClassPdStatus != nil {
		n += m.QosClassPdStatus.Size()
	}
	return n
}

func (m *QosClassStatus_EpdStatus) Size() (n int) {
	var l int
	_ = l
	if m.EpdStatus != nil {
		l = m.EpdStatus.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	return n
}
func (m *QosClassStatus_CpdStatus) Size() (n int) {
	var l int
	_ = l
	if m.CpdStatus != nil {
		l = m.CpdStatus.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	return n
}
func (m *QosClassResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovQos(uint64(m.ApiStatus))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	return n
}

func (m *QosClassResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovQos(uint64(l))
		}
	}
	return n
}

func (m *QosClassDeleteRequest) Size() (n int) {
	var l int
	_ = l
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	if m.ClearStats {
		n += 2
	}
	return n
}

func (m *QosClassDeleteRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovQos(uint64(l))
		}
	}
	return n
}

func (m *QosClassDeleteResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovQos(uint64(m.ApiStatus))
	}
	return n
}

func (m *QosClassDeleteResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovQos(uint64(l))
		}
	}
	return n
}

func (m *QosClearStatsRequest) Size() (n int) {
	var l int
	_ = l
	if m.PortNum != 0 {
		n += 1 + sovQos(uint64(m.PortNum))
	}
	if m.QosGroupBitmap != 0 {
		n += 1 + sovQos(uint64(m.QosGroupBitmap))
	}
	return n
}

func (m *QosClearStatsRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovQos(uint64(l))
		}
	}
	return n
}

func (m *QosClearStatsResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovQos(uint64(m.ApiStatus))
	}
	return n
}

func (m *QosClearStatsResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovQos(uint64(l))
		}
	}
	return n
}

func (m *QosClassInputOflowQueueStats) Size() (n int) {
	var l int
	_ = l
	if m.GoodPktsIn != 0 {
		n += 1 + sovQos(uint64(m.GoodPktsIn))
	}
	if m.GoodPktsOut != 0 {
		n += 1 + sovQos(uint64(m.GoodPktsOut))
	}
	if m.ErroredPktsIn != 0 {
		n += 1 + sovQos(uint64(m.ErroredPktsIn))
	}
	if m.FifoDepth != 0 {
		n += 1 + sovQos(uint64(m.FifoDepth))
	}
	if m.MaxFifoDepth != 0 {
		n += 1 + sovQos(uint64(m.MaxFifoDepth))
	}
	return n
}

func (m *QosClassInputQueueStats) Size() (n int) {
	var l int
	_ = l
	if m.InputQueueIdx != 0 {
		n += 1 + sovQos(uint64(m.InputQueueIdx))
	}
	if m.OflowFifoStats != nil {
		l = m.OflowFifoStats.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	if m.BufferOccupancy != 0 {
		n += 1 + sovQos(uint64(m.BufferOccupancy))
	}
	if m.PeakOccupancy != 0 {
		n += 1 + sovQos(uint64(m.PeakOccupancy))
	}
	if m.PortMonitor != 0 {
		n += 1 + sovQos(uint64(m.PortMonitor))
	}
	if m.QosGroupIdx != 0 {
		n += 1 + sovQos(uint64(m.QosGroupIdx))
	}
	return n
}

func (m *QosClassOutputQueueStats) Size() (n int) {
	var l int
	_ = l
	if m.OutputQueueIdx != 0 {
		n += 1 + sovQos(uint64(m.OutputQueueIdx))
	}
	if m.QueueDepth != 0 {
		n += 1 + sovQos(uint64(m.QueueDepth))
	}
	if m.PortMonitor != 0 {
		n += 1 + sovQos(uint64(m.PortMonitor))
	}
	if m.QosGroupIdx != 0 {
		n += 1 + sovQos(uint64(m.QosGroupIdx))
	}
	return n
}

func (m *QosClassQueueStats) Size() (n int) {
	var l int
	_ = l
	if len(m.InputQueueStats) > 0 {
		for _, e := range m.InputQueueStats {
			l = e.Size()
			n += 1 + l + sovQos(uint64(l))
		}
	}
	if len(m.OutputQueueStats) > 0 {
		for _, e := range m.OutputQueueStats {
			l = e.Size()
			n += 1 + l + sovQos(uint64(l))
		}
	}
	return n
}

func (m *QosClassPortStats) Size() (n int) {
	var l int
	_ = l
	if m.PacketBufferPort != nil {
		l = m.PacketBufferPort.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	if m.QosQueueStats != nil {
		l = m.QosQueueStats.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	return n
}

func (m *QosClassStats) Size() (n int) {
	var l int
	_ = l
	if m.NumLifsTx != 0 {
		n += 1 + sovQos(uint64(m.NumLifsTx))
	}
	if m.NumLifsRx != 0 {
		n += 1 + sovQos(uint64(m.NumLifsRx))
	}
	if len(m.PortStats) > 0 {
		for _, e := range m.PortStats {
			l = e.Size()
			n += 1 + l + sovQos(uint64(l))
		}
	}
	return n
}

func (m *QosClassGetRequest) Size() (n int) {
	var l int
	_ = l
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	return n
}

func (m *QosClassGetRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovQos(uint64(l))
		}
	}
	return n
}

func (m *QosClassGetResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovQos(uint64(m.ApiStatus))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	if m.Stats != nil {
		l = m.Stats.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	return n
}

func (m *OccupancyPerQueue) Size() (n int) {
	var l int
	_ = l
	if m.QueueIdx != 0 {
		n += 1 + sovQos(uint64(m.QueueIdx))
	}
	if m.Occupancy != 0 {
		n += 1 + sovQos(uint64(m.Occupancy))
	}
	return n
}

func (m *PortOccupancy) Size() (n int) {
	var l int
	_ = l
	if m.PortNum != 0 {
		n += 1 + sovQos(uint64(m.PortNum))
	}
	if len(m.Occupancy) > 0 {
		for _, e := range m.Occupancy {
			l = e.Size()
			n += 1 + l + sovQos(uint64(l))
		}
	}
	return n
}

func (m *Thresholds) Size() (n int) {
	var l int
	_ = l
	if m.HbmContext != 0 {
		n += 1 + sovQos(uint64(m.HbmContext))
	}
	if m.XonThreshold != 0 {
		n += 1 + sovQos(uint64(m.XonThreshold))
	}
	if m.XoffThreshold != 0 {
		n += 1 + sovQos(uint64(m.XoffThreshold))
	}
	return n
}

func (m *QosClassThresholdsGetResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovQos(uint64(m.ApiStatus))
	}
	if len(m.PortOccupancy) > 0 {
		for _, e := range m.PortOccupancy {
			l = e.Size()
			n += 1 + l + sovQos(uint64(l))
		}
	}
	if len(m.Thresholds) > 0 {
		for _, e := range m.Thresholds {
			l = e.Size()
			n += 1 + l + sovQos(uint64(l))
		}
	}
	return n
}

func (m *QosClassThresholdsGetResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovQos(uint64(l))
		}
	}
	return n
}

func (m *QosClassThresholdsGetRequest) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *QosClassThresholdsGetRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovQos(uint64(l))
		}
	}
	return n
}

func (m *QosClassGetResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovQos(uint64(l))
		}
	}
	return n
}

func (m *QosClassSetGlobalPauseTypeRequest) Size() (n int) {
	var l int
	_ = l
	if m.PauseType != 0 {
		n += 1 + sovQos(uint64(m.PauseType))
	}
	return n
}

func (m *QosClassSetGlobalPauseTypeRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovQos(uint64(l))
		}
	}
	return n
}

func (m *QosClassSetGlobalPauseTypeResponseMsg) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *QosResetRequest) Size() (n int) {
	var l int
	_ = l
	if m.Group != 0 {
		n += 1 + sovQos(uint64(m.Group))
	}
	return n
}

func (m *QosResetRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovQos(uint64(l))
		}
	}
	return n
}

func (m *QosResetResponseMsg) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *CoppSpec) Size() (n int) {
	var l int
	_ = l
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	if m.Policer != nil {
		l = m.Policer.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	return n
}

func (m *CoppRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovQos(uint64(l))
		}
	}
	return n
}

func (m *CoppStatusEpd) Size() (n int) {
	var l int
	_ = l
	if m.HwPolicerIdx != 0 {
		n += 1 + sovQos(uint64(m.HwPolicerIdx))
	}
	return n
}

func (m *CoppStatusCpd) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *CoppStatus) Size() (n int) {
	var l int
	_ = l
	if m.CoppHandle != 0 {
		n += 9
	}
	if m.QosClassPdStatus != nil {
		n += m.QosClassPdStatus.Size()
	}
	return n
}

func (m *CoppStatus_EpdStatus) Size() (n int) {
	var l int
	_ = l
	if m.EpdStatus != nil {
		l = m.EpdStatus.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	return n
}
func (m *CoppStatus_CpdStatus) Size() (n int) {
	var l int
	_ = l
	if m.CpdStatus != nil {
		l = m.CpdStatus.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	return n
}
func (m *CoppResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovQos(uint64(m.ApiStatus))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	return n
}

func (m *CoppResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovQos(uint64(l))
		}
	}
	return n
}

func (m *CoppDeleteRequest) Size() (n int) {
	var l int
	_ = l
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	return n
}

func (m *CoppDeleteRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovQos(uint64(l))
		}
	}
	return n
}

func (m *CoppDeleteResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovQos(uint64(m.ApiStatus))
	}
	return n
}

func (m *CoppDeleteResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovQos(uint64(l))
		}
	}
	return n
}

func (m *CoppStats) Size() (n int) {
	var l int
	_ = l
	if m.PolicerStats != nil {
		l = m.PolicerStats.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	if m.NumAcls != 0 {
		n += 1 + sovQos(uint64(m.NumAcls))
	}
	return n
}

func (m *CoppGetRequest) Size() (n int) {
	var l int
	_ = l
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	return n
}

func (m *CoppGetRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovQos(uint64(l))
		}
	}
	return n
}

func (m *CoppGetResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovQos(uint64(m.ApiStatus))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	if m.Stats != nil {
		l = m.Stats.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	return n
}

func (m *CoppGetResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovQos(uint64(l))
		}
	}
	return n
}

func sovQos(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozQos(x uint64) (n int) {
	return sovQos(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *PolicerPPSSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PolicerPPSSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PolicerPPSSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PacketsPerSec", wireType)
			}
			m.PacketsPerSec = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PacketsPerSec |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BurstPackets", wireType)
			}
			m.BurstPackets = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BurstPackets |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PolicerBPSSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PolicerBPSSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PolicerBPSSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BytesPerSec", wireType)
			}
			m.BytesPerSec = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BytesPerSec |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BurstBytes", wireType)
			}
			m.BurstBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BurstBytes |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PolicerSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PolicerSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PolicerSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PpsPolicer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PolicerPPSSpec{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PolicerType = &PolicerSpec_PpsPolicer{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BpsPolicer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PolicerBPSSpec{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PolicerType = &PolicerSpec_BpsPolicer{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PolicerStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PolicerStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PolicerStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PermittedPackets", wireType)
			}
			m.PermittedPackets = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PermittedPackets |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PermittedBytes", wireType)
			}
			m.PermittedBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PermittedBytes |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DroppedPackets", wireType)
			}
			m.DroppedPackets = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DroppedPackets |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DroppedBytes", wireType)
			}
			m.DroppedBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DroppedBytes |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosPause) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QosPause: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QosPause: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field XonThreshold", wireType)
			}
			m.XonThreshold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.XonThreshold |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field XoffThreshold", wireType)
			}
			m.XoffThreshold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.XoffThreshold |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (QosPauseType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PfcCos", wireType)
			}
			m.PfcCos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PfcCos |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosSched) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QosSched: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QosSched: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dwrr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &QosSched_DWRRInfo{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.SchedType = &QosSched_Dwrr{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Strict", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &QosSched_StrictPriorityInfo{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.SchedType = &QosSched_Strict{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosSched_DWRRInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DWRRInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DWRRInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BwPercentage", wireType)
			}
			m.BwPercentage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BwPercentage |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosSched_StrictPriorityInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StrictPriorityInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StrictPriorityInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bps", wireType)
			}
			m.Bps = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Bps |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosClassMap) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QosClassMap: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QosClassMap: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (QosClassMapType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dot1QPcp", wireType)
			}
			m.Dot1QPcp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Dot1QPcp |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowQos
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.IpDscp = append(m.IpDscp, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowQos
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthQos
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowQos
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.IpDscp = append(m.IpDscp, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field IpDscp", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosMarking) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QosMarking: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QosMarking: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dot1QPcpRewriteEn", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Dot1QPcpRewriteEn = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dot1QPcp", wireType)
			}
			m.Dot1QPcp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Dot1QPcp |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpDscpRewriteEn", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IpDscpRewriteEn = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpDscp", wireType)
			}
			m.IpDscp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IpDscp |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosClassSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QosClassSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QosClassSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &QosClassKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mtu", wireType)
			}
			m.Mtu = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mtu |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pause", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pause == nil {
				m.Pause = &QosPause{}
			}
			if err := m.Pause.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sched", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Sched == nil {
				m.Sched = &QosSched{}
			}
			if err := m.Sched.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClassMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ClassMap == nil {
				m.ClassMap = &QosClassMap{}
			}
			if err := m.ClassMap.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Marking", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Marking == nil {
				m.Marking = &QosMarking{}
			}
			if err := m.Marking.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoDrop", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NoDrop = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosClassRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QosClassRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QosClassRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &QosClassSpec{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PacketBufferPort) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PacketBufferPort: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PacketBufferPort: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortType", wireType)
			}
			m.PortType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PortType |= (PacketBufferPortType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortNum", wireType)
			}
			m.PortNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PortNum |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosClassPortStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QosClassPortStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QosClassPortStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PacketBufferPort", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PacketBufferPort == nil {
				m.PacketBufferPort = &PacketBufferPort{}
			}
			if err := m.PacketBufferPort.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowQos
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.InputQueues = append(m.InputQueues, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowQos
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthQos
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowQos
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.InputQueues = append(m.InputQueues, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field InputQueues", wireType)
			}
		case 3:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowQos
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.OutputQueues = append(m.OutputQueues, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowQos
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthQos
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowQos
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.OutputQueues = append(m.OutputQueues, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputQueues", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosClassStatusEpd) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QosClassStatusEpd: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QosClassStatusEpd: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PortStatus = append(m.PortStatus, &QosClassPortStatus{})
			if err := m.PortStatus[len(m.PortStatus)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowQos
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.TxTrafficClassCoses = append(m.TxTrafficClassCoses, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowQos
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthQos
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowQos
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.TxTrafficClassCoses = append(m.TxTrafficClassCoses, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field TxTrafficClassCoses", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosClassStatusCpd) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QosClassStatusCpd: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QosClassStatusCpd: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosClassStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QosClassStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QosClassStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field QosClassHandle", wireType)
			}
			m.QosClassHandle = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.QosClassHandle = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EpdStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &QosClassStatusEpd{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.QosClassPdStatus = &QosClassStatus_EpdStatus{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpdStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &QosClassStatusCpd{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.QosClassPdStatus = &QosClassStatus_CpdStatus{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosClassResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QosClassResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QosClassResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &QosClassStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosClassResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QosClassResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QosClassResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &QosClassResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosClassDeleteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QosClassDeleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QosClassDeleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &QosClassKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClearStats", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ClearStats = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosClassDeleteRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QosClassDeleteRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QosClassDeleteRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &QosClassDeleteRequest{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosClassDeleteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QosClassDeleteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QosClassDeleteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosClassDeleteResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QosClassDeleteResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QosClassDeleteResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &QosClassDeleteResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosClearStatsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QosClearStatsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QosClearStatsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortNum", wireType)
			}
			m.PortNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PortNum |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field QosGroupBitmap", wireType)
			}
			m.QosGroupBitmap = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.QosGroupBitmap |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosClearStatsRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QosClearStatsRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QosClearStatsRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &QosClearStatsRequest{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosClearStatsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QosClearStatsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QosClearStatsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosClearStatsResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QosClearStatsResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QosClearStatsResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &QosClearStatsResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosClassInputOflowQueueStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QosClassInputOflowQueueStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QosClassInputOflowQueueStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GoodPktsIn", wireType)
			}
			m.GoodPktsIn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GoodPktsIn |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GoodPktsOut", wireType)
			}
			m.GoodPktsOut = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GoodPktsOut |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErroredPktsIn", wireType)
			}
			m.ErroredPktsIn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErroredPktsIn |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FifoDepth", wireType)
			}
			m.FifoDepth = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FifoDepth |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxFifoDepth", wireType)
			}
			m.MaxFifoDepth = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxFifoDepth |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosClassInputQueueStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QosClassInputQueueStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QosClassInputQueueStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputQueueIdx", wireType)
			}
			m.InputQueueIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InputQueueIdx |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OflowFifoStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OflowFifoStats == nil {
				m.OflowFifoStats = &QosClassInputOflowQueueStats{}
			}
			if err := m.OflowFifoStats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BufferOccupancy", wireType)
			}
			m.BufferOccupancy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BufferOccupancy |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeakOccupancy", wireType)
			}
			m.PeakOccupancy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PeakOccupancy |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortMonitor", wireType)
			}
			m.PortMonitor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PortMonitor |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field QosGroupIdx", wireType)
			}
			m.QosGroupIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.QosGroupIdx |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosClassOutputQueueStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QosClassOutputQueueStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QosClassOutputQueueStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputQueueIdx", wireType)
			}
			m.OutputQueueIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OutputQueueIdx |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueueDepth", wireType)
			}
			m.QueueDepth = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.QueueDepth |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortMonitor", wireType)
			}
			m.PortMonitor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PortMonitor |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field QosGroupIdx", wireType)
			}
			m.QosGroupIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.QosGroupIdx |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosClassQueueStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QosClassQueueStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QosClassQueueStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputQueueStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InputQueueStats = append(m.InputQueueStats, &QosClassInputQueueStats{})
			if err := m.InputQueueStats[len(m.InputQueueStats)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputQueueStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OutputQueueStats = append(m.OutputQueueStats, &QosClassOutputQueueStats{})
			if err := m.OutputQueueStats[len(m.OutputQueueStats)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosClassPortStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QosClassPortStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QosClassPortStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PacketBufferPort", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PacketBufferPort == nil {
				m.PacketBufferPort = &PacketBufferPort{}
			}
			if err := m.PacketBufferPort.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QosQueueStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.QosQueueStats == nil {
				m.QosQueueStats = &QosClassQueueStats{}
			}
			if err := m.QosQueueStats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosClassStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QosClassStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QosClassStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumLifsTx", wireType)
			}
			m.NumLifsTx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumLifsTx |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumLifsRx", wireType)
			}
			m.NumLifsRx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumLifsRx |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PortStats = append(m.PortStats, &QosClassPortStats{})
			if err := m.PortStats[len(m.PortStats)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosClassGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QosClassGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QosClassGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &QosClassKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosClassGetRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QosClassGetRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QosClassGetRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &QosClassGetRequest{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosClassGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QosClassGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QosClassGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &QosClassSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &QosClassStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = &QosClassStats{}
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OccupancyPerQueue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OccupancyPerQueue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OccupancyPerQueue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueueIdx", wireType)
			}
			m.QueueIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.QueueIdx |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Occupancy", wireType)
			}
			m.Occupancy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Occupancy |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PortOccupancy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PortOccupancy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PortOccupancy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortNum", wireType)
			}
			m.PortNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PortNum |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Occupancy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Occupancy = append(m.Occupancy, &OccupancyPerQueue{})
			if err := m.Occupancy[len(m.Occupancy)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Thresholds) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Thresholds: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Thresholds: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HbmContext", wireType)
			}
			m.HbmContext = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HbmContext |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field XonThreshold", wireType)
			}
			m.XonThreshold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.XonThreshold |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field XoffThreshold", wireType)
			}
			m.XoffThreshold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.XoffThreshold |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosClassThresholdsGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QosClassThresholdsGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QosClassThresholdsGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortOccupancy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PortOccupancy = append(m.PortOccupancy, &PortOccupancy{})
			if err := m.PortOccupancy[len(m.PortOccupancy)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Thresholds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Thresholds = append(m.Thresholds, &Thresholds{})
			if err := m.Thresholds[len(m.Thresholds)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosClassThresholdsGetResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QosClassThresholdsGetResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QosClassThresholdsGetResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &QosClassThresholdsGetResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosClassThresholdsGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QosClassThresholdsGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QosClassThresholdsGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosClassThresholdsGetRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QosClassThresholdsGetRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QosClassThresholdsGetRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &QosClassThresholdsGetRequest{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosClassGetResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QosClassGetResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QosClassGetResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &QosClassGetResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosClassSetGlobalPauseTypeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QosClassSetGlobalPauseTypeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QosClassSetGlobalPauseTypeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PauseType", wireType)
			}
			m.PauseType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PauseType |= (QosPauseType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosClassSetGlobalPauseTypeRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QosClassSetGlobalPauseTypeRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QosClassSetGlobalPauseTypeRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &QosClassSetGlobalPauseTypeRequest{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosClassSetGlobalPauseTypeResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QosClassSetGlobalPauseTypeResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QosClassSetGlobalPauseTypeResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosResetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QosResetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QosResetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Group", wireType)
			}
			m.Group = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Group |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosResetRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QosResetRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QosResetRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &QosResetRequest{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosResetResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QosResetResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QosResetResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CoppSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CoppSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CoppSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &CoppKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Policer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Policer == nil {
				m.Policer = &PolicerSpec{}
			}
			if err := m.Policer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CoppRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CoppRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CoppRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &CoppSpec{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CoppStatusEpd) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CoppStatusEpd: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CoppStatusEpd: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HwPolicerIdx", wireType)
			}
			m.HwPolicerIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HwPolicerIdx |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CoppStatusCpd) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CoppStatusCpd: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CoppStatusCpd: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CoppStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CoppStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CoppStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CoppHandle", wireType)
			}
			m.CoppHandle = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.CoppHandle = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EpdStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CoppStatusEpd{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.QosClassPdStatus = &CoppStatus_EpdStatus{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpdStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CoppStatusCpd{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.QosClassPdStatus = &CoppStatus_CpdStatus{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CoppResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CoppResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CoppResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &CoppStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CoppResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CoppResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CoppResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &CoppResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CoppDeleteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CoppDeleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CoppDeleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &CoppKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CoppDeleteRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CoppDeleteRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CoppDeleteRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &CoppDeleteRequest{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CoppDeleteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CoppDeleteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CoppDeleteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CoppDeleteResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CoppDeleteResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CoppDeleteResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &CoppDeleteResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CoppStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CoppStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CoppStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PolicerStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PolicerStats == nil {
				m.PolicerStats = &PolicerStats{}
			}
			if err := m.PolicerStats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumAcls", wireType)
			}
			m.NumAcls = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumAcls |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CoppGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CoppGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CoppGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &CoppKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CoppGetRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CoppGetRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CoppGetRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &CoppGetRequest{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CoppGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CoppGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CoppGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &CoppSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &CoppStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = &CoppStats{}
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CoppGetResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CoppGetResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CoppGetResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &CoppGetResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipQos(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowQos
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowQos
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowQos
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthQos
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowQos
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipQos(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthQos = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowQos   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("qos.proto", fileDescriptorQos) }

var fileDescriptorQos = []byte{
	// 2891 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x3a, 0x4b, 0x50, 0x1b, 0xd9,
	0xb5, 0x34, 0xc2, 0x80, 0x8e, 0x90, 0x10, 0x17, 0x0c, 0x18, 0xdb, 0x08, 0xf7, 0xf8, 0xc3, 0xd8,
	0x63, 0x0f, 0xc6, 0xbf, 0xb1, 0xe7, 0xe3, 0x41, 0x02, 0x1b, 0x9e, 0x6d, 0x10, 0x0d, 0x7e, 0x53,
	0x6f, 0xde, 0xab, 0xe9, 0x69, 0x5a, 0x57, 0x48, 0x85, 0xd4, 0x7d, 0xe9, 0x6e, 0x3d, 0x44, 0xa5,
	0x5c, 0x49, 0x25, 0x55, 0x49, 0x36, 0x59, 0x65, 0x35, 0xab, 0x54, 0x56, 0x59, 0x24, 0x95, 0x45,
	0x16, 0x59, 0x64, 0x9b, 0x4d, 0xaa, 0xb2, 0x49, 0x2a, 0x9b, 0x54, 0x25, 0x45, 0xa5, 0x66, 0x97,
	0x2d, 0xbb, 0xec, 0x52, 0xf7, 0xd7, 0xb7, 0xbb, 0x25, 0x61, 0x7b, 0xc2, 0x78, 0x63, 0xe9, 0xdc,
	0x73, 0xce, 0x3d, 0xff, 0x73, 0xee, 0x11, 0x90, 0xde, 0x77, 0xfd, 0x5b, 0xc4, 0x73, 0x03, 0x17,
	0xa5, 0xf6, 0x5d, 0x7f, 0x26, 0x13, 0x1c, 0x12, 0x2c, 0x20, 0x33, 0xc3, 0x7b, 0x35, 0xfe, 0x49,
	0xff, 0xbb, 0x06, 0xb9, 0xb2, 0xdb, 0xa8, 0xdb, 0xd8, 0x2b, 0x97, 0xb7, 0xb6, 0x08, 0xb6, 0xd1,
	0x2e, 0x8c, 0x12, 0xcb, 0xde, 0xc3, 0x81, 0x6f, 0x12, 0xec, 0x99, 0x3e, 0xb6, 0xa7, 0xb5, 0x39,
	0x6d, 0x3e, 0x5b, 0x7c, 0x7c, 0x7c, 0x54, 0xf8, 0xf0, 0xff, 0xb1, 0x53, 0xb7, 0xf1, 0xa3, 0xa6,
	0xe5, 0x54, 0xac, 0xc0, 0xf5, 0x0e, 0xdf, 0x13, 0x00, 0xdb, 0x75, 0xfc, 0xc0, 0xb3, 0xea, 0x4e,
	0xe0, 0x7f, 0xfc, 0x1d, 0xcf, 0x72, 0x76, 0xf1, 0xa3, 0xbb, 0x0b, 0x0b, 0x0b, 0x37, 0x17, 0x17,
	0xe4, 0xbf, 0x57, 0x46, 0x56, 0xf0, 0x2d, 0x63, 0x6f, 0x0b, 0xdb, 0xc8, 0x82, 0xec, 0x4e, 0xcb,
	0xf3, 0x03, 0x53, 0x80, 0xa7, 0xfb, 0xd9, 0x35, 0x1f, 0x1d, 0x1f, 0x15, 0x3e, 0x78, 0x8b, 0x6b,
	0xe2, 0x77, 0x8c, 0x30, 0x96, 0x65, 0xce, 0x51, 0xff, 0xab, 0x52, 0xaf, 0x28, 0xd4, 0xc3, 0x90,
	0xdd, 0x39, 0x0c, 0x70, 0x5c, 0xb9, 0x81, 0xe2, 0xd2, 0xf1, 0x51, 0xe1, 0xe3, 0xb7, 0x55, 0xee,
	0xf6, 0xe2, 0xbd, 0xc8, 0xd5, 0x19, 0xc6, 0x57, 0x28, 0x67, 0x42, 0x86, 0x2b, 0xc7, 0x80, 0x4c,
	0xb5, 0x81, 0xe2, 0x27, 0xc7, 0x47, 0x85, 0x47, 0x6f, 0xa5, 0x5a, 0xfc, 0x06, 0x60, 0x2c, 0x8b,
	0x94, 0xa3, 0xfe, 0x13, 0x0d, 0x32, 0x42, 0x35, 0xa6, 0xd7, 0x7d, 0xc8, 0x10, 0xe2, 0x9b, 0x84,
	0x83, 0x98, 0x56, 0x99, 0xc5, 0xf1, 0x5b, 0x34, 0x0c, 0xe2, 0x0e, 0x5e, 0xed, 0x33, 0x80, 0x10,
	0x5f, 0x00, 0x29, 0xdd, 0x4e, 0x84, 0xae, 0xbf, 0x93, 0xae, 0xa8, 0xe8, 0x76, 0x42, 0xba, 0x62,
	0x0e, 0x46, 0x04, 0x8d, 0x49, 0x43, 0x4b, 0xff, 0x8d, 0x06, 0x23, 0x52, 0x9e, 0xc0, 0x0a, 0x7c,
	0x74, 0x03, 0xc6, 0x08, 0xf6, 0x9a, 0xf5, 0x20, 0xc0, 0x95, 0xd0, 0xc5, 0xcc, 0xd8, 0x46, 0x3e,
	0x3c, 0x10, 0x8e, 0x42, 0xd7, 0x60, 0x54, 0x21, 0x47, 0x4c, 0x66, 0xe4, 0x42, 0x30, 0x53, 0x9b,
	0x22, 0x56, 0x3c, 0x97, 0x90, 0x08, 0xcf, 0x14, 0x47, 0x14, 0x60, 0xc9, 0xf1, 0x1d, 0xc8, 0x4a,
	0x44, 0xce, 0x6f, 0x80, 0xa1, 0x8d, 0x08, 0x20, 0x37, 0xe2, 0xef, 0x34, 0x18, 0xde, 0x74, 0xfd,
	0xb2, 0xd5, 0xf2, 0x31, 0xa5, 0x68, 0xbb, 0x8e, 0x19, 0xd4, 0x3c, 0xec, 0xd7, 0xdc, 0x46, 0x85,
	0x87, 0xbd, 0x31, 0xd2, 0x76, 0x9d, 0x6d, 0x09, 0x43, 0x57, 0x20, 0xd7, 0x76, 0xab, 0xd5, 0x08,
	0x16, 0x8b, 0x5a, 0x23, 0x4b, 0xa1, 0x51, 0xb4, 0x01, 0x6a, 0x15, 0x26, 0x5b, 0x6e, 0x71, 0x8c,
	0x99, 0x53, 0x5e, 0xb4, 0x7d, 0x48, 0xb0, 0xc1, 0x8e, 0xd1, 0x87, 0x30, 0x44, 0xaa, 0xb6, 0x69,
	0xbb, 0x5c, 0xbc, 0x6c, 0x51, 0x3f, 0x3e, 0x2a, 0xcc, 0x9e, 0x14, 0x10, 0x0f, 0x5e, 0x19, 0x83,
	0xa4, 0x6a, 0x97, 0x5c, 0x5f, 0xff, 0x5e, 0x3f, 0x13, 0x7e, 0xcb, 0xae, 0xe1, 0x0a, 0x7a, 0x0f,
	0x06, 0x2a, 0x07, 0x9e, 0xf4, 0xfb, 0xa4, 0xbc, 0x90, 0x1d, 0xde, 0x5a, 0xfe, 0xcc, 0x30, 0xd6,
	0x9c, 0xaa, 0xbb, 0xda, 0x67, 0x30, 0x2c, 0xf4, 0x08, 0x06, 0xfd, 0xc0, 0xab, 0xdb, 0x81, 0xf0,
	0xf7, 0x5c, 0x1c, 0x7f, 0x8b, 0x9d, 0x95, 0xbd, 0xba, 0xeb, 0xd5, 0x83, 0x43, 0x41, 0x29, 0x28,
	0x66, 0x5e, 0xc2, 0xb0, 0xe4, 0x87, 0xd6, 0x20, 0xbb, 0x73, 0x40, 0x33, 0xc9, 0xc6, 0x4e, 0x60,
	0xed, 0x62, 0x51, 0x29, 0x2e, 0x1f, 0x1f, 0x15, 0xe6, 0x4e, 0x0c, 0x6b, 0x9e, 0xaa, 0x07, 0xe5,
	0x90, 0x72, 0xe6, 0x2a, 0xa0, 0xce, 0x6b, 0x51, 0x1e, 0x52, 0x3b, 0x44, 0x86, 0x0d, 0xfd, 0x58,
	0xcc, 0x40, 0x9a, 0x09, 0x49, 0xad, 0xa8, 0xff, 0x56, 0x83, 0xcc, 0xa6, 0xeb, 0x97, 0x1a, 0x96,
	0xef, 0xbf, 0xb0, 0x08, 0x9a, 0x17, 0x66, 0xd7, 0x98, 0xd9, 0x27, 0xa4, 0x56, 0xf2, 0x3c, 0x62,
	0xf9, 0xc7, 0x90, 0xae, 0xb8, 0xc1, 0xed, 0x7d, 0x93, 0xd8, 0x44, 0x14, 0x9e, 0x37, 0xb1, 0xfd,
	0x30, 0x23, 0x2a, 0xdb, 0x04, 0x7d, 0x04, 0x43, 0x75, 0x62, 0x56, 0x7c, 0x9b, 0x4c, 0xa7, 0xe6,
	0x52, 0xf3, 0xd9, 0xe2, 0x3b, 0xc7, 0x47, 0x85, 0xc2, 0x49, 0xe4, 0xf7, 0xef, 0xbc, 0x32, 0x06,
	0xeb, 0x64, 0xd9, 0xb7, 0x89, 0xfe, 0x4f, 0x0d, 0x60, 0xd3, 0xf5, 0x5f, 0x58, 0xde, 0x5e, 0xdd,
	0xd9, 0x45, 0xef, 0xc3, 0x44, 0x28, 0x8d, 0xe9, 0xe1, 0x03, 0xaf, 0x1e, 0x60, 0x13, 0x3b, 0x4c,
	0x8f, 0x61, 0x63, 0x4c, 0x5e, 0x6a, 0xf0, 0x93, 0x15, 0xe7, 0x3f, 0x17, 0xff, 0x06, 0x20, 0x21,
	0x7e, 0xf4, 0xbe, 0x14, 0xbb, 0x6f, 0x94, 0x0b, 0xa9, 0x6e, 0x8b, 0xe8, 0xca, 0xc3, 0xf4, 0xad,
	0x74, 0xfd, 0x57, 0x3f, 0x8c, 0x48, 0x27, 0xb0, 0x52, 0xb5, 0x06, 0xd9, 0x3d, 0x7c, 0x68, 0xba,
	0x9e, 0x59, 0xb3, 0x9c, 0x4a, 0x03, 0x8b, 0xa0, 0x3d, 0x7b, 0x6b, 0xaf, 0x16, 0x7a, 0xeb, 0x19,
	0x3e, 0x5c, 0x65, 0x87, 0xc5, 0xdc, 0xf1, 0x51, 0x01, 0xc4, 0x5d, 0x7b, 0xf8, 0xd0, 0xc8, 0xec,
	0xe1, 0xc3, 0x0d, 0x8f, 0x1f, 0xa2, 0x67, 0x90, 0x6a, 0x06, 0x2d, 0x61, 0x81, 0x87, 0xc7, 0x47,
	0x85, 0x7b, 0x6f, 0x51, 0x5e, 0x6f, 0xdf, 0x5b, 0x58, 0xb8, 0xf9, 0x70, 0xf1, 0xf6, 0xfd, 0x57,
	0x06, 0xe5, 0x82, 0xde, 0x81, 0x33, 0x84, 0x26, 0x28, 0x33, 0x43, 0x66, 0x31, 0x1b, 0xcb, 0x5a,
	0x83, 0x9f, 0xa1, 0x87, 0x70, 0xc6, 0xa7, 0xf1, 0xc7, 0x2c, 0x11, 0x41, 0x62, 0x41, 0x59, 0x9c,
	0x38, 0x3e, 0x2a, 0xe4, 0x93, 0x22, 0x18, 0x9c, 0x02, 0xdd, 0x84, 0xb4, 0x4d, 0x75, 0x33, 0x9b,
	0x16, 0x99, 0x3e, 0xc3, 0xc8, 0xf3, 0xc9, 0x10, 0x35, 0x86, 0x6d, 0x19, 0xcc, 0xef, 0xc2, 0x50,
	0x93, 0xc7, 0xc7, 0xf4, 0x20, 0x43, 0x1e, 0x95, 0xc8, 0x22, 0x6c, 0x0c, 0x79, 0x8e, 0xa6, 0x60,
	0xc8, 0x71, 0x4d, 0x5a, 0xda, 0xa6, 0x87, 0x98, 0x0b, 0x07, 0x1d, 0x77, 0xd9, 0x73, 0x89, 0xbe,
	0x04, 0x48, 0x32, 0x37, 0xf0, 0x7e, 0x0b, 0xfb, 0xc1, 0x0b, 0x7f, 0x17, 0xdd, 0x80, 0x21, 0x8f,
	0x7f, 0x9b, 0xd6, 0xe6, 0x52, 0xf3, 0x19, 0x55, 0xa0, 0x42, 0x27, 0x19, 0x12, 0x43, 0xc7, 0x90,
	0xe7, 0x35, 0xb5, 0xd8, 0xaa, 0x56, 0xb1, 0x57, 0x76, 0xbd, 0x00, 0xdd, 0x87, 0x34, 0x71, 0xbd,
	0xc0, 0x8c, 0x24, 0xdb, 0x39, 0xde, 0x32, 0x12, 0x98, 0x2c, 0xe3, 0x86, 0x89, 0xf8, 0x84, 0xce,
	0x01, 0xfb, 0x6c, 0x3a, 0xad, 0xa6, 0xa8, 0x9b, 0x43, 0xf4, 0xfb, 0x7a, 0xab, 0xa9, 0xff, 0x5c,
	0x53, 0xa2, 0x52, 0x4a, 0xda, 0x44, 0x5a, 0x3e, 0x2a, 0x01, 0xe2, 0x75, 0xde, 0xdc, 0x61, 0x4c,
	0x4d, 0x8a, 0x1f, 0x06, 0x4c, 0xb7, 0x2b, 0x8d, 0x3c, 0x49, 0x8a, 0x7b, 0x09, 0x46, 0xea, 0x0e,
	0x69, 0x05, 0xe6, 0x7e, 0x0b, 0xb7, 0x58, 0x6b, 0x49, 0xcd, 0x67, 0x8d, 0x0c, 0x83, 0x6d, 0x32,
	0x10, 0x2d, 0xfe, 0x6e, 0x2b, 0x88, 0xe0, 0xb0, 0xa4, 0x36, 0x46, 0x38, 0x90, 0x23, 0xe9, 0xdf,
	0xd7, 0x60, 0x2c, 0x34, 0x12, 0x93, 0x6f, 0x85, 0x54, 0xd0, 0x07, 0x90, 0x61, 0x4a, 0xf9, 0x0c,
	0x22, 0x2c, 0x3a, 0x15, 0xb3, 0xa8, 0x52, 0xc8, 0x00, 0xa2, 0x94, 0xbb, 0x03, 0x93, 0x41, 0xdb,
	0x0c, 0x3c, 0xab, 0x5a, 0xad, 0xdb, 0x26, 0x8f, 0x0d, 0xdb, 0xf5, 0x43, 0x09, 0xc7, 0x83, 0xf6,
	0x36, 0x3f, 0x64, 0x5c, 0x4a, 0xf4, 0x48, 0x1f, 0x4f, 0xca, 0x50, 0x22, 0x15, 0xfd, 0xf7, 0x1a,
	0xe4, 0xe2, 0x50, 0x34, 0x0f, 0xf9, 0x7d, 0xd7, 0x17, 0x5c, 0x23, 0x89, 0x36, 0x68, 0xe4, 0xf6,
	0x05, 0xa6, 0x48, 0xa2, 0x07, 0x00, 0x98, 0x54, 0xa4, 0xfc, 0xfd, 0xf1, 0x0e, 0x12, 0x57, 0x76,
	0xb5, 0xcf, 0x48, 0x63, 0x52, 0x11, 0x57, 0x3c, 0x00, 0xb0, 0x15, 0x61, 0xaa, 0x27, 0x61, 0x89,
	0x13, 0xda, 0x92, 0xb0, 0x78, 0x16, 0xc6, 0x95, 0x6c, 0x21, 0x07, 0xfd, 0x47, 0x1a, 0xe4, 0x55,
	0xb8, 0xfa, 0xc4, 0x75, 0x7c, 0x8c, 0x9e, 0x00, 0x58, 0xa4, 0xae, 0xac, 0x4b, 0x83, 0x2d, 0x7f,
	0x8b, 0x8f, 0xb3, 0x4b, 0xa4, 0x2e, 0x39, 0x1e, 0x1f, 0x15, 0xc6, 0x44, 0xe2, 0x29, 0x74, 0x23,
	0x6d, 0x49, 0x0c, 0x74, 0x83, 0xf6, 0xbc, 0x88, 0x86, 0xe3, 0x5d, 0x04, 0x35, 0x04, 0x8a, 0xbe,
	0x0a, 0xe3, 0x49, 0x41, 0x68, 0xe2, 0xdc, 0x86, 0x61, 0x4f, 0x7c, 0x15, 0x7e, 0x3e, 0x1b, 0xe3,
	0x22, 0x71, 0x8d, 0x10, 0x4d, 0xff, 0x81, 0x06, 0x67, 0xe5, 0xf1, 0x32, 0x6e, 0xe0, 0x00, 0x8b,
	0x44, 0x3c, 0xcd, 0x32, 0x58, 0x80, 0x8c, 0xdd, 0xc0, 0x96, 0xc7, 0xd4, 0xe6, 0x0a, 0x0e, 0x1b,
	0xc0, 0x40, 0x6c, 0x18, 0xd3, 0xcb, 0x30, 0xdd, 0x55, 0x08, 0xaa, 0xd4, 0xdd, 0x64, 0x35, 0x98,
	0x89, 0xe9, 0x14, 0xc3, 0x57, 0x65, 0xe1, 0x4b, 0x98, 0x4c, 0x62, 0x9c, 0xae, 0xc3, 0xf4, 0x6d,
	0x38, 0xd7, 0xfd, 0x06, 0x2a, 0xf4, 0x83, 0x0e, 0x4f, 0x9c, 0xef, 0x2a, 0x75, 0x87, 0x3f, 0xfe,
	0x17, 0x26, 0x18, 0x8e, 0x34, 0x8d, 0xf4, 0x46, 0xb4, 0x34, 0x69, 0xb1, 0xd2, 0x24, 0x33, 0x69,
	0xd7, 0x73, 0x5b, 0xc4, 0xdc, 0xa9, 0x07, 0xb4, 0x7c, 0xf3, 0xea, 0x45, 0x33, 0xe9, 0x29, 0x05,
	0x17, 0x19, 0x54, 0x5f, 0x87, 0xa9, 0x6e, 0xcc, 0xa9, 0xc0, 0x77, 0x92, 0x56, 0x3e, 0xa7, 0xe4,
	0x4d, 0xa0, 0x2b, 0x23, 0x9b, 0x22, 0x76, 0x14, 0xc2, 0x29, 0xdb, 0xd8, 0x10, 0x71, 0x91, 0xbc,
	0x80, 0x4a, 0x7c, 0xbf, 0xc3, 0xc4, 0x33, 0xdd, 0x44, 0xee, 0xb0, 0xf0, 0x9f, 0x35, 0xb8, 0x20,
	0xdd, 0xb0, 0x46, 0x4b, 0xec, 0x46, 0xb5, 0xe1, 0x1e, 0xb0, 0x12, 0xca, 0x5f, 0x06, 0x73, 0x30,
	0xb2, 0xeb, 0xba, 0x15, 0x93, 0xec, 0x05, 0xbe, 0x59, 0x77, 0xc4, 0x74, 0x07, 0x14, 0x56, 0xde,
	0x0b, 0xfc, 0x35, 0x07, 0xe9, 0x90, 0x55, 0x18, 0x6e, 0x2b, 0x10, 0x8f, 0x81, 0x8c, 0x44, 0xd9,
	0x68, 0x05, 0xe8, 0x2a, 0x8c, 0x62, 0xcf, 0x73, 0x3d, 0xac, 0x18, 0xf1, 0x97, 0x40, 0x56, 0x80,
	0x05, 0xaf, 0x8b, 0x00, 0xd5, 0x7a, 0xd5, 0x35, 0x2b, 0x98, 0x04, 0x35, 0x3e, 0xbf, 0x18, 0x69,
	0x0a, 0x59, 0xa6, 0x00, 0x74, 0x19, 0x72, 0x4d, 0xab, 0x6d, 0x46, 0x50, 0xce, 0xf0, 0xb1, 0xbf,
	0x69, 0xb5, 0x9f, 0x48, 0x2c, 0xfd, 0x17, 0xfd, 0xc2, 0xb3, 0x52, 0xa7, 0x88, 0x3a, 0x57, 0x61,
	0x34, 0xd2, 0x5d, 0xcc, 0x7a, 0xa5, 0x2d, 0x02, 0x28, 0xab, 0x1a, 0xcc, 0x5a, 0xa5, 0x8d, 0x9e,
	0x41, 0xde, 0xa5, 0x96, 0xe0, 0x77, 0xa9, 0x4c, 0xcd, 0x2c, 0x5e, 0x8a, 0x85, 0x6e, 0x37, 0x9b,
	0x19, 0x39, 0x46, 0x4a, 0x05, 0xe2, 0x97, 0xbe, 0x0b, 0x79, 0xd1, 0x10, 0x5d, 0xdb, 0x6e, 0x11,
	0xcb, 0xb1, 0x0f, 0x99, 0xfa, 0x59, 0x63, 0x94, 0xc3, 0x37, 0x24, 0x98, 0x3e, 0x59, 0x08, 0xb6,
	0xf6, 0x22, 0x88, 0xdc, 0x08, 0x59, 0x0a, 0x55, 0x68, 0x97, 0xe8, 0x83, 0xce, 0x0b, 0xcc, 0xa6,
	0xeb, 0xd4, 0x03, 0xd7, 0x63, 0x66, 0x18, 0x30, 0x58, 0x6b, 0x7b, 0xc1, 0x41, 0xd4, 0x2d, 0x2a,
	0x11, 0xa8, 0x9e, 0x83, 0x1c, 0x47, 0x66, 0xc1, 0x5a, 0xa5, 0xad, 0xff, 0x4a, 0x53, 0xa5, 0x66,
	0x43, 0x35, 0x4f, 0x2e, 0xf5, 0x3c, 0xe4, 0xa3, 0x5d, 0x36, 0x62, 0xab, 0x5c, 0xa4, 0xd1, 0x52,
	0x63, 0x15, 0x20, 0xc3, 0x51, 0xb8, 0x4f, 0x78, 0xba, 0x01, 0x03, 0x71, 0xbf, 0x25, 0xc5, 0x4d,
	0x7d, 0x33, 0x71, 0x7f, 0x19, 0x19, 0x3b, 0x22, 0x82, 0xae, 0xc2, 0x58, 0xd4, 0xa7, 0xdc, 0x59,
	0x3c, 0x09, 0x2e, 0x74, 0x3a, 0x2b, 0xe2, 0xa7, 0xd1, 0x7a, 0x22, 0x3a, 0x9e, 0x01, 0x8a, 0xa9,
	0x2c, 0xfd, 0x4e, 0x59, 0x5d, 0x8c, 0xb1, 0x4a, 0x5a, 0xcb, 0xc8, 0xbb, 0x09, 0x88, 0xfe, 0x55,
	0x64, 0x00, 0x91, 0x33, 0xc5, 0x29, 0xcd, 0x48, 0x8f, 0x61, 0x94, 0x1a, 0x2b, 0x2e, 0xa4, 0xd6,
	0x31, 0xc9, 0x44, 0xc4, 0xa3, 0xc6, 0x8d, 0xc8, 0xf6, 0x43, 0x0d, 0xb2, 0xd1, 0x6e, 0xea, 0xa3,
	0x59, 0xc8, 0x38, 0xad, 0xa6, 0xd9, 0xa8, 0x57, 0x7d, 0x33, 0x90, 0x8e, 0x4e, 0x3b, 0xad, 0xe6,
	0xf3, 0x7a, 0xd5, 0xdf, 0x6e, 0xc7, 0xce, 0xbd, 0xb6, 0xf0, 0xb1, 0x3c, 0x37, 0xda, 0xe8, 0x1e,
	0x40, 0x38, 0x58, 0xf1, 0x81, 0x2c, 0x39, 0x5e, 0x84, 0x36, 0x30, 0xd2, 0x72, 0xac, 0xf2, 0x75,
	0x53, 0x79, 0xf4, 0x29, 0x0e, 0x4e, 0xbf, 0xdb, 0xea, 0xff, 0xa5, 0x3a, 0xba, 0xba, 0x80, 0x8f,
	0x07, 0x89, 0x1a, 0x1f, 0xb7, 0x9d, 0x42, 0x56, 0x15, 0xfe, 0x6f, 0x9a, 0x9a, 0x34, 0xd8, 0xf9,
	0x29, 0x4f, 0x3d, 0x57, 0x60, 0xc0, 0x27, 0xd8, 0x16, 0xbe, 0xec, 0x32, 0xe7, 0xb3, 0xe3, 0xc8,
	0x70, 0x94, 0x7a, 0xed, 0x70, 0x84, 0xe6, 0xe1, 0x0c, 0x77, 0x09, 0x7f, 0x02, 0xa1, 0x0e, 0x5c,
	0xdf, 0xe0, 0x08, 0xfa, 0x3a, 0x8c, 0x85, 0x05, 0xa6, 0x8c, 0x3d, 0x16, 0x2d, 0xe8, 0x3c, 0xa4,
	0x93, 0xd9, 0x3f, 0xbc, 0x2f, 0xf3, 0xfe, 0x02, 0xa4, 0x55, 0x9d, 0x12, 0x11, 0x11, 0x02, 0xf4,
	0x2f, 0x21, 0x4b, 0x5d, 0xae, 0x8a, 0xd6, 0x09, 0x5d, 0xfb, 0x6e, 0x9c, 0x93, 0x0a, 0x9e, 0x0e,
	0x89, 0xa2, 0x37, 0x1c, 0x02, 0x84, 0x5b, 0x1c, 0x9f, 0x56, 0xa1, 0xda, 0x4e, 0xd3, 0xb4, 0x5d,
	0x27, 0xc0, 0xed, 0x40, 0xdc, 0x00, 0xb5, 0x9d, 0x66, 0x89, 0x43, 0x3a, 0x77, 0x46, 0xfd, 0x6f,
	0xb4, 0x33, 0x4a, 0x75, 0xd9, 0x19, 0xe9, 0x7f, 0xd1, 0xe0, 0xa2, 0xb4, 0xa2, 0x92, 0xe1, 0xdb,
	0x08, 0x8a, 0x87, 0x90, 0x63, 0x56, 0x4b, 0xda, 0x07, 0x89, 0xb5, 0x5f, 0xc4, 0xc2, 0x46, 0x96,
	0xc4, 0x0c, 0xfe, 0x3e, 0x40, 0xa8, 0x86, 0xcc, 0x49, 0xfe, 0x2e, 0x55, 0x22, 0x1b, 0x11, 0x14,
	0x7d, 0x07, 0xe6, 0x4e, 0x54, 0x8a, 0xe6, 0xcd, 0x27, 0x1d, 0x93, 0x86, 0x1e, 0x8b, 0xa9, 0xae,
	0x84, 0x91, 0x89, 0x63, 0x56, 0x0d, 0x1c, 0x09, 0x54, 0x9e, 0x64, 0x5f, 0x40, 0xe1, 0xa4, 0x73,
	0x2a, 0xc2, 0x87, 0xc9, 0xd4, 0xbd, 0x74, 0x92, 0x04, 0x89, 0x24, 0x5e, 0x57, 0xb3, 0x70, 0x42,
	0xb3, 0xbb, 0x1d, 0x9a, 0x4d, 0x77, 0x96, 0x84, 0x0e, 0x7d, 0x5e, 0xc2, 0xa5, 0x30, 0x9d, 0x70,
	0xf0, 0xb4, 0xe1, 0xee, 0x58, 0x0d, 0xb5, 0x3a, 0x14, 0x05, 0x6d, 0x01, 0x80, 0x6d, 0x24, 0xa2,
	0x8f, 0xf0, 0x2e, 0x8b, 0xc6, 0x34, 0x91, 0x1f, 0xf5, 0x1a, 0x5c, 0x7e, 0x2d, 0x5b, 0x2a, 0xf4,
	0xa7, 0x49, 0x5b, 0x5c, 0x8d, 0x67, 0x78, 0x2f, 0x5a, 0x65, 0x90, 0x6b, 0x70, 0xe5, 0x24, 0xec,
	0xd0, 0x3e, 0xfa, 0x35, 0x18, 0xdd, 0x74, 0xe9, 0x10, 0xa9, 0x0a, 0xf5, 0x04, 0x9c, 0x61, 0x1d,
	0x5b, 0x64, 0x1b, 0xff, 0xa2, 0x2f, 0xb3, 0xa2, 0x1e, 0x45, 0xa4, 0x92, 0xde, 0x4a, 0x4a, 0x1a,
	0xae, 0xfc, 0xa2, 0x98, 0x4a, 0xae, 0xb3, 0xac, 0xd8, 0x8a, 0x33, 0x25, 0xc5, 0x4f, 0x35, 0x18,
	0x2e, 0xb9, 0x84, 0xb0, 0xed, 0xd4, 0x4a, 0xf7, 0x46, 0x31, 0x46, 0x1b, 0x05, 0x45, 0x7a, 0xc3,
	0x27, 0xd9, 0xa7, 0x30, 0x24, 0x77, 0xea, 0xa9, 0xc8, 0xaa, 0x27, 0xb2, 0xb2, 0xef, 0xb1, 0x2c,
	0x92, 0x64, 0xfa, 0x43, 0xc8, 0xd1, 0xfb, 0x22, 0xea, 0x5e, 0x4b, 0xaa, 0xcb, 0xb7, 0x4f, 0x52,
	0x74, 0xa5, 0xe7, 0x3d, 0xc8, 0x32, 0x60, 0xb8, 0xa3, 0xb8, 0x0c, 0xb9, 0xda, 0x81, 0x5c, 0xf2,
	0x47, 0x0a, 0xef, 0x48, 0xed, 0x40, 0x48, 0x44, 0x87, 0xa1, 0xd1, 0x28, 0x59, 0x89, 0x54, 0xf4,
	0x5f, 0x6b, 0x00, 0x0a, 0xc2, 0x9e, 0x99, 0x2e, 0x21, 0xf1, 0x6d, 0x02, 0x50, 0x90, 0x50, 0xfa,
	0x4e, 0x97, 0x4d, 0x02, 0x52, 0x32, 0x76, 0xdf, 0x22, 0xdc, 0xe9, 0xb2, 0x45, 0x48, 0x12, 0xbd,
	0xe9, 0x06, 0xe1, 0xbb, 0x30, 0xc2, 0x6d, 0x76, 0xca, 0x15, 0xf3, 0x5a, 0x62, 0x79, 0x30, 0x9a,
	0x90, 0x2f, 0x5c, 0x1c, 0x7c, 0x0a, 0xa3, 0x51, 0x01, 0xa8, 0xd7, 0x6e, 0x76, 0xd4, 0x80, 0xb1,
	0x90, 0xba, 0x4b, 0xf2, 0x7f, 0x0e, 0x63, 0xf4, 0x24, 0xbe, 0x2b, 0x38, 0x9d, 0xa0, 0xd4, 0x57,
	0x61, 0xa2, 0x83, 0x37, 0x15, 0x71, 0x21, 0x19, 0x58, 0x93, 0xa1, 0x84, 0x3d, 0x9e, 0xff, 0xff,
	0x07, 0x28, 0x7a, 0x7a, 0xca, 0xcf, 0xd2, 0xe7, 0x70, 0xb6, 0x93, 0x3b, 0x7f, 0x45, 0x27, 0x6d,
	0x39, 0xd5, 0x21, 0x69, 0x87, 0x45, 0xbf, 0x80, 0xb4, 0xf4, 0x94, 0x8f, 0xee, 0x43, 0x56, 0xa6,
	0x81, 0x9c, 0xea, 0xd5, 0x64, 0x14, 0xfd, 0x01, 0xcb, 0x90, 0xbf, 0x6f, 0x71, 0xba, 0x73, 0x30,
	0x4c, 0x87, 0x55, 0xcb, 0x6e, 0xf8, 0x72, 0x75, 0xe9, 0xb4, 0x9a, 0x4b, 0x76, 0xc3, 0xd7, 0x3f,
	0xe3, 0x89, 0x1a, 0x19, 0x36, 0x4f, 0xc9, 0x5d, 0x45, 0x1e, 0x0a, 0xf1, 0x4e, 0x75, 0x33, 0xe9,
	0xab, 0xf1, 0xd0, 0x02, 0xdd, 0x7a, 0xd3, 0x1f, 0x35, 0x1e, 0x91, 0xdf, 0xc6, 0x1c, 0x71, 0x29,
	0x36, 0x5c, 0x26, 0x8a, 0x11, 0x1f, 0x2c, 0xaf, 0x25, 0x06, 0xcb, 0x5e, 0x89, 0x83, 0x2e, 0xc7,
	0x87, 0xca, 0x5c, 0x0c, 0x2f, 0x1c, 0x28, 0x9f, 0xf0, 0xb0, 0x4b, 0x74, 0xd9, 0x85, 0x8e, 0xa8,
	0x98, 0x88, 0xdb, 0x24, 0x19, 0x12, 0xd7, 0xbf, 0x60, 0x3f, 0x49, 0x84, 0x2d, 0x09, 0x4d, 0xc1,
	0xf8, 0xe6, 0xc6, 0x96, 0x59, 0x5e, 0x7a, 0xb9, 0xb5, 0x62, 0x6e, 0xff, 0x4f, 0x79, 0xc5, 0x5c,
	0xdf, 0x58, 0x5f, 0xc9, 0xf7, 0xa1, 0x8b, 0x70, 0x2e, 0x71, 0xf0, 0x7c, 0x6d, 0xfd, 0x99, 0xf9,
	0x7c, 0xe5, 0xbf, 0x57, 0x9e, 0xe7, 0x35, 0x34, 0x09, 0x28, 0x71, 0x5c, 0x7e, 0x52, 0xca, 0xf7,
	0x5f, 0xff, 0xb1, 0xc6, 0x1a, 0x5b, 0xf4, 0x87, 0x27, 0x74, 0x1e, 0xa6, 0x28, 0x6e, 0xe9, 0xf9,
	0xd2, 0xd6, 0x96, 0xf9, 0x62, 0xa9, 0x1c, 0xbb, 0x67, 0x06, 0x26, 0xbb, 0x1c, 0x96, 0x4b, 0xe5,
	0xbc, 0xd6, 0x83, 0x70, 0x79, 0xab, 0x54, 0xce, 0xf7, 0xa3, 0x02, 0x9c, 0xef, 0x4e, 0xc8, 0x11,
	0x52, 0xd7, 0x7f, 0xa6, 0xc1, 0x44, 0xb7, 0xb5, 0x3c, 0xa5, 0x2c, 0x2f, 0x95, 0x9e, 0xad, 0x6c,
	0x9b, 0xc5, 0x97, 0x4f, 0x9e, 0xac, 0x18, 0x66, 0x79, 0xc3, 0xd8, 0x16, 0xbc, 0x5f, 0x2c, 0xe5,
	0xfb, 0xd0, 0x1c, 0x5c, 0xe8, 0x85, 0x50, 0xbe, 0xbb, 0xf6, 0x34, 0xaf, 0x9d, 0x8c, 0xb1, 0xf2,
	0x34, 0xdf, 0x8f, 0x74, 0x98, 0xed, 0x85, 0xf1, 0xb2, 0x4c, 0x4d, 0x99, 0x4f, 0x2d, 0x7e, 0x35,
	0x08, 0xa9, 0xcd, 0x8d, 0x2d, 0xb4, 0xa2, 0x76, 0xd8, 0x25, 0x0f, 0x5b, 0x01, 0x46, 0x53, 0x89,
	0xed, 0xaa, 0x4c, 0x82, 0x99, 0xe9, 0xae, 0x6b, 0x57, 0xda, 0xcb, 0xfb, 0xa2, 0x6c, 0x5e, 0x92,
	0xca, 0x37, 0x66, 0xb3, 0xa9, 0xd8, 0xf0, 0xca, 0x82, 0x2e, 0xf6, 0xde, 0x8b, 0x52, 0x66, 0xb3,
	0x27, 0x2c, 0x20, 0x39, 0xcb, 0x55, 0xf5, 0x6b, 0xe5, 0x53, 0x1c, 0xa0, 0x99, 0x1e, 0xaf, 0x43,
	0xca, 0xec, 0x7c, 0xaf, 0x31, 0x91, 0x73, 0xaa, 0xaa, 0x27, 0x68, 0x6c, 0x34, 0x45, 0x97, 0x5f,
	0x3b, 0xb6, 0x52, 0xee, 0x57, 0x5e, 0x3f, 0x5e, 0xf3, 0x7b, 0x5a, 0x30, 0xd3, 0x7b, 0x90, 0x43,
	0xef, 0xbe, 0xd9, 0x5c, 0x48, 0x6f, 0xbc, 0xfe, 0x5a, 0xd4, 0xe8, 0xb5, 0xeb, 0x62, 0x95, 0x20,
	0xb7, 0x8c, 0xe8, 0x42, 0xcf, 0x65, 0x29, 0x65, 0x7e, 0xb1, 0xf7, 0x5e, 0x92, 0xf3, 0x7b, 0xcc,
	0x7e, 0x29, 0x67, 0x73, 0x9f, 0x0a, 0x86, 0xc4, 0x30, 0xa9, 0x82, 0xa1, 0x63, 0x3e, 0xec, 0x43,
	0x0f, 0xf9, 0x1c, 0x24, 0xe2, 0x69, 0x3c, 0xd2, 0xbf, 0x43, 0xf2, 0x89, 0x8e, 0xa6, 0xce, 0x49,
	0x3f, 0x82, 0x21, 0x51, 0x87, 0xd0, 0x64, 0x97, 0x4a, 0x4d, 0x49, 0xa7, 0xba, 0x55, 0x2b, 0x46,
	0x5d, 0x9c, 0xfc, 0xc3, 0xd7, 0xb3, 0xda, 0x9f, 0xbe, 0x9e, 0xd5, 0xfe, 0xf1, 0xf5, 0xac, 0xf6,
	0xf9, 0x70, 0xcd, 0x6a, 0xb0, 0x3f, 0xdc, 0xd9, 0x19, 0x64, 0xff, 0xdd, 0xf9, 0x77, 0x00, 0x00,
	0x00, 0xff, 0xff, 0xfa, 0xe0, 0xcc, 0xc5, 0xe8, 0x23, 0x00, 0x00,
}
