// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: qos.proto

package halproto

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// QosGroup identifier
type QosGroup int32

const (
	QosGroup_DEFAULT                   QosGroup = 0
	QosGroup_USER_DEFINED_1            QosGroup = 1
	QosGroup_USER_DEFINED_2            QosGroup = 2
	QosGroup_USER_DEFINED_3            QosGroup = 3
	QosGroup_USER_DEFINED_4            QosGroup = 4
	QosGroup_USER_DEFINED_5            QosGroup = 5
	QosGroup_USER_DEFINED_6            QosGroup = 6
	QosGroup_CONTROL                   QosGroup = 7
	QosGroup_SPAN                      QosGroup = 8
	QosGroup_INTERNAL_ADMIN            QosGroup = 9
	QosGroup_INTERNAL_RX_PROXY_NO_DROP QosGroup = 10
	QosGroup_INTERNAL_RX_PROXY_DROP    QosGroup = 11
	QosGroup_INTERNAL_TX_PROXY_NO_DROP QosGroup = 12
	QosGroup_INTERNAL_TX_PROXY_DROP    QosGroup = 13
	QosGroup_INTERNAL_CPU_COPY         QosGroup = 14
)

var QosGroup_name = map[int32]string{
	0:  "DEFAULT",
	1:  "USER_DEFINED_1",
	2:  "USER_DEFINED_2",
	3:  "USER_DEFINED_3",
	4:  "USER_DEFINED_4",
	5:  "USER_DEFINED_5",
	6:  "USER_DEFINED_6",
	7:  "CONTROL",
	8:  "SPAN",
	9:  "INTERNAL_ADMIN",
	10: "INTERNAL_RX_PROXY_NO_DROP",
	11: "INTERNAL_RX_PROXY_DROP",
	12: "INTERNAL_TX_PROXY_NO_DROP",
	13: "INTERNAL_TX_PROXY_DROP",
	14: "INTERNAL_CPU_COPY",
}
var QosGroup_value = map[string]int32{
	"DEFAULT":                   0,
	"USER_DEFINED_1":            1,
	"USER_DEFINED_2":            2,
	"USER_DEFINED_3":            3,
	"USER_DEFINED_4":            4,
	"USER_DEFINED_5":            5,
	"USER_DEFINED_6":            6,
	"CONTROL":                   7,
	"SPAN":                      8,
	"INTERNAL_ADMIN":            9,
	"INTERNAL_RX_PROXY_NO_DROP": 10,
	"INTERNAL_RX_PROXY_DROP":    11,
	"INTERNAL_TX_PROXY_NO_DROP": 12,
	"INTERNAL_TX_PROXY_DROP":    13,
	"INTERNAL_CPU_COPY":         14,
}

func (x QosGroup) String() string {
	return proto.EnumName(QosGroup_name, int32(x))
}
func (QosGroup) EnumDescriptor() ([]byte, []int) { return fileDescriptorQos, []int{0} }

// CoppType identifies the type of traffic for the copp policy
type CoppType int32

const (
	CoppType_COPP_TYPE_FLOW_MISS CoppType = 0
	CoppType_COPP_TYPE_ARP       CoppType = 1
	CoppType_COPP_TYPE_DHCP      CoppType = 2
)

var CoppType_name = map[int32]string{
	0: "COPP_TYPE_FLOW_MISS",
	1: "COPP_TYPE_ARP",
	2: "COPP_TYPE_DHCP",
}
var CoppType_value = map[string]int32{
	"COPP_TYPE_FLOW_MISS": 0,
	"COPP_TYPE_ARP":       1,
	"COPP_TYPE_DHCP":      2,
}

func (x CoppType) String() string {
	return proto.EnumName(CoppType_name, int32(x))
}
func (CoppType) EnumDescriptor() ([]byte, []int) { return fileDescriptorQos, []int{1} }

// Specifications of a policer
type PolicerSpec struct {
	BpsRate   uint32 `protobuf:"varint,1,opt,name=bps_rate,json=bpsRate,proto3" json:"bps_rate,omitempty"`
	BurstSize uint32 `protobuf:"varint,2,opt,name=burst_size,json=burstSize,proto3" json:"burst_size,omitempty"`
}

func (m *PolicerSpec) Reset()                    { *m = PolicerSpec{} }
func (m *PolicerSpec) String() string            { return proto.CompactTextString(m) }
func (*PolicerSpec) ProtoMessage()               {}
func (*PolicerSpec) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{0} }

func (m *PolicerSpec) GetBpsRate() uint32 {
	if m != nil {
		return m.BpsRate
	}
	return 0
}

func (m *PolicerSpec) GetBurstSize() uint32 {
	if m != nil {
		return m.BurstSize
	}
	return 0
}

// PolicerStats captures all the statistics of a policer
type PolicerStats struct {
	PermittedPackets uint64 `protobuf:"varint,1,opt,name=permitted_packets,json=permittedPackets,proto3" json:"permitted_packets,omitempty"`
	PermittedBytes   uint64 `protobuf:"varint,2,opt,name=permitted_bytes,json=permittedBytes,proto3" json:"permitted_bytes,omitempty"`
	DroppedPackets   uint64 `protobuf:"varint,3,opt,name=dropped_packets,json=droppedPackets,proto3" json:"dropped_packets,omitempty"`
	DroppedBytes     uint64 `protobuf:"varint,4,opt,name=dropped_bytes,json=droppedBytes,proto3" json:"dropped_bytes,omitempty"`
}

func (m *PolicerStats) Reset()                    { *m = PolicerStats{} }
func (m *PolicerStats) String() string            { return proto.CompactTextString(m) }
func (*PolicerStats) ProtoMessage()               {}
func (*PolicerStats) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{1} }

func (m *PolicerStats) GetPermittedPackets() uint64 {
	if m != nil {
		return m.PermittedPackets
	}
	return 0
}

func (m *PolicerStats) GetPermittedBytes() uint64 {
	if m != nil {
		return m.PermittedBytes
	}
	return 0
}

func (m *PolicerStats) GetDroppedPackets() uint64 {
	if m != nil {
		return m.DroppedPackets
	}
	return 0
}

func (m *PolicerStats) GetDroppedBytes() uint64 {
	if m != nil {
		return m.DroppedBytes
	}
	return 0
}

// QosClassKeyHandle uniquely identifies a QosClass
type QosClassKeyHandle struct {
	// Types that are valid to be assigned to KeyOrHandle:
	//	*QosClassKeyHandle_QosGroup
	//	*QosClassKeyHandle_QosClassHandle
	KeyOrHandle isQosClassKeyHandle_KeyOrHandle `protobuf_oneof:"key_or_handle"`
}

func (m *QosClassKeyHandle) Reset()                    { *m = QosClassKeyHandle{} }
func (m *QosClassKeyHandle) String() string            { return proto.CompactTextString(m) }
func (*QosClassKeyHandle) ProtoMessage()               {}
func (*QosClassKeyHandle) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{2} }

type isQosClassKeyHandle_KeyOrHandle interface {
	isQosClassKeyHandle_KeyOrHandle()
	MarshalTo([]byte) (int, error)
	Size() int
}

type QosClassKeyHandle_QosGroup struct {
	QosGroup QosGroup `protobuf:"varint,1,opt,name=qos_group,json=qosGroup,proto3,enum=qos.QosGroup,oneof"`
}
type QosClassKeyHandle_QosClassHandle struct {
	QosClassHandle uint64 `protobuf:"fixed64,2,opt,name=qos_class_handle,json=qosClassHandle,proto3,oneof"`
}

func (*QosClassKeyHandle_QosGroup) isQosClassKeyHandle_KeyOrHandle()       {}
func (*QosClassKeyHandle_QosClassHandle) isQosClassKeyHandle_KeyOrHandle() {}

func (m *QosClassKeyHandle) GetKeyOrHandle() isQosClassKeyHandle_KeyOrHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

func (m *QosClassKeyHandle) GetQosGroup() QosGroup {
	if x, ok := m.GetKeyOrHandle().(*QosClassKeyHandle_QosGroup); ok {
		return x.QosGroup
	}
	return QosGroup_DEFAULT
}

func (m *QosClassKeyHandle) GetQosClassHandle() uint64 {
	if x, ok := m.GetKeyOrHandle().(*QosClassKeyHandle_QosClassHandle); ok {
		return x.QosClassHandle
	}
	return 0
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*QosClassKeyHandle) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _QosClassKeyHandle_OneofMarshaler, _QosClassKeyHandle_OneofUnmarshaler, _QosClassKeyHandle_OneofSizer, []interface{}{
		(*QosClassKeyHandle_QosGroup)(nil),
		(*QosClassKeyHandle_QosClassHandle)(nil),
	}
}

func _QosClassKeyHandle_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*QosClassKeyHandle)
	// key_or_handle
	switch x := m.KeyOrHandle.(type) {
	case *QosClassKeyHandle_QosGroup:
		_ = b.EncodeVarint(1<<3 | proto.WireVarint)
		_ = b.EncodeVarint(uint64(x.QosGroup))
	case *QosClassKeyHandle_QosClassHandle:
		_ = b.EncodeVarint(2<<3 | proto.WireFixed64)
		_ = b.EncodeFixed64(uint64(x.QosClassHandle))
	case nil:
	default:
		return fmt.Errorf("QosClassKeyHandle.KeyOrHandle has unexpected type %T", x)
	}
	return nil
}

func _QosClassKeyHandle_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*QosClassKeyHandle)
	switch tag {
	case 1: // key_or_handle.qos_group
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.KeyOrHandle = &QosClassKeyHandle_QosGroup{QosGroup(x)}
		return true, err
	case 2: // key_or_handle.qos_class_handle
		if wire != proto.WireFixed64 {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeFixed64()
		m.KeyOrHandle = &QosClassKeyHandle_QosClassHandle{x}
		return true, err
	default:
		return false, nil
	}
}

func _QosClassKeyHandle_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*QosClassKeyHandle)
	// key_or_handle
	switch x := m.KeyOrHandle.(type) {
	case *QosClassKeyHandle_QosGroup:
		n += proto.SizeVarint(1<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.QosGroup))
	case *QosClassKeyHandle_QosClassHandle:
		n += proto.SizeVarint(2<<3 | proto.WireFixed64)
		n += 8
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// QosBuffer specifies the buffer parameters
type QosBuffer struct {
	ReservedMtus uint32 `protobuf:"varint,1,opt,name=reserved_mtus,json=reservedMtus,proto3" json:"reserved_mtus,omitempty"`
	HeadroomMtus uint32 `protobuf:"varint,2,opt,name=headroom_mtus,json=headroomMtus,proto3" json:"headroom_mtus,omitempty"`
	// pkts for no-drop classes in #mtus
	XonThreshold uint32 `protobuf:"varint,3,opt,name=xon_threshold,json=xonThreshold,proto3" json:"xon_threshold,omitempty"`
	// max occupancy at which to clear the xoff
	XoffClearLimit uint32 `protobuf:"varint,4,opt,name=xoff_clear_limit,json=xoffClearLimit,proto3" json:"xoff_clear_limit,omitempty"`
}

func (m *QosBuffer) Reset()                    { *m = QosBuffer{} }
func (m *QosBuffer) String() string            { return proto.CompactTextString(m) }
func (*QosBuffer) ProtoMessage()               {}
func (*QosBuffer) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{3} }

func (m *QosBuffer) GetReservedMtus() uint32 {
	if m != nil {
		return m.ReservedMtus
	}
	return 0
}

func (m *QosBuffer) GetHeadroomMtus() uint32 {
	if m != nil {
		return m.HeadroomMtus
	}
	return 0
}

func (m *QosBuffer) GetXonThreshold() uint32 {
	if m != nil {
		return m.XonThreshold
	}
	return 0
}

func (m *QosBuffer) GetXoffClearLimit() uint32 {
	if m != nil {
		return m.XoffClearLimit
	}
	return 0
}

// QosPFC specifies the pfc cos-es
type QosPFC struct {
	PfcCos []uint32 `protobuf:"varint,1,rep,packed,name=pfc_cos,json=pfcCos" json:"pfc_cos,omitempty"`
}

func (m *QosPFC) Reset()                    { *m = QosPFC{} }
func (m *QosPFC) String() string            { return proto.CompactTextString(m) }
func (*QosPFC) ProtoMessage()               {}
func (*QosPFC) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{4} }

func (m *QosPFC) GetPfcCos() []uint32 {
	if m != nil {
		return m.PfcCos
	}
	return nil
}

// QosSched specifies the QosClass scheduling configuration
type QosSched struct {
	// Types that are valid to be assigned to SchedType:
	//	*QosSched_Dwrr
	//	*QosSched_Strict
	SchedType isQosSched_SchedType `protobuf_oneof:"SchedType"`
}

func (m *QosSched) Reset()                    { *m = QosSched{} }
func (m *QosSched) String() string            { return proto.CompactTextString(m) }
func (*QosSched) ProtoMessage()               {}
func (*QosSched) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{5} }

type isQosSched_SchedType interface {
	isQosSched_SchedType()
	MarshalTo([]byte) (int, error)
	Size() int
}

type QosSched_Dwrr struct {
	Dwrr *QosSched_DWRRInfo `protobuf:"bytes,1,opt,name=dwrr,oneof"`
}
type QosSched_Strict struct {
	Strict *QosSched_StrictPriorityInfo `protobuf:"bytes,2,opt,name=strict,oneof"`
}

func (*QosSched_Dwrr) isQosSched_SchedType()   {}
func (*QosSched_Strict) isQosSched_SchedType() {}

func (m *QosSched) GetSchedType() isQosSched_SchedType {
	if m != nil {
		return m.SchedType
	}
	return nil
}

func (m *QosSched) GetDwrr() *QosSched_DWRRInfo {
	if x, ok := m.GetSchedType().(*QosSched_Dwrr); ok {
		return x.Dwrr
	}
	return nil
}

func (m *QosSched) GetStrict() *QosSched_StrictPriorityInfo {
	if x, ok := m.GetSchedType().(*QosSched_Strict); ok {
		return x.Strict
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*QosSched) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _QosSched_OneofMarshaler, _QosSched_OneofUnmarshaler, _QosSched_OneofSizer, []interface{}{
		(*QosSched_Dwrr)(nil),
		(*QosSched_Strict)(nil),
	}
}

func _QosSched_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*QosSched)
	// SchedType
	switch x := m.SchedType.(type) {
	case *QosSched_Dwrr:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Dwrr); err != nil {
			return err
		}
	case *QosSched_Strict:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Strict); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("QosSched.SchedType has unexpected type %T", x)
	}
	return nil
}

func _QosSched_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*QosSched)
	switch tag {
	case 1: // SchedType.dwrr
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(QosSched_DWRRInfo)
		err := b.DecodeMessage(msg)
		m.SchedType = &QosSched_Dwrr{msg}
		return true, err
	case 2: // SchedType.strict
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(QosSched_StrictPriorityInfo)
		err := b.DecodeMessage(msg)
		m.SchedType = &QosSched_Strict{msg}
		return true, err
	default:
		return false, nil
	}
}

func _QosSched_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*QosSched)
	// SchedType
	switch x := m.SchedType.(type) {
	case *QosSched_Dwrr:
		s := proto.Size(x.Dwrr)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *QosSched_Strict:
		s := proto.Size(x.Strict)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// DWRR specific information
type QosSched_DWRRInfo struct {
	BwPercentage uint32 `protobuf:"varint,1,opt,name=bw_percentage,json=bwPercentage,proto3" json:"bw_percentage,omitempty"`
}

func (m *QosSched_DWRRInfo) Reset()                    { *m = QosSched_DWRRInfo{} }
func (m *QosSched_DWRRInfo) String() string            { return proto.CompactTextString(m) }
func (*QosSched_DWRRInfo) ProtoMessage()               {}
func (*QosSched_DWRRInfo) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{5, 0} }

func (m *QosSched_DWRRInfo) GetBwPercentage() uint32 {
	if m != nil {
		return m.BwPercentage
	}
	return 0
}

// Strict Priority specific information for the class
type QosSched_StrictPriorityInfo struct {
	Bps uint32 `protobuf:"varint,1,opt,name=bps,proto3" json:"bps,omitempty"`
}

func (m *QosSched_StrictPriorityInfo) Reset()         { *m = QosSched_StrictPriorityInfo{} }
func (m *QosSched_StrictPriorityInfo) String() string { return proto.CompactTextString(m) }
func (*QosSched_StrictPriorityInfo) ProtoMessage()    {}
func (*QosSched_StrictPriorityInfo) Descriptor() ([]byte, []int) {
	return fileDescriptorQos, []int{5, 1}
}

func (m *QosSched_StrictPriorityInfo) GetBps() uint32 {
	if m != nil {
		return m.Bps
	}
	return 0
}

// QosUplinkClassMap specifies the policy with which traffic from network
// is classified
type QosUplinkClassMap struct {
	Dot1QPcp uint32   `protobuf:"varint,1,opt,name=dot1q_pcp,json=dot1qPcp,proto3" json:"dot1q_pcp,omitempty"`
	IpDscp   []uint32 `protobuf:"varint,2,rep,packed,name=ip_dscp,json=ipDscp" json:"ip_dscp,omitempty"`
}

func (m *QosUplinkClassMap) Reset()                    { *m = QosUplinkClassMap{} }
func (m *QosUplinkClassMap) String() string            { return proto.CompactTextString(m) }
func (*QosUplinkClassMap) ProtoMessage()               {}
func (*QosUplinkClassMap) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{6} }

func (m *QosUplinkClassMap) GetDot1QPcp() uint32 {
	if m != nil {
		return m.Dot1QPcp
	}
	return 0
}

func (m *QosUplinkClassMap) GetIpDscp() []uint32 {
	if m != nil {
		return m.IpDscp
	}
	return nil
}

// QosMarking specifies the policy to mark the host-to-network traffic
type QosMarking struct {
	Dot1QPcpRewriteEn bool   `protobuf:"varint,1,opt,name=dot1q_pcp_rewrite_en,json=dot1qPcpRewriteEn,proto3" json:"dot1q_pcp_rewrite_en,omitempty"`
	Dot1QPcp          uint32 `protobuf:"varint,2,opt,name=dot1q_pcp,json=dot1qPcp,proto3" json:"dot1q_pcp,omitempty"`
	IpDscpRewriteEn   bool   `protobuf:"varint,3,opt,name=ip_dscp_rewrite_en,json=ipDscpRewriteEn,proto3" json:"ip_dscp_rewrite_en,omitempty"`
	IpDscp            uint32 `protobuf:"varint,4,opt,name=ip_dscp,json=ipDscp,proto3" json:"ip_dscp,omitempty"`
}

func (m *QosMarking) Reset()                    { *m = QosMarking{} }
func (m *QosMarking) String() string            { return proto.CompactTextString(m) }
func (*QosMarking) ProtoMessage()               {}
func (*QosMarking) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{7} }

func (m *QosMarking) GetDot1QPcpRewriteEn() bool {
	if m != nil {
		return m.Dot1QPcpRewriteEn
	}
	return false
}

func (m *QosMarking) GetDot1QPcp() uint32 {
	if m != nil {
		return m.Dot1QPcp
	}
	return 0
}

func (m *QosMarking) GetIpDscpRewriteEn() bool {
	if m != nil {
		return m.IpDscpRewriteEn
	}
	return false
}

func (m *QosMarking) GetIpDscp() uint32 {
	if m != nil {
		return m.IpDscp
	}
	return 0
}

// QosClass specification
type QosClassSpec struct {
	Meta *ObjectMeta `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	// key_or_handle is QosClass's key or handle
	KeyOrHandle    *QosClassKeyHandle `protobuf:"bytes,2,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty" venice:"key"`
	Mtu            uint32             `protobuf:"varint,3,opt,name=mtu,proto3" json:"mtu,omitempty"`
	Buffer         *QosBuffer         `protobuf:"bytes,4,opt,name=buffer" json:"buffer,omitempty"`
	Pfc            *QosPFC            `protobuf:"bytes,5,opt,name=pfc" json:"pfc,omitempty"`
	Sched          *QosSched          `protobuf:"bytes,6,opt,name=sched" json:"sched,omitempty"`
	UplinkClassMap *QosUplinkClassMap `protobuf:"bytes,7,opt,name=uplink_class_map,json=uplinkClassMap" json:"uplink_class_map,omitempty"`
	Marking        *QosMarking        `protobuf:"bytes,8,opt,name=marking" json:"marking,omitempty"`
}

func (m *QosClassSpec) Reset()                    { *m = QosClassSpec{} }
func (m *QosClassSpec) String() string            { return proto.CompactTextString(m) }
func (*QosClassSpec) ProtoMessage()               {}
func (*QosClassSpec) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{8} }

func (m *QosClassSpec) GetMeta() *ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *QosClassSpec) GetKeyOrHandle() *QosClassKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

func (m *QosClassSpec) GetMtu() uint32 {
	if m != nil {
		return m.Mtu
	}
	return 0
}

func (m *QosClassSpec) GetBuffer() *QosBuffer {
	if m != nil {
		return m.Buffer
	}
	return nil
}

func (m *QosClassSpec) GetPfc() *QosPFC {
	if m != nil {
		return m.Pfc
	}
	return nil
}

func (m *QosClassSpec) GetSched() *QosSched {
	if m != nil {
		return m.Sched
	}
	return nil
}

func (m *QosClassSpec) GetUplinkClassMap() *QosUplinkClassMap {
	if m != nil {
		return m.UplinkClassMap
	}
	return nil
}

func (m *QosClassSpec) GetMarking() *QosMarking {
	if m != nil {
		return m.Marking
	}
	return nil
}

// QosClassRequestMsg is batched request to create/update the QosClasss
type QosClassRequestMsg struct {
	Request []*QosClassSpec `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *QosClassRequestMsg) Reset()                    { *m = QosClassRequestMsg{} }
func (m *QosClassRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*QosClassRequestMsg) ProtoMessage()               {}
func (*QosClassRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{9} }

func (m *QosClassRequestMsg) GetRequest() []*QosClassSpec {
	if m != nil {
		return m.Request
	}
	return nil
}

// QosClassStatus represents the operational status of QosClass
type QosClassStatus struct {
	QosClassHandle uint64 `protobuf:"fixed64,1,opt,name=qos_class_handle,json=qosClassHandle,proto3" json:"qos_class_handle,omitempty"`
}

func (m *QosClassStatus) Reset()                    { *m = QosClassStatus{} }
func (m *QosClassStatus) String() string            { return proto.CompactTextString(m) }
func (*QosClassStatus) ProtoMessage()               {}
func (*QosClassStatus) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{10} }

func (m *QosClassStatus) GetQosClassHandle() uint64 {
	if m != nil {
		return m.QosClassHandle
	}
	return 0
}

// QosClassResponse is response to one QosClassSpec
type QosClassResponse struct {
	ApiStatus ApiStatus       `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty"`
	Status    *QosClassStatus `protobuf:"bytes,2,opt,name=status" json:"status,omitempty"`
}

func (m *QosClassResponse) Reset()                    { *m = QosClassResponse{} }
func (m *QosClassResponse) String() string            { return proto.CompactTextString(m) }
func (*QosClassResponse) ProtoMessage()               {}
func (*QosClassResponse) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{11} }

func (m *QosClassResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *QosClassResponse) GetStatus() *QosClassStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

// QosClassResponseMsg is response to QosClassRequestMsg
type QosClassResponseMsg struct {
	Response []*QosClassResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *QosClassResponseMsg) Reset()                    { *m = QosClassResponseMsg{} }
func (m *QosClassResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*QosClassResponseMsg) ProtoMessage()               {}
func (*QosClassResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{12} }

func (m *QosClassResponseMsg) GetResponse() []*QosClassResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

// QosClassDeleteRequest  is used to delete a QosClass object
type QosClassDeleteRequest struct {
	Meta *ObjectMeta `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	// key_or_handle is to identify QosClass being deleted
	KeyOrHandle *QosClassKeyHandle `protobuf:"bytes,2,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty" venice:"key"`
}

func (m *QosClassDeleteRequest) Reset()                    { *m = QosClassDeleteRequest{} }
func (m *QosClassDeleteRequest) String() string            { return proto.CompactTextString(m) }
func (*QosClassDeleteRequest) ProtoMessage()               {}
func (*QosClassDeleteRequest) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{13} }

func (m *QosClassDeleteRequest) GetMeta() *ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *QosClassDeleteRequest) GetKeyOrHandle() *QosClassKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

// QosClassDeleteRequestMsg is used to delete a batch of QosClasss
type QosClassDeleteRequestMsg struct {
	Request []*QosClassDeleteRequest `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *QosClassDeleteRequestMsg) Reset()                    { *m = QosClassDeleteRequestMsg{} }
func (m *QosClassDeleteRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*QosClassDeleteRequestMsg) ProtoMessage()               {}
func (*QosClassDeleteRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{14} }

func (m *QosClassDeleteRequestMsg) GetRequest() []*QosClassDeleteRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

// QosClassDeleteResponseMsg is batched response to QosClassDeleteRequestMsg
type QosClassDeleteResponseMsg struct {
	ApiStatus []ApiStatus `protobuf:"varint,1,rep,packed,name=api_status,json=apiStatus,enum=types.ApiStatus" json:"api_status,omitempty"`
}

func (m *QosClassDeleteResponseMsg) Reset()                    { *m = QosClassDeleteResponseMsg{} }
func (m *QosClassDeleteResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*QosClassDeleteResponseMsg) ProtoMessage()               {}
func (*QosClassDeleteResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{15} }

func (m *QosClassDeleteResponseMsg) GetApiStatus() []ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return nil
}

// QosClassStats captures all the statistics of given QosClass
type QosClassStats struct {
}

func (m *QosClassStats) Reset()                    { *m = QosClassStats{} }
func (m *QosClassStats) String() string            { return proto.CompactTextString(m) }
func (*QosClassStats) ProtoMessage()               {}
func (*QosClassStats) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{16} }

// QosClassGetRequest is used to get information about a QosClass
type QosClassGetRequest struct {
	Meta *ObjectMeta `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	// key_or_handle is to identify QosClass being deleted
	KeyOrHandle *QosClassKeyHandle `protobuf:"bytes,2,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty" venice:"key"`
}

func (m *QosClassGetRequest) Reset()                    { *m = QosClassGetRequest{} }
func (m *QosClassGetRequest) String() string            { return proto.CompactTextString(m) }
func (*QosClassGetRequest) ProtoMessage()               {}
func (*QosClassGetRequest) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{17} }

func (m *QosClassGetRequest) GetMeta() *ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *QosClassGetRequest) GetKeyOrHandle() *QosClassKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

// Batched request message to get the stats about a batch of QosClasss
type QosClassGetRequestMsg struct {
	Request []*QosClassGetRequest `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *QosClassGetRequestMsg) Reset()                    { *m = QosClassGetRequestMsg{} }
func (m *QosClassGetRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*QosClassGetRequestMsg) ProtoMessage()               {}
func (*QosClassGetRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{18} }

func (m *QosClassGetRequestMsg) GetRequest() []*QosClassGetRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

// QosClassGetResponse captures all the information about a QosClass
type QosClassGetResponse struct {
	Spec   *QosClassSpec   `protobuf:"bytes,1,opt,name=spec" json:"spec,omitempty"`
	Status *QosClassStatus `protobuf:"bytes,2,opt,name=status" json:"status,omitempty"`
	Stats  *QosClassStats  `protobuf:"bytes,3,opt,name=stats" json:"stats,omitempty"`
}

func (m *QosClassGetResponse) Reset()                    { *m = QosClassGetResponse{} }
func (m *QosClassGetResponse) String() string            { return proto.CompactTextString(m) }
func (*QosClassGetResponse) ProtoMessage()               {}
func (*QosClassGetResponse) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{19} }

func (m *QosClassGetResponse) GetSpec() *QosClassSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *QosClassGetResponse) GetStatus() *QosClassStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *QosClassGetResponse) GetStats() *QosClassStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

// QosClassGetResponseMsg is response to QosClassGetRequestMsg
type QosClassGetResponseMsg struct {
	Response []*QosClassGetResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *QosClassGetResponseMsg) Reset()                    { *m = QosClassGetResponseMsg{} }
func (m *QosClassGetResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*QosClassGetResponseMsg) ProtoMessage()               {}
func (*QosClassGetResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{20} }

func (m *QosClassGetResponseMsg) GetResponse() []*QosClassGetResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

// CoppPolicerKeyHandle uniquely identifies a CoppPolicer
type CoppPolicerKeyHandle struct {
	// Types that are valid to be assigned to KeyOrHandle:
	//	*CoppPolicerKeyHandle_CoppType
	//	*CoppPolicerKeyHandle_CoppPolicerHandle
	KeyOrHandle isCoppPolicerKeyHandle_KeyOrHandle `protobuf_oneof:"key_or_handle"`
}

func (m *CoppPolicerKeyHandle) Reset()                    { *m = CoppPolicerKeyHandle{} }
func (m *CoppPolicerKeyHandle) String() string            { return proto.CompactTextString(m) }
func (*CoppPolicerKeyHandle) ProtoMessage()               {}
func (*CoppPolicerKeyHandle) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{21} }

type isCoppPolicerKeyHandle_KeyOrHandle interface {
	isCoppPolicerKeyHandle_KeyOrHandle()
	MarshalTo([]byte) (int, error)
	Size() int
}

type CoppPolicerKeyHandle_CoppType struct {
	CoppType CoppType `protobuf:"varint,1,opt,name=copp_type,json=coppType,proto3,enum=qos.CoppType,oneof"`
}
type CoppPolicerKeyHandle_CoppPolicerHandle struct {
	CoppPolicerHandle uint64 `protobuf:"fixed64,2,opt,name=copp_policer_handle,json=coppPolicerHandle,proto3,oneof"`
}

func (*CoppPolicerKeyHandle_CoppType) isCoppPolicerKeyHandle_KeyOrHandle()          {}
func (*CoppPolicerKeyHandle_CoppPolicerHandle) isCoppPolicerKeyHandle_KeyOrHandle() {}

func (m *CoppPolicerKeyHandle) GetKeyOrHandle() isCoppPolicerKeyHandle_KeyOrHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

func (m *CoppPolicerKeyHandle) GetCoppType() CoppType {
	if x, ok := m.GetKeyOrHandle().(*CoppPolicerKeyHandle_CoppType); ok {
		return x.CoppType
	}
	return CoppType_COPP_TYPE_FLOW_MISS
}

func (m *CoppPolicerKeyHandle) GetCoppPolicerHandle() uint64 {
	if x, ok := m.GetKeyOrHandle().(*CoppPolicerKeyHandle_CoppPolicerHandle); ok {
		return x.CoppPolicerHandle
	}
	return 0
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*CoppPolicerKeyHandle) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _CoppPolicerKeyHandle_OneofMarshaler, _CoppPolicerKeyHandle_OneofUnmarshaler, _CoppPolicerKeyHandle_OneofSizer, []interface{}{
		(*CoppPolicerKeyHandle_CoppType)(nil),
		(*CoppPolicerKeyHandle_CoppPolicerHandle)(nil),
	}
}

func _CoppPolicerKeyHandle_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*CoppPolicerKeyHandle)
	// key_or_handle
	switch x := m.KeyOrHandle.(type) {
	case *CoppPolicerKeyHandle_CoppType:
		_ = b.EncodeVarint(1<<3 | proto.WireVarint)
		_ = b.EncodeVarint(uint64(x.CoppType))
	case *CoppPolicerKeyHandle_CoppPolicerHandle:
		_ = b.EncodeVarint(2<<3 | proto.WireFixed64)
		_ = b.EncodeFixed64(uint64(x.CoppPolicerHandle))
	case nil:
	default:
		return fmt.Errorf("CoppPolicerKeyHandle.KeyOrHandle has unexpected type %T", x)
	}
	return nil
}

func _CoppPolicerKeyHandle_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*CoppPolicerKeyHandle)
	switch tag {
	case 1: // key_or_handle.copp_type
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.KeyOrHandle = &CoppPolicerKeyHandle_CoppType{CoppType(x)}
		return true, err
	case 2: // key_or_handle.copp_policer_handle
		if wire != proto.WireFixed64 {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeFixed64()
		m.KeyOrHandle = &CoppPolicerKeyHandle_CoppPolicerHandle{x}
		return true, err
	default:
		return false, nil
	}
}

func _CoppPolicerKeyHandle_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*CoppPolicerKeyHandle)
	// key_or_handle
	switch x := m.KeyOrHandle.(type) {
	case *CoppPolicerKeyHandle_CoppType:
		n += proto.SizeVarint(1<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.CoppType))
	case *CoppPolicerKeyHandle_CoppPolicerHandle:
		n += proto.SizeVarint(2<<3 | proto.WireFixed64)
		n += 8
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Specifications of a CoppPolicer
type CoppPolicerSpec struct {
	Meta *ObjectMeta `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	// key_or_handle is CoppPolicer's unique identifier
	KeyOrHandle *CoppPolicerKeyHandle `protobuf:"bytes,2,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty" venice:"key"`
	Policer     *PolicerSpec          `protobuf:"bytes,3,opt,name=policer" json:"policer,omitempty"`
}

func (m *CoppPolicerSpec) Reset()                    { *m = CoppPolicerSpec{} }
func (m *CoppPolicerSpec) String() string            { return proto.CompactTextString(m) }
func (*CoppPolicerSpec) ProtoMessage()               {}
func (*CoppPolicerSpec) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{22} }

func (m *CoppPolicerSpec) GetMeta() *ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *CoppPolicerSpec) GetKeyOrHandle() *CoppPolicerKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

func (m *CoppPolicerSpec) GetPolicer() *PolicerSpec {
	if m != nil {
		return m.Policer
	}
	return nil
}

// Batched requests to create/update CoppPolicers
type CoppPolicerRequestMsg struct {
	Request []*CoppPolicerSpec `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *CoppPolicerRequestMsg) Reset()                    { *m = CoppPolicerRequestMsg{} }
func (m *CoppPolicerRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*CoppPolicerRequestMsg) ProtoMessage()               {}
func (*CoppPolicerRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{23} }

func (m *CoppPolicerRequestMsg) GetRequest() []*CoppPolicerSpec {
	if m != nil {
		return m.Request
	}
	return nil
}

type CoppPolicerStatus struct {
	CoppPolicerHandle uint64 `protobuf:"fixed64,1,opt,name=copp_policer_handle,json=coppPolicerHandle,proto3" json:"copp_policer_handle,omitempty"`
}

func (m *CoppPolicerStatus) Reset()                    { *m = CoppPolicerStatus{} }
func (m *CoppPolicerStatus) String() string            { return proto.CompactTextString(m) }
func (*CoppPolicerStatus) ProtoMessage()               {}
func (*CoppPolicerStatus) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{24} }

func (m *CoppPolicerStatus) GetCoppPolicerHandle() uint64 {
	if m != nil {
		return m.CoppPolicerHandle
	}
	return 0
}

// CoppPolicerResponse is response to one CoppPolicer
type CoppPolicerResponse struct {
	ApiStatus ApiStatus          `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty"`
	Status    *CoppPolicerStatus `protobuf:"bytes,2,opt,name=status" json:"status,omitempty"`
}

func (m *CoppPolicerResponse) Reset()                    { *m = CoppPolicerResponse{} }
func (m *CoppPolicerResponse) String() string            { return proto.CompactTextString(m) }
func (*CoppPolicerResponse) ProtoMessage()               {}
func (*CoppPolicerResponse) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{25} }

func (m *CoppPolicerResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *CoppPolicerResponse) GetStatus() *CoppPolicerStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

// Batched responses to create/update CoppPolicers
type CoppPolicerResponseMsg struct {
	Response []*CoppPolicerResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *CoppPolicerResponseMsg) Reset()                    { *m = CoppPolicerResponseMsg{} }
func (m *CoppPolicerResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*CoppPolicerResponseMsg) ProtoMessage()               {}
func (*CoppPolicerResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{26} }

func (m *CoppPolicerResponseMsg) GetResponse() []*CoppPolicerResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

// CoppPolicerGetRequest is used to get information about a CoppPolicer
type CoppPolicerGetRequest struct {
	Meta *ObjectMeta `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	// key_or_handle is CoppPolicer's unique identifier
	KeyOrHandle *CoppPolicerKeyHandle `protobuf:"bytes,2,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty" venice:"key"`
}

func (m *CoppPolicerGetRequest) Reset()                    { *m = CoppPolicerGetRequest{} }
func (m *CoppPolicerGetRequest) String() string            { return proto.CompactTextString(m) }
func (*CoppPolicerGetRequest) ProtoMessage()               {}
func (*CoppPolicerGetRequest) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{27} }

func (m *CoppPolicerGetRequest) GetMeta() *ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *CoppPolicerGetRequest) GetKeyOrHandle() *CoppPolicerKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

type CoppPolicerGetRequestMsg struct {
	Request []*CoppPolicerGetRequest `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *CoppPolicerGetRequestMsg) Reset()                    { *m = CoppPolicerGetRequestMsg{} }
func (m *CoppPolicerGetRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*CoppPolicerGetRequestMsg) ProtoMessage()               {}
func (*CoppPolicerGetRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{28} }

func (m *CoppPolicerGetRequestMsg) GetRequest() []*CoppPolicerGetRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

// CoppPolicerGetResponse captures all the information about a CoppPolicer
type CoppPolicerGetResponse struct {
	Spec   *CoppPolicerSpec   `protobuf:"bytes,1,opt,name=spec" json:"spec,omitempty"`
	Status *CoppPolicerStatus `protobuf:"bytes,2,opt,name=status" json:"status,omitempty"`
	Stats  *PolicerStats      `protobuf:"bytes,3,opt,name=stats" json:"stats,omitempty"`
}

func (m *CoppPolicerGetResponse) Reset()                    { *m = CoppPolicerGetResponse{} }
func (m *CoppPolicerGetResponse) String() string            { return proto.CompactTextString(m) }
func (*CoppPolicerGetResponse) ProtoMessage()               {}
func (*CoppPolicerGetResponse) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{29} }

func (m *CoppPolicerGetResponse) GetSpec() *CoppPolicerSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *CoppPolicerGetResponse) GetStatus() *CoppPolicerStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *CoppPolicerGetResponse) GetStats() *PolicerStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

// CoppPolicerGetResponseMsg is response to CoppPolicerGetRequestMsg
type CoppPolicerGetResponseMsg struct {
	Response []*CoppPolicerGetResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *CoppPolicerGetResponseMsg) Reset()                    { *m = CoppPolicerGetResponseMsg{} }
func (m *CoppPolicerGetResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*CoppPolicerGetResponseMsg) ProtoMessage()               {}
func (*CoppPolicerGetResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{30} }

func (m *CoppPolicerGetResponseMsg) GetResponse() []*CoppPolicerGetResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

func init() {
	proto.RegisterType((*PolicerSpec)(nil), "qos.PolicerSpec")
	proto.RegisterType((*PolicerStats)(nil), "qos.PolicerStats")
	proto.RegisterType((*QosClassKeyHandle)(nil), "qos.QosClassKeyHandle")
	proto.RegisterType((*QosBuffer)(nil), "qos.QosBuffer")
	proto.RegisterType((*QosPFC)(nil), "qos.QosPFC")
	proto.RegisterType((*QosSched)(nil), "qos.QosSched")
	proto.RegisterType((*QosSched_DWRRInfo)(nil), "qos.QosSched.DWRRInfo")
	proto.RegisterType((*QosSched_StrictPriorityInfo)(nil), "qos.QosSched.StrictPriorityInfo")
	proto.RegisterType((*QosUplinkClassMap)(nil), "qos.QosUplinkClassMap")
	proto.RegisterType((*QosMarking)(nil), "qos.QosMarking")
	proto.RegisterType((*QosClassSpec)(nil), "qos.QosClassSpec")
	proto.RegisterType((*QosClassRequestMsg)(nil), "qos.QosClassRequestMsg")
	proto.RegisterType((*QosClassStatus)(nil), "qos.QosClassStatus")
	proto.RegisterType((*QosClassResponse)(nil), "qos.QosClassResponse")
	proto.RegisterType((*QosClassResponseMsg)(nil), "qos.QosClassResponseMsg")
	proto.RegisterType((*QosClassDeleteRequest)(nil), "qos.QosClassDeleteRequest")
	proto.RegisterType((*QosClassDeleteRequestMsg)(nil), "qos.QosClassDeleteRequestMsg")
	proto.RegisterType((*QosClassDeleteResponseMsg)(nil), "qos.QosClassDeleteResponseMsg")
	proto.RegisterType((*QosClassStats)(nil), "qos.QosClassStats")
	proto.RegisterType((*QosClassGetRequest)(nil), "qos.QosClassGetRequest")
	proto.RegisterType((*QosClassGetRequestMsg)(nil), "qos.QosClassGetRequestMsg")
	proto.RegisterType((*QosClassGetResponse)(nil), "qos.QosClassGetResponse")
	proto.RegisterType((*QosClassGetResponseMsg)(nil), "qos.QosClassGetResponseMsg")
	proto.RegisterType((*CoppPolicerKeyHandle)(nil), "qos.CoppPolicerKeyHandle")
	proto.RegisterType((*CoppPolicerSpec)(nil), "qos.CoppPolicerSpec")
	proto.RegisterType((*CoppPolicerRequestMsg)(nil), "qos.CoppPolicerRequestMsg")
	proto.RegisterType((*CoppPolicerStatus)(nil), "qos.CoppPolicerStatus")
	proto.RegisterType((*CoppPolicerResponse)(nil), "qos.CoppPolicerResponse")
	proto.RegisterType((*CoppPolicerResponseMsg)(nil), "qos.CoppPolicerResponseMsg")
	proto.RegisterType((*CoppPolicerGetRequest)(nil), "qos.CoppPolicerGetRequest")
	proto.RegisterType((*CoppPolicerGetRequestMsg)(nil), "qos.CoppPolicerGetRequestMsg")
	proto.RegisterType((*CoppPolicerGetResponse)(nil), "qos.CoppPolicerGetResponse")
	proto.RegisterType((*CoppPolicerGetResponseMsg)(nil), "qos.CoppPolicerGetResponseMsg")
	proto.RegisterEnum("qos.QosGroup", QosGroup_name, QosGroup_value)
	proto.RegisterEnum("qos.CoppType", CoppType_name, CoppType_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for QOS service

type QOSClient interface {
	// QOS class related APIs
	QosClassCreate(ctx context.Context, in *QosClassRequestMsg, opts ...grpc.CallOption) (*QosClassResponseMsg, error)
	QosClassUpdate(ctx context.Context, in *QosClassRequestMsg, opts ...grpc.CallOption) (*QosClassResponseMsg, error)
	QosClassDelete(ctx context.Context, in *QosClassDeleteRequestMsg, opts ...grpc.CallOption) (*QosClassDeleteResponseMsg, error)
	QosClassGet(ctx context.Context, in *QosClassGetRequestMsg, opts ...grpc.CallOption) (*QosClassGetResponseMsg, error)
	// Copp related APIs
	CoppPolicerUpdate(ctx context.Context, in *CoppPolicerRequestMsg, opts ...grpc.CallOption) (*CoppPolicerResponseMsg, error)
	CoppPolicerGet(ctx context.Context, in *CoppPolicerGetRequestMsg, opts ...grpc.CallOption) (*CoppPolicerGetResponseMsg, error)
}

type qOSClient struct {
	cc *grpc.ClientConn
}

func NewQOSClient(cc *grpc.ClientConn) QOSClient {
	return &qOSClient{cc}
}

func (c *qOSClient) QosClassCreate(ctx context.Context, in *QosClassRequestMsg, opts ...grpc.CallOption) (*QosClassResponseMsg, error) {
	out := new(QosClassResponseMsg)
	err := grpc.Invoke(ctx, "/qos.QOS/QosClassCreate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *qOSClient) QosClassUpdate(ctx context.Context, in *QosClassRequestMsg, opts ...grpc.CallOption) (*QosClassResponseMsg, error) {
	out := new(QosClassResponseMsg)
	err := grpc.Invoke(ctx, "/qos.QOS/QosClassUpdate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *qOSClient) QosClassDelete(ctx context.Context, in *QosClassDeleteRequestMsg, opts ...grpc.CallOption) (*QosClassDeleteResponseMsg, error) {
	out := new(QosClassDeleteResponseMsg)
	err := grpc.Invoke(ctx, "/qos.QOS/QosClassDelete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *qOSClient) QosClassGet(ctx context.Context, in *QosClassGetRequestMsg, opts ...grpc.CallOption) (*QosClassGetResponseMsg, error) {
	out := new(QosClassGetResponseMsg)
	err := grpc.Invoke(ctx, "/qos.QOS/QosClassGet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *qOSClient) CoppPolicerUpdate(ctx context.Context, in *CoppPolicerRequestMsg, opts ...grpc.CallOption) (*CoppPolicerResponseMsg, error) {
	out := new(CoppPolicerResponseMsg)
	err := grpc.Invoke(ctx, "/qos.QOS/CoppPolicerUpdate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *qOSClient) CoppPolicerGet(ctx context.Context, in *CoppPolicerGetRequestMsg, opts ...grpc.CallOption) (*CoppPolicerGetResponseMsg, error) {
	out := new(CoppPolicerGetResponseMsg)
	err := grpc.Invoke(ctx, "/qos.QOS/CoppPolicerGet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for QOS service

type QOSServer interface {
	// QOS class related APIs
	QosClassCreate(context.Context, *QosClassRequestMsg) (*QosClassResponseMsg, error)
	QosClassUpdate(context.Context, *QosClassRequestMsg) (*QosClassResponseMsg, error)
	QosClassDelete(context.Context, *QosClassDeleteRequestMsg) (*QosClassDeleteResponseMsg, error)
	QosClassGet(context.Context, *QosClassGetRequestMsg) (*QosClassGetResponseMsg, error)
	// Copp related APIs
	CoppPolicerUpdate(context.Context, *CoppPolicerRequestMsg) (*CoppPolicerResponseMsg, error)
	CoppPolicerGet(context.Context, *CoppPolicerGetRequestMsg) (*CoppPolicerGetResponseMsg, error)
}

func RegisterQOSServer(s *grpc.Server, srv QOSServer) {
	s.RegisterService(&_QOS_serviceDesc, srv)
}

func _QOS_QosClassCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QosClassRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QOSServer).QosClassCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/qos.QOS/QosClassCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QOSServer).QosClassCreate(ctx, req.(*QosClassRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _QOS_QosClassUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QosClassRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QOSServer).QosClassUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/qos.QOS/QosClassUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QOSServer).QosClassUpdate(ctx, req.(*QosClassRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _QOS_QosClassDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QosClassDeleteRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QOSServer).QosClassDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/qos.QOS/QosClassDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QOSServer).QosClassDelete(ctx, req.(*QosClassDeleteRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _QOS_QosClassGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QosClassGetRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QOSServer).QosClassGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/qos.QOS/QosClassGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QOSServer).QosClassGet(ctx, req.(*QosClassGetRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _QOS_CoppPolicerUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CoppPolicerRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QOSServer).CoppPolicerUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/qos.QOS/CoppPolicerUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QOSServer).CoppPolicerUpdate(ctx, req.(*CoppPolicerRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _QOS_CoppPolicerGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CoppPolicerGetRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QOSServer).CoppPolicerGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/qos.QOS/CoppPolicerGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QOSServer).CoppPolicerGet(ctx, req.(*CoppPolicerGetRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

var _QOS_serviceDesc = grpc.ServiceDesc{
	ServiceName: "qos.QOS",
	HandlerType: (*QOSServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "QosClassCreate",
			Handler:    _QOS_QosClassCreate_Handler,
		},
		{
			MethodName: "QosClassUpdate",
			Handler:    _QOS_QosClassUpdate_Handler,
		},
		{
			MethodName: "QosClassDelete",
			Handler:    _QOS_QosClassDelete_Handler,
		},
		{
			MethodName: "QosClassGet",
			Handler:    _QOS_QosClassGet_Handler,
		},
		{
			MethodName: "CoppPolicerUpdate",
			Handler:    _QOS_CoppPolicerUpdate_Handler,
		},
		{
			MethodName: "CoppPolicerGet",
			Handler:    _QOS_CoppPolicerGet_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "qos.proto",
}

func (m *PolicerSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PolicerSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.BpsRate != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.BpsRate))
	}
	if m.BurstSize != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.BurstSize))
	}
	return i, nil
}

func (m *PolicerStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PolicerStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PermittedPackets != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.PermittedPackets))
	}
	if m.PermittedBytes != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.PermittedBytes))
	}
	if m.DroppedPackets != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.DroppedPackets))
	}
	if m.DroppedBytes != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.DroppedBytes))
	}
	return i, nil
}

func (m *QosClassKeyHandle) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosClassKeyHandle) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.KeyOrHandle != nil {
		nn1, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn1
	}
	return i, nil
}

func (m *QosClassKeyHandle_QosGroup) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x8
	i++
	i = encodeVarintQos(dAtA, i, uint64(m.QosGroup))
	return i, nil
}
func (m *QosClassKeyHandle_QosClassHandle) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x11
	i++
	i = encodeFixed64Qos(dAtA, i, uint64(m.QosClassHandle))
	return i, nil
}
func (m *QosBuffer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosBuffer) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ReservedMtus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.ReservedMtus))
	}
	if m.HeadroomMtus != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.HeadroomMtus))
	}
	if m.XonThreshold != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.XonThreshold))
	}
	if m.XoffClearLimit != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.XoffClearLimit))
	}
	return i, nil
}

func (m *QosPFC) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosPFC) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PfcCos) > 0 {
		dAtA3 := make([]byte, len(m.PfcCos)*10)
		var j2 int
		for _, num := range m.PfcCos {
			for num >= 1<<7 {
				dAtA3[j2] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j2++
			}
			dAtA3[j2] = uint8(num)
			j2++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintQos(dAtA, i, uint64(j2))
		i += copy(dAtA[i:], dAtA3[:j2])
	}
	return i, nil
}

func (m *QosSched) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosSched) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SchedType != nil {
		nn4, err := m.SchedType.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn4
	}
	return i, nil
}

func (m *QosSched_Dwrr) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Dwrr != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.Dwrr.Size()))
		n5, err := m.Dwrr.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	return i, nil
}
func (m *QosSched_Strict) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Strict != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.Strict.Size()))
		n6, err := m.Strict.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}
func (m *QosSched_DWRRInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosSched_DWRRInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.BwPercentage != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.BwPercentage))
	}
	return i, nil
}

func (m *QosSched_StrictPriorityInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosSched_StrictPriorityInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Bps != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.Bps))
	}
	return i, nil
}

func (m *QosUplinkClassMap) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosUplinkClassMap) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Dot1QPcp != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.Dot1QPcp))
	}
	if len(m.IpDscp) > 0 {
		dAtA8 := make([]byte, len(m.IpDscp)*10)
		var j7 int
		for _, num := range m.IpDscp {
			for num >= 1<<7 {
				dAtA8[j7] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j7++
			}
			dAtA8[j7] = uint8(num)
			j7++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintQos(dAtA, i, uint64(j7))
		i += copy(dAtA[i:], dAtA8[:j7])
	}
	return i, nil
}

func (m *QosMarking) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosMarking) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Dot1QPcpRewriteEn {
		dAtA[i] = 0x8
		i++
		if m.Dot1QPcpRewriteEn {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Dot1QPcp != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.Dot1QPcp))
	}
	if m.IpDscpRewriteEn {
		dAtA[i] = 0x18
		i++
		if m.IpDscpRewriteEn {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IpDscp != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.IpDscp))
	}
	return i, nil
}

func (m *QosClassSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosClassSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.Meta.Size()))
		n9, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.KeyOrHandle != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n10, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.Mtu != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.Mtu))
	}
	if m.Buffer != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.Buffer.Size()))
		n11, err := m.Buffer.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if m.Pfc != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.Pfc.Size()))
		n12, err := m.Pfc.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if m.Sched != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.Sched.Size()))
		n13, err := m.Sched.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if m.UplinkClassMap != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.UplinkClassMap.Size()))
		n14, err := m.UplinkClassMap.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	if m.Marking != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.Marking.Size()))
		n15, err := m.Marking.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	return i, nil
}

func (m *QosClassRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosClassRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintQos(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *QosClassStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosClassStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.QosClassHandle != 0 {
		dAtA[i] = 0x9
		i++
		i = encodeFixed64Qos(dAtA, i, uint64(m.QosClassHandle))
	}
	return i, nil
}

func (m *QosClassResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosClassResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.ApiStatus))
	}
	if m.Status != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.Status.Size()))
		n16, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	return i, nil
}

func (m *QosClassResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosClassResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintQos(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *QosClassDeleteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosClassDeleteRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.Meta.Size()))
		n17, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	if m.KeyOrHandle != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n18, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	return i, nil
}

func (m *QosClassDeleteRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosClassDeleteRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintQos(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *QosClassDeleteResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosClassDeleteResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ApiStatus) > 0 {
		dAtA20 := make([]byte, len(m.ApiStatus)*10)
		var j19 int
		for _, num := range m.ApiStatus {
			for num >= 1<<7 {
				dAtA20[j19] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j19++
			}
			dAtA20[j19] = uint8(num)
			j19++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintQos(dAtA, i, uint64(j19))
		i += copy(dAtA[i:], dAtA20[:j19])
	}
	return i, nil
}

func (m *QosClassStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosClassStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *QosClassGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosClassGetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.Meta.Size()))
		n21, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	if m.KeyOrHandle != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n22, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	return i, nil
}

func (m *QosClassGetRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosClassGetRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintQos(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *QosClassGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosClassGetResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Spec != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.Spec.Size()))
		n23, err := m.Spec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	if m.Status != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.Status.Size()))
		n24, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	if m.Stats != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.Stats.Size()))
		n25, err := m.Stats.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	return i, nil
}

func (m *QosClassGetResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosClassGetResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintQos(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CoppPolicerKeyHandle) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CoppPolicerKeyHandle) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.KeyOrHandle != nil {
		nn26, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn26
	}
	return i, nil
}

func (m *CoppPolicerKeyHandle_CoppType) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x8
	i++
	i = encodeVarintQos(dAtA, i, uint64(m.CoppType))
	return i, nil
}
func (m *CoppPolicerKeyHandle_CoppPolicerHandle) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x11
	i++
	i = encodeFixed64Qos(dAtA, i, uint64(m.CoppPolicerHandle))
	return i, nil
}
func (m *CoppPolicerSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CoppPolicerSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.Meta.Size()))
		n27, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n27
	}
	if m.KeyOrHandle != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n28, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n28
	}
	if m.Policer != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.Policer.Size()))
		n29, err := m.Policer.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n29
	}
	return i, nil
}

func (m *CoppPolicerRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CoppPolicerRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintQos(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CoppPolicerStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CoppPolicerStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CoppPolicerHandle != 0 {
		dAtA[i] = 0x9
		i++
		i = encodeFixed64Qos(dAtA, i, uint64(m.CoppPolicerHandle))
	}
	return i, nil
}

func (m *CoppPolicerResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CoppPolicerResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.ApiStatus))
	}
	if m.Status != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.Status.Size()))
		n30, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n30
	}
	return i, nil
}

func (m *CoppPolicerResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CoppPolicerResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintQos(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CoppPolicerGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CoppPolicerGetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.Meta.Size()))
		n31, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n31
	}
	if m.KeyOrHandle != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n32, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n32
	}
	return i, nil
}

func (m *CoppPolicerGetRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CoppPolicerGetRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintQos(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CoppPolicerGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CoppPolicerGetResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Spec != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.Spec.Size()))
		n33, err := m.Spec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n33
	}
	if m.Status != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.Status.Size()))
		n34, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n34
	}
	if m.Stats != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.Stats.Size()))
		n35, err := m.Stats.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n35
	}
	return i, nil
}

func (m *CoppPolicerGetResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CoppPolicerGetResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintQos(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func encodeFixed64Qos(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Qos(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintQos(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *PolicerSpec) Size() (n int) {
	var l int
	_ = l
	if m.BpsRate != 0 {
		n += 1 + sovQos(uint64(m.BpsRate))
	}
	if m.BurstSize != 0 {
		n += 1 + sovQos(uint64(m.BurstSize))
	}
	return n
}

func (m *PolicerStats) Size() (n int) {
	var l int
	_ = l
	if m.PermittedPackets != 0 {
		n += 1 + sovQos(uint64(m.PermittedPackets))
	}
	if m.PermittedBytes != 0 {
		n += 1 + sovQos(uint64(m.PermittedBytes))
	}
	if m.DroppedPackets != 0 {
		n += 1 + sovQos(uint64(m.DroppedPackets))
	}
	if m.DroppedBytes != 0 {
		n += 1 + sovQos(uint64(m.DroppedBytes))
	}
	return n
}

func (m *QosClassKeyHandle) Size() (n int) {
	var l int
	_ = l
	if m.KeyOrHandle != nil {
		n += m.KeyOrHandle.Size()
	}
	return n
}

func (m *QosClassKeyHandle_QosGroup) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovQos(uint64(m.QosGroup))
	return n
}
func (m *QosClassKeyHandle_QosClassHandle) Size() (n int) {
	var l int
	_ = l
	n += 9
	return n
}
func (m *QosBuffer) Size() (n int) {
	var l int
	_ = l
	if m.ReservedMtus != 0 {
		n += 1 + sovQos(uint64(m.ReservedMtus))
	}
	if m.HeadroomMtus != 0 {
		n += 1 + sovQos(uint64(m.HeadroomMtus))
	}
	if m.XonThreshold != 0 {
		n += 1 + sovQos(uint64(m.XonThreshold))
	}
	if m.XoffClearLimit != 0 {
		n += 1 + sovQos(uint64(m.XoffClearLimit))
	}
	return n
}

func (m *QosPFC) Size() (n int) {
	var l int
	_ = l
	if len(m.PfcCos) > 0 {
		l = 0
		for _, e := range m.PfcCos {
			l += sovQos(uint64(e))
		}
		n += 1 + sovQos(uint64(l)) + l
	}
	return n
}

func (m *QosSched) Size() (n int) {
	var l int
	_ = l
	if m.SchedType != nil {
		n += m.SchedType.Size()
	}
	return n
}

func (m *QosSched_Dwrr) Size() (n int) {
	var l int
	_ = l
	if m.Dwrr != nil {
		l = m.Dwrr.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	return n
}
func (m *QosSched_Strict) Size() (n int) {
	var l int
	_ = l
	if m.Strict != nil {
		l = m.Strict.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	return n
}
func (m *QosSched_DWRRInfo) Size() (n int) {
	var l int
	_ = l
	if m.BwPercentage != 0 {
		n += 1 + sovQos(uint64(m.BwPercentage))
	}
	return n
}

func (m *QosSched_StrictPriorityInfo) Size() (n int) {
	var l int
	_ = l
	if m.Bps != 0 {
		n += 1 + sovQos(uint64(m.Bps))
	}
	return n
}

func (m *QosUplinkClassMap) Size() (n int) {
	var l int
	_ = l
	if m.Dot1QPcp != 0 {
		n += 1 + sovQos(uint64(m.Dot1QPcp))
	}
	if len(m.IpDscp) > 0 {
		l = 0
		for _, e := range m.IpDscp {
			l += sovQos(uint64(e))
		}
		n += 1 + sovQos(uint64(l)) + l
	}
	return n
}

func (m *QosMarking) Size() (n int) {
	var l int
	_ = l
	if m.Dot1QPcpRewriteEn {
		n += 2
	}
	if m.Dot1QPcp != 0 {
		n += 1 + sovQos(uint64(m.Dot1QPcp))
	}
	if m.IpDscpRewriteEn {
		n += 2
	}
	if m.IpDscp != 0 {
		n += 1 + sovQos(uint64(m.IpDscp))
	}
	return n
}

func (m *QosClassSpec) Size() (n int) {
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	if m.Mtu != 0 {
		n += 1 + sovQos(uint64(m.Mtu))
	}
	if m.Buffer != nil {
		l = m.Buffer.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	if m.Pfc != nil {
		l = m.Pfc.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	if m.Sched != nil {
		l = m.Sched.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	if m.UplinkClassMap != nil {
		l = m.UplinkClassMap.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	if m.Marking != nil {
		l = m.Marking.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	return n
}

func (m *QosClassRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovQos(uint64(l))
		}
	}
	return n
}

func (m *QosClassStatus) Size() (n int) {
	var l int
	_ = l
	if m.QosClassHandle != 0 {
		n += 9
	}
	return n
}

func (m *QosClassResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovQos(uint64(m.ApiStatus))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	return n
}

func (m *QosClassResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovQos(uint64(l))
		}
	}
	return n
}

func (m *QosClassDeleteRequest) Size() (n int) {
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	return n
}

func (m *QosClassDeleteRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovQos(uint64(l))
		}
	}
	return n
}

func (m *QosClassDeleteResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.ApiStatus) > 0 {
		l = 0
		for _, e := range m.ApiStatus {
			l += sovQos(uint64(e))
		}
		n += 1 + sovQos(uint64(l)) + l
	}
	return n
}

func (m *QosClassStats) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *QosClassGetRequest) Size() (n int) {
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	return n
}

func (m *QosClassGetRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovQos(uint64(l))
		}
	}
	return n
}

func (m *QosClassGetResponse) Size() (n int) {
	var l int
	_ = l
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	if m.Stats != nil {
		l = m.Stats.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	return n
}

func (m *QosClassGetResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovQos(uint64(l))
		}
	}
	return n
}

func (m *CoppPolicerKeyHandle) Size() (n int) {
	var l int
	_ = l
	if m.KeyOrHandle != nil {
		n += m.KeyOrHandle.Size()
	}
	return n
}

func (m *CoppPolicerKeyHandle_CoppType) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovQos(uint64(m.CoppType))
	return n
}
func (m *CoppPolicerKeyHandle_CoppPolicerHandle) Size() (n int) {
	var l int
	_ = l
	n += 9
	return n
}
func (m *CoppPolicerSpec) Size() (n int) {
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	if m.Policer != nil {
		l = m.Policer.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	return n
}

func (m *CoppPolicerRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovQos(uint64(l))
		}
	}
	return n
}

func (m *CoppPolicerStatus) Size() (n int) {
	var l int
	_ = l
	if m.CoppPolicerHandle != 0 {
		n += 9
	}
	return n
}

func (m *CoppPolicerResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovQos(uint64(m.ApiStatus))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	return n
}

func (m *CoppPolicerResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovQos(uint64(l))
		}
	}
	return n
}

func (m *CoppPolicerGetRequest) Size() (n int) {
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	return n
}

func (m *CoppPolicerGetRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovQos(uint64(l))
		}
	}
	return n
}

func (m *CoppPolicerGetResponse) Size() (n int) {
	var l int
	_ = l
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	if m.Stats != nil {
		l = m.Stats.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	return n
}

func (m *CoppPolicerGetResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovQos(uint64(l))
		}
	}
	return n
}

func sovQos(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozQos(x uint64) (n int) {
	return sovQos(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *PolicerSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PolicerSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PolicerSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BpsRate", wireType)
			}
			m.BpsRate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BpsRate |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BurstSize", wireType)
			}
			m.BurstSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BurstSize |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PolicerStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PolicerStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PolicerStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PermittedPackets", wireType)
			}
			m.PermittedPackets = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PermittedPackets |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PermittedBytes", wireType)
			}
			m.PermittedBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PermittedBytes |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DroppedPackets", wireType)
			}
			m.DroppedPackets = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DroppedPackets |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DroppedBytes", wireType)
			}
			m.DroppedBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DroppedBytes |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosClassKeyHandle) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QosClassKeyHandle: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QosClassKeyHandle: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field QosGroup", wireType)
			}
			var v QosGroup
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (QosGroup(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.KeyOrHandle = &QosClassKeyHandle_QosGroup{v}
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field QosClassHandle", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.KeyOrHandle = &QosClassKeyHandle_QosClassHandle{v}
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosBuffer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QosBuffer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QosBuffer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReservedMtus", wireType)
			}
			m.ReservedMtus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReservedMtus |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeadroomMtus", wireType)
			}
			m.HeadroomMtus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HeadroomMtus |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field XonThreshold", wireType)
			}
			m.XonThreshold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.XonThreshold |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field XoffClearLimit", wireType)
			}
			m.XoffClearLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.XoffClearLimit |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosPFC) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QosPFC: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QosPFC: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowQos
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.PfcCos = append(m.PfcCos, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowQos
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthQos
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowQos
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.PfcCos = append(m.PfcCos, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PfcCos", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosSched) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QosSched: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QosSched: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dwrr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &QosSched_DWRRInfo{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.SchedType = &QosSched_Dwrr{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Strict", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &QosSched_StrictPriorityInfo{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.SchedType = &QosSched_Strict{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosSched_DWRRInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DWRRInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DWRRInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BwPercentage", wireType)
			}
			m.BwPercentage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BwPercentage |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosSched_StrictPriorityInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StrictPriorityInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StrictPriorityInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bps", wireType)
			}
			m.Bps = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Bps |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosUplinkClassMap) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QosUplinkClassMap: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QosUplinkClassMap: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dot1QPcp", wireType)
			}
			m.Dot1QPcp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Dot1QPcp |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowQos
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.IpDscp = append(m.IpDscp, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowQos
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthQos
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowQos
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.IpDscp = append(m.IpDscp, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field IpDscp", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosMarking) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QosMarking: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QosMarking: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dot1QPcpRewriteEn", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Dot1QPcpRewriteEn = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dot1QPcp", wireType)
			}
			m.Dot1QPcp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Dot1QPcp |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpDscpRewriteEn", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IpDscpRewriteEn = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpDscp", wireType)
			}
			m.IpDscp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IpDscp |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosClassSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QosClassSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QosClassSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &ObjectMeta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &QosClassKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mtu", wireType)
			}
			m.Mtu = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mtu |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Buffer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Buffer == nil {
				m.Buffer = &QosBuffer{}
			}
			if err := m.Buffer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pfc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pfc == nil {
				m.Pfc = &QosPFC{}
			}
			if err := m.Pfc.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sched", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Sched == nil {
				m.Sched = &QosSched{}
			}
			if err := m.Sched.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UplinkClassMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UplinkClassMap == nil {
				m.UplinkClassMap = &QosUplinkClassMap{}
			}
			if err := m.UplinkClassMap.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Marking", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Marking == nil {
				m.Marking = &QosMarking{}
			}
			if err := m.Marking.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosClassRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QosClassRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QosClassRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &QosClassSpec{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosClassStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QosClassStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QosClassStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field QosClassHandle", wireType)
			}
			m.QosClassHandle = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			m.QosClassHandle = uint64(dAtA[iNdEx-8])
			m.QosClassHandle |= uint64(dAtA[iNdEx-7]) << 8
			m.QosClassHandle |= uint64(dAtA[iNdEx-6]) << 16
			m.QosClassHandle |= uint64(dAtA[iNdEx-5]) << 24
			m.QosClassHandle |= uint64(dAtA[iNdEx-4]) << 32
			m.QosClassHandle |= uint64(dAtA[iNdEx-3]) << 40
			m.QosClassHandle |= uint64(dAtA[iNdEx-2]) << 48
			m.QosClassHandle |= uint64(dAtA[iNdEx-1]) << 56
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosClassResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QosClassResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QosClassResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &QosClassStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosClassResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QosClassResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QosClassResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &QosClassResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosClassDeleteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QosClassDeleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QosClassDeleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &ObjectMeta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &QosClassKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosClassDeleteRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QosClassDeleteRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QosClassDeleteRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &QosClassDeleteRequest{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosClassDeleteResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QosClassDeleteResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QosClassDeleteResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v ApiStatus
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowQos
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (ApiStatus(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ApiStatus = append(m.ApiStatus, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowQos
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthQos
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v ApiStatus
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowQos
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (ApiStatus(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ApiStatus = append(m.ApiStatus, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosClassStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QosClassStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QosClassStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosClassGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QosClassGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QosClassGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &ObjectMeta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &QosClassKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosClassGetRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QosClassGetRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QosClassGetRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &QosClassGetRequest{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosClassGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QosClassGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QosClassGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &QosClassSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &QosClassStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = &QosClassStats{}
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosClassGetResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QosClassGetResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QosClassGetResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &QosClassGetResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CoppPolicerKeyHandle) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CoppPolicerKeyHandle: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CoppPolicerKeyHandle: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CoppType", wireType)
			}
			var v CoppType
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (CoppType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.KeyOrHandle = &CoppPolicerKeyHandle_CoppType{v}
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CoppPolicerHandle", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.KeyOrHandle = &CoppPolicerKeyHandle_CoppPolicerHandle{v}
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CoppPolicerSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CoppPolicerSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CoppPolicerSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &ObjectMeta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &CoppPolicerKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Policer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Policer == nil {
				m.Policer = &PolicerSpec{}
			}
			if err := m.Policer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CoppPolicerRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CoppPolicerRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CoppPolicerRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &CoppPolicerSpec{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CoppPolicerStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CoppPolicerStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CoppPolicerStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CoppPolicerHandle", wireType)
			}
			m.CoppPolicerHandle = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			m.CoppPolicerHandle = uint64(dAtA[iNdEx-8])
			m.CoppPolicerHandle |= uint64(dAtA[iNdEx-7]) << 8
			m.CoppPolicerHandle |= uint64(dAtA[iNdEx-6]) << 16
			m.CoppPolicerHandle |= uint64(dAtA[iNdEx-5]) << 24
			m.CoppPolicerHandle |= uint64(dAtA[iNdEx-4]) << 32
			m.CoppPolicerHandle |= uint64(dAtA[iNdEx-3]) << 40
			m.CoppPolicerHandle |= uint64(dAtA[iNdEx-2]) << 48
			m.CoppPolicerHandle |= uint64(dAtA[iNdEx-1]) << 56
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CoppPolicerResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CoppPolicerResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CoppPolicerResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &CoppPolicerStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CoppPolicerResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CoppPolicerResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CoppPolicerResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &CoppPolicerResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CoppPolicerGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CoppPolicerGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CoppPolicerGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &ObjectMeta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &CoppPolicerKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CoppPolicerGetRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CoppPolicerGetRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CoppPolicerGetRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &CoppPolicerGetRequest{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CoppPolicerGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CoppPolicerGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CoppPolicerGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &CoppPolicerSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &CoppPolicerStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = &PolicerStats{}
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CoppPolicerGetResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CoppPolicerGetResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CoppPolicerGetResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &CoppPolicerGetResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipQos(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowQos
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowQos
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowQos
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthQos
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowQos
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipQos(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthQos = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowQos   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("qos.proto", fileDescriptorQos) }

var fileDescriptorQos = []byte{
	// 1615 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x58, 0x4d, 0x6f, 0x23, 0x49,
	0x19, 0x76, 0xc7, 0x1e, 0xdb, 0x79, 0xfd, 0x91, 0x76, 0x65, 0x26, 0xe3, 0x78, 0x34, 0x61, 0xe9,
	0xd5, 0xee, 0x86, 0x99, 0x55, 0x86, 0xf1, 0x2e, 0x20, 0xcd, 0x89, 0xc4, 0x76, 0x3e, 0x96, 0xd8,
	0x6e, 0x97, 0x1d, 0xed, 0x0e, 0x97, 0x56, 0xbb, 0x5d, 0x4e, 0x9a, 0xd8, 0xee, 0x4a, 0x57, 0x7b,
	0x32, 0xde, 0x03, 0x57, 0x84, 0x84, 0xc4, 0x81, 0x0b, 0x12, 0x17, 0x0e, 0xfc, 0x02, 0x24, 0x7e,
	0x03, 0x1c, 0x91, 0xb8, 0x71, 0x40, 0x68, 0xb8, 0x73, 0xe0, 0x17, 0xa0, 0xaa, 0xae, 0x76, 0x7f,
	0xd8, 0xd9, 0x55, 0x56, 0x2b, 0xed, 0x69, 0x2a, 0xef, 0xfb, 0xd4, 0x53, 0xef, 0xc7, 0x53, 0x6f,
	0x97, 0x07, 0x36, 0x6f, 0x1c, 0x76, 0x40, 0x5d, 0xc7, 0x73, 0x50, 0xfa, 0xc6, 0x61, 0xb5, 0x82,
	0xb7, 0xa0, 0x44, 0x5a, 0xb4, 0x13, 0x28, 0xe8, 0xce, 0xc4, 0xb6, 0x88, 0xdb, 0xa7, 0xc4, 0x42,
	0xbb, 0x90, 0x1f, 0x52, 0x66, 0xb8, 0xa6, 0x47, 0xaa, 0xca, 0x7b, 0xca, 0x7e, 0x09, 0xe7, 0x86,
	0x94, 0x61, 0xd3, 0x23, 0xe8, 0x29, 0xc0, 0x70, 0xee, 0x32, 0xcf, 0x60, 0xf6, 0x97, 0xa4, 0xba,
	0x21, 0x9c, 0x9b, 0xc2, 0xd2, 0xb7, 0xbf, 0x24, 0xda, 0x9f, 0x15, 0x28, 0x06, 0x4c, 0x9e, 0xe9,
	0x31, 0xf4, 0x1c, 0x2a, 0x94, 0xb8, 0x53, 0xdb, 0xf3, 0xc8, 0xc8, 0xa0, 0xa6, 0x75, 0x4d, 0x3c,
	0x26, 0x38, 0x33, 0x58, 0x5d, 0x3a, 0x74, 0xdf, 0x8e, 0x3e, 0x82, 0xad, 0x10, 0x3c, 0x5c, 0x78,
	0x84, 0x89, 0x13, 0x32, 0xb8, 0xbc, 0x34, 0x1f, 0x71, 0x2b, 0x07, 0x8e, 0x5c, 0x87, 0xd2, 0x08,
	0x67, 0xda, 0x07, 0x4a, 0x73, 0xc0, 0xf8, 0x3e, 0x94, 0x02, 0xa0, 0xcf, 0x97, 0x11, 0xb0, 0xa2,
	0x34, 0x0a, 0x36, 0xed, 0x97, 0x50, 0xe9, 0x39, 0xac, 0x31, 0x31, 0x19, 0xfb, 0x19, 0x59, 0x9c,
	0x9a, 0xb3, 0xd1, 0x84, 0xa0, 0x8f, 0x45, 0xc5, 0x8c, 0x4b, 0xd7, 0x99, 0x53, 0x11, 0x70, 0xb9,
	0x5e, 0x3a, 0xe0, 0x35, 0xec, 0x39, 0xec, 0x84, 0x1b, 0x4f, 0x53, 0x38, 0x7f, 0x23, 0xd7, 0xe8,
	0x19, 0xa8, 0x1c, 0x6d, 0x71, 0x0e, 0xe3, 0x4a, 0x30, 0x88, 0xd0, 0xb3, 0xa7, 0x29, 0x5c, 0xbe,
	0x91, 0xe4, 0x3e, 0xf3, 0xd1, 0x16, 0x94, 0xae, 0xc9, 0xc2, 0x70, 0x5c, 0x09, 0xd4, 0xfe, 0xa4,
	0xc0, 0x66, 0xcf, 0x61, 0x47, 0xf3, 0xf1, 0x98, 0xb8, 0x3c, 0x64, 0x97, 0x30, 0xe2, 0xbe, 0x21,
	0x23, 0x63, 0xea, 0xcd, 0x99, 0xec, 0x40, 0x31, 0x30, 0xb6, 0xbd, 0xb9, 0xc8, 0xeb, 0x8a, 0x98,
	0x23, 0xd7, 0x71, 0xa6, 0x3e, 0xc8, 0xef, 0x44, 0x31, 0x30, 0x06, 0xa0, 0xb7, 0xce, 0xcc, 0xf0,
	0xae, 0x5c, 0xc2, 0xae, 0x9c, 0xc9, 0x48, 0xd4, 0xa8, 0x84, 0x8b, 0x6f, 0x9d, 0xd9, 0x20, 0xb0,
	0xa1, 0x7d, 0x50, 0xdf, 0x3a, 0xe3, 0xb1, 0x61, 0x4d, 0x88, 0xe9, 0x1a, 0x13, 0x7b, 0x6a, 0x7b,
	0xa2, 0x48, 0x25, 0x5c, 0xe6, 0xf6, 0x06, 0x37, 0x9f, 0x73, 0xab, 0xf6, 0x7d, 0xc8, 0xf6, 0x1c,
	0xa6, 0x1f, 0x37, 0xd0, 0x63, 0xc8, 0xd1, 0xb1, 0x65, 0x58, 0x0e, 0x0f, 0x2e, 0xbd, 0x5f, 0xc2,
	0x59, 0x3a, 0xb6, 0x1a, 0x0e, 0xd3, 0xfe, 0xa9, 0x40, 0xbe, 0xe7, 0xb0, 0xbe, 0x75, 0x45, 0x46,
	0xe8, 0x63, 0xc8, 0x8c, 0x6e, 0x5d, 0x57, 0xc4, 0x5f, 0xa8, 0xef, 0x04, 0xc5, 0x13, 0xce, 0x83,
	0xe6, 0xe7, 0x18, 0x9f, 0xcd, 0xc6, 0xce, 0x69, 0x0a, 0x0b, 0x14, 0x7a, 0x05, 0x59, 0xe6, 0xb9,
	0xb6, 0xe5, 0x89, 0x54, 0x0a, 0xf5, 0xf7, 0xe2, 0xf8, 0xbe, 0xf0, 0xe9, 0xae, 0xed, 0xb8, 0xb6,
	0xb7, 0x90, 0x3b, 0xe5, 0x8e, 0xda, 0x0b, 0xc8, 0x07, 0x7c, 0x3c, 0xe9, 0xe1, 0xad, 0x41, 0x89,
	0x6b, 0x91, 0x99, 0x67, 0x5e, 0x06, 0x02, 0x2e, 0x0e, 0x6f, 0xf5, 0xa5, 0xad, 0xf6, 0x21, 0xa0,
	0x55, 0x42, 0xa4, 0x42, 0x7a, 0x48, 0x83, 0x7a, 0xf3, 0xe5, 0x51, 0x01, 0x36, 0xc5, 0xf1, 0x83,
	0x05, 0x25, 0xda, 0x99, 0x90, 0xc9, 0x05, 0x9d, 0xd8, 0xb3, 0x6b, 0xd1, 0xcf, 0xb6, 0x49, 0xd1,
	0x13, 0xd8, 0x1c, 0x39, 0xde, 0xcb, 0x1b, 0x83, 0x5a, 0x54, 0xee, 0xcc, 0x0b, 0x83, 0x6e, 0x51,
	0x5e, 0x27, 0x9b, 0x1a, 0x23, 0x66, 0xd1, 0xea, 0x86, 0x5f, 0x27, 0x9b, 0x36, 0x99, 0x45, 0xb5,
	0x3f, 0x2a, 0x00, 0x3d, 0x87, 0xb5, 0x4d, 0xf7, 0xda, 0x9e, 0x5d, 0xa2, 0x17, 0xf0, 0x70, 0x49,
	0x62, 0xb8, 0xe4, 0xd6, 0xb5, 0x3d, 0x62, 0x90, 0x99, 0xe0, 0xcb, 0xe3, 0x4a, 0xc0, 0x87, 0x7d,
	0x4f, 0x6b, 0x16, 0x3f, 0x75, 0x23, 0x71, 0xea, 0x73, 0x40, 0xf2, 0xd4, 0x28, 0x57, 0x5a, 0x70,
	0x6d, 0xf9, 0x01, 0x84, 0x4c, 0x91, 0x10, 0xfd, 0xae, 0x07, 0x21, 0xfe, 0x77, 0x03, 0x8a, 0xc1,
	0xad, 0x10, 0x43, 0xe1, 0x03, 0xc8, 0x4c, 0x89, 0x67, 0xca, 0x76, 0x56, 0x0e, 0xfc, 0xf9, 0xd1,
	0x1d, 0xfe, 0x82, 0x58, 0x5e, 0x9b, 0x78, 0x26, 0x16, 0x6e, 0x74, 0x9e, 0x50, 0xb7, 0x6c, 0xe7,
	0xb2, 0xfd, 0xf1, 0x6b, 0x76, 0xa4, 0xfe, 0xef, 0x5f, 0xdf, 0x2b, 0xbe, 0x21, 0x33, 0xdb, 0x22,
	0xaf, 0xb4, 0x6b, 0xb2, 0xd0, 0x70, 0xe1, 0x9a, 0x2c, 0xba, 0xae, 0xbc, 0x85, 0x2a, 0xa4, 0xa7,
	0xde, 0x5c, 0x0a, 0x97, 0x2f, 0xd1, 0x87, 0x90, 0x1d, 0x8a, 0x8b, 0x22, 0xe2, 0x2d, 0xd4, 0xcb,
	0x01, 0xb1, 0x7f, 0x7d, 0xb0, 0xf4, 0xa2, 0xa7, 0x90, 0xa6, 0x63, 0xab, 0xfa, 0x40, 0x80, 0x0a,
	0x01, 0x48, 0x3f, 0x6e, 0x60, 0x6e, 0x47, 0xef, 0xc3, 0x03, 0xc6, 0x3b, 0x5b, 0xcd, 0x0a, 0x40,
	0x29, 0xa6, 0x36, 0xec, 0xfb, 0xd0, 0x4f, 0x41, 0x9d, 0x8b, 0x76, 0xcb, 0x8b, 0x3d, 0x35, 0x69,
	0x35, 0x17, 0x4f, 0x27, 0x2e, 0x07, 0x5c, 0x9e, 0xc7, 0xe5, 0xf1, 0x03, 0xc8, 0x4d, 0xfd, 0x26,
	0x57, 0xf3, 0x62, 0xe3, 0x56, 0xb0, 0x51, 0xf6, 0x1e, 0x07, 0x7e, 0xed, 0x10, 0x50, 0x50, 0x1e,
	0x4c, 0x6e, 0xe6, 0x84, 0x79, 0x6d, 0x76, 0x89, 0x9e, 0x43, 0xce, 0xf5, 0xff, 0x12, 0x57, 0x8d,
	0x17, 0x3e, 0x5a, 0x48, 0xde, 0x19, 0x1c, 0x20, 0xb4, 0x57, 0x50, 0x5e, 0x3a, 0x3c, 0x93, 0x8f,
	0x80, 0xfd, 0x35, 0x73, 0x89, 0x37, 0x30, 0x9b, 0x9c, 0x4a, 0x1a, 0x05, 0x35, 0x3c, 0x9e, 0x51,
	0x67, 0xc6, 0x08, 0x7a, 0x01, 0x60, 0x52, 0xdb, 0x60, 0x82, 0x4b, 0x0e, 0x41, 0x55, 0x36, 0xfe,
	0x90, 0xda, 0xfe, 0x19, 0x78, 0xd3, 0x0c, 0x96, 0xe8, 0x39, 0xbf, 0xc4, 0x66, 0x30, 0x8f, 0x0a,
	0xf5, 0xed, 0x78, 0xb0, 0x3e, 0x5e, 0x42, 0xb4, 0x53, 0xd8, 0x4e, 0x9e, 0xc8, 0x33, 0x7e, 0x09,
	0x79, 0x57, 0xfe, 0x29, 0x53, 0x7e, 0x14, 0x63, 0x09, 0xb0, 0x78, 0x09, 0xd3, 0x7e, 0xa3, 0xc0,
	0xa3, 0xc0, 0xdd, 0x24, 0x13, 0xe2, 0x11, 0x59, 0xc1, 0xef, 0x44, 0xb4, 0x9a, 0x0e, 0xd5, 0xb5,
	0xd1, 0xf0, 0xec, 0x3e, 0x4d, 0xf6, 0xb3, 0x16, 0x3b, 0x23, 0x86, 0x0f, 0x1b, 0x7b, 0x0e, 0xbb,
	0x49, 0x44, 0x58, 0xb0, 0x64, 0x97, 0xd2, 0x5f, 0xd3, 0x25, 0x6d, 0x0b, 0x4a, 0xd1, 0x96, 0x30,
	0xed, 0xd7, 0x4a, 0xa8, 0xbd, 0x13, 0xe2, 0x7d, 0xa7, 0xc5, 0xfb, 0x2c, 0x6c, 0x65, 0x18, 0x8a,
	0xaf, 0x8b, 0x44, 0xe5, 0x1e, 0xc7, 0x0e, 0x08, 0xc1, 0x61, 0xd9, 0x7e, 0xa7, 0x84, 0x12, 0x13,
	0x7e, 0xa9, 0xeb, 0x0f, 0x20, 0xc3, 0x28, 0xb1, 0x96, 0x89, 0xad, 0xdc, 0x28, 0xe1, 0xbe, 0x97,
	0x9a, 0xd1, 0x3e, 0x3c, 0xe0, 0x2b, 0xff, 0x21, 0x52, 0xa8, 0xa3, 0x15, 0x2c, 0xc3, 0x3e, 0x40,
	0xeb, 0xc0, 0xce, 0x9a, 0xa0, 0x7c, 0x71, 0x24, 0xa5, 0x5f, 0x5d, 0xcd, 0x71, 0x45, 0xfd, 0xbf,
	0x52, 0xe0, 0x61, 0xc3, 0xa1, 0x54, 0xbe, 0xbb, 0x62, 0x4f, 0x18, 0xcb, 0xa1, 0xd4, 0xe0, 0x7d,
	0x8b, 0x3d, 0x61, 0x38, 0x9a, 0x7f, 0xd2, 0xf8, 0x13, 0xc6, 0x92, 0x6b, 0xf4, 0x43, 0xd8, 0x16,
	0x68, 0xea, 0xd3, 0x24, 0x5f, 0x31, 0x15, 0x2b, 0x3c, 0xe2, 0xae, 0x87, 0xcc, 0x5f, 0x14, 0xd8,
	0x8a, 0x44, 0x72, 0x9f, 0xcf, 0x46, 0x77, 0xbd, 0x88, 0x76, 0x97, 0xf1, 0x26, 0xb3, 0xfb, 0xba,
	0x2f, 0xc7, 0x33, 0xc8, 0xc9, 0x4c, 0x64, 0x47, 0x54, 0x41, 0x15, 0x09, 0x0d, 0x07, 0x00, 0xed,
	0x04, 0x1e, 0x45, 0x8e, 0x88, 0x68, 0xee, 0x20, 0xa9, 0xb9, 0x87, 0xc9, 0x78, 0xe2, 0x03, 0xb8,
	0x01, 0x95, 0xa8, 0xcf, 0x57, 0xc6, 0xc1, 0xfa, 0xc2, 0xfa, 0x63, 0x78, 0xb5, 0xac, 0xda, 0x1b,
	0xd8, 0x8e, 0x45, 0xf3, 0x4d, 0x87, 0xf1, 0x41, 0x42, 0xbe, 0x3b, 0x2b, 0xb1, 0xc7, 0xe7, 0x71,
	0x07, 0x76, 0xd6, 0x9c, 0xfb, 0x55, 0xba, 0x5c, 0x03, 0x8f, 0xe8, 0xf2, 0xb7, 0x4a, 0xac, 0xac,
	0xf7, 0x1f, 0x2c, 0xdf, 0xb6, 0x26, 0xf8, 0x60, 0x5e, 0x1b, 0xd0, 0x57, 0x0c, 0xe6, 0xb5, 0xf8,
	0xb0, 0xe1, 0x7f, 0x50, 0x62, 0x45, 0x8b, 0x0e, 0x99, 0xfd, 0xd8, 0x90, 0x59, 0x2f, 0x1c, 0x7f,
	0xce, 0xdc, 0xb3, 0x51, 0xe8, 0xa3, 0xf8, 0xa8, 0xa9, 0xc4, 0x84, 0x1d, 0x9d, 0x34, 0x03, 0xd8,
	0x5d, 0x1f, 0x1c, 0x4f, 0xf8, 0x27, 0x2b, 0x4d, 0x7d, 0xb2, 0x36, 0xe3, 0x64, 0x5f, 0x9f, 0xfd,
	0x75, 0x43, 0x3c, 0xf2, 0xfd, 0x1f, 0x3e, 0x05, 0xc8, 0x35, 0x5b, 0xc7, 0x87, 0x17, 0xe7, 0x03,
	0x35, 0x85, 0x10, 0x94, 0x2f, 0xfa, 0x2d, 0x6c, 0x34, 0x5b, 0xc7, 0x67, 0x9d, 0x56, 0xd3, 0x78,
	0xa9, 0x2a, 0x2b, 0xb6, 0xba, 0xba, 0xb1, 0x62, 0xfb, 0x44, 0x4d, 0xaf, 0xd8, 0x3e, 0x55, 0x33,
	0x2b, 0xb6, 0x1f, 0xa9, 0x0f, 0x56, 0x6c, 0x3f, 0x56, 0xb3, 0x3c, 0x88, 0x46, 0xb7, 0x33, 0xc0,
	0xdd, 0x73, 0x35, 0x87, 0xf2, 0x90, 0xe9, 0xeb, 0x87, 0x1d, 0x35, 0xcf, 0xa1, 0x67, 0x9d, 0x41,
	0x0b, 0x77, 0x0e, 0xcf, 0x8d, 0xc3, 0x66, 0xfb, 0xac, 0xa3, 0x6e, 0xa2, 0xa7, 0xb0, 0xbb, 0xb4,
	0xe1, 0x2f, 0x0c, 0x1d, 0x77, 0xbf, 0x78, 0x6d, 0x74, 0xba, 0x46, 0x13, 0x77, 0x75, 0x15, 0x50,
	0x0d, 0x76, 0x56, 0xdd, 0xc2, 0x57, 0x88, 0x6d, 0x1d, 0x24, 0xb7, 0x16, 0x63, 0x5b, 0x07, 0xb1,
	0xad, 0x25, 0xf4, 0x08, 0x2a, 0x4b, 0x5f, 0x43, 0xbf, 0x30, 0x1a, 0x5d, 0xfd, 0xb5, 0x5a, 0x7e,
	0xf6, 0x19, 0xe4, 0x83, 0x51, 0x8c, 0x1e, 0xc3, 0x76, 0xa3, 0xab, 0xeb, 0xc6, 0xe0, 0xb5, 0xde,
	0x32, 0x8e, 0xcf, 0xbb, 0x9f, 0x1b, 0xed, 0xb3, 0x7e, 0x5f, 0x4d, 0xa1, 0x0a, 0x94, 0x42, 0xc7,
	0x21, 0xd6, 0xfd, 0x9a, 0x86, 0xa6, 0xe6, 0x69, 0x43, 0x57, 0x37, 0xea, 0xff, 0x48, 0x43, 0xba,
	0xd7, 0xed, 0xa3, 0x56, 0xf8, 0x06, 0x6c, 0xb8, 0x84, 0xff, 0x64, 0x7f, 0x9c, 0x78, 0x3e, 0x05,
	0x92, 0xaf, 0x55, 0xd7, 0xbe, 0xab, 0xda, 0xec, 0x52, 0x4b, 0x45, 0x69, 0x2e, 0xe8, 0xe8, 0x1b,
	0xd3, 0xf4, 0x42, 0x1a, 0xff, 0xe1, 0x82, 0x9e, 0xde, 0xfd, 0xde, 0xe1, 0x64, 0x7b, 0x6b, 0xdd,
	0x51, 0xca, 0x53, 0x28, 0x44, 0xbe, 0x87, 0xa8, 0x76, 0xc7, 0x2b, 0x80, 0x93, 0x3d, 0xb9, 0xeb,
	0xeb, 0xe9, 0x33, 0x75, 0x62, 0xd3, 0x5a, 0xa6, 0x59, 0x5b, 0x9d, 0x6c, 0x09, 0xbe, 0xf5, 0x43,
	0xd2, 0x4f, 0x36, 0x7e, 0x79, 0x64, 0xb2, 0x77, 0xcd, 0x1c, 0x99, 0xec, 0x9d, 0x57, 0x54, 0x4b,
	0x1d, 0xd5, 0xfe, 0xf6, 0x6e, 0x4f, 0xf9, 0xfb, 0xbb, 0x3d, 0xe5, 0xdf, 0xef, 0xf6, 0x94, 0xdf,
	0xff, 0x67, 0x2f, 0xf5, 0xf3, 0xfc, 0x95, 0x39, 0x11, 0xff, 0x69, 0x33, 0xcc, 0x8a, 0x7f, 0x3e,
	0xf9, 0x7f, 0x00, 0x00, 0x00, 0xff, 0xff, 0xbb, 0x86, 0x3d, 0x12, 0xda, 0x11, 0x00, 0x00,
}
