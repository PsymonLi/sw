// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: nic/proto/hal/qos.proto

package halproto

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// Ignoring public import of ObjectMeta from nic/proto/types.proto

// Ignoring public import of EncapInfo from nic/proto/types.proto

// Ignoring public import of IPAddress from nic/proto/types.proto

// Ignoring public import of IPPrefix from nic/proto/types.proto

// Ignoring public import of L4PortRange from nic/proto/types.proto

// Ignoring public import of Empty from nic/proto/types.proto

// Ignoring public import of IPProtocol from nic/proto/types.proto

// Ignoring public import of ICMPMsgType from nic/proto/types.proto

// Ignoring public import of ApiStatus from nic/proto/types.proto

// Ignoring public import of L2SegmentType from nic/proto/types.proto

// Ignoring public import of encapType from nic/proto/types.proto

// Ignoring public import of IPAddressFamily from nic/proto/types.proto

// Ignoring public import of WRingType from nic/proto/types.proto

// Ignoring public import of ProxyType from nic/proto/types.proto

// Ignoring public import of CryptoKeyType from nic/proto/types.proto

// Pre-defined trees for the hierarchical scheduler.
type QueueSchedulerPolicy int32

const (
	QueueSchedulerPolicy_TM_QUEUE_SCHEDULER_2_4 QueueSchedulerPolicy = 0
	// 4 L1 nodes per L2 node
	QueueSchedulerPolicy_TM_QUEUE_SCHEDULER_4_2 QueueSchedulerPolicy = 1
	// 2 L1 nodes per L2 node
	QueueSchedulerPolicy_TM_QUEUE_SCHEDULER_8_1 QueueSchedulerPolicy = 2
)

var QueueSchedulerPolicy_name = map[int32]string{
	0: "TM_QUEUE_SCHEDULER_2_4",
	1: "TM_QUEUE_SCHEDULER_4_2",
	2: "TM_QUEUE_SCHEDULER_8_1",
}
var QueueSchedulerPolicy_value = map[string]int32{
	"TM_QUEUE_SCHEDULER_2_4": 0,
	"TM_QUEUE_SCHEDULER_4_2": 1,
	"TM_QUEUE_SCHEDULER_8_1": 2,
}

func (x QueueSchedulerPolicy) String() string {
	return proto.EnumName(QueueSchedulerPolicy_name, int32(x))
}
func (QueueSchedulerPolicy) EnumDescriptor() ([]byte, []int) { return fileDescriptorQos, []int{0} }

type PolicerDirection int32

const (
	PolicerDirection_INGRESS_POLICER PolicerDirection = 0
	PolicerDirection_EGRESS_POLICER  PolicerDirection = 1
)

var PolicerDirection_name = map[int32]string{
	0: "INGRESS_POLICER",
	1: "EGRESS_POLICER",
}
var PolicerDirection_value = map[string]int32{
	"INGRESS_POLICER": 0,
	"EGRESS_POLICER":  1,
}

func (x PolicerDirection) String() string {
	return proto.EnumName(PolicerDirection_name, int32(x))
}
func (PolicerDirection) EnumDescriptor() ([]byte, []int) { return fileDescriptorQos, []int{1} }

// Marking action object
type MarkingActionSpec struct {
	PcpRewriteEn  bool   `protobuf:"varint,1,opt,name=pcp_rewrite_en,json=pcpRewriteEn,proto3" json:"pcp_rewrite_en,omitempty"`
	Pcp           uint32 `protobuf:"varint,2,opt,name=pcp,proto3" json:"pcp,omitempty"`
	DscpRewriteEn bool   `protobuf:"varint,3,opt,name=dscp_rewrite_en,json=dscpRewriteEn,proto3" json:"dscp_rewrite_en,omitempty"`
	Dscp          uint32 `protobuf:"varint,4,opt,name=dscp,proto3" json:"dscp,omitempty"`
}

func (m *MarkingActionSpec) Reset()                    { *m = MarkingActionSpec{} }
func (m *MarkingActionSpec) String() string            { return proto.CompactTextString(m) }
func (*MarkingActionSpec) ProtoMessage()               {}
func (*MarkingActionSpec) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{0} }

func (m *MarkingActionSpec) GetPcpRewriteEn() bool {
	if m != nil {
		return m.PcpRewriteEn
	}
	return false
}

func (m *MarkingActionSpec) GetPcp() uint32 {
	if m != nil {
		return m.Pcp
	}
	return 0
}

func (m *MarkingActionSpec) GetDscpRewriteEn() bool {
	if m != nil {
		return m.DscpRewriteEn
	}
	return false
}

func (m *MarkingActionSpec) GetDscp() uint32 {
	if m != nil {
		return m.Dscp
	}
	return 0
}

// QOS actions used by other proto files to attach the QOS actions
// at respective attachment points
type QOSActions struct {
	QueueKeyOrHandle   *QueueKeyHandle    `protobuf:"bytes,1,opt,name=queue_key_or_handle,json=queueKeyOrHandle" json:"queue_key_or_handle,omitempty"`
	PolicerKeyOrHandle *PolicerKeyHandle  `protobuf:"bytes,2,opt,name=policer_key_or_handle,json=policerKeyOrHandle" json:"policer_key_or_handle,omitempty"`
	MarkingSpec        *MarkingActionSpec `protobuf:"bytes,3,opt,name=marking_spec,json=markingSpec" json:"marking_spec,omitempty"`
}

func (m *QOSActions) Reset()                    { *m = QOSActions{} }
func (m *QOSActions) String() string            { return proto.CompactTextString(m) }
func (*QOSActions) ProtoMessage()               {}
func (*QOSActions) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{1} }

func (m *QOSActions) GetQueueKeyOrHandle() *QueueKeyHandle {
	if m != nil {
		return m.QueueKeyOrHandle
	}
	return nil
}

func (m *QOSActions) GetPolicerKeyOrHandle() *PolicerKeyHandle {
	if m != nil {
		return m.PolicerKeyOrHandle
	}
	return nil
}

func (m *QOSActions) GetMarkingSpec() *MarkingActionSpec {
	if m != nil {
		return m.MarkingSpec
	}
	return nil
}

// Traffic class identifier
type TrafficClass struct {
	Cos uint32 `protobuf:"varint,1,opt,name=cos,proto3" json:"cos,omitempty"`
}

func (m *TrafficClass) Reset()                    { *m = TrafficClass{} }
func (m *TrafficClass) String() string            { return proto.CompactTextString(m) }
func (*TrafficClass) ProtoMessage()               {}
func (*TrafficClass) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{2} }

func (m *TrafficClass) GetCos() uint32 {
	if m != nil {
		return m.Cos
	}
	return 0
}

// Mapping from the Traffic Class to Queues.
type TrafficClassQueueMap struct {
	TrafficClass   *TrafficClass   `protobuf:"bytes,1,opt,name=traffic_class,json=trafficClass" json:"traffic_class,omitempty"`
	QueueKeyHandle *QueueKeyHandle `protobuf:"bytes,2,opt,name=queue_key_handle,json=queueKeyHandle" json:"queue_key_handle,omitempty"`
}

func (m *TrafficClassQueueMap) Reset()                    { *m = TrafficClassQueueMap{} }
func (m *TrafficClassQueueMap) String() string            { return proto.CompactTextString(m) }
func (*TrafficClassQueueMap) ProtoMessage()               {}
func (*TrafficClassQueueMap) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{3} }

func (m *TrafficClassQueueMap) GetTrafficClass() *TrafficClass {
	if m != nil {
		return m.TrafficClass
	}
	return nil
}

func (m *TrafficClassQueueMap) GetQueueKeyHandle() *QueueKeyHandle {
	if m != nil {
		return m.QueueKeyHandle
	}
	return nil
}

// Buffer Pool handle - uniquely identifies a buffer pool
type BufPoolHandle struct {
	Handle uint64 `protobuf:"fixed64,1,opt,name=handle,proto3" json:"handle,omitempty"`
}

func (m *BufPoolHandle) Reset()                    { *m = BufPoolHandle{} }
func (m *BufPoolHandle) String() string            { return proto.CompactTextString(m) }
func (*BufPoolHandle) ProtoMessage()               {}
func (*BufPoolHandle) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{4} }

func (m *BufPoolHandle) GetHandle() uint64 {
	if m != nil {
		return m.Handle
	}
	return 0
}

// BufPoolKeyHandle uniquely identifies a Buffer Pool
type BufPoolKeyHandle struct {
	// Types that are valid to be assigned to KeyOrHandle:
	//	*BufPoolKeyHandle_BufPoolId
	//	*BufPoolKeyHandle_BufPoolHandle
	KeyOrHandle isBufPoolKeyHandle_KeyOrHandle `protobuf_oneof:"key_or_handle"`
}

func (m *BufPoolKeyHandle) Reset()                    { *m = BufPoolKeyHandle{} }
func (m *BufPoolKeyHandle) String() string            { return proto.CompactTextString(m) }
func (*BufPoolKeyHandle) ProtoMessage()               {}
func (*BufPoolKeyHandle) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{5} }

type isBufPoolKeyHandle_KeyOrHandle interface {
	isBufPoolKeyHandle_KeyOrHandle()
	MarshalTo([]byte) (int, error)
	Size() int
}

type BufPoolKeyHandle_BufPoolId struct {
	BufPoolId uint32 `protobuf:"fixed32,1,opt,name=buf_pool_id,json=bufPoolId,proto3,oneof"`
}
type BufPoolKeyHandle_BufPoolHandle struct {
	BufPoolHandle *BufPoolHandle `protobuf:"bytes,2,opt,name=buf_pool_handle,json=bufPoolHandle,oneof"`
}

func (*BufPoolKeyHandle_BufPoolId) isBufPoolKeyHandle_KeyOrHandle()     {}
func (*BufPoolKeyHandle_BufPoolHandle) isBufPoolKeyHandle_KeyOrHandle() {}

func (m *BufPoolKeyHandle) GetKeyOrHandle() isBufPoolKeyHandle_KeyOrHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

func (m *BufPoolKeyHandle) GetBufPoolId() uint32 {
	if x, ok := m.GetKeyOrHandle().(*BufPoolKeyHandle_BufPoolId); ok {
		return x.BufPoolId
	}
	return 0
}

func (m *BufPoolKeyHandle) GetBufPoolHandle() *BufPoolHandle {
	if x, ok := m.GetKeyOrHandle().(*BufPoolKeyHandle_BufPoolHandle); ok {
		return x.BufPoolHandle
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*BufPoolKeyHandle) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _BufPoolKeyHandle_OneofMarshaler, _BufPoolKeyHandle_OneofUnmarshaler, _BufPoolKeyHandle_OneofSizer, []interface{}{
		(*BufPoolKeyHandle_BufPoolId)(nil),
		(*BufPoolKeyHandle_BufPoolHandle)(nil),
	}
}

func _BufPoolKeyHandle_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*BufPoolKeyHandle)
	// key_or_handle
	switch x := m.KeyOrHandle.(type) {
	case *BufPoolKeyHandle_BufPoolId:
		_ = b.EncodeVarint(1<<3 | proto.WireFixed32)
		_ = b.EncodeFixed32(uint64(x.BufPoolId))
	case *BufPoolKeyHandle_BufPoolHandle:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.BufPoolHandle); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("BufPoolKeyHandle.KeyOrHandle has unexpected type %T", x)
	}
	return nil
}

func _BufPoolKeyHandle_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*BufPoolKeyHandle)
	switch tag {
	case 1: // key_or_handle.buf_pool_id
		if wire != proto.WireFixed32 {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeFixed32()
		m.KeyOrHandle = &BufPoolKeyHandle_BufPoolId{uint32(x)}
		return true, err
	case 2: // key_or_handle.buf_pool_handle
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(BufPoolHandle)
		err := b.DecodeMessage(msg)
		m.KeyOrHandle = &BufPoolKeyHandle_BufPoolHandle{msg}
		return true, err
	default:
		return false, nil
	}
}

func _BufPoolKeyHandle_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*BufPoolKeyHandle)
	// key_or_handle
	switch x := m.KeyOrHandle.(type) {
	case *BufPoolKeyHandle_BufPoolId:
		n += proto.SizeVarint(1<<3 | proto.WireFixed32)
		n += 4
	case *BufPoolKeyHandle_BufPoolHandle:
		s := proto.Size(x.BufPoolHandle)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Buffer Pool specification
type BufPoolSpec struct {
	Meta *ObjectMeta `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	// key_or_handle is Buffer pool's key or handle
	KeyOrHandle   *BufPoolKeyHandle `protobuf:"bytes,2,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty" venice:"key"`
	PortNum       uint32            `protobuf:"varint,3,opt,name=port_num,json=portNum,proto3" json:"port_num,omitempty"`
	ReservedBytes uint32            `protobuf:"varint,4,opt,name=reserved_bytes,json=reservedBytes,proto3" json:"reserved_bytes,omitempty"`
	// this pool
	HeadroomBytes uint32 `protobuf:"varint,5,opt,name=headroom_bytes,json=headroomBytes,proto3" json:"headroom_bytes,omitempty"`
	// reserved for this pool
	// Before this is used, xoff will be asserted
	SharingFactor uint32 `protobuf:"varint,6,opt,name=sharing_factor,json=sharingFactor,proto3" json:"sharing_factor,omitempty"`
	// buffers from shared pool
	XonThreshold uint32 `protobuf:"varint,7,opt,name=xon_threshold,json=xonThreshold,proto3" json:"xon_threshold,omitempty"`
	// max occupancy at which xoff will be cleared
	XoffClearLimit uint32 `protobuf:"varint,8,opt,name=xoff_clear_limit,json=xoffClearLimit,proto3" json:"xoff_clear_limit,omitempty"`
	// below this limit, xoff will be cleared
	Mtu uint32          `protobuf:"varint,9,opt,name=mtu,proto3" json:"mtu,omitempty"`
	Tcs []*TrafficClass `protobuf:"bytes,10,rep,name=tcs" json:"tcs,omitempty"`
}

func (m *BufPoolSpec) Reset()                    { *m = BufPoolSpec{} }
func (m *BufPoolSpec) String() string            { return proto.CompactTextString(m) }
func (*BufPoolSpec) ProtoMessage()               {}
func (*BufPoolSpec) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{6} }

func (m *BufPoolSpec) GetMeta() *ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *BufPoolSpec) GetKeyOrHandle() *BufPoolKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

func (m *BufPoolSpec) GetPortNum() uint32 {
	if m != nil {
		return m.PortNum
	}
	return 0
}

func (m *BufPoolSpec) GetReservedBytes() uint32 {
	if m != nil {
		return m.ReservedBytes
	}
	return 0
}

func (m *BufPoolSpec) GetHeadroomBytes() uint32 {
	if m != nil {
		return m.HeadroomBytes
	}
	return 0
}

func (m *BufPoolSpec) GetSharingFactor() uint32 {
	if m != nil {
		return m.SharingFactor
	}
	return 0
}

func (m *BufPoolSpec) GetXonThreshold() uint32 {
	if m != nil {
		return m.XonThreshold
	}
	return 0
}

func (m *BufPoolSpec) GetXoffClearLimit() uint32 {
	if m != nil {
		return m.XoffClearLimit
	}
	return 0
}

func (m *BufPoolSpec) GetMtu() uint32 {
	if m != nil {
		return m.Mtu
	}
	return 0
}

func (m *BufPoolSpec) GetTcs() []*TrafficClass {
	if m != nil {
		return m.Tcs
	}
	return nil
}

// BufPoolRequestMsg is batched request to create/update the buffer pools
type BufPoolRequestMsg struct {
	Request []*BufPoolSpec `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *BufPoolRequestMsg) Reset()                    { *m = BufPoolRequestMsg{} }
func (m *BufPoolRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*BufPoolRequestMsg) ProtoMessage()               {}
func (*BufPoolRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{7} }

func (m *BufPoolRequestMsg) GetRequest() []*BufPoolSpec {
	if m != nil {
		return m.Request
	}
	return nil
}

// BufPoolStatus represents the operational status of Buffer Pool
type BufPoolStatus struct {
	BufPoolHandle *BufPoolHandle `protobuf:"bytes,1,opt,name=buf_pool_handle,json=bufPoolHandle" json:"buf_pool_handle,omitempty"`
}

func (m *BufPoolStatus) Reset()                    { *m = BufPoolStatus{} }
func (m *BufPoolStatus) String() string            { return proto.CompactTextString(m) }
func (*BufPoolStatus) ProtoMessage()               {}
func (*BufPoolStatus) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{8} }

func (m *BufPoolStatus) GetBufPoolHandle() *BufPoolHandle {
	if m != nil {
		return m.BufPoolHandle
	}
	return nil
}

// BufPoolResponse is response to one BufPoolSpec
type BufPoolResponse struct {
	ApiStatus ApiStatus      `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty"`
	Status    *BufPoolStatus `protobuf:"bytes,2,opt,name=status" json:"status,omitempty"`
}

func (m *BufPoolResponse) Reset()                    { *m = BufPoolResponse{} }
func (m *BufPoolResponse) String() string            { return proto.CompactTextString(m) }
func (*BufPoolResponse) ProtoMessage()               {}
func (*BufPoolResponse) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{9} }

func (m *BufPoolResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *BufPoolResponse) GetStatus() *BufPoolStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

// BufPoolResponseMsg is response to BufPoolRequestMsg
type BufPoolResponseMsg struct {
	Response []*BufPoolResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *BufPoolResponseMsg) Reset()                    { *m = BufPoolResponseMsg{} }
func (m *BufPoolResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*BufPoolResponseMsg) ProtoMessage()               {}
func (*BufPoolResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{10} }

func (m *BufPoolResponseMsg) GetResponse() []*BufPoolResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

// BufPoolDeleteRequest  is used to delete a Buffer Pool object
type BufPoolDeleteRequest struct {
	Meta *ObjectMeta `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	// key_or_handle is to identify Buffer pool being deleted
	KeyOrHandle *BufPoolKeyHandle `protobuf:"bytes,2,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty" venice:"key"`
}

func (m *BufPoolDeleteRequest) Reset()                    { *m = BufPoolDeleteRequest{} }
func (m *BufPoolDeleteRequest) String() string            { return proto.CompactTextString(m) }
func (*BufPoolDeleteRequest) ProtoMessage()               {}
func (*BufPoolDeleteRequest) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{11} }

func (m *BufPoolDeleteRequest) GetMeta() *ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *BufPoolDeleteRequest) GetKeyOrHandle() *BufPoolKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

// BufPoolDeleteRequestMsg is used to delete a batch of Buffer pools
type BufPoolDeleteRequestMsg struct {
	Request []*BufPoolDeleteRequest `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *BufPoolDeleteRequestMsg) Reset()                    { *m = BufPoolDeleteRequestMsg{} }
func (m *BufPoolDeleteRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*BufPoolDeleteRequestMsg) ProtoMessage()               {}
func (*BufPoolDeleteRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{12} }

func (m *BufPoolDeleteRequestMsg) GetRequest() []*BufPoolDeleteRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

// BufPoolDeleteResponseMsg is batched response to BufPoolDeleteRequestMsg
type BufPoolDeleteResponseMsg struct {
	ApiStatus []ApiStatus `protobuf:"varint,1,rep,packed,name=api_status,json=apiStatus,enum=types.ApiStatus" json:"api_status,omitempty"`
}

func (m *BufPoolDeleteResponseMsg) Reset()                    { *m = BufPoolDeleteResponseMsg{} }
func (m *BufPoolDeleteResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*BufPoolDeleteResponseMsg) ProtoMessage()               {}
func (*BufPoolDeleteResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{13} }

func (m *BufPoolDeleteResponseMsg) GetApiStatus() []ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return nil
}

// BufPoolStats captures all the statistics of given Buffer Pool
type BufPoolStats struct {
	Occupancy uint32 `protobuf:"varint,1,opt,name=occupancy,proto3" json:"occupancy,omitempty"`
}

func (m *BufPoolStats) Reset()                    { *m = BufPoolStats{} }
func (m *BufPoolStats) String() string            { return proto.CompactTextString(m) }
func (*BufPoolStats) ProtoMessage()               {}
func (*BufPoolStats) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{14} }

func (m *BufPoolStats) GetOccupancy() uint32 {
	if m != nil {
		return m.Occupancy
	}
	return 0
}

// BufPoolGetRequest is used to get information about a Buffer Pool
type BufPoolGetRequest struct {
	Meta *ObjectMeta `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	// key_or_handle is to identify Buffer pool being deleted
	KeyOrHandle *BufPoolKeyHandle `protobuf:"bytes,2,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty" venice:"key"`
}

func (m *BufPoolGetRequest) Reset()                    { *m = BufPoolGetRequest{} }
func (m *BufPoolGetRequest) String() string            { return proto.CompactTextString(m) }
func (*BufPoolGetRequest) ProtoMessage()               {}
func (*BufPoolGetRequest) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{15} }

func (m *BufPoolGetRequest) GetMeta() *ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *BufPoolGetRequest) GetKeyOrHandle() *BufPoolKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

// Batched request message to get the stats about a batch of Buffer pools
type BufPoolGetRequestMsg struct {
	Request []*BufPoolGetRequest `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *BufPoolGetRequestMsg) Reset()                    { *m = BufPoolGetRequestMsg{} }
func (m *BufPoolGetRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*BufPoolGetRequestMsg) ProtoMessage()               {}
func (*BufPoolGetRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{16} }

func (m *BufPoolGetRequestMsg) GetRequest() []*BufPoolGetRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

// BufPoolGetResponse captures all the information about a Buffer Pool
type BufPoolGetResponse struct {
	Spec   *BufPoolSpec   `protobuf:"bytes,1,opt,name=spec" json:"spec,omitempty"`
	Status *BufPoolStatus `protobuf:"bytes,2,opt,name=status" json:"status,omitempty"`
	Stats  *BufPoolStats  `protobuf:"bytes,3,opt,name=stats" json:"stats,omitempty"`
}

func (m *BufPoolGetResponse) Reset()                    { *m = BufPoolGetResponse{} }
func (m *BufPoolGetResponse) String() string            { return proto.CompactTextString(m) }
func (*BufPoolGetResponse) ProtoMessage()               {}
func (*BufPoolGetResponse) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{17} }

func (m *BufPoolGetResponse) GetSpec() *BufPoolSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *BufPoolGetResponse) GetStatus() *BufPoolStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *BufPoolGetResponse) GetStats() *BufPoolStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

// BufPoolGetResponseMsg is response to BufPoolGetRequestMsg
type BufPoolGetResponseMsg struct {
	Response []*BufPoolGetResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *BufPoolGetResponseMsg) Reset()                    { *m = BufPoolGetResponseMsg{} }
func (m *BufPoolGetResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*BufPoolGetResponseMsg) ProtoMessage()               {}
func (*BufPoolGetResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{18} }

func (m *BufPoolGetResponseMsg) GetResponse() []*BufPoolGetResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

// Queue handle - uniquely identifies a queue
type QueueHandle struct {
	Handle uint64 `protobuf:"fixed64,1,opt,name=handle,proto3" json:"handle,omitempty"`
}

func (m *QueueHandle) Reset()                    { *m = QueueHandle{} }
func (m *QueueHandle) String() string            { return proto.CompactTextString(m) }
func (*QueueHandle) ProtoMessage()               {}
func (*QueueHandle) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{19} }

func (m *QueueHandle) GetHandle() uint64 {
	if m != nil {
		return m.Handle
	}
	return 0
}

// QueueKeyHandle uniquely identifies a queue
type QueueKeyHandle struct {
	// Types that are valid to be assigned to KeyOrHandle:
	//	*QueueKeyHandle_QueueId
	//	*QueueKeyHandle_QueueHandle
	KeyOrHandle isQueueKeyHandle_KeyOrHandle `protobuf_oneof:"key_or_handle"`
}

func (m *QueueKeyHandle) Reset()                    { *m = QueueKeyHandle{} }
func (m *QueueKeyHandle) String() string            { return proto.CompactTextString(m) }
func (*QueueKeyHandle) ProtoMessage()               {}
func (*QueueKeyHandle) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{20} }

type isQueueKeyHandle_KeyOrHandle interface {
	isQueueKeyHandle_KeyOrHandle()
	MarshalTo([]byte) (int, error)
	Size() int
}

type QueueKeyHandle_QueueId struct {
	QueueId uint32 `protobuf:"fixed32,1,opt,name=queue_id,json=queueId,proto3,oneof"`
}
type QueueKeyHandle_QueueHandle struct {
	QueueHandle *QueueHandle `protobuf:"bytes,2,opt,name=queue_handle,json=queueHandle,oneof"`
}

func (*QueueKeyHandle_QueueId) isQueueKeyHandle_KeyOrHandle()     {}
func (*QueueKeyHandle_QueueHandle) isQueueKeyHandle_KeyOrHandle() {}

func (m *QueueKeyHandle) GetKeyOrHandle() isQueueKeyHandle_KeyOrHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

func (m *QueueKeyHandle) GetQueueId() uint32 {
	if x, ok := m.GetKeyOrHandle().(*QueueKeyHandle_QueueId); ok {
		return x.QueueId
	}
	return 0
}

func (m *QueueKeyHandle) GetQueueHandle() *QueueHandle {
	if x, ok := m.GetKeyOrHandle().(*QueueKeyHandle_QueueHandle); ok {
		return x.QueueHandle
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*QueueKeyHandle) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _QueueKeyHandle_OneofMarshaler, _QueueKeyHandle_OneofUnmarshaler, _QueueKeyHandle_OneofSizer, []interface{}{
		(*QueueKeyHandle_QueueId)(nil),
		(*QueueKeyHandle_QueueHandle)(nil),
	}
}

func _QueueKeyHandle_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*QueueKeyHandle)
	// key_or_handle
	switch x := m.KeyOrHandle.(type) {
	case *QueueKeyHandle_QueueId:
		_ = b.EncodeVarint(1<<3 | proto.WireFixed32)
		_ = b.EncodeFixed32(uint64(x.QueueId))
	case *QueueKeyHandle_QueueHandle:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.QueueHandle); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("QueueKeyHandle.KeyOrHandle has unexpected type %T", x)
	}
	return nil
}

func _QueueKeyHandle_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*QueueKeyHandle)
	switch tag {
	case 1: // key_or_handle.queue_id
		if wire != proto.WireFixed32 {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeFixed32()
		m.KeyOrHandle = &QueueKeyHandle_QueueId{uint32(x)}
		return true, err
	case 2: // key_or_handle.queue_handle
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(QueueHandle)
		err := b.DecodeMessage(msg)
		m.KeyOrHandle = &QueueKeyHandle_QueueHandle{msg}
		return true, err
	default:
		return false, nil
	}
}

func _QueueKeyHandle_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*QueueKeyHandle)
	// key_or_handle
	switch x := m.KeyOrHandle.(type) {
	case *QueueKeyHandle_QueueId:
		n += proto.SizeVarint(1<<3 | proto.WireFixed32)
		n += 4
	case *QueueKeyHandle_QueueHandle:
		s := proto.Size(x.QueueHandle)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// DWRR specific information
type DWRRInfo struct {
	Weight uint32 `protobuf:"varint,1,opt,name=weight,proto3" json:"weight,omitempty"`
}

func (m *DWRRInfo) Reset()                    { *m = DWRRInfo{} }
func (m *DWRRInfo) String() string            { return proto.CompactTextString(m) }
func (*DWRRInfo) ProtoMessage()               {}
func (*DWRRInfo) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{21} }

func (m *DWRRInfo) GetWeight() uint32 {
	if m != nil {
		return m.Weight
	}
	return 0
}

// Strict Priority specific information for the queue
type StrictPriorityInfo struct {
	Rate uint32 `protobuf:"varint,1,opt,name=rate,proto3" json:"rate,omitempty"`
}

func (m *StrictPriorityInfo) Reset()                    { *m = StrictPriorityInfo{} }
func (m *StrictPriorityInfo) String() string            { return proto.CompactTextString(m) }
func (*StrictPriorityInfo) ProtoMessage()               {}
func (*StrictPriorityInfo) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{22} }

func (m *StrictPriorityInfo) GetRate() uint32 {
	if m != nil {
		return m.Rate
	}
	return 0
}

// Info about a node in Queue schedule tree
type QueueSchedulerNode struct {
	Priority uint32 `protobuf:"varint,1,opt,name=priority,proto3" json:"priority,omitempty"`
	// Types that are valid to be assigned to QueueType:
	//	*QueueSchedulerNode_Dwrr
	//	*QueueSchedulerNode_Strict
	QueueType isQueueSchedulerNode_QueueType `protobuf_oneof:"QueueType"`
}

func (m *QueueSchedulerNode) Reset()                    { *m = QueueSchedulerNode{} }
func (m *QueueSchedulerNode) String() string            { return proto.CompactTextString(m) }
func (*QueueSchedulerNode) ProtoMessage()               {}
func (*QueueSchedulerNode) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{23} }

type isQueueSchedulerNode_QueueType interface {
	isQueueSchedulerNode_QueueType()
	MarshalTo([]byte) (int, error)
	Size() int
}

type QueueSchedulerNode_Dwrr struct {
	Dwrr *DWRRInfo `protobuf:"bytes,2,opt,name=dwrr,oneof"`
}
type QueueSchedulerNode_Strict struct {
	Strict *StrictPriorityInfo `protobuf:"bytes,3,opt,name=strict,oneof"`
}

func (*QueueSchedulerNode_Dwrr) isQueueSchedulerNode_QueueType()   {}
func (*QueueSchedulerNode_Strict) isQueueSchedulerNode_QueueType() {}

func (m *QueueSchedulerNode) GetQueueType() isQueueSchedulerNode_QueueType {
	if m != nil {
		return m.QueueType
	}
	return nil
}

func (m *QueueSchedulerNode) GetPriority() uint32 {
	if m != nil {
		return m.Priority
	}
	return 0
}

func (m *QueueSchedulerNode) GetDwrr() *DWRRInfo {
	if x, ok := m.GetQueueType().(*QueueSchedulerNode_Dwrr); ok {
		return x.Dwrr
	}
	return nil
}

func (m *QueueSchedulerNode) GetStrict() *StrictPriorityInfo {
	if x, ok := m.GetQueueType().(*QueueSchedulerNode_Strict); ok {
		return x.Strict
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*QueueSchedulerNode) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _QueueSchedulerNode_OneofMarshaler, _QueueSchedulerNode_OneofUnmarshaler, _QueueSchedulerNode_OneofSizer, []interface{}{
		(*QueueSchedulerNode_Dwrr)(nil),
		(*QueueSchedulerNode_Strict)(nil),
	}
}

func _QueueSchedulerNode_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*QueueSchedulerNode)
	// QueueType
	switch x := m.QueueType.(type) {
	case *QueueSchedulerNode_Dwrr:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Dwrr); err != nil {
			return err
		}
	case *QueueSchedulerNode_Strict:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Strict); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("QueueSchedulerNode.QueueType has unexpected type %T", x)
	}
	return nil
}

func _QueueSchedulerNode_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*QueueSchedulerNode)
	switch tag {
	case 2: // QueueType.dwrr
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(DWRRInfo)
		err := b.DecodeMessage(msg)
		m.QueueType = &QueueSchedulerNode_Dwrr{msg}
		return true, err
	case 3: // QueueType.strict
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(StrictPriorityInfo)
		err := b.DecodeMessage(msg)
		m.QueueType = &QueueSchedulerNode_Strict{msg}
		return true, err
	default:
		return false, nil
	}
}

func _QueueSchedulerNode_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*QueueSchedulerNode)
	// QueueType
	switch x := m.QueueType.(type) {
	case *QueueSchedulerNode_Dwrr:
		s := proto.Size(x.Dwrr)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *QueueSchedulerNode_Strict:
		s := proto.Size(x.Strict)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type QueueInfo struct {
	// key_or_handle is Queue's key or handle
	KeyOrHandle *QueueKeyHandle     `protobuf:"bytes,1,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty" venice:"key"`
	QueueInfo   *QueueSchedulerNode `protobuf:"bytes,2,opt,name=queue_info,json=queueInfo" json:"queue_info,omitempty"`
}

func (m *QueueInfo) Reset()                    { *m = QueueInfo{} }
func (m *QueueInfo) String() string            { return proto.CompactTextString(m) }
func (*QueueInfo) ProtoMessage()               {}
func (*QueueInfo) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{24} }

func (m *QueueInfo) GetKeyOrHandle() *QueueKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

func (m *QueueInfo) GetQueueInfo() *QueueSchedulerNode {
	if m != nil {
		return m.QueueInfo
	}
	return nil
}

// Output queue specification
// Output queues are created in a batch. Multiple queues are created at a
// TM Port at one time and the scheduling policy is picked from a
// predefined template.
// A QueueHandle will be returned for each of the queues created which
// can be used to specify the queue a particular flow should take
type QueueSpec struct {
	Meta            *ObjectMeta           `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	PortNum         uint32                `protobuf:"varint,2,opt,name=port_num,json=portNum,proto3" json:"port_num,omitempty"`
	SchedulerPolicy QueueSchedulerPolicy  `protobuf:"varint,3,opt,name=scheduler_policy,json=schedulerPolicy,proto3,enum=qos.QueueSchedulerPolicy" json:"scheduler_policy,omitempty"`
	Queues          []*QueueInfo          `protobuf:"bytes,4,rep,name=queues" json:"queues,omitempty"`
	L1Nodes         []*QueueSchedulerNode `protobuf:"bytes,5,rep,name=l1_nodes,json=l1Nodes" json:"l1_nodes,omitempty"`
}

func (m *QueueSpec) Reset()                    { *m = QueueSpec{} }
func (m *QueueSpec) String() string            { return proto.CompactTextString(m) }
func (*QueueSpec) ProtoMessage()               {}
func (*QueueSpec) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{25} }

func (m *QueueSpec) GetMeta() *ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *QueueSpec) GetPortNum() uint32 {
	if m != nil {
		return m.PortNum
	}
	return 0
}

func (m *QueueSpec) GetSchedulerPolicy() QueueSchedulerPolicy {
	if m != nil {
		return m.SchedulerPolicy
	}
	return QueueSchedulerPolicy_TM_QUEUE_SCHEDULER_2_4
}

func (m *QueueSpec) GetQueues() []*QueueInfo {
	if m != nil {
		return m.Queues
	}
	return nil
}

func (m *QueueSpec) GetL1Nodes() []*QueueSchedulerNode {
	if m != nil {
		return m.L1Nodes
	}
	return nil
}

// QueueRequestMsg is batched request used to create/update Queues
type QueueRequestMsg struct {
	Request []*QueueSpec `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *QueueRequestMsg) Reset()                    { *m = QueueRequestMsg{} }
func (m *QueueRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*QueueRequestMsg) ProtoMessage()               {}
func (*QueueRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{26} }

func (m *QueueRequestMsg) GetRequest() []*QueueSpec {
	if m != nil {
		return m.Request
	}
	return nil
}

type QueueStatus struct {
	QueueHandle *QueueHandle `protobuf:"bytes,1,opt,name=queue_handle,json=queueHandle" json:"queue_handle,omitempty"`
}

func (m *QueueStatus) Reset()                    { *m = QueueStatus{} }
func (m *QueueStatus) String() string            { return proto.CompactTextString(m) }
func (*QueueStatus) ProtoMessage()               {}
func (*QueueStatus) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{27} }

func (m *QueueStatus) GetQueueHandle() *QueueHandle {
	if m != nil {
		return m.QueueHandle
	}
	return nil
}

// Response message for creating queues
type QueueResponse struct {
	ApiStatus ApiStatus      `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty"`
	Status    []*QueueStatus `protobuf:"bytes,2,rep,name=status" json:"status,omitempty"`
}

func (m *QueueResponse) Reset()                    { *m = QueueResponse{} }
func (m *QueueResponse) String() string            { return proto.CompactTextString(m) }
func (*QueueResponse) ProtoMessage()               {}
func (*QueueResponse) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{28} }

func (m *QueueResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *QueueResponse) GetStatus() []*QueueStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

// QueueResponseMsg is response to QueueRequestMsg
type QueueResponseMsg struct {
	Response []*QueueResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *QueueResponseMsg) Reset()                    { *m = QueueResponseMsg{} }
func (m *QueueResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*QueueResponseMsg) ProtoMessage()               {}
func (*QueueResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{29} }

func (m *QueueResponseMsg) GetResponse() []*QueueResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

// QueueDeleteRequest  is used to delete a Queue object
type QueueDeleteRequest struct {
	Meta *ObjectMeta `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	// key_or_handle is Queue's key or handle
	KeyOrHandle *QueueKeyHandle `protobuf:"bytes,2,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty" venice:"key"`
}

func (m *QueueDeleteRequest) Reset()                    { *m = QueueDeleteRequest{} }
func (m *QueueDeleteRequest) String() string            { return proto.CompactTextString(m) }
func (*QueueDeleteRequest) ProtoMessage()               {}
func (*QueueDeleteRequest) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{30} }

func (m *QueueDeleteRequest) GetMeta() *ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *QueueDeleteRequest) GetKeyOrHandle() *QueueKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

// QueueDeleteRequestMsg is used to delete a batch of Queues
type QueueDeleteRequestMsg struct {
	Request []*QueueDeleteRequest `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *QueueDeleteRequestMsg) Reset()                    { *m = QueueDeleteRequestMsg{} }
func (m *QueueDeleteRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*QueueDeleteRequestMsg) ProtoMessage()               {}
func (*QueueDeleteRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{31} }

func (m *QueueDeleteRequestMsg) GetRequest() []*QueueDeleteRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

// QueueDeleteResponseMsg is batched response to QueueDeleteRequestMsg
type QueueDeleteResponseMsg struct {
	ApiStatus []ApiStatus `protobuf:"varint,1,rep,packed,name=api_status,json=apiStatus,enum=types.ApiStatus" json:"api_status,omitempty"`
}

func (m *QueueDeleteResponseMsg) Reset()                    { *m = QueueDeleteResponseMsg{} }
func (m *QueueDeleteResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*QueueDeleteResponseMsg) ProtoMessage()               {}
func (*QueueDeleteResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{32} }

func (m *QueueDeleteResponseMsg) GetApiStatus() []ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return nil
}

// QueueStats captures all the statistics of given Queue
type QueueStats struct {
	QueueDepth uint32 `protobuf:"varint,1,opt,name=queue_depth,json=queueDepth,proto3" json:"queue_depth,omitempty"`
}

func (m *QueueStats) Reset()                    { *m = QueueStats{} }
func (m *QueueStats) String() string            { return proto.CompactTextString(m) }
func (*QueueStats) ProtoMessage()               {}
func (*QueueStats) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{33} }

func (m *QueueStats) GetQueueDepth() uint32 {
	if m != nil {
		return m.QueueDepth
	}
	return 0
}

// QueueGetRequest is used to get information about a Queue
type QueueGetRequest struct {
	Meta *ObjectMeta `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	// key_or_handle is Queue's key or handle
	KeyOrHandle *QueueKeyHandle `protobuf:"bytes,2,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty" venice:"key"`
}

func (m *QueueGetRequest) Reset()                    { *m = QueueGetRequest{} }
func (m *QueueGetRequest) String() string            { return proto.CompactTextString(m) }
func (*QueueGetRequest) ProtoMessage()               {}
func (*QueueGetRequest) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{34} }

func (m *QueueGetRequest) GetMeta() *ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *QueueGetRequest) GetKeyOrHandle() *QueueKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

type QueueGetRequestMsg struct {
	Request []*QueueGetRequest `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *QueueGetRequestMsg) Reset()                    { *m = QueueGetRequestMsg{} }
func (m *QueueGetRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*QueueGetRequestMsg) ProtoMessage()               {}
func (*QueueGetRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{35} }

func (m *QueueGetRequestMsg) GetRequest() []*QueueGetRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

// QueueGetResponse captures all the information about a Queue
type QueueGetResponse struct {
	Spec   *QueueSpec   `protobuf:"bytes,1,opt,name=spec" json:"spec,omitempty"`
	Status *QueueStatus `protobuf:"bytes,2,opt,name=status" json:"status,omitempty"`
	Stats  *QueueStats  `protobuf:"bytes,3,opt,name=stats" json:"stats,omitempty"`
}

func (m *QueueGetResponse) Reset()                    { *m = QueueGetResponse{} }
func (m *QueueGetResponse) String() string            { return proto.CompactTextString(m) }
func (*QueueGetResponse) ProtoMessage()               {}
func (*QueueGetResponse) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{36} }

func (m *QueueGetResponse) GetSpec() *QueueSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *QueueGetResponse) GetStatus() *QueueStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *QueueGetResponse) GetStats() *QueueStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

// QueueGetResponseMsg is response to QueueGetRequestMsg
type QueueGetResponseMsg struct {
	Response []*QueueGetResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *QueueGetResponseMsg) Reset()                    { *m = QueueGetResponseMsg{} }
func (m *QueueGetResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*QueueGetResponseMsg) ProtoMessage()               {}
func (*QueueGetResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{37} }

func (m *QueueGetResponseMsg) GetResponse() []*QueueGetResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

// Handle of the policer
type PolicerHandle struct {
	Handle uint64 `protobuf:"fixed64,1,opt,name=handle,proto3" json:"handle,omitempty"`
}

func (m *PolicerHandle) Reset()                    { *m = PolicerHandle{} }
func (m *PolicerHandle) String() string            { return proto.CompactTextString(m) }
func (*PolicerHandle) ProtoMessage()               {}
func (*PolicerHandle) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{38} }

func (m *PolicerHandle) GetHandle() uint64 {
	if m != nil {
		return m.Handle
	}
	return 0
}

// PolicerKeyHandle uniquely identifies a Policer
type PolicerKeyHandle struct {
	// Types that are valid to be assigned to KeyOrHandle:
	//	*PolicerKeyHandle_PolicerId
	//	*PolicerKeyHandle_PolicerHandle
	KeyOrHandle isPolicerKeyHandle_KeyOrHandle `protobuf_oneof:"key_or_handle"`
}

func (m *PolicerKeyHandle) Reset()                    { *m = PolicerKeyHandle{} }
func (m *PolicerKeyHandle) String() string            { return proto.CompactTextString(m) }
func (*PolicerKeyHandle) ProtoMessage()               {}
func (*PolicerKeyHandle) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{39} }

type isPolicerKeyHandle_KeyOrHandle interface {
	isPolicerKeyHandle_KeyOrHandle()
	MarshalTo([]byte) (int, error)
	Size() int
}

type PolicerKeyHandle_PolicerId struct {
	PolicerId uint32 `protobuf:"fixed32,1,opt,name=policer_id,json=policerId,proto3,oneof"`
}
type PolicerKeyHandle_PolicerHandle struct {
	PolicerHandle *PolicerHandle `protobuf:"bytes,2,opt,name=policer_handle,json=policerHandle,oneof"`
}

func (*PolicerKeyHandle_PolicerId) isPolicerKeyHandle_KeyOrHandle()     {}
func (*PolicerKeyHandle_PolicerHandle) isPolicerKeyHandle_KeyOrHandle() {}

func (m *PolicerKeyHandle) GetKeyOrHandle() isPolicerKeyHandle_KeyOrHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

func (m *PolicerKeyHandle) GetPolicerId() uint32 {
	if x, ok := m.GetKeyOrHandle().(*PolicerKeyHandle_PolicerId); ok {
		return x.PolicerId
	}
	return 0
}

func (m *PolicerKeyHandle) GetPolicerHandle() *PolicerHandle {
	if x, ok := m.GetKeyOrHandle().(*PolicerKeyHandle_PolicerHandle); ok {
		return x.PolicerHandle
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*PolicerKeyHandle) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _PolicerKeyHandle_OneofMarshaler, _PolicerKeyHandle_OneofUnmarshaler, _PolicerKeyHandle_OneofSizer, []interface{}{
		(*PolicerKeyHandle_PolicerId)(nil),
		(*PolicerKeyHandle_PolicerHandle)(nil),
	}
}

func _PolicerKeyHandle_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*PolicerKeyHandle)
	// key_or_handle
	switch x := m.KeyOrHandle.(type) {
	case *PolicerKeyHandle_PolicerId:
		_ = b.EncodeVarint(1<<3 | proto.WireFixed32)
		_ = b.EncodeFixed32(uint64(x.PolicerId))
	case *PolicerKeyHandle_PolicerHandle:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.PolicerHandle); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("PolicerKeyHandle.KeyOrHandle has unexpected type %T", x)
	}
	return nil
}

func _PolicerKeyHandle_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*PolicerKeyHandle)
	switch tag {
	case 1: // key_or_handle.policer_id
		if wire != proto.WireFixed32 {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeFixed32()
		m.KeyOrHandle = &PolicerKeyHandle_PolicerId{uint32(x)}
		return true, err
	case 2: // key_or_handle.policer_handle
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(PolicerHandle)
		err := b.DecodeMessage(msg)
		m.KeyOrHandle = &PolicerKeyHandle_PolicerHandle{msg}
		return true, err
	default:
		return false, nil
	}
}

func _PolicerKeyHandle_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*PolicerKeyHandle)
	// key_or_handle
	switch x := m.KeyOrHandle.(type) {
	case *PolicerKeyHandle_PolicerId:
		n += proto.SizeVarint(1<<3 | proto.WireFixed32)
		n += 4
	case *PolicerKeyHandle_PolicerHandle:
		s := proto.Size(x.PolicerHandle)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Specifications of a policer
type PolicerSpec struct {
	Meta *ObjectMeta `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	// key_or_handle is policer's unique identifier
	KeyOrHandle *PolicerKeyHandle  `protobuf:"bytes,2,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty" venice:"key"`
	Direction   PolicerDirection   `protobuf:"varint,3,opt,name=direction,proto3,enum=qos.PolicerDirection" json:"direction,omitempty"`
	Bandwidth   uint32             `protobuf:"varint,4,opt,name=bandwidth,proto3" json:"bandwidth,omitempty"`
	BurstSize   uint32             `protobuf:"varint,5,opt,name=burst_size,json=burstSize,proto3" json:"burst_size,omitempty"`
	MarkingSpec *MarkingActionSpec `protobuf:"bytes,6,opt,name=marking_spec,json=markingSpec" json:"marking_spec,omitempty"`
}

func (m *PolicerSpec) Reset()                    { *m = PolicerSpec{} }
func (m *PolicerSpec) String() string            { return proto.CompactTextString(m) }
func (*PolicerSpec) ProtoMessage()               {}
func (*PolicerSpec) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{40} }

func (m *PolicerSpec) GetMeta() *ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *PolicerSpec) GetKeyOrHandle() *PolicerKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

func (m *PolicerSpec) GetDirection() PolicerDirection {
	if m != nil {
		return m.Direction
	}
	return PolicerDirection_INGRESS_POLICER
}

func (m *PolicerSpec) GetBandwidth() uint32 {
	if m != nil {
		return m.Bandwidth
	}
	return 0
}

func (m *PolicerSpec) GetBurstSize() uint32 {
	if m != nil {
		return m.BurstSize
	}
	return 0
}

func (m *PolicerSpec) GetMarkingSpec() *MarkingActionSpec {
	if m != nil {
		return m.MarkingSpec
	}
	return nil
}

// Batched requests to create/update policers
type PolicerRequestMsg struct {
	Request []*PolicerSpec `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *PolicerRequestMsg) Reset()                    { *m = PolicerRequestMsg{} }
func (m *PolicerRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*PolicerRequestMsg) ProtoMessage()               {}
func (*PolicerRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{41} }

func (m *PolicerRequestMsg) GetRequest() []*PolicerSpec {
	if m != nil {
		return m.Request
	}
	return nil
}

type PolicerStatus struct {
	PolicerHandle *PolicerHandle `protobuf:"bytes,1,opt,name=policer_handle,json=policerHandle" json:"policer_handle,omitempty"`
}

func (m *PolicerStatus) Reset()                    { *m = PolicerStatus{} }
func (m *PolicerStatus) String() string            { return proto.CompactTextString(m) }
func (*PolicerStatus) ProtoMessage()               {}
func (*PolicerStatus) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{42} }

func (m *PolicerStatus) GetPolicerHandle() *PolicerHandle {
	if m != nil {
		return m.PolicerHandle
	}
	return nil
}

// PolicerResponse is response to one Policer
type PolicerResponse struct {
	ApiStatus ApiStatus      `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty"`
	Status    *PolicerStatus `protobuf:"bytes,2,opt,name=status" json:"status,omitempty"`
}

func (m *PolicerResponse) Reset()                    { *m = PolicerResponse{} }
func (m *PolicerResponse) String() string            { return proto.CompactTextString(m) }
func (*PolicerResponse) ProtoMessage()               {}
func (*PolicerResponse) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{43} }

func (m *PolicerResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *PolicerResponse) GetStatus() *PolicerStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

// Batched responses to create/update policers
type PolicerResponseMsg struct {
	Response []*PolicerResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *PolicerResponseMsg) Reset()                    { *m = PolicerResponseMsg{} }
func (m *PolicerResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*PolicerResponseMsg) ProtoMessage()               {}
func (*PolicerResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{44} }

func (m *PolicerResponseMsg) GetResponse() []*PolicerResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

type PolicerDeleteRequest struct {
	Meta *ObjectMeta `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	// key_or_handle is policer's unique identifier
	KeyOrHandle *PolicerKeyHandle `protobuf:"bytes,2,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty" venice:"key"`
}

func (m *PolicerDeleteRequest) Reset()                    { *m = PolicerDeleteRequest{} }
func (m *PolicerDeleteRequest) String() string            { return proto.CompactTextString(m) }
func (*PolicerDeleteRequest) ProtoMessage()               {}
func (*PolicerDeleteRequest) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{45} }

func (m *PolicerDeleteRequest) GetMeta() *ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *PolicerDeleteRequest) GetKeyOrHandle() *PolicerKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

// Batched requests to delete policers
type PolicerDeleteRequestMsg struct {
	Request []*PolicerDeleteRequest `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *PolicerDeleteRequestMsg) Reset()                    { *m = PolicerDeleteRequestMsg{} }
func (m *PolicerDeleteRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*PolicerDeleteRequestMsg) ProtoMessage()               {}
func (*PolicerDeleteRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{46} }

func (m *PolicerDeleteRequestMsg) GetRequest() []*PolicerDeleteRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

// PolicerDeleteResponseMsg is batched response to PolicerDeleteRequestMsg
type PolicerDeleteResponseMsg struct {
	ApiStatus []ApiStatus `protobuf:"varint,1,rep,packed,name=api_status,json=apiStatus,enum=types.ApiStatus" json:"api_status,omitempty"`
}

func (m *PolicerDeleteResponseMsg) Reset()                    { *m = PolicerDeleteResponseMsg{} }
func (m *PolicerDeleteResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*PolicerDeleteResponseMsg) ProtoMessage()               {}
func (*PolicerDeleteResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{47} }

func (m *PolicerDeleteResponseMsg) GetApiStatus() []ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return nil
}

// PolicerGetRequest is used to get information about a policer
type PolicerGetRequest struct {
	Meta *ObjectMeta `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	// key_or_handle is policer's unique identifier
	KeyOrHandle *PolicerKeyHandle `protobuf:"bytes,2,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty" venice:"key"`
}

func (m *PolicerGetRequest) Reset()                    { *m = PolicerGetRequest{} }
func (m *PolicerGetRequest) String() string            { return proto.CompactTextString(m) }
func (*PolicerGetRequest) ProtoMessage()               {}
func (*PolicerGetRequest) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{48} }

func (m *PolicerGetRequest) GetMeta() *ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *PolicerGetRequest) GetKeyOrHandle() *PolicerKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

type PolicerGetRequestMsg struct {
	Request []*PolicerGetRequest `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *PolicerGetRequestMsg) Reset()                    { *m = PolicerGetRequestMsg{} }
func (m *PolicerGetRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*PolicerGetRequestMsg) ProtoMessage()               {}
func (*PolicerGetRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{49} }

func (m *PolicerGetRequestMsg) GetRequest() []*PolicerGetRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

// PolicerStats captures all the statistics of a policer
type PolicerStats struct {
	PermittedPackets uint64 `protobuf:"varint,1,opt,name=permitted_packets,json=permittedPackets,proto3" json:"permitted_packets,omitempty"`
	PermittedBytes   uint64 `protobuf:"varint,2,opt,name=permitted_bytes,json=permittedBytes,proto3" json:"permitted_bytes,omitempty"`
	DroppedPackets   uint64 `protobuf:"varint,3,opt,name=dropped_packets,json=droppedPackets,proto3" json:"dropped_packets,omitempty"`
	DroppedBytes     uint64 `protobuf:"varint,4,opt,name=dropped_bytes,json=droppedBytes,proto3" json:"dropped_bytes,omitempty"`
}

func (m *PolicerStats) Reset()                    { *m = PolicerStats{} }
func (m *PolicerStats) String() string            { return proto.CompactTextString(m) }
func (*PolicerStats) ProtoMessage()               {}
func (*PolicerStats) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{50} }

func (m *PolicerStats) GetPermittedPackets() uint64 {
	if m != nil {
		return m.PermittedPackets
	}
	return 0
}

func (m *PolicerStats) GetPermittedBytes() uint64 {
	if m != nil {
		return m.PermittedBytes
	}
	return 0
}

func (m *PolicerStats) GetDroppedPackets() uint64 {
	if m != nil {
		return m.DroppedPackets
	}
	return 0
}

func (m *PolicerStats) GetDroppedBytes() uint64 {
	if m != nil {
		return m.DroppedBytes
	}
	return 0
}

// PolicerGetResponse captures all the information about a policer
type PolicerGetResponse struct {
	Spec   *PolicerSpec   `protobuf:"bytes,1,opt,name=spec" json:"spec,omitempty"`
	Status *PolicerStatus `protobuf:"bytes,2,opt,name=status" json:"status,omitempty"`
	Stats  *PolicerStats  `protobuf:"bytes,3,opt,name=stats" json:"stats,omitempty"`
}

func (m *PolicerGetResponse) Reset()                    { *m = PolicerGetResponse{} }
func (m *PolicerGetResponse) String() string            { return proto.CompactTextString(m) }
func (*PolicerGetResponse) ProtoMessage()               {}
func (*PolicerGetResponse) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{51} }

func (m *PolicerGetResponse) GetSpec() *PolicerSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *PolicerGetResponse) GetStatus() *PolicerStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *PolicerGetResponse) GetStats() *PolicerStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

// PolicerGetResponseMsg is response to PolicerGetRequestMsg
type PolicerGetResponseMsg struct {
	Response []*PolicerGetResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *PolicerGetResponseMsg) Reset()                    { *m = PolicerGetResponseMsg{} }
func (m *PolicerGetResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*PolicerGetResponseMsg) ProtoMessage()               {}
func (*PolicerGetResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{52} }

func (m *PolicerGetResponseMsg) GetResponse() []*PolicerGetResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

func init() {
	proto.RegisterType((*MarkingActionSpec)(nil), "qos.MarkingActionSpec")
	proto.RegisterType((*QOSActions)(nil), "qos.QOSActions")
	proto.RegisterType((*TrafficClass)(nil), "qos.TrafficClass")
	proto.RegisterType((*TrafficClassQueueMap)(nil), "qos.TrafficClassQueueMap")
	proto.RegisterType((*BufPoolHandle)(nil), "qos.BufPoolHandle")
	proto.RegisterType((*BufPoolKeyHandle)(nil), "qos.BufPoolKeyHandle")
	proto.RegisterType((*BufPoolSpec)(nil), "qos.BufPoolSpec")
	proto.RegisterType((*BufPoolRequestMsg)(nil), "qos.BufPoolRequestMsg")
	proto.RegisterType((*BufPoolStatus)(nil), "qos.BufPoolStatus")
	proto.RegisterType((*BufPoolResponse)(nil), "qos.BufPoolResponse")
	proto.RegisterType((*BufPoolResponseMsg)(nil), "qos.BufPoolResponseMsg")
	proto.RegisterType((*BufPoolDeleteRequest)(nil), "qos.BufPoolDeleteRequest")
	proto.RegisterType((*BufPoolDeleteRequestMsg)(nil), "qos.BufPoolDeleteRequestMsg")
	proto.RegisterType((*BufPoolDeleteResponseMsg)(nil), "qos.BufPoolDeleteResponseMsg")
	proto.RegisterType((*BufPoolStats)(nil), "qos.BufPoolStats")
	proto.RegisterType((*BufPoolGetRequest)(nil), "qos.BufPoolGetRequest")
	proto.RegisterType((*BufPoolGetRequestMsg)(nil), "qos.BufPoolGetRequestMsg")
	proto.RegisterType((*BufPoolGetResponse)(nil), "qos.BufPoolGetResponse")
	proto.RegisterType((*BufPoolGetResponseMsg)(nil), "qos.BufPoolGetResponseMsg")
	proto.RegisterType((*QueueHandle)(nil), "qos.QueueHandle")
	proto.RegisterType((*QueueKeyHandle)(nil), "qos.QueueKeyHandle")
	proto.RegisterType((*DWRRInfo)(nil), "qos.DWRRInfo")
	proto.RegisterType((*StrictPriorityInfo)(nil), "qos.StrictPriorityInfo")
	proto.RegisterType((*QueueSchedulerNode)(nil), "qos.QueueSchedulerNode")
	proto.RegisterType((*QueueInfo)(nil), "qos.QueueInfo")
	proto.RegisterType((*QueueSpec)(nil), "qos.QueueSpec")
	proto.RegisterType((*QueueRequestMsg)(nil), "qos.QueueRequestMsg")
	proto.RegisterType((*QueueStatus)(nil), "qos.QueueStatus")
	proto.RegisterType((*QueueResponse)(nil), "qos.QueueResponse")
	proto.RegisterType((*QueueResponseMsg)(nil), "qos.QueueResponseMsg")
	proto.RegisterType((*QueueDeleteRequest)(nil), "qos.QueueDeleteRequest")
	proto.RegisterType((*QueueDeleteRequestMsg)(nil), "qos.QueueDeleteRequestMsg")
	proto.RegisterType((*QueueDeleteResponseMsg)(nil), "qos.QueueDeleteResponseMsg")
	proto.RegisterType((*QueueStats)(nil), "qos.QueueStats")
	proto.RegisterType((*QueueGetRequest)(nil), "qos.QueueGetRequest")
	proto.RegisterType((*QueueGetRequestMsg)(nil), "qos.QueueGetRequestMsg")
	proto.RegisterType((*QueueGetResponse)(nil), "qos.QueueGetResponse")
	proto.RegisterType((*QueueGetResponseMsg)(nil), "qos.QueueGetResponseMsg")
	proto.RegisterType((*PolicerHandle)(nil), "qos.PolicerHandle")
	proto.RegisterType((*PolicerKeyHandle)(nil), "qos.PolicerKeyHandle")
	proto.RegisterType((*PolicerSpec)(nil), "qos.PolicerSpec")
	proto.RegisterType((*PolicerRequestMsg)(nil), "qos.PolicerRequestMsg")
	proto.RegisterType((*PolicerStatus)(nil), "qos.PolicerStatus")
	proto.RegisterType((*PolicerResponse)(nil), "qos.PolicerResponse")
	proto.RegisterType((*PolicerResponseMsg)(nil), "qos.PolicerResponseMsg")
	proto.RegisterType((*PolicerDeleteRequest)(nil), "qos.PolicerDeleteRequest")
	proto.RegisterType((*PolicerDeleteRequestMsg)(nil), "qos.PolicerDeleteRequestMsg")
	proto.RegisterType((*PolicerDeleteResponseMsg)(nil), "qos.PolicerDeleteResponseMsg")
	proto.RegisterType((*PolicerGetRequest)(nil), "qos.PolicerGetRequest")
	proto.RegisterType((*PolicerGetRequestMsg)(nil), "qos.PolicerGetRequestMsg")
	proto.RegisterType((*PolicerStats)(nil), "qos.PolicerStats")
	proto.RegisterType((*PolicerGetResponse)(nil), "qos.PolicerGetResponse")
	proto.RegisterType((*PolicerGetResponseMsg)(nil), "qos.PolicerGetResponseMsg")
	proto.RegisterEnum("qos.QueueSchedulerPolicy", QueueSchedulerPolicy_name, QueueSchedulerPolicy_value)
	proto.RegisterEnum("qos.PolicerDirection", PolicerDirection_name, PolicerDirection_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for QOS service

type QOSClient interface {
	// Buffer Pool Group related APIs
	// Create a Buffer pool on a port given the buffer requirements
	BufPoolCreate(ctx context.Context, in *BufPoolRequestMsg, opts ...grpc.CallOption) (*BufPoolResponseMsg, error)
	BufPoolUpdate(ctx context.Context, in *BufPoolRequestMsg, opts ...grpc.CallOption) (*BufPoolResponseMsg, error)
	BufPoolDelete(ctx context.Context, in *BufPoolDeleteRequestMsg, opts ...grpc.CallOption) (*BufPoolDeleteResponseMsg, error)
	BufPoolGet(ctx context.Context, in *BufPoolGetRequestMsg, opts ...grpc.CallOption) (*BufPoolGetResponseMsg, error)
	// Output Queue related APIs
	QueueCreate(ctx context.Context, in *QueueRequestMsg, opts ...grpc.CallOption) (*QueueResponseMsg, error)
	QueueUpdate(ctx context.Context, in *QueueRequestMsg, opts ...grpc.CallOption) (*QueueResponseMsg, error)
	QueueDelete(ctx context.Context, in *QueueDeleteRequestMsg, opts ...grpc.CallOption) (*QueueDeleteResponseMsg, error)
	QueueGet(ctx context.Context, in *QueueGetRequestMsg, opts ...grpc.CallOption) (*QueueGetResponseMsg, error)
	// Policers
	PolicerCreate(ctx context.Context, in *PolicerRequestMsg, opts ...grpc.CallOption) (*PolicerResponseMsg, error)
	PolicerUpdate(ctx context.Context, in *PolicerRequestMsg, opts ...grpc.CallOption) (*PolicerResponseMsg, error)
	PolicerDelete(ctx context.Context, in *PolicerDeleteRequestMsg, opts ...grpc.CallOption) (*PolicerDeleteResponseMsg, error)
	PolicerGet(ctx context.Context, in *PolicerGetRequestMsg, opts ...grpc.CallOption) (*PolicerGetResponseMsg, error)
}

type qOSClient struct {
	cc *grpc.ClientConn
}

func NewQOSClient(cc *grpc.ClientConn) QOSClient {
	return &qOSClient{cc}
}

func (c *qOSClient) BufPoolCreate(ctx context.Context, in *BufPoolRequestMsg, opts ...grpc.CallOption) (*BufPoolResponseMsg, error) {
	out := new(BufPoolResponseMsg)
	err := grpc.Invoke(ctx, "/qos.QOS/BufPoolCreate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *qOSClient) BufPoolUpdate(ctx context.Context, in *BufPoolRequestMsg, opts ...grpc.CallOption) (*BufPoolResponseMsg, error) {
	out := new(BufPoolResponseMsg)
	err := grpc.Invoke(ctx, "/qos.QOS/BufPoolUpdate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *qOSClient) BufPoolDelete(ctx context.Context, in *BufPoolDeleteRequestMsg, opts ...grpc.CallOption) (*BufPoolDeleteResponseMsg, error) {
	out := new(BufPoolDeleteResponseMsg)
	err := grpc.Invoke(ctx, "/qos.QOS/BufPoolDelete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *qOSClient) BufPoolGet(ctx context.Context, in *BufPoolGetRequestMsg, opts ...grpc.CallOption) (*BufPoolGetResponseMsg, error) {
	out := new(BufPoolGetResponseMsg)
	err := grpc.Invoke(ctx, "/qos.QOS/BufPoolGet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *qOSClient) QueueCreate(ctx context.Context, in *QueueRequestMsg, opts ...grpc.CallOption) (*QueueResponseMsg, error) {
	out := new(QueueResponseMsg)
	err := grpc.Invoke(ctx, "/qos.QOS/QueueCreate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *qOSClient) QueueUpdate(ctx context.Context, in *QueueRequestMsg, opts ...grpc.CallOption) (*QueueResponseMsg, error) {
	out := new(QueueResponseMsg)
	err := grpc.Invoke(ctx, "/qos.QOS/QueueUpdate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *qOSClient) QueueDelete(ctx context.Context, in *QueueDeleteRequestMsg, opts ...grpc.CallOption) (*QueueDeleteResponseMsg, error) {
	out := new(QueueDeleteResponseMsg)
	err := grpc.Invoke(ctx, "/qos.QOS/QueueDelete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *qOSClient) QueueGet(ctx context.Context, in *QueueGetRequestMsg, opts ...grpc.CallOption) (*QueueGetResponseMsg, error) {
	out := new(QueueGetResponseMsg)
	err := grpc.Invoke(ctx, "/qos.QOS/QueueGet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *qOSClient) PolicerCreate(ctx context.Context, in *PolicerRequestMsg, opts ...grpc.CallOption) (*PolicerResponseMsg, error) {
	out := new(PolicerResponseMsg)
	err := grpc.Invoke(ctx, "/qos.QOS/PolicerCreate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *qOSClient) PolicerUpdate(ctx context.Context, in *PolicerRequestMsg, opts ...grpc.CallOption) (*PolicerResponseMsg, error) {
	out := new(PolicerResponseMsg)
	err := grpc.Invoke(ctx, "/qos.QOS/PolicerUpdate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *qOSClient) PolicerDelete(ctx context.Context, in *PolicerDeleteRequestMsg, opts ...grpc.CallOption) (*PolicerDeleteResponseMsg, error) {
	out := new(PolicerDeleteResponseMsg)
	err := grpc.Invoke(ctx, "/qos.QOS/PolicerDelete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *qOSClient) PolicerGet(ctx context.Context, in *PolicerGetRequestMsg, opts ...grpc.CallOption) (*PolicerGetResponseMsg, error) {
	out := new(PolicerGetResponseMsg)
	err := grpc.Invoke(ctx, "/qos.QOS/PolicerGet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for QOS service

type QOSServer interface {
	// Buffer Pool Group related APIs
	// Create a Buffer pool on a port given the buffer requirements
	BufPoolCreate(context.Context, *BufPoolRequestMsg) (*BufPoolResponseMsg, error)
	BufPoolUpdate(context.Context, *BufPoolRequestMsg) (*BufPoolResponseMsg, error)
	BufPoolDelete(context.Context, *BufPoolDeleteRequestMsg) (*BufPoolDeleteResponseMsg, error)
	BufPoolGet(context.Context, *BufPoolGetRequestMsg) (*BufPoolGetResponseMsg, error)
	// Output Queue related APIs
	QueueCreate(context.Context, *QueueRequestMsg) (*QueueResponseMsg, error)
	QueueUpdate(context.Context, *QueueRequestMsg) (*QueueResponseMsg, error)
	QueueDelete(context.Context, *QueueDeleteRequestMsg) (*QueueDeleteResponseMsg, error)
	QueueGet(context.Context, *QueueGetRequestMsg) (*QueueGetResponseMsg, error)
	// Policers
	PolicerCreate(context.Context, *PolicerRequestMsg) (*PolicerResponseMsg, error)
	PolicerUpdate(context.Context, *PolicerRequestMsg) (*PolicerResponseMsg, error)
	PolicerDelete(context.Context, *PolicerDeleteRequestMsg) (*PolicerDeleteResponseMsg, error)
	PolicerGet(context.Context, *PolicerGetRequestMsg) (*PolicerGetResponseMsg, error)
}

func RegisterQOSServer(s *grpc.Server, srv QOSServer) {
	s.RegisterService(&_QOS_serviceDesc, srv)
}

func _QOS_BufPoolCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BufPoolRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QOSServer).BufPoolCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/qos.QOS/BufPoolCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QOSServer).BufPoolCreate(ctx, req.(*BufPoolRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _QOS_BufPoolUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BufPoolRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QOSServer).BufPoolUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/qos.QOS/BufPoolUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QOSServer).BufPoolUpdate(ctx, req.(*BufPoolRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _QOS_BufPoolDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BufPoolDeleteRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QOSServer).BufPoolDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/qos.QOS/BufPoolDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QOSServer).BufPoolDelete(ctx, req.(*BufPoolDeleteRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _QOS_BufPoolGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BufPoolGetRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QOSServer).BufPoolGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/qos.QOS/BufPoolGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QOSServer).BufPoolGet(ctx, req.(*BufPoolGetRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _QOS_QueueCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueueRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QOSServer).QueueCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/qos.QOS/QueueCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QOSServer).QueueCreate(ctx, req.(*QueueRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _QOS_QueueUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueueRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QOSServer).QueueUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/qos.QOS/QueueUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QOSServer).QueueUpdate(ctx, req.(*QueueRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _QOS_QueueDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueueDeleteRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QOSServer).QueueDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/qos.QOS/QueueDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QOSServer).QueueDelete(ctx, req.(*QueueDeleteRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _QOS_QueueGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueueGetRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QOSServer).QueueGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/qos.QOS/QueueGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QOSServer).QueueGet(ctx, req.(*QueueGetRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _QOS_PolicerCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PolicerRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QOSServer).PolicerCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/qos.QOS/PolicerCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QOSServer).PolicerCreate(ctx, req.(*PolicerRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _QOS_PolicerUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PolicerRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QOSServer).PolicerUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/qos.QOS/PolicerUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QOSServer).PolicerUpdate(ctx, req.(*PolicerRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _QOS_PolicerDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PolicerDeleteRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QOSServer).PolicerDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/qos.QOS/PolicerDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QOSServer).PolicerDelete(ctx, req.(*PolicerDeleteRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _QOS_PolicerGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PolicerGetRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QOSServer).PolicerGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/qos.QOS/PolicerGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QOSServer).PolicerGet(ctx, req.(*PolicerGetRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

var _QOS_serviceDesc = grpc.ServiceDesc{
	ServiceName: "qos.QOS",
	HandlerType: (*QOSServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "BufPoolCreate",
			Handler:    _QOS_BufPoolCreate_Handler,
		},
		{
			MethodName: "BufPoolUpdate",
			Handler:    _QOS_BufPoolUpdate_Handler,
		},
		{
			MethodName: "BufPoolDelete",
			Handler:    _QOS_BufPoolDelete_Handler,
		},
		{
			MethodName: "BufPoolGet",
			Handler:    _QOS_BufPoolGet_Handler,
		},
		{
			MethodName: "QueueCreate",
			Handler:    _QOS_QueueCreate_Handler,
		},
		{
			MethodName: "QueueUpdate",
			Handler:    _QOS_QueueUpdate_Handler,
		},
		{
			MethodName: "QueueDelete",
			Handler:    _QOS_QueueDelete_Handler,
		},
		{
			MethodName: "QueueGet",
			Handler:    _QOS_QueueGet_Handler,
		},
		{
			MethodName: "PolicerCreate",
			Handler:    _QOS_PolicerCreate_Handler,
		},
		{
			MethodName: "PolicerUpdate",
			Handler:    _QOS_PolicerUpdate_Handler,
		},
		{
			MethodName: "PolicerDelete",
			Handler:    _QOS_PolicerDelete_Handler,
		},
		{
			MethodName: "PolicerGet",
			Handler:    _QOS_PolicerGet_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "nic/proto/hal/qos.proto",
}

func (m *MarkingActionSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MarkingActionSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PcpRewriteEn {
		dAtA[i] = 0x8
		i++
		if m.PcpRewriteEn {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Pcp != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.Pcp))
	}
	if m.DscpRewriteEn {
		dAtA[i] = 0x18
		i++
		if m.DscpRewriteEn {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Dscp != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.Dscp))
	}
	return i, nil
}

func (m *QOSActions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QOSActions) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.QueueKeyOrHandle != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.QueueKeyOrHandle.Size()))
		n1, err := m.QueueKeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.PolicerKeyOrHandle != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.PolicerKeyOrHandle.Size()))
		n2, err := m.PolicerKeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.MarkingSpec != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.MarkingSpec.Size()))
		n3, err := m.MarkingSpec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}

func (m *TrafficClass) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TrafficClass) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Cos != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.Cos))
	}
	return i, nil
}

func (m *TrafficClassQueueMap) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TrafficClassQueueMap) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TrafficClass != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.TrafficClass.Size()))
		n4, err := m.TrafficClass.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.QueueKeyHandle != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.QueueKeyHandle.Size()))
		n5, err := m.QueueKeyHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	return i, nil
}

func (m *BufPoolHandle) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BufPoolHandle) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Handle != 0 {
		dAtA[i] = 0x9
		i++
		i = encodeFixed64Qos(dAtA, i, uint64(m.Handle))
	}
	return i, nil
}

func (m *BufPoolKeyHandle) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BufPoolKeyHandle) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.KeyOrHandle != nil {
		nn6, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn6
	}
	return i, nil
}

func (m *BufPoolKeyHandle_BufPoolId) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0xd
	i++
	i = encodeFixed32Qos(dAtA, i, uint32(m.BufPoolId))
	return i, nil
}
func (m *BufPoolKeyHandle_BufPoolHandle) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.BufPoolHandle != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.BufPoolHandle.Size()))
		n7, err := m.BufPoolHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	return i, nil
}
func (m *BufPoolSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BufPoolSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.Meta.Size()))
		n8, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.KeyOrHandle != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n9, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.PortNum != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.PortNum))
	}
	if m.ReservedBytes != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.ReservedBytes))
	}
	if m.HeadroomBytes != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.HeadroomBytes))
	}
	if m.SharingFactor != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.SharingFactor))
	}
	if m.XonThreshold != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.XonThreshold))
	}
	if m.XoffClearLimit != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.XoffClearLimit))
	}
	if m.Mtu != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.Mtu))
	}
	if len(m.Tcs) > 0 {
		for _, msg := range m.Tcs {
			dAtA[i] = 0x52
			i++
			i = encodeVarintQos(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *BufPoolRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BufPoolRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintQos(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *BufPoolStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BufPoolStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.BufPoolHandle != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.BufPoolHandle.Size()))
		n10, err := m.BufPoolHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	return i, nil
}

func (m *BufPoolResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BufPoolResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.ApiStatus))
	}
	if m.Status != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.Status.Size()))
		n11, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	return i, nil
}

func (m *BufPoolResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BufPoolResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintQos(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *BufPoolDeleteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BufPoolDeleteRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.Meta.Size()))
		n12, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if m.KeyOrHandle != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n13, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	return i, nil
}

func (m *BufPoolDeleteRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BufPoolDeleteRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintQos(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *BufPoolDeleteResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BufPoolDeleteResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ApiStatus) > 0 {
		dAtA15 := make([]byte, len(m.ApiStatus)*10)
		var j14 int
		for _, num := range m.ApiStatus {
			for num >= 1<<7 {
				dAtA15[j14] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j14++
			}
			dAtA15[j14] = uint8(num)
			j14++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintQos(dAtA, i, uint64(j14))
		i += copy(dAtA[i:], dAtA15[:j14])
	}
	return i, nil
}

func (m *BufPoolStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BufPoolStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Occupancy != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.Occupancy))
	}
	return i, nil
}

func (m *BufPoolGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BufPoolGetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.Meta.Size()))
		n16, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	if m.KeyOrHandle != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n17, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	return i, nil
}

func (m *BufPoolGetRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BufPoolGetRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintQos(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *BufPoolGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BufPoolGetResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Spec != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.Spec.Size()))
		n18, err := m.Spec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	if m.Status != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.Status.Size()))
		n19, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	if m.Stats != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.Stats.Size()))
		n20, err := m.Stats.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	return i, nil
}

func (m *BufPoolGetResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BufPoolGetResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintQos(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *QueueHandle) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueueHandle) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Handle != 0 {
		dAtA[i] = 0x9
		i++
		i = encodeFixed64Qos(dAtA, i, uint64(m.Handle))
	}
	return i, nil
}

func (m *QueueKeyHandle) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueueKeyHandle) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.KeyOrHandle != nil {
		nn21, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn21
	}
	return i, nil
}

func (m *QueueKeyHandle_QueueId) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0xd
	i++
	i = encodeFixed32Qos(dAtA, i, uint32(m.QueueId))
	return i, nil
}
func (m *QueueKeyHandle_QueueHandle) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.QueueHandle != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.QueueHandle.Size()))
		n22, err := m.QueueHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	return i, nil
}
func (m *DWRRInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DWRRInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Weight != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.Weight))
	}
	return i, nil
}

func (m *StrictPriorityInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StrictPriorityInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Rate != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.Rate))
	}
	return i, nil
}

func (m *QueueSchedulerNode) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueueSchedulerNode) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Priority != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.Priority))
	}
	if m.QueueType != nil {
		nn23, err := m.QueueType.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn23
	}
	return i, nil
}

func (m *QueueSchedulerNode_Dwrr) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Dwrr != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.Dwrr.Size()))
		n24, err := m.Dwrr.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	return i, nil
}
func (m *QueueSchedulerNode_Strict) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Strict != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.Strict.Size()))
		n25, err := m.Strict.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	return i, nil
}
func (m *QueueInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueueInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.KeyOrHandle != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n26, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n26
	}
	if m.QueueInfo != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.QueueInfo.Size()))
		n27, err := m.QueueInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n27
	}
	return i, nil
}

func (m *QueueSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueueSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.Meta.Size()))
		n28, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n28
	}
	if m.PortNum != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.PortNum))
	}
	if m.SchedulerPolicy != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.SchedulerPolicy))
	}
	if len(m.Queues) > 0 {
		for _, msg := range m.Queues {
			dAtA[i] = 0x22
			i++
			i = encodeVarintQos(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.L1Nodes) > 0 {
		for _, msg := range m.L1Nodes {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintQos(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *QueueRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueueRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintQos(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *QueueStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueueStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.QueueHandle != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.QueueHandle.Size()))
		n29, err := m.QueueHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n29
	}
	return i, nil
}

func (m *QueueResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueueResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.ApiStatus))
	}
	if len(m.Status) > 0 {
		for _, msg := range m.Status {
			dAtA[i] = 0x12
			i++
			i = encodeVarintQos(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *QueueResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueueResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintQos(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *QueueDeleteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueueDeleteRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.Meta.Size()))
		n30, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n30
	}
	if m.KeyOrHandle != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n31, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n31
	}
	return i, nil
}

func (m *QueueDeleteRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueueDeleteRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintQos(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *QueueDeleteResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueueDeleteResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ApiStatus) > 0 {
		dAtA33 := make([]byte, len(m.ApiStatus)*10)
		var j32 int
		for _, num := range m.ApiStatus {
			for num >= 1<<7 {
				dAtA33[j32] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j32++
			}
			dAtA33[j32] = uint8(num)
			j32++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintQos(dAtA, i, uint64(j32))
		i += copy(dAtA[i:], dAtA33[:j32])
	}
	return i, nil
}

func (m *QueueStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueueStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.QueueDepth != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.QueueDepth))
	}
	return i, nil
}

func (m *QueueGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueueGetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.Meta.Size()))
		n34, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n34
	}
	if m.KeyOrHandle != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n35, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n35
	}
	return i, nil
}

func (m *QueueGetRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueueGetRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintQos(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *QueueGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueueGetResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Spec != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.Spec.Size()))
		n36, err := m.Spec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n36
	}
	if m.Status != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.Status.Size()))
		n37, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n37
	}
	if m.Stats != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.Stats.Size()))
		n38, err := m.Stats.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n38
	}
	return i, nil
}

func (m *QueueGetResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueueGetResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintQos(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *PolicerHandle) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PolicerHandle) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Handle != 0 {
		dAtA[i] = 0x9
		i++
		i = encodeFixed64Qos(dAtA, i, uint64(m.Handle))
	}
	return i, nil
}

func (m *PolicerKeyHandle) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PolicerKeyHandle) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.KeyOrHandle != nil {
		nn39, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn39
	}
	return i, nil
}

func (m *PolicerKeyHandle_PolicerId) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0xd
	i++
	i = encodeFixed32Qos(dAtA, i, uint32(m.PolicerId))
	return i, nil
}
func (m *PolicerKeyHandle_PolicerHandle) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.PolicerHandle != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.PolicerHandle.Size()))
		n40, err := m.PolicerHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n40
	}
	return i, nil
}
func (m *PolicerSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PolicerSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.Meta.Size()))
		n41, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n41
	}
	if m.KeyOrHandle != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n42, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n42
	}
	if m.Direction != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.Direction))
	}
	if m.Bandwidth != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.Bandwidth))
	}
	if m.BurstSize != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.BurstSize))
	}
	if m.MarkingSpec != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.MarkingSpec.Size()))
		n43, err := m.MarkingSpec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n43
	}
	return i, nil
}

func (m *PolicerRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PolicerRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintQos(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *PolicerStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PolicerStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PolicerHandle != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.PolicerHandle.Size()))
		n44, err := m.PolicerHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n44
	}
	return i, nil
}

func (m *PolicerResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PolicerResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.ApiStatus))
	}
	if m.Status != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.Status.Size()))
		n45, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n45
	}
	return i, nil
}

func (m *PolicerResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PolicerResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintQos(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *PolicerDeleteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PolicerDeleteRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.Meta.Size()))
		n46, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n46
	}
	if m.KeyOrHandle != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n47, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n47
	}
	return i, nil
}

func (m *PolicerDeleteRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PolicerDeleteRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintQos(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *PolicerDeleteResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PolicerDeleteResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ApiStatus) > 0 {
		dAtA49 := make([]byte, len(m.ApiStatus)*10)
		var j48 int
		for _, num := range m.ApiStatus {
			for num >= 1<<7 {
				dAtA49[j48] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j48++
			}
			dAtA49[j48] = uint8(num)
			j48++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintQos(dAtA, i, uint64(j48))
		i += copy(dAtA[i:], dAtA49[:j48])
	}
	return i, nil
}

func (m *PolicerGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PolicerGetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.Meta.Size()))
		n50, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n50
	}
	if m.KeyOrHandle != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n51, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n51
	}
	return i, nil
}

func (m *PolicerGetRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PolicerGetRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintQos(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *PolicerStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PolicerStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PermittedPackets != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.PermittedPackets))
	}
	if m.PermittedBytes != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.PermittedBytes))
	}
	if m.DroppedPackets != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.DroppedPackets))
	}
	if m.DroppedBytes != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.DroppedBytes))
	}
	return i, nil
}

func (m *PolicerGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PolicerGetResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Spec != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.Spec.Size()))
		n52, err := m.Spec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n52
	}
	if m.Status != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.Status.Size()))
		n53, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n53
	}
	if m.Stats != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.Stats.Size()))
		n54, err := m.Stats.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n54
	}
	return i, nil
}

func (m *PolicerGetResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PolicerGetResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintQos(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func encodeFixed64Qos(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Qos(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintQos(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *MarkingActionSpec) Size() (n int) {
	var l int
	_ = l
	if m.PcpRewriteEn {
		n += 2
	}
	if m.Pcp != 0 {
		n += 1 + sovQos(uint64(m.Pcp))
	}
	if m.DscpRewriteEn {
		n += 2
	}
	if m.Dscp != 0 {
		n += 1 + sovQos(uint64(m.Dscp))
	}
	return n
}

func (m *QOSActions) Size() (n int) {
	var l int
	_ = l
	if m.QueueKeyOrHandle != nil {
		l = m.QueueKeyOrHandle.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	if m.PolicerKeyOrHandle != nil {
		l = m.PolicerKeyOrHandle.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	if m.MarkingSpec != nil {
		l = m.MarkingSpec.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	return n
}

func (m *TrafficClass) Size() (n int) {
	var l int
	_ = l
	if m.Cos != 0 {
		n += 1 + sovQos(uint64(m.Cos))
	}
	return n
}

func (m *TrafficClassQueueMap) Size() (n int) {
	var l int
	_ = l
	if m.TrafficClass != nil {
		l = m.TrafficClass.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	if m.QueueKeyHandle != nil {
		l = m.QueueKeyHandle.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	return n
}

func (m *BufPoolHandle) Size() (n int) {
	var l int
	_ = l
	if m.Handle != 0 {
		n += 9
	}
	return n
}

func (m *BufPoolKeyHandle) Size() (n int) {
	var l int
	_ = l
	if m.KeyOrHandle != nil {
		n += m.KeyOrHandle.Size()
	}
	return n
}

func (m *BufPoolKeyHandle_BufPoolId) Size() (n int) {
	var l int
	_ = l
	n += 5
	return n
}
func (m *BufPoolKeyHandle_BufPoolHandle) Size() (n int) {
	var l int
	_ = l
	if m.BufPoolHandle != nil {
		l = m.BufPoolHandle.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	return n
}
func (m *BufPoolSpec) Size() (n int) {
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	if m.PortNum != 0 {
		n += 1 + sovQos(uint64(m.PortNum))
	}
	if m.ReservedBytes != 0 {
		n += 1 + sovQos(uint64(m.ReservedBytes))
	}
	if m.HeadroomBytes != 0 {
		n += 1 + sovQos(uint64(m.HeadroomBytes))
	}
	if m.SharingFactor != 0 {
		n += 1 + sovQos(uint64(m.SharingFactor))
	}
	if m.XonThreshold != 0 {
		n += 1 + sovQos(uint64(m.XonThreshold))
	}
	if m.XoffClearLimit != 0 {
		n += 1 + sovQos(uint64(m.XoffClearLimit))
	}
	if m.Mtu != 0 {
		n += 1 + sovQos(uint64(m.Mtu))
	}
	if len(m.Tcs) > 0 {
		for _, e := range m.Tcs {
			l = e.Size()
			n += 1 + l + sovQos(uint64(l))
		}
	}
	return n
}

func (m *BufPoolRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovQos(uint64(l))
		}
	}
	return n
}

func (m *BufPoolStatus) Size() (n int) {
	var l int
	_ = l
	if m.BufPoolHandle != nil {
		l = m.BufPoolHandle.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	return n
}

func (m *BufPoolResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovQos(uint64(m.ApiStatus))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	return n
}

func (m *BufPoolResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovQos(uint64(l))
		}
	}
	return n
}

func (m *BufPoolDeleteRequest) Size() (n int) {
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	return n
}

func (m *BufPoolDeleteRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovQos(uint64(l))
		}
	}
	return n
}

func (m *BufPoolDeleteResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.ApiStatus) > 0 {
		l = 0
		for _, e := range m.ApiStatus {
			l += sovQos(uint64(e))
		}
		n += 1 + sovQos(uint64(l)) + l
	}
	return n
}

func (m *BufPoolStats) Size() (n int) {
	var l int
	_ = l
	if m.Occupancy != 0 {
		n += 1 + sovQos(uint64(m.Occupancy))
	}
	return n
}

func (m *BufPoolGetRequest) Size() (n int) {
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	return n
}

func (m *BufPoolGetRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovQos(uint64(l))
		}
	}
	return n
}

func (m *BufPoolGetResponse) Size() (n int) {
	var l int
	_ = l
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	if m.Stats != nil {
		l = m.Stats.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	return n
}

func (m *BufPoolGetResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovQos(uint64(l))
		}
	}
	return n
}

func (m *QueueHandle) Size() (n int) {
	var l int
	_ = l
	if m.Handle != 0 {
		n += 9
	}
	return n
}

func (m *QueueKeyHandle) Size() (n int) {
	var l int
	_ = l
	if m.KeyOrHandle != nil {
		n += m.KeyOrHandle.Size()
	}
	return n
}

func (m *QueueKeyHandle_QueueId) Size() (n int) {
	var l int
	_ = l
	n += 5
	return n
}
func (m *QueueKeyHandle_QueueHandle) Size() (n int) {
	var l int
	_ = l
	if m.QueueHandle != nil {
		l = m.QueueHandle.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	return n
}
func (m *DWRRInfo) Size() (n int) {
	var l int
	_ = l
	if m.Weight != 0 {
		n += 1 + sovQos(uint64(m.Weight))
	}
	return n
}

func (m *StrictPriorityInfo) Size() (n int) {
	var l int
	_ = l
	if m.Rate != 0 {
		n += 1 + sovQos(uint64(m.Rate))
	}
	return n
}

func (m *QueueSchedulerNode) Size() (n int) {
	var l int
	_ = l
	if m.Priority != 0 {
		n += 1 + sovQos(uint64(m.Priority))
	}
	if m.QueueType != nil {
		n += m.QueueType.Size()
	}
	return n
}

func (m *QueueSchedulerNode_Dwrr) Size() (n int) {
	var l int
	_ = l
	if m.Dwrr != nil {
		l = m.Dwrr.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	return n
}
func (m *QueueSchedulerNode_Strict) Size() (n int) {
	var l int
	_ = l
	if m.Strict != nil {
		l = m.Strict.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	return n
}
func (m *QueueInfo) Size() (n int) {
	var l int
	_ = l
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	if m.QueueInfo != nil {
		l = m.QueueInfo.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	return n
}

func (m *QueueSpec) Size() (n int) {
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	if m.PortNum != 0 {
		n += 1 + sovQos(uint64(m.PortNum))
	}
	if m.SchedulerPolicy != 0 {
		n += 1 + sovQos(uint64(m.SchedulerPolicy))
	}
	if len(m.Queues) > 0 {
		for _, e := range m.Queues {
			l = e.Size()
			n += 1 + l + sovQos(uint64(l))
		}
	}
	if len(m.L1Nodes) > 0 {
		for _, e := range m.L1Nodes {
			l = e.Size()
			n += 1 + l + sovQos(uint64(l))
		}
	}
	return n
}

func (m *QueueRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovQos(uint64(l))
		}
	}
	return n
}

func (m *QueueStatus) Size() (n int) {
	var l int
	_ = l
	if m.QueueHandle != nil {
		l = m.QueueHandle.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	return n
}

func (m *QueueResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovQos(uint64(m.ApiStatus))
	}
	if len(m.Status) > 0 {
		for _, e := range m.Status {
			l = e.Size()
			n += 1 + l + sovQos(uint64(l))
		}
	}
	return n
}

func (m *QueueResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovQos(uint64(l))
		}
	}
	return n
}

func (m *QueueDeleteRequest) Size() (n int) {
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	return n
}

func (m *QueueDeleteRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovQos(uint64(l))
		}
	}
	return n
}

func (m *QueueDeleteResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.ApiStatus) > 0 {
		l = 0
		for _, e := range m.ApiStatus {
			l += sovQos(uint64(e))
		}
		n += 1 + sovQos(uint64(l)) + l
	}
	return n
}

func (m *QueueStats) Size() (n int) {
	var l int
	_ = l
	if m.QueueDepth != 0 {
		n += 1 + sovQos(uint64(m.QueueDepth))
	}
	return n
}

func (m *QueueGetRequest) Size() (n int) {
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	return n
}

func (m *QueueGetRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovQos(uint64(l))
		}
	}
	return n
}

func (m *QueueGetResponse) Size() (n int) {
	var l int
	_ = l
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	if m.Stats != nil {
		l = m.Stats.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	return n
}

func (m *QueueGetResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovQos(uint64(l))
		}
	}
	return n
}

func (m *PolicerHandle) Size() (n int) {
	var l int
	_ = l
	if m.Handle != 0 {
		n += 9
	}
	return n
}

func (m *PolicerKeyHandle) Size() (n int) {
	var l int
	_ = l
	if m.KeyOrHandle != nil {
		n += m.KeyOrHandle.Size()
	}
	return n
}

func (m *PolicerKeyHandle_PolicerId) Size() (n int) {
	var l int
	_ = l
	n += 5
	return n
}
func (m *PolicerKeyHandle_PolicerHandle) Size() (n int) {
	var l int
	_ = l
	if m.PolicerHandle != nil {
		l = m.PolicerHandle.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	return n
}
func (m *PolicerSpec) Size() (n int) {
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	if m.Direction != 0 {
		n += 1 + sovQos(uint64(m.Direction))
	}
	if m.Bandwidth != 0 {
		n += 1 + sovQos(uint64(m.Bandwidth))
	}
	if m.BurstSize != 0 {
		n += 1 + sovQos(uint64(m.BurstSize))
	}
	if m.MarkingSpec != nil {
		l = m.MarkingSpec.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	return n
}

func (m *PolicerRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovQos(uint64(l))
		}
	}
	return n
}

func (m *PolicerStatus) Size() (n int) {
	var l int
	_ = l
	if m.PolicerHandle != nil {
		l = m.PolicerHandle.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	return n
}

func (m *PolicerResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovQos(uint64(m.ApiStatus))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	return n
}

func (m *PolicerResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovQos(uint64(l))
		}
	}
	return n
}

func (m *PolicerDeleteRequest) Size() (n int) {
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	return n
}

func (m *PolicerDeleteRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovQos(uint64(l))
		}
	}
	return n
}

func (m *PolicerDeleteResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.ApiStatus) > 0 {
		l = 0
		for _, e := range m.ApiStatus {
			l += sovQos(uint64(e))
		}
		n += 1 + sovQos(uint64(l)) + l
	}
	return n
}

func (m *PolicerGetRequest) Size() (n int) {
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	return n
}

func (m *PolicerGetRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovQos(uint64(l))
		}
	}
	return n
}

func (m *PolicerStats) Size() (n int) {
	var l int
	_ = l
	if m.PermittedPackets != 0 {
		n += 1 + sovQos(uint64(m.PermittedPackets))
	}
	if m.PermittedBytes != 0 {
		n += 1 + sovQos(uint64(m.PermittedBytes))
	}
	if m.DroppedPackets != 0 {
		n += 1 + sovQos(uint64(m.DroppedPackets))
	}
	if m.DroppedBytes != 0 {
		n += 1 + sovQos(uint64(m.DroppedBytes))
	}
	return n
}

func (m *PolicerGetResponse) Size() (n int) {
	var l int
	_ = l
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	if m.Stats != nil {
		l = m.Stats.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	return n
}

func (m *PolicerGetResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovQos(uint64(l))
		}
	}
	return n
}

func sovQos(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozQos(x uint64) (n int) {
	return sovQos(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *MarkingActionSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MarkingActionSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MarkingActionSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PcpRewriteEn", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PcpRewriteEn = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pcp", wireType)
			}
			m.Pcp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pcp |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DscpRewriteEn", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DscpRewriteEn = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dscp", wireType)
			}
			m.Dscp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Dscp |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QOSActions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QOSActions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QOSActions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueueKeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.QueueKeyOrHandle == nil {
				m.QueueKeyOrHandle = &QueueKeyHandle{}
			}
			if err := m.QueueKeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PolicerKeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PolicerKeyOrHandle == nil {
				m.PolicerKeyOrHandle = &PolicerKeyHandle{}
			}
			if err := m.PolicerKeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarkingSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MarkingSpec == nil {
				m.MarkingSpec = &MarkingActionSpec{}
			}
			if err := m.MarkingSpec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TrafficClass) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TrafficClass: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TrafficClass: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cos", wireType)
			}
			m.Cos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cos |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TrafficClassQueueMap) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TrafficClassQueueMap: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TrafficClassQueueMap: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrafficClass", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TrafficClass == nil {
				m.TrafficClass = &TrafficClass{}
			}
			if err := m.TrafficClass.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueueKeyHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.QueueKeyHandle == nil {
				m.QueueKeyHandle = &QueueKeyHandle{}
			}
			if err := m.QueueKeyHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BufPoolHandle) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BufPoolHandle: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BufPoolHandle: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Handle", wireType)
			}
			m.Handle = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			m.Handle = uint64(dAtA[iNdEx-8])
			m.Handle |= uint64(dAtA[iNdEx-7]) << 8
			m.Handle |= uint64(dAtA[iNdEx-6]) << 16
			m.Handle |= uint64(dAtA[iNdEx-5]) << 24
			m.Handle |= uint64(dAtA[iNdEx-4]) << 32
			m.Handle |= uint64(dAtA[iNdEx-3]) << 40
			m.Handle |= uint64(dAtA[iNdEx-2]) << 48
			m.Handle |= uint64(dAtA[iNdEx-1]) << 56
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BufPoolKeyHandle) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BufPoolKeyHandle: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BufPoolKeyHandle: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field BufPoolId", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.KeyOrHandle = &BufPoolKeyHandle_BufPoolId{v}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BufPoolHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &BufPoolHandle{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.KeyOrHandle = &BufPoolKeyHandle_BufPoolHandle{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BufPoolSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BufPoolSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BufPoolSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &ObjectMeta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &BufPoolKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortNum", wireType)
			}
			m.PortNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PortNum |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReservedBytes", wireType)
			}
			m.ReservedBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReservedBytes |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeadroomBytes", wireType)
			}
			m.HeadroomBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HeadroomBytes |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SharingFactor", wireType)
			}
			m.SharingFactor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SharingFactor |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field XonThreshold", wireType)
			}
			m.XonThreshold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.XonThreshold |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field XoffClearLimit", wireType)
			}
			m.XoffClearLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.XoffClearLimit |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mtu", wireType)
			}
			m.Mtu = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mtu |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tcs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tcs = append(m.Tcs, &TrafficClass{})
			if err := m.Tcs[len(m.Tcs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BufPoolRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BufPoolRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BufPoolRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &BufPoolSpec{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BufPoolStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BufPoolStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BufPoolStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BufPoolHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BufPoolHandle == nil {
				m.BufPoolHandle = &BufPoolHandle{}
			}
			if err := m.BufPoolHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BufPoolResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BufPoolResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BufPoolResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &BufPoolStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BufPoolResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BufPoolResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BufPoolResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &BufPoolResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BufPoolDeleteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BufPoolDeleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BufPoolDeleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &ObjectMeta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &BufPoolKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BufPoolDeleteRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BufPoolDeleteRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BufPoolDeleteRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &BufPoolDeleteRequest{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BufPoolDeleteResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BufPoolDeleteResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BufPoolDeleteResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v ApiStatus
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowQos
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (ApiStatus(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ApiStatus = append(m.ApiStatus, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowQos
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthQos
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v ApiStatus
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowQos
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (ApiStatus(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ApiStatus = append(m.ApiStatus, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BufPoolStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BufPoolStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BufPoolStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Occupancy", wireType)
			}
			m.Occupancy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Occupancy |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BufPoolGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BufPoolGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BufPoolGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &ObjectMeta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &BufPoolKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BufPoolGetRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BufPoolGetRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BufPoolGetRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &BufPoolGetRequest{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BufPoolGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BufPoolGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BufPoolGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &BufPoolSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &BufPoolStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = &BufPoolStats{}
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BufPoolGetResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BufPoolGetResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BufPoolGetResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &BufPoolGetResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueueHandle) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueueHandle: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueueHandle: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Handle", wireType)
			}
			m.Handle = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			m.Handle = uint64(dAtA[iNdEx-8])
			m.Handle |= uint64(dAtA[iNdEx-7]) << 8
			m.Handle |= uint64(dAtA[iNdEx-6]) << 16
			m.Handle |= uint64(dAtA[iNdEx-5]) << 24
			m.Handle |= uint64(dAtA[iNdEx-4]) << 32
			m.Handle |= uint64(dAtA[iNdEx-3]) << 40
			m.Handle |= uint64(dAtA[iNdEx-2]) << 48
			m.Handle |= uint64(dAtA[iNdEx-1]) << 56
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueueKeyHandle) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueueKeyHandle: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueueKeyHandle: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueueId", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.KeyOrHandle = &QueueKeyHandle_QueueId{v}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueueHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &QueueHandle{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.KeyOrHandle = &QueueKeyHandle_QueueHandle{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DWRRInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DWRRInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DWRRInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Weight", wireType)
			}
			m.Weight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Weight |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StrictPriorityInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StrictPriorityInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StrictPriorityInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rate", wireType)
			}
			m.Rate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rate |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueueSchedulerNode) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueueSchedulerNode: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueueSchedulerNode: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Priority", wireType)
			}
			m.Priority = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Priority |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dwrr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DWRRInfo{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.QueueType = &QueueSchedulerNode_Dwrr{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Strict", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &StrictPriorityInfo{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.QueueType = &QueueSchedulerNode_Strict{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueueInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueueInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueueInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &QueueKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueueInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.QueueInfo == nil {
				m.QueueInfo = &QueueSchedulerNode{}
			}
			if err := m.QueueInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueueSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueueSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueueSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &ObjectMeta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortNum", wireType)
			}
			m.PortNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PortNum |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SchedulerPolicy", wireType)
			}
			m.SchedulerPolicy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SchedulerPolicy |= (QueueSchedulerPolicy(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Queues", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Queues = append(m.Queues, &QueueInfo{})
			if err := m.Queues[len(m.Queues)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field L1Nodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.L1Nodes = append(m.L1Nodes, &QueueSchedulerNode{})
			if err := m.L1Nodes[len(m.L1Nodes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueueRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueueRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueueRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &QueueSpec{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueueStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueueStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueueStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueueHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.QueueHandle == nil {
				m.QueueHandle = &QueueHandle{}
			}
			if err := m.QueueHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueueResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueueResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueueResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = append(m.Status, &QueueStatus{})
			if err := m.Status[len(m.Status)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueueResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueueResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueueResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &QueueResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueueDeleteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueueDeleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueueDeleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &ObjectMeta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &QueueKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueueDeleteRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueueDeleteRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueueDeleteRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &QueueDeleteRequest{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueueDeleteResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueueDeleteResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueueDeleteResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v ApiStatus
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowQos
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (ApiStatus(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ApiStatus = append(m.ApiStatus, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowQos
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthQos
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v ApiStatus
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowQos
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (ApiStatus(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ApiStatus = append(m.ApiStatus, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueueStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueueStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueueStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueueDepth", wireType)
			}
			m.QueueDepth = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.QueueDepth |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueueGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueueGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueueGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &ObjectMeta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &QueueKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueueGetRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueueGetRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueueGetRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &QueueGetRequest{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueueGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueueGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueueGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &QueueSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &QueueStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = &QueueStats{}
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueueGetResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueueGetResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueueGetResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &QueueGetResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PolicerHandle) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PolicerHandle: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PolicerHandle: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Handle", wireType)
			}
			m.Handle = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			m.Handle = uint64(dAtA[iNdEx-8])
			m.Handle |= uint64(dAtA[iNdEx-7]) << 8
			m.Handle |= uint64(dAtA[iNdEx-6]) << 16
			m.Handle |= uint64(dAtA[iNdEx-5]) << 24
			m.Handle |= uint64(dAtA[iNdEx-4]) << 32
			m.Handle |= uint64(dAtA[iNdEx-3]) << 40
			m.Handle |= uint64(dAtA[iNdEx-2]) << 48
			m.Handle |= uint64(dAtA[iNdEx-1]) << 56
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PolicerKeyHandle) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PolicerKeyHandle: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PolicerKeyHandle: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field PolicerId", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.KeyOrHandle = &PolicerKeyHandle_PolicerId{v}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PolicerHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PolicerHandle{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.KeyOrHandle = &PolicerKeyHandle_PolicerHandle{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PolicerSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PolicerSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PolicerSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &ObjectMeta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &PolicerKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Direction", wireType)
			}
			m.Direction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Direction |= (PolicerDirection(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bandwidth", wireType)
			}
			m.Bandwidth = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Bandwidth |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BurstSize", wireType)
			}
			m.BurstSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BurstSize |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarkingSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MarkingSpec == nil {
				m.MarkingSpec = &MarkingActionSpec{}
			}
			if err := m.MarkingSpec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PolicerRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PolicerRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PolicerRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &PolicerSpec{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PolicerStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PolicerStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PolicerStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PolicerHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PolicerHandle == nil {
				m.PolicerHandle = &PolicerHandle{}
			}
			if err := m.PolicerHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PolicerResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PolicerResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PolicerResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &PolicerStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PolicerResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PolicerResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PolicerResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &PolicerResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PolicerDeleteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PolicerDeleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PolicerDeleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &ObjectMeta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &PolicerKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PolicerDeleteRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PolicerDeleteRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PolicerDeleteRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &PolicerDeleteRequest{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PolicerDeleteResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PolicerDeleteResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PolicerDeleteResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v ApiStatus
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowQos
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (ApiStatus(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ApiStatus = append(m.ApiStatus, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowQos
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthQos
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v ApiStatus
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowQos
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (ApiStatus(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ApiStatus = append(m.ApiStatus, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PolicerGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PolicerGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PolicerGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &ObjectMeta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &PolicerKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PolicerGetRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PolicerGetRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PolicerGetRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &PolicerGetRequest{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PolicerStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PolicerStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PolicerStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PermittedPackets", wireType)
			}
			m.PermittedPackets = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PermittedPackets |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PermittedBytes", wireType)
			}
			m.PermittedBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PermittedBytes |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DroppedPackets", wireType)
			}
			m.DroppedPackets = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DroppedPackets |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DroppedBytes", wireType)
			}
			m.DroppedBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DroppedBytes |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PolicerGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PolicerGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PolicerGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &PolicerSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &PolicerStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = &PolicerStats{}
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PolicerGetResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PolicerGetResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PolicerGetResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &PolicerGetResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipQos(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowQos
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowQos
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowQos
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthQos
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowQos
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipQos(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthQos = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowQos   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("nic/proto/hal/qos.proto", fileDescriptorQos) }

var fileDescriptorQos = []byte{
	// 1968 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x59, 0x5f, 0x6f, 0xdc, 0xc6,
	0x11, 0x3f, 0xea, 0x14, 0xe9, 0x34, 0xf7, 0x8f, 0x5a, 0xeb, 0xcf, 0x59, 0x49, 0x6c, 0x81, 0x8e,
	0x23, 0xc1, 0x6d, 0xed, 0x4a, 0x4e, 0x83, 0x26, 0x4e, 0x61, 0xe4, 0xa4, 0x4b, 0xee, 0x62, 0xeb,
	0x8f, 0x79, 0x36, 0x0a, 0xf4, 0x85, 0xa0, 0xc8, 0x3d, 0x1f, 0xad, 0x3b, 0x92, 0x22, 0xf7, 0x62,
	0x5f, 0xde, 0x8a, 0x02, 0x0d, 0x50, 0xa0, 0xed, 0x53, 0xd1, 0x7e, 0x8a, 0x3e, 0xf4, 0x53, 0x14,
	0x7d, 0xea, 0x4b, 0x5f, 0x8b, 0xc2, 0xfd, 0x00, 0x05, 0xfa, 0x09, 0x82, 0x5d, 0x2e, 0xc9, 0x5d,
	0x92, 0x27, 0x45, 0x8e, 0x00, 0x3f, 0xe9, 0x76, 0x66, 0x76, 0x76, 0x66, 0xf6, 0xb7, 0xfb, 0xdb,
	0xa1, 0x60, 0xdd, 0x75, 0xac, 0x7b, 0x7e, 0xe0, 0x11, 0xef, 0xde, 0xd0, 0x1c, 0xdd, 0x3b, 0xf3,
	0xc2, 0xbb, 0x6c, 0x84, 0xca, 0x67, 0x5e, 0xb8, 0xb1, 0x9a, 0x6a, 0xc9, 0xd4, 0xc7, 0x5c, 0xa7,
	0x7d, 0xab, 0xc0, 0xf2, 0x81, 0x19, 0x9c, 0x3a, 0xee, 0xf3, 0xcf, 0x2d, 0xe2, 0x78, 0x6e, 0xdf,
	0xc7, 0x16, 0xfa, 0x00, 0x1a, 0xbe, 0xe5, 0x1b, 0x01, 0x7e, 0x19, 0x38, 0x04, 0x1b, 0xd8, 0x6d,
	0x29, 0x9b, 0xca, 0x76, 0x45, 0xaf, 0xf9, 0x96, 0xaf, 0x47, 0xc2, 0x8e, 0x8b, 0x54, 0x28, 0xfb,
	0x96, 0xdf, 0x9a, 0xdb, 0x54, 0xb6, 0xeb, 0x3a, 0xfd, 0x89, 0x3e, 0x84, 0xa6, 0x1d, 0xca, 0x13,
	0xcb, 0x6c, 0x62, 0x9d, 0x8a, 0xd3, 0x99, 0x08, 0xe6, 0xa9, 0xa0, 0x35, 0xcf, 0xa6, 0xb2, 0xdf,
	0xda, 0xbf, 0x14, 0x80, 0x27, 0x47, 0xfd, 0x28, 0x8a, 0x10, 0xb5, 0xe1, 0xda, 0xd9, 0x04, 0x4f,
	0xb0, 0x71, 0x8a, 0xa7, 0x86, 0x17, 0x18, 0x43, 0xd3, 0xb5, 0x47, 0x98, 0xc5, 0x51, 0xdd, 0xbd,
	0x76, 0x97, 0x66, 0xf7, 0x84, 0xea, 0x1f, 0xe1, 0x69, 0x97, 0xa9, 0x74, 0xf5, 0x8c, 0x8f, 0x8f,
	0x82, 0x48, 0x82, 0xba, 0xb0, 0xea, 0x7b, 0x23, 0xc7, 0xc2, 0x41, 0xc6, 0xcb, 0x1c, 0xf3, 0xb2,
	0xca, 0xbc, 0x1c, 0x47, 0x16, 0xa9, 0x1f, 0xe4, 0x27, 0x92, 0xc4, 0xd3, 0x27, 0x50, 0x1b, 0x47,
	0x55, 0x32, 0x42, 0x1f, 0x5b, 0x2c, 0xab, 0xea, 0xee, 0x1a, 0x73, 0x90, 0x2b, 0x9f, 0x5e, 0xe5,
	0xb6, 0x74, 0xa0, 0x6d, 0x42, 0xed, 0x69, 0x60, 0x0e, 0x06, 0x8e, 0xb5, 0x37, 0x32, 0xc3, 0x90,
	0x56, 0xcd, 0xf2, 0x42, 0x96, 0x48, 0x5d, 0xa7, 0x3f, 0xb5, 0xdf, 0x2b, 0xb0, 0x22, 0x9a, 0xb0,
	0xbc, 0x0e, 0x4c, 0x1f, 0x7d, 0x0c, 0x75, 0x12, 0xc9, 0x0d, 0x8b, 0x2a, 0x78, 0xf6, 0xcb, 0x6c,
	0x59, 0x71, 0x86, 0x5e, 0x23, 0xe2, 0x12, 0xbf, 0x00, 0x35, 0xad, 0x9d, 0x94, 0x72, 0x61, 0xe1,
	0x1a, 0x67, 0xd2, 0x58, 0xdb, 0x82, 0x7a, 0x7b, 0x32, 0x38, 0xf6, 0xbc, 0x11, 0xcf, 0x7e, 0x0d,
	0x16, 0x84, 0xf2, 0x2f, 0xe8, 0x7c, 0xa4, 0xfd, 0x46, 0x01, 0x95, 0x5b, 0x26, 0xb3, 0xd1, 0x26,
	0x54, 0x4f, 0x26, 0x03, 0xc3, 0xf7, 0xbc, 0x91, 0xe1, 0xd8, 0x6c, 0xc6, 0x62, 0xb7, 0xa4, 0x2f,
	0x9d, 0x44, 0x86, 0x3d, 0x1b, 0x7d, 0x06, 0xcd, 0xc4, 0x42, 0x8a, 0x0e, 0xb1, 0xe8, 0xa4, 0xb5,
	0xbb, 0x25, 0xbd, 0x7e, 0x22, 0x0a, 0xda, 0x4d, 0xa8, 0x4b, 0x9b, 0xa9, 0xfd, 0xb9, 0x0c, 0x55,
	0x3e, 0x87, 0x81, 0xf7, 0x36, 0xcc, 0x8f, 0x31, 0x31, 0x93, 0x62, 0x45, 0x70, 0x3f, 0x3a, 0x79,
	0x81, 0x2d, 0x72, 0x80, 0x89, 0xa9, 0x33, 0x35, 0x7a, 0x94, 0xf1, 0x23, 0x81, 0x22, 0x9b, 0x55,
	0x5b, 0xfd, 0xff, 0xbf, 0x6f, 0xd6, 0xbe, 0xc6, 0xae, 0x63, 0xe1, 0x4f, 0xb5, 0x53, 0x3c, 0xd5,
	0xf4, 0xea, 0xa9, 0x80, 0x8f, 0xeb, 0x50, 0xf1, 0xbd, 0x80, 0x18, 0xee, 0x64, 0xcc, 0xb0, 0x51,
	0xd7, 0x17, 0xe9, 0xf8, 0x70, 0x32, 0x46, 0xb7, 0xa1, 0x11, 0xe0, 0x10, 0x07, 0x5f, 0x63, 0xdb,
	0x38, 0x99, 0x12, 0x1c, 0x72, 0xd4, 0xd7, 0x63, 0x69, 0x9b, 0x0a, 0xa9, 0xd9, 0x10, 0x9b, 0x76,
	0xe0, 0x79, 0x63, 0x6e, 0xf6, 0x4e, 0x64, 0x16, 0x4b, 0x13, 0xb3, 0x70, 0x68, 0x06, 0x14, 0x88,
	0x03, 0xd3, 0x22, 0x5e, 0xd0, 0x5a, 0x88, 0xcc, 0xb8, 0xf4, 0x0b, 0x26, 0x44, 0xb7, 0xa0, 0xfe,
	0xca, 0x73, 0x0d, 0x32, 0x0c, 0x70, 0x38, 0xf4, 0x46, 0x76, 0x6b, 0x91, 0x59, 0xd5, 0x5e, 0x79,
	0xee, 0xd3, 0x58, 0x86, 0xb6, 0x41, 0x7d, 0xe5, 0x0d, 0x06, 0x86, 0x35, 0xc2, 0x66, 0x60, 0x8c,
	0x9c, 0xb1, 0x43, 0x5a, 0x15, 0x66, 0xd7, 0xa0, 0xf2, 0x3d, 0x2a, 0x7e, 0x4c, 0xa5, 0x14, 0xb3,
	0x63, 0x32, 0x69, 0x2d, 0x45, 0x98, 0x1d, 0x93, 0x09, 0xba, 0x05, 0x65, 0x62, 0x85, 0x2d, 0xd8,
	0x2c, 0x17, 0x03, 0x92, 0x6a, 0xb5, 0x87, 0xb0, 0xcc, 0x0b, 0xa9, 0xe3, 0xb3, 0x09, 0x0e, 0xc9,
	0x41, 0xf8, 0x1c, 0xdd, 0x81, 0xc5, 0x20, 0x1a, 0xb5, 0x14, 0x36, 0x5b, 0x15, 0x2b, 0xce, 0xce,
	0x4f, 0x6c, 0xa0, 0x3d, 0x4a, 0x90, 0xd8, 0x27, 0x26, 0x99, 0x84, 0xe8, 0xd3, 0x3c, 0x74, 0x94,
	0x59, 0xd0, 0xc9, 0x00, 0x47, 0x73, 0xa1, 0x99, 0x44, 0x13, 0xfa, 0x9e, 0x1b, 0x62, 0x74, 0x0f,
	0xc0, 0xf4, 0x1d, 0x23, 0x64, 0xce, 0x99, 0xa7, 0xc6, 0xae, 0xca, 0x01, 0xf3, 0xb9, 0xef, 0x44,
	0x8b, 0xea, 0x4b, 0x66, 0xfc, 0x13, 0xdd, 0x81, 0x05, 0x6e, 0x5c, 0x80, 0x58, 0x6e, 0xce, 0x2d,
	0xb4, 0x2f, 0x00, 0x65, 0xd6, 0xa3, 0xe9, 0xff, 0x14, 0x2a, 0x01, 0x1f, 0xf2, 0xfc, 0x57, 0x44,
	0x1f, 0xb1, 0xa9, 0x9e, 0x58, 0x69, 0xbf, 0x53, 0x60, 0x85, 0x6b, 0xf7, 0xf1, 0x08, 0x13, 0xcc,
	0x8b, 0xf9, 0x36, 0x80, 0xae, 0x1d, 0xc2, 0x7a, 0x51, 0x2c, 0x34, 0xb3, 0xfb, 0xd9, 0x8d, 0xbd,
	0x2e, 0xae, 0x20, 0x99, 0x8b, 0x3b, 0xdc, 0xca, 0x18, 0xa4, 0xa5, 0xca, 0xee, 0x4e, 0xf9, 0x82,
	0xdd, 0xd1, 0x7e, 0x0c, 0x35, 0x61, 0x2b, 0x42, 0xf4, 0x1e, 0x2c, 0x79, 0x96, 0x35, 0xf1, 0x4d,
	0xd7, 0x9a, 0xf2, 0x0b, 0x37, 0x15, 0x30, 0xea, 0xe3, 0xe6, 0x5f, 0x62, 0xf2, 0x36, 0x8b, 0xda,
	0x4d, 0x36, 0x38, 0x0d, 0x24, 0xc2, 0x4a, 0xa6, 0xa2, 0x6b, 0xa2, 0xfb, 0xd4, 0x36, 0x2d, 0xe7,
	0x1f, 0x95, 0x04, 0x74, 0x4c, 0xcd, 0x71, 0xfe, 0x01, 0xcc, 0x33, 0xda, 0x8a, 0x92, 0xca, 0x1f,
	0x38, 0xa6, 0xbd, 0x0c, 0xb8, 0xd1, 0x16, 0xbc, 0x43, 0x7f, 0x85, 0x9c, 0x09, 0x97, 0xb3, 0xa6,
	0xa1, 0x1e, 0xe9, 0xb5, 0xc7, 0xb0, 0x9a, 0x0f, 0x28, 0x82, 0x4b, 0xf6, 0x20, 0xac, 0xe7, 0xb2,
	0xcb, 0x9d, 0x85, 0xdb, 0x50, 0x65, 0xe4, 0x75, 0x01, 0x31, 0x4d, 0xa0, 0x21, 0x73, 0x1c, 0x7a,
	0x17, 0x2a, 0x11, 0x25, 0x0a, 0x94, 0xb4, 0xc8, 0x24, 0x3d, 0x1b, 0xfd, 0x0c, 0x6a, 0x91, 0x52,
	0xda, 0x4b, 0x35, 0xe5, 0xca, 0x84, 0x8b, 0xaa, 0x67, 0xe9, 0x30, 0xcf, 0x44, 0x1a, 0x54, 0xf6,
	0x7f, 0xa9, 0xeb, 0x3d, 0x77, 0xe0, 0xd1, 0xd0, 0x5e, 0x62, 0xe7, 0xf9, 0x90, 0x70, 0xe0, 0xf1,
	0x91, 0xb6, 0x0d, 0xa8, 0x4f, 0x02, 0xc7, 0x22, 0xc7, 0x81, 0xe3, 0x05, 0x0e, 0x99, 0x32, 0x6b,
	0x04, 0xf3, 0x81, 0x49, 0x30, 0xb7, 0x65, 0xbf, 0xb5, 0x3f, 0x29, 0x80, 0xd8, 0xea, 0x7d, 0x6b,
	0x88, 0xed, 0xc9, 0x08, 0x07, 0x87, 0x9e, 0x8d, 0xd1, 0x06, 0x54, 0x7c, 0x3e, 0x95, 0x9b, 0x27,
	0x63, 0x74, 0x0b, 0xe6, 0xed, 0x97, 0x41, 0xc0, 0x13, 0xa8, 0xb3, 0x04, 0xe2, 0x88, 0xba, 0x25,
	0x9d, 0x29, 0xd1, 0x0e, 0xdd, 0x66, 0x1a, 0x01, 0xdf, 0xbb, 0xa8, 0xec, 0xf9, 0xa0, 0xba, 0x25,
	0x9d, 0x1b, 0xb6, 0xab, 0xb0, 0xc4, 0x22, 0x79, 0x3a, 0xf5, 0xb1, 0xf6, 0x07, 0x85, 0x8f, 0x58,
	0xe4, 0xbd, 0xec, 0x41, 0x98, 0xfd, 0x42, 0xbb, 0x88, 0x44, 0x3f, 0x06, 0xe0, 0x7b, 0xe4, 0x0e,
	0x3c, 0x9e, 0xc3, 0x7a, 0xea, 0x47, 0x2a, 0x83, 0xbe, 0x74, 0x16, 0x87, 0xa0, 0xfd, 0x2f, 0x0e,
	0xe8, 0x32, 0xf4, 0x2f, 0x32, 0xf6, 0x9c, 0xcc, 0xd8, 0xfb, 0xa0, 0x86, 0xf1, 0x5a, 0x06, 0x7b,
	0x0c, 0x4e, 0x59, 0xa9, 0x1a, 0xfc, 0x46, 0x93, 0xa3, 0x61, 0xef, 0xc7, 0xa9, 0xde, 0x0c, 0x65,
	0x01, 0xfa, 0x10, 0x16, 0x58, 0x88, 0x94, 0xef, 0x29, 0xba, 0x1b, 0xe9, 0x5c, 0x1a, 0xb5, 0xce,
	0xb5, 0x68, 0x17, 0x2a, 0xa3, 0x1d, 0xc3, 0xf5, 0x6c, 0x46, 0xf9, 0xe5, 0xf3, 0x72, 0x5e, 0x1c,
	0xed, 0xd0, 0xbf, 0xa1, 0xf6, 0x00, 0x9a, 0x4c, 0x2d, 0xdc, 0x15, 0xdb, 0xd9, 0xbb, 0x42, 0x58,
	0x4f, 0x26, 0xd5, 0x36, 0x3f, 0x43, 0x9c, 0xd2, 0xee, 0x67, 0xc0, 0xaf, 0x14, 0x83, 0x5f, 0x82,
	0xbe, 0xf6, 0x02, 0xea, 0x3c, 0x80, 0x37, 0x65, 0xd2, 0x6d, 0xe1, 0xb2, 0x29, 0xcb, 0x0b, 0x66,
	0x78, 0xb4, 0x0d, 0xaa, 0xb4, 0x16, 0xcd, 0xf6, 0x6e, 0xee, 0xf2, 0x40, 0xe9, 0xfc, 0x82, 0x7b,
	0xe3, 0xb7, 0xf1, 0x59, 0x7a, 0x23, 0x06, 0xed, 0x15, 0x5f, 0xf6, 0x6f, 0x80, 0x71, 0xed, 0x2b,
	0x58, 0xcd, 0xc7, 0x41, 0x33, 0xda, 0xc9, 0xee, 0x9f, 0x80, 0x82, 0x19, 0xdc, 0xd9, 0x83, 0x35,
	0x49, 0xfd, 0x03, 0x98, 0xf3, 0x27, 0x00, 0x49, 0xe9, 0x43, 0x74, 0x13, 0xa2, 0xcd, 0x36, 0x6c,
	0xec, 0x93, 0x21, 0xbf, 0x65, 0xa2, 0xb3, 0xb9, 0x4f, 0x25, 0xf4, 0xe1, 0x1f, 0x01, 0xf0, 0xf2,
	0xc4, 0x79, 0x85, 0xb5, 0xdc, 0xe7, 0x7b, 0x2a, 0x93, 0xe6, 0xdd, 0x6c, 0x21, 0x57, 0x52, 0xd7,
	0x45, 0x94, 0xf9, 0xad, 0xc2, 0xf1, 0x25, 0x12, 0xa6, 0x26, 0x11, 0x66, 0xf6, 0x28, 0x45, 0x74,
	0xb9, 0x9d, 0xa1, 0xcb, 0x99, 0x08, 0x46, 0xb7, 0x65, 0xb2, 0x6c, 0xca, 0x86, 0x09, 0x55, 0x76,
	0xe1, 0x5a, 0x36, 0x90, 0x08, 0x19, 0x59, 0xac, 0xaf, 0x66, 0x32, 0xca, 0xc1, 0x7d, 0x0b, 0xea,
	0xbc, 0xad, 0xbd, 0x80, 0x28, 0x7f, 0xad, 0x80, 0x9a, 0x6d, 0x80, 0xd1, 0x4d, 0x80, 0xb8, 0x6d,
	0x16, 0x1b, 0x38, 0x2e, 0xeb, 0xd9, 0xe8, 0x01, 0x34, 0x62, 0x83, 0x82, 0xfe, 0x4d, 0x5a, 0x99,
	0xf6, 0x6f, 0xbe, 0x28, 0xc8, 0xb3, 0xe6, 0x5f, 0xe7, 0xa0, 0xca, 0xe7, 0x5c, 0x59, 0xff, 0x96,
	0xcd, 0xe9, 0x22, 0xea, 0xb9, 0x0f, 0x4b, 0xb6, 0x13, 0x60, 0xd6, 0xc2, 0xf3, 0xbb, 0x5e, 0x72,
	0xb4, 0x1f, 0x2b, 0xf5, 0xd4, 0x8e, 0x3e, 0x2f, 0x4f, 0x4c, 0xd7, 0x7e, 0xe9, 0xd8, 0x64, 0xc8,
	0x9b, 0xba, 0x54, 0x80, 0xde, 0x07, 0x38, 0x99, 0x04, 0x21, 0x31, 0x42, 0xe7, 0x1b, 0xcc, 0x9b,
	0xb9, 0x25, 0x26, 0xe9, 0x3b, 0xdf, 0xe4, 0xbf, 0x28, 0x2c, 0x7c, 0xff, 0x2f, 0x0a, 0x0f, 0x61,
	0x99, 0x87, 0x75, 0x71, 0x5b, 0x25, 0x14, 0x36, 0x85, 0xfc, 0x57, 0x09, 0x3c, 0xf8, 0x65, 0xfc,
	0x49, 0x6e, 0x43, 0x95, 0x59, 0x1b, 0x9a, 0xd9, 0x4e, 0xda, 0x55, 0x25, 0xc1, 0x5c, 0x6d, 0x57,
	0x25, 0x85, 0x28, 0x76, 0x55, 0x99, 0xf5, 0xce, 0xeb, 0xaa, 0x32, 0xa6, 0x99, 0xae, 0x2a, 0xde,
	0xdc, 0x2b, 0xef, 0xaa, 0x2e, 0x09, 0x3f, 0xda, 0x55, 0x15, 0xc5, 0x72, 0x4e, 0x57, 0x55, 0x64,
	0x2e, 0x75, 0x55, 0x19, 0x83, 0x1f, 0xc0, 0x0d, 0xb4, 0x4f, 0xe2, 0xde, 0xae, 0xb8, 0x4f, 0xba,
	0x6c, 0x99, 0xba, 0xc9, 0x96, 0x7d, 0xaf, 0x3e, 0x29, 0x67, 0x9b, 0x16, 0xe8, 0x6f, 0x0a, 0xd4,
	0x04, 0x7c, 0x85, 0xe8, 0x47, 0xb0, 0xec, 0xe3, 0x60, 0xec, 0x10, 0x82, 0x6d, 0xc3, 0x37, 0xad,
	0x53, 0x4c, 0x22, 0xe8, 0xce, 0xeb, 0x6a, 0xa2, 0x38, 0x8e, 0xe4, 0x68, 0x0b, 0x9a, 0xa9, 0x71,
	0xf4, 0xb1, 0x66, 0x8e, 0x99, 0x36, 0x12, 0x71, 0xf4, 0xb5, 0x66, 0x0b, 0x9a, 0x76, 0xe0, 0xf9,
	0xbe, 0xe0, 0xb3, 0x1c, 0x19, 0x72, 0x71, 0xec, 0xf1, 0x16, 0xd4, 0x63, 0xc3, 0xf4, 0x1b, 0xd1,
	0xbc, 0x5e, 0xe3, 0x42, 0xe6, 0x8d, 0x35, 0x77, 0x62, 0x4e, 0xe7, 0x34, 0x77, 0xe2, 0xb1, 0x3f,
	0xaf, 0xb9, 0x2b, 0x3c, 0x63, 0xc5, 0xcd, 0x9d, 0x58, 0x2e, 0xa1, 0xb9, 0xcb, 0x07, 0x74, 0x5e,
	0x73, 0x97, 0xb7, 0x4e, 0x8f, 0xe4, 0x9d, 0x17, 0xb0, 0x52, 0xf4, 0xb4, 0x46, 0x1b, 0xb0, 0xf6,
	0xf4, 0xc0, 0x78, 0xf2, 0xac, 0xf3, 0xac, 0x63, 0xf4, 0xf7, 0xba, 0x9d, 0xfd, 0x67, 0x8f, 0x3b,
	0xba, 0xb1, 0x6b, 0x7c, 0xa4, 0x96, 0x66, 0xe8, 0x3e, 0x32, 0x76, 0x55, 0x65, 0x86, 0xee, 0xe7,
	0xc6, 0x8e, 0x3a, 0x77, 0xe7, 0x41, 0xc2, 0x7b, 0xc9, 0xd5, 0x8e, 0xae, 0x41, 0xb3, 0x77, 0xf8,
	0xa5, 0xde, 0xe9, 0xf7, 0x8d, 0xe3, 0xa3, 0xc7, 0xbd, 0xbd, 0x8e, 0xae, 0x96, 0x10, 0x82, 0x46,
	0x47, 0x96, 0x29, 0xbb, 0xff, 0x58, 0x80, 0xf2, 0x93, 0xa3, 0x3e, 0x6a, 0x27, 0x9f, 0xa7, 0xf6,
	0x02, 0x6c, 0x12, 0x8c, 0xd6, 0xe4, 0x4f, 0x39, 0x31, 0x40, 0x37, 0xd6, 0x8b, 0x3e, 0xf1, 0x1c,
	0x84, 0xcf, 0xb5, 0x92, 0xe0, 0xe3, 0x99, 0x6f, 0xbf, 0xa1, 0x8f, 0xc3, 0xc4, 0x47, 0x74, 0xdc,
	0xd1, 0x7b, 0x33, 0xbf, 0xbc, 0x50, 0x4f, 0xef, 0x17, 0x69, 0x45, 0x7f, 0x1d, 0x80, 0xb4, 0x0b,
	0x47, 0xd7, 0x8b, 0x3f, 0x3a, 0x50, 0x4f, 0x1b, 0x33, 0x3a, 0xf6, 0xc8, 0xcd, 0x67, 0xbc, 0xd1,
	0xe0, 0xc5, 0x59, 0x11, 0x5f, 0xe8, 0x89, 0x8b, 0xd5, 0xfc, 0xbb, 0x5d, 0x9e, 0xcd, 0xcb, 0x72,
	0xc9, 0xd9, 0x5d, 0x3e, 0x9b, 0x17, 0x64, 0x63, 0xc6, 0x63, 0x9a, 0xfa, 0x78, 0x37, 0xaf, 0x13,
	0x3d, 0x3d, 0x84, 0x4a, 0xfc, 0xd2, 0x42, 0xeb, 0x45, 0x4f, 0x49, 0xea, 0xa3, 0x55, 0xf8, 0x22,
	0x4b, 0x76, 0x98, 0x43, 0x4d, 0x42, 0x49, 0x8e, 0xc2, 0x37, 0xd6, 0x8b, 0x28, 0x2b, 0xeb, 0x43,
	0x42, 0xc9, 0xa5, 0x7c, 0x1c, 0x26, 0x3e, 0x24, 0x94, 0xcc, 0x20, 0x1e, 0x8e, 0x92, 0x59, 0x34,
	0x12, 0xa1, 0x24, 0x3d, 0xce, 0xe8, 0x7a, 0xf1, 0x95, 0x9b, 0xa2, 0xa4, 0xf0, 0xa2, 0xd0, 0x4a,
	0xed, 0x8d, 0xbf, 0xbf, 0xbe, 0xa1, 0xfc, 0xf3, 0xf5, 0x0d, 0xe5, 0x3f, 0xaf, 0x6f, 0x28, 0x7f,
	0xf9, 0xef, 0x8d, 0xd2, 0xaf, 0x2a, 0x43, 0x73, 0xc4, 0xfe, 0x3b, 0x75, 0x5c, 0x3a, 0x59, 0x60,
	0x3f, 0xee, 0x7f, 0x17, 0x00, 0x00, 0xff, 0xff, 0x6e, 0xd4, 0x4c, 0xd3, 0xdd, 0x1a, 0x00, 0x00,
}
