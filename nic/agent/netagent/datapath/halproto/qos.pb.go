// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: qos.proto

package halproto

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import encoding_binary "encoding/binary"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type PortTypeNum_PortType int32

const (
	PortTypeNum_PORT_TYPE_DMA  PortTypeNum_PortType = 0
	PortTypeNum_PORT_TYPE_P4IG PortTypeNum_PortType = 1
	PortTypeNum_PORT_TYPE_P4EG PortTypeNum_PortType = 2
)

var PortTypeNum_PortType_name = map[int32]string{
	0: "PORT_TYPE_DMA",
	1: "PORT_TYPE_P4IG",
	2: "PORT_TYPE_P4EG",
}
var PortTypeNum_PortType_value = map[string]int32{
	"PORT_TYPE_DMA":  0,
	"PORT_TYPE_P4IG": 1,
	"PORT_TYPE_P4EG": 2,
}

func (x PortTypeNum_PortType) String() string {
	return proto.EnumName(PortTypeNum_PortType_name, int32(x))
}
func (PortTypeNum_PortType) EnumDescriptor() ([]byte, []int) { return fileDescriptorQos, []int{8, 0} }

// Specifications of a policer
type PolicerSpec struct {
	BpsRate   uint64 `protobuf:"varint,1,opt,name=bps_rate,json=bpsRate,proto3" json:"bps_rate,omitempty"`
	BurstSize uint64 `protobuf:"varint,2,opt,name=burst_size,json=burstSize,proto3" json:"burst_size,omitempty"`
}

func (m *PolicerSpec) Reset()                    { *m = PolicerSpec{} }
func (m *PolicerSpec) String() string            { return proto.CompactTextString(m) }
func (*PolicerSpec) ProtoMessage()               {}
func (*PolicerSpec) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{0} }

func (m *PolicerSpec) GetBpsRate() uint64 {
	if m != nil {
		return m.BpsRate
	}
	return 0
}

func (m *PolicerSpec) GetBurstSize() uint64 {
	if m != nil {
		return m.BurstSize
	}
	return 0
}

// PolicerStats captures all the statistics of a policer
type PolicerStats struct {
	PermittedPackets uint64 `protobuf:"varint,1,opt,name=permitted_packets,json=permittedPackets,proto3" json:"permitted_packets,omitempty"`
	PermittedBytes   uint64 `protobuf:"varint,2,opt,name=permitted_bytes,json=permittedBytes,proto3" json:"permitted_bytes,omitempty"`
	DroppedPackets   uint64 `protobuf:"varint,3,opt,name=dropped_packets,json=droppedPackets,proto3" json:"dropped_packets,omitempty"`
	DroppedBytes     uint64 `protobuf:"varint,4,opt,name=dropped_bytes,json=droppedBytes,proto3" json:"dropped_bytes,omitempty"`
}

func (m *PolicerStats) Reset()                    { *m = PolicerStats{} }
func (m *PolicerStats) String() string            { return proto.CompactTextString(m) }
func (*PolicerStats) ProtoMessage()               {}
func (*PolicerStats) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{1} }

func (m *PolicerStats) GetPermittedPackets() uint64 {
	if m != nil {
		return m.PermittedPackets
	}
	return 0
}

func (m *PolicerStats) GetPermittedBytes() uint64 {
	if m != nil {
		return m.PermittedBytes
	}
	return 0
}

func (m *PolicerStats) GetDroppedPackets() uint64 {
	if m != nil {
		return m.DroppedPackets
	}
	return 0
}

func (m *PolicerStats) GetDroppedBytes() uint64 {
	if m != nil {
		return m.DroppedBytes
	}
	return 0
}

// QosPFC specifies the pfc cos to respond to
type QosPFC struct {
	Cos           uint32 `protobuf:"varint,1,opt,name=cos,proto3" json:"cos,omitempty" venice:mandatory,venice:constraints={range:0-7}`
	XonThreshold  uint32 `protobuf:"varint,2,opt,name=xon_threshold,json=xonThreshold,proto3" json:"xon_threshold,omitempty" venice:mandatory,venice:constraints={range:3000-36864}`
	XoffThreshold uint32 `protobuf:"varint,3,opt,name=xoff_threshold,json=xoffThreshold,proto3" json:"xoff_threshold,omitempty" venice:mandatory,venice:constraints={range:3000-73728}`
}

func (m *QosPFC) Reset()                    { *m = QosPFC{} }
func (m *QosPFC) String() string            { return proto.CompactTextString(m) }
func (*QosPFC) ProtoMessage()               {}
func (*QosPFC) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{2} }

func (m *QosPFC) GetCos() uint32 {
	if m != nil {
		return m.Cos
	}
	return 0
}

func (m *QosPFC) GetXonThreshold() uint32 {
	if m != nil {
		return m.XonThreshold
	}
	return 0
}

func (m *QosPFC) GetXoffThreshold() uint32 {
	if m != nil {
		return m.XoffThreshold
	}
	return 0
}

// QosSched specifies the QosClass scheduling configuration
type QosSched struct {
	// Types that are valid to be assigned to SchedType:
	//	*QosSched_Dwrr
	//	*QosSched_Strict
	SchedType isQosSched_SchedType `protobuf_oneof:"SchedType"`
}

func (m *QosSched) Reset()                    { *m = QosSched{} }
func (m *QosSched) String() string            { return proto.CompactTextString(m) }
func (*QosSched) ProtoMessage()               {}
func (*QosSched) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{3} }

type isQosSched_SchedType interface {
	isQosSched_SchedType()
	MarshalTo([]byte) (int, error)
	Size() int
}

type QosSched_Dwrr struct {
	Dwrr *QosSched_DWRRInfo `protobuf:"bytes,1,opt,name=dwrr,oneof"`
}
type QosSched_Strict struct {
	Strict *QosSched_StrictPriorityInfo `protobuf:"bytes,2,opt,name=strict,oneof"`
}

func (*QosSched_Dwrr) isQosSched_SchedType()   {}
func (*QosSched_Strict) isQosSched_SchedType() {}

func (m *QosSched) GetSchedType() isQosSched_SchedType {
	if m != nil {
		return m.SchedType
	}
	return nil
}

func (m *QosSched) GetDwrr() *QosSched_DWRRInfo {
	if x, ok := m.GetSchedType().(*QosSched_Dwrr); ok {
		return x.Dwrr
	}
	return nil
}

func (m *QosSched) GetStrict() *QosSched_StrictPriorityInfo {
	if x, ok := m.GetSchedType().(*QosSched_Strict); ok {
		return x.Strict
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*QosSched) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _QosSched_OneofMarshaler, _QosSched_OneofUnmarshaler, _QosSched_OneofSizer, []interface{}{
		(*QosSched_Dwrr)(nil),
		(*QosSched_Strict)(nil),
	}
}

func _QosSched_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*QosSched)
	// SchedType
	switch x := m.SchedType.(type) {
	case *QosSched_Dwrr:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Dwrr); err != nil {
			return err
		}
	case *QosSched_Strict:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Strict); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("QosSched.SchedType has unexpected type %T", x)
	}
	return nil
}

func _QosSched_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*QosSched)
	switch tag {
	case 1: // SchedType.dwrr
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(QosSched_DWRRInfo)
		err := b.DecodeMessage(msg)
		m.SchedType = &QosSched_Dwrr{msg}
		return true, err
	case 2: // SchedType.strict
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(QosSched_StrictPriorityInfo)
		err := b.DecodeMessage(msg)
		m.SchedType = &QosSched_Strict{msg}
		return true, err
	default:
		return false, nil
	}
}

func _QosSched_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*QosSched)
	// SchedType
	switch x := m.SchedType.(type) {
	case *QosSched_Dwrr:
		s := proto.Size(x.Dwrr)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *QosSched_Strict:
		s := proto.Size(x.Strict)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// DWRR specific information
type QosSched_DWRRInfo struct {
	BwPercentage uint32 `protobuf:"varint,1,opt,name=bw_percentage,json=bwPercentage,proto3" json:"bw_percentage,omitempty" venice:constraints={range:0-100}`
}

func (m *QosSched_DWRRInfo) Reset()                    { *m = QosSched_DWRRInfo{} }
func (m *QosSched_DWRRInfo) String() string            { return proto.CompactTextString(m) }
func (*QosSched_DWRRInfo) ProtoMessage()               {}
func (*QosSched_DWRRInfo) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{3, 0} }

func (m *QosSched_DWRRInfo) GetBwPercentage() uint32 {
	if m != nil {
		return m.BwPercentage
	}
	return 0
}

// Strict Priority specific information for the class
type QosSched_StrictPriorityInfo struct {
	Bps uint32 `protobuf:"varint,1,opt,name=bps,proto3" json:"bps,omitempty"`
}

func (m *QosSched_StrictPriorityInfo) Reset()         { *m = QosSched_StrictPriorityInfo{} }
func (m *QosSched_StrictPriorityInfo) String() string { return proto.CompactTextString(m) }
func (*QosSched_StrictPriorityInfo) ProtoMessage()    {}
func (*QosSched_StrictPriorityInfo) Descriptor() ([]byte, []int) {
	return fileDescriptorQos, []int{3, 1}
}

func (m *QosSched_StrictPriorityInfo) GetBps() uint32 {
	if m != nil {
		return m.Bps
	}
	return 0
}

// QosUplinkClassMap specifies the policy with which traffic from network
// is classified
type QosUplinkClassMap struct {
	Dot1QPcp uint32   `protobuf:"varint,1,opt,name=dot1q_pcp,json=dot1qPcp,proto3" json:"dot1q_pcp,omitempty" venice:mandatory,venice:constraints={range:0-7}`
	IpDscp   []uint32 `protobuf:"varint,2,rep,packed,name=ip_dscp,json=ipDscp" json:"ip_dscp,omitempty" venice:constraints={range:0-63}`
}

func (m *QosUplinkClassMap) Reset()                    { *m = QosUplinkClassMap{} }
func (m *QosUplinkClassMap) String() string            { return proto.CompactTextString(m) }
func (*QosUplinkClassMap) ProtoMessage()               {}
func (*QosUplinkClassMap) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{4} }

func (m *QosUplinkClassMap) GetDot1QPcp() uint32 {
	if m != nil {
		return m.Dot1QPcp
	}
	return 0
}

func (m *QosUplinkClassMap) GetIpDscp() []uint32 {
	if m != nil {
		return m.IpDscp
	}
	return nil
}

// QosMarking specifies the policy to mark the host-to-network traffic
type QosMarking struct {
	Dot1QPcpRewriteEn bool   `protobuf:"varint,1,opt,name=dot1q_pcp_rewrite_en,json=dot1qPcpRewriteEn,proto3" json:"dot1q_pcp_rewrite_en,omitempty"`
	Dot1QPcp          uint32 `protobuf:"varint,2,opt,name=dot1q_pcp,json=dot1qPcp,proto3" json:"dot1q_pcp,omitempty" venice:constraints={range:0-7}`
	IpDscpRewriteEn   bool   `protobuf:"varint,3,opt,name=ip_dscp_rewrite_en,json=ipDscpRewriteEn,proto3" json:"ip_dscp_rewrite_en,omitempty"`
	IpDscp            uint32 `protobuf:"varint,4,opt,name=ip_dscp,json=ipDscp,proto3" json:"ip_dscp,omitempty" venice:constraints={range:0-63}`
}

func (m *QosMarking) Reset()                    { *m = QosMarking{} }
func (m *QosMarking) String() string            { return proto.CompactTextString(m) }
func (*QosMarking) ProtoMessage()               {}
func (*QosMarking) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{5} }

func (m *QosMarking) GetDot1QPcpRewriteEn() bool {
	if m != nil {
		return m.Dot1QPcpRewriteEn
	}
	return false
}

func (m *QosMarking) GetDot1QPcp() uint32 {
	if m != nil {
		return m.Dot1QPcp
	}
	return 0
}

func (m *QosMarking) GetIpDscpRewriteEn() bool {
	if m != nil {
		return m.IpDscpRewriteEn
	}
	return false
}

func (m *QosMarking) GetIpDscp() uint32 {
	if m != nil {
		return m.IpDscp
	}
	return 0
}

// QosClass specification
type QosClassSpec struct {
	Meta *ObjectMeta `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	// key_or_handle is QosClass's key or handle
	KeyOrHandle    *QosClassKeyHandle `protobuf:"bytes,2,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty" venice:"key"`
	Mtu            uint32             `protobuf:"varint,3,opt,name=mtu,proto3" json:"mtu,omitempty" venice:mandatory,venice:constraints={range:1500-9216}`
	Pfc            *QosPFC            `protobuf:"bytes,4,opt,name=pfc" json:"pfc,omitempty"`
	Sched          *QosSched          `protobuf:"bytes,5,opt,name=sched" json:"sched,omitempty" venice:mandatory`
	UplinkClassMap *QosUplinkClassMap `protobuf:"bytes,6,opt,name=uplink_class_map,json=uplinkClassMap" json:"uplink_class_map,omitempty"`
	Marking        *QosMarking        `protobuf:"bytes,7,opt,name=marking" json:"marking,omitempty"`
}

func (m *QosClassSpec) Reset()                    { *m = QosClassSpec{} }
func (m *QosClassSpec) String() string            { return proto.CompactTextString(m) }
func (*QosClassSpec) ProtoMessage()               {}
func (*QosClassSpec) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{6} }

func (m *QosClassSpec) GetMeta() *ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *QosClassSpec) GetKeyOrHandle() *QosClassKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

func (m *QosClassSpec) GetMtu() uint32 {
	if m != nil {
		return m.Mtu
	}
	return 0
}

func (m *QosClassSpec) GetPfc() *QosPFC {
	if m != nil {
		return m.Pfc
	}
	return nil
}

func (m *QosClassSpec) GetSched() *QosSched {
	if m != nil {
		return m.Sched
	}
	return nil
}

func (m *QosClassSpec) GetUplinkClassMap() *QosUplinkClassMap {
	if m != nil {
		return m.UplinkClassMap
	}
	return nil
}

func (m *QosClassSpec) GetMarking() *QosMarking {
	if m != nil {
		return m.Marking
	}
	return nil
}

// QosClassRequestMsg is batched request to create/update the QosClasss
type QosClassRequestMsg struct {
	Request []*QosClassSpec `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *QosClassRequestMsg) Reset()                    { *m = QosClassRequestMsg{} }
func (m *QosClassRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*QosClassRequestMsg) ProtoMessage()               {}
func (*QosClassRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{7} }

func (m *QosClassRequestMsg) GetRequest() []*QosClassSpec {
	if m != nil {
		return m.Request
	}
	return nil
}

type PortTypeNum struct {
	// Types that are valid to be assigned to PortTypeOrNum:
	//	*PortTypeNum_PortType_
	//	*PortTypeNum_UplinkPortNum
	PortTypeOrNum isPortTypeNum_PortTypeOrNum `protobuf_oneof:"port_type_or_num"`
}

func (m *PortTypeNum) Reset()                    { *m = PortTypeNum{} }
func (m *PortTypeNum) String() string            { return proto.CompactTextString(m) }
func (*PortTypeNum) ProtoMessage()               {}
func (*PortTypeNum) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{8} }

type isPortTypeNum_PortTypeOrNum interface {
	isPortTypeNum_PortTypeOrNum()
	MarshalTo([]byte) (int, error)
	Size() int
}

type PortTypeNum_PortType_ struct {
	PortType PortTypeNum_PortType `protobuf:"varint,1,opt,name=port_type,json=portType,proto3,enum=qos.PortTypeNum_PortType,oneof"`
}
type PortTypeNum_UplinkPortNum struct {
	UplinkPortNum uint32 `protobuf:"varint,2,opt,name=uplink_port_num,json=uplinkPortNum,proto3,oneof"`
}

func (*PortTypeNum_PortType_) isPortTypeNum_PortTypeOrNum()     {}
func (*PortTypeNum_UplinkPortNum) isPortTypeNum_PortTypeOrNum() {}

func (m *PortTypeNum) GetPortTypeOrNum() isPortTypeNum_PortTypeOrNum {
	if m != nil {
		return m.PortTypeOrNum
	}
	return nil
}

func (m *PortTypeNum) GetPortType() PortTypeNum_PortType {
	if x, ok := m.GetPortTypeOrNum().(*PortTypeNum_PortType_); ok {
		return x.PortType
	}
	return PortTypeNum_PORT_TYPE_DMA
}

func (m *PortTypeNum) GetUplinkPortNum() uint32 {
	if x, ok := m.GetPortTypeOrNum().(*PortTypeNum_UplinkPortNum); ok {
		return x.UplinkPortNum
	}
	return 0
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*PortTypeNum) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _PortTypeNum_OneofMarshaler, _PortTypeNum_OneofUnmarshaler, _PortTypeNum_OneofSizer, []interface{}{
		(*PortTypeNum_PortType_)(nil),
		(*PortTypeNum_UplinkPortNum)(nil),
	}
}

func _PortTypeNum_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*PortTypeNum)
	// port_type_or_num
	switch x := m.PortTypeOrNum.(type) {
	case *PortTypeNum_PortType_:
		_ = b.EncodeVarint(1<<3 | proto.WireVarint)
		_ = b.EncodeVarint(uint64(x.PortType))
	case *PortTypeNum_UplinkPortNum:
		_ = b.EncodeVarint(2<<3 | proto.WireVarint)
		_ = b.EncodeVarint(uint64(x.UplinkPortNum))
	case nil:
	default:
		return fmt.Errorf("PortTypeNum.PortTypeOrNum has unexpected type %T", x)
	}
	return nil
}

func _PortTypeNum_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*PortTypeNum)
	switch tag {
	case 1: // port_type_or_num.port_type
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.PortTypeOrNum = &PortTypeNum_PortType_{PortTypeNum_PortType(x)}
		return true, err
	case 2: // port_type_or_num.uplink_port_num
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.PortTypeOrNum = &PortTypeNum_UplinkPortNum{uint32(x)}
		return true, err
	default:
		return false, nil
	}
}

func _PortTypeNum_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*PortTypeNum)
	// port_type_or_num
	switch x := m.PortTypeOrNum.(type) {
	case *PortTypeNum_PortType_:
		n += proto.SizeVarint(1<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.PortType))
	case *PortTypeNum_UplinkPortNum:
		n += proto.SizeVarint(2<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.UplinkPortNum))
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type QosClassInputQueue struct {
	PortTypeNum   *PortTypeNum `protobuf:"bytes,1,opt,name=port_type_num,json=portTypeNum" json:"port_type_num,omitempty"`
	InputQueueIdx uint32       `protobuf:"varint,2,opt,name=input_queue_idx,json=inputQueueIdx,proto3" json:"input_queue_idx,omitempty"`
}

func (m *QosClassInputQueue) Reset()                    { *m = QosClassInputQueue{} }
func (m *QosClassInputQueue) String() string            { return proto.CompactTextString(m) }
func (*QosClassInputQueue) ProtoMessage()               {}
func (*QosClassInputQueue) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{9} }

func (m *QosClassInputQueue) GetPortTypeNum() *PortTypeNum {
	if m != nil {
		return m.PortTypeNum
	}
	return nil
}

func (m *QosClassInputQueue) GetInputQueueIdx() uint32 {
	if m != nil {
		return m.InputQueueIdx
	}
	return 0
}

type QosClassOutputQueue struct {
	PortTypeNum    *PortTypeNum `protobuf:"bytes,1,opt,name=port_type_num,json=portTypeNum" json:"port_type_num,omitempty"`
	OutputQueueIdx uint32       `protobuf:"varint,2,opt,name=output_queue_idx,json=outputQueueIdx,proto3" json:"output_queue_idx,omitempty"`
}

func (m *QosClassOutputQueue) Reset()                    { *m = QosClassOutputQueue{} }
func (m *QosClassOutputQueue) String() string            { return proto.CompactTextString(m) }
func (*QosClassOutputQueue) ProtoMessage()               {}
func (*QosClassOutputQueue) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{10} }

func (m *QosClassOutputQueue) GetPortTypeNum() *PortTypeNum {
	if m != nil {
		return m.PortTypeNum
	}
	return nil
}

func (m *QosClassOutputQueue) GetOutputQueueIdx() uint32 {
	if m != nil {
		return m.OutputQueueIdx
	}
	return 0
}

// QosClass oper state for enterprise pipeline
type QosClassStatusEpd struct {
	InputQueues  []*QosClassInputQueue  `protobuf:"bytes,1,rep,name=input_queues,json=inputQueues" json:"input_queues,omitempty"`
	OutputQueues []*QosClassOutputQueue `protobuf:"bytes,2,rep,name=output_queues,json=outputQueues" json:"output_queues,omitempty"`
}

func (m *QosClassStatusEpd) Reset()                    { *m = QosClassStatusEpd{} }
func (m *QosClassStatusEpd) String() string            { return proto.CompactTextString(m) }
func (*QosClassStatusEpd) ProtoMessage()               {}
func (*QosClassStatusEpd) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{11} }

func (m *QosClassStatusEpd) GetInputQueues() []*QosClassInputQueue {
	if m != nil {
		return m.InputQueues
	}
	return nil
}

func (m *QosClassStatusEpd) GetOutputQueues() []*QosClassOutputQueue {
	if m != nil {
		return m.OutputQueues
	}
	return nil
}

// QosClass oper state for cloud pipeline
type QosClassStatusCpd struct {
}

func (m *QosClassStatusCpd) Reset()                    { *m = QosClassStatusCpd{} }
func (m *QosClassStatusCpd) String() string            { return proto.CompactTextString(m) }
func (*QosClassStatusCpd) ProtoMessage()               {}
func (*QosClassStatusCpd) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{12} }

// QosClassStatus represents the operational status of QosClass
type QosClassStatus struct {
	QosClassHandle uint64 `protobuf:"fixed64,1,opt,name=qos_class_handle,json=qosClassHandle,proto3" json:"qos_class_handle,omitempty"`
	// Types that are valid to be assigned to QosClassPdStatus:
	//	*QosClassStatus_EpdStatus
	//	*QosClassStatus_CpdStatus
	QosClassPdStatus isQosClassStatus_QosClassPdStatus `protobuf_oneof:"qos_class_pd_status"`
}

func (m *QosClassStatus) Reset()                    { *m = QosClassStatus{} }
func (m *QosClassStatus) String() string            { return proto.CompactTextString(m) }
func (*QosClassStatus) ProtoMessage()               {}
func (*QosClassStatus) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{13} }

type isQosClassStatus_QosClassPdStatus interface {
	isQosClassStatus_QosClassPdStatus()
	MarshalTo([]byte) (int, error)
	Size() int
}

type QosClassStatus_EpdStatus struct {
	EpdStatus *QosClassStatusEpd `protobuf:"bytes,2,opt,name=epd_status,json=epdStatus,oneof"`
}
type QosClassStatus_CpdStatus struct {
	CpdStatus *QosClassStatusCpd `protobuf:"bytes,3,opt,name=cpd_status,json=cpdStatus,oneof"`
}

func (*QosClassStatus_EpdStatus) isQosClassStatus_QosClassPdStatus() {}
func (*QosClassStatus_CpdStatus) isQosClassStatus_QosClassPdStatus() {}

func (m *QosClassStatus) GetQosClassPdStatus() isQosClassStatus_QosClassPdStatus {
	if m != nil {
		return m.QosClassPdStatus
	}
	return nil
}

func (m *QosClassStatus) GetQosClassHandle() uint64 {
	if m != nil {
		return m.QosClassHandle
	}
	return 0
}

func (m *QosClassStatus) GetEpdStatus() *QosClassStatusEpd {
	if x, ok := m.GetQosClassPdStatus().(*QosClassStatus_EpdStatus); ok {
		return x.EpdStatus
	}
	return nil
}

func (m *QosClassStatus) GetCpdStatus() *QosClassStatusCpd {
	if x, ok := m.GetQosClassPdStatus().(*QosClassStatus_CpdStatus); ok {
		return x.CpdStatus
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*QosClassStatus) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _QosClassStatus_OneofMarshaler, _QosClassStatus_OneofUnmarshaler, _QosClassStatus_OneofSizer, []interface{}{
		(*QosClassStatus_EpdStatus)(nil),
		(*QosClassStatus_CpdStatus)(nil),
	}
}

func _QosClassStatus_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*QosClassStatus)
	// qos_class_pd_status
	switch x := m.QosClassPdStatus.(type) {
	case *QosClassStatus_EpdStatus:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.EpdStatus); err != nil {
			return err
		}
	case *QosClassStatus_CpdStatus:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.CpdStatus); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("QosClassStatus.QosClassPdStatus has unexpected type %T", x)
	}
	return nil
}

func _QosClassStatus_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*QosClassStatus)
	switch tag {
	case 2: // qos_class_pd_status.epd_status
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(QosClassStatusEpd)
		err := b.DecodeMessage(msg)
		m.QosClassPdStatus = &QosClassStatus_EpdStatus{msg}
		return true, err
	case 3: // qos_class_pd_status.cpd_status
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(QosClassStatusCpd)
		err := b.DecodeMessage(msg)
		m.QosClassPdStatus = &QosClassStatus_CpdStatus{msg}
		return true, err
	default:
		return false, nil
	}
}

func _QosClassStatus_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*QosClassStatus)
	// qos_class_pd_status
	switch x := m.QosClassPdStatus.(type) {
	case *QosClassStatus_EpdStatus:
		s := proto.Size(x.EpdStatus)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *QosClassStatus_CpdStatus:
		s := proto.Size(x.CpdStatus)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// QosClassResponse is response to one QosClassSpec
type QosClassResponse struct {
	ApiStatus ApiStatus       `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty" venice:api_status`
	Status    *QosClassStatus `protobuf:"bytes,2,opt,name=status" json:"status,omitempty"`
}

func (m *QosClassResponse) Reset()                    { *m = QosClassResponse{} }
func (m *QosClassResponse) String() string            { return proto.CompactTextString(m) }
func (*QosClassResponse) ProtoMessage()               {}
func (*QosClassResponse) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{14} }

func (m *QosClassResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *QosClassResponse) GetStatus() *QosClassStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

// QosClassResponseMsg is response to QosClassRequestMsg
type QosClassResponseMsg struct {
	Response []*QosClassResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *QosClassResponseMsg) Reset()                    { *m = QosClassResponseMsg{} }
func (m *QosClassResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*QosClassResponseMsg) ProtoMessage()               {}
func (*QosClassResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{15} }

func (m *QosClassResponseMsg) GetResponse() []*QosClassResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

// QosClassDeleteRequest  is used to delete a QosClass object
type QosClassDeleteRequest struct {
	Meta *ObjectMeta `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	// key_or_handle is to identify QosClass being deleted
	KeyOrHandle *QosClassKeyHandle `protobuf:"bytes,2,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty" venice:"key"`
}

func (m *QosClassDeleteRequest) Reset()                    { *m = QosClassDeleteRequest{} }
func (m *QosClassDeleteRequest) String() string            { return proto.CompactTextString(m) }
func (*QosClassDeleteRequest) ProtoMessage()               {}
func (*QosClassDeleteRequest) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{16} }

func (m *QosClassDeleteRequest) GetMeta() *ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *QosClassDeleteRequest) GetKeyOrHandle() *QosClassKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

// QosClassDeleteRequestMsg is used to delete a batch of QosClasss
type QosClassDeleteRequestMsg struct {
	Request []*QosClassDeleteRequest `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *QosClassDeleteRequestMsg) Reset()                    { *m = QosClassDeleteRequestMsg{} }
func (m *QosClassDeleteRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*QosClassDeleteRequestMsg) ProtoMessage()               {}
func (*QosClassDeleteRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{17} }

func (m *QosClassDeleteRequestMsg) GetRequest() []*QosClassDeleteRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

// QosClassDeleteResponse is response to QosClass delete request
type QosClassDeleteResponse struct {
	ApiStatus ApiStatus `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty" venice:api_status`
}

func (m *QosClassDeleteResponse) Reset()                    { *m = QosClassDeleteResponse{} }
func (m *QosClassDeleteResponse) String() string            { return proto.CompactTextString(m) }
func (*QosClassDeleteResponse) ProtoMessage()               {}
func (*QosClassDeleteResponse) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{18} }

func (m *QosClassDeleteResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

// QosClassDeleteResponseMsg is batched response to QosClassDeleteRequestMsg
type QosClassDeleteResponseMsg struct {
	Response []*QosClassDeleteResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *QosClassDeleteResponseMsg) Reset()                    { *m = QosClassDeleteResponseMsg{} }
func (m *QosClassDeleteResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*QosClassDeleteResponseMsg) ProtoMessage()               {}
func (*QosClassDeleteResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{19} }

func (m *QosClassDeleteResponseMsg) GetResponse() []*QosClassDeleteResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

type QosClassInputQueueStats struct {
	InputQueue      *QosClassInputQueue `protobuf:"bytes,1,opt,name=input_queue,json=inputQueue" json:"input_queue,omitempty"`
	GoodPktsIn      uint64              `protobuf:"varint,2,opt,name=good_pkts_in,json=goodPktsIn,proto3" json:"good_pkts_in,omitempty"`
	GoodPktsOut     uint64              `protobuf:"varint,3,opt,name=good_pkts_out,json=goodPktsOut,proto3" json:"good_pkts_out,omitempty"`
	ErroredPktsIn   uint64              `protobuf:"varint,4,opt,name=errored_pkts_in,json=erroredPktsIn,proto3" json:"errored_pkts_in,omitempty"`
	HbmFifoDepth    uint32              `protobuf:"varint,5,opt,name=hbm_fifo_depth,json=hbmFifoDepth,proto3" json:"hbm_fifo_depth,omitempty"`
	MaxFifoDepth    uint32              `protobuf:"varint,6,opt,name=max_fifo_depth,json=maxFifoDepth,proto3" json:"max_fifo_depth,omitempty"`
	BufferOccupancy uint32              `protobuf:"varint,7,opt,name=buffer_occupancy,json=bufferOccupancy,proto3" json:"buffer_occupancy,omitempty"`
}

func (m *QosClassInputQueueStats) Reset()                    { *m = QosClassInputQueueStats{} }
func (m *QosClassInputQueueStats) String() string            { return proto.CompactTextString(m) }
func (*QosClassInputQueueStats) ProtoMessage()               {}
func (*QosClassInputQueueStats) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{20} }

func (m *QosClassInputQueueStats) GetInputQueue() *QosClassInputQueue {
	if m != nil {
		return m.InputQueue
	}
	return nil
}

func (m *QosClassInputQueueStats) GetGoodPktsIn() uint64 {
	if m != nil {
		return m.GoodPktsIn
	}
	return 0
}

func (m *QosClassInputQueueStats) GetGoodPktsOut() uint64 {
	if m != nil {
		return m.GoodPktsOut
	}
	return 0
}

func (m *QosClassInputQueueStats) GetErroredPktsIn() uint64 {
	if m != nil {
		return m.ErroredPktsIn
	}
	return 0
}

func (m *QosClassInputQueueStats) GetHbmFifoDepth() uint32 {
	if m != nil {
		return m.HbmFifoDepth
	}
	return 0
}

func (m *QosClassInputQueueStats) GetMaxFifoDepth() uint32 {
	if m != nil {
		return m.MaxFifoDepth
	}
	return 0
}

func (m *QosClassInputQueueStats) GetBufferOccupancy() uint32 {
	if m != nil {
		return m.BufferOccupancy
	}
	return 0
}

type QosClassOutputQueueStats struct {
	OutputQueue *QosClassOutputQueue `protobuf:"bytes,1,opt,name=output_queue,json=outputQueue" json:"output_queue,omitempty"`
	QueueDepth  uint32               `protobuf:"varint,2,opt,name=queue_depth,json=queueDepth,proto3" json:"queue_depth,omitempty"`
}

func (m *QosClassOutputQueueStats) Reset()                    { *m = QosClassOutputQueueStats{} }
func (m *QosClassOutputQueueStats) String() string            { return proto.CompactTextString(m) }
func (*QosClassOutputQueueStats) ProtoMessage()               {}
func (*QosClassOutputQueueStats) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{21} }

func (m *QosClassOutputQueueStats) GetOutputQueue() *QosClassOutputQueue {
	if m != nil {
		return m.OutputQueue
	}
	return nil
}

func (m *QosClassOutputQueueStats) GetQueueDepth() uint32 {
	if m != nil {
		return m.QueueDepth
	}
	return 0
}

// QosClassStats captures all the statistics of given QosClass
type QosClassStats struct {
	NumLifsTx        uint32                      `protobuf:"varint,1,opt,name=num_lifs_tx,json=numLifsTx,proto3" json:"num_lifs_tx,omitempty"`
	NumLifsRx        uint32                      `protobuf:"varint,2,opt,name=num_lifs_rx,json=numLifsRx,proto3" json:"num_lifs_rx,omitempty"`
	InputQueueStats  []*QosClassInputQueueStats  `protobuf:"bytes,3,rep,name=input_queue_stats,json=inputQueueStats" json:"input_queue_stats,omitempty"`
	OutputQueueStats []*QosClassOutputQueueStats `protobuf:"bytes,4,rep,name=output_queue_stats,json=outputQueueStats" json:"output_queue_stats,omitempty"`
}

func (m *QosClassStats) Reset()                    { *m = QosClassStats{} }
func (m *QosClassStats) String() string            { return proto.CompactTextString(m) }
func (*QosClassStats) ProtoMessage()               {}
func (*QosClassStats) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{22} }

func (m *QosClassStats) GetNumLifsTx() uint32 {
	if m != nil {
		return m.NumLifsTx
	}
	return 0
}

func (m *QosClassStats) GetNumLifsRx() uint32 {
	if m != nil {
		return m.NumLifsRx
	}
	return 0
}

func (m *QosClassStats) GetInputQueueStats() []*QosClassInputQueueStats {
	if m != nil {
		return m.InputQueueStats
	}
	return nil
}

func (m *QosClassStats) GetOutputQueueStats() []*QosClassOutputQueueStats {
	if m != nil {
		return m.OutputQueueStats
	}
	return nil
}

// QosClassGetRequest is used to get information about a QosClass
type QosClassGetRequest struct {
	Meta *ObjectMeta `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	// key_or_handle is to identify QosClass being deleted
	KeyOrHandle *QosClassKeyHandle `protobuf:"bytes,2,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty" venice:"key"`
}

func (m *QosClassGetRequest) Reset()                    { *m = QosClassGetRequest{} }
func (m *QosClassGetRequest) String() string            { return proto.CompactTextString(m) }
func (*QosClassGetRequest) ProtoMessage()               {}
func (*QosClassGetRequest) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{23} }

func (m *QosClassGetRequest) GetMeta() *ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *QosClassGetRequest) GetKeyOrHandle() *QosClassKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

// Batched request message to get the stats about a batch of QosClasss
type QosClassGetRequestMsg struct {
	Request []*QosClassGetRequest `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *QosClassGetRequestMsg) Reset()                    { *m = QosClassGetRequestMsg{} }
func (m *QosClassGetRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*QosClassGetRequestMsg) ProtoMessage()               {}
func (*QosClassGetRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{24} }

func (m *QosClassGetRequestMsg) GetRequest() []*QosClassGetRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

// QosClassGetResponse captures all the information about a QosClass
type QosClassGetResponse struct {
	ApiStatus ApiStatus       `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty" venice:api_status`
	Spec      *QosClassSpec   `protobuf:"bytes,2,opt,name=spec" json:"spec,omitempty"`
	Status    *QosClassStatus `protobuf:"bytes,3,opt,name=status" json:"status,omitempty"`
	Stats     *QosClassStats  `protobuf:"bytes,4,opt,name=stats" json:"stats,omitempty"`
}

func (m *QosClassGetResponse) Reset()                    { *m = QosClassGetResponse{} }
func (m *QosClassGetResponse) String() string            { return proto.CompactTextString(m) }
func (*QosClassGetResponse) ProtoMessage()               {}
func (*QosClassGetResponse) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{25} }

func (m *QosClassGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *QosClassGetResponse) GetSpec() *QosClassSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *QosClassGetResponse) GetStatus() *QosClassStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *QosClassGetResponse) GetStats() *QosClassStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

// QosClassGetResponseMsg is response to QosClassGetRequestMsg
type QosClassGetResponseMsg struct {
	Response []*QosClassGetResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *QosClassGetResponseMsg) Reset()                    { *m = QosClassGetResponseMsg{} }
func (m *QosClassGetResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*QosClassGetResponseMsg) ProtoMessage()               {}
func (*QosClassGetResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{26} }

func (m *QosClassGetResponseMsg) GetResponse() []*QosClassGetResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

// Specifications of a Copp
type CoppSpec struct {
	Meta *ObjectMeta `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	// key_or_handle is Copp's unique identifier
	KeyOrHandle *CoppKeyHandle `protobuf:"bytes,2,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty" venice:"key"`
	Policer     *PolicerSpec   `protobuf:"bytes,3,opt,name=policer" json:"policer,omitempty" venice:mandatory`
}

func (m *CoppSpec) Reset()                    { *m = CoppSpec{} }
func (m *CoppSpec) String() string            { return proto.CompactTextString(m) }
func (*CoppSpec) ProtoMessage()               {}
func (*CoppSpec) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{27} }

func (m *CoppSpec) GetMeta() *ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *CoppSpec) GetKeyOrHandle() *CoppKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

func (m *CoppSpec) GetPolicer() *PolicerSpec {
	if m != nil {
		return m.Policer
	}
	return nil
}

// Batched requests to create/update Copps
type CoppRequestMsg struct {
	Request []*CoppSpec `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *CoppRequestMsg) Reset()                    { *m = CoppRequestMsg{} }
func (m *CoppRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*CoppRequestMsg) ProtoMessage()               {}
func (*CoppRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{28} }

func (m *CoppRequestMsg) GetRequest() []*CoppSpec {
	if m != nil {
		return m.Request
	}
	return nil
}

type CoppStatus struct {
	CoppHandle uint64 `protobuf:"fixed64,1,opt,name=copp_handle,json=coppHandle,proto3" json:"copp_handle,omitempty"`
}

func (m *CoppStatus) Reset()                    { *m = CoppStatus{} }
func (m *CoppStatus) String() string            { return proto.CompactTextString(m) }
func (*CoppStatus) ProtoMessage()               {}
func (*CoppStatus) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{29} }

func (m *CoppStatus) GetCoppHandle() uint64 {
	if m != nil {
		return m.CoppHandle
	}
	return 0
}

// CoppResponse is response to one Copp
type CoppResponse struct {
	ApiStatus ApiStatus   `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty" venice:api_status`
	Status    *CoppStatus `protobuf:"bytes,2,opt,name=status" json:"status,omitempty"`
}

func (m *CoppResponse) Reset()                    { *m = CoppResponse{} }
func (m *CoppResponse) String() string            { return proto.CompactTextString(m) }
func (*CoppResponse) ProtoMessage()               {}
func (*CoppResponse) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{30} }

func (m *CoppResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *CoppResponse) GetStatus() *CoppStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

// Batched responses to create/update Copps
type CoppResponseMsg struct {
	Response []*CoppResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *CoppResponseMsg) Reset()                    { *m = CoppResponseMsg{} }
func (m *CoppResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*CoppResponseMsg) ProtoMessage()               {}
func (*CoppResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{31} }

func (m *CoppResponseMsg) GetResponse() []*CoppResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

// CoppGetRequest is used to get information about a Copp
type CoppGetRequest struct {
	Meta *ObjectMeta `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	// key_or_handle is Copp's unique identifier
	KeyOrHandle *CoppKeyHandle `protobuf:"bytes,2,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty" venice:"key"`
}

func (m *CoppGetRequest) Reset()                    { *m = CoppGetRequest{} }
func (m *CoppGetRequest) String() string            { return proto.CompactTextString(m) }
func (*CoppGetRequest) ProtoMessage()               {}
func (*CoppGetRequest) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{32} }

func (m *CoppGetRequest) GetMeta() *ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *CoppGetRequest) GetKeyOrHandle() *CoppKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

type CoppGetRequestMsg struct {
	Request []*CoppGetRequest `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *CoppGetRequestMsg) Reset()                    { *m = CoppGetRequestMsg{} }
func (m *CoppGetRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*CoppGetRequestMsg) ProtoMessage()               {}
func (*CoppGetRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{33} }

func (m *CoppGetRequestMsg) GetRequest() []*CoppGetRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

// CoppGetResponse captures all the information about a Copp
type CoppGetResponse struct {
	ApiStatus ApiStatus     `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty" venice:api_status`
	Spec      *CoppSpec     `protobuf:"bytes,2,opt,name=spec" json:"spec,omitempty"`
	Status    *CoppStatus   `protobuf:"bytes,3,opt,name=status" json:"status,omitempty"`
	Stats     *PolicerStats `protobuf:"bytes,4,opt,name=stats" json:"stats,omitempty"`
}

func (m *CoppGetResponse) Reset()                    { *m = CoppGetResponse{} }
func (m *CoppGetResponse) String() string            { return proto.CompactTextString(m) }
func (*CoppGetResponse) ProtoMessage()               {}
func (*CoppGetResponse) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{34} }

func (m *CoppGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *CoppGetResponse) GetSpec() *CoppSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *CoppGetResponse) GetStatus() *CoppStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *CoppGetResponse) GetStats() *PolicerStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

// CoppGetResponseMsg is response to CoppGetRequestMsg
type CoppGetResponseMsg struct {
	Response []*CoppGetResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *CoppGetResponseMsg) Reset()                    { *m = CoppGetResponseMsg{} }
func (m *CoppGetResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*CoppGetResponseMsg) ProtoMessage()               {}
func (*CoppGetResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptorQos, []int{35} }

func (m *CoppGetResponseMsg) GetResponse() []*CoppGetResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

func init() {
	proto.RegisterType((*PolicerSpec)(nil), "qos.PolicerSpec")
	proto.RegisterType((*PolicerStats)(nil), "qos.PolicerStats")
	proto.RegisterType((*QosPFC)(nil), "qos.QosPFC")
	proto.RegisterType((*QosSched)(nil), "qos.QosSched")
	proto.RegisterType((*QosSched_DWRRInfo)(nil), "qos.QosSched.DWRRInfo")
	proto.RegisterType((*QosSched_StrictPriorityInfo)(nil), "qos.QosSched.StrictPriorityInfo")
	proto.RegisterType((*QosUplinkClassMap)(nil), "qos.QosUplinkClassMap")
	proto.RegisterType((*QosMarking)(nil), "qos.QosMarking")
	proto.RegisterType((*QosClassSpec)(nil), "qos.QosClassSpec")
	proto.RegisterType((*QosClassRequestMsg)(nil), "qos.QosClassRequestMsg")
	proto.RegisterType((*PortTypeNum)(nil), "qos.PortTypeNum")
	proto.RegisterType((*QosClassInputQueue)(nil), "qos.QosClassInputQueue")
	proto.RegisterType((*QosClassOutputQueue)(nil), "qos.QosClassOutputQueue")
	proto.RegisterType((*QosClassStatusEpd)(nil), "qos.QosClassStatusEpd")
	proto.RegisterType((*QosClassStatusCpd)(nil), "qos.QosClassStatusCpd")
	proto.RegisterType((*QosClassStatus)(nil), "qos.QosClassStatus")
	proto.RegisterType((*QosClassResponse)(nil), "qos.QosClassResponse")
	proto.RegisterType((*QosClassResponseMsg)(nil), "qos.QosClassResponseMsg")
	proto.RegisterType((*QosClassDeleteRequest)(nil), "qos.QosClassDeleteRequest")
	proto.RegisterType((*QosClassDeleteRequestMsg)(nil), "qos.QosClassDeleteRequestMsg")
	proto.RegisterType((*QosClassDeleteResponse)(nil), "qos.QosClassDeleteResponse")
	proto.RegisterType((*QosClassDeleteResponseMsg)(nil), "qos.QosClassDeleteResponseMsg")
	proto.RegisterType((*QosClassInputQueueStats)(nil), "qos.QosClassInputQueueStats")
	proto.RegisterType((*QosClassOutputQueueStats)(nil), "qos.QosClassOutputQueueStats")
	proto.RegisterType((*QosClassStats)(nil), "qos.QosClassStats")
	proto.RegisterType((*QosClassGetRequest)(nil), "qos.QosClassGetRequest")
	proto.RegisterType((*QosClassGetRequestMsg)(nil), "qos.QosClassGetRequestMsg")
	proto.RegisterType((*QosClassGetResponse)(nil), "qos.QosClassGetResponse")
	proto.RegisterType((*QosClassGetResponseMsg)(nil), "qos.QosClassGetResponseMsg")
	proto.RegisterType((*CoppSpec)(nil), "qos.CoppSpec")
	proto.RegisterType((*CoppRequestMsg)(nil), "qos.CoppRequestMsg")
	proto.RegisterType((*CoppStatus)(nil), "qos.CoppStatus")
	proto.RegisterType((*CoppResponse)(nil), "qos.CoppResponse")
	proto.RegisterType((*CoppResponseMsg)(nil), "qos.CoppResponseMsg")
	proto.RegisterType((*CoppGetRequest)(nil), "qos.CoppGetRequest")
	proto.RegisterType((*CoppGetRequestMsg)(nil), "qos.CoppGetRequestMsg")
	proto.RegisterType((*CoppGetResponse)(nil), "qos.CoppGetResponse")
	proto.RegisterType((*CoppGetResponseMsg)(nil), "qos.CoppGetResponseMsg")
	proto.RegisterEnum("qos.PortTypeNum_PortType", PortTypeNum_PortType_name, PortTypeNum_PortType_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for QOS service

type QOSClient interface {
	// QOS class related APIs
	QosClassCreate(ctx context.Context, in *QosClassRequestMsg, opts ...grpc.CallOption) (*QosClassResponseMsg, error)
	QosClassUpdate(ctx context.Context, in *QosClassRequestMsg, opts ...grpc.CallOption) (*QosClassResponseMsg, error)
	QosClassDelete(ctx context.Context, in *QosClassDeleteRequestMsg, opts ...grpc.CallOption) (*QosClassDeleteResponseMsg, error)
	QosClassGet(ctx context.Context, in *QosClassGetRequestMsg, opts ...grpc.CallOption) (*QosClassGetResponseMsg, error)
	// Copp related APIs
	CoppUpdate(ctx context.Context, in *CoppRequestMsg, opts ...grpc.CallOption) (*CoppResponseMsg, error)
	CoppGet(ctx context.Context, in *CoppGetRequestMsg, opts ...grpc.CallOption) (*CoppGetResponseMsg, error)
}

type qOSClient struct {
	cc *grpc.ClientConn
}

func NewQOSClient(cc *grpc.ClientConn) QOSClient {
	return &qOSClient{cc}
}

func (c *qOSClient) QosClassCreate(ctx context.Context, in *QosClassRequestMsg, opts ...grpc.CallOption) (*QosClassResponseMsg, error) {
	out := new(QosClassResponseMsg)
	err := grpc.Invoke(ctx, "/qos.QOS/QosClassCreate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *qOSClient) QosClassUpdate(ctx context.Context, in *QosClassRequestMsg, opts ...grpc.CallOption) (*QosClassResponseMsg, error) {
	out := new(QosClassResponseMsg)
	err := grpc.Invoke(ctx, "/qos.QOS/QosClassUpdate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *qOSClient) QosClassDelete(ctx context.Context, in *QosClassDeleteRequestMsg, opts ...grpc.CallOption) (*QosClassDeleteResponseMsg, error) {
	out := new(QosClassDeleteResponseMsg)
	err := grpc.Invoke(ctx, "/qos.QOS/QosClassDelete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *qOSClient) QosClassGet(ctx context.Context, in *QosClassGetRequestMsg, opts ...grpc.CallOption) (*QosClassGetResponseMsg, error) {
	out := new(QosClassGetResponseMsg)
	err := grpc.Invoke(ctx, "/qos.QOS/QosClassGet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *qOSClient) CoppUpdate(ctx context.Context, in *CoppRequestMsg, opts ...grpc.CallOption) (*CoppResponseMsg, error) {
	out := new(CoppResponseMsg)
	err := grpc.Invoke(ctx, "/qos.QOS/CoppUpdate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *qOSClient) CoppGet(ctx context.Context, in *CoppGetRequestMsg, opts ...grpc.CallOption) (*CoppGetResponseMsg, error) {
	out := new(CoppGetResponseMsg)
	err := grpc.Invoke(ctx, "/qos.QOS/CoppGet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for QOS service

type QOSServer interface {
	// QOS class related APIs
	QosClassCreate(context.Context, *QosClassRequestMsg) (*QosClassResponseMsg, error)
	QosClassUpdate(context.Context, *QosClassRequestMsg) (*QosClassResponseMsg, error)
	QosClassDelete(context.Context, *QosClassDeleteRequestMsg) (*QosClassDeleteResponseMsg, error)
	QosClassGet(context.Context, *QosClassGetRequestMsg) (*QosClassGetResponseMsg, error)
	// Copp related APIs
	CoppUpdate(context.Context, *CoppRequestMsg) (*CoppResponseMsg, error)
	CoppGet(context.Context, *CoppGetRequestMsg) (*CoppGetResponseMsg, error)
}

func RegisterQOSServer(s *grpc.Server, srv QOSServer) {
	s.RegisterService(&_QOS_serviceDesc, srv)
}

func _QOS_QosClassCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QosClassRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QOSServer).QosClassCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/qos.QOS/QosClassCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QOSServer).QosClassCreate(ctx, req.(*QosClassRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _QOS_QosClassUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QosClassRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QOSServer).QosClassUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/qos.QOS/QosClassUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QOSServer).QosClassUpdate(ctx, req.(*QosClassRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _QOS_QosClassDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QosClassDeleteRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QOSServer).QosClassDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/qos.QOS/QosClassDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QOSServer).QosClassDelete(ctx, req.(*QosClassDeleteRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _QOS_QosClassGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QosClassGetRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QOSServer).QosClassGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/qos.QOS/QosClassGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QOSServer).QosClassGet(ctx, req.(*QosClassGetRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _QOS_CoppUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CoppRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QOSServer).CoppUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/qos.QOS/CoppUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QOSServer).CoppUpdate(ctx, req.(*CoppRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _QOS_CoppGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CoppGetRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QOSServer).CoppGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/qos.QOS/CoppGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QOSServer).CoppGet(ctx, req.(*CoppGetRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

var _QOS_serviceDesc = grpc.ServiceDesc{
	ServiceName: "qos.QOS",
	HandlerType: (*QOSServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "QosClassCreate",
			Handler:    _QOS_QosClassCreate_Handler,
		},
		{
			MethodName: "QosClassUpdate",
			Handler:    _QOS_QosClassUpdate_Handler,
		},
		{
			MethodName: "QosClassDelete",
			Handler:    _QOS_QosClassDelete_Handler,
		},
		{
			MethodName: "QosClassGet",
			Handler:    _QOS_QosClassGet_Handler,
		},
		{
			MethodName: "CoppUpdate",
			Handler:    _QOS_CoppUpdate_Handler,
		},
		{
			MethodName: "CoppGet",
			Handler:    _QOS_CoppGet_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "qos.proto",
}

func (m *PolicerSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PolicerSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.BpsRate != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.BpsRate))
	}
	if m.BurstSize != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.BurstSize))
	}
	return i, nil
}

func (m *PolicerStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PolicerStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PermittedPackets != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.PermittedPackets))
	}
	if m.PermittedBytes != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.PermittedBytes))
	}
	if m.DroppedPackets != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.DroppedPackets))
	}
	if m.DroppedBytes != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.DroppedBytes))
	}
	return i, nil
}

func (m *QosPFC) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosPFC) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Cos != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.Cos))
	}
	if m.XonThreshold != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.XonThreshold))
	}
	if m.XoffThreshold != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.XoffThreshold))
	}
	return i, nil
}

func (m *QosSched) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosSched) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SchedType != nil {
		nn1, err := m.SchedType.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn1
	}
	return i, nil
}

func (m *QosSched_Dwrr) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Dwrr != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.Dwrr.Size()))
		n2, err := m.Dwrr.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}
func (m *QosSched_Strict) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Strict != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.Strict.Size()))
		n3, err := m.Strict.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}
func (m *QosSched_DWRRInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosSched_DWRRInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.BwPercentage != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.BwPercentage))
	}
	return i, nil
}

func (m *QosSched_StrictPriorityInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosSched_StrictPriorityInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Bps != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.Bps))
	}
	return i, nil
}

func (m *QosUplinkClassMap) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosUplinkClassMap) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Dot1QPcp != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.Dot1QPcp))
	}
	if len(m.IpDscp) > 0 {
		dAtA5 := make([]byte, len(m.IpDscp)*10)
		var j4 int
		for _, num := range m.IpDscp {
			for num >= 1<<7 {
				dAtA5[j4] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j4++
			}
			dAtA5[j4] = uint8(num)
			j4++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintQos(dAtA, i, uint64(j4))
		i += copy(dAtA[i:], dAtA5[:j4])
	}
	return i, nil
}

func (m *QosMarking) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosMarking) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Dot1QPcpRewriteEn {
		dAtA[i] = 0x8
		i++
		if m.Dot1QPcpRewriteEn {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Dot1QPcp != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.Dot1QPcp))
	}
	if m.IpDscpRewriteEn {
		dAtA[i] = 0x18
		i++
		if m.IpDscpRewriteEn {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IpDscp != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.IpDscp))
	}
	return i, nil
}

func (m *QosClassSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosClassSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.Meta.Size()))
		n6, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.KeyOrHandle != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n7, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.Mtu != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.Mtu))
	}
	if m.Pfc != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.Pfc.Size()))
		n8, err := m.Pfc.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.Sched != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.Sched.Size()))
		n9, err := m.Sched.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.UplinkClassMap != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.UplinkClassMap.Size()))
		n10, err := m.UplinkClassMap.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.Marking != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.Marking.Size()))
		n11, err := m.Marking.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	return i, nil
}

func (m *QosClassRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosClassRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintQos(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *PortTypeNum) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PortTypeNum) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PortTypeOrNum != nil {
		nn12, err := m.PortTypeOrNum.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn12
	}
	return i, nil
}

func (m *PortTypeNum_PortType_) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x8
	i++
	i = encodeVarintQos(dAtA, i, uint64(m.PortType))
	return i, nil
}
func (m *PortTypeNum_UplinkPortNum) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x10
	i++
	i = encodeVarintQos(dAtA, i, uint64(m.UplinkPortNum))
	return i, nil
}
func (m *QosClassInputQueue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosClassInputQueue) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PortTypeNum != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.PortTypeNum.Size()))
		n13, err := m.PortTypeNum.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if m.InputQueueIdx != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.InputQueueIdx))
	}
	return i, nil
}

func (m *QosClassOutputQueue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosClassOutputQueue) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PortTypeNum != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.PortTypeNum.Size()))
		n14, err := m.PortTypeNum.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	if m.OutputQueueIdx != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.OutputQueueIdx))
	}
	return i, nil
}

func (m *QosClassStatusEpd) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosClassStatusEpd) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.InputQueues) > 0 {
		for _, msg := range m.InputQueues {
			dAtA[i] = 0xa
			i++
			i = encodeVarintQos(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.OutputQueues) > 0 {
		for _, msg := range m.OutputQueues {
			dAtA[i] = 0x12
			i++
			i = encodeVarintQos(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *QosClassStatusCpd) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosClassStatusCpd) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *QosClassStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosClassStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.QosClassHandle != 0 {
		dAtA[i] = 0x9
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.QosClassHandle))
		i += 8
	}
	if m.QosClassPdStatus != nil {
		nn15, err := m.QosClassPdStatus.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn15
	}
	return i, nil
}

func (m *QosClassStatus_EpdStatus) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.EpdStatus != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.EpdStatus.Size()))
		n16, err := m.EpdStatus.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	return i, nil
}
func (m *QosClassStatus_CpdStatus) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.CpdStatus != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.CpdStatus.Size()))
		n17, err := m.CpdStatus.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	return i, nil
}
func (m *QosClassResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosClassResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.ApiStatus))
	}
	if m.Status != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.Status.Size()))
		n18, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	return i, nil
}

func (m *QosClassResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosClassResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintQos(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *QosClassDeleteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosClassDeleteRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.Meta.Size()))
		n19, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	if m.KeyOrHandle != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n20, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	return i, nil
}

func (m *QosClassDeleteRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosClassDeleteRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintQos(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *QosClassDeleteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosClassDeleteResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.ApiStatus))
	}
	return i, nil
}

func (m *QosClassDeleteResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosClassDeleteResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintQos(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *QosClassInputQueueStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosClassInputQueueStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.InputQueue != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.InputQueue.Size()))
		n21, err := m.InputQueue.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	if m.GoodPktsIn != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.GoodPktsIn))
	}
	if m.GoodPktsOut != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.GoodPktsOut))
	}
	if m.ErroredPktsIn != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.ErroredPktsIn))
	}
	if m.HbmFifoDepth != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.HbmFifoDepth))
	}
	if m.MaxFifoDepth != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.MaxFifoDepth))
	}
	if m.BufferOccupancy != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.BufferOccupancy))
	}
	return i, nil
}

func (m *QosClassOutputQueueStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosClassOutputQueueStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.OutputQueue != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.OutputQueue.Size()))
		n22, err := m.OutputQueue.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	if m.QueueDepth != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.QueueDepth))
	}
	return i, nil
}

func (m *QosClassStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosClassStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.NumLifsTx != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.NumLifsTx))
	}
	if m.NumLifsRx != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.NumLifsRx))
	}
	if len(m.InputQueueStats) > 0 {
		for _, msg := range m.InputQueueStats {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintQos(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.OutputQueueStats) > 0 {
		for _, msg := range m.OutputQueueStats {
			dAtA[i] = 0x22
			i++
			i = encodeVarintQos(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *QosClassGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosClassGetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.Meta.Size()))
		n23, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	if m.KeyOrHandle != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n24, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	return i, nil
}

func (m *QosClassGetRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosClassGetRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintQos(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *QosClassGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosClassGetResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.ApiStatus))
	}
	if m.Spec != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.Spec.Size()))
		n25, err := m.Spec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	if m.Status != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.Status.Size()))
		n26, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n26
	}
	if m.Stats != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.Stats.Size()))
		n27, err := m.Stats.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n27
	}
	return i, nil
}

func (m *QosClassGetResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosClassGetResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintQos(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CoppSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CoppSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.Meta.Size()))
		n28, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n28
	}
	if m.KeyOrHandle != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n29, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n29
	}
	if m.Policer != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.Policer.Size()))
		n30, err := m.Policer.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n30
	}
	return i, nil
}

func (m *CoppRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CoppRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintQos(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CoppStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CoppStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CoppHandle != 0 {
		dAtA[i] = 0x9
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.CoppHandle))
		i += 8
	}
	return i, nil
}

func (m *CoppResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CoppResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.ApiStatus))
	}
	if m.Status != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.Status.Size()))
		n31, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n31
	}
	return i, nil
}

func (m *CoppResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CoppResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintQos(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CoppGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CoppGetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.Meta.Size()))
		n32, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n32
	}
	if m.KeyOrHandle != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n33, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n33
	}
	return i, nil
}

func (m *CoppGetRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CoppGetRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintQos(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CoppGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CoppGetResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.ApiStatus))
	}
	if m.Spec != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.Spec.Size()))
		n34, err := m.Spec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n34
	}
	if m.Status != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.Status.Size()))
		n35, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n35
	}
	if m.Stats != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintQos(dAtA, i, uint64(m.Stats.Size()))
		n36, err := m.Stats.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n36
	}
	return i, nil
}

func (m *CoppGetResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CoppGetResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintQos(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func encodeVarintQos(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *PolicerSpec) Size() (n int) {
	var l int
	_ = l
	if m.BpsRate != 0 {
		n += 1 + sovQos(uint64(m.BpsRate))
	}
	if m.BurstSize != 0 {
		n += 1 + sovQos(uint64(m.BurstSize))
	}
	return n
}

func (m *PolicerStats) Size() (n int) {
	var l int
	_ = l
	if m.PermittedPackets != 0 {
		n += 1 + sovQos(uint64(m.PermittedPackets))
	}
	if m.PermittedBytes != 0 {
		n += 1 + sovQos(uint64(m.PermittedBytes))
	}
	if m.DroppedPackets != 0 {
		n += 1 + sovQos(uint64(m.DroppedPackets))
	}
	if m.DroppedBytes != 0 {
		n += 1 + sovQos(uint64(m.DroppedBytes))
	}
	return n
}

func (m *QosPFC) Size() (n int) {
	var l int
	_ = l
	if m.Cos != 0 {
		n += 1 + sovQos(uint64(m.Cos))
	}
	if m.XonThreshold != 0 {
		n += 1 + sovQos(uint64(m.XonThreshold))
	}
	if m.XoffThreshold != 0 {
		n += 1 + sovQos(uint64(m.XoffThreshold))
	}
	return n
}

func (m *QosSched) Size() (n int) {
	var l int
	_ = l
	if m.SchedType != nil {
		n += m.SchedType.Size()
	}
	return n
}

func (m *QosSched_Dwrr) Size() (n int) {
	var l int
	_ = l
	if m.Dwrr != nil {
		l = m.Dwrr.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	return n
}
func (m *QosSched_Strict) Size() (n int) {
	var l int
	_ = l
	if m.Strict != nil {
		l = m.Strict.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	return n
}
func (m *QosSched_DWRRInfo) Size() (n int) {
	var l int
	_ = l
	if m.BwPercentage != 0 {
		n += 1 + sovQos(uint64(m.BwPercentage))
	}
	return n
}

func (m *QosSched_StrictPriorityInfo) Size() (n int) {
	var l int
	_ = l
	if m.Bps != 0 {
		n += 1 + sovQos(uint64(m.Bps))
	}
	return n
}

func (m *QosUplinkClassMap) Size() (n int) {
	var l int
	_ = l
	if m.Dot1QPcp != 0 {
		n += 1 + sovQos(uint64(m.Dot1QPcp))
	}
	if len(m.IpDscp) > 0 {
		l = 0
		for _, e := range m.IpDscp {
			l += sovQos(uint64(e))
		}
		n += 1 + sovQos(uint64(l)) + l
	}
	return n
}

func (m *QosMarking) Size() (n int) {
	var l int
	_ = l
	if m.Dot1QPcpRewriteEn {
		n += 2
	}
	if m.Dot1QPcp != 0 {
		n += 1 + sovQos(uint64(m.Dot1QPcp))
	}
	if m.IpDscpRewriteEn {
		n += 2
	}
	if m.IpDscp != 0 {
		n += 1 + sovQos(uint64(m.IpDscp))
	}
	return n
}

func (m *QosClassSpec) Size() (n int) {
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	if m.Mtu != 0 {
		n += 1 + sovQos(uint64(m.Mtu))
	}
	if m.Pfc != nil {
		l = m.Pfc.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	if m.Sched != nil {
		l = m.Sched.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	if m.UplinkClassMap != nil {
		l = m.UplinkClassMap.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	if m.Marking != nil {
		l = m.Marking.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	return n
}

func (m *QosClassRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovQos(uint64(l))
		}
	}
	return n
}

func (m *PortTypeNum) Size() (n int) {
	var l int
	_ = l
	if m.PortTypeOrNum != nil {
		n += m.PortTypeOrNum.Size()
	}
	return n
}

func (m *PortTypeNum_PortType_) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovQos(uint64(m.PortType))
	return n
}
func (m *PortTypeNum_UplinkPortNum) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovQos(uint64(m.UplinkPortNum))
	return n
}
func (m *QosClassInputQueue) Size() (n int) {
	var l int
	_ = l
	if m.PortTypeNum != nil {
		l = m.PortTypeNum.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	if m.InputQueueIdx != 0 {
		n += 1 + sovQos(uint64(m.InputQueueIdx))
	}
	return n
}

func (m *QosClassOutputQueue) Size() (n int) {
	var l int
	_ = l
	if m.PortTypeNum != nil {
		l = m.PortTypeNum.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	if m.OutputQueueIdx != 0 {
		n += 1 + sovQos(uint64(m.OutputQueueIdx))
	}
	return n
}

func (m *QosClassStatusEpd) Size() (n int) {
	var l int
	_ = l
	if len(m.InputQueues) > 0 {
		for _, e := range m.InputQueues {
			l = e.Size()
			n += 1 + l + sovQos(uint64(l))
		}
	}
	if len(m.OutputQueues) > 0 {
		for _, e := range m.OutputQueues {
			l = e.Size()
			n += 1 + l + sovQos(uint64(l))
		}
	}
	return n
}

func (m *QosClassStatusCpd) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *QosClassStatus) Size() (n int) {
	var l int
	_ = l
	if m.QosClassHandle != 0 {
		n += 9
	}
	if m.QosClassPdStatus != nil {
		n += m.QosClassPdStatus.Size()
	}
	return n
}

func (m *QosClassStatus_EpdStatus) Size() (n int) {
	var l int
	_ = l
	if m.EpdStatus != nil {
		l = m.EpdStatus.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	return n
}
func (m *QosClassStatus_CpdStatus) Size() (n int) {
	var l int
	_ = l
	if m.CpdStatus != nil {
		l = m.CpdStatus.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	return n
}
func (m *QosClassResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovQos(uint64(m.ApiStatus))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	return n
}

func (m *QosClassResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovQos(uint64(l))
		}
	}
	return n
}

func (m *QosClassDeleteRequest) Size() (n int) {
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	return n
}

func (m *QosClassDeleteRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovQos(uint64(l))
		}
	}
	return n
}

func (m *QosClassDeleteResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovQos(uint64(m.ApiStatus))
	}
	return n
}

func (m *QosClassDeleteResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovQos(uint64(l))
		}
	}
	return n
}

func (m *QosClassInputQueueStats) Size() (n int) {
	var l int
	_ = l
	if m.InputQueue != nil {
		l = m.InputQueue.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	if m.GoodPktsIn != 0 {
		n += 1 + sovQos(uint64(m.GoodPktsIn))
	}
	if m.GoodPktsOut != 0 {
		n += 1 + sovQos(uint64(m.GoodPktsOut))
	}
	if m.ErroredPktsIn != 0 {
		n += 1 + sovQos(uint64(m.ErroredPktsIn))
	}
	if m.HbmFifoDepth != 0 {
		n += 1 + sovQos(uint64(m.HbmFifoDepth))
	}
	if m.MaxFifoDepth != 0 {
		n += 1 + sovQos(uint64(m.MaxFifoDepth))
	}
	if m.BufferOccupancy != 0 {
		n += 1 + sovQos(uint64(m.BufferOccupancy))
	}
	return n
}

func (m *QosClassOutputQueueStats) Size() (n int) {
	var l int
	_ = l
	if m.OutputQueue != nil {
		l = m.OutputQueue.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	if m.QueueDepth != 0 {
		n += 1 + sovQos(uint64(m.QueueDepth))
	}
	return n
}

func (m *QosClassStats) Size() (n int) {
	var l int
	_ = l
	if m.NumLifsTx != 0 {
		n += 1 + sovQos(uint64(m.NumLifsTx))
	}
	if m.NumLifsRx != 0 {
		n += 1 + sovQos(uint64(m.NumLifsRx))
	}
	if len(m.InputQueueStats) > 0 {
		for _, e := range m.InputQueueStats {
			l = e.Size()
			n += 1 + l + sovQos(uint64(l))
		}
	}
	if len(m.OutputQueueStats) > 0 {
		for _, e := range m.OutputQueueStats {
			l = e.Size()
			n += 1 + l + sovQos(uint64(l))
		}
	}
	return n
}

func (m *QosClassGetRequest) Size() (n int) {
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	return n
}

func (m *QosClassGetRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovQos(uint64(l))
		}
	}
	return n
}

func (m *QosClassGetResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovQos(uint64(m.ApiStatus))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	if m.Stats != nil {
		l = m.Stats.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	return n
}

func (m *QosClassGetResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovQos(uint64(l))
		}
	}
	return n
}

func (m *CoppSpec) Size() (n int) {
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	if m.Policer != nil {
		l = m.Policer.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	return n
}

func (m *CoppRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovQos(uint64(l))
		}
	}
	return n
}

func (m *CoppStatus) Size() (n int) {
	var l int
	_ = l
	if m.CoppHandle != 0 {
		n += 9
	}
	return n
}

func (m *CoppResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovQos(uint64(m.ApiStatus))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	return n
}

func (m *CoppResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovQos(uint64(l))
		}
	}
	return n
}

func (m *CoppGetRequest) Size() (n int) {
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	return n
}

func (m *CoppGetRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovQos(uint64(l))
		}
	}
	return n
}

func (m *CoppGetResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovQos(uint64(m.ApiStatus))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	if m.Stats != nil {
		l = m.Stats.Size()
		n += 1 + l + sovQos(uint64(l))
	}
	return n
}

func (m *CoppGetResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovQos(uint64(l))
		}
	}
	return n
}

func sovQos(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozQos(x uint64) (n int) {
	return sovQos(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *PolicerSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PolicerSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PolicerSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BpsRate", wireType)
			}
			m.BpsRate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BpsRate |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BurstSize", wireType)
			}
			m.BurstSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BurstSize |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PolicerStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PolicerStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PolicerStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PermittedPackets", wireType)
			}
			m.PermittedPackets = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PermittedPackets |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PermittedBytes", wireType)
			}
			m.PermittedBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PermittedBytes |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DroppedPackets", wireType)
			}
			m.DroppedPackets = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DroppedPackets |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DroppedBytes", wireType)
			}
			m.DroppedBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DroppedBytes |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosPFC) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QosPFC: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QosPFC: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cos", wireType)
			}
			m.Cos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cos |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field XonThreshold", wireType)
			}
			m.XonThreshold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.XonThreshold |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field XoffThreshold", wireType)
			}
			m.XoffThreshold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.XoffThreshold |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosSched) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QosSched: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QosSched: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dwrr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &QosSched_DWRRInfo{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.SchedType = &QosSched_Dwrr{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Strict", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &QosSched_StrictPriorityInfo{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.SchedType = &QosSched_Strict{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosSched_DWRRInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DWRRInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DWRRInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BwPercentage", wireType)
			}
			m.BwPercentage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BwPercentage |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosSched_StrictPriorityInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StrictPriorityInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StrictPriorityInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bps", wireType)
			}
			m.Bps = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Bps |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosUplinkClassMap) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QosUplinkClassMap: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QosUplinkClassMap: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dot1QPcp", wireType)
			}
			m.Dot1QPcp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Dot1QPcp |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowQos
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.IpDscp = append(m.IpDscp, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowQos
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthQos
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowQos
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.IpDscp = append(m.IpDscp, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field IpDscp", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosMarking) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QosMarking: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QosMarking: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dot1QPcpRewriteEn", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Dot1QPcpRewriteEn = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dot1QPcp", wireType)
			}
			m.Dot1QPcp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Dot1QPcp |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpDscpRewriteEn", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IpDscpRewriteEn = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpDscp", wireType)
			}
			m.IpDscp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IpDscp |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosClassSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QosClassSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QosClassSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &ObjectMeta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &QosClassKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mtu", wireType)
			}
			m.Mtu = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mtu |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pfc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pfc == nil {
				m.Pfc = &QosPFC{}
			}
			if err := m.Pfc.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sched", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Sched == nil {
				m.Sched = &QosSched{}
			}
			if err := m.Sched.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UplinkClassMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UplinkClassMap == nil {
				m.UplinkClassMap = &QosUplinkClassMap{}
			}
			if err := m.UplinkClassMap.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Marking", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Marking == nil {
				m.Marking = &QosMarking{}
			}
			if err := m.Marking.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosClassRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QosClassRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QosClassRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &QosClassSpec{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PortTypeNum) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PortTypeNum: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PortTypeNum: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortType", wireType)
			}
			var v PortTypeNum_PortType
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (PortTypeNum_PortType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PortTypeOrNum = &PortTypeNum_PortType_{v}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UplinkPortNum", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PortTypeOrNum = &PortTypeNum_UplinkPortNum{v}
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosClassInputQueue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QosClassInputQueue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QosClassInputQueue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortTypeNum", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PortTypeNum == nil {
				m.PortTypeNum = &PortTypeNum{}
			}
			if err := m.PortTypeNum.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputQueueIdx", wireType)
			}
			m.InputQueueIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InputQueueIdx |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosClassOutputQueue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QosClassOutputQueue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QosClassOutputQueue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortTypeNum", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PortTypeNum == nil {
				m.PortTypeNum = &PortTypeNum{}
			}
			if err := m.PortTypeNum.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputQueueIdx", wireType)
			}
			m.OutputQueueIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OutputQueueIdx |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosClassStatusEpd) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QosClassStatusEpd: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QosClassStatusEpd: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputQueues", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InputQueues = append(m.InputQueues, &QosClassInputQueue{})
			if err := m.InputQueues[len(m.InputQueues)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputQueues", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OutputQueues = append(m.OutputQueues, &QosClassOutputQueue{})
			if err := m.OutputQueues[len(m.OutputQueues)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosClassStatusCpd) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QosClassStatusCpd: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QosClassStatusCpd: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosClassStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QosClassStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QosClassStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field QosClassHandle", wireType)
			}
			m.QosClassHandle = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.QosClassHandle = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EpdStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &QosClassStatusEpd{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.QosClassPdStatus = &QosClassStatus_EpdStatus{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpdStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &QosClassStatusCpd{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.QosClassPdStatus = &QosClassStatus_CpdStatus{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosClassResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QosClassResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QosClassResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &QosClassStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosClassResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QosClassResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QosClassResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &QosClassResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosClassDeleteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QosClassDeleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QosClassDeleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &ObjectMeta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &QosClassKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosClassDeleteRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QosClassDeleteRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QosClassDeleteRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &QosClassDeleteRequest{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosClassDeleteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QosClassDeleteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QosClassDeleteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosClassDeleteResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QosClassDeleteResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QosClassDeleteResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &QosClassDeleteResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosClassInputQueueStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QosClassInputQueueStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QosClassInputQueueStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputQueue", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InputQueue == nil {
				m.InputQueue = &QosClassInputQueue{}
			}
			if err := m.InputQueue.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GoodPktsIn", wireType)
			}
			m.GoodPktsIn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GoodPktsIn |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GoodPktsOut", wireType)
			}
			m.GoodPktsOut = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GoodPktsOut |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErroredPktsIn", wireType)
			}
			m.ErroredPktsIn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErroredPktsIn |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HbmFifoDepth", wireType)
			}
			m.HbmFifoDepth = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HbmFifoDepth |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxFifoDepth", wireType)
			}
			m.MaxFifoDepth = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxFifoDepth |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BufferOccupancy", wireType)
			}
			m.BufferOccupancy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BufferOccupancy |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosClassOutputQueueStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QosClassOutputQueueStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QosClassOutputQueueStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputQueue", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OutputQueue == nil {
				m.OutputQueue = &QosClassOutputQueue{}
			}
			if err := m.OutputQueue.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueueDepth", wireType)
			}
			m.QueueDepth = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.QueueDepth |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosClassStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QosClassStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QosClassStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumLifsTx", wireType)
			}
			m.NumLifsTx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumLifsTx |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumLifsRx", wireType)
			}
			m.NumLifsRx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumLifsRx |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputQueueStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InputQueueStats = append(m.InputQueueStats, &QosClassInputQueueStats{})
			if err := m.InputQueueStats[len(m.InputQueueStats)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputQueueStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OutputQueueStats = append(m.OutputQueueStats, &QosClassOutputQueueStats{})
			if err := m.OutputQueueStats[len(m.OutputQueueStats)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosClassGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QosClassGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QosClassGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &ObjectMeta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &QosClassKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosClassGetRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QosClassGetRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QosClassGetRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &QosClassGetRequest{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosClassGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QosClassGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QosClassGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &QosClassSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &QosClassStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = &QosClassStats{}
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosClassGetResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QosClassGetResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QosClassGetResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &QosClassGetResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CoppSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CoppSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CoppSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &ObjectMeta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &CoppKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Policer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Policer == nil {
				m.Policer = &PolicerSpec{}
			}
			if err := m.Policer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CoppRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CoppRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CoppRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &CoppSpec{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CoppStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CoppStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CoppStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CoppHandle", wireType)
			}
			m.CoppHandle = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.CoppHandle = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CoppResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CoppResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CoppResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &CoppStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CoppResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CoppResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CoppResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &CoppResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CoppGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CoppGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CoppGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &ObjectMeta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &CoppKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CoppGetRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CoppGetRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CoppGetRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &CoppGetRequest{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CoppGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CoppGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CoppGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &CoppSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &CoppStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = &PolicerStats{}
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CoppGetResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CoppGetResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CoppGetResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &CoppGetResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipQos(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowQos
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowQos
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowQos
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthQos
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowQos
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipQos(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthQos = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowQos   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("qos.proto", fileDescriptorQos) }

var fileDescriptorQos = []byte{
	// 1967 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x58, 0xcb, 0x6f, 0x1b, 0xc9,
	0xd1, 0xd7, 0x88, 0xb2, 0x44, 0x15, 0x1f, 0x22, 0x5b, 0x7e, 0xd0, 0xda, 0xcf, 0xa2, 0xbe, 0xd9,
	0x87, 0xbd, 0xf0, 0x5a, 0x2b, 0x4b, 0x5e, 0xcb, 0x52, 0x76, 0x11, 0x9b, 0x7a, 0xc7, 0x91, 0x45,
	0x8d, 0x64, 0x04, 0xc9, 0x65, 0x32, 0x1c, 0x36, 0xc5, 0x09, 0xc5, 0x99, 0xd6, 0x74, 0x4f, 0x4c,
	0x6e, 0x20, 0x64, 0x6f, 0x09, 0x10, 0x20, 0x97, 0x00, 0x41, 0xee, 0x39, 0xe5, 0x9a, 0x53, 0x0e,
	0xb9, 0xe5, 0x92, 0x43, 0x10, 0xe4, 0x1e, 0x40, 0x08, 0x1c, 0x20, 0x40, 0xae, 0xfa, 0x0b, 0x82,
	0x7e, 0x0c, 0x67, 0x86, 0x0f, 0x67, 0xb5, 0xeb, 0x60, 0x4f, 0xa2, 0xaa, 0xab, 0x7e, 0x55, 0xd5,
	0x55, 0xf5, 0xeb, 0x22, 0x61, 0xfa, 0xcc, 0xa3, 0x8b, 0xc4, 0xf7, 0x98, 0x87, 0x52, 0x67, 0x1e,
	0x9d, 0xcb, 0xb0, 0x2e, 0xc1, 0x4a, 0x32, 0x97, 0x6e, 0x35, 0xe5, 0x27, 0x7d, 0x07, 0x32, 0x55,
	0xef, 0xd4, 0xb1, 0xb1, 0x7f, 0x44, 0xb0, 0x8d, 0x6e, 0x43, 0xba, 0x46, 0xa8, 0xe9, 0x5b, 0x0c,
	0x97, 0xb4, 0x05, 0xed, 0xde, 0x84, 0x31, 0x55, 0x23, 0xd4, 0xb0, 0x18, 0x46, 0x77, 0x00, 0x6a,
	0x81, 0x4f, 0x99, 0x49, 0x9d, 0xcf, 0x71, 0x69, 0x5c, 0x1c, 0x4e, 0x0b, 0xc9, 0x91, 0xf3, 0x39,
	0xd6, 0x7f, 0xaf, 0x41, 0x36, 0x44, 0x62, 0x16, 0xa3, 0xe8, 0x3e, 0x14, 0x09, 0xf6, 0xdb, 0x0e,
	0x63, 0xb8, 0x6e, 0x12, 0xcb, 0x6e, 0x61, 0x46, 0x15, 0x66, 0xa1, 0x77, 0x50, 0x95, 0x72, 0x74,
	0x17, 0x66, 0x22, 0xe5, 0x5a, 0x97, 0x61, 0xaa, 0x3c, 0xe4, 0x7b, 0xe2, 0x0a, 0x97, 0x72, 0xc5,
	0xba, 0xef, 0x11, 0x12, 0xc3, 0x4c, 0x49, 0x45, 0x25, 0x0e, 0x11, 0xdf, 0x85, 0x5c, 0xa8, 0x28,
	0xf1, 0x26, 0x84, 0x5a, 0x56, 0x09, 0x05, 0x9a, 0xfe, 0xab, 0x71, 0x98, 0x3c, 0xf4, 0x68, 0x75,
	0x7b, 0x03, 0x6d, 0x41, 0xca, 0xf6, 0x64, 0x80, 0xb9, 0xca, 0xca, 0xe5, 0x45, 0xf9, 0xe3, 0x1f,
	0x63, 0xd7, 0xb1, 0xf1, 0x7a, 0xdb, 0x72, 0xeb, 0x16, 0xf3, 0xfc, 0xee, 0x47, 0x4a, 0x60, 0x7b,
	0x2e, 0x65, 0xbe, 0xe5, 0xb8, 0x8c, 0x7e, 0xf6, 0x13, 0xdf, 0x72, 0x4f, 0xf0, 0xfa, 0xd2, 0x83,
	0xd5, 0x73, 0x83, 0xdb, 0x23, 0x13, 0x72, 0x1d, 0xcf, 0x35, 0x59, 0xd3, 0xc7, 0xb4, 0xe9, 0x9d,
	0xd6, 0x45, 0x1a, 0xb9, 0xca, 0xfa, 0xe5, 0x45, 0xf9, 0xf1, 0x15, 0x00, 0x57, 0x96, 0x96, 0x96,
	0x1e, 0xac, 0x3c, 0x7e, 0xf2, 0xf8, 0xd1, 0xb9, 0x91, 0xed, 0x78, 0xee, 0x71, 0x88, 0x87, 0x2c,
	0xc8, 0x77, 0xbc, 0x46, 0x23, 0xe6, 0x21, 0xf5, 0xd5, 0x3d, 0xac, 0xae, 0xac, 0x2e, 0x3f, 0x39,
	0x37, 0x72, 0x1c, 0xb1, 0xe7, 0x42, 0xff, 0x62, 0x1c, 0xd2, 0x87, 0x1e, 0x3d, 0xb2, 0x9b, 0xb8,
	0x8e, 0x3e, 0x82, 0x89, 0xfa, 0x2b, 0xdf, 0x17, 0x17, 0x93, 0x59, 0xbe, 0xb9, 0xc8, 0xdb, 0x2a,
	0x3c, 0x5c, 0xdc, 0xfc, 0x9e, 0x61, 0xec, 0xb9, 0x0d, 0x6f, 0x77, 0xcc, 0x10, 0x5a, 0x68, 0x1d,
	0x26, 0x29, 0xf3, 0x1d, 0x9b, 0x89, 0xbc, 0x33, 0xcb, 0x0b, 0x49, 0xfd, 0x23, 0x71, 0x56, 0xf5,
	0x1d, 0xcf, 0x77, 0x58, 0x57, 0x59, 0x2a, 0x8b, 0xb9, 0x97, 0x90, 0x0e, 0xf1, 0xd0, 0x1e, 0xe4,
	0x6a, 0xaf, 0x4c, 0x82, 0x7d, 0x1b, 0xbb, 0xcc, 0x3a, 0xc1, 0xaa, 0x2e, 0xef, 0x5d, 0x5e, 0x94,
	0x17, 0xde, 0x54, 0x86, 0x87, 0x4b, 0x4b, 0xe7, 0x46, 0xb6, 0xf6, 0xaa, 0xda, 0xb3, 0x9c, 0xfb,
	0x00, 0xd0, 0xa0, 0x5b, 0x54, 0x80, 0x54, 0x8d, 0xa8, 0x72, 0x1b, 0xfc, 0x63, 0x25, 0x03, 0xd3,
	0x22, 0xc8, 0xe3, 0x2e, 0xc1, 0xfa, 0x6f, 0x35, 0x28, 0x1e, 0x7a, 0xf4, 0x25, 0x39, 0x75, 0xdc,
	0xd6, 0xc6, 0xa9, 0x45, 0xe9, 0xbe, 0x45, 0x50, 0x15, 0xa6, 0xeb, 0x1e, 0x7b, 0x78, 0x66, 0x12,
	0x9b, 0x7c, 0x9d, 0x4e, 0x49, 0x0b, 0x94, 0xaa, 0x4d, 0xd0, 0xa7, 0x30, 0xe5, 0x10, 0xb3, 0x4e,
	0x6d, 0x52, 0x1a, 0x5f, 0x48, 0xdd, 0xcb, 0x55, 0xde, 0xbd, 0xbc, 0x28, 0x97, 0xdf, 0x64, 0xfe,
	0x78, 0xe5, 0xdc, 0x98, 0x74, 0xc8, 0x26, 0xb5, 0x89, 0xfe, 0x6f, 0x0d, 0xe0, 0xd0, 0xa3, 0xfb,
	0x96, 0xdf, 0x72, 0xdc, 0x13, 0xf4, 0x31, 0x5c, 0xef, 0x85, 0x67, 0xfa, 0xf8, 0x95, 0xef, 0x30,
	0x6c, 0x62, 0x57, 0x44, 0x9a, 0x36, 0x8a, 0xa1, 0x53, 0x43, 0x9e, 0x6c, 0xb9, 0xe8, 0xdb, 0xf1,
	0x7c, 0x64, 0xa3, 0xea, 0x97, 0x17, 0xe5, 0xf9, 0x2f, 0x1d, 0xfe, 0x7d, 0x40, 0x2a, 0xfc, 0xb8,
	0xbf, 0x94, 0xf0, 0x37, 0x23, 0x83, 0x8c, 0xbc, 0xc5, 0x72, 0x9d, 0x10, 0xbe, 0xae, 0x94, 0xeb,
	0xaf, 0x53, 0x90, 0x3d, 0xf4, 0xa8, 0xa8, 0x85, 0xa0, 0xaa, 0xf7, 0x61, 0xa2, 0x8d, 0x99, 0xa5,
	0x1a, 0xb3, 0xb8, 0x28, 0xf9, 0xed, 0xa0, 0xf6, 0x23, 0x6c, 0xb3, 0x7d, 0xcc, 0x2c, 0x43, 0x1c,
	0xa3, 0xe7, 0x90, 0x6b, 0xe1, 0xae, 0xe9, 0xf9, 0x66, 0xd3, 0x72, 0xeb, 0xa7, 0x58, 0x35, 0xe6,
	0x8d, 0xc5, 0x56, 0x73, 0x31, 0xc4, 0x7b, 0x8e, 0xbb, 0xbb, 0xe2, 0xb0, 0x52, 0xb8, 0xbc, 0x28,
	0x67, 0x55, 0x48, 0x7a, 0x0b, 0x77, 0x75, 0x23, 0xd3, 0xc2, 0xdd, 0x03, 0x5f, 0x1e, 0xa3, 0xe7,
	0x90, 0x6a, 0xb3, 0x40, 0x4d, 0xdc, 0xda, 0xe5, 0x45, 0xf9, 0x93, 0x2b, 0x94, 0xfe, 0xe1, 0x27,
	0x4b, 0x4b, 0x0f, 0xd6, 0x96, 0x1f, 0x3e, 0x3e, 0x37, 0x38, 0x0a, 0xba, 0x03, 0x29, 0xd2, 0xb0,
	0xc5, 0x5d, 0x64, 0x96, 0x33, 0xe1, 0xa0, 0x54, 0xb7, 0x37, 0x0c, 0x2e, 0x47, 0x6b, 0x70, 0x8d,
	0xf2, 0x7e, 0x2c, 0x5d, 0x13, 0x0a, 0xb9, 0xc4, 0x24, 0x55, 0xae, 0x5f, 0x5e, 0x94, 0x0b, 0xfd,
	0xce, 0x0d, 0x69, 0x81, 0x9e, 0x42, 0x21, 0x10, 0x9d, 0x6b, 0xda, 0x3c, 0x3d, 0xb3, 0x6d, 0x91,
	0xd2, 0x64, 0x72, 0x7e, 0x93, 0x9d, 0x6d, 0xe4, 0x83, 0x64, 0xa7, 0x7f, 0x08, 0x53, 0x6d, 0xd9,
	0x55, 0xa5, 0x29, 0x61, 0x38, 0x13, 0x1a, 0xaa, 0x66, 0x33, 0xc2, 0x73, 0xfd, 0x19, 0xa0, 0xf0,
	0x1e, 0x0d, 0x7c, 0x16, 0x60, 0xca, 0xf6, 0xe9, 0x09, 0xba, 0x0f, 0x53, 0xbe, 0xfc, 0xaf, 0xa4,
	0x2d, 0xa4, 0x44, 0x81, 0x14, 0x40, 0xaf, 0x82, 0x46, 0xa8, 0xa1, 0xff, 0x45, 0xe3, 0xaf, 0x90,
	0xcf, 0xf8, 0xe8, 0xbd, 0x08, 0xda, 0xe8, 0x09, 0x4c, 0x13, 0xcf, 0x67, 0x26, 0x2f, 0xa9, 0xa8,
	0x6f, 0x7e, 0xf9, 0xb6, 0x30, 0x8f, 0x29, 0xf5, 0x3e, 0xef, 0x8e, 0x19, 0x69, 0xa2, 0x3e, 0xa3,
	0x7b, 0x30, 0xa3, 0x32, 0x17, 0x00, 0x6e, 0xd0, 0x96, 0x7d, 0xbd, 0x3b, 0x66, 0xe4, 0xe4, 0x01,
	0x37, 0x7b, 0x11, 0xb4, 0xf5, 0x2d, 0x48, 0x87, 0x08, 0xa8, 0x08, 0xb9, 0xea, 0x81, 0x71, 0x6c,
	0x1e, 0x7f, 0xbf, 0xba, 0x65, 0x6e, 0xee, 0x3f, 0x2b, 0x8c, 0x21, 0x04, 0xf9, 0x48, 0x54, 0x7d,
	0xb4, 0xb7, 0x53, 0xd0, 0xfa, 0x65, 0x5b, 0x3b, 0x85, 0xf1, 0x0a, 0x82, 0x42, 0x2f, 0x54, 0xde,
	0x64, 0x6e, 0xd0, 0xd6, 0xfd, 0xe8, 0x46, 0xf6, 0x5c, 0x12, 0xb0, 0xc3, 0x00, 0x07, 0x18, 0x3d,
	0x82, 0x5c, 0xa4, 0xc9, 0x03, 0x93, 0x8d, 0x5b, 0xe8, 0x4f, 0xcc, 0xc8, 0x90, 0xd8, 0x55, 0x7c,
	0x00, 0x33, 0x0e, 0xc7, 0x30, 0xcf, 0x38, 0x88, 0xe9, 0xd4, 0x3b, 0x32, 0x21, 0x23, 0xe7, 0xf4,
	0xa0, 0xf7, 0xea, 0x1d, 0x3d, 0x80, 0xd9, 0xd0, 0xe7, 0x41, 0xc0, 0xbe, 0xa6, 0xd3, 0x7b, 0x50,
	0xf0, 0x04, 0xc8, 0x80, 0xd7, 0xbc, 0x17, 0x81, 0x73, 0xb7, 0xbf, 0x94, 0x3c, 0x29, 0x6b, 0xca,
	0x2c, 0x16, 0xd0, 0x2d, 0x52, 0x47, 0xeb, 0x90, 0x8d, 0x05, 0x4d, 0x55, 0x07, 0xdc, 0x4a, 0x74,
	0x40, 0x74, 0x33, 0x46, 0x26, 0x4a, 0x85, 0xa2, 0xcf, 0x20, 0x17, 0xf7, 0x4d, 0x05, 0x2f, 0x66,
	0x96, 0x4b, 0x09, 0xe3, 0x58, 0x8a, 0x46, 0x36, 0x16, 0x12, 0xd5, 0x67, 0xfb, 0xe3, 0xd9, 0x20,
	0x75, 0xfd, 0x4f, 0x1a, 0xe4, 0x93, 0x52, 0x9e, 0xe2, 0x99, 0x47, 0xd5, 0x7c, 0x28, 0x66, 0xe0,
	0x77, 0x33, 0x69, 0xe4, 0xcf, 0x94, 0xa6, 0x9a, 0xf9, 0x55, 0x00, 0x4c, 0xea, 0x26, 0x15, 0x76,
	0x8a, 0x3d, 0x6e, 0x26, 0x9b, 0x39, 0x4c, 0x7c, 0x77, 0xcc, 0x98, 0xc6, 0xa4, 0xae, 0x5c, 0xac,
	0x02, 0xd8, 0x91, 0x61, 0x6a, 0xa4, 0xe1, 0x86, 0x34, 0xb4, 0x43, 0xc3, 0xca, 0x0d, 0x98, 0x8d,
	0x62, 0xeb, 0x21, 0xe8, 0x3f, 0xd3, 0xa0, 0x10, 0x4d, 0x1a, 0x25, 0x9e, 0x4b, 0x31, 0xda, 0x06,
	0xb0, 0x88, 0x13, 0x3a, 0x91, 0xb3, 0x52, 0x50, 0x5c, 0xf8, 0x8c, 0x38, 0x21, 0xe2, 0xe5, 0x45,
	0xb9, 0xa8, 0xd8, 0x22, 0x52, 0x37, 0xa6, 0xad, 0x50, 0x03, 0xdd, 0xe7, 0x0f, 0x77, 0x2c, 0xc3,
	0xd9, 0x21, 0x81, 0x1a, 0x4a, 0x45, 0xdf, 0x8d, 0x9a, 0x2d, 0x0c, 0x84, 0xcf, 0xfc, 0x43, 0x48,
	0xfb, 0xea, 0x5f, 0x55, 0xf2, 0x1b, 0x09, 0x94, 0x50, 0xd7, 0xe8, 0xa9, 0xe9, 0xbf, 0xd0, 0xe0,
	0x46, 0x78, 0xbc, 0x89, 0x4f, 0x31, 0xc3, 0x8a, 0x43, 0xbe, 0x09, 0x7a, 0xd7, 0xab, 0x50, 0x1a,
	0x1a, 0x0c, 0x4f, 0xee, 0x51, 0x3f, 0xa1, 0xcd, 0x25, 0x72, 0x4b, 0xe8, 0x47, 0xcc, 0xf6, 0x43,
	0xb8, 0xd9, 0xaf, 0xf1, 0x76, 0x0b, 0xa7, 0x1f, 0xc3, 0xed, 0xe1, 0x1e, 0x78, 0xd0, 0xab, 0x03,
	0x15, 0x79, 0x67, 0x68, 0xd4, 0x03, 0x75, 0xf9, 0xc3, 0x38, 0xdc, 0x1a, 0x9c, 0x54, 0xb9, 0xd8,
	0x3f, 0x81, 0x4c, 0x6c, 0xba, 0x55, 0x81, 0x46, 0x0e, 0x37, 0x44, 0xc3, 0x8d, 0x16, 0x20, 0x7b,
	0xe2, 0x79, 0x75, 0x93, 0xb4, 0x18, 0x35, 0x1d, 0x57, 0xad, 0xf8, 0xc0, 0x65, 0xd5, 0x16, 0xa3,
	0x7b, 0x2e, 0xd2, 0x21, 0x17, 0x69, 0x78, 0x01, 0x53, 0xcb, 0x7d, 0x26, 0x54, 0x39, 0x08, 0x18,
	0xa7, 0x44, 0xec, 0xfb, 0x9e, 0x8f, 0x23, 0x20, 0xb9, 0xdb, 0xe7, 0x94, 0x58, 0x61, 0xbd, 0x07,
	0xf9, 0x66, 0xad, 0x6d, 0x36, 0x9c, 0x86, 0x67, 0xd6, 0x31, 0x61, 0x4d, 0xf1, 0x92, 0xe6, 0x8c,
	0x6c, 0xb3, 0xd6, 0xde, 0x76, 0x1a, 0xde, 0x26, 0x97, 0x71, 0xad, 0xb6, 0xd5, 0x89, 0x6b, 0x4d,
	0x4a, 0xad, 0xb6, 0xd5, 0x89, 0xb4, 0x3e, 0x84, 0x42, 0x2d, 0x68, 0x34, 0xb0, 0x6f, 0x7a, 0xb6,
	0x1d, 0x10, 0xcb, 0xb5, 0xbb, 0xe2, 0x61, 0xcc, 0x19, 0x33, 0x52, 0x7e, 0x10, 0x8a, 0xf5, 0x4e,
	0xd4, 0x44, 0x31, 0x9a, 0x92, 0x57, 0xf7, 0x2d, 0xc8, 0xc6, 0xc9, 0x4d, 0xdd, 0xdd, 0x68, 0x6e,
	0xcb, 0xc4, 0xb8, 0x0d, 0x95, 0x21, 0x23, 0xe9, 0x58, 0x86, 0x29, 0x09, 0x19, 0x84, 0x48, 0x04,
	0xa9, 0xff, 0x4b, 0x83, 0x5c, 0x7c, 0x62, 0x29, 0x9a, 0x87, 0x8c, 0x1b, 0xb4, 0xcd, 0x53, 0xa7,
	0x41, 0x4d, 0xd6, 0x51, 0xdb, 0xee, 0xb4, 0x1b, 0xb4, 0xbf, 0xeb, 0x34, 0xe8, 0x71, 0x27, 0x71,
	0xee, 0x87, 0x1c, 0x1f, 0x9e, 0x1b, 0x1d, 0xb4, 0x0b, 0xc5, 0xf8, 0xeb, 0xc3, 0xbb, 0x8f, 0x33,
	0x19, 0x6f, 0xa4, 0xff, 0x1b, 0x51, 0x70, 0xe1, 0xd8, 0x98, 0x71, 0xfa, 0x9a, 0xe6, 0x39, 0xa0,
	0xc4, 0x93, 0x22, 0xa1, 0x26, 0x04, 0xd4, 0x9d, 0x51, 0xf9, 0x4b, 0xac, 0x82, 0xd7, 0x27, 0xd1,
	0x7f, 0xae, 0x45, 0x2f, 0xec, 0x0e, 0x66, 0xdf, 0x24, 0x65, 0x7c, 0x27, 0xe2, 0xaf, 0x28, 0x12,
	0x49, 0x86, 0x7d, 0x7c, 0x91, 0x9c, 0x90, 0x48, 0x39, 0x22, 0x8b, 0xbf, 0x6b, 0x11, 0xaf, 0x8a,
	0xf3, 0xb7, 0xcc, 0xf1, 0xef, 0xc3, 0x04, 0x25, 0xd8, 0x56, 0xf9, 0x0e, 0x59, 0xc8, 0xc4, 0x71,
	0xec, 0x29, 0x48, 0xfd, 0xd7, 0xa7, 0x00, 0xdd, 0x83, 0x6b, 0x61, 0x29, 0xb9, 0x2e, 0x1a, 0xd0,
	0xa5, 0x86, 0x54, 0xd0, 0x5f, 0x44, 0x54, 0x18, 0x4b, 0x4e, 0x52, 0x6b, 0x3f, 0x4b, 0x95, 0x06,
	0xef, 0x6a, 0x80, 0xa2, 0xfe, 0xa8, 0x41, 0x7a, 0xc3, 0x23, 0xe4, 0x2a, 0x5f, 0x06, 0x76, 0x86,
	0x97, 0xbe, 0xc8, 0x4b, 0xcf, 0xb1, 0xbe, 0xf4, 0x17, 0x81, 0xa7, 0x30, 0x45, 0xe4, 0x8f, 0x1d,
	0xea, 0x92, 0xc2, 0x8d, 0xaa, 0xf7, 0x53, 0xca, 0x88, 0x0d, 0x3d, 0x34, 0xd3, 0xd7, 0x20, 0xcf,
	0x3d, 0xc6, 0x3a, 0xe6, 0x6e, 0x7f, 0xc7, 0xc8, 0x95, 0x3f, 0xcc, 0x31, 0xea, 0x93, 0x07, 0x00,
	0x42, 0x28, 0x2b, 0x50, 0x86, 0x8c, 0xed, 0x11, 0x92, 0x5c, 0x62, 0x80, 0x8b, 0x54, 0x8b, 0xfe,
	0x14, 0xb2, 0xd2, 0xd3, 0x5b, 0x6e, 0xa7, 0xbb, 0x7d, 0x2b, 0xc3, 0x4c, 0x14, 0x6e, 0x72, 0x5d,
	0x78, 0x0a, 0x33, 0xf1, 0x00, 0x78, 0xae, 0x0f, 0x06, 0x4a, 0x5e, 0xec, 0x59, 0x0f, 0xa9, 0xf5,
	0x17, 0x9a, 0xbc, 0xad, 0xab, 0x0f, 0xfb, 0xdb, 0xaa, 0xb8, 0x5e, 0x81, 0x62, 0x32, 0x02, 0x99,
	0x46, 0x5f, 0xc9, 0x66, 0x7b, 0x59, 0x0c, 0x1b, 0xf0, 0xbf, 0x6a, 0xf2, 0x26, 0xfe, 0x17, 0xc3,
	0xfd, 0xff, 0x89, 0xe1, 0xee, 0x6b, 0x1d, 0x39, 0xd8, 0x77, 0xfb, 0x06, 0x7b, 0x54, 0xc1, 0xd0,
	0xdd, 0xe4, 0x50, 0x17, 0x13, 0xbd, 0x1d, 0x9f, 0xe9, 0x6d, 0x40, 0x7d, 0xf9, 0xf0, 0x5b, 0x59,
	0x1a, 0x28, 0xee, 0xf5, 0xe4, 0xb5, 0xf4, 0xd7, 0x77, 0xf9, 0x77, 0x29, 0x48, 0x1d, 0x1e, 0x1c,
	0xa1, 0xad, 0x68, 0x4f, 0xdf, 0xf0, 0xb1, 0xc5, 0x30, 0xba, 0xd5, 0xb7, 0x41, 0x86, 0x57, 0x3f,
	0x57, 0x1a, 0xba, 0x5a, 0xee, 0xd3, 0x13, 0x7d, 0x2c, 0x0e, 0xf3, 0x92, 0xd4, 0xbf, 0x32, 0xcc,
	0x61, 0x04, 0x23, 0x17, 0x25, 0x74, 0x67, 0xf4, 0xce, 0xc7, 0xc1, 0xe6, 0xdf, 0xb0, 0x5c, 0x49,
	0xc8, 0x5d, 0xc8, 0xc4, 0x58, 0x0d, 0xcd, 0x8d, 0x78, 0x13, 0x38, 0xd8, 0x3b, 0xa3, 0x38, 0x50,
	0x22, 0xad, 0x49, 0x12, 0x50, 0xf9, 0xcd, 0xc6, 0xa6, 0xa7, 0x87, 0x70, 0x7d, 0x60, 0xa4, 0xa4,
	0xe9, 0xa7, 0x30, 0xa5, 0x4a, 0x81, 0x6e, 0x0e, 0xe9, 0x57, 0x6e, 0x7a, 0x6b, 0x58, 0xc1, 0x84,
	0x75, 0x65, 0xee, 0xcf, 0xaf, 0xe7, 0xb5, 0xbf, 0xbd, 0x9e, 0xd7, 0xfe, 0xf1, 0x7a, 0x5e, 0xfb,
	0xcd, 0x3f, 0xe7, 0xc7, 0x7e, 0x90, 0x6e, 0x5a, 0xa7, 0xe2, 0xd7, 0xe4, 0xda, 0xa4, 0xf8, 0xb3,
	0xf2, 0x9f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x7c, 0x37, 0x17, 0x43, 0x7d, 0x16, 0x00, 0x00,
}
