// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: rawccb.proto

package halproto

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import encoding_binary "encoding/binary"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// RawcCbKeyHandle is used to operate on a rawccb either by its key or handle
type RawcCbKeyHandle struct {
	// Types that are valid to be assigned to KeyOrHandle:
	//	*RawcCbKeyHandle_RawccbId
	//	*RawcCbKeyHandle_RawccbHandle
	KeyOrHandle isRawcCbKeyHandle_KeyOrHandle `protobuf_oneof:"key_or_handle"`
}

func (m *RawcCbKeyHandle) Reset()                    { *m = RawcCbKeyHandle{} }
func (m *RawcCbKeyHandle) String() string            { return proto.CompactTextString(m) }
func (*RawcCbKeyHandle) ProtoMessage()               {}
func (*RawcCbKeyHandle) Descriptor() ([]byte, []int) { return fileDescriptorRawccb, []int{0} }

type isRawcCbKeyHandle_KeyOrHandle interface {
	isRawcCbKeyHandle_KeyOrHandle()
	MarshalTo([]byte) (int, error)
	Size() int
}

type RawcCbKeyHandle_RawccbId struct {
	RawccbId uint32 `protobuf:"varint,1,opt,name=rawccb_id,json=rawccbId,proto3,oneof"`
}
type RawcCbKeyHandle_RawccbHandle struct {
	RawccbHandle uint64 `protobuf:"fixed64,2,opt,name=rawccb_handle,json=rawccbHandle,proto3,oneof"`
}

func (*RawcCbKeyHandle_RawccbId) isRawcCbKeyHandle_KeyOrHandle()     {}
func (*RawcCbKeyHandle_RawccbHandle) isRawcCbKeyHandle_KeyOrHandle() {}

func (m *RawcCbKeyHandle) GetKeyOrHandle() isRawcCbKeyHandle_KeyOrHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

func (m *RawcCbKeyHandle) GetRawccbId() uint32 {
	if x, ok := m.GetKeyOrHandle().(*RawcCbKeyHandle_RawccbId); ok {
		return x.RawccbId
	}
	return 0
}

func (m *RawcCbKeyHandle) GetRawccbHandle() uint64 {
	if x, ok := m.GetKeyOrHandle().(*RawcCbKeyHandle_RawccbHandle); ok {
		return x.RawccbHandle
	}
	return 0
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*RawcCbKeyHandle) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _RawcCbKeyHandle_OneofMarshaler, _RawcCbKeyHandle_OneofUnmarshaler, _RawcCbKeyHandle_OneofSizer, []interface{}{
		(*RawcCbKeyHandle_RawccbId)(nil),
		(*RawcCbKeyHandle_RawccbHandle)(nil),
	}
}

func _RawcCbKeyHandle_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*RawcCbKeyHandle)
	// key_or_handle
	switch x := m.KeyOrHandle.(type) {
	case *RawcCbKeyHandle_RawccbId:
		_ = b.EncodeVarint(1<<3 | proto.WireVarint)
		_ = b.EncodeVarint(uint64(x.RawccbId))
	case *RawcCbKeyHandle_RawccbHandle:
		_ = b.EncodeVarint(2<<3 | proto.WireFixed64)
		_ = b.EncodeFixed64(uint64(x.RawccbHandle))
	case nil:
	default:
		return fmt.Errorf("RawcCbKeyHandle.KeyOrHandle has unexpected type %T", x)
	}
	return nil
}

func _RawcCbKeyHandle_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*RawcCbKeyHandle)
	switch tag {
	case 1: // key_or_handle.rawccb_id
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.KeyOrHandle = &RawcCbKeyHandle_RawccbId{uint32(x)}
		return true, err
	case 2: // key_or_handle.rawccb_handle
		if wire != proto.WireFixed64 {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeFixed64()
		m.KeyOrHandle = &RawcCbKeyHandle_RawccbHandle{x}
		return true, err
	default:
		return false, nil
	}
}

func _RawcCbKeyHandle_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*RawcCbKeyHandle)
	// key_or_handle
	switch x := m.KeyOrHandle.(type) {
	case *RawcCbKeyHandle_RawccbId:
		n += proto.SizeVarint(1<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.RawccbId))
	case *RawcCbKeyHandle_RawccbHandle:
		n += proto.SizeVarint(2<<3 | proto.WireFixed64)
		n += 8
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// RawcCbSpec captures all the rawccb level configuration
type RawcCbSpec struct {
	KeyOrHandle             *RawcCbKeyHandle `protobuf:"bytes,1,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty"`
	Pi                      uint32           `protobuf:"varint,2,opt,name=pi,proto3" json:"pi,omitempty"`
	Ci                      uint32           `protobuf:"varint,3,opt,name=ci,proto3" json:"ci,omitempty"`
	RawccbFlags             uint32           `protobuf:"varint,4,opt,name=rawccb_flags,json=rawccbFlags,proto3" json:"rawccb_flags,omitempty"`
	MyTxqBase               uint64           `protobuf:"varint,5,opt,name=my_txq_base,json=myTxqBase,proto3" json:"my_txq_base,omitempty"`
	MyTxqRingSizeShift      uint32           `protobuf:"varint,6,opt,name=my_txq_ring_size_shift,json=myTxqRingSizeShift,proto3" json:"my_txq_ring_size_shift,omitempty"`
	MyTxqEntrySizeShift     uint32           `protobuf:"varint,7,opt,name=my_txq_entry_size_shift,json=myTxqEntrySizeShift,proto3" json:"my_txq_entry_size_shift,omitempty"`
	ChainTxqBase            uint64           `protobuf:"varint,8,opt,name=chain_txq_base,json=chainTxqBase,proto3" json:"chain_txq_base,omitempty"`
	ChainTxqRingIndicesAddr uint64           `protobuf:"varint,9,opt,name=chain_txq_ring_indices_addr,json=chainTxqRingIndicesAddr,proto3" json:"chain_txq_ring_indices_addr,omitempty"`
	ChainTxqRingSizeShift   uint32           `protobuf:"varint,10,opt,name=chain_txq_ring_size_shift,json=chainTxqRingSizeShift,proto3" json:"chain_txq_ring_size_shift,omitempty"`
	ChainTxqEntrySizeShift  uint32           `protobuf:"varint,11,opt,name=chain_txq_entry_size_shift,json=chainTxqEntrySizeShift,proto3" json:"chain_txq_entry_size_shift,omitempty"`
	ChainTxqLif             uint32           `protobuf:"varint,12,opt,name=chain_txq_lif,json=chainTxqLif,proto3" json:"chain_txq_lif,omitempty"`
	ChainTxqQtype           uint32           `protobuf:"varint,13,opt,name=chain_txq_qtype,json=chainTxqQtype,proto3" json:"chain_txq_qtype,omitempty"`
	ChainTxqQid             uint32           `protobuf:"varint,14,opt,name=chain_txq_qid,json=chainTxqQid,proto3" json:"chain_txq_qid,omitempty"`
	ChainTxqRing            uint32           `protobuf:"varint,15,opt,name=chain_txq_ring,json=chainTxqRing,proto3" json:"chain_txq_ring,omitempty"`
	//
	// 64-bit statistic counters
	StatPktsChain   uint64 `protobuf:"varint,16,opt,name=stat_pkts_chain,json=statPktsChain,proto3" json:"stat_pkts_chain,omitempty"`
	StatPktsDiscard uint64 `protobuf:"varint,17,opt,name=stat_pkts_discard,json=statPktsDiscard,proto3" json:"stat_pkts_discard,omitempty"`
	//
	// 32-bit saturating statistic counters
	StatCbNotReady      uint32 `protobuf:"varint,18,opt,name=stat_cb_not_ready,json=statCbNotReady,proto3" json:"stat_cb_not_ready,omitempty"`
	StatMyTxqEmpty      uint32 `protobuf:"varint,19,opt,name=stat_my_txq_empty,json=statMyTxqEmpty,proto3" json:"stat_my_txq_empty,omitempty"`
	StatAolErr          uint32 `protobuf:"varint,20,opt,name=stat_aol_err,json=statAolErr,proto3" json:"stat_aol_err,omitempty"`
	StatTxqFull         uint32 `protobuf:"varint,21,opt,name=stat_txq_full,json=statTxqFull,proto3" json:"stat_txq_full,omitempty"`
	StatDescSemFreeFull uint32 `protobuf:"varint,22,opt,name=stat_desc_sem_free_full,json=statDescSemFreeFull,proto3" json:"stat_desc_sem_free_full,omitempty"`
	StatPageSemFreeFull uint32 `protobuf:"varint,23,opt,name=stat_page_sem_free_full,json=statPageSemFreeFull,proto3" json:"stat_page_sem_free_full,omitempty"`
}

func (m *RawcCbSpec) Reset()                    { *m = RawcCbSpec{} }
func (m *RawcCbSpec) String() string            { return proto.CompactTextString(m) }
func (*RawcCbSpec) ProtoMessage()               {}
func (*RawcCbSpec) Descriptor() ([]byte, []int) { return fileDescriptorRawccb, []int{1} }

func (m *RawcCbSpec) GetKeyOrHandle() *RawcCbKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

func (m *RawcCbSpec) GetPi() uint32 {
	if m != nil {
		return m.Pi
	}
	return 0
}

func (m *RawcCbSpec) GetCi() uint32 {
	if m != nil {
		return m.Ci
	}
	return 0
}

func (m *RawcCbSpec) GetRawccbFlags() uint32 {
	if m != nil {
		return m.RawccbFlags
	}
	return 0
}

func (m *RawcCbSpec) GetMyTxqBase() uint64 {
	if m != nil {
		return m.MyTxqBase
	}
	return 0
}

func (m *RawcCbSpec) GetMyTxqRingSizeShift() uint32 {
	if m != nil {
		return m.MyTxqRingSizeShift
	}
	return 0
}

func (m *RawcCbSpec) GetMyTxqEntrySizeShift() uint32 {
	if m != nil {
		return m.MyTxqEntrySizeShift
	}
	return 0
}

func (m *RawcCbSpec) GetChainTxqBase() uint64 {
	if m != nil {
		return m.ChainTxqBase
	}
	return 0
}

func (m *RawcCbSpec) GetChainTxqRingIndicesAddr() uint64 {
	if m != nil {
		return m.ChainTxqRingIndicesAddr
	}
	return 0
}

func (m *RawcCbSpec) GetChainTxqRingSizeShift() uint32 {
	if m != nil {
		return m.ChainTxqRingSizeShift
	}
	return 0
}

func (m *RawcCbSpec) GetChainTxqEntrySizeShift() uint32 {
	if m != nil {
		return m.ChainTxqEntrySizeShift
	}
	return 0
}

func (m *RawcCbSpec) GetChainTxqLif() uint32 {
	if m != nil {
		return m.ChainTxqLif
	}
	return 0
}

func (m *RawcCbSpec) GetChainTxqQtype() uint32 {
	if m != nil {
		return m.ChainTxqQtype
	}
	return 0
}

func (m *RawcCbSpec) GetChainTxqQid() uint32 {
	if m != nil {
		return m.ChainTxqQid
	}
	return 0
}

func (m *RawcCbSpec) GetChainTxqRing() uint32 {
	if m != nil {
		return m.ChainTxqRing
	}
	return 0
}

func (m *RawcCbSpec) GetStatPktsChain() uint64 {
	if m != nil {
		return m.StatPktsChain
	}
	return 0
}

func (m *RawcCbSpec) GetStatPktsDiscard() uint64 {
	if m != nil {
		return m.StatPktsDiscard
	}
	return 0
}

func (m *RawcCbSpec) GetStatCbNotReady() uint32 {
	if m != nil {
		return m.StatCbNotReady
	}
	return 0
}

func (m *RawcCbSpec) GetStatMyTxqEmpty() uint32 {
	if m != nil {
		return m.StatMyTxqEmpty
	}
	return 0
}

func (m *RawcCbSpec) GetStatAolErr() uint32 {
	if m != nil {
		return m.StatAolErr
	}
	return 0
}

func (m *RawcCbSpec) GetStatTxqFull() uint32 {
	if m != nil {
		return m.StatTxqFull
	}
	return 0
}

func (m *RawcCbSpec) GetStatDescSemFreeFull() uint32 {
	if m != nil {
		return m.StatDescSemFreeFull
	}
	return 0
}

func (m *RawcCbSpec) GetStatPageSemFreeFull() uint32 {
	if m != nil {
		return m.StatPageSemFreeFull
	}
	return 0
}

// RawcCbRequestMsg is batched add or modify rawccb request
type RawcCbRequestMsg struct {
	Request []*RawcCbSpec `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *RawcCbRequestMsg) Reset()                    { *m = RawcCbRequestMsg{} }
func (m *RawcCbRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*RawcCbRequestMsg) ProtoMessage()               {}
func (*RawcCbRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptorRawccb, []int{2} }

func (m *RawcCbRequestMsg) GetRequest() []*RawcCbSpec {
	if m != nil {
		return m.Request
	}
	return nil
}

// RawcCbStatus is the operational status of a given rawccb
type RawcCbStatus struct {
	RawccbHandle uint64 `protobuf:"fixed64,1,opt,name=rawccb_handle,json=rawccbHandle,proto3" json:"rawccb_handle,omitempty"`
}

func (m *RawcCbStatus) Reset()                    { *m = RawcCbStatus{} }
func (m *RawcCbStatus) String() string            { return proto.CompactTextString(m) }
func (*RawcCbStatus) ProtoMessage()               {}
func (*RawcCbStatus) Descriptor() ([]byte, []int) { return fileDescriptorRawccb, []int{3} }

func (m *RawcCbStatus) GetRawccbHandle() uint64 {
	if m != nil {
		return m.RawccbHandle
	}
	return 0
}

// RawcCbResponse is response to RawcCbSpec
type RawcCbResponse struct {
	ApiStatus    ApiStatus     `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty"`
	RawccbStatus *RawcCbStatus `protobuf:"bytes,2,opt,name=rawccb_status,json=rawccbStatus" json:"rawccb_status,omitempty"`
}

func (m *RawcCbResponse) Reset()                    { *m = RawcCbResponse{} }
func (m *RawcCbResponse) String() string            { return proto.CompactTextString(m) }
func (*RawcCbResponse) ProtoMessage()               {}
func (*RawcCbResponse) Descriptor() ([]byte, []int) { return fileDescriptorRawccb, []int{4} }

func (m *RawcCbResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *RawcCbResponse) GetRawccbStatus() *RawcCbStatus {
	if m != nil {
		return m.RawccbStatus
	}
	return nil
}

// RawcCbResponseMsg is batched response to RawcCbRequestMsg
type RawcCbResponseMsg struct {
	Response []*RawcCbResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *RawcCbResponseMsg) Reset()                    { *m = RawcCbResponseMsg{} }
func (m *RawcCbResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*RawcCbResponseMsg) ProtoMessage()               {}
func (*RawcCbResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptorRawccb, []int{5} }

func (m *RawcCbResponseMsg) GetResponse() []*RawcCbResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

// RawcCbDeleteRequest is used to delete a rawccb
type RawcCbDeleteRequest struct {
	KeyOrHandle *RawcCbKeyHandle `protobuf:"bytes,1,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty"`
}

func (m *RawcCbDeleteRequest) Reset()                    { *m = RawcCbDeleteRequest{} }
func (m *RawcCbDeleteRequest) String() string            { return proto.CompactTextString(m) }
func (*RawcCbDeleteRequest) ProtoMessage()               {}
func (*RawcCbDeleteRequest) Descriptor() ([]byte, []int) { return fileDescriptorRawccb, []int{6} }

func (m *RawcCbDeleteRequest) GetKeyOrHandle() *RawcCbKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

// RawcCbDeleteRequestMsg is used to delete a batch of rawccbs
type RawcCbDeleteRequestMsg struct {
	Request []*RawcCbDeleteRequest `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *RawcCbDeleteRequestMsg) Reset()                    { *m = RawcCbDeleteRequestMsg{} }
func (m *RawcCbDeleteRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*RawcCbDeleteRequestMsg) ProtoMessage()               {}
func (*RawcCbDeleteRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptorRawccb, []int{7} }

func (m *RawcCbDeleteRequestMsg) GetRequest() []*RawcCbDeleteRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

type RawcCbDeleteResponse struct {
	ApiStatus ApiStatus `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty"`
}

func (m *RawcCbDeleteResponse) Reset()                    { *m = RawcCbDeleteResponse{} }
func (m *RawcCbDeleteResponse) String() string            { return proto.CompactTextString(m) }
func (*RawcCbDeleteResponse) ProtoMessage()               {}
func (*RawcCbDeleteResponse) Descriptor() ([]byte, []int) { return fileDescriptorRawccb, []int{8} }

func (m *RawcCbDeleteResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

// RawcCbDeleteResponseMsg is batched response to RawcCbDeleteRequestMsg
type RawcCbDeleteResponseMsg struct {
	Response []*RawcCbDeleteResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *RawcCbDeleteResponseMsg) Reset()                    { *m = RawcCbDeleteResponseMsg{} }
func (m *RawcCbDeleteResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*RawcCbDeleteResponseMsg) ProtoMessage()               {}
func (*RawcCbDeleteResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptorRawccb, []int{9} }

func (m *RawcCbDeleteResponseMsg) GetResponse() []*RawcCbDeleteResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

// RawcCbGetRequest is used to get information about a rawccb
type RawcCbGetRequest struct {
	KeyOrHandle *RawcCbKeyHandle `protobuf:"bytes,1,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty"`
}

func (m *RawcCbGetRequest) Reset()                    { *m = RawcCbGetRequest{} }
func (m *RawcCbGetRequest) String() string            { return proto.CompactTextString(m) }
func (*RawcCbGetRequest) ProtoMessage()               {}
func (*RawcCbGetRequest) Descriptor() ([]byte, []int) { return fileDescriptorRawccb, []int{10} }

func (m *RawcCbGetRequest) GetKeyOrHandle() *RawcCbKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

// RawcCbGetRequestMsg is batched GET requests for rawccbs
type RawcCbGetRequestMsg struct {
	Request []*RawcCbGetRequest `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *RawcCbGetRequestMsg) Reset()                    { *m = RawcCbGetRequestMsg{} }
func (m *RawcCbGetRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*RawcCbGetRequestMsg) ProtoMessage()               {}
func (*RawcCbGetRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptorRawccb, []int{11} }

func (m *RawcCbGetRequestMsg) GetRequest() []*RawcCbGetRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

// RawcCbStats is the statistics object for each rawccb
type RawcCbStats struct {
}

func (m *RawcCbStats) Reset()                    { *m = RawcCbStats{} }
func (m *RawcCbStats) String() string            { return proto.CompactTextString(m) }
func (*RawcCbStats) ProtoMessage()               {}
func (*RawcCbStats) Descriptor() ([]byte, []int) { return fileDescriptorRawccb, []int{12} }

// RawcCbGetResponse captures all the information about a rawccb
// only if api_status indicates success, other fields are valid
type RawcCbGetResponse struct {
	ApiStatus ApiStatus     `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty"`
	Spec      *RawcCbSpec   `protobuf:"bytes,2,opt,name=spec" json:"spec,omitempty"`
	Status    *RawcCbStatus `protobuf:"bytes,3,opt,name=status" json:"status,omitempty"`
	Stats     *RawcCbStats  `protobuf:"bytes,4,opt,name=stats" json:"stats,omitempty"`
}

func (m *RawcCbGetResponse) Reset()                    { *m = RawcCbGetResponse{} }
func (m *RawcCbGetResponse) String() string            { return proto.CompactTextString(m) }
func (*RawcCbGetResponse) ProtoMessage()               {}
func (*RawcCbGetResponse) Descriptor() ([]byte, []int) { return fileDescriptorRawccb, []int{13} }

func (m *RawcCbGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *RawcCbGetResponse) GetSpec() *RawcCbSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *RawcCbGetResponse) GetStatus() *RawcCbStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *RawcCbGetResponse) GetStats() *RawcCbStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

// RawcCbGetResponseMsg is batched response to RawcCbGetRequestMsg
type RawcCbGetResponseMsg struct {
	Response []*RawcCbGetResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *RawcCbGetResponseMsg) Reset()                    { *m = RawcCbGetResponseMsg{} }
func (m *RawcCbGetResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*RawcCbGetResponseMsg) ProtoMessage()               {}
func (*RawcCbGetResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptorRawccb, []int{14} }

func (m *RawcCbGetResponseMsg) GetResponse() []*RawcCbGetResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

func init() {
	proto.RegisterType((*RawcCbKeyHandle)(nil), "rawccb.RawcCbKeyHandle")
	proto.RegisterType((*RawcCbSpec)(nil), "rawccb.RawcCbSpec")
	proto.RegisterType((*RawcCbRequestMsg)(nil), "rawccb.RawcCbRequestMsg")
	proto.RegisterType((*RawcCbStatus)(nil), "rawccb.RawcCbStatus")
	proto.RegisterType((*RawcCbResponse)(nil), "rawccb.RawcCbResponse")
	proto.RegisterType((*RawcCbResponseMsg)(nil), "rawccb.RawcCbResponseMsg")
	proto.RegisterType((*RawcCbDeleteRequest)(nil), "rawccb.RawcCbDeleteRequest")
	proto.RegisterType((*RawcCbDeleteRequestMsg)(nil), "rawccb.RawcCbDeleteRequestMsg")
	proto.RegisterType((*RawcCbDeleteResponse)(nil), "rawccb.RawcCbDeleteResponse")
	proto.RegisterType((*RawcCbDeleteResponseMsg)(nil), "rawccb.RawcCbDeleteResponseMsg")
	proto.RegisterType((*RawcCbGetRequest)(nil), "rawccb.RawcCbGetRequest")
	proto.RegisterType((*RawcCbGetRequestMsg)(nil), "rawccb.RawcCbGetRequestMsg")
	proto.RegisterType((*RawcCbStats)(nil), "rawccb.RawcCbStats")
	proto.RegisterType((*RawcCbGetResponse)(nil), "rawccb.RawcCbGetResponse")
	proto.RegisterType((*RawcCbGetResponseMsg)(nil), "rawccb.RawcCbGetResponseMsg")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for RawcCb service

type RawcCbClient interface {
	RawcCbCreate(ctx context.Context, in *RawcCbRequestMsg, opts ...grpc.CallOption) (*RawcCbResponseMsg, error)
	RawcCbUpdate(ctx context.Context, in *RawcCbRequestMsg, opts ...grpc.CallOption) (*RawcCbResponseMsg, error)
	RawcCbDelete(ctx context.Context, in *RawcCbDeleteRequestMsg, opts ...grpc.CallOption) (*RawcCbDeleteResponseMsg, error)
	RawcCbGet(ctx context.Context, in *RawcCbGetRequestMsg, opts ...grpc.CallOption) (*RawcCbGetResponseMsg, error)
}

type rawcCbClient struct {
	cc *grpc.ClientConn
}

func NewRawcCbClient(cc *grpc.ClientConn) RawcCbClient {
	return &rawcCbClient{cc}
}

func (c *rawcCbClient) RawcCbCreate(ctx context.Context, in *RawcCbRequestMsg, opts ...grpc.CallOption) (*RawcCbResponseMsg, error) {
	out := new(RawcCbResponseMsg)
	err := grpc.Invoke(ctx, "/rawccb.RawcCb/RawcCbCreate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rawcCbClient) RawcCbUpdate(ctx context.Context, in *RawcCbRequestMsg, opts ...grpc.CallOption) (*RawcCbResponseMsg, error) {
	out := new(RawcCbResponseMsg)
	err := grpc.Invoke(ctx, "/rawccb.RawcCb/RawcCbUpdate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rawcCbClient) RawcCbDelete(ctx context.Context, in *RawcCbDeleteRequestMsg, opts ...grpc.CallOption) (*RawcCbDeleteResponseMsg, error) {
	out := new(RawcCbDeleteResponseMsg)
	err := grpc.Invoke(ctx, "/rawccb.RawcCb/RawcCbDelete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rawcCbClient) RawcCbGet(ctx context.Context, in *RawcCbGetRequestMsg, opts ...grpc.CallOption) (*RawcCbGetResponseMsg, error) {
	out := new(RawcCbGetResponseMsg)
	err := grpc.Invoke(ctx, "/rawccb.RawcCb/RawcCbGet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for RawcCb service

type RawcCbServer interface {
	RawcCbCreate(context.Context, *RawcCbRequestMsg) (*RawcCbResponseMsg, error)
	RawcCbUpdate(context.Context, *RawcCbRequestMsg) (*RawcCbResponseMsg, error)
	RawcCbDelete(context.Context, *RawcCbDeleteRequestMsg) (*RawcCbDeleteResponseMsg, error)
	RawcCbGet(context.Context, *RawcCbGetRequestMsg) (*RawcCbGetResponseMsg, error)
}

func RegisterRawcCbServer(s *grpc.Server, srv RawcCbServer) {
	s.RegisterService(&_RawcCb_serviceDesc, srv)
}

func _RawcCb_RawcCbCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RawcCbRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RawcCbServer).RawcCbCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rawccb.RawcCb/RawcCbCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RawcCbServer).RawcCbCreate(ctx, req.(*RawcCbRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _RawcCb_RawcCbUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RawcCbRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RawcCbServer).RawcCbUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rawccb.RawcCb/RawcCbUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RawcCbServer).RawcCbUpdate(ctx, req.(*RawcCbRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _RawcCb_RawcCbDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RawcCbDeleteRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RawcCbServer).RawcCbDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rawccb.RawcCb/RawcCbDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RawcCbServer).RawcCbDelete(ctx, req.(*RawcCbDeleteRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _RawcCb_RawcCbGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RawcCbGetRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RawcCbServer).RawcCbGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rawccb.RawcCb/RawcCbGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RawcCbServer).RawcCbGet(ctx, req.(*RawcCbGetRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

var _RawcCb_serviceDesc = grpc.ServiceDesc{
	ServiceName: "rawccb.RawcCb",
	HandlerType: (*RawcCbServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RawcCbCreate",
			Handler:    _RawcCb_RawcCbCreate_Handler,
		},
		{
			MethodName: "RawcCbUpdate",
			Handler:    _RawcCb_RawcCbUpdate_Handler,
		},
		{
			MethodName: "RawcCbDelete",
			Handler:    _RawcCb_RawcCbDelete_Handler,
		},
		{
			MethodName: "RawcCbGet",
			Handler:    _RawcCb_RawcCbGet_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "rawccb.proto",
}

func (m *RawcCbKeyHandle) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RawcCbKeyHandle) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.KeyOrHandle != nil {
		nn1, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn1
	}
	return i, nil
}

func (m *RawcCbKeyHandle_RawccbId) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x8
	i++
	i = encodeVarintRawccb(dAtA, i, uint64(m.RawccbId))
	return i, nil
}
func (m *RawcCbKeyHandle_RawccbHandle) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x11
	i++
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.RawccbHandle))
	i += 8
	return i, nil
}
func (m *RawcCbSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RawcCbSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.KeyOrHandle != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRawccb(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n2, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.Pi != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRawccb(dAtA, i, uint64(m.Pi))
	}
	if m.Ci != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintRawccb(dAtA, i, uint64(m.Ci))
	}
	if m.RawccbFlags != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintRawccb(dAtA, i, uint64(m.RawccbFlags))
	}
	if m.MyTxqBase != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintRawccb(dAtA, i, uint64(m.MyTxqBase))
	}
	if m.MyTxqRingSizeShift != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintRawccb(dAtA, i, uint64(m.MyTxqRingSizeShift))
	}
	if m.MyTxqEntrySizeShift != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintRawccb(dAtA, i, uint64(m.MyTxqEntrySizeShift))
	}
	if m.ChainTxqBase != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintRawccb(dAtA, i, uint64(m.ChainTxqBase))
	}
	if m.ChainTxqRingIndicesAddr != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintRawccb(dAtA, i, uint64(m.ChainTxqRingIndicesAddr))
	}
	if m.ChainTxqRingSizeShift != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintRawccb(dAtA, i, uint64(m.ChainTxqRingSizeShift))
	}
	if m.ChainTxqEntrySizeShift != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintRawccb(dAtA, i, uint64(m.ChainTxqEntrySizeShift))
	}
	if m.ChainTxqLif != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintRawccb(dAtA, i, uint64(m.ChainTxqLif))
	}
	if m.ChainTxqQtype != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintRawccb(dAtA, i, uint64(m.ChainTxqQtype))
	}
	if m.ChainTxqQid != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintRawccb(dAtA, i, uint64(m.ChainTxqQid))
	}
	if m.ChainTxqRing != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintRawccb(dAtA, i, uint64(m.ChainTxqRing))
	}
	if m.StatPktsChain != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintRawccb(dAtA, i, uint64(m.StatPktsChain))
	}
	if m.StatPktsDiscard != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintRawccb(dAtA, i, uint64(m.StatPktsDiscard))
	}
	if m.StatCbNotReady != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintRawccb(dAtA, i, uint64(m.StatCbNotReady))
	}
	if m.StatMyTxqEmpty != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintRawccb(dAtA, i, uint64(m.StatMyTxqEmpty))
	}
	if m.StatAolErr != 0 {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintRawccb(dAtA, i, uint64(m.StatAolErr))
	}
	if m.StatTxqFull != 0 {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintRawccb(dAtA, i, uint64(m.StatTxqFull))
	}
	if m.StatDescSemFreeFull != 0 {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintRawccb(dAtA, i, uint64(m.StatDescSemFreeFull))
	}
	if m.StatPageSemFreeFull != 0 {
		dAtA[i] = 0xb8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintRawccb(dAtA, i, uint64(m.StatPageSemFreeFull))
	}
	return i, nil
}

func (m *RawcCbRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RawcCbRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintRawccb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *RawcCbStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RawcCbStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RawccbHandle != 0 {
		dAtA[i] = 0x9
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.RawccbHandle))
		i += 8
	}
	return i, nil
}

func (m *RawcCbResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RawcCbResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRawccb(dAtA, i, uint64(m.ApiStatus))
	}
	if m.RawccbStatus != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRawccb(dAtA, i, uint64(m.RawccbStatus.Size()))
		n3, err := m.RawccbStatus.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}

func (m *RawcCbResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RawcCbResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintRawccb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *RawcCbDeleteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RawcCbDeleteRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.KeyOrHandle != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRawccb(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n4, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	return i, nil
}

func (m *RawcCbDeleteRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RawcCbDeleteRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintRawccb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *RawcCbDeleteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RawcCbDeleteResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRawccb(dAtA, i, uint64(m.ApiStatus))
	}
	return i, nil
}

func (m *RawcCbDeleteResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RawcCbDeleteResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintRawccb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *RawcCbGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RawcCbGetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.KeyOrHandle != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRawccb(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n5, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	return i, nil
}

func (m *RawcCbGetRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RawcCbGetRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintRawccb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *RawcCbStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RawcCbStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *RawcCbGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RawcCbGetResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRawccb(dAtA, i, uint64(m.ApiStatus))
	}
	if m.Spec != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRawccb(dAtA, i, uint64(m.Spec.Size()))
		n6, err := m.Spec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.Status != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintRawccb(dAtA, i, uint64(m.Status.Size()))
		n7, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.Stats != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintRawccb(dAtA, i, uint64(m.Stats.Size()))
		n8, err := m.Stats.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	return i, nil
}

func (m *RawcCbGetResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RawcCbGetResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintRawccb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func encodeVarintRawccb(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *RawcCbKeyHandle) Size() (n int) {
	var l int
	_ = l
	if m.KeyOrHandle != nil {
		n += m.KeyOrHandle.Size()
	}
	return n
}

func (m *RawcCbKeyHandle_RawccbId) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovRawccb(uint64(m.RawccbId))
	return n
}
func (m *RawcCbKeyHandle_RawccbHandle) Size() (n int) {
	var l int
	_ = l
	n += 9
	return n
}
func (m *RawcCbSpec) Size() (n int) {
	var l int
	_ = l
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovRawccb(uint64(l))
	}
	if m.Pi != 0 {
		n += 1 + sovRawccb(uint64(m.Pi))
	}
	if m.Ci != 0 {
		n += 1 + sovRawccb(uint64(m.Ci))
	}
	if m.RawccbFlags != 0 {
		n += 1 + sovRawccb(uint64(m.RawccbFlags))
	}
	if m.MyTxqBase != 0 {
		n += 1 + sovRawccb(uint64(m.MyTxqBase))
	}
	if m.MyTxqRingSizeShift != 0 {
		n += 1 + sovRawccb(uint64(m.MyTxqRingSizeShift))
	}
	if m.MyTxqEntrySizeShift != 0 {
		n += 1 + sovRawccb(uint64(m.MyTxqEntrySizeShift))
	}
	if m.ChainTxqBase != 0 {
		n += 1 + sovRawccb(uint64(m.ChainTxqBase))
	}
	if m.ChainTxqRingIndicesAddr != 0 {
		n += 1 + sovRawccb(uint64(m.ChainTxqRingIndicesAddr))
	}
	if m.ChainTxqRingSizeShift != 0 {
		n += 1 + sovRawccb(uint64(m.ChainTxqRingSizeShift))
	}
	if m.ChainTxqEntrySizeShift != 0 {
		n += 1 + sovRawccb(uint64(m.ChainTxqEntrySizeShift))
	}
	if m.ChainTxqLif != 0 {
		n += 1 + sovRawccb(uint64(m.ChainTxqLif))
	}
	if m.ChainTxqQtype != 0 {
		n += 1 + sovRawccb(uint64(m.ChainTxqQtype))
	}
	if m.ChainTxqQid != 0 {
		n += 1 + sovRawccb(uint64(m.ChainTxqQid))
	}
	if m.ChainTxqRing != 0 {
		n += 1 + sovRawccb(uint64(m.ChainTxqRing))
	}
	if m.StatPktsChain != 0 {
		n += 2 + sovRawccb(uint64(m.StatPktsChain))
	}
	if m.StatPktsDiscard != 0 {
		n += 2 + sovRawccb(uint64(m.StatPktsDiscard))
	}
	if m.StatCbNotReady != 0 {
		n += 2 + sovRawccb(uint64(m.StatCbNotReady))
	}
	if m.StatMyTxqEmpty != 0 {
		n += 2 + sovRawccb(uint64(m.StatMyTxqEmpty))
	}
	if m.StatAolErr != 0 {
		n += 2 + sovRawccb(uint64(m.StatAolErr))
	}
	if m.StatTxqFull != 0 {
		n += 2 + sovRawccb(uint64(m.StatTxqFull))
	}
	if m.StatDescSemFreeFull != 0 {
		n += 2 + sovRawccb(uint64(m.StatDescSemFreeFull))
	}
	if m.StatPageSemFreeFull != 0 {
		n += 2 + sovRawccb(uint64(m.StatPageSemFreeFull))
	}
	return n
}

func (m *RawcCbRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovRawccb(uint64(l))
		}
	}
	return n
}

func (m *RawcCbStatus) Size() (n int) {
	var l int
	_ = l
	if m.RawccbHandle != 0 {
		n += 9
	}
	return n
}

func (m *RawcCbResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovRawccb(uint64(m.ApiStatus))
	}
	if m.RawccbStatus != nil {
		l = m.RawccbStatus.Size()
		n += 1 + l + sovRawccb(uint64(l))
	}
	return n
}

func (m *RawcCbResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovRawccb(uint64(l))
		}
	}
	return n
}

func (m *RawcCbDeleteRequest) Size() (n int) {
	var l int
	_ = l
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovRawccb(uint64(l))
	}
	return n
}

func (m *RawcCbDeleteRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovRawccb(uint64(l))
		}
	}
	return n
}

func (m *RawcCbDeleteResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovRawccb(uint64(m.ApiStatus))
	}
	return n
}

func (m *RawcCbDeleteResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovRawccb(uint64(l))
		}
	}
	return n
}

func (m *RawcCbGetRequest) Size() (n int) {
	var l int
	_ = l
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovRawccb(uint64(l))
	}
	return n
}

func (m *RawcCbGetRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovRawccb(uint64(l))
		}
	}
	return n
}

func (m *RawcCbStats) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *RawcCbGetResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovRawccb(uint64(m.ApiStatus))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovRawccb(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovRawccb(uint64(l))
	}
	if m.Stats != nil {
		l = m.Stats.Size()
		n += 1 + l + sovRawccb(uint64(l))
	}
	return n
}

func (m *RawcCbGetResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovRawccb(uint64(l))
		}
	}
	return n
}

func sovRawccb(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozRawccb(x uint64) (n int) {
	return sovRawccb(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *RawcCbKeyHandle) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRawccb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RawcCbKeyHandle: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RawcCbKeyHandle: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RawccbId", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRawccb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.KeyOrHandle = &RawcCbKeyHandle_RawccbId{v}
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field RawccbHandle", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.KeyOrHandle = &RawcCbKeyHandle_RawccbHandle{v}
		default:
			iNdEx = preIndex
			skippy, err := skipRawccb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRawccb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RawcCbSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRawccb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RawcCbSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RawcCbSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRawccb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRawccb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &RawcCbKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pi", wireType)
			}
			m.Pi = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRawccb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pi |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ci", wireType)
			}
			m.Ci = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRawccb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ci |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RawccbFlags", wireType)
			}
			m.RawccbFlags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRawccb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RawccbFlags |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MyTxqBase", wireType)
			}
			m.MyTxqBase = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRawccb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MyTxqBase |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MyTxqRingSizeShift", wireType)
			}
			m.MyTxqRingSizeShift = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRawccb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MyTxqRingSizeShift |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MyTxqEntrySizeShift", wireType)
			}
			m.MyTxqEntrySizeShift = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRawccb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MyTxqEntrySizeShift |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainTxqBase", wireType)
			}
			m.ChainTxqBase = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRawccb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChainTxqBase |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainTxqRingIndicesAddr", wireType)
			}
			m.ChainTxqRingIndicesAddr = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRawccb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChainTxqRingIndicesAddr |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainTxqRingSizeShift", wireType)
			}
			m.ChainTxqRingSizeShift = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRawccb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChainTxqRingSizeShift |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainTxqEntrySizeShift", wireType)
			}
			m.ChainTxqEntrySizeShift = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRawccb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChainTxqEntrySizeShift |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainTxqLif", wireType)
			}
			m.ChainTxqLif = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRawccb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChainTxqLif |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainTxqQtype", wireType)
			}
			m.ChainTxqQtype = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRawccb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChainTxqQtype |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainTxqQid", wireType)
			}
			m.ChainTxqQid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRawccb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChainTxqQid |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainTxqRing", wireType)
			}
			m.ChainTxqRing = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRawccb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChainTxqRing |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatPktsChain", wireType)
			}
			m.StatPktsChain = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRawccb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StatPktsChain |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatPktsDiscard", wireType)
			}
			m.StatPktsDiscard = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRawccb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StatPktsDiscard |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatCbNotReady", wireType)
			}
			m.StatCbNotReady = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRawccb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StatCbNotReady |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatMyTxqEmpty", wireType)
			}
			m.StatMyTxqEmpty = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRawccb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StatMyTxqEmpty |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatAolErr", wireType)
			}
			m.StatAolErr = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRawccb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StatAolErr |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatTxqFull", wireType)
			}
			m.StatTxqFull = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRawccb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StatTxqFull |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatDescSemFreeFull", wireType)
			}
			m.StatDescSemFreeFull = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRawccb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StatDescSemFreeFull |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatPageSemFreeFull", wireType)
			}
			m.StatPageSemFreeFull = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRawccb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StatPageSemFreeFull |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRawccb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRawccb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RawcCbRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRawccb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RawcCbRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RawcCbRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRawccb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRawccb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &RawcCbSpec{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRawccb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRawccb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RawcCbStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRawccb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RawcCbStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RawcCbStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field RawccbHandle", wireType)
			}
			m.RawccbHandle = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.RawccbHandle = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		default:
			iNdEx = preIndex
			skippy, err := skipRawccb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRawccb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RawcCbResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRawccb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RawcCbResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RawcCbResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRawccb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RawccbStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRawccb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRawccb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RawccbStatus == nil {
				m.RawccbStatus = &RawcCbStatus{}
			}
			if err := m.RawccbStatus.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRawccb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRawccb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RawcCbResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRawccb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RawcCbResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RawcCbResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRawccb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRawccb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &RawcCbResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRawccb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRawccb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RawcCbDeleteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRawccb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RawcCbDeleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RawcCbDeleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRawccb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRawccb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &RawcCbKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRawccb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRawccb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RawcCbDeleteRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRawccb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RawcCbDeleteRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RawcCbDeleteRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRawccb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRawccb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &RawcCbDeleteRequest{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRawccb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRawccb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RawcCbDeleteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRawccb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RawcCbDeleteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RawcCbDeleteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRawccb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRawccb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRawccb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RawcCbDeleteResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRawccb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RawcCbDeleteResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RawcCbDeleteResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRawccb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRawccb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &RawcCbDeleteResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRawccb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRawccb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RawcCbGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRawccb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RawcCbGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RawcCbGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRawccb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRawccb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &RawcCbKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRawccb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRawccb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RawcCbGetRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRawccb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RawcCbGetRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RawcCbGetRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRawccb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRawccb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &RawcCbGetRequest{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRawccb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRawccb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RawcCbStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRawccb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RawcCbStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RawcCbStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipRawccb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRawccb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RawcCbGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRawccb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RawcCbGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RawcCbGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRawccb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRawccb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRawccb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &RawcCbSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRawccb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRawccb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &RawcCbStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRawccb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRawccb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = &RawcCbStats{}
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRawccb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRawccb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RawcCbGetResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRawccb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RawcCbGetResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RawcCbGetResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRawccb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRawccb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &RawcCbGetResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRawccb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRawccb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipRawccb(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowRawccb
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRawccb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRawccb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthRawccb
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowRawccb
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipRawccb(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthRawccb = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowRawccb   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("rawccb.proto", fileDescriptorRawccb) }

var fileDescriptorRawccb = []byte{
	// 962 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x56, 0xdd, 0x6e, 0x1b, 0x37,
	0x13, 0xb5, 0x64, 0x47, 0xb6, 0x46, 0x7f, 0x36, 0xed, 0x48, 0xb4, 0x9d, 0x4f, 0x9f, 0xba, 0x6d,
	0x03, 0xa7, 0x08, 0x5c, 0x40, 0x69, 0x81, 0xf4, 0xe7, 0xa2, 0xfe, 0xb7, 0xd1, 0xba, 0x8e, 0x57,
	0xe9, 0xf5, 0x82, 0xda, 0xa5, 0x64, 0xc2, 0x2b, 0x69, 0x45, 0xd2, 0x88, 0x37, 0xe8, 0x5b, 0xf5,
	0x19, 0x0a, 0xf4, 0xb2, 0x8f, 0x50, 0xf8, 0x49, 0x0a, 0x92, 0x4b, 0xaf, 0x76, 0xad, 0xf8, 0x22,
	0xe9, 0xdd, 0x72, 0xe6, 0x9c, 0x33, 0xc3, 0xe1, 0x21, 0x25, 0xa8, 0x72, 0xf2, 0xce, 0xf7, 0xfb,
	0xbb, 0x11, 0x9f, 0xc8, 0x09, 0x2a, 0x99, 0xd5, 0x56, 0x45, 0xc6, 0x11, 0x15, 0x26, 0xe8, 0x5c,
	0x41, 0xc3, 0x25, 0xef, 0xfc, 0x83, 0xfe, 0xcf, 0x34, 0x3e, 0x25, 0xe3, 0x20, 0xa4, 0xe8, 0x7f,
	0x50, 0x36, 0x48, 0x8f, 0x05, 0xb8, 0xd0, 0x29, 0xec, 0xd4, 0x4e, 0x17, 0xdc, 0x15, 0x13, 0x3a,
	0x0b, 0xd0, 0x97, 0x50, 0x4b, 0xd2, 0x57, 0x1a, 0x8f, 0x8b, 0x9d, 0xc2, 0x4e, 0xe9, 0x74, 0xc1,
	0x4d, 0xaa, 0x19, 0x95, 0xfd, 0x06, 0xd4, 0xae, 0x69, 0xec, 0x4d, 0x78, 0x02, 0x73, 0xee, 0x96,
	0x01, 0x4c, 0xa9, 0x5e, 0x44, 0x7d, 0xf4, 0x43, 0x2e, 0xaf, 0x2b, 0x55, 0xba, 0xad, 0xdd, 0xa4,
	0xe7, 0x5c, 0x57, 0x6e, 0xe5, 0x9a, 0xc6, 0x17, 0x3c, 0x69, 0xb1, 0x0e, 0xc5, 0x88, 0xe9, 0xc2,
	0x35, 0xb7, 0x18, 0x31, 0xb5, 0xf6, 0x19, 0x5e, 0x34, 0x6b, 0x9f, 0xa1, 0xcf, 0xec, 0xd6, 0xbd,
	0x41, 0x48, 0x86, 0x02, 0x2f, 0xe9, 0x4c, 0xc5, 0xc4, 0x8e, 0x55, 0x08, 0xb5, 0xa1, 0x32, 0x8a,
	0x3d, 0x79, 0x3b, 0xf5, 0xfa, 0x44, 0x50, 0xfc, 0xa4, 0x53, 0xd8, 0x59, 0x72, 0xcb, 0xa3, 0xf8,
	0xed, 0xed, 0x74, 0x9f, 0x08, 0x8a, 0xba, 0xd0, 0x4c, 0xf2, 0x9c, 0x8d, 0x87, 0x9e, 0x60, 0xef,
	0xa9, 0x27, 0xae, 0xd8, 0x40, 0xe2, 0x92, 0x16, 0x43, 0x1a, 0xea, 0xb2, 0xf1, 0xb0, 0xc7, 0xde,
	0xd3, 0x9e, 0xca, 0xa0, 0x6f, 0xa0, 0x95, 0x70, 0xe8, 0x58, 0xf2, 0x78, 0x96, 0xb4, 0xac, 0x49,
	0xeb, 0x9a, 0x74, 0xa4, 0x92, 0x29, 0xeb, 0x0b, 0xa8, 0xfb, 0x57, 0x84, 0x8d, 0xd3, 0x66, 0x56,
	0x74, 0x33, 0x55, 0x1d, 0xb5, 0xfd, 0xfc, 0x08, 0xdb, 0x29, 0x4a, 0xb7, 0xc4, 0xc6, 0x01, 0xf3,
	0xa9, 0xf0, 0x48, 0x10, 0x70, 0x5c, 0xd6, 0x94, 0x96, 0xa5, 0xa8, 0xbe, 0xce, 0x4c, 0x7e, 0x2f,
	0x08, 0x38, 0x7a, 0x0d, 0x9b, 0x39, 0xf6, 0x4c, 0x6f, 0xa0, 0x7b, 0x7b, 0x3a, 0xcb, 0x4d, 0xbb,
	0xfb, 0x1e, 0xb6, 0x52, 0xe6, 0x83, 0x6d, 0x55, 0x34, 0xb5, 0x69, 0xa9, 0xb9, 0x9d, 0x39, 0x50,
	0x4b, 0xb9, 0x21, 0x1b, 0xe0, 0xaa, 0x39, 0x07, 0x0b, 0xff, 0x85, 0x0d, 0xd0, 0x73, 0x68, 0xa4,
	0x98, 0xa9, 0xb2, 0x26, 0xae, 0x69, 0x54, 0xcd, 0xa2, 0x2e, 0x55, 0x30, 0xab, 0x35, 0x65, 0x01,
	0xae, 0x67, 0xb5, 0x2e, 0x59, 0x90, 0x9d, 0xa4, 0xda, 0x25, 0x6e, 0x68, 0x50, 0x75, 0x76, 0x6b,
	0xaa, 0xa2, 0x90, 0x44, 0x7a, 0xd1, 0xb5, 0x14, 0x9e, 0xce, 0xe0, 0x55, 0x3d, 0xbd, 0x9a, 0x0a,
	0xbf, 0xb9, 0x96, 0xe2, 0x40, 0x05, 0xd1, 0x57, 0xb0, 0x96, 0xe2, 0x02, 0x26, 0x7c, 0xc2, 0x03,
	0xbc, 0xa6, 0x91, 0x0d, 0x8b, 0x3c, 0x34, 0x61, 0xf4, 0x22, 0xc1, 0xfa, 0x7d, 0x6f, 0x3c, 0x91,
	0x1e, 0xa7, 0x24, 0x88, 0x31, 0xd2, 0xc5, 0xeb, 0x2a, 0x71, 0xd0, 0xff, 0x75, 0x22, 0x5d, 0x15,
	0xbd, 0x87, 0x5a, 0xa7, 0x8c, 0x22, 0x19, 0xe3, 0xf5, 0x14, 0x7a, 0xae, 0x2d, 0xa2, 0xa2, 0xa8,
	0x03, 0x55, 0x0d, 0x25, 0x93, 0xd0, 0xa3, 0x9c, 0xe3, 0x0d, 0x8d, 0x02, 0x15, 0xdb, 0x9b, 0x84,
	0x47, 0x9c, 0xab, 0xa9, 0x68, 0x84, 0x52, 0x1a, 0xdc, 0x84, 0x21, 0x7e, 0x6a, 0xa6, 0xa2, 0x82,
	0x6f, 0x6f, 0xa7, 0xc7, 0x37, 0x61, 0xa8, 0x5c, 0xa9, 0x31, 0x01, 0x15, 0xbe, 0x27, 0xe8, 0xc8,
	0x1b, 0x70, 0x4a, 0x0d, 0xba, 0x69, 0x5c, 0xa9, 0xd2, 0x87, 0x54, 0xf8, 0x3d, 0x3a, 0x3a, 0xe6,
	0x94, 0x66, 0x58, 0x11, 0x19, 0xd2, 0x1c, 0xab, 0x95, 0xb2, 0xde, 0x90, 0x21, 0x9d, 0x61, 0x39,
	0x3f, 0xc1, 0xaa, 0xb9, 0xb8, 0x2e, 0x9d, 0xde, 0x50, 0x21, 0xcf, 0xc5, 0x10, 0xbd, 0x84, 0x65,
	0x6e, 0x56, 0xb8, 0xd0, 0x59, 0xdc, 0xa9, 0x74, 0x51, 0xf6, 0x8e, 0xab, 0xe7, 0xc0, 0xb5, 0x10,
	0xe7, 0x15, 0x54, 0x93, 0xb0, 0x24, 0xf2, 0x46, 0xa0, 0xcf, 0xf3, 0xcf, 0x8d, 0x7a, 0x27, 0x4a,
	0xd9, 0xc7, 0xc6, 0xf9, 0x1d, 0xea, 0xb6, 0xac, 0x88, 0x26, 0x63, 0x41, 0xd1, 0xd7, 0x00, 0x24,
	0x62, 0x9e, 0xd0, 0x22, 0x9a, 0x53, 0xef, 0xae, 0xee, 0x9a, 0x97, 0x6f, 0x2f, 0x62, 0x46, 0xdc,
	0x2d, 0x13, 0xfb, 0x89, 0xbe, 0xbb, 0xaf, 0x93, 0x70, 0x8a, 0xfa, 0x3d, 0xda, 0xc8, 0xf5, 0x6a,
	0x78, 0x49, 0x75, 0xb3, 0x72, 0x4e, 0x60, 0x2d, 0x5b, 0x5d, 0xed, 0xba, 0x0b, 0x2b, 0x3c, 0x59,
	0x26, 0xdb, 0x6e, 0x66, 0xa5, 0x2c, 0xd8, 0xbd, 0xc7, 0x39, 0x2e, 0xac, 0x9b, 0xdc, 0x21, 0x0d,
	0xa9, 0xa4, 0xc9, 0x0c, 0x3f, 0xe9, 0xa9, 0x74, 0x2e, 0xa0, 0x39, 0x47, 0x53, 0x75, 0xf8, 0x6d,
	0xfe, 0x5c, 0xb6, 0xb3, 0x82, 0x19, 0x42, 0x7a, 0x40, 0x27, 0xb0, 0x91, 0xcd, 0x7f, 0xe4, 0xc4,
	0x9d, 0x1e, 0xb4, 0xe6, 0x09, 0xa9, 0xd6, 0x5e, 0x3f, 0x18, 0xde, 0xb3, 0xf9, 0xbd, 0x3d, 0x18,
	0xe1, 0x85, 0x35, 0xe0, 0x09, 0x95, 0xff, 0xc9, 0xfc, 0xce, 0xec, 0x99, 0xa4, 0x82, 0xe6, 0x78,
	0x73, 0xc3, 0xc3, 0x59, 0xb5, 0x14, 0x9d, 0x4e, 0xae, 0x06, 0x95, 0xd4, 0x45, 0xc2, 0xf9, 0xb3,
	0x60, 0x7d, 0xa3, 0xc1, 0x1f, 0x6b, 0xdc, 0xe7, 0xb0, 0x24, 0x22, 0xea, 0x27, 0x7e, 0x9d, 0x77,
	0xb7, 0x74, 0x1e, 0xbd, 0x84, 0x52, 0x22, 0xba, 0xf8, 0x88, 0xb3, 0x13, 0x0c, 0x7a, 0x01, 0x4f,
	0xd4, 0x97, 0xf9, 0xe9, 0xac, 0x74, 0xd7, 0x1f, 0x82, 0x85, 0x6b, 0x10, 0xce, 0xb9, 0x35, 0xc4,
	0xcc, 0x36, 0x8c, 0xbf, 0xf2, 0x87, 0xb8, 0x39, 0x67, 0x46, 0xf9, 0x13, 0xec, 0xfe, 0x51, 0x84,
	0x92, 0xc9, 0xa3, 0x23, 0xfb, 0x16, 0x1c, 0x70, 0x4a, 0x24, 0x45, 0x38, 0x7f, 0x83, 0xec, 0x71,
	0x6c, 0x6d, 0xce, 0xbf, 0x5b, 0xe7, 0x62, 0xe8, 0x2c, 0xa4, 0x32, 0xbf, 0x45, 0xc1, 0x27, 0xc8,
	0x5c, 0x5a, 0x19, 0x63, 0x3e, 0xd4, 0x7e, 0xe4, 0xba, 0x28, 0xb1, 0xff, 0x3f, 0x66, 0x59, 0x23,
	0x79, 0x0a, 0xe5, 0xfb, 0x51, 0xa0, 0xed, 0x0f, 0x39, 0x48, 0x89, 0x3d, 0xfb, 0xe0, 0xe8, 0xb4,
	0xd2, 0x7e, 0xf5, 0xaf, 0xbb, 0x76, 0xe1, 0xef, 0xbb, 0x76, 0xe1, 0x9f, 0xbb, 0x76, 0xa1, 0x5f,
	0xd2, 0x7f, 0xee, 0x5e, 0xfd, 0x1b, 0x00, 0x00, 0xff, 0xff, 0x01, 0xeb, 0x71, 0xf4, 0x01, 0x0a,
	0x00, 0x00,
}
