// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: nwsec_1.proto

package halproto

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import encoding_binary "encoding/binary"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// predefined apps - default apps for which ALG functionality is invoked
type PredefinedApps int32

const (
	PredefinedApps_APP_NAME_NONE       PredefinedApps = 0
	PredefinedApps_APP_NAME_TFTP       PredefinedApps = 1
	PredefinedApps_APP_NAME_FTP        PredefinedApps = 2
	PredefinedApps_APP_NAME_SUNRPC_TCP PredefinedApps = 3
	PredefinedApps_APP_NAME_MSRPC      PredefinedApps = 4
	PredefinedApps_APP_NAME_DNS        PredefinedApps = 5
	PredefinedApps_APP_NAME_SIP        PredefinedApps = 6
	PredefinedApps_APP_NAME_RTSP       PredefinedApps = 7
	PredefinedApps_APP_NAME_TRACEROUTE PredefinedApps = 8
	PredefinedApps_APP_NAME_IP         PredefinedApps = 9
	PredefinedApps_APP_NAME_ANY        PredefinedApps = 10
)

var PredefinedApps_name = map[int32]string{
	0:  "APP_NAME_NONE",
	1:  "APP_NAME_TFTP",
	2:  "APP_NAME_FTP",
	3:  "APP_NAME_SUNRPC_TCP",
	4:  "APP_NAME_MSRPC",
	5:  "APP_NAME_DNS",
	6:  "APP_NAME_SIP",
	7:  "APP_NAME_RTSP",
	8:  "APP_NAME_TRACEROUTE",
	9:  "APP_NAME_IP",
	10: "APP_NAME_ANY",
}
var PredefinedApps_value = map[string]int32{
	"APP_NAME_NONE":       0,
	"APP_NAME_TFTP":       1,
	"APP_NAME_FTP":        2,
	"APP_NAME_SUNRPC_TCP": 3,
	"APP_NAME_MSRPC":      4,
	"APP_NAME_DNS":        5,
	"APP_NAME_SIP":        6,
	"APP_NAME_RTSP":       7,
	"APP_NAME_TRACEROUTE": 8,
	"APP_NAME_IP":         9,
	"APP_NAME_ANY":        10,
}

func (x PredefinedApps) String() string {
	return proto.EnumName(PredefinedApps_name, int32(x))
}
func (PredefinedApps) EnumDescriptor() ([]byte, []int) { return fileDescriptorNwsec_1, []int{0} }

// AppSec represents an application
type SecurityAction int32

const (
	SecurityAction_SECURITY_RULE_ACTION_NONE   SecurityAction = 0
	SecurityAction_SECURITY_RULE_ACTION_ALLOW  SecurityAction = 1
	SecurityAction_SECURITY_RULE_ACTION_DENY   SecurityAction = 2
	SecurityAction_SECURITY_RULE_ACTION_REJECT SecurityAction = 3
)

var SecurityAction_name = map[int32]string{
	0: "SECURITY_RULE_ACTION_NONE",
	1: "SECURITY_RULE_ACTION_ALLOW",
	2: "SECURITY_RULE_ACTION_DENY",
	3: "SECURITY_RULE_ACTION_REJECT",
}
var SecurityAction_value = map[string]int32{
	"SECURITY_RULE_ACTION_NONE":   0,
	"SECURITY_RULE_ACTION_ALLOW":  1,
	"SECURITY_RULE_ACTION_DENY":   2,
	"SECURITY_RULE_ACTION_REJECT": 3,
}

func (x SecurityAction) String() string {
	return proto.EnumName(SecurityAction_name, int32(x))
}
func (SecurityAction) EnumDescriptor() ([]byte, []int) { return fileDescriptorNwsec_1, []int{1} }

type LogAction int32

const (
	LogAction_LOG_NONE                     LogAction = 0
	LogAction_LOG_ON_SESSION_START         LogAction = 1
	LogAction_LOG_ON_SESSION_END           LogAction = 2
	LogAction_LOG_ON_SESSION_START_AND_END LogAction = 3
)

var LogAction_name = map[int32]string{
	0: "LOG_NONE",
	1: "LOG_ON_SESSION_START",
	2: "LOG_ON_SESSION_END",
	3: "LOG_ON_SESSION_START_AND_END",
}
var LogAction_value = map[string]int32{
	"LOG_NONE":                     0,
	"LOG_ON_SESSION_START":         1,
	"LOG_ON_SESSION_END":           2,
	"LOG_ON_SESSION_START_AND_END": 3,
}

func (x LogAction) String() string {
	return proto.EnumName(LogAction_name, int32(x))
}
func (LogAction) EnumDescriptor() ([]byte, []int) { return fileDescriptorNwsec_1, []int{2} }

type App_TraceLevel int32

const (
	App_TRACE_LEVEL_NONE      App_TraceLevel = 0
	App_TRACE_LEVEL_BRIEF     App_TraceLevel = 1
	App_TRACE_LEVEL_DETAIL    App_TraceLevel = 2
	App_TRACE_LEVEL_EXTENSIVE App_TraceLevel = 3
	App_TRACE_LEVEL_VERBOSE   App_TraceLevel = 4
)

var App_TraceLevel_name = map[int32]string{
	0: "TRACE_LEVEL_NONE",
	1: "TRACE_LEVEL_BRIEF",
	2: "TRACE_LEVEL_DETAIL",
	3: "TRACE_LEVEL_EXTENSIVE",
	4: "TRACE_LEVEL_VERBOSE",
}
var App_TraceLevel_value = map[string]int32{
	"TRACE_LEVEL_NONE":      0,
	"TRACE_LEVEL_BRIEF":     1,
	"TRACE_LEVEL_DETAIL":    2,
	"TRACE_LEVEL_EXTENSIVE": 3,
	"TRACE_LEVEL_VERBOSE":   4,
}

func (x App_TraceLevel) String() string {
	return proto.EnumName(App_TraceLevel_name, int32(x))
}
func (App_TraceLevel) EnumDescriptor() ([]byte, []int) { return fileDescriptorNwsec_1, []int{6, 0} }

// AddressSpec is the named prefix or range
type AddressSpec struct {
	// Types that are valid to be assigned to Address:
	//	*AddressSpec_Prefix
	//	*AddressSpec_Range
	Address isAddressSpec_Address `protobuf_oneof:"Address"`
}

func (m *AddressSpec) Reset()                    { *m = AddressSpec{} }
func (m *AddressSpec) String() string            { return proto.CompactTextString(m) }
func (*AddressSpec) ProtoMessage()               {}
func (*AddressSpec) Descriptor() ([]byte, []int) { return fileDescriptorNwsec_1, []int{0} }

type isAddressSpec_Address interface {
	isAddressSpec_Address()
	MarshalTo([]byte) (int, error)
	Size() int
}

type AddressSpec_Prefix struct {
	Prefix *IPSubnet `protobuf:"bytes,1,opt,name=prefix,oneof"`
}
type AddressSpec_Range struct {
	Range *AddressRange `protobuf:"bytes,2,opt,name=range,oneof"`
}

func (*AddressSpec_Prefix) isAddressSpec_Address() {}
func (*AddressSpec_Range) isAddressSpec_Address()  {}

func (m *AddressSpec) GetAddress() isAddressSpec_Address {
	if m != nil {
		return m.Address
	}
	return nil
}

func (m *AddressSpec) GetPrefix() *IPSubnet {
	if x, ok := m.GetAddress().(*AddressSpec_Prefix); ok {
		return x.Prefix
	}
	return nil
}

func (m *AddressSpec) GetRange() *AddressRange {
	if x, ok := m.GetAddress().(*AddressSpec_Range); ok {
		return x.Range
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*AddressSpec) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _AddressSpec_OneofMarshaler, _AddressSpec_OneofUnmarshaler, _AddressSpec_OneofSizer, []interface{}{
		(*AddressSpec_Prefix)(nil),
		(*AddressSpec_Range)(nil),
	}
}

func _AddressSpec_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*AddressSpec)
	// Address
	switch x := m.Address.(type) {
	case *AddressSpec_Prefix:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Prefix); err != nil {
			return err
		}
	case *AddressSpec_Range:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Range); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("AddressSpec.Address has unexpected type %T", x)
	}
	return nil
}

func _AddressSpec_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*AddressSpec)
	switch tag {
	case 1: // Address.prefix
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(IPSubnet)
		err := b.DecodeMessage(msg)
		m.Address = &AddressSpec_Prefix{msg}
		return true, err
	case 2: // Address.range
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(AddressRange)
		err := b.DecodeMessage(msg)
		m.Address = &AddressSpec_Range{msg}
		return true, err
	default:
		return false, nil
	}
}

func _AddressSpec_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*AddressSpec)
	// Address
	switch x := m.Address.(type) {
	case *AddressSpec_Prefix:
		s := proto.Size(x.Prefix)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *AddressSpec_Range:
		s := proto.Size(x.Range)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type AddressStatus struct {
}

func (m *AddressStatus) Reset()                    { *m = AddressStatus{} }
func (m *AddressStatus) String() string            { return proto.CompactTextString(m) }
func (*AddressStatus) ProtoMessage()               {}
func (*AddressStatus) Descriptor() ([]byte, []int) { return fileDescriptorNwsec_1, []int{1} }

type AddressGroupSpec struct {
	Address []*Address `protobuf:"bytes,1,rep,name=address" json:"address,omitempty"`
}

func (m *AddressGroupSpec) Reset()                    { *m = AddressGroupSpec{} }
func (m *AddressGroupSpec) String() string            { return proto.CompactTextString(m) }
func (*AddressGroupSpec) ProtoMessage()               {}
func (*AddressGroupSpec) Descriptor() ([]byte, []int) { return fileDescriptorNwsec_1, []int{2} }

func (m *AddressGroupSpec) GetAddress() []*Address {
	if m != nil {
		return m.Address
	}
	return nil
}

type AddressGroupStatus struct {
}

func (m *AddressGroupStatus) Reset()                    { *m = AddressGroupStatus{} }
func (m *AddressGroupStatus) String() string            { return proto.CompactTextString(m) }
func (*AddressGroupStatus) ProtoMessage()               {}
func (*AddressGroupStatus) Descriptor() ([]byte, []int) { return fileDescriptorNwsec_1, []int{3} }

type AddressGroup struct {
	Meta   *ObjectMeta         `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	Spec   *AddressGroupSpec   `protobuf:"bytes,2,opt,name=spec" json:"spec,omitempty"`
	Status *AddressGroupStatus `protobuf:"bytes,3,opt,name=status" json:"status,omitempty"`
}

func (m *AddressGroup) Reset()                    { *m = AddressGroup{} }
func (m *AddressGroup) String() string            { return proto.CompactTextString(m) }
func (*AddressGroup) ProtoMessage()               {}
func (*AddressGroup) Descriptor() ([]byte, []int) { return fileDescriptorNwsec_1, []int{4} }

func (m *AddressGroup) GetMeta() *ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *AddressGroup) GetSpec() *AddressGroupSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *AddressGroup) GetStatus() *AddressGroupStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

type IPAddressSpec struct {
	// Types that are valid to be assigned to Formats:
	//	*IPAddressSpec_Type
	//	*IPAddressSpec_Prefix
	//	*IPAddressSpec_Range
	//	*IPAddressSpec_Address
	//	*IPAddressSpec_AddrGrp
	Formats isIPAddressSpec_Formats `protobuf_oneof:"Formats"`
	Negate  bool                    `protobuf:"varint,6,opt,name=negate,proto3" json:"negate,omitempty"`
}

func (m *IPAddressSpec) Reset()                    { *m = IPAddressSpec{} }
func (m *IPAddressSpec) String() string            { return proto.CompactTextString(m) }
func (*IPAddressSpec) ProtoMessage()               {}
func (*IPAddressSpec) Descriptor() ([]byte, []int) { return fileDescriptorNwsec_1, []int{5} }

type isIPAddressSpec_Formats interface {
	isIPAddressSpec_Formats()
	MarshalTo([]byte) (int, error)
	Size() int
}

type IPAddressSpec_Type struct {
	Type IPAddressType `protobuf:"varint,1,opt,name=type,proto3,enum=types.IPAddressType,oneof"`
}
type IPAddressSpec_Prefix struct {
	Prefix *IPSubnet `protobuf:"bytes,2,opt,name=prefix,oneof"`
}
type IPAddressSpec_Range struct {
	Range *AddressRange `protobuf:"bytes,3,opt,name=range,oneof"`
}
type IPAddressSpec_Address struct {
	Address *Address `protobuf:"bytes,4,opt,name=address,oneof"`
}
type IPAddressSpec_AddrGrp struct {
	AddrGrp *AddressGroup `protobuf:"bytes,5,opt,name=addr_grp,json=addrGrp,oneof"`
}

func (*IPAddressSpec_Type) isIPAddressSpec_Formats()    {}
func (*IPAddressSpec_Prefix) isIPAddressSpec_Formats()  {}
func (*IPAddressSpec_Range) isIPAddressSpec_Formats()   {}
func (*IPAddressSpec_Address) isIPAddressSpec_Formats() {}
func (*IPAddressSpec_AddrGrp) isIPAddressSpec_Formats() {}

func (m *IPAddressSpec) GetFormats() isIPAddressSpec_Formats {
	if m != nil {
		return m.Formats
	}
	return nil
}

func (m *IPAddressSpec) GetType() IPAddressType {
	if x, ok := m.GetFormats().(*IPAddressSpec_Type); ok {
		return x.Type
	}
	return IPAddressType_IP_ADDRESS_NONE
}

func (m *IPAddressSpec) GetPrefix() *IPSubnet {
	if x, ok := m.GetFormats().(*IPAddressSpec_Prefix); ok {
		return x.Prefix
	}
	return nil
}

func (m *IPAddressSpec) GetRange() *AddressRange {
	if x, ok := m.GetFormats().(*IPAddressSpec_Range); ok {
		return x.Range
	}
	return nil
}

func (m *IPAddressSpec) GetAddress() *Address {
	if x, ok := m.GetFormats().(*IPAddressSpec_Address); ok {
		return x.Address
	}
	return nil
}

func (m *IPAddressSpec) GetAddrGrp() *AddressGroup {
	if x, ok := m.GetFormats().(*IPAddressSpec_AddrGrp); ok {
		return x.AddrGrp
	}
	return nil
}

func (m *IPAddressSpec) GetNegate() bool {
	if m != nil {
		return m.Negate
	}
	return false
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*IPAddressSpec) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _IPAddressSpec_OneofMarshaler, _IPAddressSpec_OneofUnmarshaler, _IPAddressSpec_OneofSizer, []interface{}{
		(*IPAddressSpec_Type)(nil),
		(*IPAddressSpec_Prefix)(nil),
		(*IPAddressSpec_Range)(nil),
		(*IPAddressSpec_Address)(nil),
		(*IPAddressSpec_AddrGrp)(nil),
	}
}

func _IPAddressSpec_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*IPAddressSpec)
	// Formats
	switch x := m.Formats.(type) {
	case *IPAddressSpec_Type:
		_ = b.EncodeVarint(1<<3 | proto.WireVarint)
		_ = b.EncodeVarint(uint64(x.Type))
	case *IPAddressSpec_Prefix:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Prefix); err != nil {
			return err
		}
	case *IPAddressSpec_Range:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Range); err != nil {
			return err
		}
	case *IPAddressSpec_Address:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Address); err != nil {
			return err
		}
	case *IPAddressSpec_AddrGrp:
		_ = b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.AddrGrp); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("IPAddressSpec.Formats has unexpected type %T", x)
	}
	return nil
}

func _IPAddressSpec_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*IPAddressSpec)
	switch tag {
	case 1: // Formats.type
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Formats = &IPAddressSpec_Type{IPAddressType(x)}
		return true, err
	case 2: // Formats.prefix
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(IPSubnet)
		err := b.DecodeMessage(msg)
		m.Formats = &IPAddressSpec_Prefix{msg}
		return true, err
	case 3: // Formats.range
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(AddressRange)
		err := b.DecodeMessage(msg)
		m.Formats = &IPAddressSpec_Range{msg}
		return true, err
	case 4: // Formats.address
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Address)
		err := b.DecodeMessage(msg)
		m.Formats = &IPAddressSpec_Address{msg}
		return true, err
	case 5: // Formats.addr_grp
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(AddressGroup)
		err := b.DecodeMessage(msg)
		m.Formats = &IPAddressSpec_AddrGrp{msg}
		return true, err
	default:
		return false, nil
	}
}

func _IPAddressSpec_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*IPAddressSpec)
	// Formats
	switch x := m.Formats.(type) {
	case *IPAddressSpec_Type:
		n += proto.SizeVarint(1<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.Type))
	case *IPAddressSpec_Prefix:
		s := proto.Size(x.Prefix)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *IPAddressSpec_Range:
		s := proto.Size(x.Range)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *IPAddressSpec_Address:
		s := proto.Size(x.Address)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *IPAddressSpec_AddrGrp:
		s := proto.Size(x.AddrGrp)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// App - represents an application defined by (Protocol, port) combination
// along with all applicable parameters
type App struct {
	Protocol IPProtocol `protobuf:"varint,1,opt,name=protocol,proto3,enum=types.IPProtocol" json:"protocol,omitempty"`
	// Types that are valid to be assigned to L4AppInfo:
	//	*App_PortInfo
	//	*App_IcmpInfo
	//	*App_Icmpv6Info
	//	*App_RpcInfo
	//	*App_MsrpcCinfo
	L4AppInfo isApp_L4AppInfo `protobuf_oneof:"L4AppInfo"`
	Alg       PredefinedApps  `protobuf:"varint,7,opt,name=alg,proto3,enum=nwsec.PredefinedApps" json:"alg,omitempty"`
	// Types that are valid to be assigned to AppOptions:
	//	*App_FtpOptionInfo
	//	*App_DnsOptionInfo
	//	*App_MsrpCoptionInfo
	//	*App_SunRpcPptionInfo
	//	*App_SipOptions
	AppOptions  isApp_AppOptions  `protobuf_oneof:"AppOptions"`
	IdleTimeout uint32            `protobuf:"varint,13,opt,name=idle_timeout,json=idleTimeout,proto3" json:"idle_timeout,omitempty"`
	TraceOpts   *App_TraceOptions `protobuf:"bytes,14,opt,name=trace_opts,json=traceOpts" json:"trace_opts,omitempty"`
}

func (m *App) Reset()                    { *m = App{} }
func (m *App) String() string            { return proto.CompactTextString(m) }
func (*App) ProtoMessage()               {}
func (*App) Descriptor() ([]byte, []int) { return fileDescriptorNwsec_1, []int{6} }

type isApp_L4AppInfo interface {
	isApp_L4AppInfo()
	MarshalTo([]byte) (int, error)
	Size() int
}
type isApp_AppOptions interface {
	isApp_AppOptions()
	MarshalTo([]byte) (int, error)
	Size() int
}

type App_PortInfo struct {
	PortInfo *App_AppPortInfo `protobuf:"bytes,2,opt,name=port_info,json=portInfo,oneof"`
}
type App_IcmpInfo struct {
	IcmpInfo *App_ICMPAppInfo `protobuf:"bytes,3,opt,name=icmp_info,json=icmpInfo,oneof"`
}
type App_Icmpv6Info struct {
	Icmpv6Info *App_ICMPv6AppInfo `protobuf:"bytes,4,opt,name=icmpv6_info,json=icmpv6Info,oneof"`
}
type App_RpcInfo struct {
	RpcInfo *App_RPCAppInfo `protobuf:"bytes,5,opt,name=rpc_info,json=rpcInfo,oneof"`
}
type App_MsrpcCinfo struct {
	MsrpcCinfo *App_MSRPCAppInfo `protobuf:"bytes,6,opt,name=msrpc_cinfo,json=msrpcCinfo,oneof"`
}
type App_FtpOptionInfo struct {
	FtpOptionInfo *App_FTPOptions `protobuf:"bytes,8,opt,name=ftp_option_info,json=ftpOptionInfo,oneof"`
}
type App_DnsOptionInfo struct {
	DnsOptionInfo *App_DNSOptions `protobuf:"bytes,9,opt,name=dns_option_info,json=dnsOptionInfo,oneof"`
}
type App_MsrpCoptionInfo struct {
	MsrpCoptionInfo *App_MSRPCOptions `protobuf:"bytes,10,opt,name=msrp_coption_info,json=msrpCoptionInfo,oneof"`
}
type App_SunRpcPptionInfo struct {
	SunRpcPptionInfo *App_SunRPCOptions `protobuf:"bytes,11,opt,name=sun_rpc_pption_info,json=sunRpcPptionInfo,oneof"`
}
type App_SipOptions struct {
	SipOptions *App_SIPOptions `protobuf:"bytes,12,opt,name=sip_options,json=sipOptions,oneof"`
}

func (*App_PortInfo) isApp_L4AppInfo()          {}
func (*App_IcmpInfo) isApp_L4AppInfo()          {}
func (*App_Icmpv6Info) isApp_L4AppInfo()        {}
func (*App_RpcInfo) isApp_L4AppInfo()           {}
func (*App_MsrpcCinfo) isApp_L4AppInfo()        {}
func (*App_FtpOptionInfo) isApp_AppOptions()    {}
func (*App_DnsOptionInfo) isApp_AppOptions()    {}
func (*App_MsrpCoptionInfo) isApp_AppOptions()  {}
func (*App_SunRpcPptionInfo) isApp_AppOptions() {}
func (*App_SipOptions) isApp_AppOptions()       {}

func (m *App) GetL4AppInfo() isApp_L4AppInfo {
	if m != nil {
		return m.L4AppInfo
	}
	return nil
}
func (m *App) GetAppOptions() isApp_AppOptions {
	if m != nil {
		return m.AppOptions
	}
	return nil
}

func (m *App) GetProtocol() IPProtocol {
	if m != nil {
		return m.Protocol
	}
	return IPProtocol_IPPROTO_NONE
}

func (m *App) GetPortInfo() *App_AppPortInfo {
	if x, ok := m.GetL4AppInfo().(*App_PortInfo); ok {
		return x.PortInfo
	}
	return nil
}

func (m *App) GetIcmpInfo() *App_ICMPAppInfo {
	if x, ok := m.GetL4AppInfo().(*App_IcmpInfo); ok {
		return x.IcmpInfo
	}
	return nil
}

func (m *App) GetIcmpv6Info() *App_ICMPv6AppInfo {
	if x, ok := m.GetL4AppInfo().(*App_Icmpv6Info); ok {
		return x.Icmpv6Info
	}
	return nil
}

func (m *App) GetRpcInfo() *App_RPCAppInfo {
	if x, ok := m.GetL4AppInfo().(*App_RpcInfo); ok {
		return x.RpcInfo
	}
	return nil
}

func (m *App) GetMsrpcCinfo() *App_MSRPCAppInfo {
	if x, ok := m.GetL4AppInfo().(*App_MsrpcCinfo); ok {
		return x.MsrpcCinfo
	}
	return nil
}

func (m *App) GetAlg() PredefinedApps {
	if m != nil {
		return m.Alg
	}
	return PredefinedApps_APP_NAME_NONE
}

func (m *App) GetFtpOptionInfo() *App_FTPOptions {
	if x, ok := m.GetAppOptions().(*App_FtpOptionInfo); ok {
		return x.FtpOptionInfo
	}
	return nil
}

func (m *App) GetDnsOptionInfo() *App_DNSOptions {
	if x, ok := m.GetAppOptions().(*App_DnsOptionInfo); ok {
		return x.DnsOptionInfo
	}
	return nil
}

func (m *App) GetMsrpCoptionInfo() *App_MSRPCOptions {
	if x, ok := m.GetAppOptions().(*App_MsrpCoptionInfo); ok {
		return x.MsrpCoptionInfo
	}
	return nil
}

func (m *App) GetSunRpcPptionInfo() *App_SunRPCOptions {
	if x, ok := m.GetAppOptions().(*App_SunRpcPptionInfo); ok {
		return x.SunRpcPptionInfo
	}
	return nil
}

func (m *App) GetSipOptions() *App_SIPOptions {
	if x, ok := m.GetAppOptions().(*App_SipOptions); ok {
		return x.SipOptions
	}
	return nil
}

func (m *App) GetIdleTimeout() uint32 {
	if m != nil {
		return m.IdleTimeout
	}
	return 0
}

func (m *App) GetTraceOpts() *App_TraceOptions {
	if m != nil {
		return m.TraceOpts
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*App) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _App_OneofMarshaler, _App_OneofUnmarshaler, _App_OneofSizer, []interface{}{
		(*App_PortInfo)(nil),
		(*App_IcmpInfo)(nil),
		(*App_Icmpv6Info)(nil),
		(*App_RpcInfo)(nil),
		(*App_MsrpcCinfo)(nil),
		(*App_FtpOptionInfo)(nil),
		(*App_DnsOptionInfo)(nil),
		(*App_MsrpCoptionInfo)(nil),
		(*App_SunRpcPptionInfo)(nil),
		(*App_SipOptions)(nil),
	}
}

func _App_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*App)
	// L4AppInfo
	switch x := m.L4AppInfo.(type) {
	case *App_PortInfo:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.PortInfo); err != nil {
			return err
		}
	case *App_IcmpInfo:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.IcmpInfo); err != nil {
			return err
		}
	case *App_Icmpv6Info:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Icmpv6Info); err != nil {
			return err
		}
	case *App_RpcInfo:
		_ = b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.RpcInfo); err != nil {
			return err
		}
	case *App_MsrpcCinfo:
		_ = b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.MsrpcCinfo); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("App.L4AppInfo has unexpected type %T", x)
	}
	// AppOptions
	switch x := m.AppOptions.(type) {
	case *App_FtpOptionInfo:
		_ = b.EncodeVarint(8<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.FtpOptionInfo); err != nil {
			return err
		}
	case *App_DnsOptionInfo:
		_ = b.EncodeVarint(9<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DnsOptionInfo); err != nil {
			return err
		}
	case *App_MsrpCoptionInfo:
		_ = b.EncodeVarint(10<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.MsrpCoptionInfo); err != nil {
			return err
		}
	case *App_SunRpcPptionInfo:
		_ = b.EncodeVarint(11<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.SunRpcPptionInfo); err != nil {
			return err
		}
	case *App_SipOptions:
		_ = b.EncodeVarint(12<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.SipOptions); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("App.AppOptions has unexpected type %T", x)
	}
	return nil
}

func _App_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*App)
	switch tag {
	case 2: // L4AppInfo.port_info
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(App_AppPortInfo)
		err := b.DecodeMessage(msg)
		m.L4AppInfo = &App_PortInfo{msg}
		return true, err
	case 3: // L4AppInfo.icmp_info
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(App_ICMPAppInfo)
		err := b.DecodeMessage(msg)
		m.L4AppInfo = &App_IcmpInfo{msg}
		return true, err
	case 4: // L4AppInfo.icmpv6_info
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(App_ICMPv6AppInfo)
		err := b.DecodeMessage(msg)
		m.L4AppInfo = &App_Icmpv6Info{msg}
		return true, err
	case 5: // L4AppInfo.rpc_info
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(App_RPCAppInfo)
		err := b.DecodeMessage(msg)
		m.L4AppInfo = &App_RpcInfo{msg}
		return true, err
	case 6: // L4AppInfo.msrpc_cinfo
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(App_MSRPCAppInfo)
		err := b.DecodeMessage(msg)
		m.L4AppInfo = &App_MsrpcCinfo{msg}
		return true, err
	case 8: // AppOptions.ftp_option_info
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(App_FTPOptions)
		err := b.DecodeMessage(msg)
		m.AppOptions = &App_FtpOptionInfo{msg}
		return true, err
	case 9: // AppOptions.dns_option_info
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(App_DNSOptions)
		err := b.DecodeMessage(msg)
		m.AppOptions = &App_DnsOptionInfo{msg}
		return true, err
	case 10: // AppOptions.msrp_coption_info
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(App_MSRPCOptions)
		err := b.DecodeMessage(msg)
		m.AppOptions = &App_MsrpCoptionInfo{msg}
		return true, err
	case 11: // AppOptions.sun_rpc_pption_info
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(App_SunRPCOptions)
		err := b.DecodeMessage(msg)
		m.AppOptions = &App_SunRpcPptionInfo{msg}
		return true, err
	case 12: // AppOptions.sip_options
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(App_SIPOptions)
		err := b.DecodeMessage(msg)
		m.AppOptions = &App_SipOptions{msg}
		return true, err
	default:
		return false, nil
	}
}

func _App_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*App)
	// L4AppInfo
	switch x := m.L4AppInfo.(type) {
	case *App_PortInfo:
		s := proto.Size(x.PortInfo)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *App_IcmpInfo:
		s := proto.Size(x.IcmpInfo)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *App_Icmpv6Info:
		s := proto.Size(x.Icmpv6Info)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *App_RpcInfo:
		s := proto.Size(x.RpcInfo)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *App_MsrpcCinfo:
		s := proto.Size(x.MsrpcCinfo)
		n += proto.SizeVarint(6<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// AppOptions
	switch x := m.AppOptions.(type) {
	case *App_FtpOptionInfo:
		s := proto.Size(x.FtpOptionInfo)
		n += proto.SizeVarint(8<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *App_DnsOptionInfo:
		s := proto.Size(x.DnsOptionInfo)
		n += proto.SizeVarint(9<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *App_MsrpCoptionInfo:
		s := proto.Size(x.MsrpCoptionInfo)
		n += proto.SizeVarint(10<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *App_SunRpcPptionInfo:
		s := proto.Size(x.SunRpcPptionInfo)
		n += proto.SizeVarint(11<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *App_SipOptions:
		s := proto.Size(x.SipOptions)
		n += proto.SizeVarint(12<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type App_AppPortInfo struct {
	DstPortRange []*L4PortRange `protobuf:"bytes,1,rep,name=dst_port_range,json=dstPortRange" json:"dst_port_range,omitempty"`
	SrcPortRange []*L4PortRange `protobuf:"bytes,2,rep,name=src_port_range,json=srcPortRange" json:"src_port_range,omitempty"`
}

func (m *App_AppPortInfo) Reset()                    { *m = App_AppPortInfo{} }
func (m *App_AppPortInfo) String() string            { return proto.CompactTextString(m) }
func (*App_AppPortInfo) ProtoMessage()               {}
func (*App_AppPortInfo) Descriptor() ([]byte, []int) { return fileDescriptorNwsec_1, []int{6, 0} }

func (m *App_AppPortInfo) GetDstPortRange() []*L4PortRange {
	if m != nil {
		return m.DstPortRange
	}
	return nil
}

func (m *App_AppPortInfo) GetSrcPortRange() []*L4PortRange {
	if m != nil {
		return m.SrcPortRange
	}
	return nil
}

type App_ICMPAppInfo struct {
	IcmpType uint32 `protobuf:"varint,1,opt,name=icmp_type,json=icmpType,proto3" json:"icmp_type,omitempty"`
	IcmpCode uint32 `protobuf:"varint,2,opt,name=icmp_code,json=icmpCode,proto3" json:"icmp_code,omitempty"`
}

func (m *App_ICMPAppInfo) Reset()                    { *m = App_ICMPAppInfo{} }
func (m *App_ICMPAppInfo) String() string            { return proto.CompactTextString(m) }
func (*App_ICMPAppInfo) ProtoMessage()               {}
func (*App_ICMPAppInfo) Descriptor() ([]byte, []int) { return fileDescriptorNwsec_1, []int{6, 1} }

func (m *App_ICMPAppInfo) GetIcmpType() uint32 {
	if m != nil {
		return m.IcmpType
	}
	return 0
}

func (m *App_ICMPAppInfo) GetIcmpCode() uint32 {
	if m != nil {
		return m.IcmpCode
	}
	return 0
}

type App_ICMPv6AppInfo struct {
	Icmpv6Type uint32 `protobuf:"varint,1,opt,name=icmpv6_type,json=icmpv6Type,proto3" json:"icmpv6_type,omitempty"`
	Icmpv6Code uint32 `protobuf:"varint,2,opt,name=icmpv6_code,json=icmpv6Code,proto3" json:"icmpv6_code,omitempty"`
}

func (m *App_ICMPv6AppInfo) Reset()                    { *m = App_ICMPv6AppInfo{} }
func (m *App_ICMPv6AppInfo) String() string            { return proto.CompactTextString(m) }
func (*App_ICMPv6AppInfo) ProtoMessage()               {}
func (*App_ICMPv6AppInfo) Descriptor() ([]byte, []int) { return fileDescriptorNwsec_1, []int{6, 2} }

func (m *App_ICMPv6AppInfo) GetIcmpv6Type() uint32 {
	if m != nil {
		return m.Icmpv6Type
	}
	return 0
}

func (m *App_ICMPv6AppInfo) GetIcmpv6Code() uint32 {
	if m != nil {
		return m.Icmpv6Code
	}
	return 0
}

type App_RPCAppInfo struct {
	ProgramNumber uint32 `protobuf:"varint,1,opt,name=program_number,json=programNumber,proto3" json:"program_number,omitempty"`
}

func (m *App_RPCAppInfo) Reset()                    { *m = App_RPCAppInfo{} }
func (m *App_RPCAppInfo) String() string            { return proto.CompactTextString(m) }
func (*App_RPCAppInfo) ProtoMessage()               {}
func (*App_RPCAppInfo) Descriptor() ([]byte, []int) { return fileDescriptorNwsec_1, []int{6, 3} }

func (m *App_RPCAppInfo) GetProgramNumber() uint32 {
	if m != nil {
		return m.ProgramNumber
	}
	return 0
}

type App_MSRPCAppInfo struct {
	Uuid uint32 `protobuf:"varint,1,opt,name=uuid,proto3" json:"uuid,omitempty"`
}

func (m *App_MSRPCAppInfo) Reset()                    { *m = App_MSRPCAppInfo{} }
func (m *App_MSRPCAppInfo) String() string            { return proto.CompactTextString(m) }
func (*App_MSRPCAppInfo) ProtoMessage()               {}
func (*App_MSRPCAppInfo) Descriptor() ([]byte, []int) { return fileDescriptorNwsec_1, []int{6, 4} }

func (m *App_MSRPCAppInfo) GetUuid() uint32 {
	if m != nil {
		return m.Uuid
	}
	return 0
}

type App_TraceOptions struct {
	Level App_TraceLevel `protobuf:"varint,1,opt,name=level,proto3,enum=nwsec.App_TraceLevel" json:"level,omitempty"`
}

func (m *App_TraceOptions) Reset()                    { *m = App_TraceOptions{} }
func (m *App_TraceOptions) String() string            { return proto.CompactTextString(m) }
func (*App_TraceOptions) ProtoMessage()               {}
func (*App_TraceOptions) Descriptor() ([]byte, []int) { return fileDescriptorNwsec_1, []int{6, 5} }

func (m *App_TraceOptions) GetLevel() App_TraceLevel {
	if m != nil {
		return m.Level
	}
	return App_TRACE_LEVEL_NONE
}

type App_FTPOptions struct {
	AllowMismatchIpAddress bool `protobuf:"varint,1,opt,name=allow_mismatch_ip_address,json=allowMismatchIpAddress,proto3" json:"allow_mismatch_ip_address,omitempty"`
	FtpSslExtension        bool `protobuf:"varint,2,opt,name=ftp_ssl_extension,json=ftpSslExtension,proto3" json:"ftp_ssl_extension,omitempty"`
	LineBreakExtension     bool `protobuf:"varint,3,opt,name=line_break_extension,json=lineBreakExtension,proto3" json:"line_break_extension,omitempty"`
}

func (m *App_FTPOptions) Reset()                    { *m = App_FTPOptions{} }
func (m *App_FTPOptions) String() string            { return proto.CompactTextString(m) }
func (*App_FTPOptions) ProtoMessage()               {}
func (*App_FTPOptions) Descriptor() ([]byte, []int) { return fileDescriptorNwsec_1, []int{6, 6} }

func (m *App_FTPOptions) GetAllowMismatchIpAddress() bool {
	if m != nil {
		return m.AllowMismatchIpAddress
	}
	return false
}

func (m *App_FTPOptions) GetFtpSslExtension() bool {
	if m != nil {
		return m.FtpSslExtension
	}
	return false
}

func (m *App_FTPOptions) GetLineBreakExtension() bool {
	if m != nil {
		return m.LineBreakExtension
	}
	return false
}

type App_DNSOptions struct {
	DropMultiQuestionPackets   bool   `protobuf:"varint,1,opt,name=drop_multi_question_packets,json=dropMultiQuestionPackets,proto3" json:"drop_multi_question_packets,omitempty"`
	DropLargeDomainNamePackets bool   `protobuf:"varint,2,opt,name=drop_large_domain_name_packets,json=dropLargeDomainNamePackets,proto3" json:"drop_large_domain_name_packets,omitempty"`
	DropLongLabelPackets       uint32 `protobuf:"varint,3,opt,name=drop_long_label_packets,json=dropLongLabelPackets,proto3" json:"drop_long_label_packets,omitempty"`
	DropMultizonePackets       uint32 `protobuf:"varint,4,opt,name=drop_multizone_packets,json=dropMultizonePackets,proto3" json:"drop_multizone_packets,omitempty"`
	MaxMsgLength               uint32 `protobuf:"varint,5,opt,name=max_msg_length,json=maxMsgLength,proto3" json:"max_msg_length,omitempty"`
}

func (m *App_DNSOptions) Reset()                    { *m = App_DNSOptions{} }
func (m *App_DNSOptions) String() string            { return proto.CompactTextString(m) }
func (*App_DNSOptions) ProtoMessage()               {}
func (*App_DNSOptions) Descriptor() ([]byte, []int) { return fileDescriptorNwsec_1, []int{6, 7} }

func (m *App_DNSOptions) GetDropMultiQuestionPackets() bool {
	if m != nil {
		return m.DropMultiQuestionPackets
	}
	return false
}

func (m *App_DNSOptions) GetDropLargeDomainNamePackets() bool {
	if m != nil {
		return m.DropLargeDomainNamePackets
	}
	return false
}

func (m *App_DNSOptions) GetDropLongLabelPackets() uint32 {
	if m != nil {
		return m.DropLongLabelPackets
	}
	return 0
}

func (m *App_DNSOptions) GetDropMultizonePackets() uint32 {
	if m != nil {
		return m.DropMultizonePackets
	}
	return 0
}

func (m *App_DNSOptions) GetMaxMsgLength() uint32 {
	if m != nil {
		return m.MaxMsgLength
	}
	return 0
}

type App_MSRPCOptions struct {
	MapEntryTimeout uint32 `protobuf:"varint,1,opt,name=map_entry_timeout,json=mapEntryTimeout,proto3" json:"map_entry_timeout,omitempty"`
}

func (m *App_MSRPCOptions) Reset()                    { *m = App_MSRPCOptions{} }
func (m *App_MSRPCOptions) String() string            { return proto.CompactTextString(m) }
func (*App_MSRPCOptions) ProtoMessage()               {}
func (*App_MSRPCOptions) Descriptor() ([]byte, []int) { return fileDescriptorNwsec_1, []int{6, 8} }

func (m *App_MSRPCOptions) GetMapEntryTimeout() uint32 {
	if m != nil {
		return m.MapEntryTimeout
	}
	return 0
}

type App_SunRPCOptions struct {
	MapEntryTimeout uint32 `protobuf:"varint,1,opt,name=map_entry_timeout,json=mapEntryTimeout,proto3" json:"map_entry_timeout,omitempty"`
}

func (m *App_SunRPCOptions) Reset()                    { *m = App_SunRPCOptions{} }
func (m *App_SunRPCOptions) String() string            { return proto.CompactTextString(m) }
func (*App_SunRPCOptions) ProtoMessage()               {}
func (*App_SunRPCOptions) Descriptor() ([]byte, []int) { return fileDescriptorNwsec_1, []int{6, 9} }

func (m *App_SunRPCOptions) GetMapEntryTimeout() uint32 {
	if m != nil {
		return m.MapEntryTimeout
	}
	return 0
}

type App_SIPOptions struct {
	Ctimeout               uint32 `protobuf:"varint,1,opt,name=ctimeout,proto3" json:"ctimeout,omitempty"`
	DscpCodePoint          uint32 `protobuf:"varint,2,opt,name=dscp_code_point,json=dscpCodePoint,proto3" json:"dscp_code_point,omitempty"`
	MediaInactivityTimeout uint32 `protobuf:"varint,3,opt,name=media_inactivity_timeout,json=mediaInactivityTimeout,proto3" json:"media_inactivity_timeout,omitempty"`
	MaxCallDuration        uint32 `protobuf:"varint,4,opt,name=max_call_duration,json=maxCallDuration,proto3" json:"max_call_duration,omitempty"`
	T1TimerValue           uint32 `protobuf:"varint,5,opt,name=t1_timer_value,json=t1TimerValue,proto3" json:"t1_timer_value,omitempty"`
	T4TimerValue           uint32 `protobuf:"varint,6,opt,name=t4_timer_value,json=t4TimerValue,proto3" json:"t4_timer_value,omitempty"`
}

func (m *App_SIPOptions) Reset()                    { *m = App_SIPOptions{} }
func (m *App_SIPOptions) String() string            { return proto.CompactTextString(m) }
func (*App_SIPOptions) ProtoMessage()               {}
func (*App_SIPOptions) Descriptor() ([]byte, []int) { return fileDescriptorNwsec_1, []int{6, 10} }

func (m *App_SIPOptions) GetCtimeout() uint32 {
	if m != nil {
		return m.Ctimeout
	}
	return 0
}

func (m *App_SIPOptions) GetDscpCodePoint() uint32 {
	if m != nil {
		return m.DscpCodePoint
	}
	return 0
}

func (m *App_SIPOptions) GetMediaInactivityTimeout() uint32 {
	if m != nil {
		return m.MediaInactivityTimeout
	}
	return 0
}

func (m *App_SIPOptions) GetMaxCallDuration() uint32 {
	if m != nil {
		return m.MaxCallDuration
	}
	return 0
}

func (m *App_SIPOptions) GetT1TimerValue() uint32 {
	if m != nil {
		return m.T1TimerValue
	}
	return 0
}

func (m *App_SIPOptions) GetT4TimerValue() uint32 {
	if m != nil {
		return m.T4TimerValue
	}
	return 0
}

// ApplicationSpec is either a pre-defined pensando application or user-defined
// custom application
type ApplicationSpec struct {
	// Types that are valid to be assigned to Apps:
	//	*ApplicationSpec_PredefinedApps
	//	*ApplicationSpec_Appln
	Apps isApplicationSpec_Apps `protobuf_oneof:"apps"`
}

func (m *ApplicationSpec) Reset()                    { *m = ApplicationSpec{} }
func (m *ApplicationSpec) String() string            { return proto.CompactTextString(m) }
func (*ApplicationSpec) ProtoMessage()               {}
func (*ApplicationSpec) Descriptor() ([]byte, []int) { return fileDescriptorNwsec_1, []int{7} }

type isApplicationSpec_Apps interface {
	isApplicationSpec_Apps()
	MarshalTo([]byte) (int, error)
	Size() int
}

type ApplicationSpec_PredefinedApps struct {
	PredefinedApps PredefinedApps `protobuf:"varint,1,opt,name=predefined_apps,json=predefinedApps,proto3,enum=nwsec.PredefinedApps,oneof"`
}
type ApplicationSpec_Appln struct {
	Appln *App `protobuf:"bytes,2,opt,name=appln,oneof"`
}

func (*ApplicationSpec_PredefinedApps) isApplicationSpec_Apps() {}
func (*ApplicationSpec_Appln) isApplicationSpec_Apps()          {}

func (m *ApplicationSpec) GetApps() isApplicationSpec_Apps {
	if m != nil {
		return m.Apps
	}
	return nil
}

func (m *ApplicationSpec) GetPredefinedApps() PredefinedApps {
	if x, ok := m.GetApps().(*ApplicationSpec_PredefinedApps); ok {
		return x.PredefinedApps
	}
	return PredefinedApps_APP_NAME_NONE
}

func (m *ApplicationSpec) GetAppln() *App {
	if x, ok := m.GetApps().(*ApplicationSpec_Appln); ok {
		return x.Appln
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ApplicationSpec) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ApplicationSpec_OneofMarshaler, _ApplicationSpec_OneofUnmarshaler, _ApplicationSpec_OneofSizer, []interface{}{
		(*ApplicationSpec_PredefinedApps)(nil),
		(*ApplicationSpec_Appln)(nil),
	}
}

func _ApplicationSpec_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ApplicationSpec)
	// apps
	switch x := m.Apps.(type) {
	case *ApplicationSpec_PredefinedApps:
		_ = b.EncodeVarint(1<<3 | proto.WireVarint)
		_ = b.EncodeVarint(uint64(x.PredefinedApps))
	case *ApplicationSpec_Appln:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Appln); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("ApplicationSpec.Apps has unexpected type %T", x)
	}
	return nil
}

func _ApplicationSpec_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ApplicationSpec)
	switch tag {
	case 1: // apps.predefined_apps
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Apps = &ApplicationSpec_PredefinedApps{PredefinedApps(x)}
		return true, err
	case 2: // apps.appln
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(App)
		err := b.DecodeMessage(msg)
		m.Apps = &ApplicationSpec_Appln{msg}
		return true, err
	default:
		return false, nil
	}
}

func _ApplicationSpec_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ApplicationSpec)
	// apps
	switch x := m.Apps.(type) {
	case *ApplicationSpec_PredefinedApps:
		n += proto.SizeVarint(1<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.PredefinedApps))
	case *ApplicationSpec_Appln:
		s := proto.Size(x.Appln)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type ApplicationStatus struct {
}

func (m *ApplicationStatus) Reset()                    { *m = ApplicationStatus{} }
func (m *ApplicationStatus) String() string            { return proto.CompactTextString(m) }
func (*ApplicationStatus) ProtoMessage()               {}
func (*ApplicationStatus) Descriptor() ([]byte, []int) { return fileDescriptorNwsec_1, []int{8} }

type Application struct {
	Meta   *ObjectMeta        `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	Spec   *ApplicationSpec   `protobuf:"bytes,2,opt,name=spec" json:"spec,omitempty"`
	Status *ApplicationStatus `protobuf:"bytes,3,opt,name=status" json:"status,omitempty"`
}

func (m *Application) Reset()                    { *m = Application{} }
func (m *Application) String() string            { return proto.CompactTextString(m) }
func (*Application) ProtoMessage()               {}
func (*Application) Descriptor() ([]byte, []int) { return fileDescriptorNwsec_1, []int{9} }

func (m *Application) GetMeta() *ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *Application) GetSpec() *ApplicationSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *Application) GetStatus() *ApplicationStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

// group of applications to apply same policy on
type AppGroupSpec struct {
	Apps []*Application `protobuf:"bytes,2,rep,name=Apps" json:"Apps,omitempty"`
}

func (m *AppGroupSpec) Reset()                    { *m = AppGroupSpec{} }
func (m *AppGroupSpec) String() string            { return proto.CompactTextString(m) }
func (*AppGroupSpec) ProtoMessage()               {}
func (*AppGroupSpec) Descriptor() ([]byte, []int) { return fileDescriptorNwsec_1, []int{10} }

func (m *AppGroupSpec) GetApps() []*Application {
	if m != nil {
		return m.Apps
	}
	return nil
}

type AppGroupStatus struct {
}

func (m *AppGroupStatus) Reset()                    { *m = AppGroupStatus{} }
func (m *AppGroupStatus) String() string            { return proto.CompactTextString(m) }
func (*AppGroupStatus) ProtoMessage()               {}
func (*AppGroupStatus) Descriptor() ([]byte, []int) { return fileDescriptorNwsec_1, []int{11} }

type AppGroup struct {
	Meta   *ObjectMeta     `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	Spec   *AppGroupSpec   `protobuf:"bytes,2,opt,name=spec" json:"spec,omitempty"`
	Status *AppGroupStatus `protobuf:"bytes,3,opt,name=status" json:"status,omitempty"`
}

func (m *AppGroup) Reset()                    { *m = AppGroup{} }
func (m *AppGroup) String() string            { return proto.CompactTextString(m) }
func (*AppGroup) ProtoMessage()               {}
func (*AppGroup) Descriptor() ([]byte, []int) { return fileDescriptorNwsec_1, []int{12} }

func (m *AppGroup) GetMeta() *ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *AppGroup) GetSpec() *AppGroupSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *AppGroup) GetStatus() *AppGroupStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

type SecurityRuleAction struct {
	SecAction SecurityAction `protobuf:"varint,1,opt,name=sec_action,json=secAction,proto3,enum=nwsec.SecurityAction" json:"sec_action,omitempty"`
	LogAction LogAction      `protobuf:"varint,2,opt,name=log_action,json=logAction,proto3,enum=nwsec.LogAction" json:"log_action,omitempty"`
}

func (m *SecurityRuleAction) Reset()                    { *m = SecurityRuleAction{} }
func (m *SecurityRuleAction) String() string            { return proto.CompactTextString(m) }
func (*SecurityRuleAction) ProtoMessage()               {}
func (*SecurityRuleAction) Descriptor() ([]byte, []int) { return fileDescriptorNwsec_1, []int{13} }

func (m *SecurityRuleAction) GetSecAction() SecurityAction {
	if m != nil {
		return m.SecAction
	}
	return SecurityAction_SECURITY_RULE_ACTION_NONE
}

func (m *SecurityRuleAction) GetLogAction() LogAction {
	if m != nil {
		return m.LogAction
	}
	return LogAction_LOG_NONE
}

type SecurityRuleSpec struct {
	RuleId       uint32              `protobuf:"varint,1,opt,name=rule_id,json=ruleId,proto3" json:"rule_id,omitempty"`
	Enable       bool                `protobuf:"varint,2,opt,name=enable,proto3" json:"enable,omitempty"`
	Enforce      bool                `protobuf:"varint,100,opt,name=enforce,proto3" json:"enforce,omitempty"`
	Action       *SecurityRuleAction `protobuf:"bytes,3,opt,name=action" json:"action,omitempty"`
	Count        bool                `protobuf:"varint,4,opt,name=count,proto3" json:"count,omitempty"`
	App          []*Application      `protobuf:"bytes,5,rep,name=app" json:"app,omitempty"`
	AppGroup     []*AppGroup         `protobuf:"bytes,6,rep,name=app_group,json=appGroup" json:"app_group,omitempty"`
	SrcAddress   []*IPAddressSpec    `protobuf:"bytes,7,rep,name=src_address,json=srcAddress" json:"src_address,omitempty"`
	SrcSg        []uint32            `protobuf:"varint,8,rep,packed,name=src_sg,json=srcSg" json:"src_sg,omitempty"`
	DstAddress   []*IPAddressSpec    `protobuf:"bytes,9,rep,name=dst_address,json=dstAddress" json:"dst_address,omitempty"`
	DstSg        []uint32            `protobuf:"varint,10,rep,packed,name=dst_sg,json=dstSg" json:"dst_sg,omitempty"`
	DstPortRange []*L4PortRange      `protobuf:"bytes,11,rep,name=dst_port_range,json=dstPortRange" json:"dst_port_range,omitempty"`
	SrcPortRange []*L4PortRange      `protobuf:"bytes,12,rep,name=src_port_range,json=srcPortRange" json:"src_port_range,omitempty"`
	ConnTrackEn  bool                `protobuf:"varint,13,opt,name=conn_track_en,json=connTrackEn,proto3" json:"conn_track_en,omitempty"`
}

func (m *SecurityRuleSpec) Reset()                    { *m = SecurityRuleSpec{} }
func (m *SecurityRuleSpec) String() string            { return proto.CompactTextString(m) }
func (*SecurityRuleSpec) ProtoMessage()               {}
func (*SecurityRuleSpec) Descriptor() ([]byte, []int) { return fileDescriptorNwsec_1, []int{14} }

func (m *SecurityRuleSpec) GetRuleId() uint32 {
	if m != nil {
		return m.RuleId
	}
	return 0
}

func (m *SecurityRuleSpec) GetEnable() bool {
	if m != nil {
		return m.Enable
	}
	return false
}

func (m *SecurityRuleSpec) GetEnforce() bool {
	if m != nil {
		return m.Enforce
	}
	return false
}

func (m *SecurityRuleSpec) GetAction() *SecurityRuleAction {
	if m != nil {
		return m.Action
	}
	return nil
}

func (m *SecurityRuleSpec) GetCount() bool {
	if m != nil {
		return m.Count
	}
	return false
}

func (m *SecurityRuleSpec) GetApp() []*Application {
	if m != nil {
		return m.App
	}
	return nil
}

func (m *SecurityRuleSpec) GetAppGroup() []*AppGroup {
	if m != nil {
		return m.AppGroup
	}
	return nil
}

func (m *SecurityRuleSpec) GetSrcAddress() []*IPAddressSpec {
	if m != nil {
		return m.SrcAddress
	}
	return nil
}

func (m *SecurityRuleSpec) GetSrcSg() []uint32 {
	if m != nil {
		return m.SrcSg
	}
	return nil
}

func (m *SecurityRuleSpec) GetDstAddress() []*IPAddressSpec {
	if m != nil {
		return m.DstAddress
	}
	return nil
}

func (m *SecurityRuleSpec) GetDstSg() []uint32 {
	if m != nil {
		return m.DstSg
	}
	return nil
}

func (m *SecurityRuleSpec) GetDstPortRange() []*L4PortRange {
	if m != nil {
		return m.DstPortRange
	}
	return nil
}

func (m *SecurityRuleSpec) GetSrcPortRange() []*L4PortRange {
	if m != nil {
		return m.SrcPortRange
	}
	return nil
}

func (m *SecurityRuleSpec) GetConnTrackEn() bool {
	if m != nil {
		return m.ConnTrackEn
	}
	return false
}

type SecurityRuleStatus struct {
	SecurityRuleHandle uint64 `protobuf:"fixed64,1,opt,name=security_rule_handle,json=securityRuleHandle,proto3" json:"security_rule_handle,omitempty"`
}

func (m *SecurityRuleStatus) Reset()                    { *m = SecurityRuleStatus{} }
func (m *SecurityRuleStatus) String() string            { return proto.CompactTextString(m) }
func (*SecurityRuleStatus) ProtoMessage()               {}
func (*SecurityRuleStatus) Descriptor() ([]byte, []int) { return fileDescriptorNwsec_1, []int{15} }

func (m *SecurityRuleStatus) GetSecurityRuleHandle() uint64 {
	if m != nil {
		return m.SecurityRuleHandle
	}
	return 0
}

type SecurityRule struct {
	Meta   *ObjectMeta         `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	Spec   *SecurityRuleSpec   `protobuf:"bytes,2,opt,name=spec" json:"spec,omitempty"`
	Status *SecurityRuleStatus `protobuf:"bytes,3,opt,name=status" json:"status,omitempty"`
}

func (m *SecurityRule) Reset()                    { *m = SecurityRule{} }
func (m *SecurityRule) String() string            { return proto.CompactTextString(m) }
func (*SecurityRule) ProtoMessage()               {}
func (*SecurityRule) Descriptor() ([]byte, []int) { return fileDescriptorNwsec_1, []int{16} }

func (m *SecurityRule) GetMeta() *ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *SecurityRule) GetSpec() *SecurityRuleSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *SecurityRule) GetStatus() *SecurityRuleStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

// SecurityRuleRequestMsg is batched add or modify security rule request
type SecurityRuleRequestMsg struct {
	Request []*SecurityRule `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *SecurityRuleRequestMsg) Reset()                    { *m = SecurityRuleRequestMsg{} }
func (m *SecurityRuleRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*SecurityRuleRequestMsg) ProtoMessage()               {}
func (*SecurityRuleRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptorNwsec_1, []int{17} }

func (m *SecurityRuleRequestMsg) GetRequest() []*SecurityRule {
	if m != nil {
		return m.Request
	}
	return nil
}

// SecurityRuleResponse is the response to SecurityRule
type SecurityRuleResponse struct {
	ApiStatus ApiStatus           `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status"`
	Status    *SecurityRuleStatus `protobuf:"bytes,2,opt,name=status" json:"status,omitempty"`
}

func (m *SecurityRuleResponse) Reset()                    { *m = SecurityRuleResponse{} }
func (m *SecurityRuleResponse) String() string            { return proto.CompactTextString(m) }
func (*SecurityRuleResponse) ProtoMessage()               {}
func (*SecurityRuleResponse) Descriptor() ([]byte, []int) { return fileDescriptorNwsec_1, []int{18} }

func (m *SecurityRuleResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *SecurityRuleResponse) GetStatus() *SecurityRuleStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

type SecurityRuleResponseMsg struct {
	Response []*SecurityRuleResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *SecurityRuleResponseMsg) Reset()                    { *m = SecurityRuleResponseMsg{} }
func (m *SecurityRuleResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*SecurityRuleResponseMsg) ProtoMessage()               {}
func (*SecurityRuleResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptorNwsec_1, []int{19} }

func (m *SecurityRuleResponseMsg) GetResponse() []*SecurityRuleResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

// SecurityRuleDeleteRequest is used to delete a security rule
type SecurityRuleDeleteRequest struct {
	Meta            *ObjectMeta            `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	RuleKeyOrHandle *SecurityRuleKeyHandle `protobuf:"bytes,2,opt,name=rule_key_or_handle,json=ruleKeyOrHandle" json:"key"`
}

func (m *SecurityRuleDeleteRequest) Reset()         { *m = SecurityRuleDeleteRequest{} }
func (m *SecurityRuleDeleteRequest) String() string { return proto.CompactTextString(m) }
func (*SecurityRuleDeleteRequest) ProtoMessage()    {}
func (*SecurityRuleDeleteRequest) Descriptor() ([]byte, []int) {
	return fileDescriptorNwsec_1, []int{20}
}

func (m *SecurityRuleDeleteRequest) GetMeta() *ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *SecurityRuleDeleteRequest) GetRuleKeyOrHandle() *SecurityRuleKeyHandle {
	if m != nil {
		return m.RuleKeyOrHandle
	}
	return nil
}

// SecurityRuleDeleteRequestMsg is used to delete a batch of security rules
type SecurityRuleDeleteRequestMsg struct {
	Request []*SecurityRuleDeleteRequest `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *SecurityRuleDeleteRequestMsg) Reset()         { *m = SecurityRuleDeleteRequestMsg{} }
func (m *SecurityRuleDeleteRequestMsg) String() string { return proto.CompactTextString(m) }
func (*SecurityRuleDeleteRequestMsg) ProtoMessage()    {}
func (*SecurityRuleDeleteRequestMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorNwsec_1, []int{21}
}

func (m *SecurityRuleDeleteRequestMsg) GetRequest() []*SecurityRuleDeleteRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

type SecurityRuleDeleteResponse struct {
	ApiStatus ApiStatus `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status"`
}

func (m *SecurityRuleDeleteResponse) Reset()         { *m = SecurityRuleDeleteResponse{} }
func (m *SecurityRuleDeleteResponse) String() string { return proto.CompactTextString(m) }
func (*SecurityRuleDeleteResponse) ProtoMessage()    {}
func (*SecurityRuleDeleteResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorNwsec_1, []int{22}
}

func (m *SecurityRuleDeleteResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

// SecurityRuleDeleteResponseMsg is batched response to SecurityRuleDeleteRequestMsg
type SecurityRuleDeleteResponseMsg struct {
	Response []*SecurityRuleDeleteResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *SecurityRuleDeleteResponseMsg) Reset()         { *m = SecurityRuleDeleteResponseMsg{} }
func (m *SecurityRuleDeleteResponseMsg) String() string { return proto.CompactTextString(m) }
func (*SecurityRuleDeleteResponseMsg) ProtoMessage()    {}
func (*SecurityRuleDeleteResponseMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorNwsec_1, []int{23}
}

func (m *SecurityRuleDeleteResponseMsg) GetResponse() []*SecurityRuleDeleteResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

// SecurityRuleGet is used to get information about a security rule
type SecurityRuleGet struct {
	Meta *ObjectMeta `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	// key_or_handle is the security rule's unique identifier
	KeyOrHandle *SecurityRuleKeyHandle `protobuf:"bytes,2,opt,name=key_or_handle,json=keyOrHandle" json:"key"`
}

func (m *SecurityRuleGet) Reset()                    { *m = SecurityRuleGet{} }
func (m *SecurityRuleGet) String() string            { return proto.CompactTextString(m) }
func (*SecurityRuleGet) ProtoMessage()               {}
func (*SecurityRuleGet) Descriptor() ([]byte, []int) { return fileDescriptorNwsec_1, []int{24} }

func (m *SecurityRuleGet) GetMeta() *ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *SecurityRuleGet) GetKeyOrHandle() *SecurityRuleKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

// SecurityRuleGetRequestMsg is batched GET request for security rules
type SecurityRuleGetMsg struct {
	Request []*SecurityRuleGet `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *SecurityRuleGetMsg) Reset()                    { *m = SecurityRuleGetMsg{} }
func (m *SecurityRuleGetMsg) String() string            { return proto.CompactTextString(m) }
func (*SecurityRuleGetMsg) ProtoMessage()               {}
func (*SecurityRuleGetMsg) Descriptor() ([]byte, []int) { return fileDescriptorNwsec_1, []int{25} }

func (m *SecurityRuleGetMsg) GetRequest() []*SecurityRuleGet {
	if m != nil {
		return m.Request
	}
	return nil
}

// SecurityRuleGetResponse caputres all the information about a security rule
type SecurityRuleGetResponse struct {
	ApiStatus ApiStatus           `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status"`
	Spec      *SecurityRuleSpec   `protobuf:"bytes,2,opt,name=spec" json:"spec,omitempty"`
	Status    *SecurityRuleStatus `protobuf:"bytes,3,opt,name=status" json:"status,omitempty"`
}

func (m *SecurityRuleGetResponse) Reset()                    { *m = SecurityRuleGetResponse{} }
func (m *SecurityRuleGetResponse) String() string            { return proto.CompactTextString(m) }
func (*SecurityRuleGetResponse) ProtoMessage()               {}
func (*SecurityRuleGetResponse) Descriptor() ([]byte, []int) { return fileDescriptorNwsec_1, []int{26} }

func (m *SecurityRuleGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *SecurityRuleGetResponse) GetSpec() *SecurityRuleSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *SecurityRuleGetResponse) GetStatus() *SecurityRuleStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

type SecurityRuleGetResponseMsg struct {
	Response  []*SecurityRuleGetResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
	ApiStatus ApiStatus                  `protobuf:"varint,2,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty"`
}

func (m *SecurityRuleGetResponseMsg) Reset()         { *m = SecurityRuleGetResponseMsg{} }
func (m *SecurityRuleGetResponseMsg) String() string { return proto.CompactTextString(m) }
func (*SecurityRuleGetResponseMsg) ProtoMessage()    {}
func (*SecurityRuleGetResponseMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorNwsec_1, []int{27}
}

func (m *SecurityRuleGetResponseMsg) GetResponse() []*SecurityRuleGetResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

func (m *SecurityRuleGetResponseMsg) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func init() {
	proto.RegisterType((*AddressSpec)(nil), "nwsec.AddressSpec")
	proto.RegisterType((*AddressStatus)(nil), "nwsec.AddressStatus")
	proto.RegisterType((*AddressGroupSpec)(nil), "nwsec.AddressGroupSpec")
	proto.RegisterType((*AddressGroupStatus)(nil), "nwsec.AddressGroupStatus")
	proto.RegisterType((*AddressGroup)(nil), "nwsec.AddressGroup")
	proto.RegisterType((*IPAddressSpec)(nil), "nwsec.IPAddressSpec")
	proto.RegisterType((*App)(nil), "nwsec.App")
	proto.RegisterType((*App_AppPortInfo)(nil), "nwsec.App.AppPortInfo")
	proto.RegisterType((*App_ICMPAppInfo)(nil), "nwsec.App.ICMPAppInfo")
	proto.RegisterType((*App_ICMPv6AppInfo)(nil), "nwsec.App.ICMPv6AppInfo")
	proto.RegisterType((*App_RPCAppInfo)(nil), "nwsec.App.RPCAppInfo")
	proto.RegisterType((*App_MSRPCAppInfo)(nil), "nwsec.App.MSRPCAppInfo")
	proto.RegisterType((*App_TraceOptions)(nil), "nwsec.App.TraceOptions")
	proto.RegisterType((*App_FTPOptions)(nil), "nwsec.App.FTPOptions")
	proto.RegisterType((*App_DNSOptions)(nil), "nwsec.App.DNSOptions")
	proto.RegisterType((*App_MSRPCOptions)(nil), "nwsec.App.MSRPCOptions")
	proto.RegisterType((*App_SunRPCOptions)(nil), "nwsec.App.SunRPCOptions")
	proto.RegisterType((*App_SIPOptions)(nil), "nwsec.App.SIPOptions")
	proto.RegisterType((*ApplicationSpec)(nil), "nwsec.ApplicationSpec")
	proto.RegisterType((*ApplicationStatus)(nil), "nwsec.ApplicationStatus")
	proto.RegisterType((*Application)(nil), "nwsec.Application")
	proto.RegisterType((*AppGroupSpec)(nil), "nwsec.AppGroupSpec")
	proto.RegisterType((*AppGroupStatus)(nil), "nwsec.AppGroupStatus")
	proto.RegisterType((*AppGroup)(nil), "nwsec.AppGroup")
	proto.RegisterType((*SecurityRuleAction)(nil), "nwsec.SecurityRuleAction")
	proto.RegisterType((*SecurityRuleSpec)(nil), "nwsec.SecurityRuleSpec")
	proto.RegisterType((*SecurityRuleStatus)(nil), "nwsec.SecurityRuleStatus")
	proto.RegisterType((*SecurityRule)(nil), "nwsec.SecurityRule")
	proto.RegisterType((*SecurityRuleRequestMsg)(nil), "nwsec.SecurityRuleRequestMsg")
	proto.RegisterType((*SecurityRuleResponse)(nil), "nwsec.SecurityRuleResponse")
	proto.RegisterType((*SecurityRuleResponseMsg)(nil), "nwsec.SecurityRuleResponseMsg")
	proto.RegisterType((*SecurityRuleDeleteRequest)(nil), "nwsec.SecurityRuleDeleteRequest")
	proto.RegisterType((*SecurityRuleDeleteRequestMsg)(nil), "nwsec.SecurityRuleDeleteRequestMsg")
	proto.RegisterType((*SecurityRuleDeleteResponse)(nil), "nwsec.SecurityRuleDeleteResponse")
	proto.RegisterType((*SecurityRuleDeleteResponseMsg)(nil), "nwsec.SecurityRuleDeleteResponseMsg")
	proto.RegisterType((*SecurityRuleGet)(nil), "nwsec.SecurityRuleGet")
	proto.RegisterType((*SecurityRuleGetMsg)(nil), "nwsec.SecurityRuleGetMsg")
	proto.RegisterType((*SecurityRuleGetResponse)(nil), "nwsec.SecurityRuleGetResponse")
	proto.RegisterType((*SecurityRuleGetResponseMsg)(nil), "nwsec.SecurityRuleGetResponseMsg")
	proto.RegisterEnum("nwsec.PredefinedApps", PredefinedApps_name, PredefinedApps_value)
	proto.RegisterEnum("nwsec.SecurityAction", SecurityAction_name, SecurityAction_value)
	proto.RegisterEnum("nwsec.LogAction", LogAction_name, LogAction_value)
	proto.RegisterEnum("nwsec.App_TraceLevel", App_TraceLevel_name, App_TraceLevel_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for NwSecurityRule service

type NwSecurityRuleClient interface {
	SecurityRuleCreate(ctx context.Context, in *SecurityRuleRequestMsg, opts ...grpc.CallOption) (*SecurityRuleResponseMsg, error)
	SecurityRuleUpdate(ctx context.Context, in *SecurityRuleRequestMsg, opts ...grpc.CallOption) (*SecurityRuleResponseMsg, error)
	SecurityRuleDelete(ctx context.Context, in *SecurityRuleDeleteRequestMsg, opts ...grpc.CallOption) (*SecurityRuleDeleteResponseMsg, error)
	SecurityRuleGet(ctx context.Context, in *SecurityRuleGetMsg, opts ...grpc.CallOption) (*SecurityRuleGetResponseMsg, error)
}

type nwSecurityRuleClient struct {
	cc *grpc.ClientConn
}

func NewNwSecurityRuleClient(cc *grpc.ClientConn) NwSecurityRuleClient {
	return &nwSecurityRuleClient{cc}
}

func (c *nwSecurityRuleClient) SecurityRuleCreate(ctx context.Context, in *SecurityRuleRequestMsg, opts ...grpc.CallOption) (*SecurityRuleResponseMsg, error) {
	out := new(SecurityRuleResponseMsg)
	err := grpc.Invoke(ctx, "/nwsec.NwSecurityRule/SecurityRuleCreate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nwSecurityRuleClient) SecurityRuleUpdate(ctx context.Context, in *SecurityRuleRequestMsg, opts ...grpc.CallOption) (*SecurityRuleResponseMsg, error) {
	out := new(SecurityRuleResponseMsg)
	err := grpc.Invoke(ctx, "/nwsec.NwSecurityRule/SecurityRuleUpdate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nwSecurityRuleClient) SecurityRuleDelete(ctx context.Context, in *SecurityRuleDeleteRequestMsg, opts ...grpc.CallOption) (*SecurityRuleDeleteResponseMsg, error) {
	out := new(SecurityRuleDeleteResponseMsg)
	err := grpc.Invoke(ctx, "/nwsec.NwSecurityRule/SecurityRuleDelete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nwSecurityRuleClient) SecurityRuleGet(ctx context.Context, in *SecurityRuleGetMsg, opts ...grpc.CallOption) (*SecurityRuleGetResponseMsg, error) {
	out := new(SecurityRuleGetResponseMsg)
	err := grpc.Invoke(ctx, "/nwsec.NwSecurityRule/SecurityRuleGet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for NwSecurityRule service

type NwSecurityRuleServer interface {
	SecurityRuleCreate(context.Context, *SecurityRuleRequestMsg) (*SecurityRuleResponseMsg, error)
	SecurityRuleUpdate(context.Context, *SecurityRuleRequestMsg) (*SecurityRuleResponseMsg, error)
	SecurityRuleDelete(context.Context, *SecurityRuleDeleteRequestMsg) (*SecurityRuleDeleteResponseMsg, error)
	SecurityRuleGet(context.Context, *SecurityRuleGetMsg) (*SecurityRuleGetResponseMsg, error)
}

func RegisterNwSecurityRuleServer(s *grpc.Server, srv NwSecurityRuleServer) {
	s.RegisterService(&_NwSecurityRule_serviceDesc, srv)
}

func _NwSecurityRule_SecurityRuleCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SecurityRuleRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NwSecurityRuleServer).SecurityRuleCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nwsec.NwSecurityRule/SecurityRuleCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NwSecurityRuleServer).SecurityRuleCreate(ctx, req.(*SecurityRuleRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _NwSecurityRule_SecurityRuleUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SecurityRuleRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NwSecurityRuleServer).SecurityRuleUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nwsec.NwSecurityRule/SecurityRuleUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NwSecurityRuleServer).SecurityRuleUpdate(ctx, req.(*SecurityRuleRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _NwSecurityRule_SecurityRuleDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SecurityRuleDeleteRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NwSecurityRuleServer).SecurityRuleDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nwsec.NwSecurityRule/SecurityRuleDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NwSecurityRuleServer).SecurityRuleDelete(ctx, req.(*SecurityRuleDeleteRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _NwSecurityRule_SecurityRuleGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SecurityRuleGetMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NwSecurityRuleServer).SecurityRuleGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nwsec.NwSecurityRule/SecurityRuleGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NwSecurityRuleServer).SecurityRuleGet(ctx, req.(*SecurityRuleGetMsg))
	}
	return interceptor(ctx, in, info, handler)
}

var _NwSecurityRule_serviceDesc = grpc.ServiceDesc{
	ServiceName: "nwsec.NwSecurityRule",
	HandlerType: (*NwSecurityRuleServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SecurityRuleCreate",
			Handler:    _NwSecurityRule_SecurityRuleCreate_Handler,
		},
		{
			MethodName: "SecurityRuleUpdate",
			Handler:    _NwSecurityRule_SecurityRuleUpdate_Handler,
		},
		{
			MethodName: "SecurityRuleDelete",
			Handler:    _NwSecurityRule_SecurityRuleDelete_Handler,
		},
		{
			MethodName: "SecurityRuleGet",
			Handler:    _NwSecurityRule_SecurityRuleGet_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "nwsec_1.proto",
}

func (m *AddressSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddressSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Address != nil {
		nn1, err := m.Address.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn1
	}
	return i, nil
}

func (m *AddressSpec_Prefix) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Prefix != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNwsec_1(dAtA, i, uint64(m.Prefix.Size()))
		n2, err := m.Prefix.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}
func (m *AddressSpec_Range) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Range != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNwsec_1(dAtA, i, uint64(m.Range.Size()))
		n3, err := m.Range.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}
func (m *AddressStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddressStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *AddressGroupSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddressGroupSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Address) > 0 {
		for _, msg := range m.Address {
			dAtA[i] = 0xa
			i++
			i = encodeVarintNwsec_1(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *AddressGroupStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddressGroupStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *AddressGroup) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddressGroup) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNwsec_1(dAtA, i, uint64(m.Meta.Size()))
		n4, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.Spec != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNwsec_1(dAtA, i, uint64(m.Spec.Size()))
		n5, err := m.Spec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.Status != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintNwsec_1(dAtA, i, uint64(m.Status.Size()))
		n6, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}

func (m *IPAddressSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IPAddressSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Formats != nil {
		nn7, err := m.Formats.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn7
	}
	if m.Negate {
		dAtA[i] = 0x30
		i++
		if m.Negate {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *IPAddressSpec_Type) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x8
	i++
	i = encodeVarintNwsec_1(dAtA, i, uint64(m.Type))
	return i, nil
}
func (m *IPAddressSpec_Prefix) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Prefix != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNwsec_1(dAtA, i, uint64(m.Prefix.Size()))
		n8, err := m.Prefix.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	return i, nil
}
func (m *IPAddressSpec_Range) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Range != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintNwsec_1(dAtA, i, uint64(m.Range.Size()))
		n9, err := m.Range.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	return i, nil
}
func (m *IPAddressSpec_Address) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Address != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintNwsec_1(dAtA, i, uint64(m.Address.Size()))
		n10, err := m.Address.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	return i, nil
}
func (m *IPAddressSpec_AddrGrp) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.AddrGrp != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintNwsec_1(dAtA, i, uint64(m.AddrGrp.Size()))
		n11, err := m.AddrGrp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	return i, nil
}
func (m *App) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *App) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Protocol != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNwsec_1(dAtA, i, uint64(m.Protocol))
	}
	if m.L4AppInfo != nil {
		nn12, err := m.L4AppInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn12
	}
	if m.Alg != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintNwsec_1(dAtA, i, uint64(m.Alg))
	}
	if m.AppOptions != nil {
		nn13, err := m.AppOptions.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn13
	}
	if m.IdleTimeout != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintNwsec_1(dAtA, i, uint64(m.IdleTimeout))
	}
	if m.TraceOpts != nil {
		dAtA[i] = 0x72
		i++
		i = encodeVarintNwsec_1(dAtA, i, uint64(m.TraceOpts.Size()))
		n14, err := m.TraceOpts.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	return i, nil
}

func (m *App_PortInfo) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.PortInfo != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNwsec_1(dAtA, i, uint64(m.PortInfo.Size()))
		n15, err := m.PortInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	return i, nil
}
func (m *App_IcmpInfo) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.IcmpInfo != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintNwsec_1(dAtA, i, uint64(m.IcmpInfo.Size()))
		n16, err := m.IcmpInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	return i, nil
}
func (m *App_Icmpv6Info) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Icmpv6Info != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintNwsec_1(dAtA, i, uint64(m.Icmpv6Info.Size()))
		n17, err := m.Icmpv6Info.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	return i, nil
}
func (m *App_RpcInfo) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.RpcInfo != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintNwsec_1(dAtA, i, uint64(m.RpcInfo.Size()))
		n18, err := m.RpcInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	return i, nil
}
func (m *App_MsrpcCinfo) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.MsrpcCinfo != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintNwsec_1(dAtA, i, uint64(m.MsrpcCinfo.Size()))
		n19, err := m.MsrpcCinfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	return i, nil
}
func (m *App_FtpOptionInfo) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.FtpOptionInfo != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintNwsec_1(dAtA, i, uint64(m.FtpOptionInfo.Size()))
		n20, err := m.FtpOptionInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	return i, nil
}
func (m *App_DnsOptionInfo) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.DnsOptionInfo != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintNwsec_1(dAtA, i, uint64(m.DnsOptionInfo.Size()))
		n21, err := m.DnsOptionInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	return i, nil
}
func (m *App_MsrpCoptionInfo) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.MsrpCoptionInfo != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintNwsec_1(dAtA, i, uint64(m.MsrpCoptionInfo.Size()))
		n22, err := m.MsrpCoptionInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	return i, nil
}
func (m *App_SunRpcPptionInfo) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.SunRpcPptionInfo != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintNwsec_1(dAtA, i, uint64(m.SunRpcPptionInfo.Size()))
		n23, err := m.SunRpcPptionInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	return i, nil
}
func (m *App_SipOptions) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.SipOptions != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintNwsec_1(dAtA, i, uint64(m.SipOptions.Size()))
		n24, err := m.SipOptions.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	return i, nil
}
func (m *App_AppPortInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *App_AppPortInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.DstPortRange) > 0 {
		for _, msg := range m.DstPortRange {
			dAtA[i] = 0xa
			i++
			i = encodeVarintNwsec_1(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.SrcPortRange) > 0 {
		for _, msg := range m.SrcPortRange {
			dAtA[i] = 0x12
			i++
			i = encodeVarintNwsec_1(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *App_ICMPAppInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *App_ICMPAppInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.IcmpType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNwsec_1(dAtA, i, uint64(m.IcmpType))
	}
	if m.IcmpCode != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintNwsec_1(dAtA, i, uint64(m.IcmpCode))
	}
	return i, nil
}

func (m *App_ICMPv6AppInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *App_ICMPv6AppInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Icmpv6Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNwsec_1(dAtA, i, uint64(m.Icmpv6Type))
	}
	if m.Icmpv6Code != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintNwsec_1(dAtA, i, uint64(m.Icmpv6Code))
	}
	return i, nil
}

func (m *App_RPCAppInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *App_RPCAppInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ProgramNumber != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNwsec_1(dAtA, i, uint64(m.ProgramNumber))
	}
	return i, nil
}

func (m *App_MSRPCAppInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *App_MSRPCAppInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uuid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNwsec_1(dAtA, i, uint64(m.Uuid))
	}
	return i, nil
}

func (m *App_TraceOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *App_TraceOptions) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Level != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNwsec_1(dAtA, i, uint64(m.Level))
	}
	return i, nil
}

func (m *App_FTPOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *App_FTPOptions) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.AllowMismatchIpAddress {
		dAtA[i] = 0x8
		i++
		if m.AllowMismatchIpAddress {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.FtpSslExtension {
		dAtA[i] = 0x10
		i++
		if m.FtpSslExtension {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.LineBreakExtension {
		dAtA[i] = 0x18
		i++
		if m.LineBreakExtension {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *App_DNSOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *App_DNSOptions) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.DropMultiQuestionPackets {
		dAtA[i] = 0x8
		i++
		if m.DropMultiQuestionPackets {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DropLargeDomainNamePackets {
		dAtA[i] = 0x10
		i++
		if m.DropLargeDomainNamePackets {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DropLongLabelPackets != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintNwsec_1(dAtA, i, uint64(m.DropLongLabelPackets))
	}
	if m.DropMultizonePackets != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintNwsec_1(dAtA, i, uint64(m.DropMultizonePackets))
	}
	if m.MaxMsgLength != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintNwsec_1(dAtA, i, uint64(m.MaxMsgLength))
	}
	return i, nil
}

func (m *App_MSRPCOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *App_MSRPCOptions) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MapEntryTimeout != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNwsec_1(dAtA, i, uint64(m.MapEntryTimeout))
	}
	return i, nil
}

func (m *App_SunRPCOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *App_SunRPCOptions) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MapEntryTimeout != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNwsec_1(dAtA, i, uint64(m.MapEntryTimeout))
	}
	return i, nil
}

func (m *App_SIPOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *App_SIPOptions) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Ctimeout != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNwsec_1(dAtA, i, uint64(m.Ctimeout))
	}
	if m.DscpCodePoint != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintNwsec_1(dAtA, i, uint64(m.DscpCodePoint))
	}
	if m.MediaInactivityTimeout != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintNwsec_1(dAtA, i, uint64(m.MediaInactivityTimeout))
	}
	if m.MaxCallDuration != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintNwsec_1(dAtA, i, uint64(m.MaxCallDuration))
	}
	if m.T1TimerValue != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintNwsec_1(dAtA, i, uint64(m.T1TimerValue))
	}
	if m.T4TimerValue != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintNwsec_1(dAtA, i, uint64(m.T4TimerValue))
	}
	return i, nil
}

func (m *ApplicationSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ApplicationSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Apps != nil {
		nn25, err := m.Apps.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn25
	}
	return i, nil
}

func (m *ApplicationSpec_PredefinedApps) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x8
	i++
	i = encodeVarintNwsec_1(dAtA, i, uint64(m.PredefinedApps))
	return i, nil
}
func (m *ApplicationSpec_Appln) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Appln != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNwsec_1(dAtA, i, uint64(m.Appln.Size()))
		n26, err := m.Appln.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n26
	}
	return i, nil
}
func (m *ApplicationStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ApplicationStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *Application) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Application) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNwsec_1(dAtA, i, uint64(m.Meta.Size()))
		n27, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n27
	}
	if m.Spec != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNwsec_1(dAtA, i, uint64(m.Spec.Size()))
		n28, err := m.Spec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n28
	}
	if m.Status != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintNwsec_1(dAtA, i, uint64(m.Status.Size()))
		n29, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n29
	}
	return i, nil
}

func (m *AppGroupSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppGroupSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Apps) > 0 {
		for _, msg := range m.Apps {
			dAtA[i] = 0x12
			i++
			i = encodeVarintNwsec_1(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *AppGroupStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppGroupStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *AppGroup) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppGroup) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNwsec_1(dAtA, i, uint64(m.Meta.Size()))
		n30, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n30
	}
	if m.Spec != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNwsec_1(dAtA, i, uint64(m.Spec.Size()))
		n31, err := m.Spec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n31
	}
	if m.Status != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintNwsec_1(dAtA, i, uint64(m.Status.Size()))
		n32, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n32
	}
	return i, nil
}

func (m *SecurityRuleAction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityRuleAction) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SecAction != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNwsec_1(dAtA, i, uint64(m.SecAction))
	}
	if m.LogAction != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintNwsec_1(dAtA, i, uint64(m.LogAction))
	}
	return i, nil
}

func (m *SecurityRuleSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityRuleSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RuleId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNwsec_1(dAtA, i, uint64(m.RuleId))
	}
	if m.Enable {
		dAtA[i] = 0x10
		i++
		if m.Enable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Action != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintNwsec_1(dAtA, i, uint64(m.Action.Size()))
		n33, err := m.Action.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n33
	}
	if m.Count {
		dAtA[i] = 0x20
		i++
		if m.Count {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.App) > 0 {
		for _, msg := range m.App {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintNwsec_1(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.AppGroup) > 0 {
		for _, msg := range m.AppGroup {
			dAtA[i] = 0x32
			i++
			i = encodeVarintNwsec_1(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.SrcAddress) > 0 {
		for _, msg := range m.SrcAddress {
			dAtA[i] = 0x3a
			i++
			i = encodeVarintNwsec_1(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.SrcSg) > 0 {
		dAtA35 := make([]byte, len(m.SrcSg)*10)
		var j34 int
		for _, num := range m.SrcSg {
			for num >= 1<<7 {
				dAtA35[j34] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j34++
			}
			dAtA35[j34] = uint8(num)
			j34++
		}
		dAtA[i] = 0x42
		i++
		i = encodeVarintNwsec_1(dAtA, i, uint64(j34))
		i += copy(dAtA[i:], dAtA35[:j34])
	}
	if len(m.DstAddress) > 0 {
		for _, msg := range m.DstAddress {
			dAtA[i] = 0x4a
			i++
			i = encodeVarintNwsec_1(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.DstSg) > 0 {
		dAtA37 := make([]byte, len(m.DstSg)*10)
		var j36 int
		for _, num := range m.DstSg {
			for num >= 1<<7 {
				dAtA37[j36] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j36++
			}
			dAtA37[j36] = uint8(num)
			j36++
		}
		dAtA[i] = 0x52
		i++
		i = encodeVarintNwsec_1(dAtA, i, uint64(j36))
		i += copy(dAtA[i:], dAtA37[:j36])
	}
	if len(m.DstPortRange) > 0 {
		for _, msg := range m.DstPortRange {
			dAtA[i] = 0x5a
			i++
			i = encodeVarintNwsec_1(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.SrcPortRange) > 0 {
		for _, msg := range m.SrcPortRange {
			dAtA[i] = 0x62
			i++
			i = encodeVarintNwsec_1(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.ConnTrackEn {
		dAtA[i] = 0x68
		i++
		if m.ConnTrackEn {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Enforce {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x6
		i++
		if m.Enforce {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *SecurityRuleStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityRuleStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SecurityRuleHandle != 0 {
		dAtA[i] = 0x9
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.SecurityRuleHandle))
		i += 8
	}
	return i, nil
}

func (m *SecurityRule) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityRule) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNwsec_1(dAtA, i, uint64(m.Meta.Size()))
		n38, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n38
	}
	if m.Spec != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNwsec_1(dAtA, i, uint64(m.Spec.Size()))
		n39, err := m.Spec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n39
	}
	if m.Status != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintNwsec_1(dAtA, i, uint64(m.Status.Size()))
		n40, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n40
	}
	return i, nil
}

func (m *SecurityRuleRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityRuleRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintNwsec_1(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SecurityRuleResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityRuleResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNwsec_1(dAtA, i, uint64(m.ApiStatus))
	}
	if m.Status != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNwsec_1(dAtA, i, uint64(m.Status.Size()))
		n41, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n41
	}
	return i, nil
}

func (m *SecurityRuleResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityRuleResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintNwsec_1(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SecurityRuleDeleteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityRuleDeleteRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNwsec_1(dAtA, i, uint64(m.Meta.Size()))
		n42, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n42
	}
	if m.RuleKeyOrHandle != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNwsec_1(dAtA, i, uint64(m.RuleKeyOrHandle.Size()))
		n43, err := m.RuleKeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n43
	}
	return i, nil
}

func (m *SecurityRuleDeleteRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityRuleDeleteRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintNwsec_1(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SecurityRuleDeleteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityRuleDeleteResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNwsec_1(dAtA, i, uint64(m.ApiStatus))
	}
	return i, nil
}

func (m *SecurityRuleDeleteResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityRuleDeleteResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintNwsec_1(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SecurityRuleGet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityRuleGet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNwsec_1(dAtA, i, uint64(m.Meta.Size()))
		n44, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n44
	}
	if m.KeyOrHandle != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNwsec_1(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n45, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n45
	}
	return i, nil
}

func (m *SecurityRuleGetMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityRuleGetMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintNwsec_1(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SecurityRuleGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityRuleGetResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNwsec_1(dAtA, i, uint64(m.ApiStatus))
	}
	if m.Spec != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNwsec_1(dAtA, i, uint64(m.Spec.Size()))
		n46, err := m.Spec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n46
	}
	if m.Status != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintNwsec_1(dAtA, i, uint64(m.Status.Size()))
		n47, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n47
	}
	return i, nil
}

func (m *SecurityRuleGetResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityRuleGetResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintNwsec_1(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.ApiStatus != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintNwsec_1(dAtA, i, uint64(m.ApiStatus))
	}
	return i, nil
}

func encodeVarintNwsec_1(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *AddressSpec) Size() (n int) {
	var l int
	_ = l
	if m.Address != nil {
		n += m.Address.Size()
	}
	return n
}

func (m *AddressSpec_Prefix) Size() (n int) {
	var l int
	_ = l
	if m.Prefix != nil {
		l = m.Prefix.Size()
		n += 1 + l + sovNwsec_1(uint64(l))
	}
	return n
}
func (m *AddressSpec_Range) Size() (n int) {
	var l int
	_ = l
	if m.Range != nil {
		l = m.Range.Size()
		n += 1 + l + sovNwsec_1(uint64(l))
	}
	return n
}
func (m *AddressStatus) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *AddressGroupSpec) Size() (n int) {
	var l int
	_ = l
	if len(m.Address) > 0 {
		for _, e := range m.Address {
			l = e.Size()
			n += 1 + l + sovNwsec_1(uint64(l))
		}
	}
	return n
}

func (m *AddressGroupStatus) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *AddressGroup) Size() (n int) {
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovNwsec_1(uint64(l))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovNwsec_1(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovNwsec_1(uint64(l))
	}
	return n
}

func (m *IPAddressSpec) Size() (n int) {
	var l int
	_ = l
	if m.Formats != nil {
		n += m.Formats.Size()
	}
	if m.Negate {
		n += 2
	}
	return n
}

func (m *IPAddressSpec_Type) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovNwsec_1(uint64(m.Type))
	return n
}
func (m *IPAddressSpec_Prefix) Size() (n int) {
	var l int
	_ = l
	if m.Prefix != nil {
		l = m.Prefix.Size()
		n += 1 + l + sovNwsec_1(uint64(l))
	}
	return n
}
func (m *IPAddressSpec_Range) Size() (n int) {
	var l int
	_ = l
	if m.Range != nil {
		l = m.Range.Size()
		n += 1 + l + sovNwsec_1(uint64(l))
	}
	return n
}
func (m *IPAddressSpec_Address) Size() (n int) {
	var l int
	_ = l
	if m.Address != nil {
		l = m.Address.Size()
		n += 1 + l + sovNwsec_1(uint64(l))
	}
	return n
}
func (m *IPAddressSpec_AddrGrp) Size() (n int) {
	var l int
	_ = l
	if m.AddrGrp != nil {
		l = m.AddrGrp.Size()
		n += 1 + l + sovNwsec_1(uint64(l))
	}
	return n
}
func (m *App) Size() (n int) {
	var l int
	_ = l
	if m.Protocol != 0 {
		n += 1 + sovNwsec_1(uint64(m.Protocol))
	}
	if m.L4AppInfo != nil {
		n += m.L4AppInfo.Size()
	}
	if m.Alg != 0 {
		n += 1 + sovNwsec_1(uint64(m.Alg))
	}
	if m.AppOptions != nil {
		n += m.AppOptions.Size()
	}
	if m.IdleTimeout != 0 {
		n += 1 + sovNwsec_1(uint64(m.IdleTimeout))
	}
	if m.TraceOpts != nil {
		l = m.TraceOpts.Size()
		n += 1 + l + sovNwsec_1(uint64(l))
	}
	return n
}

func (m *App_PortInfo) Size() (n int) {
	var l int
	_ = l
	if m.PortInfo != nil {
		l = m.PortInfo.Size()
		n += 1 + l + sovNwsec_1(uint64(l))
	}
	return n
}
func (m *App_IcmpInfo) Size() (n int) {
	var l int
	_ = l
	if m.IcmpInfo != nil {
		l = m.IcmpInfo.Size()
		n += 1 + l + sovNwsec_1(uint64(l))
	}
	return n
}
func (m *App_Icmpv6Info) Size() (n int) {
	var l int
	_ = l
	if m.Icmpv6Info != nil {
		l = m.Icmpv6Info.Size()
		n += 1 + l + sovNwsec_1(uint64(l))
	}
	return n
}
func (m *App_RpcInfo) Size() (n int) {
	var l int
	_ = l
	if m.RpcInfo != nil {
		l = m.RpcInfo.Size()
		n += 1 + l + sovNwsec_1(uint64(l))
	}
	return n
}
func (m *App_MsrpcCinfo) Size() (n int) {
	var l int
	_ = l
	if m.MsrpcCinfo != nil {
		l = m.MsrpcCinfo.Size()
		n += 1 + l + sovNwsec_1(uint64(l))
	}
	return n
}
func (m *App_FtpOptionInfo) Size() (n int) {
	var l int
	_ = l
	if m.FtpOptionInfo != nil {
		l = m.FtpOptionInfo.Size()
		n += 1 + l + sovNwsec_1(uint64(l))
	}
	return n
}
func (m *App_DnsOptionInfo) Size() (n int) {
	var l int
	_ = l
	if m.DnsOptionInfo != nil {
		l = m.DnsOptionInfo.Size()
		n += 1 + l + sovNwsec_1(uint64(l))
	}
	return n
}
func (m *App_MsrpCoptionInfo) Size() (n int) {
	var l int
	_ = l
	if m.MsrpCoptionInfo != nil {
		l = m.MsrpCoptionInfo.Size()
		n += 1 + l + sovNwsec_1(uint64(l))
	}
	return n
}
func (m *App_SunRpcPptionInfo) Size() (n int) {
	var l int
	_ = l
	if m.SunRpcPptionInfo != nil {
		l = m.SunRpcPptionInfo.Size()
		n += 1 + l + sovNwsec_1(uint64(l))
	}
	return n
}
func (m *App_SipOptions) Size() (n int) {
	var l int
	_ = l
	if m.SipOptions != nil {
		l = m.SipOptions.Size()
		n += 1 + l + sovNwsec_1(uint64(l))
	}
	return n
}
func (m *App_AppPortInfo) Size() (n int) {
	var l int
	_ = l
	if len(m.DstPortRange) > 0 {
		for _, e := range m.DstPortRange {
			l = e.Size()
			n += 1 + l + sovNwsec_1(uint64(l))
		}
	}
	if len(m.SrcPortRange) > 0 {
		for _, e := range m.SrcPortRange {
			l = e.Size()
			n += 1 + l + sovNwsec_1(uint64(l))
		}
	}
	return n
}

func (m *App_ICMPAppInfo) Size() (n int) {
	var l int
	_ = l
	if m.IcmpType != 0 {
		n += 1 + sovNwsec_1(uint64(m.IcmpType))
	}
	if m.IcmpCode != 0 {
		n += 1 + sovNwsec_1(uint64(m.IcmpCode))
	}
	return n
}

func (m *App_ICMPv6AppInfo) Size() (n int) {
	var l int
	_ = l
	if m.Icmpv6Type != 0 {
		n += 1 + sovNwsec_1(uint64(m.Icmpv6Type))
	}
	if m.Icmpv6Code != 0 {
		n += 1 + sovNwsec_1(uint64(m.Icmpv6Code))
	}
	return n
}

func (m *App_RPCAppInfo) Size() (n int) {
	var l int
	_ = l
	if m.ProgramNumber != 0 {
		n += 1 + sovNwsec_1(uint64(m.ProgramNumber))
	}
	return n
}

func (m *App_MSRPCAppInfo) Size() (n int) {
	var l int
	_ = l
	if m.Uuid != 0 {
		n += 1 + sovNwsec_1(uint64(m.Uuid))
	}
	return n
}

func (m *App_TraceOptions) Size() (n int) {
	var l int
	_ = l
	if m.Level != 0 {
		n += 1 + sovNwsec_1(uint64(m.Level))
	}
	return n
}

func (m *App_FTPOptions) Size() (n int) {
	var l int
	_ = l
	if m.AllowMismatchIpAddress {
		n += 2
	}
	if m.FtpSslExtension {
		n += 2
	}
	if m.LineBreakExtension {
		n += 2
	}
	return n
}

func (m *App_DNSOptions) Size() (n int) {
	var l int
	_ = l
	if m.DropMultiQuestionPackets {
		n += 2
	}
	if m.DropLargeDomainNamePackets {
		n += 2
	}
	if m.DropLongLabelPackets != 0 {
		n += 1 + sovNwsec_1(uint64(m.DropLongLabelPackets))
	}
	if m.DropMultizonePackets != 0 {
		n += 1 + sovNwsec_1(uint64(m.DropMultizonePackets))
	}
	if m.MaxMsgLength != 0 {
		n += 1 + sovNwsec_1(uint64(m.MaxMsgLength))
	}
	return n
}

func (m *App_MSRPCOptions) Size() (n int) {
	var l int
	_ = l
	if m.MapEntryTimeout != 0 {
		n += 1 + sovNwsec_1(uint64(m.MapEntryTimeout))
	}
	return n
}

func (m *App_SunRPCOptions) Size() (n int) {
	var l int
	_ = l
	if m.MapEntryTimeout != 0 {
		n += 1 + sovNwsec_1(uint64(m.MapEntryTimeout))
	}
	return n
}

func (m *App_SIPOptions) Size() (n int) {
	var l int
	_ = l
	if m.Ctimeout != 0 {
		n += 1 + sovNwsec_1(uint64(m.Ctimeout))
	}
	if m.DscpCodePoint != 0 {
		n += 1 + sovNwsec_1(uint64(m.DscpCodePoint))
	}
	if m.MediaInactivityTimeout != 0 {
		n += 1 + sovNwsec_1(uint64(m.MediaInactivityTimeout))
	}
	if m.MaxCallDuration != 0 {
		n += 1 + sovNwsec_1(uint64(m.MaxCallDuration))
	}
	if m.T1TimerValue != 0 {
		n += 1 + sovNwsec_1(uint64(m.T1TimerValue))
	}
	if m.T4TimerValue != 0 {
		n += 1 + sovNwsec_1(uint64(m.T4TimerValue))
	}
	return n
}

func (m *ApplicationSpec) Size() (n int) {
	var l int
	_ = l
	if m.Apps != nil {
		n += m.Apps.Size()
	}
	return n
}

func (m *ApplicationSpec_PredefinedApps) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovNwsec_1(uint64(m.PredefinedApps))
	return n
}
func (m *ApplicationSpec_Appln) Size() (n int) {
	var l int
	_ = l
	if m.Appln != nil {
		l = m.Appln.Size()
		n += 1 + l + sovNwsec_1(uint64(l))
	}
	return n
}
func (m *ApplicationStatus) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *Application) Size() (n int) {
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovNwsec_1(uint64(l))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovNwsec_1(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovNwsec_1(uint64(l))
	}
	return n
}

func (m *AppGroupSpec) Size() (n int) {
	var l int
	_ = l
	if len(m.Apps) > 0 {
		for _, e := range m.Apps {
			l = e.Size()
			n += 1 + l + sovNwsec_1(uint64(l))
		}
	}
	return n
}

func (m *AppGroupStatus) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *AppGroup) Size() (n int) {
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovNwsec_1(uint64(l))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovNwsec_1(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovNwsec_1(uint64(l))
	}
	return n
}

func (m *SecurityRuleAction) Size() (n int) {
	var l int
	_ = l
	if m.SecAction != 0 {
		n += 1 + sovNwsec_1(uint64(m.SecAction))
	}
	if m.LogAction != 0 {
		n += 1 + sovNwsec_1(uint64(m.LogAction))
	}
	return n
}

func (m *SecurityRuleSpec) Size() (n int) {
	var l int
	_ = l
	if m.RuleId != 0 {
		n += 1 + sovNwsec_1(uint64(m.RuleId))
	}
	if m.Enable {
		n += 2
	}
	if m.Action != nil {
		l = m.Action.Size()
		n += 1 + l + sovNwsec_1(uint64(l))
	}
	if m.Count {
		n += 2
	}
	if len(m.App) > 0 {
		for _, e := range m.App {
			l = e.Size()
			n += 1 + l + sovNwsec_1(uint64(l))
		}
	}
	if len(m.AppGroup) > 0 {
		for _, e := range m.AppGroup {
			l = e.Size()
			n += 1 + l + sovNwsec_1(uint64(l))
		}
	}
	if len(m.SrcAddress) > 0 {
		for _, e := range m.SrcAddress {
			l = e.Size()
			n += 1 + l + sovNwsec_1(uint64(l))
		}
	}
	if len(m.SrcSg) > 0 {
		l = 0
		for _, e := range m.SrcSg {
			l += sovNwsec_1(uint64(e))
		}
		n += 1 + sovNwsec_1(uint64(l)) + l
	}
	if len(m.DstAddress) > 0 {
		for _, e := range m.DstAddress {
			l = e.Size()
			n += 1 + l + sovNwsec_1(uint64(l))
		}
	}
	if len(m.DstSg) > 0 {
		l = 0
		for _, e := range m.DstSg {
			l += sovNwsec_1(uint64(e))
		}
		n += 1 + sovNwsec_1(uint64(l)) + l
	}
	if len(m.DstPortRange) > 0 {
		for _, e := range m.DstPortRange {
			l = e.Size()
			n += 1 + l + sovNwsec_1(uint64(l))
		}
	}
	if len(m.SrcPortRange) > 0 {
		for _, e := range m.SrcPortRange {
			l = e.Size()
			n += 1 + l + sovNwsec_1(uint64(l))
		}
	}
	if m.ConnTrackEn {
		n += 2
	}
	if m.Enforce {
		n += 3
	}
	return n
}

func (m *SecurityRuleStatus) Size() (n int) {
	var l int
	_ = l
	if m.SecurityRuleHandle != 0 {
		n += 9
	}
	return n
}

func (m *SecurityRule) Size() (n int) {
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovNwsec_1(uint64(l))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovNwsec_1(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovNwsec_1(uint64(l))
	}
	return n
}

func (m *SecurityRuleRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovNwsec_1(uint64(l))
		}
	}
	return n
}

func (m *SecurityRuleResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovNwsec_1(uint64(m.ApiStatus))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovNwsec_1(uint64(l))
	}
	return n
}

func (m *SecurityRuleResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovNwsec_1(uint64(l))
		}
	}
	return n
}

func (m *SecurityRuleDeleteRequest) Size() (n int) {
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovNwsec_1(uint64(l))
	}
	if m.RuleKeyOrHandle != nil {
		l = m.RuleKeyOrHandle.Size()
		n += 1 + l + sovNwsec_1(uint64(l))
	}
	return n
}

func (m *SecurityRuleDeleteRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovNwsec_1(uint64(l))
		}
	}
	return n
}

func (m *SecurityRuleDeleteResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovNwsec_1(uint64(m.ApiStatus))
	}
	return n
}

func (m *SecurityRuleDeleteResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovNwsec_1(uint64(l))
		}
	}
	return n
}

func (m *SecurityRuleGet) Size() (n int) {
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovNwsec_1(uint64(l))
	}
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovNwsec_1(uint64(l))
	}
	return n
}

func (m *SecurityRuleGetMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovNwsec_1(uint64(l))
		}
	}
	return n
}

func (m *SecurityRuleGetResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovNwsec_1(uint64(m.ApiStatus))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovNwsec_1(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovNwsec_1(uint64(l))
	}
	return n
}

func (m *SecurityRuleGetResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovNwsec_1(uint64(l))
		}
	}
	if m.ApiStatus != 0 {
		n += 1 + sovNwsec_1(uint64(m.ApiStatus))
	}
	return n
}

func sovNwsec_1(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozNwsec_1(x uint64) (n int) {
	return sovNwsec_1(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *AddressSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec_1
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddressSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddressSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prefix", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec_1
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec_1
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &IPSubnet{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Address = &AddressSpec_Prefix{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Range", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec_1
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec_1
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AddressRange{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Address = &AddressSpec_Range{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec_1(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec_1
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddressStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec_1
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddressStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddressStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec_1(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec_1
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddressGroupSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec_1
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddressGroupSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddressGroupSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec_1
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec_1
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = append(m.Address, &Address{})
			if err := m.Address[len(m.Address)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec_1(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec_1
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddressGroupStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec_1
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddressGroupStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddressGroupStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec_1(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec_1
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddressGroup) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec_1
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddressGroup: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddressGroup: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec_1
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec_1
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &ObjectMeta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec_1
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec_1
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &AddressGroupSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec_1
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec_1
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &AddressGroupStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec_1(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec_1
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IPAddressSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec_1
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IPAddressSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IPAddressSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var v IPAddressType
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec_1
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (IPAddressType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Formats = &IPAddressSpec_Type{v}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prefix", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec_1
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec_1
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &IPSubnet{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Formats = &IPAddressSpec_Prefix{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Range", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec_1
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec_1
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AddressRange{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Formats = &IPAddressSpec_Range{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec_1
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec_1
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Address{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Formats = &IPAddressSpec_Address{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddrGrp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec_1
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec_1
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AddressGroup{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Formats = &IPAddressSpec_AddrGrp{v}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Negate", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec_1
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Negate = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec_1(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec_1
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *App) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec_1
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: App: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: App: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			m.Protocol = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec_1
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Protocol |= (IPProtocol(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec_1
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec_1
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &App_AppPortInfo{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.L4AppInfo = &App_PortInfo{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IcmpInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec_1
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec_1
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &App_ICMPAppInfo{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.L4AppInfo = &App_IcmpInfo{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Icmpv6Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec_1
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec_1
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &App_ICMPv6AppInfo{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.L4AppInfo = &App_Icmpv6Info{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RpcInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec_1
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec_1
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &App_RPCAppInfo{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.L4AppInfo = &App_RpcInfo{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsrpcCinfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec_1
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec_1
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &App_MSRPCAppInfo{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.L4AppInfo = &App_MsrpcCinfo{v}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Alg", wireType)
			}
			m.Alg = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec_1
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Alg |= (PredefinedApps(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FtpOptionInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec_1
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec_1
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &App_FTPOptions{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AppOptions = &App_FtpOptionInfo{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DnsOptionInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec_1
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec_1
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &App_DNSOptions{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AppOptions = &App_DnsOptionInfo{v}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsrpCoptionInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec_1
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec_1
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &App_MSRPCOptions{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AppOptions = &App_MsrpCoptionInfo{v}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SunRpcPptionInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec_1
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec_1
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &App_SunRPCOptions{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AppOptions = &App_SunRpcPptionInfo{v}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SipOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec_1
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec_1
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &App_SIPOptions{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AppOptions = &App_SipOptions{v}
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdleTimeout", wireType)
			}
			m.IdleTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec_1
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IdleTimeout |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TraceOpts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec_1
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec_1
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TraceOpts == nil {
				m.TraceOpts = &App_TraceOptions{}
			}
			if err := m.TraceOpts.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec_1(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec_1
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *App_AppPortInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec_1
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppPortInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppPortInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstPortRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec_1
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec_1
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DstPortRange = append(m.DstPortRange, &L4PortRange{})
			if err := m.DstPortRange[len(m.DstPortRange)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcPortRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec_1
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec_1
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SrcPortRange = append(m.SrcPortRange, &L4PortRange{})
			if err := m.SrcPortRange[len(m.SrcPortRange)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec_1(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec_1
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *App_ICMPAppInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec_1
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ICMPAppInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ICMPAppInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IcmpType", wireType)
			}
			m.IcmpType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec_1
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IcmpType |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IcmpCode", wireType)
			}
			m.IcmpCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec_1
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IcmpCode |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec_1(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec_1
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *App_ICMPv6AppInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec_1
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ICMPv6AppInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ICMPv6AppInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Icmpv6Type", wireType)
			}
			m.Icmpv6Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec_1
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Icmpv6Type |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Icmpv6Code", wireType)
			}
			m.Icmpv6Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec_1
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Icmpv6Code |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec_1(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec_1
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *App_RPCAppInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec_1
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RPCAppInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RPCAppInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProgramNumber", wireType)
			}
			m.ProgramNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec_1
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProgramNumber |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec_1(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec_1
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *App_MSRPCAppInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec_1
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MSRPCAppInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MSRPCAppInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			m.Uuid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec_1
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uuid |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec_1(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec_1
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *App_TraceOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec_1
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TraceOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TraceOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec_1
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= (App_TraceLevel(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec_1(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec_1
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *App_FTPOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec_1
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FTPOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FTPOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowMismatchIpAddress", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec_1
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AllowMismatchIpAddress = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FtpSslExtension", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec_1
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FtpSslExtension = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LineBreakExtension", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec_1
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LineBreakExtension = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec_1(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec_1
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *App_DNSOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec_1
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DNSOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DNSOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropMultiQuestionPackets", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec_1
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DropMultiQuestionPackets = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropLargeDomainNamePackets", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec_1
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DropLargeDomainNamePackets = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropLongLabelPackets", wireType)
			}
			m.DropLongLabelPackets = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec_1
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DropLongLabelPackets |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropMultizonePackets", wireType)
			}
			m.DropMultizonePackets = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec_1
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DropMultizonePackets |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxMsgLength", wireType)
			}
			m.MaxMsgLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec_1
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxMsgLength |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec_1(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec_1
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *App_MSRPCOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec_1
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MSRPCOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MSRPCOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapEntryTimeout", wireType)
			}
			m.MapEntryTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec_1
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MapEntryTimeout |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec_1(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec_1
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *App_SunRPCOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec_1
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SunRPCOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SunRPCOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapEntryTimeout", wireType)
			}
			m.MapEntryTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec_1
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MapEntryTimeout |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec_1(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec_1
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *App_SIPOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec_1
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SIPOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SIPOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ctimeout", wireType)
			}
			m.Ctimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec_1
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ctimeout |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DscpCodePoint", wireType)
			}
			m.DscpCodePoint = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec_1
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DscpCodePoint |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MediaInactivityTimeout", wireType)
			}
			m.MediaInactivityTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec_1
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MediaInactivityTimeout |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxCallDuration", wireType)
			}
			m.MaxCallDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec_1
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxCallDuration |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field T1TimerValue", wireType)
			}
			m.T1TimerValue = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec_1
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.T1TimerValue |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field T4TimerValue", wireType)
			}
			m.T4TimerValue = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec_1
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.T4TimerValue |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec_1(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec_1
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ApplicationSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec_1
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ApplicationSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ApplicationSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PredefinedApps", wireType)
			}
			var v PredefinedApps
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec_1
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (PredefinedApps(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Apps = &ApplicationSpec_PredefinedApps{v}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Appln", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec_1
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec_1
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &App{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Apps = &ApplicationSpec_Appln{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec_1(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec_1
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ApplicationStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec_1
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ApplicationStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ApplicationStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec_1(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec_1
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Application) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec_1
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Application: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Application: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec_1
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec_1
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &ObjectMeta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec_1
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec_1
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &ApplicationSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec_1
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec_1
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &ApplicationStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec_1(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec_1
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppGroupSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec_1
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppGroupSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppGroupSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Apps", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec_1
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec_1
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Apps = append(m.Apps, &Application{})
			if err := m.Apps[len(m.Apps)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec_1(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec_1
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppGroupStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec_1
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppGroupStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppGroupStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec_1(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec_1
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppGroup) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec_1
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppGroup: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppGroup: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec_1
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec_1
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &ObjectMeta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec_1
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec_1
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &AppGroupSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec_1
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec_1
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &AppGroupStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec_1(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec_1
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityRuleAction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec_1
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityRuleAction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityRuleAction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecAction", wireType)
			}
			m.SecAction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec_1
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SecAction |= (SecurityAction(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogAction", wireType)
			}
			m.LogAction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec_1
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LogAction |= (LogAction(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec_1(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec_1
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityRuleSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec_1
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityRuleSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityRuleSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuleId", wireType)
			}
			m.RuleId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec_1
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RuleId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec_1
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enable = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec_1
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec_1
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Action == nil {
				m.Action = &SecurityRuleAction{}
			}
			if err := m.Action.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec_1
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Count = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field App", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec_1
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec_1
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.App = append(m.App, &Application{})
			if err := m.App[len(m.App)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppGroup", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec_1
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec_1
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppGroup = append(m.AppGroup, &AppGroup{})
			if err := m.AppGroup[len(m.AppGroup)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcAddress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec_1
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec_1
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SrcAddress = append(m.SrcAddress, &IPAddressSpec{})
			if err := m.SrcAddress[len(m.SrcAddress)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNwsec_1
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SrcSg = append(m.SrcSg, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNwsec_1
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthNwsec_1
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNwsec_1
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SrcSg = append(m.SrcSg, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcSg", wireType)
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstAddress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec_1
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec_1
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DstAddress = append(m.DstAddress, &IPAddressSpec{})
			if err := m.DstAddress[len(m.DstAddress)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNwsec_1
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.DstSg = append(m.DstSg, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNwsec_1
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthNwsec_1
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNwsec_1
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.DstSg = append(m.DstSg, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field DstSg", wireType)
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstPortRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec_1
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec_1
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DstPortRange = append(m.DstPortRange, &L4PortRange{})
			if err := m.DstPortRange[len(m.DstPortRange)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcPortRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec_1
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec_1
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SrcPortRange = append(m.SrcPortRange, &L4PortRange{})
			if err := m.SrcPortRange[len(m.SrcPortRange)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnTrackEn", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec_1
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ConnTrackEn = bool(v != 0)
		case 100:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enforce", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec_1
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enforce = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec_1(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec_1
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityRuleStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec_1
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityRuleStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityRuleStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecurityRuleHandle", wireType)
			}
			m.SecurityRuleHandle = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.SecurityRuleHandle = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec_1(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec_1
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityRule) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec_1
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityRule: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityRule: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec_1
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec_1
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &ObjectMeta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec_1
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec_1
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &SecurityRuleSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec_1
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec_1
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &SecurityRuleStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec_1(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec_1
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityRuleRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec_1
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityRuleRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityRuleRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec_1
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec_1
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &SecurityRule{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec_1(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec_1
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityRuleResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec_1
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityRuleResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityRuleResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec_1
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec_1
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec_1
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &SecurityRuleStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec_1(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec_1
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityRuleResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec_1
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityRuleResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityRuleResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec_1
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec_1
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &SecurityRuleResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec_1(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec_1
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityRuleDeleteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec_1
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityRuleDeleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityRuleDeleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec_1
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec_1
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &ObjectMeta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuleKeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec_1
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec_1
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RuleKeyOrHandle == nil {
				m.RuleKeyOrHandle = &SecurityRuleKeyHandle{}
			}
			if err := m.RuleKeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec_1(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec_1
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityRuleDeleteRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec_1
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityRuleDeleteRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityRuleDeleteRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec_1
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec_1
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &SecurityRuleDeleteRequest{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec_1(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec_1
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityRuleDeleteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec_1
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityRuleDeleteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityRuleDeleteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec_1
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec_1(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec_1
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityRuleDeleteResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec_1
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityRuleDeleteResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityRuleDeleteResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec_1
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec_1
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &SecurityRuleDeleteResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec_1(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec_1
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityRuleGet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec_1
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityRuleGet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityRuleGet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec_1
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec_1
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &ObjectMeta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec_1
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec_1
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &SecurityRuleKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec_1(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec_1
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityRuleGetMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec_1
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityRuleGetMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityRuleGetMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec_1
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec_1
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &SecurityRuleGet{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec_1(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec_1
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityRuleGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec_1
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityRuleGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityRuleGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec_1
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec_1
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec_1
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &SecurityRuleSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec_1
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec_1
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &SecurityRuleStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec_1(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec_1
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityRuleGetResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNwsec_1
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityRuleGetResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityRuleGetResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec_1
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNwsec_1
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &SecurityRuleGetResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNwsec_1
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNwsec_1(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNwsec_1
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipNwsec_1(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowNwsec_1
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowNwsec_1
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowNwsec_1
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthNwsec_1
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowNwsec_1
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipNwsec_1(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthNwsec_1 = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowNwsec_1   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("nwsec_1.proto", fileDescriptorNwsec_1) }

var fileDescriptorNwsec_1 = []byte{
	// 2374 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x58, 0x4b, 0x6f, 0xdb, 0xd8,
	0xf5, 0x37, 0x25, 0x5b, 0x96, 0x8f, 0x5e, 0xf4, 0xf5, 0x23, 0xb2, 0x32, 0xe3, 0x78, 0xf4, 0x9f,
	0x87, 0xff, 0x9e, 0x4e, 0x9a, 0x64, 0x3c, 0xe9, 0x34, 0xe9, 0x20, 0x95, 0x65, 0xda, 0x56, 0x2b,
	0xcb, 0xca, 0x95, 0x9c, 0x36, 0x03, 0xb4, 0x04, 0x4d, 0x5d, 0xcb, 0xac, 0x29, 0xf2, 0x96, 0x97,
	0x4a, 0xec, 0x76, 0xd1, 0x07, 0xd0, 0xc5, 0x74, 0x53, 0xa0, 0x0f, 0xa0, 0xeb, 0x02, 0xdd, 0xf6,
	0x03, 0x74, 0x5f, 0xa0, 0xcb, 0x7e, 0x82, 0x41, 0x91, 0x6e, 0x8a, 0x59, 0xf7, 0x03, 0x14, 0xf7,
	0xf2, 0x92, 0x22, 0x25, 0x39, 0x71, 0xa7, 0xe9, 0x22, 0x88, 0xee, 0x39, 0xbf, 0xdf, 0xe1, 0x79,
	0xdc, 0x73, 0x78, 0x68, 0x28, 0x38, 0xcf, 0x19, 0x31, 0xf5, 0xbb, 0xb7, 0xa9, 0xe7, 0xfa, 0x2e,
	0x9a, 0x13, 0xc7, 0x4a, 0xce, 0xbf, 0xa4, 0x84, 0x05, 0xb2, 0x4a, 0xf6, 0xfc, 0x2c, 0xf8, 0x55,
	0xa5, 0x90, 0xab, 0xf5, 0x7a, 0x1e, 0x61, 0xac, 0x43, 0x89, 0x89, 0xfe, 0x1f, 0x32, 0xd4, 0x23,
	0xa7, 0xd6, 0x45, 0x59, 0xd9, 0x50, 0x36, 0x73, 0xf7, 0x4a, 0xb7, 0x03, 0x5a, 0xa3, 0xdd, 0x19,
	0x9e, 0x38, 0xc4, 0x3f, 0x98, 0xc1, 0x12, 0x80, 0xde, 0x87, 0x39, 0xcf, 0x70, 0xfa, 0xa4, 0x9c,
	0x12, 0xc8, 0x25, 0x89, 0x94, 0xd6, 0x30, 0x57, 0x1d, 0xcc, 0xe0, 0x00, 0xb3, 0xb3, 0x00, 0xf3,
	0x52, 0x51, 0x2d, 0x41, 0x21, 0x7c, 0xa2, 0x6f, 0xf8, 0x43, 0x56, 0xfd, 0x06, 0xa8, 0x52, 0xb0,
	0xef, 0xb9, 0x43, 0x2a, 0xfc, 0xd8, 0x84, 0x79, 0x23, 0x90, 0x95, 0x95, 0x8d, 0xf4, 0x66, 0xee,
	0x5e, 0x71, 0xcc, 0x7c, 0xa8, 0xae, 0x2e, 0x03, 0x4a, 0xb0, 0x03, 0x9b, 0xbf, 0x53, 0x20, 0x1f,
	0x17, 0xa3, 0x77, 0x60, 0x76, 0x40, 0x7c, 0x43, 0x86, 0xb5, 0x28, 0xad, 0x1d, 0x9d, 0xfc, 0x80,
	0x98, 0xfe, 0x21, 0xf1, 0x0d, 0x2c, 0xd4, 0xe8, 0x7d, 0x98, 0x65, 0x94, 0x98, 0x32, 0xa6, 0x1b,
	0xb7, 0x45, 0xee, 0x6e, 0x8f, 0xbb, 0x87, 0x05, 0x08, 0xdd, 0x85, 0x0c, 0x13, 0x8f, 0x2b, 0xa7,
	0x05, 0x7c, 0x6d, 0x1a, 0x5c, 0x00, 0xb0, 0x04, 0x56, 0x7f, 0x9b, 0x82, 0x42, 0xa3, 0x1d, 0xcf,
	0xf8, 0x16, 0xcc, 0x72, 0x5f, 0x84, 0x63, 0xc5, 0x7b, 0xcb, 0x51, 0xbe, 0x25, 0xa6, 0x7b, 0x49,
	0x79, 0x1a, 0x05, 0x26, 0x56, 0x9d, 0xd4, 0xb5, 0xab, 0x93, 0x7e, 0x75, 0x75, 0xd0, 0xd6, 0x28,
	0xdb, 0xb3, 0x02, 0x3e, 0x96, 0xed, 0x83, 0x99, 0x28, 0xdf, 0xe8, 0x0e, 0x64, 0xf9, 0x4f, 0xbd,
	0xef, 0xd1, 0xf2, 0x9c, 0xb4, 0x3d, 0x19, 0x76, 0xc8, 0xd8, 0xf7, 0x28, 0x5a, 0x85, 0x8c, 0x43,
	0xfa, 0x86, 0x4f, 0xca, 0x99, 0x0d, 0x65, 0x33, 0x8b, 0xe5, 0x89, 0xdf, 0x89, 0x3d, 0xd7, 0x1b,
	0x18, 0x3e, 0xab, 0xfe, 0x65, 0x11, 0xd2, 0x35, 0x4a, 0xd1, 0x07, 0x90, 0x15, 0xd7, 0xd2, 0x74,
	0x6d, 0x99, 0x90, 0xc5, 0x28, 0xc4, 0xb6, 0x54, 0xe0, 0x08, 0x82, 0x3e, 0x82, 0x05, 0xea, 0x7a,
	0xbe, 0x6e, 0x39, 0xa7, 0xae, 0x4c, 0xc9, 0x6a, 0xe8, 0x0c, 0xa5, 0xfc, 0x5f, 0xdb, 0xf5, 0xfc,
	0x86, 0x73, 0xea, 0x1e, 0xcc, 0xe0, 0x2c, 0x95, 0xbf, 0x39, 0xcd, 0x32, 0x07, 0x34, 0xa0, 0xa5,
	0x27, 0x68, 0x8d, 0xfa, 0x61, 0xbb, 0x46, 0x69, 0x48, 0xe3, 0x50, 0x41, 0x7b, 0x08, 0x39, 0xfe,
	0xfb, 0xd9, 0xfd, 0x80, 0x18, 0x64, 0xaa, 0x3c, 0x46, 0x7c, 0x76, 0x7f, 0x44, 0x85, 0x00, 0x2e,
	0xc8, 0xf7, 0x20, 0xeb, 0x51, 0x33, 0x60, 0x06, 0x69, 0x5b, 0x89, 0x31, 0x71, 0xbb, 0x3e, 0xa2,
	0xcd, 0x7b, 0xd4, 0x14, 0x9c, 0x07, 0x90, 0x1b, 0x30, 0xce, 0x32, 0x05, 0x2d, 0x93, 0xbc, 0x93,
	0x94, 0xde, 0x3e, 0xec, 0x24, 0x88, 0x20, 0xd0, 0x75, 0x0e, 0x46, 0xef, 0x41, 0xda, 0xb0, 0xfb,
	0xe5, 0x79, 0x91, 0xc4, 0xf0, 0x51, 0x6d, 0x8f, 0xf4, 0xc8, 0xa9, 0xe5, 0x90, 0x5e, 0x8d, 0x52,
	0x86, 0x39, 0x02, 0x3d, 0x82, 0xd2, 0xa9, 0x4f, 0x75, 0x97, 0xfa, 0x96, 0xeb, 0x04, 0xfe, 0x65,
	0x27, 0xfc, 0xdb, 0xeb, 0xb6, 0x8f, 0x04, 0x80, 0x1d, 0x28, 0xb8, 0x70, 0xea, 0xd3, 0xe0, 0x24,
	0xbc, 0x7c, 0x04, 0xa5, 0x9e, 0xc3, 0x12, 0x06, 0x16, 0x26, 0x0c, 0xec, 0xb6, 0x3a, 0x31, 0x03,
	0x3d, 0x87, 0xc5, 0x0c, 0x68, 0xb0, 0xc8, 0x1d, 0xd7, 0xcd, 0xb8, 0x09, 0x98, 0x1e, 0xec, 0xc8,
	0x48, 0x89, 0x73, 0xea, 0xee, 0xc8, 0x4c, 0x03, 0x96, 0xd8, 0xd0, 0xd1, 0x79, 0xbe, 0x68, 0xcc,
	0x50, 0x6e, 0xa2, 0x4c, 0x9d, 0xa1, 0x93, 0xb0, 0xa4, 0xb2, 0xa1, 0x83, 0xa9, 0xd9, 0x1e, 0x99,
	0xfa, 0x18, 0x72, 0xcc, 0x0a, 0x73, 0xc2, 0xca, 0xf9, 0x89, 0x70, 0x3a, 0x8d, 0x58, 0x3e, 0x80,
	0x59, 0x32, 0x1f, 0x0c, 0xbd, 0x05, 0x79, 0xab, 0x67, 0x13, 0xdd, 0xb7, 0x06, 0xc4, 0x1d, 0xfa,
	0xe5, 0xc2, 0x86, 0xb2, 0x59, 0xc0, 0x39, 0x2e, 0xeb, 0x06, 0x22, 0x74, 0x1f, 0xc0, 0xf7, 0x0c,
	0x93, 0x70, 0xf3, 0xac, 0x5c, 0x9c, 0x88, 0xb3, 0xcb, 0x95, 0xd2, 0x1e, 0x5e, 0xf0, 0xe5, 0x89,
	0x55, 0x7e, 0xa6, 0x40, 0x2e, 0x76, 0xa3, 0xd1, 0xc7, 0x50, 0xec, 0x31, 0x5f, 0x17, 0x0d, 0x10,
	0xb4, 0x7a, 0x30, 0x29, 0x91, 0xec, 0x98, 0xe6, 0x36, 0x87, 0x8a, 0x4e, 0xc7, 0xf9, 0x1e, 0xf3,
	0xa3, 0x13, 0x67, 0x32, 0xcf, 0x8c, 0x33, 0x53, 0x57, 0x33, 0x99, 0x67, 0x46, 0xa7, 0xca, 0x3e,
	0xe4, 0x62, 0xdd, 0x81, 0x6e, 0xca, 0x46, 0x8a, 0x06, 0x58, 0x21, 0x68, 0x17, 0x3e, 0xb4, 0x22,
	0xa5, 0xe9, 0xf6, 0x82, 0x77, 0x84, 0x54, 0xd6, 0xdd, 0x1e, 0xa9, 0x3c, 0x86, 0x42, 0xa2, 0x5b,
	0xd0, 0xad, 0xa8, 0xb9, 0x62, 0xc6, 0x64, 0x03, 0x09, 0x73, 0x23, 0x40, 0xcc, 0xa0, 0x04, 0x08,
	0x93, 0x1f, 0x02, 0x8c, 0xba, 0x01, 0xbd, 0x03, 0x45, 0xea, 0xb9, 0x7d, 0xcf, 0x18, 0xe8, 0xce,
	0x70, 0x70, 0x42, 0x3c, 0x69, 0xb2, 0x20, 0xa5, 0x2d, 0x21, 0xac, 0x54, 0x21, 0x1f, 0x6f, 0x22,
	0x84, 0x60, 0x76, 0x38, 0xb4, 0x7a, 0x12, 0x2c, 0x7e, 0x57, 0x1e, 0x42, 0x3e, 0x5e, 0x13, 0x3e,
	0x5a, 0x6d, 0xf2, 0x8c, 0x84, 0x13, 0x6a, 0x65, 0xbc, 0x76, 0x4d, 0xae, 0xc4, 0x01, 0xa6, 0xf2,
	0x47, 0x05, 0x60, 0xd4, 0x3d, 0xe8, 0xeb, 0xb0, 0x66, 0xd8, 0xb6, 0xfb, 0x5c, 0x1f, 0x58, 0x6c,
	0x60, 0xf8, 0xe6, 0x99, 0x6e, 0x51, 0x7d, 0xf4, 0xa6, 0xe3, 0xe3, 0x71, 0x55, 0x00, 0x0e, 0xa5,
	0xbe, 0x41, 0xe5, 0x58, 0x45, 0x5b, 0xb0, 0xc8, 0x1b, 0x95, 0x31, 0x5b, 0x27, 0x17, 0x3e, 0x71,
	0x98, 0xe5, 0x3a, 0x22, 0x0d, 0x59, 0xcc, 0x3b, 0xb8, 0xc3, 0x6c, 0x2d, 0x14, 0xa3, 0x3b, 0xb0,
	0x6c, 0x5b, 0x0e, 0xd1, 0x4f, 0x3c, 0x62, 0x9c, 0xc7, 0xe0, 0x69, 0x01, 0x47, 0x5c, 0xb7, 0xc3,
	0x55, 0x11, 0xa3, 0xf2, 0x87, 0x14, 0xc0, 0xa8, 0x49, 0xd1, 0x27, 0x70, 0xb3, 0xe7, 0xb9, 0x54,
	0x1f, 0x0c, 0x6d, 0xdf, 0xd2, 0x7f, 0x38, 0x24, 0x4c, 0x74, 0x14, 0x35, 0xcc, 0x73, 0xe2, 0x87,
	0x9e, 0x96, 0x39, 0xe4, 0x90, 0x23, 0x1e, 0x4b, 0x40, 0x3b, 0xd0, 0xa3, 0x1d, 0x58, 0x17, 0x74,
	0xdb, 0xf0, 0xfa, 0x44, 0xef, 0xb9, 0x03, 0xc3, 0x72, 0x74, 0xc7, 0x18, 0x90, 0xc8, 0x42, 0xe0,
	0x78, 0x85, 0xa3, 0x9a, 0x1c, 0xb4, 0x2b, 0x30, 0x2d, 0x63, 0x40, 0x42, 0x1b, 0x1f, 0xc1, 0x8d,
	0xc0, 0x86, 0xeb, 0xf4, 0x75, 0xdb, 0x38, 0x21, 0x76, 0x44, 0x4e, 0x8b, 0xea, 0x2c, 0x0b, 0xb2,
	0xeb, 0xf4, 0x9b, 0x5c, 0x19, 0xd2, 0xb6, 0x61, 0x75, 0xe4, 0xf9, 0x8f, 0x5c, 0x67, 0xf4, 0xc8,
	0xd9, 0x11, 0xeb, 0x30, 0x54, 0x86, 0xac, 0xb7, 0xa1, 0x38, 0x30, 0x2e, 0xf4, 0x01, 0xeb, 0xeb,
	0x36, 0x71, 0xfa, 0xfe, 0x99, 0x18, 0xd2, 0x05, 0x9c, 0x1f, 0x18, 0x17, 0x87, 0xac, 0xdf, 0x14,
	0xb2, 0xca, 0x03, 0x79, 0x5b, 0xc2, 0x2c, 0x6d, 0xc1, 0xe2, 0xc0, 0xa0, 0x3a, 0x71, 0x7c, 0xef,
	0x32, 0x6a, 0xf9, 0xe0, 0xea, 0x94, 0x06, 0x06, 0xd5, 0xb8, 0x5c, 0xb6, 0x7d, 0xe5, 0x21, 0x14,
	0x12, 0x83, 0xe7, 0x3f, 0x22, 0xff, 0x3c, 0x05, 0x30, 0x9a, 0x39, 0xa8, 0x02, 0x59, 0x33, 0xc9,
	0x88, 0xce, 0xe8, 0x5d, 0x28, 0xf5, 0x98, 0x19, 0xb4, 0x9d, 0x4e, 0x5d, 0xcb, 0xf1, 0x65, 0xaf,
	0x14, 0xb8, 0x98, 0x77, 0x4a, 0x9b, 0x0b, 0xd1, 0xc7, 0x50, 0x1e, 0x90, 0x9e, 0x65, 0xe8, 0x96,
	0x63, 0x98, 0xbe, 0xf5, 0xcc, 0xf2, 0x47, 0x5e, 0x04, 0xf9, 0x5d, 0x15, 0xfa, 0x46, 0xa4, 0x0e,
	0x07, 0x98, 0x70, 0xfc, 0x42, 0x37, 0x0d, 0xdb, 0xd6, 0x7b, 0x43, 0xcf, 0xe0, 0x3e, 0xc9, 0xe4,
	0x96, 0x06, 0xc6, 0x45, 0xdd, 0xb0, 0xed, 0x5d, 0x29, 0xe6, 0x79, 0xf5, 0xef, 0x0a, 0xbb, 0x9e,
	0xfe, 0xcc, 0xb0, 0x87, 0x24, 0xcc, 0xab, 0x7f, 0x97, 0x9b, 0xf3, 0x9e, 0x70, 0x99, 0x40, 0x6d,
	0x27, 0x50, 0x19, 0x89, 0xda, 0x1e, 0xa1, 0xaa, 0xbf, 0x50, 0x00, 0x46, 0x0d, 0x86, 0x96, 0x41,
	0xed, 0xe2, 0x5a, 0x5d, 0xd3, 0x9b, 0xda, 0x13, 0xad, 0xa9, 0xb7, 0x8e, 0x5a, 0x9a, 0x3a, 0x83,
	0x56, 0x60, 0x31, 0x2e, 0xdd, 0xc1, 0x0d, 0x6d, 0x4f, 0x55, 0xd0, 0x2a, 0xa0, 0xb8, 0x78, 0x57,
	0xeb, 0xd6, 0x1a, 0x4d, 0x35, 0x85, 0xd6, 0x60, 0x25, 0x2e, 0xd7, 0xbe, 0xdb, 0xd5, 0x5a, 0x9d,
	0xc6, 0x13, 0x4d, 0x4d, 0xa3, 0x1b, 0xb0, 0x14, 0x57, 0x3d, 0xd1, 0xf0, 0xce, 0x51, 0x47, 0x53,
	0x67, 0x77, 0x72, 0xb0, 0xd0, 0xdc, 0x96, 0x03, 0x63, 0x27, 0x0f, 0x50, 0xa3, 0xe1, 0xf8, 0xaf,
	0xfe, 0x04, 0x4a, 0x35, 0x4a, 0x6d, 0xcb, 0x14, 0xd1, 0x8b, 0xfd, 0xee, 0x9b, 0x50, 0xa2, 0xd1,
	0x6b, 0x57, 0x37, 0x28, 0x65, 0x63, 0x73, 0x23, 0xf9, 0x52, 0x3e, 0x98, 0xc1, 0x45, 0x9a, 0x90,
	0xa0, 0x2a, 0xcc, 0x19, 0x94, 0xda, 0x8e, 0xdc, 0x70, 0x60, 0x34, 0x6f, 0xf8, 0x06, 0x27, 0x54,
	0x3b, 0x19, 0x98, 0xe5, 0xa6, 0xab, 0x4b, 0xb0, 0x18, 0x77, 0x20, 0x58, 0x3a, 0x7f, 0x1d, 0xbc,
	0x39, 0x42, 0xe9, 0x75, 0x77, 0xe1, 0xad, 0xc4, 0x2e, 0x1c, 0xdb, 0x90, 0xe2, 0xf1, 0xc9, 0x55,
	0xf8, 0xce, 0xd8, 0x2a, 0x5c, 0x9e, 0x82, 0x4e, 0x6e, 0xc2, 0xf7, 0x21, 0x5f, 0xa3, 0x74, 0xb4,
	0xf1, 0xbf, 0x0b, 0xb3, 0x3c, 0xda, 0xe8, 0x55, 0x34, 0xc1, 0xc7, 0x42, 0x5f, 0x55, 0xa1, 0x18,
	0xf1, 0x02, 0x4b, 0x9f, 0x29, 0x90, 0x0d, 0x45, 0xd7, 0x8d, 0xed, 0xbd, 0x44, 0x6c, 0x4b, 0xa3,
	0xa7, 0x8d, 0xef, 0xf8, 0x1f, 0x8c, 0x05, 0xb6, 0x32, 0x0e, 0x4d, 0x46, 0xf5, 0x63, 0x40, 0x1d,
	0x62, 0x0e, 0x3d, 0xcb, 0xbf, 0xc4, 0x43, 0x9b, 0xd4, 0x4c, 0x91, 0xf0, 0x6d, 0x00, 0xfe, 0x45,
	0x66, 0x88, 0xd3, 0x58, 0xf9, 0x43, 0x78, 0x00, 0xc5, 0x0b, 0x8c, 0x98, 0x92, 0xf5, 0x55, 0x00,
	0xdb, 0xed, 0x87, 0xac, 0x94, 0x60, 0xa9, 0x92, 0xd5, 0x74, 0xfb, 0x21, 0xc1, 0x0e, 0x7f, 0x56,
	0xff, 0x34, 0x0b, 0x6a, 0xfc, 0xe9, 0x22, 0xaf, 0x37, 0x60, 0xde, 0x1b, 0xda, 0x44, 0x8f, 0x5e,
	0x6a, 0x19, 0x7e, 0x6c, 0xf4, 0xf8, 0x5a, 0x4e, 0x1c, 0xe3, 0xc4, 0x26, 0x72, 0x16, 0xcb, 0x13,
	0xff, 0xaa, 0x91, 0x8f, 0x4c, 0x7e, 0xd5, 0x4c, 0xc6, 0x85, 0x25, 0x10, 0x2d, 0xc3, 0x9c, 0xe9,
	0x0e, 0x1d, 0x5f, 0x4c, 0x81, 0x2c, 0x0e, 0x0e, 0xe8, 0x6d, 0x48, 0x1b, 0x94, 0x7f, 0x24, 0x5c,
	0x55, 0x50, 0xae, 0x46, 0x5f, 0x81, 0x05, 0x83, 0x52, 0xbd, 0xcf, 0x93, 0x59, 0xce, 0x08, 0x6c,
	0x69, 0x2c, 0xc7, 0x38, 0x6b, 0x84, 0xe5, 0xfd, 0x08, 0x72, 0x7c, 0x75, 0x09, 0xdf, 0x98, 0xf3,
	0x02, 0xbf, 0x2c, 0xf1, 0x89, 0x0f, 0x2b, 0x0c, 0xcc, 0x33, 0xc3, 0x77, 0xe7, 0x0a, 0x64, 0x38,
	0x8d, 0xf5, 0xcb, 0xd9, 0x8d, 0xf4, 0x66, 0x01, 0xcf, 0x31, 0xcf, 0xec, 0xf4, 0xb9, 0x35, 0xbe,
	0x42, 0x85, 0xd6, 0x16, 0x5e, 0x66, 0xad, 0xc7, 0xfc, 0x98, 0x35, 0x4e, 0x63, 0xfd, 0x32, 0x04,
	0xd6, 0x7a, 0xcc, 0xef, 0xf4, 0xa7, 0x2c, 0x64, 0xb9, 0x2f, 0xbd, 0x90, 0xe5, 0xaf, 0xb7, 0x90,
	0xa1, 0x2a, 0x14, 0x4c, 0xd7, 0x71, 0x74, 0xbe, 0x26, 0x9e, 0xeb, 0xc4, 0x11, 0x0b, 0x67, 0x16,
	0xe7, 0xb8, 0x90, 0xcf, 0xca, 0x73, 0xcd, 0x41, 0x65, 0x98, 0x27, 0xce, 0xa9, 0xeb, 0x99, 0xa4,
	0xdc, 0x13, 0xda, 0xf0, 0x58, 0xdd, 0x4b, 0xde, 0xd6, 0xe0, 0x2e, 0xf3, 0xe5, 0x81, 0x49, 0xa9,
	0x2e, 0xae, 0xce, 0x99, 0xe1, 0xf4, 0xec, 0x60, 0x27, 0xcb, 0x60, 0xc4, 0x62, 0x8c, 0x03, 0xa1,
	0x11, 0x5f, 0xdb, 0x71, 0x43, 0xff, 0xdd, 0xd7, 0xf6, 0xf8, 0x15, 0x7e, 0xc5, 0xd7, 0xf6, 0x64,
	0x04, 0x51, 0x37, 0xee, 0xc3, 0x6a, 0x5c, 0x8b, 0x89, 0x58, 0x64, 0x0e, 0x59, 0x1f, 0x7d, 0x00,
	0xf3, 0x5e, 0x70, 0x92, 0x5b, 0xf3, 0xd2, 0x14, 0x6b, 0x38, 0xc4, 0x54, 0x7f, 0xa9, 0xc0, 0x72,
	0xd2, 0x12, 0xa3, 0xae, 0xc3, 0x08, 0x7a, 0x04, 0x60, 0x50, 0x4b, 0x97, 0x8e, 0x29, 0xb2, 0x47,
	0xe5, 0xc7, 0x33, 0xb5, 0x02, 0x7f, 0x76, 0x8a, 0x5f, 0x7c, 0x7e, 0x2b, 0x86, 0xc3, 0x0b, 0x46,
	0xa8, 0x8a, 0x45, 0x95, 0xba, 0x6e, 0x54, 0x18, 0x6e, 0x4c, 0xf3, 0x85, 0x87, 0xf5, 0x35, 0xc8,
	0x7a, 0xf2, 0x28, 0xe3, 0xba, 0x39, 0x2d, 0x2e, 0x09, 0xc1, 0x11, 0xb8, 0xfa, 0x1b, 0x05, 0xd6,
	0xe2, 0x90, 0x5d, 0x62, 0x13, 0x3f, 0x4c, 0xd8, 0x75, 0xcb, 0x79, 0x04, 0x48, 0xdc, 0x97, 0x73,
	0x72, 0xa9, 0xbb, 0x5e, 0x78, 0x6d, 0xc2, 0xb8, 0xce, 0xcf, 0x12, 0x4e, 0x7c, 0x9b, 0x5c, 0x06,
	0xb7, 0x67, 0x67, 0xfe, 0x8b, 0xcf, 0x6f, 0xa5, 0xcf, 0xc9, 0x25, 0x2e, 0x79, 0x81, 0xfc, 0xc8,
	0x93, 0xf7, 0xea, 0x53, 0x78, 0xe3, 0x4a, 0xa7, 0x78, 0xb8, 0x0f, 0xc6, 0xab, 0xb8, 0x31, 0x25,
	0xda, 0x04, 0x6b, 0x54, 0xd2, 0xef, 0x41, 0x65, 0x1a, 0xea, 0x35, 0xd5, 0xb5, 0xfa, 0x7d, 0x78,
	0xf3, 0x6a, 0xf3, 0xdc, 0xf7, 0x4f, 0x26, 0x4a, 0xf5, 0xd6, 0x4b, 0x9c, 0x9f, 0x28, 0xd8, 0x4f,
	0x15, 0x28, 0xc5, 0x81, 0xfb, 0xe4, 0xda, 0x65, 0xda, 0x83, 0xc2, 0x97, 0xad, 0x50, 0xee, 0x3c,
	0x56, 0x9d, 0xb1, 0xe9, 0xb1, 0x4f, 0x44, 0x4d, 0xee, 0x8c, 0xd7, 0x64, 0x75, 0x4a, 0x58, 0xfb,
	0x24, 0x56, 0x89, 0x3f, 0x2b, 0xc9, 0x0b, 0xcd, 0x95, 0xaf, 0xad, 0xbf, 0xfe, 0xd7, 0x23, 0xe6,
	0x33, 0x25, 0x79, 0x8f, 0x62, 0xce, 0x07, 0x37, 0x74, 0xbc, 0xca, 0xeb, 0x57, 0xa4, 0x63, 0xa2,
	0xc4, 0xfc, 0xfd, 0x1f, 0x8b, 0x3d, 0x35, 0x3d, 0xf6, 0x58, 0xac, 0x5b, 0xff, 0x54, 0xa0, 0x98,
	0xdc, 0x26, 0xd1, 0x22, 0x14, 0x6a, 0xed, 0xb6, 0xde, 0xaa, 0x1d, 0x6a, 0xe1, 0x86, 0x1c, 0x17,
	0x75, 0xf7, 0xba, 0x6d, 0x55, 0x41, 0x2a, 0xe4, 0x23, 0x11, 0x97, 0xa4, 0xf8, 0xf2, 0x1b, 0x49,
	0x3a, 0xc7, 0x2d, 0xdc, 0xae, 0xeb, 0xdd, 0x7a, 0x5b, 0x4d, 0x23, 0x04, 0xc5, 0x48, 0x21, 0xbe,
	0x85, 0xd4, 0xd9, 0x04, 0x7d, 0xb7, 0xd5, 0x51, 0xe7, 0x12, 0x92, 0x4e, 0xa3, 0xad, 0x66, 0x12,
	0x4f, 0xc5, 0xdd, 0x4e, 0x5b, 0x9d, 0x4f, 0x3c, 0x43, 0x6c, 0xda, 0xf8, 0xe8, 0xb8, 0xab, 0xa9,
	0x59, 0x54, 0x82, 0x5c, 0xa4, 0x68, 0xb4, 0xd5, 0x85, 0x84, 0xb9, 0x5a, 0xeb, 0xa9, 0x0a, 0x5b,
	0xbf, 0x52, 0xa0, 0x98, 0xdc, 0x9c, 0xd0, 0x9b, 0xb0, 0xd6, 0xd1, 0xea, 0xc7, 0xb8, 0xd1, 0x7d,
	0xaa, 0xe3, 0xe3, 0xa6, 0xa6, 0xd7, 0xea, 0xdd, 0xc6, 0x51, 0x2b, 0x0c, 0x7b, 0x1d, 0x2a, 0x53,
	0xd5, 0xb5, 0x66, 0xf3, 0xe8, 0x3b, 0xaa, 0x72, 0x25, 0x7d, 0x57, 0x6b, 0x3d, 0x55, 0x53, 0xe8,
	0x16, 0xdc, 0x9c, 0xaa, 0xc6, 0xda, 0xb7, 0xb4, 0x7a, 0x57, 0x4d, 0x6f, 0x0d, 0x60, 0x21, 0x5a,
	0xca, 0x50, 0x1e, 0xb2, 0xcd, 0xa3, 0xfd, 0xf0, 0xd1, 0x65, 0x58, 0xe6, 0xa7, 0xa3, 0x96, 0xde,
	0xd1, 0x3a, 0x1d, 0xce, 0xea, 0x74, 0x6b, 0xb8, 0x1b, 0x7c, 0x96, 0x8c, 0x69, 0xb4, 0xd6, 0xae,
	0x9a, 0x42, 0x1b, 0xf0, 0xc6, 0x34, 0x86, 0x5e, 0x6b, 0xed, 0x0a, 0x44, 0xfa, 0xde, 0xbf, 0x52,
	0x50, 0x6c, 0x3d, 0x4f, 0xbc, 0x74, 0x8f, 0x93, 0xfd, 0x58, 0xf7, 0x88, 0xe1, 0x13, 0xf4, 0xe6,
	0xd4, 0x17, 0x40, 0x38, 0x42, 0x2b, 0xeb, 0x2f, 0x79, 0x3f, 0x1c, 0xb2, 0x7e, 0x75, 0x66, 0xdc,
	0xec, 0x31, 0xed, 0xbd, 0x16, 0xb3, 0x46, 0xd2, 0x6c, 0x30, 0xe8, 0xd0, 0xff, 0xbd, 0x6a, 0x80,
	0x73, 0xe3, 0x6f, 0xbf, 0x72, 0x50, 0x06, 0x8f, 0x78, 0x3c, 0x39, 0x22, 0xd7, 0xa6, 0x77, 0x1f,
	0xb7, 0xfa, 0xd6, 0xcb, 0x1b, 0x53, 0x98, 0xdc, 0xa9, 0xfc, 0xf5, 0xc5, 0xba, 0xf2, 0xb7, 0x17,
	0xeb, 0xca, 0xdf, 0x5f, 0xac, 0x2b, 0xbf, 0xff, 0xc7, 0xfa, 0xcc, 0xa7, 0xd9, 0x33, 0xc3, 0x16,
	0x7f, 0x90, 0x3e, 0xc9, 0x88, 0xff, 0x3e, 0xfc, 0x77, 0x00, 0x00, 0x00, 0xff, 0xff, 0x04, 0x5b,
	0xf4, 0x76, 0x80, 0x19, 0x00, 0x00,
}
