// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: nic/proto/types.proto

package halproto

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import gogoproto "github.com/gogo/protobuf/gogoproto"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// goproto_enum_prefix from public import protos/github/gogo/protobuf/gogoproto/gogo.proto
var E_GoprotoEnumPrefix = gogoproto.E_GoprotoEnumPrefix

// goproto_enum_stringer from public import protos/github/gogo/protobuf/gogoproto/gogo.proto
var E_GoprotoEnumStringer = gogoproto.E_GoprotoEnumStringer

// enum_stringer from public import protos/github/gogo/protobuf/gogoproto/gogo.proto
var E_EnumStringer = gogoproto.E_EnumStringer

// enum_customname from public import protos/github/gogo/protobuf/gogoproto/gogo.proto
var E_EnumCustomname = gogoproto.E_EnumCustomname

// enumdecl from public import protos/github/gogo/protobuf/gogoproto/gogo.proto
var E_Enumdecl = gogoproto.E_Enumdecl

// enumvalue_customname from public import protos/github/gogo/protobuf/gogoproto/gogo.proto
var E_EnumvalueCustomname = gogoproto.E_EnumvalueCustomname

// goproto_getters_all from public import protos/github/gogo/protobuf/gogoproto/gogo.proto
var E_GoprotoGettersAll = gogoproto.E_GoprotoGettersAll

// goproto_enum_prefix_all from public import protos/github/gogo/protobuf/gogoproto/gogo.proto
var E_GoprotoEnumPrefixAll = gogoproto.E_GoprotoEnumPrefixAll

// goproto_stringer_all from public import protos/github/gogo/protobuf/gogoproto/gogo.proto
var E_GoprotoStringerAll = gogoproto.E_GoprotoStringerAll

// verbose_equal_all from public import protos/github/gogo/protobuf/gogoproto/gogo.proto
var E_VerboseEqualAll = gogoproto.E_VerboseEqualAll

// face_all from public import protos/github/gogo/protobuf/gogoproto/gogo.proto
var E_FaceAll = gogoproto.E_FaceAll

// gostring_all from public import protos/github/gogo/protobuf/gogoproto/gogo.proto
var E_GostringAll = gogoproto.E_GostringAll

// populate_all from public import protos/github/gogo/protobuf/gogoproto/gogo.proto
var E_PopulateAll = gogoproto.E_PopulateAll

// stringer_all from public import protos/github/gogo/protobuf/gogoproto/gogo.proto
var E_StringerAll = gogoproto.E_StringerAll

// onlyone_all from public import protos/github/gogo/protobuf/gogoproto/gogo.proto
var E_OnlyoneAll = gogoproto.E_OnlyoneAll

// equal_all from public import protos/github/gogo/protobuf/gogoproto/gogo.proto
var E_EqualAll = gogoproto.E_EqualAll

// description_all from public import protos/github/gogo/protobuf/gogoproto/gogo.proto
var E_DescriptionAll = gogoproto.E_DescriptionAll

// testgen_all from public import protos/github/gogo/protobuf/gogoproto/gogo.proto
var E_TestgenAll = gogoproto.E_TestgenAll

// benchgen_all from public import protos/github/gogo/protobuf/gogoproto/gogo.proto
var E_BenchgenAll = gogoproto.E_BenchgenAll

// marshaler_all from public import protos/github/gogo/protobuf/gogoproto/gogo.proto
var E_MarshalerAll = gogoproto.E_MarshalerAll

// unmarshaler_all from public import protos/github/gogo/protobuf/gogoproto/gogo.proto
var E_UnmarshalerAll = gogoproto.E_UnmarshalerAll

// stable_marshaler_all from public import protos/github/gogo/protobuf/gogoproto/gogo.proto
var E_StableMarshalerAll = gogoproto.E_StableMarshalerAll

// sizer_all from public import protos/github/gogo/protobuf/gogoproto/gogo.proto
var E_SizerAll = gogoproto.E_SizerAll

// goproto_enum_stringer_all from public import protos/github/gogo/protobuf/gogoproto/gogo.proto
var E_GoprotoEnumStringerAll = gogoproto.E_GoprotoEnumStringerAll

// enum_stringer_all from public import protos/github/gogo/protobuf/gogoproto/gogo.proto
var E_EnumStringerAll = gogoproto.E_EnumStringerAll

// unsafe_marshaler_all from public import protos/github/gogo/protobuf/gogoproto/gogo.proto
var E_UnsafeMarshalerAll = gogoproto.E_UnsafeMarshalerAll

// unsafe_unmarshaler_all from public import protos/github/gogo/protobuf/gogoproto/gogo.proto
var E_UnsafeUnmarshalerAll = gogoproto.E_UnsafeUnmarshalerAll

// goproto_extensions_map_all from public import protos/github/gogo/protobuf/gogoproto/gogo.proto
var E_GoprotoExtensionsMapAll = gogoproto.E_GoprotoExtensionsMapAll

// goproto_unrecognized_all from public import protos/github/gogo/protobuf/gogoproto/gogo.proto
var E_GoprotoUnrecognizedAll = gogoproto.E_GoprotoUnrecognizedAll

// gogoproto_import from public import protos/github/gogo/protobuf/gogoproto/gogo.proto
var E_GogoprotoImport = gogoproto.E_GogoprotoImport

// protosizer_all from public import protos/github/gogo/protobuf/gogoproto/gogo.proto
var E_ProtosizerAll = gogoproto.E_ProtosizerAll

// compare_all from public import protos/github/gogo/protobuf/gogoproto/gogo.proto
var E_CompareAll = gogoproto.E_CompareAll

// typedecl_all from public import protos/github/gogo/protobuf/gogoproto/gogo.proto
var E_TypedeclAll = gogoproto.E_TypedeclAll

// enumdecl_all from public import protos/github/gogo/protobuf/gogoproto/gogo.proto
var E_EnumdeclAll = gogoproto.E_EnumdeclAll

// goproto_registration from public import protos/github/gogo/protobuf/gogoproto/gogo.proto
var E_GoprotoRegistration = gogoproto.E_GoprotoRegistration

// goproto_getters from public import protos/github/gogo/protobuf/gogoproto/gogo.proto
var E_GoprotoGetters = gogoproto.E_GoprotoGetters

// goproto_stringer from public import protos/github/gogo/protobuf/gogoproto/gogo.proto
var E_GoprotoStringer = gogoproto.E_GoprotoStringer

// verbose_equal from public import protos/github/gogo/protobuf/gogoproto/gogo.proto
var E_VerboseEqual = gogoproto.E_VerboseEqual

// face from public import protos/github/gogo/protobuf/gogoproto/gogo.proto
var E_Face = gogoproto.E_Face

// gostring from public import protos/github/gogo/protobuf/gogoproto/gogo.proto
var E_Gostring = gogoproto.E_Gostring

// populate from public import protos/github/gogo/protobuf/gogoproto/gogo.proto
var E_Populate = gogoproto.E_Populate

// stringer from public import protos/github/gogo/protobuf/gogoproto/gogo.proto
var E_Stringer = gogoproto.E_Stringer

// onlyone from public import protos/github/gogo/protobuf/gogoproto/gogo.proto
var E_Onlyone = gogoproto.E_Onlyone

// equal from public import protos/github/gogo/protobuf/gogoproto/gogo.proto
var E_Equal = gogoproto.E_Equal

// description from public import protos/github/gogo/protobuf/gogoproto/gogo.proto
var E_Description = gogoproto.E_Description

// testgen from public import protos/github/gogo/protobuf/gogoproto/gogo.proto
var E_Testgen = gogoproto.E_Testgen

// benchgen from public import protos/github/gogo/protobuf/gogoproto/gogo.proto
var E_Benchgen = gogoproto.E_Benchgen

// marshaler from public import protos/github/gogo/protobuf/gogoproto/gogo.proto
var E_Marshaler = gogoproto.E_Marshaler

// unmarshaler from public import protos/github/gogo/protobuf/gogoproto/gogo.proto
var E_Unmarshaler = gogoproto.E_Unmarshaler

// stable_marshaler from public import protos/github/gogo/protobuf/gogoproto/gogo.proto
var E_StableMarshaler = gogoproto.E_StableMarshaler

// sizer from public import protos/github/gogo/protobuf/gogoproto/gogo.proto
var E_Sizer = gogoproto.E_Sizer

// unsafe_marshaler from public import protos/github/gogo/protobuf/gogoproto/gogo.proto
var E_UnsafeMarshaler = gogoproto.E_UnsafeMarshaler

// unsafe_unmarshaler from public import protos/github/gogo/protobuf/gogoproto/gogo.proto
var E_UnsafeUnmarshaler = gogoproto.E_UnsafeUnmarshaler

// goproto_extensions_map from public import protos/github/gogo/protobuf/gogoproto/gogo.proto
var E_GoprotoExtensionsMap = gogoproto.E_GoprotoExtensionsMap

// goproto_unrecognized from public import protos/github/gogo/protobuf/gogoproto/gogo.proto
var E_GoprotoUnrecognized = gogoproto.E_GoprotoUnrecognized

// protosizer from public import protos/github/gogo/protobuf/gogoproto/gogo.proto
var E_Protosizer = gogoproto.E_Protosizer

// compare from public import protos/github/gogo/protobuf/gogoproto/gogo.proto
var E_Compare = gogoproto.E_Compare

// typedecl from public import protos/github/gogo/protobuf/gogoproto/gogo.proto
var E_Typedecl = gogoproto.E_Typedecl

// nullable from public import protos/github/gogo/protobuf/gogoproto/gogo.proto
var E_Nullable = gogoproto.E_Nullable

// embed from public import protos/github/gogo/protobuf/gogoproto/gogo.proto
var E_Embed = gogoproto.E_Embed

// customtype from public import protos/github/gogo/protobuf/gogoproto/gogo.proto
var E_Customtype = gogoproto.E_Customtype

// customname from public import protos/github/gogo/protobuf/gogoproto/gogo.proto
var E_Customname = gogoproto.E_Customname

// jsontag from public import protos/github/gogo/protobuf/gogoproto/gogo.proto
var E_Jsontag = gogoproto.E_Jsontag

// moretags from public import protos/github/gogo/protobuf/gogoproto/gogo.proto
var E_Moretags = gogoproto.E_Moretags

// casttype from public import protos/github/gogo/protobuf/gogoproto/gogo.proto
var E_Casttype = gogoproto.E_Casttype

// castkey from public import protos/github/gogo/protobuf/gogoproto/gogo.proto
var E_Castkey = gogoproto.E_Castkey

// castvalue from public import protos/github/gogo/protobuf/gogoproto/gogo.proto
var E_Castvalue = gogoproto.E_Castvalue

// stdtime from public import protos/github/gogo/protobuf/gogoproto/gogo.proto
var E_Stdtime = gogoproto.E_Stdtime

// stdduration from public import protos/github/gogo/protobuf/gogoproto/gogo.proto
var E_Stdduration = gogoproto.E_Stdduration

// IP protocol numbers
type IPProtocol int32

const (
	IPProtocol_IPPROTO_NONE   IPProtocol = 0
	IPProtocol_IPPROTO_ICMP   IPProtocol = 1
	IPProtocol_IPPROTO_IPV4   IPProtocol = 4
	IPProtocol_IPPROTO_TCP    IPProtocol = 6
	IPProtocol_IPPROTO_UDP    IPProtocol = 17
	IPProtocol_IPPROTO_GRE    IPProtocol = 47
	IPProtocol_IPPROTO_ESP    IPProtocol = 50
	IPProtocol_IPPROTO_AH     IPProtocol = 51
	IPProtocol_IPPROTO_ICMPV6 IPProtocol = 58
)

var IPProtocol_name = map[int32]string{
	0:  "IPPROTO_NONE",
	1:  "IPPROTO_ICMP",
	4:  "IPPROTO_IPV4",
	6:  "IPPROTO_TCP",
	17: "IPPROTO_UDP",
	47: "IPPROTO_GRE",
	50: "IPPROTO_ESP",
	51: "IPPROTO_AH",
	58: "IPPROTO_ICMPV6",
}
var IPProtocol_value = map[string]int32{
	"IPPROTO_NONE":   0,
	"IPPROTO_ICMP":   1,
	"IPPROTO_IPV4":   4,
	"IPPROTO_TCP":    6,
	"IPPROTO_UDP":    17,
	"IPPROTO_GRE":    47,
	"IPPROTO_ESP":    50,
	"IPPROTO_AH":     51,
	"IPPROTO_ICMPV6": 58,
}

func (x IPProtocol) String() string {
	return proto.EnumName(IPProtocol_name, int32(x))
}
func (IPProtocol) EnumDescriptor() ([]byte, []int) { return fileDescriptorTypes, []int{0} }

// ICMP message types
// TBD - add more here !!
type ICMPMsgType int32

const (
	ICMPMsgType_ICMP_MSG_TYPE_NONE ICMPMsgType = 0
	ICMPMsgType_ICMP_MSG_TYPE_ECHO ICMPMsgType = 1
)

var ICMPMsgType_name = map[int32]string{
	0: "ICMP_MSG_TYPE_NONE",
	1: "ICMP_MSG_TYPE_ECHO",
}
var ICMPMsgType_value = map[string]int32{
	"ICMP_MSG_TYPE_NONE": 0,
	"ICMP_MSG_TYPE_ECHO": 1,
}

func (x ICMPMsgType) String() string {
	return proto.EnumName(ICMPMsgType_name, int32(x))
}
func (ICMPMsgType) EnumDescriptor() ([]byte, []int) { return fileDescriptorTypes, []int{1} }

// API return codes (more descriptive than protobuf enums)
type ApiStatus int32

const (
	ApiStatus_API_STATUS_OK                           ApiStatus = 0
	ApiStatus_API_STATUS_ERR                          ApiStatus = 1
	ApiStatus_API_STATUS_INVALID_ARG                  ApiStatus = 2
	ApiStatus_API_STATUS_EXISTS_ALREADY               ApiStatus = 3
	ApiStatus_API_STATUS_OUT_OF_MEM                   ApiStatus = 4
	ApiStatus_API_STATUS_NOT_FOUND                    ApiStatus = 5
	ApiStatus_API_STATUS_OUT_OF_RESOURCE              ApiStatus = 6
	ApiStatus_API_STATUS_ENCAP_INVALID                ApiStatus = 7
	ApiStatus_API_STATUS_TENANT_ID_INVALID            ApiStatus = 8
	ApiStatus_API_STATUS_TENANT_NOT_FOUND             ApiStatus = 9
	ApiStatus_API_STATUS_L2_SEGMENT_ID_INVALID        ApiStatus = 10
	ApiStatus_API_STATUS_L2_SEGMENT_NOT_FOUND         ApiStatus = 11
	ApiStatus_API_STATUS_INTERFACE_ID_INVALID         ApiStatus = 12
	ApiStatus_API_STATUS_INTERFACE_NOT_FOUND          ApiStatus = 13
	ApiStatus_API_STATUS_IF_TYPE_INVALID              ApiStatus = 14
	ApiStatus_API_STATUS_IF_INFO_INVALID              ApiStatus = 15
	ApiStatus_API_STATUS_IF_L2SEGMENT_INVALID         ApiStatus = 16
	ApiStatus_API_STATUS_IF_ENIC_INFO_INVALID         ApiStatus = 17
	ApiStatus_API_STATUS_IF_ENIC_TYPE_INVALID         ApiStatus = 18
	ApiStatus_API_STATUS_IF_LIF_INFO_NOT_INVALID      ApiStatus = 19
	ApiStatus_API_STATUS_IF_LIFQ_INFO_NOT_INVALID     ApiStatus = 20
	ApiStatus_API_STATUS_ENDPOINT_NOT_FOUND           ApiStatus = 21
	ApiStatus_API_STATUS_FLOW_KEY_INVALID             ApiStatus = 22
	ApiStatus_API_STATUS_FLOW_INFO_INVALID            ApiStatus = 23
	ApiStatus_API_STATUS_FLOW_NOT_FOUND               ApiStatus = 24
	ApiStatus_API_STATUS_SESSION_NOT_FOUND            ApiStatus = 25
	ApiStatus_API_STATUS_HANDLE_INVALID               ApiStatus = 26
	ApiStatus_API_STATUS_HW_PROG_ERR                  ApiStatus = 27
	ApiStatus_API_STATUS_LIF_ID_INVALID               ApiStatus = 28
	ApiStatus_API_STATUS_LIF_NOT_FOUND                ApiStatus = 29
	ApiStatus_API_STATUS_NWSEC_PROFILE_ID_INVALID     ApiStatus = 30
	ApiStatus_API_STATUS_NWSEC_PROFILE_NOT_FOUND      ApiStatus = 31
	ApiStatus_API_STATUS_TLS_CB_ID_INVALID            ApiStatus = 32
	ApiStatus_API_STATUS_TLS_CB_NOT_FOUND             ApiStatus = 33
	ApiStatus_API_STATUS_TCP_CB_ID_INVALID            ApiStatus = 34
	ApiStatus_API_STATUS_TCP_CB_NOT_FOUND             ApiStatus = 35
	ApiStatus_API_STATUS_BUF_POOL_ID_INVALID          ApiStatus = 36
	ApiStatus_API_STATUS_BUF_POOL_NOT_FOUND           ApiStatus = 37
	ApiStatus_API_STATUS_BUF_POOL_COS_MAP_EXISTS      ApiStatus = 38
	ApiStatus_API_STATUS_QUEUE_ID_INVALID             ApiStatus = 39
	ApiStatus_API_STATUS_QUEUE_COUNT_INVALID          ApiStatus = 40
	ApiStatus_API_STATUS_QUEUE_NOT_FOUND              ApiStatus = 41
	ApiStatus_API_STATUS_POLICER_ID_INVALID           ApiStatus = 42
	ApiStatus_API_STATUS_POLICER_NOT_FOUND            ApiStatus = 43
	ApiStatus_API_STATUS_NETWORK_NOT_FOUND            ApiStatus = 44
	ApiStatus_API_STATUS_ACL_ID_INVALID               ApiStatus = 45
	ApiStatus_API_STATUS_ACL_NOT_FOUND                ApiStatus = 46
	ApiStatus_API_STATUS_WRING_ID_INVALID             ApiStatus = 47
	ApiStatus_API_STATUS_WRING_NOT_FOUND              ApiStatus = 48
	ApiStatus_API_STATUS_WRING_TYPE_INVALID           ApiStatus = 49
	ApiStatus_API_STATUS_PROXY_TYPE_INVALID           ApiStatus = 50
	ApiStatus_API_STATUS_IPSEC_CB_ID_INVALID          ApiStatus = 51
	ApiStatus_API_STATUS_IPSEC_CB_NOT_FOUND           ApiStatus = 52
	ApiStatus_API_STATUS_L4LB_KEY_INVALID             ApiStatus = 53
	ApiStatus_API_STATUS_CPU_CB_ID_INVALID            ApiStatus = 54
	ApiStatus_API_STATUS_CPU_CB_NOT_FOUND             ApiStatus = 55
	ApiStatus_API_STATUS_PROXY_NOT_ENABLED            ApiStatus = 56
	ApiStatus_API_STATUS_PROXY_FLOW_NOT_FOUND         ApiStatus = 57
	ApiStatus_API_STATUS_CFG_DB_ERR                   ApiStatus = 58
	ApiStatus_API_STATUS_SECURITY_GROUP_ID_INVALID    ApiStatus = 59
	ApiStatus_API_STATUS_ENDPOINT_UPD_KEY_HDL_INVALID ApiStatus = 60
	ApiStatus_API_STATUS_DOS_POLICY_ID_INVALID        ApiStatus = 61
	ApiStatus_API_STATUS_DOS_POLICY_NOT_FOUND         ApiStatus = 62
	ApiStatus_API_STATUS_RAWR_CB_ID_INVALID           ApiStatus = 63
	ApiStatus_API_STATUS_RAWR_CB_NOT_FOUND            ApiStatus = 64
	ApiStatus_API_STATUS_REFERENCES_EXIST             ApiStatus = 65
)

var ApiStatus_name = map[int32]string{
	0:  "API_STATUS_OK",
	1:  "API_STATUS_ERR",
	2:  "API_STATUS_INVALID_ARG",
	3:  "API_STATUS_EXISTS_ALREADY",
	4:  "API_STATUS_OUT_OF_MEM",
	5:  "API_STATUS_NOT_FOUND",
	6:  "API_STATUS_OUT_OF_RESOURCE",
	7:  "API_STATUS_ENCAP_INVALID",
	8:  "API_STATUS_TENANT_ID_INVALID",
	9:  "API_STATUS_TENANT_NOT_FOUND",
	10: "API_STATUS_L2_SEGMENT_ID_INVALID",
	11: "API_STATUS_L2_SEGMENT_NOT_FOUND",
	12: "API_STATUS_INTERFACE_ID_INVALID",
	13: "API_STATUS_INTERFACE_NOT_FOUND",
	14: "API_STATUS_IF_TYPE_INVALID",
	15: "API_STATUS_IF_INFO_INVALID",
	16: "API_STATUS_IF_L2SEGMENT_INVALID",
	17: "API_STATUS_IF_ENIC_INFO_INVALID",
	18: "API_STATUS_IF_ENIC_TYPE_INVALID",
	19: "API_STATUS_IF_LIF_INFO_NOT_INVALID",
	20: "API_STATUS_IF_LIFQ_INFO_NOT_INVALID",
	21: "API_STATUS_ENDPOINT_NOT_FOUND",
	22: "API_STATUS_FLOW_KEY_INVALID",
	23: "API_STATUS_FLOW_INFO_INVALID",
	24: "API_STATUS_FLOW_NOT_FOUND",
	25: "API_STATUS_SESSION_NOT_FOUND",
	26: "API_STATUS_HANDLE_INVALID",
	27: "API_STATUS_HW_PROG_ERR",
	28: "API_STATUS_LIF_ID_INVALID",
	29: "API_STATUS_LIF_NOT_FOUND",
	30: "API_STATUS_NWSEC_PROFILE_ID_INVALID",
	31: "API_STATUS_NWSEC_PROFILE_NOT_FOUND",
	32: "API_STATUS_TLS_CB_ID_INVALID",
	33: "API_STATUS_TLS_CB_NOT_FOUND",
	34: "API_STATUS_TCP_CB_ID_INVALID",
	35: "API_STATUS_TCP_CB_NOT_FOUND",
	36: "API_STATUS_BUF_POOL_ID_INVALID",
	37: "API_STATUS_BUF_POOL_NOT_FOUND",
	38: "API_STATUS_BUF_POOL_COS_MAP_EXISTS",
	39: "API_STATUS_QUEUE_ID_INVALID",
	40: "API_STATUS_QUEUE_COUNT_INVALID",
	41: "API_STATUS_QUEUE_NOT_FOUND",
	42: "API_STATUS_POLICER_ID_INVALID",
	43: "API_STATUS_POLICER_NOT_FOUND",
	44: "API_STATUS_NETWORK_NOT_FOUND",
	45: "API_STATUS_ACL_ID_INVALID",
	46: "API_STATUS_ACL_NOT_FOUND",
	47: "API_STATUS_WRING_ID_INVALID",
	48: "API_STATUS_WRING_NOT_FOUND",
	49: "API_STATUS_WRING_TYPE_INVALID",
	50: "API_STATUS_PROXY_TYPE_INVALID",
	51: "API_STATUS_IPSEC_CB_ID_INVALID",
	52: "API_STATUS_IPSEC_CB_NOT_FOUND",
	53: "API_STATUS_L4LB_KEY_INVALID",
	54: "API_STATUS_CPU_CB_ID_INVALID",
	55: "API_STATUS_CPU_CB_NOT_FOUND",
	56: "API_STATUS_PROXY_NOT_ENABLED",
	57: "API_STATUS_PROXY_FLOW_NOT_FOUND",
	58: "API_STATUS_CFG_DB_ERR",
	59: "API_STATUS_SECURITY_GROUP_ID_INVALID",
	60: "API_STATUS_ENDPOINT_UPD_KEY_HDL_INVALID",
	61: "API_STATUS_DOS_POLICY_ID_INVALID",
	62: "API_STATUS_DOS_POLICY_NOT_FOUND",
	63: "API_STATUS_RAWR_CB_ID_INVALID",
	64: "API_STATUS_RAWR_CB_NOT_FOUND",
	65: "API_STATUS_REFERENCES_EXIST",
}
var ApiStatus_value = map[string]int32{
	"API_STATUS_OK":                           0,
	"API_STATUS_ERR":                          1,
	"API_STATUS_INVALID_ARG":                  2,
	"API_STATUS_EXISTS_ALREADY":               3,
	"API_STATUS_OUT_OF_MEM":                   4,
	"API_STATUS_NOT_FOUND":                    5,
	"API_STATUS_OUT_OF_RESOURCE":              6,
	"API_STATUS_ENCAP_INVALID":                7,
	"API_STATUS_TENANT_ID_INVALID":            8,
	"API_STATUS_TENANT_NOT_FOUND":             9,
	"API_STATUS_L2_SEGMENT_ID_INVALID":        10,
	"API_STATUS_L2_SEGMENT_NOT_FOUND":         11,
	"API_STATUS_INTERFACE_ID_INVALID":         12,
	"API_STATUS_INTERFACE_NOT_FOUND":          13,
	"API_STATUS_IF_TYPE_INVALID":              14,
	"API_STATUS_IF_INFO_INVALID":              15,
	"API_STATUS_IF_L2SEGMENT_INVALID":         16,
	"API_STATUS_IF_ENIC_INFO_INVALID":         17,
	"API_STATUS_IF_ENIC_TYPE_INVALID":         18,
	"API_STATUS_IF_LIF_INFO_NOT_INVALID":      19,
	"API_STATUS_IF_LIFQ_INFO_NOT_INVALID":     20,
	"API_STATUS_ENDPOINT_NOT_FOUND":           21,
	"API_STATUS_FLOW_KEY_INVALID":             22,
	"API_STATUS_FLOW_INFO_INVALID":            23,
	"API_STATUS_FLOW_NOT_FOUND":               24,
	"API_STATUS_SESSION_NOT_FOUND":            25,
	"API_STATUS_HANDLE_INVALID":               26,
	"API_STATUS_HW_PROG_ERR":                  27,
	"API_STATUS_LIF_ID_INVALID":               28,
	"API_STATUS_LIF_NOT_FOUND":                29,
	"API_STATUS_NWSEC_PROFILE_ID_INVALID":     30,
	"API_STATUS_NWSEC_PROFILE_NOT_FOUND":      31,
	"API_STATUS_TLS_CB_ID_INVALID":            32,
	"API_STATUS_TLS_CB_NOT_FOUND":             33,
	"API_STATUS_TCP_CB_ID_INVALID":            34,
	"API_STATUS_TCP_CB_NOT_FOUND":             35,
	"API_STATUS_BUF_POOL_ID_INVALID":          36,
	"API_STATUS_BUF_POOL_NOT_FOUND":           37,
	"API_STATUS_BUF_POOL_COS_MAP_EXISTS":      38,
	"API_STATUS_QUEUE_ID_INVALID":             39,
	"API_STATUS_QUEUE_COUNT_INVALID":          40,
	"API_STATUS_QUEUE_NOT_FOUND":              41,
	"API_STATUS_POLICER_ID_INVALID":           42,
	"API_STATUS_POLICER_NOT_FOUND":            43,
	"API_STATUS_NETWORK_NOT_FOUND":            44,
	"API_STATUS_ACL_ID_INVALID":               45,
	"API_STATUS_ACL_NOT_FOUND":                46,
	"API_STATUS_WRING_ID_INVALID":             47,
	"API_STATUS_WRING_NOT_FOUND":              48,
	"API_STATUS_WRING_TYPE_INVALID":           49,
	"API_STATUS_PROXY_TYPE_INVALID":           50,
	"API_STATUS_IPSEC_CB_ID_INVALID":          51,
	"API_STATUS_IPSEC_CB_NOT_FOUND":           52,
	"API_STATUS_L4LB_KEY_INVALID":             53,
	"API_STATUS_CPU_CB_ID_INVALID":            54,
	"API_STATUS_CPU_CB_NOT_FOUND":             55,
	"API_STATUS_PROXY_NOT_ENABLED":            56,
	"API_STATUS_PROXY_FLOW_NOT_FOUND":         57,
	"API_STATUS_CFG_DB_ERR":                   58,
	"API_STATUS_SECURITY_GROUP_ID_INVALID":    59,
	"API_STATUS_ENDPOINT_UPD_KEY_HDL_INVALID": 60,
	"API_STATUS_DOS_POLICY_ID_INVALID":        61,
	"API_STATUS_DOS_POLICY_NOT_FOUND":         62,
	"API_STATUS_RAWR_CB_ID_INVALID":           63,
	"API_STATUS_RAWR_CB_NOT_FOUND":            64,
	"API_STATUS_REFERENCES_EXIST":             65,
}

func (x ApiStatus) String() string {
	return proto.EnumName(ApiStatus_name, int32(x))
}
func (ApiStatus) EnumDescriptor() ([]byte, []int) { return fileDescriptorTypes, []int{2} }

// Types of L2 segments
type L2SegmentType int32

const (
	L2SegmentType_L2_SEGMENT_TYPE_NONE   L2SegmentType = 0
	L2SegmentType_L2_SEGMENT_TYPE_TENANT L2SegmentType = 1
	L2SegmentType_L2_SEGMENT_TYPE_MGMT   L2SegmentType = 2
	L2SegmentType_L2_SEGMENT_TYPE_INFRA  L2SegmentType = 3
	L2SegmentType_L2_SEGMENT_PRIMARY     L2SegmentType = 4
	L2SegmentType_L2_SEGMENT_ISOLATED    L2SegmentType = 5
)

var L2SegmentType_name = map[int32]string{
	0: "L2_SEGMENT_TYPE_NONE",
	1: "L2_SEGMENT_TYPE_TENANT",
	2: "L2_SEGMENT_TYPE_MGMT",
	3: "L2_SEGMENT_TYPE_INFRA",
	4: "L2_SEGMENT_PRIMARY",
	5: "L2_SEGMENT_ISOLATED",
}
var L2SegmentType_value = map[string]int32{
	"L2_SEGMENT_TYPE_NONE":   0,
	"L2_SEGMENT_TYPE_TENANT": 1,
	"L2_SEGMENT_TYPE_MGMT":   2,
	"L2_SEGMENT_TYPE_INFRA":  3,
	"L2_SEGMENT_PRIMARY":     4,
	"L2_SEGMENT_ISOLATED":    5,
}

func (x L2SegmentType) String() string {
	return proto.EnumName(L2SegmentType_name, int32(x))
}
func (L2SegmentType) EnumDescriptor() ([]byte, []int) { return fileDescriptorTypes, []int{3} }

// Supported wire encaps for the L2 segments
type EncapType int32

const (
	EncapType_ENCAP_TYPE_NONE     EncapType = 0
	EncapType_ENCAP_TYPE_DOT1Q    EncapType = 1
	EncapType_ENCAP_TYPE_VXLAN    EncapType = 2
	EncapType_ENCAP_TYPE_IP_IN_IP EncapType = 3
	EncapType_ENCAP_TYPE_GRE      EncapType = 4
	EncapType_ENCAP_TYPE_IPSEC    EncapType = 5
)

var EncapType_name = map[int32]string{
	0: "ENCAP_TYPE_NONE",
	1: "ENCAP_TYPE_DOT1Q",
	2: "ENCAP_TYPE_VXLAN",
	3: "ENCAP_TYPE_IP_IN_IP",
	4: "ENCAP_TYPE_GRE",
	5: "ENCAP_TYPE_IPSEC",
}
var EncapType_value = map[string]int32{
	"ENCAP_TYPE_NONE":     0,
	"ENCAP_TYPE_DOT1Q":    1,
	"ENCAP_TYPE_VXLAN":    2,
	"ENCAP_TYPE_IP_IN_IP": 3,
	"ENCAP_TYPE_GRE":      4,
	"ENCAP_TYPE_IPSEC":    5,
}

func (x EncapType) String() string {
	return proto.EnumName(EncapType_name, int32(x))
}
func (EncapType) EnumDescriptor() ([]byte, []int) { return fileDescriptorTypes, []int{4} }

// IP address families
type IPAddressFamily int32

const (
	IPAddressFamily_IP_AF_NONE  IPAddressFamily = 0
	IPAddressFamily_IP_AF_INET  IPAddressFamily = 1
	IPAddressFamily_IP_AF_INET6 IPAddressFamily = 2
)

var IPAddressFamily_name = map[int32]string{
	0: "IP_AF_NONE",
	1: "IP_AF_INET",
	2: "IP_AF_INET6",
}
var IPAddressFamily_value = map[string]int32{
	"IP_AF_NONE":  0,
	"IP_AF_INET":  1,
	"IP_AF_INET6": 2,
}

func (x IPAddressFamily) String() string {
	return proto.EnumName(IPAddressFamily_name, int32(x))
}
func (IPAddressFamily) EnumDescriptor() ([]byte, []int) { return fileDescriptorTypes, []int{5} }

// Types of Work Ring
type WRingType int32

const (
	WRingType_WRING_TYPE_NONE          WRingType = 0
	WRingType_WRING_TYPE_SERQ          WRingType = 1
	WRingType_WRING_TYPE_NMDR_TX       WRingType = 2
	WRingType_WRING_TYPE_NMDR_RX       WRingType = 3
	WRingType_WRING_TYPE_NMPR_SMALL_TX WRingType = 4
	WRingType_WRING_TYPE_NMPR_SMALL_RX WRingType = 5
	WRingType_WRING_TYPE_NMPR_BIG_TX   WRingType = 6
	WRingType_WRING_TYPE_NMPR_BIG_RX   WRingType = 7
	WRingType_WRING_TYPE_BSQ           WRingType = 8
	WRingType_WRING_TYPE_BRQ           WRingType = 9
	WRingType_WRING_TYPE_SESQ          WRingType = 10
	WRingType_WRING_TYPE_IPSECCBQ      WRingType = 11
	WRingType_WRING_TYPE_ARQRX         WRingType = 12
	WRingType_WRING_TYPE_ASQ           WRingType = 13
	WRingType_WRING_TYPE_ASESQ         WRingType = 14
	WRingType_WRING_TYPE_RAWRCB        WRingType = 15
)

var WRingType_name = map[int32]string{
	0:  "WRING_TYPE_NONE",
	1:  "WRING_TYPE_SERQ",
	2:  "WRING_TYPE_NMDR_TX",
	3:  "WRING_TYPE_NMDR_RX",
	4:  "WRING_TYPE_NMPR_SMALL_TX",
	5:  "WRING_TYPE_NMPR_SMALL_RX",
	6:  "WRING_TYPE_NMPR_BIG_TX",
	7:  "WRING_TYPE_NMPR_BIG_RX",
	8:  "WRING_TYPE_BSQ",
	9:  "WRING_TYPE_BRQ",
	10: "WRING_TYPE_SESQ",
	11: "WRING_TYPE_IPSECCBQ",
	12: "WRING_TYPE_ARQRX",
	13: "WRING_TYPE_ASQ",
	14: "WRING_TYPE_ASESQ",
	15: "WRING_TYPE_RAWRCB",
}
var WRingType_value = map[string]int32{
	"WRING_TYPE_NONE":          0,
	"WRING_TYPE_SERQ":          1,
	"WRING_TYPE_NMDR_TX":       2,
	"WRING_TYPE_NMDR_RX":       3,
	"WRING_TYPE_NMPR_SMALL_TX": 4,
	"WRING_TYPE_NMPR_SMALL_RX": 5,
	"WRING_TYPE_NMPR_BIG_TX":   6,
	"WRING_TYPE_NMPR_BIG_RX":   7,
	"WRING_TYPE_BSQ":           8,
	"WRING_TYPE_BRQ":           9,
	"WRING_TYPE_SESQ":          10,
	"WRING_TYPE_IPSECCBQ":      11,
	"WRING_TYPE_ARQRX":         12,
	"WRING_TYPE_ASQ":           13,
	"WRING_TYPE_ASESQ":         14,
	"WRING_TYPE_RAWRCB":        15,
}

func (x WRingType) String() string {
	return proto.EnumName(WRingType_name, int32(x))
}
func (WRingType) EnumDescriptor() ([]byte, []int) { return fileDescriptorTypes, []int{6} }

// Types of Proxy Service
type ProxyType int32

const (
	ProxyType_PROXY_TYPE_NONE      ProxyType = 0
	ProxyType_PROXY_TYPE_TCP       ProxyType = 1
	ProxyType_PROXY_TYPE_TLS       ProxyType = 2
	ProxyType_PROXY_TYPE_IPSEC     ProxyType = 3
	ProxyType_PROXY_TYPE_CPU       ProxyType = 4
	ProxyType_PROXY_TYPE_IPFIX     ProxyType = 5
	ProxyType_PROXY_TYPE_RAW_REDIR ProxyType = 6
)

var ProxyType_name = map[int32]string{
	0: "PROXY_TYPE_NONE",
	1: "PROXY_TYPE_TCP",
	2: "PROXY_TYPE_TLS",
	3: "PROXY_TYPE_IPSEC",
	4: "PROXY_TYPE_CPU",
	5: "PROXY_TYPE_IPFIX",
	6: "PROXY_TYPE_RAW_REDIR",
}
var ProxyType_value = map[string]int32{
	"PROXY_TYPE_NONE":      0,
	"PROXY_TYPE_TCP":       1,
	"PROXY_TYPE_TLS":       2,
	"PROXY_TYPE_IPSEC":     3,
	"PROXY_TYPE_CPU":       4,
	"PROXY_TYPE_IPFIX":     5,
	"PROXY_TYPE_RAW_REDIR": 6,
}

func (x ProxyType) String() string {
	return proto.EnumName(ProxyType_name, int32(x))
}
func (ProxyType) EnumDescriptor() ([]byte, []int) { return fileDescriptorTypes, []int{7} }

// Types of Cryptographic keys
type CryptoKeyType int32

const (
	CryptoKeyType_CRYPTO_KEY_TYPE_AES128   CryptoKeyType = 0
	CryptoKeyType_CRYPTO_KEY_TYPE_AES192   CryptoKeyType = 1
	CryptoKeyType_CRYPTO_KEY_TYPE_AES256   CryptoKeyType = 2
	CryptoKeyType_CRYPTO_KEY_TYPE_DES      CryptoKeyType = 3
	CryptoKeyType_CRYPTO_KEY_TYPE_CHACHA20 CryptoKeyType = 4
	CryptoKeyType_CRYPTO_KEY_TYPE_POLY1305 CryptoKeyType = 5
	CryptoKeyType_CRYPTO_KEY_TYPE_HMAC     CryptoKeyType = 6
)

var CryptoKeyType_name = map[int32]string{
	0: "CRYPTO_KEY_TYPE_AES128",
	1: "CRYPTO_KEY_TYPE_AES192",
	2: "CRYPTO_KEY_TYPE_AES256",
	3: "CRYPTO_KEY_TYPE_DES",
	4: "CRYPTO_KEY_TYPE_CHACHA20",
	5: "CRYPTO_KEY_TYPE_POLY1305",
	6: "CRYPTO_KEY_TYPE_HMAC",
}
var CryptoKeyType_value = map[string]int32{
	"CRYPTO_KEY_TYPE_AES128":   0,
	"CRYPTO_KEY_TYPE_AES192":   1,
	"CRYPTO_KEY_TYPE_AES256":   2,
	"CRYPTO_KEY_TYPE_DES":      3,
	"CRYPTO_KEY_TYPE_CHACHA20": 4,
	"CRYPTO_KEY_TYPE_POLY1305": 5,
	"CRYPTO_KEY_TYPE_HMAC":     6,
}

func (x CryptoKeyType) String() string {
	return proto.EnumName(CryptoKeyType_name, int32(x))
}
func (CryptoKeyType) EnumDescriptor() ([]byte, []int) { return fileDescriptorTypes, []int{8} }

// common meta object that is part of all other top level objects
// TODO: should we add last updated timestamp, revision etc. here ?
type ObjectMeta struct {
	TenantId uint32 `protobuf:"fixed32,1,opt,name=tenant_id,json=tenantId,proto3" json:"tenant_id,omitempty"`
}

func (m *ObjectMeta) Reset()                    { *m = ObjectMeta{} }
func (m *ObjectMeta) String() string            { return proto.CompactTextString(m) }
func (*ObjectMeta) ProtoMessage()               {}
func (*ObjectMeta) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{0} }

func (m *ObjectMeta) GetTenantId() uint32 {
	if m != nil {
		return m.TenantId
	}
	return 0
}

// EncapInfo captures wire encap information
type EncapInfo struct {
	EncapType  EncapType `protobuf:"varint,1,opt,name=encap_type,json=encapType,proto3,enum=types.EncapType" json:"encap_type,omitempty"`
	EncapValue uint32    `protobuf:"varint,2,opt,name=encap_value,json=encapValue,proto3" json:"encap_value,omitempty"`
}

func (m *EncapInfo) Reset()                    { *m = EncapInfo{} }
func (m *EncapInfo) String() string            { return proto.CompactTextString(m) }
func (*EncapInfo) ProtoMessage()               {}
func (*EncapInfo) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{1} }

func (m *EncapInfo) GetEncapType() EncapType {
	if m != nil {
		return m.EncapType
	}
	return EncapType_ENCAP_TYPE_NONE
}

func (m *EncapInfo) GetEncapValue() uint32 {
	if m != nil {
		return m.EncapValue
	}
	return 0
}

// IP address object
type IPAddress struct {
	IpAf IPAddressFamily `protobuf:"varint,1,opt,name=ip_af,json=ipAf,proto3,enum=types.IPAddressFamily" json:"ip_af,omitempty"`
	// Types that are valid to be assigned to V4OrV6:
	//	*IPAddress_V4Addr
	//	*IPAddress_V6Addr
	V4OrV6 isIPAddress_V4OrV6 `protobuf_oneof:"v4_or_v6"`
}

func (m *IPAddress) Reset()                    { *m = IPAddress{} }
func (m *IPAddress) String() string            { return proto.CompactTextString(m) }
func (*IPAddress) ProtoMessage()               {}
func (*IPAddress) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{2} }

type isIPAddress_V4OrV6 interface {
	isIPAddress_V4OrV6()
	MarshalTo([]byte) (int, error)
	Size() int
}

type IPAddress_V4Addr struct {
	V4Addr uint32 `protobuf:"fixed32,2,opt,name=v4_addr,json=v4Addr,proto3,oneof"`
}
type IPAddress_V6Addr struct {
	V6Addr []byte `protobuf:"bytes,3,opt,name=v6_addr,json=v6Addr,proto3,oneof"`
}

func (*IPAddress_V4Addr) isIPAddress_V4OrV6() {}
func (*IPAddress_V6Addr) isIPAddress_V4OrV6() {}

func (m *IPAddress) GetV4OrV6() isIPAddress_V4OrV6 {
	if m != nil {
		return m.V4OrV6
	}
	return nil
}

func (m *IPAddress) GetIpAf() IPAddressFamily {
	if m != nil {
		return m.IpAf
	}
	return IPAddressFamily_IP_AF_NONE
}

func (m *IPAddress) GetV4Addr() uint32 {
	if x, ok := m.GetV4OrV6().(*IPAddress_V4Addr); ok {
		return x.V4Addr
	}
	return 0
}

func (m *IPAddress) GetV6Addr() []byte {
	if x, ok := m.GetV4OrV6().(*IPAddress_V6Addr); ok {
		return x.V6Addr
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*IPAddress) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _IPAddress_OneofMarshaler, _IPAddress_OneofUnmarshaler, _IPAddress_OneofSizer, []interface{}{
		(*IPAddress_V4Addr)(nil),
		(*IPAddress_V6Addr)(nil),
	}
}

func _IPAddress_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*IPAddress)
	// v4_or_v6
	switch x := m.V4OrV6.(type) {
	case *IPAddress_V4Addr:
		_ = b.EncodeVarint(2<<3 | proto.WireFixed32)
		_ = b.EncodeFixed32(uint64(x.V4Addr))
	case *IPAddress_V6Addr:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		_ = b.EncodeRawBytes(x.V6Addr)
	case nil:
	default:
		return fmt.Errorf("IPAddress.V4OrV6 has unexpected type %T", x)
	}
	return nil
}

func _IPAddress_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*IPAddress)
	switch tag {
	case 2: // v4_or_v6.v4_addr
		if wire != proto.WireFixed32 {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeFixed32()
		m.V4OrV6 = &IPAddress_V4Addr{uint32(x)}
		return true, err
	case 3: // v4_or_v6.v6_addr
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeRawBytes(true)
		m.V4OrV6 = &IPAddress_V6Addr{x}
		return true, err
	default:
		return false, nil
	}
}

func _IPAddress_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*IPAddress)
	// v4_or_v6
	switch x := m.V4OrV6.(type) {
	case *IPAddress_V4Addr:
		n += proto.SizeVarint(2<<3 | proto.WireFixed32)
		n += 4
	case *IPAddress_V6Addr:
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.V6Addr)))
		n += len(x.V6Addr)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// IP Prefix object
type IPPrefix struct {
	Address   *IPAddress `protobuf:"bytes,1,opt,name=address" json:"address,omitempty"`
	PrefixLen uint32     `protobuf:"varint,2,opt,name=prefix_len,json=prefixLen,proto3" json:"prefix_len,omitempty"`
}

func (m *IPPrefix) Reset()                    { *m = IPPrefix{} }
func (m *IPPrefix) String() string            { return proto.CompactTextString(m) }
func (*IPPrefix) ProtoMessage()               {}
func (*IPPrefix) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{3} }

func (m *IPPrefix) GetAddress() *IPAddress {
	if m != nil {
		return m.Address
	}
	return nil
}

func (m *IPPrefix) GetPrefixLen() uint32 {
	if m != nil {
		return m.PrefixLen
	}
	return 0
}

// PortRange object has low and high end of the port ranges
type L4PortRange struct {
	PortLow  uint32 `protobuf:"varint,1,opt,name=port_low,json=portLow,proto3" json:"port_low,omitempty"`
	PortHigh uint32 `protobuf:"varint,2,opt,name=port_high,json=portHigh,proto3" json:"port_high,omitempty"`
}

func (m *L4PortRange) Reset()                    { *m = L4PortRange{} }
func (m *L4PortRange) String() string            { return proto.CompactTextString(m) }
func (*L4PortRange) ProtoMessage()               {}
func (*L4PortRange) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{4} }

func (m *L4PortRange) GetPortLow() uint32 {
	if m != nil {
		return m.PortLow
	}
	return 0
}

func (m *L4PortRange) GetPortHigh() uint32 {
	if m != nil {
		return m.PortHigh
	}
	return 0
}

type Empty struct {
}

func (m *Empty) Reset()                    { *m = Empty{} }
func (m *Empty) String() string            { return proto.CompactTextString(m) }
func (*Empty) ProtoMessage()               {}
func (*Empty) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{5} }

func init() {
	proto.RegisterType((*ObjectMeta)(nil), "types.ObjectMeta")
	proto.RegisterType((*EncapInfo)(nil), "types.EncapInfo")
	proto.RegisterType((*IPAddress)(nil), "types.IPAddress")
	proto.RegisterType((*IPPrefix)(nil), "types.IPPrefix")
	proto.RegisterType((*L4PortRange)(nil), "types.L4PortRange")
	proto.RegisterType((*Empty)(nil), "types.Empty")
	proto.RegisterEnum("types.IPProtocol", IPProtocol_name, IPProtocol_value)
	proto.RegisterEnum("types.ICMPMsgType", ICMPMsgType_name, ICMPMsgType_value)
	proto.RegisterEnum("types.ApiStatus", ApiStatus_name, ApiStatus_value)
	proto.RegisterEnum("types.L2SegmentType", L2SegmentType_name, L2SegmentType_value)
	proto.RegisterEnum("types.EncapType", EncapType_name, EncapType_value)
	proto.RegisterEnum("types.IPAddressFamily", IPAddressFamily_name, IPAddressFamily_value)
	proto.RegisterEnum("types.WRingType", WRingType_name, WRingType_value)
	proto.RegisterEnum("types.ProxyType", ProxyType_name, ProxyType_value)
	proto.RegisterEnum("types.CryptoKeyType", CryptoKeyType_name, CryptoKeyType_value)
}
func (m *ObjectMeta) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ObjectMeta) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TenantId != 0 {
		dAtA[i] = 0xd
		i++
		i = encodeFixed32Types(dAtA, i, uint32(m.TenantId))
	}
	return i, nil
}

func (m *EncapInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EncapInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.EncapType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.EncapType))
	}
	if m.EncapValue != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.EncapValue))
	}
	return i, nil
}

func (m *IPAddress) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IPAddress) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.IpAf != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.IpAf))
	}
	if m.V4OrV6 != nil {
		nn1, err := m.V4OrV6.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn1
	}
	return i, nil
}

func (m *IPAddress_V4Addr) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x15
	i++
	i = encodeFixed32Types(dAtA, i, uint32(m.V4Addr))
	return i, nil
}
func (m *IPAddress_V6Addr) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.V6Addr != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.V6Addr)))
		i += copy(dAtA[i:], m.V6Addr)
	}
	return i, nil
}
func (m *IPPrefix) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IPPrefix) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Address != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Address.Size()))
		n2, err := m.Address.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.PrefixLen != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.PrefixLen))
	}
	return i, nil
}

func (m *L4PortRange) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *L4PortRange) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PortLow != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.PortLow))
	}
	if m.PortHigh != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.PortHigh))
	}
	return i, nil
}

func (m *Empty) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Empty) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func encodeFixed64Types(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Types(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *ObjectMeta) Size() (n int) {
	var l int
	_ = l
	if m.TenantId != 0 {
		n += 5
	}
	return n
}

func (m *EncapInfo) Size() (n int) {
	var l int
	_ = l
	if m.EncapType != 0 {
		n += 1 + sovTypes(uint64(m.EncapType))
	}
	if m.EncapValue != 0 {
		n += 1 + sovTypes(uint64(m.EncapValue))
	}
	return n
}

func (m *IPAddress) Size() (n int) {
	var l int
	_ = l
	if m.IpAf != 0 {
		n += 1 + sovTypes(uint64(m.IpAf))
	}
	if m.V4OrV6 != nil {
		n += m.V4OrV6.Size()
	}
	return n
}

func (m *IPAddress_V4Addr) Size() (n int) {
	var l int
	_ = l
	n += 5
	return n
}
func (m *IPAddress_V6Addr) Size() (n int) {
	var l int
	_ = l
	if m.V6Addr != nil {
		l = len(m.V6Addr)
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *IPPrefix) Size() (n int) {
	var l int
	_ = l
	if m.Address != nil {
		l = m.Address.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.PrefixLen != 0 {
		n += 1 + sovTypes(uint64(m.PrefixLen))
	}
	return n
}

func (m *L4PortRange) Size() (n int) {
	var l int
	_ = l
	if m.PortLow != 0 {
		n += 1 + sovTypes(uint64(m.PortLow))
	}
	if m.PortHigh != 0 {
		n += 1 + sovTypes(uint64(m.PortHigh))
	}
	return n
}

func (m *Empty) Size() (n int) {
	var l int
	_ = l
	return n
}

func sovTypes(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ObjectMeta) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ObjectMeta: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ObjectMeta: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field TenantId", wireType)
			}
			m.TenantId = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			m.TenantId = uint32(dAtA[iNdEx-4])
			m.TenantId |= uint32(dAtA[iNdEx-3]) << 8
			m.TenantId |= uint32(dAtA[iNdEx-2]) << 16
			m.TenantId |= uint32(dAtA[iNdEx-1]) << 24
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EncapInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EncapInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EncapInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncapType", wireType)
			}
			m.EncapType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EncapType |= (EncapType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncapValue", wireType)
			}
			m.EncapValue = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EncapValue |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IPAddress) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IPAddress: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IPAddress: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpAf", wireType)
			}
			m.IpAf = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IpAf |= (IPAddressFamily(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field V4Addr", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.V4OrV6 = &IPAddress_V4Addr{v}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field V6Addr", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := make([]byte, postIndex-iNdEx)
			copy(v, dAtA[iNdEx:postIndex])
			m.V4OrV6 = &IPAddress_V6Addr{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IPPrefix) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IPPrefix: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IPPrefix: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Address == nil {
				m.Address = &IPAddress{}
			}
			if err := m.Address.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrefixLen", wireType)
			}
			m.PrefixLen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrefixLen |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *L4PortRange) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: L4PortRange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: L4PortRange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortLow", wireType)
			}
			m.PortLow = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PortLow |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortHigh", wireType)
			}
			m.PortHigh = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PortHigh |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Empty) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Empty: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Empty: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipTypes(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthTypes = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("nic/proto/types.proto", fileDescriptorTypes) }

var fileDescriptorTypes = []byte{
	// 1616 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x74, 0x57, 0xdd, 0x52, 0x1b, 0xc9,
	0x15, 0x66, 0xf8, 0x13, 0x6a, 0x0c, 0x34, 0x6d, 0xcc, 0x02, 0xb6, 0x31, 0x2b, 0x3b, 0x6b, 0x56,
	0x4e, 0x8c, 0x2d, 0x30, 0xd9, 0xdd, 0x64, 0x93, 0x8c, 0x66, 0x5a, 0xd2, 0x14, 0xa3, 0x99, 0x56,
	0xcf, 0x08, 0x49, 0xa9, 0x4a, 0x75, 0x09, 0x10, 0x42, 0x29, 0x2c, 0xa9, 0x84, 0x60, 0x4d, 0x1e,
	0x20, 0xb7, 0xb9, 0xcd, 0x75, 0x2e, 0x93, 0xa7, 0xc8, 0x5d, 0x2e, 0x53, 0x79, 0x82, 0x94, 0xf3,
	0x22, 0xa9, 0xee, 0x91, 0x34, 0x3d, 0x47, 0xf8, 0x6e, 0xfa, 0x7c, 0x5f, 0x7f, 0xe7, 0xa7, 0x4f,
	0x1f, 0xb5, 0xd0, 0x93, 0x6e, 0xe7, 0xfc, 0xa0, 0x3f, 0xe8, 0x0d, 0x7b, 0x07, 0xc3, 0xfb, 0x7e,
	0xeb, 0xe6, 0xad, 0xfa, 0x26, 0x0b, 0x6a, 0xb1, 0xf3, 0x4e, 0xad, 0x6e, 0x0e, 0xda, 0x9d, 0xe1,
	0xd5, 0xed, 0xd9, 0x41, 0xbb, 0xd7, 0xee, 0x45, 0xe4, 0xb3, 0xdb, 0x4b, 0xb5, 0x8a, 0x76, 0xca,
	0xaf, 0x68, 0x63, 0xe6, 0x5b, 0x84, 0xfc, 0xb3, 0x3f, 0xb6, 0xce, 0x87, 0xe5, 0xd6, 0xb0, 0x49,
	0x9e, 0xa2, 0xf4, 0xb0, 0xd5, 0x6d, 0x76, 0x87, 0xa2, 0x73, 0xb1, 0x65, 0xec, 0x19, 0xfb, 0x29,
	0xbe, 0x14, 0x19, 0x9c, 0x8b, 0xcc, 0x1f, 0x50, 0x9a, 0x76, 0xcf, 0x9b, 0x7d, 0xa7, 0x7b, 0xd9,
	0x23, 0x07, 0x08, 0xb5, 0xe4, 0x42, 0x48, 0xc7, 0x8a, 0xba, 0x9a, 0xc3, 0x6f, 0xa3, 0x90, 0x14,
	0x10, 0xde, 0xf7, 0x5b, 0x3c, 0x3d, 0xf9, 0x24, 0x2f, 0xd0, 0x72, 0xb4, 0xe1, 0xae, 0x79, 0x7d,
	0xdb, 0xda, 0x9a, 0xdd, 0x33, 0xf6, 0x57, 0x78, 0xa4, 0x71, 0x2a, 0x2d, 0x99, 0x3f, 0xa1, 0xb4,
	0xc3, 0xcc, 0x8b, 0x8b, 0x41, 0xeb, 0xe6, 0x86, 0xbc, 0x41, 0x0b, 0x9d, 0xbe, 0x68, 0x5e, 0x8e,
	0x94, 0x37, 0x47, 0xca, 0x13, 0x42, 0xa1, 0xf9, 0xb1, 0x73, 0x7d, 0xcf, 0xe7, 0x3b, 0x7d, 0xf3,
	0x92, 0x6c, 0xa3, 0xd4, 0xdd, 0x91, 0x68, 0x5e, 0x5c, 0x0c, 0x94, 0x6c, 0xaa, 0x34, 0xc3, 0x17,
	0xef, 0x8e, 0x24, 0x53, 0x41, 0xc7, 0x11, 0x34, 0xb7, 0x67, 0xec, 0x3f, 0x52, 0xd0, 0xb1, 0x84,
	0xf2, 0x08, 0x2d, 0xdd, 0x1d, 0x89, 0xde, 0x40, 0xdc, 0x1d, 0x67, 0xaa, 0x68, 0xc9, 0x61, 0x6c,
	0xd0, 0xba, 0xec, 0x7c, 0x22, 0x59, 0x94, 0x6a, 0x46, 0x4e, 0x94, 0xf3, 0xe5, 0x49, 0x5a, 0x13,
	0xe7, 0x7c, 0x4c, 0x20, 0xcf, 0x11, 0xea, 0xab, 0x5d, 0xe2, 0xba, 0xd5, 0x1d, 0xe5, 0x94, 0x8e,
	0x2c, 0x6e, 0xab, 0x9b, 0xa1, 0x68, 0xd9, 0x3d, 0x62, 0xbd, 0xc1, 0x90, 0x37, 0xbb, 0xed, 0x16,
	0xd9, 0x46, 0x4b, 0xfd, 0xde, 0x60, 0x28, 0xae, 0x7b, 0x3f, 0x29, 0xe9, 0x15, 0x9e, 0x92, 0x6b,
	0xb7, 0xf7, 0x93, 0x2c, 0xbc, 0x82, 0xae, 0x3a, 0xed, 0xab, 0x91, 0x8e, 0xe2, 0x96, 0x3a, 0xed,
	0xab, 0x4c, 0x0a, 0x2d, 0xd0, 0x8f, 0xfd, 0xe1, 0x7d, 0xf6, 0xef, 0x06, 0x42, 0x32, 0xce, 0xde,
	0xb0, 0x77, 0xde, 0xbb, 0x26, 0x18, 0x3d, 0x72, 0x18, 0xe3, 0x7e, 0xe8, 0x0b, 0xcf, 0xf7, 0x28,
	0x9e, 0xd1, 0x2d, 0x8e, 0x55, 0x66, 0xd8, 0x48, 0x58, 0xd8, 0xe9, 0x11, 0x9e, 0x27, 0x6b, 0x68,
	0x79, 0x6c, 0x09, 0x2d, 0x86, 0x17, 0x75, 0x43, 0xd5, 0x66, 0x78, 0x5d, 0x37, 0x14, 0x39, 0xc5,
	0x07, 0xba, 0x81, 0x06, 0x0c, 0xe7, 0xc8, 0xaa, 0x8a, 0x43, 0x19, 0xcc, 0x12, 0x3e, 0x24, 0x04,
	0xad, 0xea, 0x7e, 0x4f, 0x8f, 0xf1, 0x0f, 0xd9, 0x1f, 0xd1, 0xb2, 0xfc, 0x2e, 0xdf, 0xb4, 0xd5,
	0xf9, 0x6f, 0x22, 0x22, 0x97, 0xa2, 0x1c, 0x14, 0x45, 0xd8, 0x60, 0x74, 0x1c, 0xf2, 0x94, 0x9d,
	0x5a, 0x25, 0x1f, 0x1b, 0xd9, 0x7f, 0xae, 0xa3, 0xb4, 0xd9, 0xef, 0x04, 0xc3, 0xe6, 0xf0, 0xf6,
	0x86, 0xac, 0xa3, 0x15, 0x93, 0x39, 0x22, 0x08, 0xcd, 0xb0, 0x1a, 0x08, 0xff, 0x04, 0xcf, 0x48,
	0x9f, 0x9a, 0x89, 0x72, 0x8e, 0x0d, 0xb2, 0x83, 0x36, 0x35, 0x9b, 0xe3, 0x9d, 0x9a, 0xae, 0x63,
	0x0b, 0x93, 0x17, 0xf1, 0x2c, 0x79, 0x8e, 0xb6, 0x75, 0x7e, 0xdd, 0x09, 0xc2, 0x40, 0x98, 0x2e,
	0xa7, 0xa6, 0xdd, 0xc0, 0x73, 0x64, 0x1b, 0x3d, 0xd1, 0x3d, 0x54, 0x43, 0xe1, 0x17, 0x44, 0x99,
	0x96, 0xf1, 0x3c, 0xd9, 0x42, 0x1b, 0x1a, 0xe4, 0xf9, 0xa1, 0x28, 0xf8, 0x55, 0xcf, 0xc6, 0x0b,
	0x64, 0x17, 0xed, 0x4c, 0x6f, 0xe2, 0x34, 0xf0, 0xab, 0xdc, 0xa2, 0x78, 0x91, 0x3c, 0x43, 0x5b,
	0xba, 0x4f, 0xcf, 0x32, 0xd9, 0x38, 0x2a, 0x9c, 0x22, 0x7b, 0xe8, 0x99, 0x86, 0x86, 0xd4, 0x33,
	0xbd, 0x50, 0x38, 0xf6, 0x84, 0xb1, 0x44, 0x5e, 0xa0, 0xa7, 0xd3, 0x8c, 0x38, 0x80, 0x34, 0x79,
	0x85, 0xf6, 0x34, 0x82, 0x9b, 0x13, 0x01, 0x2d, 0x96, 0x69, 0x52, 0x06, 0x91, 0x97, 0xe8, 0xc5,
	0xc3, 0xac, 0x58, 0x6a, 0x19, 0x90, 0x1c, 0x2f, 0xa4, 0xbc, 0x60, 0x5a, 0x54, 0x57, 0x7a, 0x44,
	0x32, 0x68, 0xf7, 0x41, 0x52, 0x2c, 0xb4, 0x02, 0x8a, 0xe2, 0x14, 0xa2, 0x63, 0x1d, 0x6b, 0xac,
	0x4e, 0xe3, 0x8e, 0x57, 0xf0, 0x27, 0xf8, 0x1a, 0x0c, 0xa4, 0x20, 0xdc, 0xdc, 0x24, 0xab, 0x11,
	0x09, 0x4f, 0x93, 0xa8, 0xe7, 0x58, 0x49, 0xa5, 0xf5, 0x2f, 0x90, 0x12, 0xe1, 0x10, 0xf2, 0x0d,
	0xca, 0x00, 0x77, 0xe3, 0x90, 0x64, 0x52, 0x63, 0xde, 0x63, 0xf2, 0x1a, 0xbd, 0x9c, 0xe2, 0x55,
	0xa6, 0x89, 0x1b, 0xe4, 0x6b, 0xf4, 0x3c, 0x71, 0xe8, 0x36, 0xf3, 0x9d, 0x44, 0xad, 0x9f, 0x80,
	0x73, 0x2d, 0xb8, 0x7e, 0x4d, 0x9c, 0xd0, 0xc6, 0x44, 0x63, 0x13, 0xb4, 0x86, 0x22, 0x24, 0x72,
	0xfb, 0x0a, 0xb4, 0xb3, 0x62, 0xc4, 0x1e, 0xb6, 0x80, 0x40, 0x40, 0x83, 0xc0, 0xf1, 0x3d, 0x8d,
	0xb1, 0x0d, 0x04, 0x4a, 0xa6, 0x67, 0xbb, 0x71, 0x59, 0x76, 0xc0, 0x55, 0x2a, 0xd5, 0x04, 0xe3,
	0x7e, 0x51, 0x5d, 0xb3, 0xa7, 0x60, 0xab, 0xaa, 0x57, 0xdc, 0x24, 0xcf, 0x40, 0xd7, 0x4b, 0x38,
	0xf6, 0xfb, 0x1c, 0xd4, 0xd1, 0xab, 0x05, 0xd4, 0x92, 0xda, 0x05, 0xc7, 0x4d, 0xf4, 0xda, 0x2e,
	0x38, 0x98, 0x24, 0x31, 0x16, 0x7c, 0x01, 0xaf, 0x91, 0x1b, 0x08, 0x2b, 0xaf, 0x2b, 0xed, 0xc1,
	0x6b, 0x14, 0x31, 0x62, 0x89, 0xaf, 0xa1, 0x84, 0xc5, 0x80, 0x44, 0x06, 0x4a, 0x44, 0x8c, 0x58,
	0xe2, 0x25, 0xb8, 0x19, 0xf9, 0x6a, 0x41, 0x30, 0xdf, 0x77, 0x75, 0x91, 0x57, 0xa0, 0x33, 0x26,
	0x9c, 0x58, 0xe6, 0x67, 0x20, 0xe9, 0x09, 0xc5, 0xf2, 0x03, 0x51, 0x36, 0xd9, 0x68, 0x6c, 0xe1,
	0x6f, 0x40, 0x3c, 0x95, 0x2a, 0xad, 0x26, 0xaa, 0xf7, 0x1a, 0xc4, 0x13, 0x11, 0x2c, 0xbf, 0xaa,
	0x5d, 0xa2, 0x7d, 0x70, 0x13, 0x23, 0x4e, 0x1c, 0xcc, 0xb7, 0x20, 0x5e, 0xe6, 0xbb, 0x8e, 0x45,
	0xb9, 0xee, 0x26, 0x0b, 0x2a, 0x37, 0xa6, 0xc4, 0x22, 0x6f, 0x00, 0xc3, 0xa3, 0x61, 0xcd, 0xe7,
	0x27, 0x1a, 0xe3, 0xe7, 0xa0, 0x9d, 0x4c, 0x2b, 0x51, 0xb5, 0x5f, 0x80, 0x76, 0x92, 0x70, 0xbc,
	0xf9, 0x2d, 0x28, 0x44, 0x8d, 0x3b, 0x5e, 0x51, 0xdf, 0x7e, 0x00, 0x92, 0x8c, 0x08, 0xb1, 0xc0,
	0x3b, 0x90, 0x64, 0x84, 0x27, 0x46, 0xc4, 0x7b, 0x58, 0x07, 0xee, 0xd7, 0x1b, 0x49, 0x4a, 0x0e,
	0x0e, 0x46, 0x26, 0x9b, 0x35, 0xd9, 0x43, 0x87, 0x40, 0x66, 0xc2, 0x89, 0x83, 0x39, 0x02, 0xd9,
	0xb8, 0x47, 0x6e, 0x3e, 0x31, 0x18, 0x3e, 0x80, 0x6a, 0x5a, 0xac, 0x0a, 0xbc, 0x1c, 0x03, 0x89,
	0x11, 0x23, 0xf6, 0xf1, 0x4b, 0x78, 0x64, 0x2a, 0x1b, 0x89, 0x53, 0xcf, 0xcc, 0xbb, 0xd4, 0xc6,
	0xdf, 0x81, 0xb9, 0x19, 0x31, 0xc0, 0x84, 0xf9, 0x1e, 0xfc, 0x60, 0x5a, 0x85, 0xa2, 0xb0, 0xf3,
	0x6a, 0x3e, 0xfc, 0x40, 0xf6, 0xd1, 0xab, 0xc4, 0xf0, 0xb1, 0xaa, 0xdc, 0x09, 0x1b, 0xa2, 0xc8,
	0xfd, 0x2a, 0xd3, 0x83, 0xfd, 0x15, 0x79, 0x83, 0x5e, 0x3f, 0x34, 0x2b, 0xab, 0xcc, 0x56, 0x79,
	0x97, 0x6c, 0x77, 0x42, 0xfe, 0x35, 0xf8, 0xb1, 0xb3, 0xfd, 0x51, 0xbf, 0x35, 0x74, 0xc9, 0x1f,
	0x41, 0xf0, 0x1a, 0x2b, 0x0e, 0xfe, 0x37, 0xe0, 0x28, 0xb8, 0x59, 0xe3, 0xa0, 0x8e, 0xbf, 0x05,
	0x65, 0x1a, 0x53, 0x62, 0x91, 0xdf, 0x81, 0x4a, 0x73, 0x5a, 0xa0, 0x9c, 0x7a, 0x16, 0x1d, 0x3d,
	0x2e, 0xb0, 0x99, 0xfd, 0x87, 0x81, 0x56, 0xdc, 0x5c, 0xd0, 0x6a, 0x7f, 0x6c, 0x75, 0x87, 0xea,
	0x15, 0xb4, 0x85, 0x36, 0xb4, 0x9f, 0x5f, 0xfd, 0x1d, 0xb4, 0x83, 0x36, 0x21, 0x12, 0xfd, 0xde,
	0x63, 0xe3, 0xa1, 0x5d, 0xe5, 0x62, 0x39, 0xc4, 0xb3, 0xf2, 0x10, 0x20, 0xe2, 0x78, 0x05, 0x6e,
	0xe2, 0x39, 0xf9, 0xb0, 0xd2, 0x20, 0xc6, 0x9d, 0xb2, 0xc9, 0x1b, 0x78, 0x9e, 0x7c, 0x85, 0x1e,
	0xeb, 0xef, 0x84, 0xc0, 0x77, 0xcd, 0x90, 0xda, 0x78, 0x21, 0xfb, 0x17, 0x03, 0x69, 0xef, 0xf5,
	0xc7, 0x68, 0x2d, 0x7a, 0xaf, 0xe8, 0x41, 0x6e, 0x20, 0xac, 0x19, 0x6d, 0x3f, 0x7c, 0x5f, 0xc1,
	0x06, 0xb0, 0x9e, 0xd6, 0x5d, 0xd3, 0xc3, 0xb3, 0xd2, 0x8f, 0x66, 0x75, 0xe4, 0xc3, 0x47, 0x38,
	0x0c, 0xcf, 0xc9, 0x87, 0x9b, 0x06, 0xc8, 0x17, 0xe6, 0x3c, 0x90, 0x50, 0x57, 0x03, 0x2f, 0x64,
	0xf3, 0x68, 0x0d, 0xbc, 0xf8, 0xa3, 0x97, 0xa7, 0x30, 0x0b, 0xe3, 0x88, 0x26, 0x6b, 0xc7, 0xa3,
	0xb2, 0x54, 0xea, 0xa9, 0x3a, 0x5e, 0x1f, 0xe3, 0xd9, 0xec, 0x9f, 0xe7, 0x50, 0xba, 0xc6, 0x3b,
	0xdd, 0xf6, 0x38, 0x2b, 0xed, 0x86, 0x8f, 0x34, 0x92, 0xc6, 0x80, 0x72, 0x99, 0xd4, 0x26, 0x22,
	0x3a, 0xb3, 0x6c, 0x73, 0x11, 0xd6, 0xf1, 0xec, 0x43, 0x76, 0x5e, 0xc7, 0x73, 0x72, 0x4a, 0x25,
	0xec, 0x8c, 0x8b, 0xa0, 0x6c, 0xba, 0xae, 0xdc, 0x35, 0xff, 0x65, 0x94, 0xd7, 0xf1, 0x82, 0x3c,
	0x7b, 0x88, 0xe6, 0x9d, 0xa2, 0xdc, 0xb9, 0xf8, 0x25, 0x8c, 0xd7, 0x71, 0x4a, 0x56, 0x52, 0xc3,
	0xf2, 0x41, 0x05, 0x2f, 0x41, 0x1b, 0xaf, 0xe0, 0xf4, 0x54, 0x82, 0x41, 0x05, 0x23, 0x79, 0x3e,
	0xfa, 0xb0, 0x93, 0x25, 0xb7, 0xf2, 0x15, 0xbc, 0x2c, 0xcf, 0x42, 0x03, 0x4c, 0x5e, 0xe1, 0x75,
	0xfc, 0x08, 0xe8, 0x9a, 0x41, 0x05, 0xaf, 0x40, 0xa6, 0x12, 0x5e, 0x25, 0x4f, 0xd0, 0xba, 0x66,
	0x95, 0x17, 0xc7, 0xca, 0xe3, 0xb5, 0xec, 0xdf, 0x0c, 0x94, 0x66, 0x83, 0xde, 0xa7, 0xfb, 0xf1,
	0x41, 0x68, 0x73, 0x74, 0x74, 0x10, 0x04, 0xad, 0x6a, 0x46, 0xf9, 0xef, 0xc4, 0x80, 0x36, 0x37,
	0xc0, 0xb3, 0xd2, 0xaf, 0x3e, 0x84, 0x55, 0xb7, 0xcc, 0x01, 0xa6, 0xc5, 0xaa, 0x51, 0x5f, 0x25,
	0x98, 0x05, 0x47, 0xd6, 0x7b, 0x0b, 0x6d, 0x68, 0x56, 0x6e, 0xd6, 0x04, 0xa7, 0xb6, 0xc3, 0xf1,
	0x62, 0xf6, 0x3f, 0x06, 0x5a, 0xb1, 0x06, 0xf7, 0xfd, 0x61, 0xef, 0xa4, 0x15, 0x05, 0xba, 0x83,
	0x36, 0x2d, 0xde, 0x60, 0xa1, 0xaf, 0x06, 0x52, 0x94, 0x28, 0x0d, 0xde, 0xe7, 0xbe, 0x8b, 0xee,
	0xec, 0x43, 0xd8, 0xf7, 0xb9, 0xe8, 0xaf, 0xc8, 0x03, 0x58, 0xee, 0xc3, 0x71, 0x74, 0x35, 0x20,
	0x66, 0xd3, 0x20, 0x6a, 0x22, 0x08, 0x58, 0x25, 0xd3, 0x2a, 0x99, 0xb9, 0x77, 0x51, 0x13, 0x41,
	0x94, 0xf9, 0x6e, 0xe3, 0xfd, 0xe1, 0xbb, 0x0f, 0x51, 0x52, 0x10, 0x2d, 0x95, 0x4d, 0x0b, 0x2f,
	0xe6, 0x77, 0xfe, 0xf5, 0x79, 0xd7, 0xf8, 0xf7, 0xe7, 0x5d, 0xe3, 0xbf, 0x9f, 0x77, 0x8d, 0xbf,
	0xfe, 0x6f, 0x77, 0xe6, 0xf7, 0x4b, 0x57, 0xcd, 0x6b, 0xf5, 0xff, 0x9f, 0xcd, 0x9c, 0x2d, 0xaa,
	0x8f, 0xc3, 0xff, 0x07, 0x00, 0x00, 0xff, 0xff, 0x28, 0xbc, 0x95, 0x40, 0x5a, 0x10, 0x00, 0x00,
}
