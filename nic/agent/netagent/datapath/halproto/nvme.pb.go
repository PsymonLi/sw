// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: nvme.proto

package halproto

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// **********************   NVME Feature Enable *****************************//
// NvmeEnable Request object
type NvmeEnableRequest struct {
	MaxNs           uint32 `protobuf:"varint,1,opt,name=max_ns,json=maxNs,proto3" json:"max_ns,omitempty"`
	MaxSess         uint32 `protobuf:"varint,2,opt,name=max_sess,json=maxSess,proto3" json:"max_sess,omitempty"`
	MaxCmdContext   uint32 `protobuf:"varint,3,opt,name=max_cmd_context,json=maxCmdContext,proto3" json:"max_cmd_context,omitempty"`
	TxMaxPduContext uint32 `protobuf:"varint,4,opt,name=tx_max_pdu_context,json=txMaxPduContext,proto3" json:"tx_max_pdu_context,omitempty"`
	RxMaxPduContext uint32 `protobuf:"varint,5,opt,name=rx_max_pdu_context,json=rxMaxPduContext,proto3" json:"rx_max_pdu_context,omitempty"`
}

func (m *NvmeEnableRequest) Reset()                    { *m = NvmeEnableRequest{} }
func (m *NvmeEnableRequest) String() string            { return proto.CompactTextString(m) }
func (*NvmeEnableRequest) ProtoMessage()               {}
func (*NvmeEnableRequest) Descriptor() ([]byte, []int) { return fileDescriptorNvme, []int{0} }

func (m *NvmeEnableRequest) GetMaxNs() uint32 {
	if m != nil {
		return m.MaxNs
	}
	return 0
}

func (m *NvmeEnableRequest) GetMaxSess() uint32 {
	if m != nil {
		return m.MaxSess
	}
	return 0
}

func (m *NvmeEnableRequest) GetMaxCmdContext() uint32 {
	if m != nil {
		return m.MaxCmdContext
	}
	return 0
}

func (m *NvmeEnableRequest) GetTxMaxPduContext() uint32 {
	if m != nil {
		return m.TxMaxPduContext
	}
	return 0
}

func (m *NvmeEnableRequest) GetRxMaxPduContext() uint32 {
	if m != nil {
		return m.RxMaxPduContext
	}
	return 0
}

// NvmeEnableRequestMsg is batched request
type NvmeEnableRequestMsg struct {
	Request []*NvmeEnableRequest `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *NvmeEnableRequestMsg) Reset()                    { *m = NvmeEnableRequestMsg{} }
func (m *NvmeEnableRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*NvmeEnableRequestMsg) ProtoMessage()               {}
func (*NvmeEnableRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptorNvme, []int{1} }

func (m *NvmeEnableRequestMsg) GetRequest() []*NvmeEnableRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

// NvmeEnableResponse response to one NvmeEnableSpec
type NvmeEnableResponse struct {
	ApiStatus          ApiStatus `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty"`
	CmdContextRingBase uint64    `protobuf:"varint,2,opt,name=cmd_context_ring_base,json=cmdContextRingBase,proto3" json:"cmd_context_ring_base,omitempty"`
	CmdContextPageBase uint64    `protobuf:"varint,3,opt,name=cmd_context_page_base,json=cmdContextPageBase,proto3" json:"cmd_context_page_base,omitempty"`
}

func (m *NvmeEnableResponse) Reset()                    { *m = NvmeEnableResponse{} }
func (m *NvmeEnableResponse) String() string            { return proto.CompactTextString(m) }
func (*NvmeEnableResponse) ProtoMessage()               {}
func (*NvmeEnableResponse) Descriptor() ([]byte, []int) { return fileDescriptorNvme, []int{2} }

func (m *NvmeEnableResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *NvmeEnableResponse) GetCmdContextRingBase() uint64 {
	if m != nil {
		return m.CmdContextRingBase
	}
	return 0
}

func (m *NvmeEnableResponse) GetCmdContextPageBase() uint64 {
	if m != nil {
		return m.CmdContextPageBase
	}
	return 0
}

// NvmeEnableResponseMsg is batched Response
type NvmeEnableResponseMsg struct {
	Response []*NvmeEnableResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *NvmeEnableResponseMsg) Reset()                    { *m = NvmeEnableResponseMsg{} }
func (m *NvmeEnableResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*NvmeEnableResponseMsg) ProtoMessage()               {}
func (*NvmeEnableResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptorNvme, []int{3} }

func (m *NvmeEnableResponseMsg) GetResponse() []*NvmeEnableResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

// **********************   Submission Queue  *****************************//
// NvmeSq object
type NvmeSqSpec struct {
	SqNum     uint32 `protobuf:"varint,1,opt,name=sq_num,json=sqNum,proto3" json:"sq_num,omitempty"`
	HwLifId   uint32 `protobuf:"varint,2,opt,name=hw_lif_id,json=hwLifId,proto3" json:"hw_lif_id,omitempty"`
	SqWqeSize uint32 `protobuf:"varint,3,opt,name=sq_wqe_size,json=sqWqeSize,proto3" json:"sq_wqe_size,omitempty"`
	NumSqWqes uint32 `protobuf:"varint,4,opt,name=num_sq_wqes,json=numSqWqes,proto3" json:"num_sq_wqes,omitempty"`
	BaseAddr  uint64 `protobuf:"varint,5,opt,name=base_addr,json=baseAddr,proto3" json:"base_addr,omitempty"`
	CqNum     uint32 `protobuf:"varint,6,opt,name=cq_num,json=cqNum,proto3" json:"cq_num,omitempty"`
}

func (m *NvmeSqSpec) Reset()                    { *m = NvmeSqSpec{} }
func (m *NvmeSqSpec) String() string            { return proto.CompactTextString(m) }
func (*NvmeSqSpec) ProtoMessage()               {}
func (*NvmeSqSpec) Descriptor() ([]byte, []int) { return fileDescriptorNvme, []int{4} }

func (m *NvmeSqSpec) GetSqNum() uint32 {
	if m != nil {
		return m.SqNum
	}
	return 0
}

func (m *NvmeSqSpec) GetHwLifId() uint32 {
	if m != nil {
		return m.HwLifId
	}
	return 0
}

func (m *NvmeSqSpec) GetSqWqeSize() uint32 {
	if m != nil {
		return m.SqWqeSize
	}
	return 0
}

func (m *NvmeSqSpec) GetNumSqWqes() uint32 {
	if m != nil {
		return m.NumSqWqes
	}
	return 0
}

func (m *NvmeSqSpec) GetBaseAddr() uint64 {
	if m != nil {
		return m.BaseAddr
	}
	return 0
}

func (m *NvmeSqSpec) GetCqNum() uint32 {
	if m != nil {
		return m.CqNum
	}
	return 0
}

// NvmeSqRequestMsg is batched request
type NvmeSqRequestMsg struct {
	Request []*NvmeSqSpec `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *NvmeSqRequestMsg) Reset()                    { *m = NvmeSqRequestMsg{} }
func (m *NvmeSqRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*NvmeSqRequestMsg) ProtoMessage()               {}
func (*NvmeSqRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptorNvme, []int{5} }

func (m *NvmeSqRequestMsg) GetRequest() []*NvmeSqSpec {
	if m != nil {
		return m.Request
	}
	return nil
}

// NvmeSqResponse response to one NvmeSqSpec
type NvmeSqResponse struct {
	ApiStatus ApiStatus `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty"`
}

func (m *NvmeSqResponse) Reset()                    { *m = NvmeSqResponse{} }
func (m *NvmeSqResponse) String() string            { return proto.CompactTextString(m) }
func (*NvmeSqResponse) ProtoMessage()               {}
func (*NvmeSqResponse) Descriptor() ([]byte, []int) { return fileDescriptorNvme, []int{6} }

func (m *NvmeSqResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

// NvmeSqResponseMsg is response to NvmeSqRequestMsg
type NvmeSqResponseMsg struct {
	Response []*NvmeSqResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *NvmeSqResponseMsg) Reset()                    { *m = NvmeSqResponseMsg{} }
func (m *NvmeSqResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*NvmeSqResponseMsg) ProtoMessage()               {}
func (*NvmeSqResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptorNvme, []int{7} }

func (m *NvmeSqResponseMsg) GetResponse() []*NvmeSqResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

// **********************   Completion Queue  *****************************//
// NvmeCq object
type NvmeCqSpec struct {
	CqNum     uint32 `protobuf:"varint,1,opt,name=cq_num,json=cqNum,proto3" json:"cq_num,omitempty"`
	HwLifId   uint32 `protobuf:"varint,2,opt,name=hw_lif_id,json=hwLifId,proto3" json:"hw_lif_id,omitempty"`
	CqWqeSize uint32 `protobuf:"varint,3,opt,name=cq_wqe_size,json=cqWqeSize,proto3" json:"cq_wqe_size,omitempty"`
	NumCqWqes uint32 `protobuf:"varint,4,opt,name=num_cq_wqes,json=numCqWqes,proto3" json:"num_cq_wqes,omitempty"`
	BaseAddr  uint64 `protobuf:"varint,5,opt,name=base_addr,json=baseAddr,proto3" json:"base_addr,omitempty"`
	IntNum    uint32 `protobuf:"varint,6,opt,name=int_num,json=intNum,proto3" json:"int_num,omitempty"`
}

func (m *NvmeCqSpec) Reset()                    { *m = NvmeCqSpec{} }
func (m *NvmeCqSpec) String() string            { return proto.CompactTextString(m) }
func (*NvmeCqSpec) ProtoMessage()               {}
func (*NvmeCqSpec) Descriptor() ([]byte, []int) { return fileDescriptorNvme, []int{8} }

func (m *NvmeCqSpec) GetCqNum() uint32 {
	if m != nil {
		return m.CqNum
	}
	return 0
}

func (m *NvmeCqSpec) GetHwLifId() uint32 {
	if m != nil {
		return m.HwLifId
	}
	return 0
}

func (m *NvmeCqSpec) GetCqWqeSize() uint32 {
	if m != nil {
		return m.CqWqeSize
	}
	return 0
}

func (m *NvmeCqSpec) GetNumCqWqes() uint32 {
	if m != nil {
		return m.NumCqWqes
	}
	return 0
}

func (m *NvmeCqSpec) GetBaseAddr() uint64 {
	if m != nil {
		return m.BaseAddr
	}
	return 0
}

func (m *NvmeCqSpec) GetIntNum() uint32 {
	if m != nil {
		return m.IntNum
	}
	return 0
}

// NvmeCqRequestMsg is batched request
type NvmeCqRequestMsg struct {
	Request []*NvmeCqSpec `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *NvmeCqRequestMsg) Reset()                    { *m = NvmeCqRequestMsg{} }
func (m *NvmeCqRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*NvmeCqRequestMsg) ProtoMessage()               {}
func (*NvmeCqRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptorNvme, []int{9} }

func (m *NvmeCqRequestMsg) GetRequest() []*NvmeCqSpec {
	if m != nil {
		return m.Request
	}
	return nil
}

// NvmeCqResponse response to one NvmeCqSpec
type NvmeCqResponse struct {
	ApiStatus     ApiStatus `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty"`
	CqIntrTblAddr uint32    `protobuf:"varint,2,opt,name=cq_intr_tbl_addr,json=cqIntrTblAddr,proto3" json:"cq_intr_tbl_addr,omitempty"`
}

func (m *NvmeCqResponse) Reset()                    { *m = NvmeCqResponse{} }
func (m *NvmeCqResponse) String() string            { return proto.CompactTextString(m) }
func (*NvmeCqResponse) ProtoMessage()               {}
func (*NvmeCqResponse) Descriptor() ([]byte, []int) { return fileDescriptorNvme, []int{10} }

func (m *NvmeCqResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *NvmeCqResponse) GetCqIntrTblAddr() uint32 {
	if m != nil {
		return m.CqIntrTblAddr
	}
	return 0
}

// NvmeCqResponseMsg is response to NvmeCqRequestMsg
type NvmeCqResponseMsg struct {
	Response []*NvmeCqResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *NvmeCqResponseMsg) Reset()                    { *m = NvmeCqResponseMsg{} }
func (m *NvmeCqResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*NvmeCqResponseMsg) ProtoMessage()               {}
func (*NvmeCqResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptorNvme, []int{11} }

func (m *NvmeCqResponseMsg) GetResponse() []*NvmeCqResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

// **********************   NameSpace *****************************//
// NvmeNs object
type NvmeNsSpec struct {
	Nsid        uint32 `protobuf:"varint,1,opt,name=nsid,proto3" json:"nsid,omitempty"`
	HwLifId     uint32 `protobuf:"varint,2,opt,name=hw_lif_id,json=hwLifId,proto3" json:"hw_lif_id,omitempty"`
	BackendNsid uint32 `protobuf:"varint,3,opt,name=backend_nsid,json=backendNsid,proto3" json:"backend_nsid,omitempty"`
	Size_       uint32 `protobuf:"varint,4,opt,name=size,proto3" json:"size,omitempty"`
	LbaSize     uint32 `protobuf:"varint,5,opt,name=lba_size,json=lbaSize,proto3" json:"lba_size,omitempty"`
	MaxSess     uint32 `protobuf:"varint,6,opt,name=max_sess,json=maxSess,proto3" json:"max_sess,omitempty"`
	KeyIndex    uint32 `protobuf:"varint,7,opt,name=key_index,json=keyIndex,proto3" json:"key_index,omitempty"`
	SecKeyIndex uint32 `protobuf:"varint,8,opt,name=sec_key_index,json=secKeyIndex,proto3" json:"sec_key_index,omitempty"`
}

func (m *NvmeNsSpec) Reset()                    { *m = NvmeNsSpec{} }
func (m *NvmeNsSpec) String() string            { return proto.CompactTextString(m) }
func (*NvmeNsSpec) ProtoMessage()               {}
func (*NvmeNsSpec) Descriptor() ([]byte, []int) { return fileDescriptorNvme, []int{12} }

func (m *NvmeNsSpec) GetNsid() uint32 {
	if m != nil {
		return m.Nsid
	}
	return 0
}

func (m *NvmeNsSpec) GetHwLifId() uint32 {
	if m != nil {
		return m.HwLifId
	}
	return 0
}

func (m *NvmeNsSpec) GetBackendNsid() uint32 {
	if m != nil {
		return m.BackendNsid
	}
	return 0
}

func (m *NvmeNsSpec) GetSize_() uint32 {
	if m != nil {
		return m.Size_
	}
	return 0
}

func (m *NvmeNsSpec) GetLbaSize() uint32 {
	if m != nil {
		return m.LbaSize
	}
	return 0
}

func (m *NvmeNsSpec) GetMaxSess() uint32 {
	if m != nil {
		return m.MaxSess
	}
	return 0
}

func (m *NvmeNsSpec) GetKeyIndex() uint32 {
	if m != nil {
		return m.KeyIndex
	}
	return 0
}

func (m *NvmeNsSpec) GetSecKeyIndex() uint32 {
	if m != nil {
		return m.SecKeyIndex
	}
	return 0
}

// NvmeNsRequestMsg is batched request used to create/update of Nvme QPs
type NvmeNsRequestMsg struct {
	Request []*NvmeNsSpec `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *NvmeNsRequestMsg) Reset()                    { *m = NvmeNsRequestMsg{} }
func (m *NvmeNsRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*NvmeNsRequestMsg) ProtoMessage()               {}
func (*NvmeNsRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptorNvme, []int{13} }

func (m *NvmeNsRequestMsg) GetRequest() []*NvmeNsSpec {
	if m != nil {
		return m.Request
	}
	return nil
}

// NvmeNsResponse response to one NvmeNsSpec
type NvmeNsResponse struct {
	ApiStatus ApiStatus `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty"`
	NscbAddr  uint64    `protobuf:"varint,2,opt,name=nscb_addr,json=nscbAddr,proto3" json:"nscb_addr,omitempty"`
}

func (m *NvmeNsResponse) Reset()                    { *m = NvmeNsResponse{} }
func (m *NvmeNsResponse) String() string            { return proto.CompactTextString(m) }
func (*NvmeNsResponse) ProtoMessage()               {}
func (*NvmeNsResponse) Descriptor() ([]byte, []int) { return fileDescriptorNvme, []int{14} }

func (m *NvmeNsResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *NvmeNsResponse) GetNscbAddr() uint64 {
	if m != nil {
		return m.NscbAddr
	}
	return 0
}

// NvmeNsResponseMsg is response to NvmeNsRequestMsg
type NvmeNsResponseMsg struct {
	Response []*NvmeNsResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *NvmeNsResponseMsg) Reset()                    { *m = NvmeNsResponseMsg{} }
func (m *NvmeNsResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*NvmeNsResponseMsg) ProtoMessage()               {}
func (*NvmeNsResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptorNvme, []int{15} }

func (m *NvmeNsResponseMsg) GetResponse() []*NvmeNsResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

// **********************   NameSpace *****************************//
// NvmeSess object
type NvmeSessSpec struct {
	HwLifId      uint32        `protobuf:"varint,1,opt,name=hw_lif_id,json=hwLifId,proto3" json:"hw_lif_id,omitempty"`
	Nsid         uint32        `protobuf:"varint,2,opt,name=nsid,proto3" json:"nsid,omitempty"`
	FlowKey      *FlowKey      `protobuf:"bytes,3,opt,name=flow_key,json=flowKey" json:"flow_key,omitempty"`
	VrfKeyHandle *VrfKeyHandle `protobuf:"bytes,4,opt,name=vrf_key_handle,json=vrfKeyHandle" json:"vrf_key_handle,omitempty"`
}

func (m *NvmeSessSpec) Reset()                    { *m = NvmeSessSpec{} }
func (m *NvmeSessSpec) String() string            { return proto.CompactTextString(m) }
func (*NvmeSessSpec) ProtoMessage()               {}
func (*NvmeSessSpec) Descriptor() ([]byte, []int) { return fileDescriptorNvme, []int{16} }

func (m *NvmeSessSpec) GetHwLifId() uint32 {
	if m != nil {
		return m.HwLifId
	}
	return 0
}

func (m *NvmeSessSpec) GetNsid() uint32 {
	if m != nil {
		return m.Nsid
	}
	return 0
}

func (m *NvmeSessSpec) GetFlowKey() *FlowKey {
	if m != nil {
		return m.FlowKey
	}
	return nil
}

func (m *NvmeSessSpec) GetVrfKeyHandle() *VrfKeyHandle {
	if m != nil {
		return m.VrfKeyHandle
	}
	return nil
}

// NvmeNsRequestMsg is batched request used to create/update of Nvme QPs
type NvmeSessRequestMsg struct {
	Request []*NvmeSessSpec `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *NvmeSessRequestMsg) Reset()                    { *m = NvmeSessRequestMsg{} }
func (m *NvmeSessRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*NvmeSessRequestMsg) ProtoMessage()               {}
func (*NvmeSessRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptorNvme, []int{17} }

func (m *NvmeSessRequestMsg) GetRequest() []*NvmeSessSpec {
	if m != nil {
		return m.Request
	}
	return nil
}

// NvmeSessResponse response to one NvmeSessSpec
type NvmeSessResponse struct {
	ApiStatus         ApiStatus `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty"`
	SessId            uint32    `protobuf:"varint,2,opt,name=sess_id,json=sessId,proto3" json:"sess_id,omitempty"`
	TxsessprodcbAddr  uint64    `protobuf:"varint,3,opt,name=txsessprodcb_addr,json=txsessprodcbAddr,proto3" json:"txsessprodcb_addr,omitempty"`
	RxsessprodcbAddr  uint64    `protobuf:"varint,4,opt,name=rxsessprodcb_addr,json=rxsessprodcbAddr,proto3" json:"rxsessprodcb_addr,omitempty"`
	TxXtsqBase        uint64    `protobuf:"varint,5,opt,name=tx_xtsq_base,json=txXtsqBase,proto3" json:"tx_xtsq_base,omitempty"`
	TxXtsqNumEntries  uint64    `protobuf:"varint,6,opt,name=tx_xtsq_num_entries,json=txXtsqNumEntries,proto3" json:"tx_xtsq_num_entries,omitempty"`
	TxDgstqBase       uint64    `protobuf:"varint,7,opt,name=tx_dgstq_base,json=txDgstqBase,proto3" json:"tx_dgstq_base,omitempty"`
	TxDgstqNumEntries uint64    `protobuf:"varint,8,opt,name=tx_dgstq_num_entries,json=txDgstqNumEntries,proto3" json:"tx_dgstq_num_entries,omitempty"`
	TxSesqBase        uint64    `protobuf:"varint,9,opt,name=tx_sesq_base,json=txSesqBase,proto3" json:"tx_sesq_base,omitempty"`
	TxSesqNumEntries  uint64    `protobuf:"varint,10,opt,name=tx_sesq_num_entries,json=txSesqNumEntries,proto3" json:"tx_sesq_num_entries,omitempty"`
	RxXtsqBase        uint64    `protobuf:"varint,11,opt,name=rx_xtsq_base,json=rxXtsqBase,proto3" json:"rx_xtsq_base,omitempty"`
	RxXtsqNumEntries  uint64    `protobuf:"varint,12,opt,name=rx_xtsq_num_entries,json=rxXtsqNumEntries,proto3" json:"rx_xtsq_num_entries,omitempty"`
	RxDgstqBase       uint64    `protobuf:"varint,13,opt,name=rx_dgstq_base,json=rxDgstqBase,proto3" json:"rx_dgstq_base,omitempty"`
	RxDgstqNumEntries uint64    `protobuf:"varint,14,opt,name=rx_dgstq_num_entries,json=rxDgstqNumEntries,proto3" json:"rx_dgstq_num_entries,omitempty"`
	RxSerqBase        uint64    `protobuf:"varint,15,opt,name=rx_serq_base,json=rxSerqBase,proto3" json:"rx_serq_base,omitempty"`
	RxSerqNumEntries  uint64    `protobuf:"varint,16,opt,name=rx_serq_num_entries,json=rxSerqNumEntries,proto3" json:"rx_serq_num_entries,omitempty"`
}

func (m *NvmeSessResponse) Reset()                    { *m = NvmeSessResponse{} }
func (m *NvmeSessResponse) String() string            { return proto.CompactTextString(m) }
func (*NvmeSessResponse) ProtoMessage()               {}
func (*NvmeSessResponse) Descriptor() ([]byte, []int) { return fileDescriptorNvme, []int{18} }

func (m *NvmeSessResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *NvmeSessResponse) GetSessId() uint32 {
	if m != nil {
		return m.SessId
	}
	return 0
}

func (m *NvmeSessResponse) GetTxsessprodcbAddr() uint64 {
	if m != nil {
		return m.TxsessprodcbAddr
	}
	return 0
}

func (m *NvmeSessResponse) GetRxsessprodcbAddr() uint64 {
	if m != nil {
		return m.RxsessprodcbAddr
	}
	return 0
}

func (m *NvmeSessResponse) GetTxXtsqBase() uint64 {
	if m != nil {
		return m.TxXtsqBase
	}
	return 0
}

func (m *NvmeSessResponse) GetTxXtsqNumEntries() uint64 {
	if m != nil {
		return m.TxXtsqNumEntries
	}
	return 0
}

func (m *NvmeSessResponse) GetTxDgstqBase() uint64 {
	if m != nil {
		return m.TxDgstqBase
	}
	return 0
}

func (m *NvmeSessResponse) GetTxDgstqNumEntries() uint64 {
	if m != nil {
		return m.TxDgstqNumEntries
	}
	return 0
}

func (m *NvmeSessResponse) GetTxSesqBase() uint64 {
	if m != nil {
		return m.TxSesqBase
	}
	return 0
}

func (m *NvmeSessResponse) GetTxSesqNumEntries() uint64 {
	if m != nil {
		return m.TxSesqNumEntries
	}
	return 0
}

func (m *NvmeSessResponse) GetRxXtsqBase() uint64 {
	if m != nil {
		return m.RxXtsqBase
	}
	return 0
}

func (m *NvmeSessResponse) GetRxXtsqNumEntries() uint64 {
	if m != nil {
		return m.RxXtsqNumEntries
	}
	return 0
}

func (m *NvmeSessResponse) GetRxDgstqBase() uint64 {
	if m != nil {
		return m.RxDgstqBase
	}
	return 0
}

func (m *NvmeSessResponse) GetRxDgstqNumEntries() uint64 {
	if m != nil {
		return m.RxDgstqNumEntries
	}
	return 0
}

func (m *NvmeSessResponse) GetRxSerqBase() uint64 {
	if m != nil {
		return m.RxSerqBase
	}
	return 0
}

func (m *NvmeSessResponse) GetRxSerqNumEntries() uint64 {
	if m != nil {
		return m.RxSerqNumEntries
	}
	return 0
}

// NvmeSessResponseMsg is response to NvmeSessRequestMsg
type NvmeSessResponseMsg struct {
	Response []*NvmeSessResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *NvmeSessResponseMsg) Reset()                    { *m = NvmeSessResponseMsg{} }
func (m *NvmeSessResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*NvmeSessResponseMsg) ProtoMessage()               {}
func (*NvmeSessResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptorNvme, []int{19} }

func (m *NvmeSessResponseMsg) GetResponse() []*NvmeSessResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

func init() {
	proto.RegisterType((*NvmeEnableRequest)(nil), "nvme.NvmeEnableRequest")
	proto.RegisterType((*NvmeEnableRequestMsg)(nil), "nvme.NvmeEnableRequestMsg")
	proto.RegisterType((*NvmeEnableResponse)(nil), "nvme.NvmeEnableResponse")
	proto.RegisterType((*NvmeEnableResponseMsg)(nil), "nvme.NvmeEnableResponseMsg")
	proto.RegisterType((*NvmeSqSpec)(nil), "nvme.NvmeSqSpec")
	proto.RegisterType((*NvmeSqRequestMsg)(nil), "nvme.NvmeSqRequestMsg")
	proto.RegisterType((*NvmeSqResponse)(nil), "nvme.NvmeSqResponse")
	proto.RegisterType((*NvmeSqResponseMsg)(nil), "nvme.NvmeSqResponseMsg")
	proto.RegisterType((*NvmeCqSpec)(nil), "nvme.NvmeCqSpec")
	proto.RegisterType((*NvmeCqRequestMsg)(nil), "nvme.NvmeCqRequestMsg")
	proto.RegisterType((*NvmeCqResponse)(nil), "nvme.NvmeCqResponse")
	proto.RegisterType((*NvmeCqResponseMsg)(nil), "nvme.NvmeCqResponseMsg")
	proto.RegisterType((*NvmeNsSpec)(nil), "nvme.NvmeNsSpec")
	proto.RegisterType((*NvmeNsRequestMsg)(nil), "nvme.NvmeNsRequestMsg")
	proto.RegisterType((*NvmeNsResponse)(nil), "nvme.NvmeNsResponse")
	proto.RegisterType((*NvmeNsResponseMsg)(nil), "nvme.NvmeNsResponseMsg")
	proto.RegisterType((*NvmeSessSpec)(nil), "nvme.NvmeSessSpec")
	proto.RegisterType((*NvmeSessRequestMsg)(nil), "nvme.NvmeSessRequestMsg")
	proto.RegisterType((*NvmeSessResponse)(nil), "nvme.NvmeSessResponse")
	proto.RegisterType((*NvmeSessResponseMsg)(nil), "nvme.NvmeSessResponseMsg")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Nvme service

type NvmeClient interface {
	// NVME feature Enable API
	NvmeEnable(ctx context.Context, in *NvmeEnableRequestMsg, opts ...grpc.CallOption) (*NvmeEnableResponseMsg, error)
	// Submission Q related APIs
	NvmeSqCreate(ctx context.Context, in *NvmeSqRequestMsg, opts ...grpc.CallOption) (*NvmeSqResponseMsg, error)
	// Completion Q related APIs
	NvmeCqCreate(ctx context.Context, in *NvmeCqRequestMsg, opts ...grpc.CallOption) (*NvmeCqResponseMsg, error)
	// Namespace related APIs
	NvmeNsCreate(ctx context.Context, in *NvmeNsRequestMsg, opts ...grpc.CallOption) (*NvmeNsResponseMsg, error)
	// Namespace related APIs
	NvmeSessCreate(ctx context.Context, in *NvmeSessRequestMsg, opts ...grpc.CallOption) (*NvmeSessResponseMsg, error)
}

type nvmeClient struct {
	cc *grpc.ClientConn
}

func NewNvmeClient(cc *grpc.ClientConn) NvmeClient {
	return &nvmeClient{cc}
}

func (c *nvmeClient) NvmeEnable(ctx context.Context, in *NvmeEnableRequestMsg, opts ...grpc.CallOption) (*NvmeEnableResponseMsg, error) {
	out := new(NvmeEnableResponseMsg)
	err := grpc.Invoke(ctx, "/nvme.Nvme/NvmeEnable", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nvmeClient) NvmeSqCreate(ctx context.Context, in *NvmeSqRequestMsg, opts ...grpc.CallOption) (*NvmeSqResponseMsg, error) {
	out := new(NvmeSqResponseMsg)
	err := grpc.Invoke(ctx, "/nvme.Nvme/NvmeSqCreate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nvmeClient) NvmeCqCreate(ctx context.Context, in *NvmeCqRequestMsg, opts ...grpc.CallOption) (*NvmeCqResponseMsg, error) {
	out := new(NvmeCqResponseMsg)
	err := grpc.Invoke(ctx, "/nvme.Nvme/NvmeCqCreate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nvmeClient) NvmeNsCreate(ctx context.Context, in *NvmeNsRequestMsg, opts ...grpc.CallOption) (*NvmeNsResponseMsg, error) {
	out := new(NvmeNsResponseMsg)
	err := grpc.Invoke(ctx, "/nvme.Nvme/NvmeNsCreate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nvmeClient) NvmeSessCreate(ctx context.Context, in *NvmeSessRequestMsg, opts ...grpc.CallOption) (*NvmeSessResponseMsg, error) {
	out := new(NvmeSessResponseMsg)
	err := grpc.Invoke(ctx, "/nvme.Nvme/NvmeSessCreate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Nvme service

type NvmeServer interface {
	// NVME feature Enable API
	NvmeEnable(context.Context, *NvmeEnableRequestMsg) (*NvmeEnableResponseMsg, error)
	// Submission Q related APIs
	NvmeSqCreate(context.Context, *NvmeSqRequestMsg) (*NvmeSqResponseMsg, error)
	// Completion Q related APIs
	NvmeCqCreate(context.Context, *NvmeCqRequestMsg) (*NvmeCqResponseMsg, error)
	// Namespace related APIs
	NvmeNsCreate(context.Context, *NvmeNsRequestMsg) (*NvmeNsResponseMsg, error)
	// Namespace related APIs
	NvmeSessCreate(context.Context, *NvmeSessRequestMsg) (*NvmeSessResponseMsg, error)
}

func RegisterNvmeServer(s *grpc.Server, srv NvmeServer) {
	s.RegisterService(&_Nvme_serviceDesc, srv)
}

func _Nvme_NvmeEnable_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NvmeEnableRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NvmeServer).NvmeEnable(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nvme.Nvme/NvmeEnable",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NvmeServer).NvmeEnable(ctx, req.(*NvmeEnableRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Nvme_NvmeSqCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NvmeSqRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NvmeServer).NvmeSqCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nvme.Nvme/NvmeSqCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NvmeServer).NvmeSqCreate(ctx, req.(*NvmeSqRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Nvme_NvmeCqCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NvmeCqRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NvmeServer).NvmeCqCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nvme.Nvme/NvmeCqCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NvmeServer).NvmeCqCreate(ctx, req.(*NvmeCqRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Nvme_NvmeNsCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NvmeNsRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NvmeServer).NvmeNsCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nvme.Nvme/NvmeNsCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NvmeServer).NvmeNsCreate(ctx, req.(*NvmeNsRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Nvme_NvmeSessCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NvmeSessRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NvmeServer).NvmeSessCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nvme.Nvme/NvmeSessCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NvmeServer).NvmeSessCreate(ctx, req.(*NvmeSessRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

var _Nvme_serviceDesc = grpc.ServiceDesc{
	ServiceName: "nvme.Nvme",
	HandlerType: (*NvmeServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "NvmeEnable",
			Handler:    _Nvme_NvmeEnable_Handler,
		},
		{
			MethodName: "NvmeSqCreate",
			Handler:    _Nvme_NvmeSqCreate_Handler,
		},
		{
			MethodName: "NvmeCqCreate",
			Handler:    _Nvme_NvmeCqCreate_Handler,
		},
		{
			MethodName: "NvmeNsCreate",
			Handler:    _Nvme_NvmeNsCreate_Handler,
		},
		{
			MethodName: "NvmeSessCreate",
			Handler:    _Nvme_NvmeSessCreate_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "nvme.proto",
}

func (m *NvmeEnableRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NvmeEnableRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MaxNs != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNvme(dAtA, i, uint64(m.MaxNs))
	}
	if m.MaxSess != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintNvme(dAtA, i, uint64(m.MaxSess))
	}
	if m.MaxCmdContext != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintNvme(dAtA, i, uint64(m.MaxCmdContext))
	}
	if m.TxMaxPduContext != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintNvme(dAtA, i, uint64(m.TxMaxPduContext))
	}
	if m.RxMaxPduContext != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintNvme(dAtA, i, uint64(m.RxMaxPduContext))
	}
	return i, nil
}

func (m *NvmeEnableRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NvmeEnableRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintNvme(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *NvmeEnableResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NvmeEnableResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNvme(dAtA, i, uint64(m.ApiStatus))
	}
	if m.CmdContextRingBase != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintNvme(dAtA, i, uint64(m.CmdContextRingBase))
	}
	if m.CmdContextPageBase != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintNvme(dAtA, i, uint64(m.CmdContextPageBase))
	}
	return i, nil
}

func (m *NvmeEnableResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NvmeEnableResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintNvme(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *NvmeSqSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NvmeSqSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SqNum != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNvme(dAtA, i, uint64(m.SqNum))
	}
	if m.HwLifId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintNvme(dAtA, i, uint64(m.HwLifId))
	}
	if m.SqWqeSize != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintNvme(dAtA, i, uint64(m.SqWqeSize))
	}
	if m.NumSqWqes != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintNvme(dAtA, i, uint64(m.NumSqWqes))
	}
	if m.BaseAddr != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintNvme(dAtA, i, uint64(m.BaseAddr))
	}
	if m.CqNum != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintNvme(dAtA, i, uint64(m.CqNum))
	}
	return i, nil
}

func (m *NvmeSqRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NvmeSqRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintNvme(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *NvmeSqResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NvmeSqResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNvme(dAtA, i, uint64(m.ApiStatus))
	}
	return i, nil
}

func (m *NvmeSqResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NvmeSqResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintNvme(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *NvmeCqSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NvmeCqSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CqNum != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNvme(dAtA, i, uint64(m.CqNum))
	}
	if m.HwLifId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintNvme(dAtA, i, uint64(m.HwLifId))
	}
	if m.CqWqeSize != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintNvme(dAtA, i, uint64(m.CqWqeSize))
	}
	if m.NumCqWqes != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintNvme(dAtA, i, uint64(m.NumCqWqes))
	}
	if m.BaseAddr != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintNvme(dAtA, i, uint64(m.BaseAddr))
	}
	if m.IntNum != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintNvme(dAtA, i, uint64(m.IntNum))
	}
	return i, nil
}

func (m *NvmeCqRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NvmeCqRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintNvme(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *NvmeCqResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NvmeCqResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNvme(dAtA, i, uint64(m.ApiStatus))
	}
	if m.CqIntrTblAddr != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintNvme(dAtA, i, uint64(m.CqIntrTblAddr))
	}
	return i, nil
}

func (m *NvmeCqResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NvmeCqResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintNvme(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *NvmeNsSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NvmeNsSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Nsid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNvme(dAtA, i, uint64(m.Nsid))
	}
	if m.HwLifId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintNvme(dAtA, i, uint64(m.HwLifId))
	}
	if m.BackendNsid != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintNvme(dAtA, i, uint64(m.BackendNsid))
	}
	if m.Size_ != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintNvme(dAtA, i, uint64(m.Size_))
	}
	if m.LbaSize != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintNvme(dAtA, i, uint64(m.LbaSize))
	}
	if m.MaxSess != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintNvme(dAtA, i, uint64(m.MaxSess))
	}
	if m.KeyIndex != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintNvme(dAtA, i, uint64(m.KeyIndex))
	}
	if m.SecKeyIndex != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintNvme(dAtA, i, uint64(m.SecKeyIndex))
	}
	return i, nil
}

func (m *NvmeNsRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NvmeNsRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintNvme(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *NvmeNsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NvmeNsResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNvme(dAtA, i, uint64(m.ApiStatus))
	}
	if m.NscbAddr != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintNvme(dAtA, i, uint64(m.NscbAddr))
	}
	return i, nil
}

func (m *NvmeNsResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NvmeNsResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintNvme(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *NvmeSessSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NvmeSessSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.HwLifId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNvme(dAtA, i, uint64(m.HwLifId))
	}
	if m.Nsid != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintNvme(dAtA, i, uint64(m.Nsid))
	}
	if m.FlowKey != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintNvme(dAtA, i, uint64(m.FlowKey.Size()))
		n1, err := m.FlowKey.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.VrfKeyHandle != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintNvme(dAtA, i, uint64(m.VrfKeyHandle.Size()))
		n2, err := m.VrfKeyHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}

func (m *NvmeSessRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NvmeSessRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintNvme(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *NvmeSessResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NvmeSessResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNvme(dAtA, i, uint64(m.ApiStatus))
	}
	if m.SessId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintNvme(dAtA, i, uint64(m.SessId))
	}
	if m.TxsessprodcbAddr != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintNvme(dAtA, i, uint64(m.TxsessprodcbAddr))
	}
	if m.RxsessprodcbAddr != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintNvme(dAtA, i, uint64(m.RxsessprodcbAddr))
	}
	if m.TxXtsqBase != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintNvme(dAtA, i, uint64(m.TxXtsqBase))
	}
	if m.TxXtsqNumEntries != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintNvme(dAtA, i, uint64(m.TxXtsqNumEntries))
	}
	if m.TxDgstqBase != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintNvme(dAtA, i, uint64(m.TxDgstqBase))
	}
	if m.TxDgstqNumEntries != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintNvme(dAtA, i, uint64(m.TxDgstqNumEntries))
	}
	if m.TxSesqBase != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintNvme(dAtA, i, uint64(m.TxSesqBase))
	}
	if m.TxSesqNumEntries != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintNvme(dAtA, i, uint64(m.TxSesqNumEntries))
	}
	if m.RxXtsqBase != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintNvme(dAtA, i, uint64(m.RxXtsqBase))
	}
	if m.RxXtsqNumEntries != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintNvme(dAtA, i, uint64(m.RxXtsqNumEntries))
	}
	if m.RxDgstqBase != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintNvme(dAtA, i, uint64(m.RxDgstqBase))
	}
	if m.RxDgstqNumEntries != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintNvme(dAtA, i, uint64(m.RxDgstqNumEntries))
	}
	if m.RxSerqBase != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintNvme(dAtA, i, uint64(m.RxSerqBase))
	}
	if m.RxSerqNumEntries != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintNvme(dAtA, i, uint64(m.RxSerqNumEntries))
	}
	return i, nil
}

func (m *NvmeSessResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NvmeSessResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintNvme(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func encodeVarintNvme(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *NvmeEnableRequest) Size() (n int) {
	var l int
	_ = l
	if m.MaxNs != 0 {
		n += 1 + sovNvme(uint64(m.MaxNs))
	}
	if m.MaxSess != 0 {
		n += 1 + sovNvme(uint64(m.MaxSess))
	}
	if m.MaxCmdContext != 0 {
		n += 1 + sovNvme(uint64(m.MaxCmdContext))
	}
	if m.TxMaxPduContext != 0 {
		n += 1 + sovNvme(uint64(m.TxMaxPduContext))
	}
	if m.RxMaxPduContext != 0 {
		n += 1 + sovNvme(uint64(m.RxMaxPduContext))
	}
	return n
}

func (m *NvmeEnableRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovNvme(uint64(l))
		}
	}
	return n
}

func (m *NvmeEnableResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovNvme(uint64(m.ApiStatus))
	}
	if m.CmdContextRingBase != 0 {
		n += 1 + sovNvme(uint64(m.CmdContextRingBase))
	}
	if m.CmdContextPageBase != 0 {
		n += 1 + sovNvme(uint64(m.CmdContextPageBase))
	}
	return n
}

func (m *NvmeEnableResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovNvme(uint64(l))
		}
	}
	return n
}

func (m *NvmeSqSpec) Size() (n int) {
	var l int
	_ = l
	if m.SqNum != 0 {
		n += 1 + sovNvme(uint64(m.SqNum))
	}
	if m.HwLifId != 0 {
		n += 1 + sovNvme(uint64(m.HwLifId))
	}
	if m.SqWqeSize != 0 {
		n += 1 + sovNvme(uint64(m.SqWqeSize))
	}
	if m.NumSqWqes != 0 {
		n += 1 + sovNvme(uint64(m.NumSqWqes))
	}
	if m.BaseAddr != 0 {
		n += 1 + sovNvme(uint64(m.BaseAddr))
	}
	if m.CqNum != 0 {
		n += 1 + sovNvme(uint64(m.CqNum))
	}
	return n
}

func (m *NvmeSqRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovNvme(uint64(l))
		}
	}
	return n
}

func (m *NvmeSqResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovNvme(uint64(m.ApiStatus))
	}
	return n
}

func (m *NvmeSqResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovNvme(uint64(l))
		}
	}
	return n
}

func (m *NvmeCqSpec) Size() (n int) {
	var l int
	_ = l
	if m.CqNum != 0 {
		n += 1 + sovNvme(uint64(m.CqNum))
	}
	if m.HwLifId != 0 {
		n += 1 + sovNvme(uint64(m.HwLifId))
	}
	if m.CqWqeSize != 0 {
		n += 1 + sovNvme(uint64(m.CqWqeSize))
	}
	if m.NumCqWqes != 0 {
		n += 1 + sovNvme(uint64(m.NumCqWqes))
	}
	if m.BaseAddr != 0 {
		n += 1 + sovNvme(uint64(m.BaseAddr))
	}
	if m.IntNum != 0 {
		n += 1 + sovNvme(uint64(m.IntNum))
	}
	return n
}

func (m *NvmeCqRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovNvme(uint64(l))
		}
	}
	return n
}

func (m *NvmeCqResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovNvme(uint64(m.ApiStatus))
	}
	if m.CqIntrTblAddr != 0 {
		n += 1 + sovNvme(uint64(m.CqIntrTblAddr))
	}
	return n
}

func (m *NvmeCqResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovNvme(uint64(l))
		}
	}
	return n
}

func (m *NvmeNsSpec) Size() (n int) {
	var l int
	_ = l
	if m.Nsid != 0 {
		n += 1 + sovNvme(uint64(m.Nsid))
	}
	if m.HwLifId != 0 {
		n += 1 + sovNvme(uint64(m.HwLifId))
	}
	if m.BackendNsid != 0 {
		n += 1 + sovNvme(uint64(m.BackendNsid))
	}
	if m.Size_ != 0 {
		n += 1 + sovNvme(uint64(m.Size_))
	}
	if m.LbaSize != 0 {
		n += 1 + sovNvme(uint64(m.LbaSize))
	}
	if m.MaxSess != 0 {
		n += 1 + sovNvme(uint64(m.MaxSess))
	}
	if m.KeyIndex != 0 {
		n += 1 + sovNvme(uint64(m.KeyIndex))
	}
	if m.SecKeyIndex != 0 {
		n += 1 + sovNvme(uint64(m.SecKeyIndex))
	}
	return n
}

func (m *NvmeNsRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovNvme(uint64(l))
		}
	}
	return n
}

func (m *NvmeNsResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovNvme(uint64(m.ApiStatus))
	}
	if m.NscbAddr != 0 {
		n += 1 + sovNvme(uint64(m.NscbAddr))
	}
	return n
}

func (m *NvmeNsResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovNvme(uint64(l))
		}
	}
	return n
}

func (m *NvmeSessSpec) Size() (n int) {
	var l int
	_ = l
	if m.HwLifId != 0 {
		n += 1 + sovNvme(uint64(m.HwLifId))
	}
	if m.Nsid != 0 {
		n += 1 + sovNvme(uint64(m.Nsid))
	}
	if m.FlowKey != nil {
		l = m.FlowKey.Size()
		n += 1 + l + sovNvme(uint64(l))
	}
	if m.VrfKeyHandle != nil {
		l = m.VrfKeyHandle.Size()
		n += 1 + l + sovNvme(uint64(l))
	}
	return n
}

func (m *NvmeSessRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovNvme(uint64(l))
		}
	}
	return n
}

func (m *NvmeSessResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovNvme(uint64(m.ApiStatus))
	}
	if m.SessId != 0 {
		n += 1 + sovNvme(uint64(m.SessId))
	}
	if m.TxsessprodcbAddr != 0 {
		n += 1 + sovNvme(uint64(m.TxsessprodcbAddr))
	}
	if m.RxsessprodcbAddr != 0 {
		n += 1 + sovNvme(uint64(m.RxsessprodcbAddr))
	}
	if m.TxXtsqBase != 0 {
		n += 1 + sovNvme(uint64(m.TxXtsqBase))
	}
	if m.TxXtsqNumEntries != 0 {
		n += 1 + sovNvme(uint64(m.TxXtsqNumEntries))
	}
	if m.TxDgstqBase != 0 {
		n += 1 + sovNvme(uint64(m.TxDgstqBase))
	}
	if m.TxDgstqNumEntries != 0 {
		n += 1 + sovNvme(uint64(m.TxDgstqNumEntries))
	}
	if m.TxSesqBase != 0 {
		n += 1 + sovNvme(uint64(m.TxSesqBase))
	}
	if m.TxSesqNumEntries != 0 {
		n += 1 + sovNvme(uint64(m.TxSesqNumEntries))
	}
	if m.RxXtsqBase != 0 {
		n += 1 + sovNvme(uint64(m.RxXtsqBase))
	}
	if m.RxXtsqNumEntries != 0 {
		n += 1 + sovNvme(uint64(m.RxXtsqNumEntries))
	}
	if m.RxDgstqBase != 0 {
		n += 1 + sovNvme(uint64(m.RxDgstqBase))
	}
	if m.RxDgstqNumEntries != 0 {
		n += 1 + sovNvme(uint64(m.RxDgstqNumEntries))
	}
	if m.RxSerqBase != 0 {
		n += 1 + sovNvme(uint64(m.RxSerqBase))
	}
	if m.RxSerqNumEntries != 0 {
		n += 2 + sovNvme(uint64(m.RxSerqNumEntries))
	}
	return n
}

func (m *NvmeSessResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovNvme(uint64(l))
		}
	}
	return n
}

func sovNvme(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozNvme(x uint64) (n int) {
	return sovNvme(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *NvmeEnableRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNvme
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NvmeEnableRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NvmeEnableRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxNs", wireType)
			}
			m.MaxNs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNvme
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxNs |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxSess", wireType)
			}
			m.MaxSess = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNvme
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxSess |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxCmdContext", wireType)
			}
			m.MaxCmdContext = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNvme
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxCmdContext |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxMaxPduContext", wireType)
			}
			m.TxMaxPduContext = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNvme
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TxMaxPduContext |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RxMaxPduContext", wireType)
			}
			m.RxMaxPduContext = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNvme
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RxMaxPduContext |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNvme(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNvme
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NvmeEnableRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNvme
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NvmeEnableRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NvmeEnableRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNvme
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNvme
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &NvmeEnableRequest{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNvme(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNvme
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NvmeEnableResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNvme
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NvmeEnableResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NvmeEnableResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNvme
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdContextRingBase", wireType)
			}
			m.CmdContextRingBase = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNvme
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CmdContextRingBase |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdContextPageBase", wireType)
			}
			m.CmdContextPageBase = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNvme
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CmdContextPageBase |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNvme(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNvme
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NvmeEnableResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNvme
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NvmeEnableResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NvmeEnableResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNvme
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNvme
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &NvmeEnableResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNvme(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNvme
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NvmeSqSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNvme
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NvmeSqSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NvmeSqSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SqNum", wireType)
			}
			m.SqNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNvme
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SqNum |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HwLifId", wireType)
			}
			m.HwLifId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNvme
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HwLifId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SqWqeSize", wireType)
			}
			m.SqWqeSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNvme
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SqWqeSize |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumSqWqes", wireType)
			}
			m.NumSqWqes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNvme
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumSqWqes |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseAddr", wireType)
			}
			m.BaseAddr = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNvme
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BaseAddr |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CqNum", wireType)
			}
			m.CqNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNvme
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CqNum |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNvme(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNvme
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NvmeSqRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNvme
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NvmeSqRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NvmeSqRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNvme
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNvme
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &NvmeSqSpec{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNvme(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNvme
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NvmeSqResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNvme
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NvmeSqResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NvmeSqResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNvme
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNvme(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNvme
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NvmeSqResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNvme
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NvmeSqResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NvmeSqResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNvme
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNvme
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &NvmeSqResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNvme(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNvme
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NvmeCqSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNvme
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NvmeCqSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NvmeCqSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CqNum", wireType)
			}
			m.CqNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNvme
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CqNum |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HwLifId", wireType)
			}
			m.HwLifId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNvme
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HwLifId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CqWqeSize", wireType)
			}
			m.CqWqeSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNvme
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CqWqeSize |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumCqWqes", wireType)
			}
			m.NumCqWqes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNvme
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumCqWqes |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseAddr", wireType)
			}
			m.BaseAddr = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNvme
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BaseAddr |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IntNum", wireType)
			}
			m.IntNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNvme
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IntNum |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNvme(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNvme
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NvmeCqRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNvme
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NvmeCqRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NvmeCqRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNvme
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNvme
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &NvmeCqSpec{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNvme(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNvme
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NvmeCqResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNvme
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NvmeCqResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NvmeCqResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNvme
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CqIntrTblAddr", wireType)
			}
			m.CqIntrTblAddr = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNvme
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CqIntrTblAddr |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNvme(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNvme
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NvmeCqResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNvme
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NvmeCqResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NvmeCqResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNvme
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNvme
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &NvmeCqResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNvme(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNvme
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NvmeNsSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNvme
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NvmeNsSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NvmeNsSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nsid", wireType)
			}
			m.Nsid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNvme
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nsid |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HwLifId", wireType)
			}
			m.HwLifId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNvme
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HwLifId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BackendNsid", wireType)
			}
			m.BackendNsid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNvme
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BackendNsid |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNvme
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LbaSize", wireType)
			}
			m.LbaSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNvme
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LbaSize |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxSess", wireType)
			}
			m.MaxSess = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNvme
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxSess |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyIndex", wireType)
			}
			m.KeyIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNvme
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyIndex |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecKeyIndex", wireType)
			}
			m.SecKeyIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNvme
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SecKeyIndex |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNvme(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNvme
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NvmeNsRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNvme
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NvmeNsRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NvmeNsRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNvme
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNvme
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &NvmeNsSpec{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNvme(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNvme
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NvmeNsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNvme
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NvmeNsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NvmeNsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNvme
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NscbAddr", wireType)
			}
			m.NscbAddr = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNvme
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NscbAddr |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNvme(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNvme
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NvmeNsResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNvme
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NvmeNsResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NvmeNsResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNvme
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNvme
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &NvmeNsResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNvme(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNvme
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NvmeSessSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNvme
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NvmeSessSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NvmeSessSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HwLifId", wireType)
			}
			m.HwLifId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNvme
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HwLifId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nsid", wireType)
			}
			m.Nsid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNvme
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nsid |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlowKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNvme
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNvme
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FlowKey == nil {
				m.FlowKey = &FlowKey{}
			}
			if err := m.FlowKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VrfKeyHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNvme
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNvme
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VrfKeyHandle == nil {
				m.VrfKeyHandle = &VrfKeyHandle{}
			}
			if err := m.VrfKeyHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNvme(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNvme
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NvmeSessRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNvme
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NvmeSessRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NvmeSessRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNvme
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNvme
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &NvmeSessSpec{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNvme(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNvme
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NvmeSessResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNvme
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NvmeSessResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NvmeSessResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNvme
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessId", wireType)
			}
			m.SessId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNvme
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SessId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxsessprodcbAddr", wireType)
			}
			m.TxsessprodcbAddr = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNvme
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TxsessprodcbAddr |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RxsessprodcbAddr", wireType)
			}
			m.RxsessprodcbAddr = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNvme
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RxsessprodcbAddr |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxXtsqBase", wireType)
			}
			m.TxXtsqBase = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNvme
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TxXtsqBase |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxXtsqNumEntries", wireType)
			}
			m.TxXtsqNumEntries = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNvme
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TxXtsqNumEntries |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxDgstqBase", wireType)
			}
			m.TxDgstqBase = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNvme
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TxDgstqBase |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxDgstqNumEntries", wireType)
			}
			m.TxDgstqNumEntries = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNvme
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TxDgstqNumEntries |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxSesqBase", wireType)
			}
			m.TxSesqBase = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNvme
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TxSesqBase |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxSesqNumEntries", wireType)
			}
			m.TxSesqNumEntries = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNvme
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TxSesqNumEntries |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RxXtsqBase", wireType)
			}
			m.RxXtsqBase = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNvme
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RxXtsqBase |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RxXtsqNumEntries", wireType)
			}
			m.RxXtsqNumEntries = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNvme
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RxXtsqNumEntries |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RxDgstqBase", wireType)
			}
			m.RxDgstqBase = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNvme
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RxDgstqBase |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RxDgstqNumEntries", wireType)
			}
			m.RxDgstqNumEntries = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNvme
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RxDgstqNumEntries |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RxSerqBase", wireType)
			}
			m.RxSerqBase = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNvme
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RxSerqBase |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RxSerqNumEntries", wireType)
			}
			m.RxSerqNumEntries = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNvme
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RxSerqNumEntries |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNvme(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNvme
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NvmeSessResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNvme
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NvmeSessResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NvmeSessResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNvme
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNvme
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &NvmeSessResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNvme(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNvme
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipNvme(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowNvme
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowNvme
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowNvme
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthNvme
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowNvme
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipNvme(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthNvme = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowNvme   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("nvme.proto", fileDescriptorNvme) }

var fileDescriptorNvme = []byte{
	// 1152 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x97, 0xdd, 0x72, 0xe3, 0x34,
	0x14, 0xc7, 0xd7, 0xdb, 0x34, 0x1f, 0x27, 0x4d, 0x9b, 0x6a, 0xfb, 0x91, 0x6d, 0x67, 0x3a, 0xc5,
	0x17, 0xb0, 0x43, 0xa1, 0xcb, 0x16, 0x86, 0x4b, 0x66, 0x5a, 0x53, 0x96, 0x4c, 0x69, 0x66, 0xc7,
	0x61, 0x80, 0xe1, 0x02, 0x8f, 0x63, 0x2b, 0x89, 0xa9, 0xad, 0xc4, 0x92, 0xd2, 0xba, 0xfb, 0x3a,
	0x70, 0xc7, 0x25, 0xc3, 0x33, 0xc0, 0x25, 0x8f, 0x00, 0xbd, 0xe4, 0x29, 0x18, 0x49, 0x76, 0x2c,
	0xc7, 0x29, 0x74, 0x7a, 0x55, 0x59, 0xfa, 0xeb, 0xf4, 0x9c, 0xff, 0x4f, 0x3e, 0x72, 0x00, 0xc8,
	0x75, 0x84, 0x8f, 0xa7, 0x74, 0xc2, 0x27, 0xa8, 0x22, 0xc6, 0x7b, 0x4d, 0x7e, 0x3b, 0xc5, 0x4c,
	0x4d, 0xed, 0xb5, 0x18, 0x66, 0x2c, 0x98, 0x90, 0xf4, 0xb1, 0x7e, 0x35, 0x56, 0x23, 0xf3, 0x77,
	0x03, 0x36, 0x7b, 0xd7, 0x11, 0x3e, 0x27, 0xee, 0x20, 0xc4, 0x36, 0x8e, 0x67, 0x98, 0x71, 0xb4,
	0x0d, 0xd5, 0xc8, 0x4d, 0x1c, 0xc2, 0x3a, 0xc6, 0xa1, 0xf1, 0xa2, 0x65, 0xaf, 0x46, 0x6e, 0xd2,
	0x63, 0xe8, 0x39, 0xd4, 0xc5, 0xb4, 0x88, 0xd5, 0x79, 0x2a, 0x17, 0x6a, 0x91, 0x9b, 0xf4, 0x31,
	0x63, 0xe8, 0x5d, 0xd8, 0x10, 0x4b, 0x5e, 0xe4, 0x3b, 0xde, 0x84, 0x70, 0x9c, 0xf0, 0xce, 0x8a,
	0x54, 0xb4, 0x22, 0x37, 0xb1, 0x22, 0xdf, 0x52, 0x93, 0xe8, 0x08, 0x10, 0x4f, 0x1c, 0x21, 0x9d,
	0xfa, 0xb3, 0xb9, 0xb4, 0x22, 0xa5, 0x1b, 0x3c, 0xb9, 0x74, 0x93, 0x37, 0xfe, 0x4c, 0x13, 0xd3,
	0xb2, 0x78, 0x55, 0x89, 0x69, 0x51, 0x6c, 0x76, 0x61, 0xab, 0x54, 0xc8, 0x25, 0x1b, 0xa1, 0x57,
	0x50, 0xa3, 0xea, 0xa9, 0x63, 0x1c, 0xae, 0xbc, 0x68, 0x9e, 0xec, 0x1e, 0x4b, 0xaf, 0x4a, 0x62,
	0x3b, 0xd3, 0x99, 0xbf, 0x18, 0x80, 0xf4, 0x65, 0x36, 0x9d, 0x10, 0x86, 0xd1, 0x4b, 0x00, 0x77,
	0x1a, 0x38, 0x8c, 0xbb, 0x7c, 0xa6, 0x9c, 0x59, 0x3f, 0x69, 0x1f, 0x2b, 0x9b, 0x4f, 0xa7, 0x41,
	0x5f, 0xce, 0xdb, 0x0d, 0x37, 0x1b, 0xa2, 0x57, 0xb0, 0xad, 0x19, 0xe2, 0xd0, 0x80, 0x8c, 0x9c,
	0x81, 0xcb, 0xb0, 0x34, 0xaf, 0x62, 0x23, 0x6f, 0xee, 0x8b, 0x1d, 0x90, 0xd1, 0x99, 0xcb, 0xf0,
	0xe2, 0x96, 0xa9, 0x3b, 0xc2, 0x6a, 0xcb, 0xca, 0xe2, 0x96, 0x37, 0xee, 0x08, 0x8b, 0x2d, 0xe6,
	0x25, 0x6c, 0x97, 0x93, 0x15, 0x95, 0x7f, 0x02, 0x75, 0x9a, 0x3e, 0xa6, 0xa5, 0x77, 0xca, 0xa5,
	0xab, 0x75, 0x7b, 0xae, 0x34, 0x7f, 0x35, 0x00, 0x84, 0xa0, 0x1f, 0xf7, 0xa7, 0xd8, 0x13, 0x47,
	0x81, 0xc5, 0x0e, 0x99, 0x45, 0xd9, 0x51, 0x60, 0x71, 0x6f, 0x16, 0xa1, 0x3d, 0x68, 0x8c, 0x6f,
	0x9c, 0x30, 0x18, 0x3a, 0x81, 0x9f, 0x9d, 0x85, 0xf1, 0xcd, 0x57, 0xc1, 0xb0, 0xeb, 0xa3, 0x03,
	0x68, 0xb2, 0xd8, 0xb9, 0x89, 0xb1, 0xc3, 0x82, 0xb7, 0x38, 0x3d, 0x07, 0x0d, 0x16, 0x7f, 0x1b,
	0xe3, 0x7e, 0xf0, 0x16, 0x8b, 0x75, 0x32, 0x8b, 0x1c, 0xa5, 0x61, 0x29, 0xfc, 0x06, 0x99, 0x45,
	0x7d, 0x21, 0x61, 0x68, 0x1f, 0x1a, 0xa2, 0x64, 0xc7, 0xf5, 0x7d, 0x2a, 0x69, 0x57, 0xec, 0xba,
	0x98, 0x38, 0xf5, 0x7d, 0x2a, 0xf2, 0xf1, 0x54, 0x3e, 0x55, 0x95, 0x8f, 0x27, 0xf2, 0x31, 0x3f,
	0x83, 0xb6, 0x4a, 0x5a, 0x23, 0xff, 0xfe, 0x22, 0xf9, 0x76, 0x5e, 0xbe, 0xaa, 0x2e, 0x47, 0x7e,
	0x0a, 0xeb, 0xd9, 0xfe, 0x47, 0xd2, 0x36, 0xcf, 0xd5, 0x9b, 0x94, 0x87, 0x10, 0x39, 0x7c, 0x54,
	0x62, 0xb0, 0xa5, 0x27, 0xb1, 0xc4, 0xff, 0xdf, 0x52, 0xff, 0xad, 0xb9, 0xff, 0x5e, 0xc1, 0x7f,
	0xef, 0x21, 0xfe, 0x7b, 0x65, 0xff, 0xbd, 0x45, 0xff, 0xbd, 0x92, 0xff, 0xd6, 0x03, 0xfc, 0xdf,
	0x85, 0x5a, 0x40, 0xb8, 0x06, 0xa0, 0x1a, 0x10, 0xae, 0x11, 0xb0, 0x1e, 0x4a, 0xc0, 0x5a, 0x20,
	0xf0, 0xa3, 0x22, 0x60, 0x3d, 0x9e, 0x00, 0x7a, 0x0f, 0xda, 0x5e, 0xec, 0x04, 0x84, 0x53, 0x87,
	0x0f, 0x42, 0x95, 0xbf, 0xf2, 0xa6, 0xe5, 0xc5, 0x5d, 0xc2, 0xe9, 0xd7, 0x83, 0x50, 0x14, 0x91,
	0xa1, 0xb2, 0x1e, 0x8e, 0xca, 0x5a, 0x86, 0xea, 0x9f, 0x14, 0x55, 0x8f, 0x49, 0x54, 0x08, 0x2a,
	0x84, 0x05, 0x7e, 0x0a, 0x4a, 0x8e, 0xff, 0x93, 0xd3, 0x3b, 0xb0, 0x36, 0x70, 0xbd, 0x2b, 0x4c,
	0x7c, 0x47, 0xee, 0x53, 0xa0, 0x9a, 0xe9, 0x5c, 0x4f, 0x6c, 0x47, 0x50, 0x91, 0x0c, 0x15, 0x23,
	0x39, 0x16, 0x5d, 0x38, 0x1c, 0xb8, 0x8a, 0xad, 0xea, 0x85, 0xb5, 0x70, 0xe0, 0xf6, 0xd3, 0xa5,
	0x79, 0x83, 0xae, 0x16, 0x1b, 0xf4, 0x3e, 0x34, 0xae, 0xf0, 0xad, 0x13, 0x10, 0x1f, 0x27, 0x9d,
	0x9a, 0x5c, 0xab, 0x5f, 0xe1, 0xdb, 0xae, 0x78, 0x46, 0x26, 0xb4, 0x18, 0xf6, 0x9c, 0x5c, 0x50,
	0x57, 0xa9, 0x30, 0xec, 0x5d, 0xa4, 0x9a, 0x8c, 0x6f, 0x8f, 0x3d, 0x90, 0xaf, 0x32, 0x25, 0xe7,
	0xfb, 0x83, 0xe2, 0x2b, 0xf6, 0x3f, 0x96, 0xef, 0x3e, 0x34, 0x08, 0xf3, 0x06, 0x39, 0xd8, 0x8a,
	0x5d, 0x17, 0x13, 0x3a, 0xd3, 0x3c, 0xfe, 0xff, 0x32, 0xcd, 0xa5, 0x1a, 0xd3, 0x9f, 0x0c, 0x58,
	0x93, 0xef, 0x26, 0x66, 0x8a, 0x6a, 0x81, 0xa0, 0x51, 0x24, 0x98, 0x11, 0x7f, 0xaa, 0x11, 0x3f,
	0x82, 0xfa, 0x30, 0x9c, 0xdc, 0x08, 0x33, 0x25, 0x51, 0x61, 0x4a, 0x76, 0xfb, 0x7e, 0x11, 0x4e,
	0x6e, 0x2e, 0xf0, 0xad, 0x5d, 0x1b, 0xaa, 0x01, 0xfa, 0x14, 0xd6, 0xaf, 0xe9, 0x50, 0x1a, 0x3f,
	0x76, 0x89, 0x1f, 0x2a, 0xd2, 0x62, 0xcb, 0xd5, 0xf8, 0xf8, 0x1b, 0x3a, 0xbc, 0xc0, 0xb7, 0x5f,
	0xca, 0x79, 0x7b, 0xed, 0x5a, 0x7b, 0x32, 0xcf, 0xd4, 0x05, 0x25, 0x92, 0xd4, 0x70, 0x7c, 0xb0,
	0x88, 0x03, 0x69, 0xbd, 0x26, 0xad, 0x27, 0x07, 0xf2, 0xf3, 0x6a, 0xda, 0x33, 0x65, 0x90, 0xc7,
	0x32, 0xd9, 0x85, 0x9a, 0xa8, 0x2e, 0x3f, 0xde, 0x55, 0xf1, 0xd8, 0x15, 0x3e, 0x6c, 0xf2, 0x44,
	0x8c, 0xa7, 0x74, 0xe2, 0x67, 0xd0, 0xd4, 0x2d, 0xd6, 0xd6, 0x17, 0x64, 0x57, 0x39, 0x82, 0x4d,
	0x5a, 0x12, 0x57, 0x94, 0x98, 0x2e, 0x8a, 0x0f, 0x61, 0x8d, 0x27, 0x4e, 0xc2, 0x59, 0xac, 0xae,
	0x46, 0xd5, 0xa2, 0x80, 0x27, 0xdf, 0x71, 0x16, 0xcb, 0x5b, 0xf4, 0x43, 0x78, 0x96, 0x29, 0x44,
	0xa7, 0xc3, 0x84, 0xd3, 0x00, 0xab, 0x57, 0x42, 0xfe, 0x77, 0x21, 0xec, 0xcd, 0xa2, 0x73, 0x35,
	0x2f, 0x8e, 0x3f, 0x4f, 0x1c, 0x7f, 0xc4, 0x78, 0x1a, 0xb1, 0x26, 0x85, 0x4d, 0x9e, 0x7c, 0x2e,
	0xe6, 0x64, 0xc8, 0x97, 0xb0, 0x35, 0xd7, 0xe8, 0x31, 0xeb, 0x52, 0xba, 0x99, 0x4a, 0xb5, 0xa0,
	0x2a, 0x4b, 0x86, 0xb3, 0x2c, 0x1b, 0x59, 0x96, 0x7d, 0x5c, 0xc8, 0x52, 0x2a, 0xf4, 0x88, 0x90,
	0x65, 0x29, 0x84, 0xc5, 0x80, 0x54, 0x2f, 0xbb, 0xa9, 0x02, 0xd2, 0x42, 0xd9, 0x74, 0x49, 0xd9,
	0x6b, 0x99, 0x8f, 0xe5, 0xb2, 0x69, 0xa1, 0xec, 0x96, 0x2a, 0x9b, 0x16, 0xcb, 0xa6, 0xcb, 0xca,
	0x5e, 0x57, 0x65, 0xd3, 0x65, 0x65, 0x53, 0x51, 0x14, 0x4d, 0x63, 0x6e, 0x64, 0x59, 0xf6, 0x31,
	0xd5, 0xb3, 0x94, 0x0a, 0x3d, 0x62, 0x3b, 0xcb, 0x52, 0x08, 0xf3, 0x80, 0x66, 0x17, 0x9e, 0x2d,
	0x9e, 0x52, 0x71, 0xd6, 0x4f, 0x4a, 0x6f, 0xf6, 0x4e, 0xf1, 0xb0, 0x97, 0xdf, 0xed, 0x93, 0xbf,
	0x9f, 0x42, 0x45, 0x2c, 0xa3, 0xd7, 0xaa, 0x6f, 0xab, 0x6f, 0x20, 0xb4, 0x77, 0xcf, 0x07, 0xe1,
	0x25, 0x1b, 0xed, 0xed, 0xdf, 0xf7, 0xc5, 0x74, 0xc9, 0x46, 0xe6, 0x13, 0x74, 0x9a, 0x36, 0x8b,
	0xd8, 0xa2, 0xd8, 0xe5, 0x18, 0xed, 0x14, 0x2f, 0xf7, 0x79, 0x98, 0xdd, 0x65, 0x97, 0x7e, 0x21,
	0x84, 0xb5, 0x24, 0x84, 0x75, 0x4f, 0x08, 0x6b, 0x79, 0x88, 0x1e, 0x2b, 0x87, 0xd0, 0xdb, 0xb5,
	0x1e, 0xa2, 0xd0, 0x26, 0xcd, 0x27, 0xe8, 0x75, 0xfa, 0xfd, 0x83, 0x59, 0x16, 0xa4, 0xb3, 0x68,
	0xe7, 0x3c, 0xcc, 0xf3, 0xe5, 0x46, 0xcb, 0x40, 0x67, 0x3b, 0x7f, 0xdc, 0x1d, 0x18, 0x7f, 0xde,
	0x1d, 0x18, 0x7f, 0xdd, 0x1d, 0x18, 0xdf, 0xd7, 0xc7, 0x6e, 0x28, 0x7f, 0x68, 0x0c, 0xaa, 0xf2,
	0xcf, 0xc7, 0xff, 0x06, 0x00, 0x00, 0xff, 0xff, 0xae, 0x9d, 0xc5, 0x99, 0xa9, 0x0c, 0x00, 0x00,
}
