// Code generated by protoc-gen-go. DO NOT EDIT.
// source: nic/proto/hal/acl.proto

/*
Package halproto is a generated protocol buffer package.

It is generated from these files:
	nic/proto/hal/acl.proto
	nic/proto/hal/cpucb.proto
	nic/proto/hal/crypto_keys.proto
	nic/proto/hal/descriptor_aol.proto
	nic/proto/hal/endpoint.proto
	nic/proto/hal/interface.proto
	nic/proto/hal/internal.proto
	nic/proto/hal/ipseccb.proto
	nic/proto/hal/l2segment.proto
	nic/proto/hal/l4lb.proto
	nic/proto/hal/multicast.proto
	nic/proto/hal/nic.proto
	nic/proto/hal/nw.proto
	nic/proto/hal/nwsec.proto
	nic/proto/hal/proxy.proto
	nic/proto/hal/qos.proto
	nic/proto/hal/rdma.proto
	nic/proto/hal/session.proto
	nic/proto/hal/system.proto
	nic/proto/hal/tcp_proxy_cb.proto
	nic/proto/hal/telemetry.proto
	nic/proto/hal/tenant.proto
	nic/proto/hal/tls_proxy_cb.proto
	nic/proto/hal/wring.proto
	nic/proto/types.proto

It has these top-level messages:
	AclHandle
	AclKeyHandle
	EthSelector
	UDPSelector
	TCPSelector
	ICMPSelector
	IPSelector
	AclInternalSelector
	AclInternalActionInfo
	AclSelector
	AclActionInfo
	AclSpec
	AclRequestMsg
	AclStatus
	AclResponse
	AclResponseMsg
	AclDeleteRequest
	AclDeleteRequestMsg
	AclDeleteResponse
	AclDeleteResponseMsg
	AclGetRequest
	AclGetRequestMsg
	AclStats
	AclGetResponse
	AclGetResponseMsg
	CpuCbKeyHandle
	CpuCbSpec
	CpuCbRequestMsg
	CpuCbStatus
	CpuCbResponse
	CpuCbResponseMsg
	CpuCbDeleteRequest
	CpuCbDeleteRequestMsg
	CpuCbDeleteResponseMsg
	CpuCbGetRequest
	CpuCbGetRequestMsg
	CpuCbStats
	CpuCbGetResponse
	CpuCbGetResponseMsg
	CryptoKeyCreateRequest
	CryptoKeyCreateRequestMsg
	CryptoKeyCreateResponse
	CryptoKeyCreateResponseMsg
	CryptoKeySpec
	CryptoKeyReadRequest
	CryptoKeyReadRequestMsg
	CryptoKeyReadResponse
	CryptoKeyReadResponseMsg
	CryptoKeyUpdateRequest
	CryptoKeyUpdateRequestMsg
	CryptoKeyUpdateResponse
	CryptoKeyUpdateResponseMsg
	CryptoKeyDeleteRequest
	CryptoKeyDeleteRequestMsg
	CryptoKeyDeleteResponse
	CryptoKeyDeleteResponseMsg
	DescrAolRequest
	DescrAolRequestMsg
	DescrAolSpec
	DescrAolResponseMsg
	EndpointSpec
	EndpointRequestMsg
	EndpointStatus
	EndpointResponse
	EndpointResponseMsg
	EndpointL2Key
	EndpointL3Key
	EndpointKey
	EndpointKeyHandle
	EndpointUpdateRequest
	EndpointUpdateRequestMsg
	EndpointUpdateResponseMsg
	EndpointFilter
	EndpointDeleteRequest
	EndpointDeleteRequestMsg
	EndpointDeleteResponseMsg
	EndpointGetRequest
	EndpointGetRequestMsg
	EndpointGetByInterfaceRequestMsg
	EndpointGetAllRequestMsg
	EndpointStats
	EndpointGetResponse
	EndpointGetResponseMsg
	LifQStateMapEntry
	LifKeyHandle
	LifSpec
	LifRequestMsg
	LifStatus
	LifQState
	LifResponse
	LifResponseMsg
	QStateGetReq
	GetQStateRequestMsg
	QStateGetResp
	GetQStateResponseMsg
	P4ProgLabel
	QStateSetReq
	SetQStateRequestMsg
	QStateSetResp
	SetQStateResponseMsg
	LifDeleteRequest
	LifDeleteRequestMsg
	LifDeleteResponseMsg
	LifTxStats
	LifRxStats
	LifStats
	LifGetRequest
	LifGetRequestMsg
	LifGetResponse
	LifGetResponseMsg
	IfEnicInfo
	TrafficClassInfo
	IfUplinkInfo
	IfUplinkPCInfo
	InterfaceKeyHandle
	IfTunnelVxlanInfo
	IfTunnelInfo
	IfCPUInfo
	InterfaceSpec
	InterfaceRequestMsg
	InterfaceStatus
	InterfaceResponse
	InterfaceResponseMsg
	InterfaceDeleteRequest
	InterfaceDeleteRequestMsg
	InterfaceDeleteResponseMsg
	InterfaceStats
	InterfaceGetRequest
	InterfaceGetRequestMsg
	InterfaceGetResponse
	InterfaceGetResponseMsg
	InterfaceL2SegmentSpec
	InterfaceL2SegmentRequestMsg
	InterfaceL2SegmentResponse
	InterfaceL2SegmentResponseMsg
	ProgramAddressReq
	ProgramAddressResp
	GetProgramAddressRequestMsg
	ProgramAddressResponseMsg
	HbmAddressReq
	HbmAddressResp
	AllocHbmAddressRequestMsg
	AllocHbmAddressResponseMsg
	IpsecCbKeyHandle
	IpsecCbSpec
	IpsecCbRequestMsg
	IpsecCbStatus
	IpsecCbResponse
	IpsecCbResponseMsg
	IpsecCbDeleteRequest
	IpsecCbDeleteRequestMsg
	IpsecCbDeleteResponseMsg
	IpsecCbGetRequest
	IpsecCbGetRequestMsg
	IpsecCbStats
	IpsecCbGetResponse
	IpsecCbGetResponseMsg
	L2SegmentKeyHandle
	L2SegmentSpec
	L2SegmentRequestMsg
	L2SegmentStatus
	L2SegmentResponse
	L2SegmentResponseMsg
	L2SegmentDeleteRequest
	L2SegmentDeleteRequestMsg
	L2SegmentDeleteResponseMsg
	L2SegmentGetRequest
	L2SegmentGetRequestMsg
	L2SegmentStats
	L2SegmentGetResponse
	L2SegmentGetResponseMsg
	LBMethod
	HealthCheck
	L4LbServiceKey
	L4LbServiceKeyHandle
	L4LbServiceSpec
	L4LbServiceRequestMsg
	L4LbServiceStatus
	L4LbServiceResponse
	L4LbServiceResponseMsg
	L4LbServiceDeleteRequest
	L4LbServiceDeleteRequestMsg
	L4LbServiceDeleteResponseMsg
	L4LbServiceStats
	L4LbBackendKey
	L4LbBackendKeyHandle
	L4LbBackendSpec
	L4LbBackendRequestMsg
	L4LbBackendStatus
	L4LbBackendResponse
	L4LbBackendResponseMsg
	L4LbBackendDeleteRequest
	L4LbBackendDeleteRequestMsg
	L4LbBackendDeleteResponseMsg
	L4LbBackendStats
	L4LbBackendGetRequest
	L4LbBackendGetRequestMsg
	L4LbBackendGetResponse
	L4LbBackendGetResponseMsg
	L4LbServiceGetRequest
	L4LbServiceGetRequestMsg
	L4LbServiceGetResponse
	L4LbServiceGetResponseMsg
	MulticastEntryKeyIP
	MulticastEntryKeyMac
	MulticastEntryKey
	MulticastEntryKeyHandle
	MulticastEntrySpec
	MulticastEntryRequestMsg
	MulticastEntryStatus
	MulticastEntryResponse
	MulticastEntryResponseMsg
	MulticastEntryDeleteRequest
	MulticastEntryDeleteRequestMsg
	MulticastEntryDeleteResponseMsg
	MulticastEntryGetRequest
	MulticastEntryGetRequestMsg
	MulticastEntryGetResponse
	MulticastEntryGetResponseMsg
	RootConfig
	NetworkKeyHandle
	NetworkSpec
	NetworkRequestMsg
	NetworkStatus
	NetworkResponse
	NetworkResponseMsg
	NetworkDeleteRequest
	NetworkDeleteRequestMsg
	NetworkDeleteResponseMsg
	NetworkStats
	NetworkGetRequest
	NetworkGetRequestMsg
	NetworkGetResponse
	NetworkGetResponseMsg
	SecurityProfileKeyHandle
	SecurityProfileSpec
	SecurityProfileRequestMsg
	SecurityProfileStatus
	SecurityProfileResponse
	SecurityProfileResponseMsg
	SecurityProfileDeleteRequest
	SecurityProfileDeleteRequestMsg
	SecurityProfileDeleteResponseMsg
	SecurityProfileGetRequest
	SecurityProfileGetRequestMsg
	SecurityProfileStats
	SecurityProfileGetResponse
	SecurityProfileGetResponseMsg
	Service
	ALG
	FirewallRuleSpec
	DoSSessionLimits
	DoSPolicer
	DoSFloodLimits
	DoSProtectionSpec
	IngressSGPolicy
	EgressSGPolicy
	SecurityGroupKeyHandle
	SecurityGroupSpec
	SecurityGroupRequestMsg
	SecurityGroupStatus
	SecurityGroupResponse
	SecurityGroupResponseMsg
	SecurityGroupDeleteRequest
	SecurityGroupDeleteRequestMsg
	SecurityGroupDeleteResponseMsg
	SecurityGroupGetRequest
	SecurityGroupGetRequestMsg
	SecurityGroupStats
	SecurityGroupGetResponse
	SecurityGroupGetResponseMsg
	ProxyKeyHandle
	ProxySpec
	ProxyRequestMsg
	ProxyStatus
	ProxyResponse
	ProxyResponseMsg
	ProxyDisableRequest
	ProxyDisableRequestMsg
	ProxyDisableResponseMsg
	ProxyGetRequest
	ProxyGetRequestMsg
	ProxyStats
	ProxyGetResponse
	ProxyGetResponseMsg
	ProxyFlowConfigRequest
	ProxyFlowConfigRequestMsg
	ProxyGetFlowInfoRequest
	ProxyGetFlowInfoRequestMsg
	ProxyGetFlowInfoResponse
	ProxyGetFlowInfoResponseMsg
	MarkingActionSpec
	QOSActions
	TrafficClass
	TrafficClassQueueMap
	BufPoolHandle
	BufPoolKeyHandle
	BufPoolSpec
	BufPoolRequestMsg
	BufPoolStatus
	BufPoolResponse
	BufPoolResponseMsg
	BufPoolDeleteRequest
	BufPoolDeleteRequestMsg
	BufPoolDeleteResponseMsg
	BufPoolStats
	BufPoolGetRequest
	BufPoolGetRequestMsg
	BufPoolGetResponse
	BufPoolGetResponseMsg
	QueueHandle
	QueueKeyHandle
	DWRRInfo
	StrictPriorityInfo
	QueueSchedulerNode
	QueueInfo
	QueueSpec
	QueueRequestMsg
	QueueStatus
	QueueResponse
	QueueResponseMsg
	QueueDeleteRequest
	QueueDeleteRequestMsg
	QueueDeleteResponseMsg
	QueueStats
	QueueGetRequest
	QueueGetRequestMsg
	QueueGetResponse
	QueueGetResponseMsg
	PolicerHandle
	PolicerKeyHandle
	PolicerSpec
	PolicerRequestMsg
	PolicerStatus
	PolicerResponse
	PolicerResponseMsg
	PolicerDeleteRequest
	PolicerDeleteRequestMsg
	PolicerDeleteResponseMsg
	PolicerGetRequest
	PolicerGetRequestMsg
	PolicerStats
	PolicerGetResponse
	PolicerGetResponseMsg
	RdmaQpSpec
	RdmaQpRequestMsg
	RdmaQpResponse
	RdmaQpResponseMsg
	RdmaCqSpec
	RdmaCqRequestMsg
	RdmaCqResponse
	RdmaCqResponseMsg
	RdmaMemRegSpec
	RdmaMemRegRequestMsg
	RdmaMemRegResponse
	RdmaMemRegResponseMsg
	FlowKeyL2
	FlowKeyTcpUdpInfo
	FlowKeyICMPInfo
	FlowKeyESPInfo
	FlowKeyV4
	FlowKeyV6
	FlowKey
	FlowInfo
	ConnTrackInfo
	FlowData
	FlowSpec
	SessionSpec
	SessionRequestMsg
	FlowStatus
	SessionStatus
	SessionResponse
	SessionResponseMsg
	SessionDeleteRequest
	SessionDeleteRequestMsg
	SessionDeleteResponseMsg
	SessionGetRequest
	SessionGetRequestMsg
	FlowStats
	SessionStats
	SessionGetResponse
	SessionGetResponseMsg
	SystemResponse
	Stats
	DropStats
	DropStatsEntry
	TcpCbKeyHandle
	TcpCbSpec
	TcpCbRequestMsg
	TcpCbStatus
	TcpCbResponse
	TcpCbResponseMsg
	TcpCbDeleteRequest
	TcpCbDeleteRequestMsg
	TcpCbDeleteResponseMsg
	TcpCbGetRequest
	TcpCbGetRequestMsg
	TcpCbStats
	TcpCbGetResponse
	TcpCbGetResponseMsg
	L4Port
	MacAddress
	CollectorSpec
	CollectorStatus
	Collector
	CollectorConfigMsg
	CollectorResponseMsg
	ExportControlId
	ExportControlSpec
	ExportControlStatus
	ExportControl
	ExportControlConfigMsg
	ExportControlResponseMsg
	MonitorAction
	FlowMonitorRuleSpec
	FlowMonitorRuleStatus
	FlowMonitorRule
	FlowMonitorRuleConfigMsg
	FlowMonitorRuleResponseMsg
	RSpanSpec
	ERSpanSpec
	MirrorSessionId
	MirrorSessionSpec
	MirrorSessionStatus
	MirrorSession
	MirrorSessionConfigMsg
	MirrorSessionDeleteMsg
	MirrorSessionResponseMsg
	TenantKeyHandle
	TenantSpec
	TenantRequestMsg
	TenantStatus
	TenantResponse
	TenantResponseMsg
	TenantDeleteRequest
	TenantDeleteRequestMsg
	TenantDeleteResponseMsg
	TenantGetRequest
	TenantGetRequestMsg
	TenantStats
	TenantGetResponse
	TenantGetResponseMsg
	TlsCbKeyHandle
	TlsCbSpec
	TlsCbRequestMsg
	TlsCbStatus
	TlsCbResponse
	TlsCbResponseMsg
	TlsCbDeleteRequest
	TlsCbDeleteRequestMsg
	TlsCbDeleteResponseMsg
	TlsCbGetRequest
	TlsCbGetRequestMsg
	TlsCbStats
	TlsCbGetResponse
	TlsCbGetResponseMsg
	WRingKeyHandle
	WRingSpec
	WRingRequestMsg
	WRingStatus
	WRingResponse
	WRingResponseMsg
	WRingDeleteRequest
	WRingDeleteRequestMsg
	WRingDeleteResponseMsg
	WRingGetEntriesRequest
	WRingGetEntriesRequestMsg
	WRingStats
	WRingBarcoGCMDescMsg
	WRingGetEntriesResponse
	WRingGetEntriesResponseMsg
	WRingGetMetaResponse
	WRingGetMetaResponseMsg
	ObjectMeta
	EncapInfo
	IPAddress
	IPPrefix
	L4PortRange
	Empty
*/
package halproto

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// AclAction specifies all possible actions for ACL entries
type AclAction int32

const (
	AclAction_ACL_ACTION_NONE     AclAction = 0
	AclAction_ACL_ACTION_PERMIT   AclAction = 1
	AclAction_ACL_ACTION_LOG      AclAction = 2
	AclAction_ACL_ACTION_DENY     AclAction = 3
	AclAction_ACL_ACTION_REDIRECT AclAction = 4
)

var AclAction_name = map[int32]string{
	0: "ACL_ACTION_NONE",
	1: "ACL_ACTION_PERMIT",
	2: "ACL_ACTION_LOG",
	3: "ACL_ACTION_DENY",
	4: "ACL_ACTION_REDIRECT",
}
var AclAction_value = map[string]int32{
	"ACL_ACTION_NONE":     0,
	"ACL_ACTION_PERMIT":   1,
	"ACL_ACTION_LOG":      2,
	"ACL_ACTION_DENY":     3,
	"ACL_ACTION_REDIRECT": 4,
}

func (x AclAction) String() string {
	return proto.EnumName(AclAction_name, int32(x))
}
func (AclAction) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

// Handle of the acl
type AclHandle struct {
	Handle uint64 `protobuf:"fixed64,1,opt,name=handle" json:"handle,omitempty"`
}

func (m *AclHandle) Reset()                    { *m = AclHandle{} }
func (m *AclHandle) String() string            { return proto.CompactTextString(m) }
func (*AclHandle) ProtoMessage()               {}
func (*AclHandle) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *AclHandle) GetHandle() uint64 {
	if m != nil {
		return m.Handle
	}
	return 0
}

// AclKeyHandle uniquely identifies a Acl
type AclKeyHandle struct {
	// Types that are valid to be assigned to KeyOrHandle:
	//	*AclKeyHandle_AclId
	//	*AclKeyHandle_AclHandle
	KeyOrHandle isAclKeyHandle_KeyOrHandle `protobuf_oneof:"key_or_handle"`
}

func (m *AclKeyHandle) Reset()                    { *m = AclKeyHandle{} }
func (m *AclKeyHandle) String() string            { return proto.CompactTextString(m) }
func (*AclKeyHandle) ProtoMessage()               {}
func (*AclKeyHandle) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

type isAclKeyHandle_KeyOrHandle interface {
	isAclKeyHandle_KeyOrHandle()
}

type AclKeyHandle_AclId struct {
	AclId uint32 `protobuf:"fixed32,1,opt,name=acl_id,json=aclId,oneof"`
}
type AclKeyHandle_AclHandle struct {
	AclHandle *AclHandle `protobuf:"bytes,2,opt,name=acl_handle,json=aclHandle,oneof"`
}

func (*AclKeyHandle_AclId) isAclKeyHandle_KeyOrHandle()     {}
func (*AclKeyHandle_AclHandle) isAclKeyHandle_KeyOrHandle() {}

func (m *AclKeyHandle) GetKeyOrHandle() isAclKeyHandle_KeyOrHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

func (m *AclKeyHandle) GetAclId() uint32 {
	if x, ok := m.GetKeyOrHandle().(*AclKeyHandle_AclId); ok {
		return x.AclId
	}
	return 0
}

func (m *AclKeyHandle) GetAclHandle() *AclHandle {
	if x, ok := m.GetKeyOrHandle().(*AclKeyHandle_AclHandle); ok {
		return x.AclHandle
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*AclKeyHandle) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _AclKeyHandle_OneofMarshaler, _AclKeyHandle_OneofUnmarshaler, _AclKeyHandle_OneofSizer, []interface{}{
		(*AclKeyHandle_AclId)(nil),
		(*AclKeyHandle_AclHandle)(nil),
	}
}

func _AclKeyHandle_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*AclKeyHandle)
	// key_or_handle
	switch x := m.KeyOrHandle.(type) {
	case *AclKeyHandle_AclId:
		b.EncodeVarint(1<<3 | proto.WireFixed32)
		b.EncodeFixed32(uint64(x.AclId))
	case *AclKeyHandle_AclHandle:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.AclHandle); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("AclKeyHandle.KeyOrHandle has unexpected type %T", x)
	}
	return nil
}

func _AclKeyHandle_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*AclKeyHandle)
	switch tag {
	case 1: // key_or_handle.acl_id
		if wire != proto.WireFixed32 {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeFixed32()
		m.KeyOrHandle = &AclKeyHandle_AclId{uint32(x)}
		return true, err
	case 2: // key_or_handle.acl_handle
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(AclHandle)
		err := b.DecodeMessage(msg)
		m.KeyOrHandle = &AclKeyHandle_AclHandle{msg}
		return true, err
	default:
		return false, nil
	}
}

func _AclKeyHandle_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*AclKeyHandle)
	// key_or_handle
	switch x := m.KeyOrHandle.(type) {
	case *AclKeyHandle_AclId:
		n += proto.SizeVarint(1<<3 | proto.WireFixed32)
		n += 4
	case *AclKeyHandle_AclHandle:
		s := proto.Size(x.AclHandle)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// EthSelector has match criteria for non-IP packets
type EthSelector struct {
	EthType     uint32 `protobuf:"varint,1,opt,name=eth_type,json=ethType" json:"eth_type,omitempty"`
	EthTypeMask uint32 `protobuf:"varint,2,opt,name=eth_type_mask,json=ethTypeMask" json:"eth_type_mask,omitempty"`
	SrcMac      uint64 `protobuf:"varint,3,opt,name=src_mac,json=srcMac" json:"src_mac,omitempty"`
	SrcMacMask  uint64 `protobuf:"varint,4,opt,name=src_mac_mask,json=srcMacMask" json:"src_mac_mask,omitempty"`
	DstMac      uint64 `protobuf:"varint,5,opt,name=dst_mac,json=dstMac" json:"dst_mac,omitempty"`
	DstMacMask  uint64 `protobuf:"varint,6,opt,name=dst_mac_mask,json=dstMacMask" json:"dst_mac_mask,omitempty"`
}

func (m *EthSelector) Reset()                    { *m = EthSelector{} }
func (m *EthSelector) String() string            { return proto.CompactTextString(m) }
func (*EthSelector) ProtoMessage()               {}
func (*EthSelector) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *EthSelector) GetEthType() uint32 {
	if m != nil {
		return m.EthType
	}
	return 0
}

func (m *EthSelector) GetEthTypeMask() uint32 {
	if m != nil {
		return m.EthTypeMask
	}
	return 0
}

func (m *EthSelector) GetSrcMac() uint64 {
	if m != nil {
		return m.SrcMac
	}
	return 0
}

func (m *EthSelector) GetSrcMacMask() uint64 {
	if m != nil {
		return m.SrcMacMask
	}
	return 0
}

func (m *EthSelector) GetDstMac() uint64 {
	if m != nil {
		return m.DstMac
	}
	return 0
}

func (m *EthSelector) GetDstMacMask() uint64 {
	if m != nil {
		return m.DstMacMask
	}
	return 0
}

// UDPSelector is used to specify match criteria for UDP traffic
type UDPSelector struct {
	SrcPortRange *L4PortRange `protobuf:"bytes,1,opt,name=src_port_range,json=srcPortRange" json:"src_port_range,omitempty"`
	DstPortRange *L4PortRange `protobuf:"bytes,2,opt,name=dst_port_range,json=dstPortRange" json:"dst_port_range,omitempty"`
}

func (m *UDPSelector) Reset()                    { *m = UDPSelector{} }
func (m *UDPSelector) String() string            { return proto.CompactTextString(m) }
func (*UDPSelector) ProtoMessage()               {}
func (*UDPSelector) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *UDPSelector) GetSrcPortRange() *L4PortRange {
	if m != nil {
		return m.SrcPortRange
	}
	return nil
}

func (m *UDPSelector) GetDstPortRange() *L4PortRange {
	if m != nil {
		return m.DstPortRange
	}
	return nil
}

// TCPSelector is used to specify match criteria for TCP traffic
type TCPSelector struct {
	// Types that are valid to be assigned to TcpSyn:
	//	*TCPSelector_TcpSynSet
	//	*TCPSelector_TcpSynClear
	TcpSyn isTCPSelector_TcpSyn `protobuf_oneof:"tcp_syn"`
	// Types that are valid to be assigned to TcpAck:
	//	*TCPSelector_TcpAckSet
	//	*TCPSelector_TcpAckClear
	TcpAck isTCPSelector_TcpAck `protobuf_oneof:"tcp_ack"`
	// Types that are valid to be assigned to TcpFin:
	//	*TCPSelector_TcpFinSet
	//	*TCPSelector_TcpFinClear
	TcpFin isTCPSelector_TcpFin `protobuf_oneof:"tcp_fin"`
	// Types that are valid to be assigned to TcpRst:
	//	*TCPSelector_TcpRstSet
	//	*TCPSelector_TcpRstClear
	TcpRst isTCPSelector_TcpRst `protobuf_oneof:"tcp_rst"`
	// Types that are valid to be assigned to TcpUrg:
	//	*TCPSelector_TcpUrgSet
	//	*TCPSelector_TcpUrgClear
	TcpUrg       isTCPSelector_TcpUrg `protobuf_oneof:"tcp_urg"`
	SrcPortRange *L4PortRange         `protobuf:"bytes,11,opt,name=src_port_range,json=srcPortRange" json:"src_port_range,omitempty"`
	DstPortRange *L4PortRange         `protobuf:"bytes,12,opt,name=dst_port_range,json=dstPortRange" json:"dst_port_range,omitempty"`
}

func (m *TCPSelector) Reset()                    { *m = TCPSelector{} }
func (m *TCPSelector) String() string            { return proto.CompactTextString(m) }
func (*TCPSelector) ProtoMessage()               {}
func (*TCPSelector) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

type isTCPSelector_TcpSyn interface {
	isTCPSelector_TcpSyn()
}
type isTCPSelector_TcpAck interface {
	isTCPSelector_TcpAck()
}
type isTCPSelector_TcpFin interface {
	isTCPSelector_TcpFin()
}
type isTCPSelector_TcpRst interface {
	isTCPSelector_TcpRst()
}
type isTCPSelector_TcpUrg interface {
	isTCPSelector_TcpUrg()
}

type TCPSelector_TcpSynSet struct {
	TcpSynSet bool `protobuf:"varint,1,opt,name=tcp_syn_set,json=tcpSynSet,oneof"`
}
type TCPSelector_TcpSynClear struct {
	TcpSynClear bool `protobuf:"varint,2,opt,name=tcp_syn_clear,json=tcpSynClear,oneof"`
}
type TCPSelector_TcpAckSet struct {
	TcpAckSet bool `protobuf:"varint,3,opt,name=tcp_ack_set,json=tcpAckSet,oneof"`
}
type TCPSelector_TcpAckClear struct {
	TcpAckClear bool `protobuf:"varint,4,opt,name=tcp_ack_clear,json=tcpAckClear,oneof"`
}
type TCPSelector_TcpFinSet struct {
	TcpFinSet bool `protobuf:"varint,5,opt,name=tcp_fin_set,json=tcpFinSet,oneof"`
}
type TCPSelector_TcpFinClear struct {
	TcpFinClear bool `protobuf:"varint,6,opt,name=tcp_fin_clear,json=tcpFinClear,oneof"`
}
type TCPSelector_TcpRstSet struct {
	TcpRstSet bool `protobuf:"varint,7,opt,name=tcp_rst_set,json=tcpRstSet,oneof"`
}
type TCPSelector_TcpRstClear struct {
	TcpRstClear bool `protobuf:"varint,8,opt,name=tcp_rst_clear,json=tcpRstClear,oneof"`
}
type TCPSelector_TcpUrgSet struct {
	TcpUrgSet bool `protobuf:"varint,9,opt,name=tcp_urg_set,json=tcpUrgSet,oneof"`
}
type TCPSelector_TcpUrgClear struct {
	TcpUrgClear bool `protobuf:"varint,10,opt,name=tcp_urg_clear,json=tcpUrgClear,oneof"`
}

func (*TCPSelector_TcpSynSet) isTCPSelector_TcpSyn()   {}
func (*TCPSelector_TcpSynClear) isTCPSelector_TcpSyn() {}
func (*TCPSelector_TcpAckSet) isTCPSelector_TcpAck()   {}
func (*TCPSelector_TcpAckClear) isTCPSelector_TcpAck() {}
func (*TCPSelector_TcpFinSet) isTCPSelector_TcpFin()   {}
func (*TCPSelector_TcpFinClear) isTCPSelector_TcpFin() {}
func (*TCPSelector_TcpRstSet) isTCPSelector_TcpRst()   {}
func (*TCPSelector_TcpRstClear) isTCPSelector_TcpRst() {}
func (*TCPSelector_TcpUrgSet) isTCPSelector_TcpUrg()   {}
func (*TCPSelector_TcpUrgClear) isTCPSelector_TcpUrg() {}

func (m *TCPSelector) GetTcpSyn() isTCPSelector_TcpSyn {
	if m != nil {
		return m.TcpSyn
	}
	return nil
}
func (m *TCPSelector) GetTcpAck() isTCPSelector_TcpAck {
	if m != nil {
		return m.TcpAck
	}
	return nil
}
func (m *TCPSelector) GetTcpFin() isTCPSelector_TcpFin {
	if m != nil {
		return m.TcpFin
	}
	return nil
}
func (m *TCPSelector) GetTcpRst() isTCPSelector_TcpRst {
	if m != nil {
		return m.TcpRst
	}
	return nil
}
func (m *TCPSelector) GetTcpUrg() isTCPSelector_TcpUrg {
	if m != nil {
		return m.TcpUrg
	}
	return nil
}

func (m *TCPSelector) GetTcpSynSet() bool {
	if x, ok := m.GetTcpSyn().(*TCPSelector_TcpSynSet); ok {
		return x.TcpSynSet
	}
	return false
}

func (m *TCPSelector) GetTcpSynClear() bool {
	if x, ok := m.GetTcpSyn().(*TCPSelector_TcpSynClear); ok {
		return x.TcpSynClear
	}
	return false
}

func (m *TCPSelector) GetTcpAckSet() bool {
	if x, ok := m.GetTcpAck().(*TCPSelector_TcpAckSet); ok {
		return x.TcpAckSet
	}
	return false
}

func (m *TCPSelector) GetTcpAckClear() bool {
	if x, ok := m.GetTcpAck().(*TCPSelector_TcpAckClear); ok {
		return x.TcpAckClear
	}
	return false
}

func (m *TCPSelector) GetTcpFinSet() bool {
	if x, ok := m.GetTcpFin().(*TCPSelector_TcpFinSet); ok {
		return x.TcpFinSet
	}
	return false
}

func (m *TCPSelector) GetTcpFinClear() bool {
	if x, ok := m.GetTcpFin().(*TCPSelector_TcpFinClear); ok {
		return x.TcpFinClear
	}
	return false
}

func (m *TCPSelector) GetTcpRstSet() bool {
	if x, ok := m.GetTcpRst().(*TCPSelector_TcpRstSet); ok {
		return x.TcpRstSet
	}
	return false
}

func (m *TCPSelector) GetTcpRstClear() bool {
	if x, ok := m.GetTcpRst().(*TCPSelector_TcpRstClear); ok {
		return x.TcpRstClear
	}
	return false
}

func (m *TCPSelector) GetTcpUrgSet() bool {
	if x, ok := m.GetTcpUrg().(*TCPSelector_TcpUrgSet); ok {
		return x.TcpUrgSet
	}
	return false
}

func (m *TCPSelector) GetTcpUrgClear() bool {
	if x, ok := m.GetTcpUrg().(*TCPSelector_TcpUrgClear); ok {
		return x.TcpUrgClear
	}
	return false
}

func (m *TCPSelector) GetSrcPortRange() *L4PortRange {
	if m != nil {
		return m.SrcPortRange
	}
	return nil
}

func (m *TCPSelector) GetDstPortRange() *L4PortRange {
	if m != nil {
		return m.DstPortRange
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*TCPSelector) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _TCPSelector_OneofMarshaler, _TCPSelector_OneofUnmarshaler, _TCPSelector_OneofSizer, []interface{}{
		(*TCPSelector_TcpSynSet)(nil),
		(*TCPSelector_TcpSynClear)(nil),
		(*TCPSelector_TcpAckSet)(nil),
		(*TCPSelector_TcpAckClear)(nil),
		(*TCPSelector_TcpFinSet)(nil),
		(*TCPSelector_TcpFinClear)(nil),
		(*TCPSelector_TcpRstSet)(nil),
		(*TCPSelector_TcpRstClear)(nil),
		(*TCPSelector_TcpUrgSet)(nil),
		(*TCPSelector_TcpUrgClear)(nil),
	}
}

func _TCPSelector_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*TCPSelector)
	// tcp_syn
	switch x := m.TcpSyn.(type) {
	case *TCPSelector_TcpSynSet:
		t := uint64(0)
		if x.TcpSynSet {
			t = 1
		}
		b.EncodeVarint(1<<3 | proto.WireVarint)
		b.EncodeVarint(t)
	case *TCPSelector_TcpSynClear:
		t := uint64(0)
		if x.TcpSynClear {
			t = 1
		}
		b.EncodeVarint(2<<3 | proto.WireVarint)
		b.EncodeVarint(t)
	case nil:
	default:
		return fmt.Errorf("TCPSelector.TcpSyn has unexpected type %T", x)
	}
	// tcp_ack
	switch x := m.TcpAck.(type) {
	case *TCPSelector_TcpAckSet:
		t := uint64(0)
		if x.TcpAckSet {
			t = 1
		}
		b.EncodeVarint(3<<3 | proto.WireVarint)
		b.EncodeVarint(t)
	case *TCPSelector_TcpAckClear:
		t := uint64(0)
		if x.TcpAckClear {
			t = 1
		}
		b.EncodeVarint(4<<3 | proto.WireVarint)
		b.EncodeVarint(t)
	case nil:
	default:
		return fmt.Errorf("TCPSelector.TcpAck has unexpected type %T", x)
	}
	// tcp_fin
	switch x := m.TcpFin.(type) {
	case *TCPSelector_TcpFinSet:
		t := uint64(0)
		if x.TcpFinSet {
			t = 1
		}
		b.EncodeVarint(5<<3 | proto.WireVarint)
		b.EncodeVarint(t)
	case *TCPSelector_TcpFinClear:
		t := uint64(0)
		if x.TcpFinClear {
			t = 1
		}
		b.EncodeVarint(6<<3 | proto.WireVarint)
		b.EncodeVarint(t)
	case nil:
	default:
		return fmt.Errorf("TCPSelector.TcpFin has unexpected type %T", x)
	}
	// tcp_rst
	switch x := m.TcpRst.(type) {
	case *TCPSelector_TcpRstSet:
		t := uint64(0)
		if x.TcpRstSet {
			t = 1
		}
		b.EncodeVarint(7<<3 | proto.WireVarint)
		b.EncodeVarint(t)
	case *TCPSelector_TcpRstClear:
		t := uint64(0)
		if x.TcpRstClear {
			t = 1
		}
		b.EncodeVarint(8<<3 | proto.WireVarint)
		b.EncodeVarint(t)
	case nil:
	default:
		return fmt.Errorf("TCPSelector.TcpRst has unexpected type %T", x)
	}
	// tcp_urg
	switch x := m.TcpUrg.(type) {
	case *TCPSelector_TcpUrgSet:
		t := uint64(0)
		if x.TcpUrgSet {
			t = 1
		}
		b.EncodeVarint(9<<3 | proto.WireVarint)
		b.EncodeVarint(t)
	case *TCPSelector_TcpUrgClear:
		t := uint64(0)
		if x.TcpUrgClear {
			t = 1
		}
		b.EncodeVarint(10<<3 | proto.WireVarint)
		b.EncodeVarint(t)
	case nil:
	default:
		return fmt.Errorf("TCPSelector.TcpUrg has unexpected type %T", x)
	}
	return nil
}

func _TCPSelector_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*TCPSelector)
	switch tag {
	case 1: // tcp_syn.tcp_syn_set
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.TcpSyn = &TCPSelector_TcpSynSet{x != 0}
		return true, err
	case 2: // tcp_syn.tcp_syn_clear
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.TcpSyn = &TCPSelector_TcpSynClear{x != 0}
		return true, err
	case 3: // tcp_ack.tcp_ack_set
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.TcpAck = &TCPSelector_TcpAckSet{x != 0}
		return true, err
	case 4: // tcp_ack.tcp_ack_clear
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.TcpAck = &TCPSelector_TcpAckClear{x != 0}
		return true, err
	case 5: // tcp_fin.tcp_fin_set
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.TcpFin = &TCPSelector_TcpFinSet{x != 0}
		return true, err
	case 6: // tcp_fin.tcp_fin_clear
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.TcpFin = &TCPSelector_TcpFinClear{x != 0}
		return true, err
	case 7: // tcp_rst.tcp_rst_set
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.TcpRst = &TCPSelector_TcpRstSet{x != 0}
		return true, err
	case 8: // tcp_rst.tcp_rst_clear
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.TcpRst = &TCPSelector_TcpRstClear{x != 0}
		return true, err
	case 9: // tcp_urg.tcp_urg_set
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.TcpUrg = &TCPSelector_TcpUrgSet{x != 0}
		return true, err
	case 10: // tcp_urg.tcp_urg_clear
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.TcpUrg = &TCPSelector_TcpUrgClear{x != 0}
		return true, err
	default:
		return false, nil
	}
}

func _TCPSelector_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*TCPSelector)
	// tcp_syn
	switch x := m.TcpSyn.(type) {
	case *TCPSelector_TcpSynSet:
		n += proto.SizeVarint(1<<3 | proto.WireVarint)
		n += 1
	case *TCPSelector_TcpSynClear:
		n += proto.SizeVarint(2<<3 | proto.WireVarint)
		n += 1
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// tcp_ack
	switch x := m.TcpAck.(type) {
	case *TCPSelector_TcpAckSet:
		n += proto.SizeVarint(3<<3 | proto.WireVarint)
		n += 1
	case *TCPSelector_TcpAckClear:
		n += proto.SizeVarint(4<<3 | proto.WireVarint)
		n += 1
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// tcp_fin
	switch x := m.TcpFin.(type) {
	case *TCPSelector_TcpFinSet:
		n += proto.SizeVarint(5<<3 | proto.WireVarint)
		n += 1
	case *TCPSelector_TcpFinClear:
		n += proto.SizeVarint(6<<3 | proto.WireVarint)
		n += 1
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// tcp_rst
	switch x := m.TcpRst.(type) {
	case *TCPSelector_TcpRstSet:
		n += proto.SizeVarint(7<<3 | proto.WireVarint)
		n += 1
	case *TCPSelector_TcpRstClear:
		n += proto.SizeVarint(8<<3 | proto.WireVarint)
		n += 1
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// tcp_urg
	switch x := m.TcpUrg.(type) {
	case *TCPSelector_TcpUrgSet:
		n += proto.SizeVarint(9<<3 | proto.WireVarint)
		n += 1
	case *TCPSelector_TcpUrgClear:
		n += proto.SizeVarint(10<<3 | proto.WireVarint)
		n += 1
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// ICMPSelector has match criteria for ICMP packets
type ICMPSelector struct {
	IcmpCode     uint32 `protobuf:"varint,1,opt,name=icmp_code,json=icmpCode" json:"icmp_code,omitempty"`
	IcmpCodeMask uint32 `protobuf:"varint,2,opt,name=icmp_code_mask,json=icmpCodeMask" json:"icmp_code_mask,omitempty"`
	IcmpType     uint32 `protobuf:"varint,3,opt,name=icmp_type,json=icmpType" json:"icmp_type,omitempty"`
	IcmpTypeMask uint32 `protobuf:"varint,4,opt,name=icmp_type_mask,json=icmpTypeMask" json:"icmp_type_mask,omitempty"`
}

func (m *ICMPSelector) Reset()                    { *m = ICMPSelector{} }
func (m *ICMPSelector) String() string            { return proto.CompactTextString(m) }
func (*ICMPSelector) ProtoMessage()               {}
func (*ICMPSelector) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *ICMPSelector) GetIcmpCode() uint32 {
	if m != nil {
		return m.IcmpCode
	}
	return 0
}

func (m *ICMPSelector) GetIcmpCodeMask() uint32 {
	if m != nil {
		return m.IcmpCodeMask
	}
	return 0
}

func (m *ICMPSelector) GetIcmpType() uint32 {
	if m != nil {
		return m.IcmpType
	}
	return 0
}

func (m *ICMPSelector) GetIcmpTypeMask() uint32 {
	if m != nil {
		return m.IcmpTypeMask
	}
	return 0
}

// IPSelector has match criteria for selecting IP packets
type IPSelector struct {
	IpAf      IPAddressFamily `protobuf:"varint,1,opt,name=ip_af,json=ipAf,enum=types.IPAddressFamily" json:"ip_af,omitempty"`
	SrcPrefix *IPPrefix       `protobuf:"bytes,2,opt,name=src_prefix,json=srcPrefix" json:"src_prefix,omitempty"`
	DstPrefix *IPPrefix       `protobuf:"bytes,3,opt,name=dst_prefix,json=dstPrefix" json:"dst_prefix,omitempty"`
	// Types that are valid to be assigned to L4Selectors:
	//	*IPSelector_IpProtocol
	//	*IPSelector_IcmpSelector
	//	*IPSelector_UdpSelector
	//	*IPSelector_TcpSelector
	L4Selectors isIPSelector_L4Selectors `protobuf_oneof:"l4_selectors"`
}

func (m *IPSelector) Reset()                    { *m = IPSelector{} }
func (m *IPSelector) String() string            { return proto.CompactTextString(m) }
func (*IPSelector) ProtoMessage()               {}
func (*IPSelector) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

type isIPSelector_L4Selectors interface {
	isIPSelector_L4Selectors()
}

type IPSelector_IpProtocol struct {
	IpProtocol IPProtocol `protobuf:"varint,4,opt,name=ip_protocol,json=ipProtocol,enum=types.IPProtocol,oneof"`
}
type IPSelector_IcmpSelector struct {
	IcmpSelector *ICMPSelector `protobuf:"bytes,5,opt,name=icmp_selector,json=icmpSelector,oneof"`
}
type IPSelector_UdpSelector struct {
	UdpSelector *UDPSelector `protobuf:"bytes,6,opt,name=udp_selector,json=udpSelector,oneof"`
}
type IPSelector_TcpSelector struct {
	TcpSelector *TCPSelector `protobuf:"bytes,7,opt,name=tcp_selector,json=tcpSelector,oneof"`
}

func (*IPSelector_IpProtocol) isIPSelector_L4Selectors()   {}
func (*IPSelector_IcmpSelector) isIPSelector_L4Selectors() {}
func (*IPSelector_UdpSelector) isIPSelector_L4Selectors()  {}
func (*IPSelector_TcpSelector) isIPSelector_L4Selectors()  {}

func (m *IPSelector) GetL4Selectors() isIPSelector_L4Selectors {
	if m != nil {
		return m.L4Selectors
	}
	return nil
}

func (m *IPSelector) GetIpAf() IPAddressFamily {
	if m != nil {
		return m.IpAf
	}
	return IPAddressFamily_IP_AF_NONE
}

func (m *IPSelector) GetSrcPrefix() *IPPrefix {
	if m != nil {
		return m.SrcPrefix
	}
	return nil
}

func (m *IPSelector) GetDstPrefix() *IPPrefix {
	if m != nil {
		return m.DstPrefix
	}
	return nil
}

func (m *IPSelector) GetIpProtocol() IPProtocol {
	if x, ok := m.GetL4Selectors().(*IPSelector_IpProtocol); ok {
		return x.IpProtocol
	}
	return IPProtocol_IPPROTO_NONE
}

func (m *IPSelector) GetIcmpSelector() *ICMPSelector {
	if x, ok := m.GetL4Selectors().(*IPSelector_IcmpSelector); ok {
		return x.IcmpSelector
	}
	return nil
}

func (m *IPSelector) GetUdpSelector() *UDPSelector {
	if x, ok := m.GetL4Selectors().(*IPSelector_UdpSelector); ok {
		return x.UdpSelector
	}
	return nil
}

func (m *IPSelector) GetTcpSelector() *TCPSelector {
	if x, ok := m.GetL4Selectors().(*IPSelector_TcpSelector); ok {
		return x.TcpSelector
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*IPSelector) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _IPSelector_OneofMarshaler, _IPSelector_OneofUnmarshaler, _IPSelector_OneofSizer, []interface{}{
		(*IPSelector_IpProtocol)(nil),
		(*IPSelector_IcmpSelector)(nil),
		(*IPSelector_UdpSelector)(nil),
		(*IPSelector_TcpSelector)(nil),
	}
}

func _IPSelector_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*IPSelector)
	// l4_selectors
	switch x := m.L4Selectors.(type) {
	case *IPSelector_IpProtocol:
		b.EncodeVarint(4<<3 | proto.WireVarint)
		b.EncodeVarint(uint64(x.IpProtocol))
	case *IPSelector_IcmpSelector:
		b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.IcmpSelector); err != nil {
			return err
		}
	case *IPSelector_UdpSelector:
		b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.UdpSelector); err != nil {
			return err
		}
	case *IPSelector_TcpSelector:
		b.EncodeVarint(7<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.TcpSelector); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("IPSelector.L4Selectors has unexpected type %T", x)
	}
	return nil
}

func _IPSelector_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*IPSelector)
	switch tag {
	case 4: // l4_selectors.ip_protocol
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.L4Selectors = &IPSelector_IpProtocol{IPProtocol(x)}
		return true, err
	case 5: // l4_selectors.icmp_selector
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ICMPSelector)
		err := b.DecodeMessage(msg)
		m.L4Selectors = &IPSelector_IcmpSelector{msg}
		return true, err
	case 6: // l4_selectors.udp_selector
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(UDPSelector)
		err := b.DecodeMessage(msg)
		m.L4Selectors = &IPSelector_UdpSelector{msg}
		return true, err
	case 7: // l4_selectors.tcp_selector
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TCPSelector)
		err := b.DecodeMessage(msg)
		m.L4Selectors = &IPSelector_TcpSelector{msg}
		return true, err
	default:
		return false, nil
	}
}

func _IPSelector_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*IPSelector)
	// l4_selectors
	switch x := m.L4Selectors.(type) {
	case *IPSelector_IpProtocol:
		n += proto.SizeVarint(4<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.IpProtocol))
	case *IPSelector_IcmpSelector:
		s := proto.Size(x.IcmpSelector)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *IPSelector_UdpSelector:
		s := proto.Size(x.UdpSelector)
		n += proto.SizeVarint(6<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *IPSelector_TcpSelector:
		s := proto.Size(x.TcpSelector)
		n += proto.SizeVarint(7<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// AclInternalSelector has match criteria which are for internal use only with
// DOL/testing infra
// For production builds this needs to be removed
// TODO: REMOVE
type AclInternalSelector struct {
	FlowMiss        bool   `protobuf:"varint,1,opt,name=flow_miss,json=flowMiss" json:"flow_miss,omitempty"`
	OuterDstMac     uint64 `protobuf:"varint,2,opt,name=outer_dst_mac,json=outerDstMac" json:"outer_dst_mac,omitempty"`
	IpOptions       bool   `protobuf:"varint,3,opt,name=ip_options,json=ipOptions" json:"ip_options,omitempty"`
	IpFrag          bool   `protobuf:"varint,4,opt,name=ip_frag,json=ipFrag" json:"ip_frag,omitempty"`
	DropReason      uint32 `protobuf:"fixed32,5,opt,name=drop_reason,json=dropReason" json:"drop_reason,omitempty"`
	TunnelTerminate bool   `protobuf:"varint,6,opt,name=tunnel_terminate,json=tunnelTerminate" json:"tunnel_terminate,omitempty"`
	Direction       bool   `protobuf:"varint,7,opt,name=direction" json:"direction,omitempty"`
}

func (m *AclInternalSelector) Reset()                    { *m = AclInternalSelector{} }
func (m *AclInternalSelector) String() string            { return proto.CompactTextString(m) }
func (*AclInternalSelector) ProtoMessage()               {}
func (*AclInternalSelector) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *AclInternalSelector) GetFlowMiss() bool {
	if m != nil {
		return m.FlowMiss
	}
	return false
}

func (m *AclInternalSelector) GetOuterDstMac() uint64 {
	if m != nil {
		return m.OuterDstMac
	}
	return 0
}

func (m *AclInternalSelector) GetIpOptions() bool {
	if m != nil {
		return m.IpOptions
	}
	return false
}

func (m *AclInternalSelector) GetIpFrag() bool {
	if m != nil {
		return m.IpFrag
	}
	return false
}

func (m *AclInternalSelector) GetDropReason() uint32 {
	if m != nil {
		return m.DropReason
	}
	return 0
}

func (m *AclInternalSelector) GetTunnelTerminate() bool {
	if m != nil {
		return m.TunnelTerminate
	}
	return false
}

func (m *AclInternalSelector) GetDirection() bool {
	if m != nil {
		return m.Direction
	}
	return false
}

// AclInternalActionInfo has action parameters for internal use only with
// DOL/testing infra
// For production builds this needs to be removed
// TODO: REMOVE
type AclInternalActionInfo struct {
	MacSaRewriteEn bool       `protobuf:"varint,1,opt,name=mac_sa_rewrite_en,json=macSaRewriteEn" json:"mac_sa_rewrite_en,omitempty"`
	MacSa          uint64     `protobuf:"varint,2,opt,name=mac_sa,json=macSa" json:"mac_sa,omitempty"`
	MacDaRewriteEn bool       `protobuf:"varint,3,opt,name=mac_da_rewrite_en,json=macDaRewriteEn" json:"mac_da_rewrite_en,omitempty"`
	MacDa          uint64     `protobuf:"varint,4,opt,name=mac_da,json=macDa" json:"mac_da,omitempty"`
	TtlDecEn       bool       `protobuf:"varint,5,opt,name=ttl_dec_en,json=ttlDecEn" json:"ttl_dec_en,omitempty"`
	EncapInfo      *EncapInfo `protobuf:"bytes,6,opt,name=encap_info,json=encapInfo" json:"encap_info,omitempty"`
}

func (m *AclInternalActionInfo) Reset()                    { *m = AclInternalActionInfo{} }
func (m *AclInternalActionInfo) String() string            { return proto.CompactTextString(m) }
func (*AclInternalActionInfo) ProtoMessage()               {}
func (*AclInternalActionInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *AclInternalActionInfo) GetMacSaRewriteEn() bool {
	if m != nil {
		return m.MacSaRewriteEn
	}
	return false
}

func (m *AclInternalActionInfo) GetMacSa() uint64 {
	if m != nil {
		return m.MacSa
	}
	return 0
}

func (m *AclInternalActionInfo) GetMacDaRewriteEn() bool {
	if m != nil {
		return m.MacDaRewriteEn
	}
	return false
}

func (m *AclInternalActionInfo) GetMacDa() uint64 {
	if m != nil {
		return m.MacDa
	}
	return 0
}

func (m *AclInternalActionInfo) GetTtlDecEn() bool {
	if m != nil {
		return m.TtlDecEn
	}
	return false
}

func (m *AclInternalActionInfo) GetEncapInfo() *EncapInfo {
	if m != nil {
		return m.EncapInfo
	}
	return nil
}

// AclSelector has all the match criteria for an ACL entry
type AclSelector struct {
	SrcIfKeyHandle *InterfaceKeyHandle `protobuf:"bytes,1,opt,name=src_if_key_handle,json=srcIfKeyHandle" json:"src_if_key_handle,omitempty"`
	DstIfKeyHandle *InterfaceKeyHandle `protobuf:"bytes,2,opt,name=dst_if_key_handle,json=dstIfKeyHandle" json:"dst_if_key_handle,omitempty"`
	// Types that are valid to be assigned to SegSelector:
	//	*AclSelector_TenantKeyHandle
	//	*AclSelector_L2SegmentKeyHandle
	SegSelector isAclSelector_SegSelector `protobuf_oneof:"seg_selector"`
	// Types that are valid to be assigned to PktSelector:
	//	*AclSelector_EthSelector
	//	*AclSelector_IpSelector
	PktSelector isAclSelector_PktSelector `protobuf_oneof:"pkt_selector"`
	// TODO: REMOVE
	InternalKey  *AclInternalSelector `protobuf:"bytes,7,opt,name=internal_key,json=internalKey" json:"internal_key,omitempty"`
	InternalMask *AclInternalSelector `protobuf:"bytes,8,opt,name=internal_mask,json=internalMask" json:"internal_mask,omitempty"`
}

func (m *AclSelector) Reset()                    { *m = AclSelector{} }
func (m *AclSelector) String() string            { return proto.CompactTextString(m) }
func (*AclSelector) ProtoMessage()               {}
func (*AclSelector) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

type isAclSelector_SegSelector interface {
	isAclSelector_SegSelector()
}
type isAclSelector_PktSelector interface {
	isAclSelector_PktSelector()
}

type AclSelector_TenantKeyHandle struct {
	TenantKeyHandle *TenantKeyHandle `protobuf:"bytes,3,opt,name=tenant_key_handle,json=tenantKeyHandle,oneof"`
}
type AclSelector_L2SegmentKeyHandle struct {
	L2SegmentKeyHandle *L2SegmentKeyHandle `protobuf:"bytes,4,opt,name=l2segment_key_handle,json=l2segmentKeyHandle,oneof"`
}
type AclSelector_EthSelector struct {
	EthSelector *EthSelector `protobuf:"bytes,5,opt,name=eth_selector,json=ethSelector,oneof"`
}
type AclSelector_IpSelector struct {
	IpSelector *IPSelector `protobuf:"bytes,6,opt,name=ip_selector,json=ipSelector,oneof"`
}

func (*AclSelector_TenantKeyHandle) isAclSelector_SegSelector()    {}
func (*AclSelector_L2SegmentKeyHandle) isAclSelector_SegSelector() {}
func (*AclSelector_EthSelector) isAclSelector_PktSelector()        {}
func (*AclSelector_IpSelector) isAclSelector_PktSelector()         {}

func (m *AclSelector) GetSegSelector() isAclSelector_SegSelector {
	if m != nil {
		return m.SegSelector
	}
	return nil
}
func (m *AclSelector) GetPktSelector() isAclSelector_PktSelector {
	if m != nil {
		return m.PktSelector
	}
	return nil
}

func (m *AclSelector) GetSrcIfKeyHandle() *InterfaceKeyHandle {
	if m != nil {
		return m.SrcIfKeyHandle
	}
	return nil
}

func (m *AclSelector) GetDstIfKeyHandle() *InterfaceKeyHandle {
	if m != nil {
		return m.DstIfKeyHandle
	}
	return nil
}

func (m *AclSelector) GetTenantKeyHandle() *TenantKeyHandle {
	if x, ok := m.GetSegSelector().(*AclSelector_TenantKeyHandle); ok {
		return x.TenantKeyHandle
	}
	return nil
}

func (m *AclSelector) GetL2SegmentKeyHandle() *L2SegmentKeyHandle {
	if x, ok := m.GetSegSelector().(*AclSelector_L2SegmentKeyHandle); ok {
		return x.L2SegmentKeyHandle
	}
	return nil
}

func (m *AclSelector) GetEthSelector() *EthSelector {
	if x, ok := m.GetPktSelector().(*AclSelector_EthSelector); ok {
		return x.EthSelector
	}
	return nil
}

func (m *AclSelector) GetIpSelector() *IPSelector {
	if x, ok := m.GetPktSelector().(*AclSelector_IpSelector); ok {
		return x.IpSelector
	}
	return nil
}

func (m *AclSelector) GetInternalKey() *AclInternalSelector {
	if m != nil {
		return m.InternalKey
	}
	return nil
}

func (m *AclSelector) GetInternalMask() *AclInternalSelector {
	if m != nil {
		return m.InternalMask
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*AclSelector) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _AclSelector_OneofMarshaler, _AclSelector_OneofUnmarshaler, _AclSelector_OneofSizer, []interface{}{
		(*AclSelector_TenantKeyHandle)(nil),
		(*AclSelector_L2SegmentKeyHandle)(nil),
		(*AclSelector_EthSelector)(nil),
		(*AclSelector_IpSelector)(nil),
	}
}

func _AclSelector_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*AclSelector)
	// seg_selector
	switch x := m.SegSelector.(type) {
	case *AclSelector_TenantKeyHandle:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.TenantKeyHandle); err != nil {
			return err
		}
	case *AclSelector_L2SegmentKeyHandle:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.L2SegmentKeyHandle); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("AclSelector.SegSelector has unexpected type %T", x)
	}
	// pkt_selector
	switch x := m.PktSelector.(type) {
	case *AclSelector_EthSelector:
		b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.EthSelector); err != nil {
			return err
		}
	case *AclSelector_IpSelector:
		b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.IpSelector); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("AclSelector.PktSelector has unexpected type %T", x)
	}
	return nil
}

func _AclSelector_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*AclSelector)
	switch tag {
	case 3: // seg_selector.tenant_key_handle
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TenantKeyHandle)
		err := b.DecodeMessage(msg)
		m.SegSelector = &AclSelector_TenantKeyHandle{msg}
		return true, err
	case 4: // seg_selector.l2segment_key_handle
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(L2SegmentKeyHandle)
		err := b.DecodeMessage(msg)
		m.SegSelector = &AclSelector_L2SegmentKeyHandle{msg}
		return true, err
	case 5: // pkt_selector.eth_selector
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(EthSelector)
		err := b.DecodeMessage(msg)
		m.PktSelector = &AclSelector_EthSelector{msg}
		return true, err
	case 6: // pkt_selector.ip_selector
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(IPSelector)
		err := b.DecodeMessage(msg)
		m.PktSelector = &AclSelector_IpSelector{msg}
		return true, err
	default:
		return false, nil
	}
}

func _AclSelector_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*AclSelector)
	// seg_selector
	switch x := m.SegSelector.(type) {
	case *AclSelector_TenantKeyHandle:
		s := proto.Size(x.TenantKeyHandle)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *AclSelector_L2SegmentKeyHandle:
		s := proto.Size(x.L2SegmentKeyHandle)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// pkt_selector
	switch x := m.PktSelector.(type) {
	case *AclSelector_EthSelector:
		s := proto.Size(x.EthSelector)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *AclSelector_IpSelector:
		s := proto.Size(x.IpSelector)
		n += proto.SizeVarint(6<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type AclActionInfo struct {
	Action                 AclAction           `protobuf:"varint,1,opt,name=action,enum=acl.AclAction" json:"action,omitempty"`
	IngMirrorEn            bool                `protobuf:"varint,2,opt,name=ing_mirror_en,json=ingMirrorEn" json:"ing_mirror_en,omitempty"`
	IngMirrorSessionHandle uint64              `protobuf:"fixed64,3,opt,name=ing_mirror_session_handle,json=ingMirrorSessionHandle" json:"ing_mirror_session_handle,omitempty"`
	EgrMirrorEn            bool                `protobuf:"varint,4,opt,name=egr_mirror_en,json=egrMirrorEn" json:"egr_mirror_en,omitempty"`
	EgrMirrorSessionHandle uint64              `protobuf:"fixed64,5,opt,name=egr_mirror_session_handle,json=egrMirrorSessionHandle" json:"egr_mirror_session_handle,omitempty"`
	CoppPolicerHandle      uint64              `protobuf:"fixed64,6,opt,name=copp_policer_handle,json=coppPolicerHandle" json:"copp_policer_handle,omitempty"`
	RedirectIfKeyHandle    *InterfaceKeyHandle `protobuf:"bytes,7,opt,name=redirect_if_key_handle,json=redirectIfKeyHandle" json:"redirect_if_key_handle,omitempty"`
	// TODO: REMOVE
	InternalActions *AclInternalActionInfo `protobuf:"bytes,8,opt,name=internal_actions,json=internalActions" json:"internal_actions,omitempty"`
}

func (m *AclActionInfo) Reset()                    { *m = AclActionInfo{} }
func (m *AclActionInfo) String() string            { return proto.CompactTextString(m) }
func (*AclActionInfo) ProtoMessage()               {}
func (*AclActionInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *AclActionInfo) GetAction() AclAction {
	if m != nil {
		return m.Action
	}
	return AclAction_ACL_ACTION_NONE
}

func (m *AclActionInfo) GetIngMirrorEn() bool {
	if m != nil {
		return m.IngMirrorEn
	}
	return false
}

func (m *AclActionInfo) GetIngMirrorSessionHandle() uint64 {
	if m != nil {
		return m.IngMirrorSessionHandle
	}
	return 0
}

func (m *AclActionInfo) GetEgrMirrorEn() bool {
	if m != nil {
		return m.EgrMirrorEn
	}
	return false
}

func (m *AclActionInfo) GetEgrMirrorSessionHandle() uint64 {
	if m != nil {
		return m.EgrMirrorSessionHandle
	}
	return 0
}

func (m *AclActionInfo) GetCoppPolicerHandle() uint64 {
	if m != nil {
		return m.CoppPolicerHandle
	}
	return 0
}

func (m *AclActionInfo) GetRedirectIfKeyHandle() *InterfaceKeyHandle {
	if m != nil {
		return m.RedirectIfKeyHandle
	}
	return nil
}

func (m *AclActionInfo) GetInternalActions() *AclInternalActionInfo {
	if m != nil {
		return m.InternalActions
	}
	return nil
}

// ACL entry configuration
type AclSpec struct {
	Meta        *ObjectMeta   `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	KeyOrHandle *AclKeyHandle `protobuf:"bytes,2,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty"`
	Priority    uint32        `protobuf:"varint,3,opt,name=priority" json:"priority,omitempty"`
	// TBD: is this per-tenant priority ? or global ?
	Match  *AclSelector   `protobuf:"bytes,4,opt,name=match" json:"match,omitempty"`
	Action *AclActionInfo `protobuf:"bytes,5,opt,name=action" json:"action,omitempty"`
}

func (m *AclSpec) Reset()                    { *m = AclSpec{} }
func (m *AclSpec) String() string            { return proto.CompactTextString(m) }
func (*AclSpec) ProtoMessage()               {}
func (*AclSpec) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *AclSpec) GetMeta() *ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *AclSpec) GetKeyOrHandle() *AclKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

func (m *AclSpec) GetPriority() uint32 {
	if m != nil {
		return m.Priority
	}
	return 0
}

func (m *AclSpec) GetMatch() *AclSelector {
	if m != nil {
		return m.Match
	}
	return nil
}

func (m *AclSpec) GetAction() *AclActionInfo {
	if m != nil {
		return m.Action
	}
	return nil
}

// Batched requests to create/update acls
type AclRequestMsg struct {
	Request []*AclSpec `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *AclRequestMsg) Reset()                    { *m = AclRequestMsg{} }
func (m *AclRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*AclRequestMsg) ProtoMessage()               {}
func (*AclRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *AclRequestMsg) GetRequest() []*AclSpec {
	if m != nil {
		return m.Request
	}
	return nil
}

// AclStatus represents the operational status of an ACL entry
type AclStatus struct {
	AclHandle *AclHandle `protobuf:"bytes,1,opt,name=acl_handle,json=aclHandle" json:"acl_handle,omitempty"`
}

func (m *AclStatus) Reset()                    { *m = AclStatus{} }
func (m *AclStatus) String() string            { return proto.CompactTextString(m) }
func (*AclStatus) ProtoMessage()               {}
func (*AclStatus) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *AclStatus) GetAclHandle() *AclHandle {
	if m != nil {
		return m.AclHandle
	}
	return nil
}

// AclResponse is response to one Acl
type AclResponse struct {
	ApiStatus ApiStatus  `protobuf:"varint,1,opt,name=api_status,json=apiStatus,enum=types.ApiStatus" json:"api_status,omitempty"`
	Status    *AclStatus `protobuf:"bytes,2,opt,name=status" json:"status,omitempty"`
}

func (m *AclResponse) Reset()                    { *m = AclResponse{} }
func (m *AclResponse) String() string            { return proto.CompactTextString(m) }
func (*AclResponse) ProtoMessage()               {}
func (*AclResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *AclResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *AclResponse) GetStatus() *AclStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

// Batched responses to create/update acls
type AclResponseMsg struct {
	Response []*AclResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *AclResponseMsg) Reset()                    { *m = AclResponseMsg{} }
func (m *AclResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*AclResponseMsg) ProtoMessage()               {}
func (*AclResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

func (m *AclResponseMsg) GetResponse() []*AclResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

type AclDeleteRequest struct {
	Meta        *ObjectMeta   `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	KeyOrHandle *AclKeyHandle `protobuf:"bytes,2,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty"`
}

func (m *AclDeleteRequest) Reset()                    { *m = AclDeleteRequest{} }
func (m *AclDeleteRequest) String() string            { return proto.CompactTextString(m) }
func (*AclDeleteRequest) ProtoMessage()               {}
func (*AclDeleteRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

func (m *AclDeleteRequest) GetMeta() *ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *AclDeleteRequest) GetKeyOrHandle() *AclKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

// Batched requests to delete acls
type AclDeleteRequestMsg struct {
	Request []*AclDeleteRequest `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *AclDeleteRequestMsg) Reset()                    { *m = AclDeleteRequestMsg{} }
func (m *AclDeleteRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*AclDeleteRequestMsg) ProtoMessage()               {}
func (*AclDeleteRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

func (m *AclDeleteRequestMsg) GetRequest() []*AclDeleteRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

// AclDeleteResponse is response to Acl delete request
type AclDeleteResponse struct {
	ApiStatus ApiStatus `protobuf:"varint,1,opt,name=api_status,json=apiStatus,enum=types.ApiStatus" json:"api_status,omitempty"`
}

func (m *AclDeleteResponse) Reset()                    { *m = AclDeleteResponse{} }
func (m *AclDeleteResponse) String() string            { return proto.CompactTextString(m) }
func (*AclDeleteResponse) ProtoMessage()               {}
func (*AclDeleteResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{18} }

func (m *AclDeleteResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

// AclDeleteResponseMsg is batched response to AclDeleteRequestMsg
type AclDeleteResponseMsg struct {
	Response []*AclDeleteResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *AclDeleteResponseMsg) Reset()                    { *m = AclDeleteResponseMsg{} }
func (m *AclDeleteResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*AclDeleteResponseMsg) ProtoMessage()               {}
func (*AclDeleteResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{19} }

func (m *AclDeleteResponseMsg) GetResponse() []*AclDeleteResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

// AclGetRequest is used to get information about a acl
type AclGetRequest struct {
	Meta        *ObjectMeta   `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	KeyOrHandle *AclKeyHandle `protobuf:"bytes,2,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty"`
}

func (m *AclGetRequest) Reset()                    { *m = AclGetRequest{} }
func (m *AclGetRequest) String() string            { return proto.CompactTextString(m) }
func (*AclGetRequest) ProtoMessage()               {}
func (*AclGetRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{20} }

func (m *AclGetRequest) GetMeta() *ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *AclGetRequest) GetKeyOrHandle() *AclKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

type AclGetRequestMsg struct {
	Request []*AclGetRequest `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *AclGetRequestMsg) Reset()                    { *m = AclGetRequestMsg{} }
func (m *AclGetRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*AclGetRequestMsg) ProtoMessage()               {}
func (*AclGetRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{21} }

func (m *AclGetRequestMsg) GetRequest() []*AclGetRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

// AclStats captures all the statistics of a acl
type AclStats struct {
}

func (m *AclStats) Reset()                    { *m = AclStats{} }
func (m *AclStats) String() string            { return proto.CompactTextString(m) }
func (*AclStats) ProtoMessage()               {}
func (*AclStats) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{22} }

// AclGetResponse captures all the information about a acl
type AclGetResponse struct {
	Spec   *AclSpec   `protobuf:"bytes,1,opt,name=spec" json:"spec,omitempty"`
	Status *AclStatus `protobuf:"bytes,2,opt,name=status" json:"status,omitempty"`
	Stats  *AclStats  `protobuf:"bytes,3,opt,name=stats" json:"stats,omitempty"`
}

func (m *AclGetResponse) Reset()                    { *m = AclGetResponse{} }
func (m *AclGetResponse) String() string            { return proto.CompactTextString(m) }
func (*AclGetResponse) ProtoMessage()               {}
func (*AclGetResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{23} }

func (m *AclGetResponse) GetSpec() *AclSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *AclGetResponse) GetStatus() *AclStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *AclGetResponse) GetStats() *AclStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

// AclGetResponseMsg is response to AclGetRequestMsg
type AclGetResponseMsg struct {
	Response []*AclGetResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *AclGetResponseMsg) Reset()                    { *m = AclGetResponseMsg{} }
func (m *AclGetResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*AclGetResponseMsg) ProtoMessage()               {}
func (*AclGetResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{24} }

func (m *AclGetResponseMsg) GetResponse() []*AclGetResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

func init() {
	proto.RegisterType((*AclHandle)(nil), "acl.AclHandle")
	proto.RegisterType((*AclKeyHandle)(nil), "acl.AclKeyHandle")
	proto.RegisterType((*EthSelector)(nil), "acl.EthSelector")
	proto.RegisterType((*UDPSelector)(nil), "acl.UDPSelector")
	proto.RegisterType((*TCPSelector)(nil), "acl.TCPSelector")
	proto.RegisterType((*ICMPSelector)(nil), "acl.ICMPSelector")
	proto.RegisterType((*IPSelector)(nil), "acl.IPSelector")
	proto.RegisterType((*AclInternalSelector)(nil), "acl.AclInternalSelector")
	proto.RegisterType((*AclInternalActionInfo)(nil), "acl.AclInternalActionInfo")
	proto.RegisterType((*AclSelector)(nil), "acl.AclSelector")
	proto.RegisterType((*AclActionInfo)(nil), "acl.AclActionInfo")
	proto.RegisterType((*AclSpec)(nil), "acl.AclSpec")
	proto.RegisterType((*AclRequestMsg)(nil), "acl.AclRequestMsg")
	proto.RegisterType((*AclStatus)(nil), "acl.AclStatus")
	proto.RegisterType((*AclResponse)(nil), "acl.AclResponse")
	proto.RegisterType((*AclResponseMsg)(nil), "acl.AclResponseMsg")
	proto.RegisterType((*AclDeleteRequest)(nil), "acl.AclDeleteRequest")
	proto.RegisterType((*AclDeleteRequestMsg)(nil), "acl.AclDeleteRequestMsg")
	proto.RegisterType((*AclDeleteResponse)(nil), "acl.AclDeleteResponse")
	proto.RegisterType((*AclDeleteResponseMsg)(nil), "acl.AclDeleteResponseMsg")
	proto.RegisterType((*AclGetRequest)(nil), "acl.AclGetRequest")
	proto.RegisterType((*AclGetRequestMsg)(nil), "acl.AclGetRequestMsg")
	proto.RegisterType((*AclStats)(nil), "acl.AclStats")
	proto.RegisterType((*AclGetResponse)(nil), "acl.AclGetResponse")
	proto.RegisterType((*AclGetResponseMsg)(nil), "acl.AclGetResponseMsg")
	proto.RegisterEnum("acl.AclAction", AclAction_name, AclAction_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Acl service

type AclClient interface {
	// Acl related APIs
	AclCreate(ctx context.Context, in *AclRequestMsg, opts ...grpc.CallOption) (*AclResponseMsg, error)
	AclUpdate(ctx context.Context, in *AclRequestMsg, opts ...grpc.CallOption) (*AclResponseMsg, error)
	AclDelete(ctx context.Context, in *AclDeleteRequestMsg, opts ...grpc.CallOption) (*AclDeleteResponseMsg, error)
	AclGet(ctx context.Context, in *AclGetRequestMsg, opts ...grpc.CallOption) (*AclGetResponseMsg, error)
}

type aclClient struct {
	cc *grpc.ClientConn
}

func NewAclClient(cc *grpc.ClientConn) AclClient {
	return &aclClient{cc}
}

func (c *aclClient) AclCreate(ctx context.Context, in *AclRequestMsg, opts ...grpc.CallOption) (*AclResponseMsg, error) {
	out := new(AclResponseMsg)
	err := grpc.Invoke(ctx, "/acl.Acl/AclCreate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aclClient) AclUpdate(ctx context.Context, in *AclRequestMsg, opts ...grpc.CallOption) (*AclResponseMsg, error) {
	out := new(AclResponseMsg)
	err := grpc.Invoke(ctx, "/acl.Acl/AclUpdate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aclClient) AclDelete(ctx context.Context, in *AclDeleteRequestMsg, opts ...grpc.CallOption) (*AclDeleteResponseMsg, error) {
	out := new(AclDeleteResponseMsg)
	err := grpc.Invoke(ctx, "/acl.Acl/AclDelete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aclClient) AclGet(ctx context.Context, in *AclGetRequestMsg, opts ...grpc.CallOption) (*AclGetResponseMsg, error) {
	out := new(AclGetResponseMsg)
	err := grpc.Invoke(ctx, "/acl.Acl/AclGet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Acl service

type AclServer interface {
	// Acl related APIs
	AclCreate(context.Context, *AclRequestMsg) (*AclResponseMsg, error)
	AclUpdate(context.Context, *AclRequestMsg) (*AclResponseMsg, error)
	AclDelete(context.Context, *AclDeleteRequestMsg) (*AclDeleteResponseMsg, error)
	AclGet(context.Context, *AclGetRequestMsg) (*AclGetResponseMsg, error)
}

func RegisterAclServer(s *grpc.Server, srv AclServer) {
	s.RegisterService(&_Acl_serviceDesc, srv)
}

func _Acl_AclCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AclRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AclServer).AclCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/acl.Acl/AclCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AclServer).AclCreate(ctx, req.(*AclRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Acl_AclUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AclRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AclServer).AclUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/acl.Acl/AclUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AclServer).AclUpdate(ctx, req.(*AclRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Acl_AclDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AclDeleteRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AclServer).AclDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/acl.Acl/AclDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AclServer).AclDelete(ctx, req.(*AclDeleteRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Acl_AclGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AclGetRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AclServer).AclGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/acl.Acl/AclGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AclServer).AclGet(ctx, req.(*AclGetRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

var _Acl_serviceDesc = grpc.ServiceDesc{
	ServiceName: "acl.Acl",
	HandlerType: (*AclServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AclCreate",
			Handler:    _Acl_AclCreate_Handler,
		},
		{
			MethodName: "AclUpdate",
			Handler:    _Acl_AclUpdate_Handler,
		},
		{
			MethodName: "AclDelete",
			Handler:    _Acl_AclDelete_Handler,
		},
		{
			MethodName: "AclGet",
			Handler:    _Acl_AclGet_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "nic/proto/hal/acl.proto",
}

func init() { proto.RegisterFile("nic/proto/hal/acl.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 1831 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x57, 0xdd, 0x72, 0x23, 0x47,
	0x15, 0xb6, 0xac, 0xff, 0x33, 0xb2, 0x2d, 0xb5, 0xe3, 0x9f, 0x35, 0xd9, 0xc2, 0x35, 0x09, 0x5b,
	0x9b, 0x00, 0x76, 0x95, 0xd8, 0x85, 0x04, 0x0a, 0x0a, 0x59, 0xd6, 0xc6, 0x22, 0xab, 0xb5, 0x69,
	0x7b, 0x2f, 0xe0, 0x66, 0x6a, 0xd2, 0xd3, 0x92, 0x1b, 0x8f, 0x66, 0x86, 0xee, 0x76, 0x05, 0x5d,
	0x51, 0x5c, 0xf1, 0x02, 0x3c, 0x00, 0x8f, 0x41, 0x15, 0x77, 0xbc, 0x04, 0xef, 0xc0, 0x35, 0x17,
	0x5c, 0x52, 0xfd, 0x37, 0x3f, 0xb2, 0x53, 0x1b, 0x52, 0x45, 0xae, 0xd4, 0x7d, 0xce, 0x77, 0xbe,
	0xee, 0x3e, 0x7f, 0x3a, 0x03, 0x07, 0x09, 0x23, 0xa7, 0x19, 0x4f, 0x65, 0x7a, 0x7a, 0x1b, 0xc6,
	0xa7, 0x21, 0x89, 0x4f, 0xf4, 0x0e, 0xd5, 0x43, 0x12, 0x1f, 0x1d, 0x55, 0xb5, 0x92, 0x26, 0x61,
	0x22, 0x0d, 0xe0, 0x68, 0xaf, 0xd0, 0xc9, 0x55, 0x46, 0x85, 0x15, 0x3f, 0xad, 0x9a, 0xb0, 0x44,
	0x52, 0x3e, 0x0f, 0x09, 0x7d, 0x5c, 0x1d, 0x0f, 0x05, 0x5d, 0x2c, 0xa9, 0x23, 0xf5, 0x3f, 0x80,
	0xee, 0x88, 0xc4, 0x17, 0x61, 0x12, 0xc5, 0x14, 0xed, 0x43, 0xeb, 0x56, 0xaf, 0x0e, 0x6b, 0xc7,
	0xb5, 0xe7, 0x2d, 0x6c, 0x77, 0x3e, 0x83, 0xde, 0x88, 0xc4, 0x9f, 0xd3, 0x95, 0xc5, 0x1d, 0x40,
	0x2b, 0x24, 0x71, 0xc0, 0x22, 0x8d, 0x6b, 0x5f, 0x6c, 0xe0, 0x66, 0x48, 0xe2, 0x69, 0x84, 0x4e,
	0x01, 0x94, 0xc2, 0x92, 0x6c, 0x1e, 0xd7, 0x9e, 0x7b, 0xc3, 0xed, 0x13, 0xf5, 0xc6, 0xfc, 0x90,
	0x8b, 0x0d, 0xdc, 0x0d, 0xdd, 0xe6, 0x6c, 0x07, 0xb6, 0xee, 0xe8, 0x2a, 0x48, 0xb9, 0xb5, 0xf1,
	0xff, 0x51, 0x03, 0x6f, 0x22, 0x6f, 0xaf, 0x69, 0x4c, 0x89, 0x4c, 0x39, 0x7a, 0x02, 0x1d, 0x2a,
	0x6f, 0x03, 0xf5, 0x60, 0x7d, 0xd8, 0x16, 0x6e, 0x53, 0x79, 0x7b, 0xb3, 0xca, 0x28, 0xf2, 0x61,
	0xcb, 0xa9, 0x82, 0x65, 0x28, 0xee, 0xf4, 0x79, 0x5b, 0xd8, 0xb3, 0xfa, 0x59, 0x28, 0xee, 0xd0,
	0x01, 0xb4, 0x05, 0x27, 0xc1, 0x32, 0x24, 0x87, 0xf5, 0xe3, 0xda, 0xf3, 0x06, 0x6e, 0x09, 0x4e,
	0x66, 0x21, 0x41, 0xc7, 0xd0, 0xb3, 0x0a, 0x63, 0xdb, 0xd0, 0x5a, 0x30, 0x5a, 0x67, 0x1a, 0x09,
	0xa9, 0x4d, 0x9b, 0xc6, 0x34, 0x12, 0xd2, 0x9a, 0x5a, 0x85, 0x31, 0x6d, 0x19, 0x53, 0xa3, 0x55,
	0xa6, 0xfe, 0x9f, 0x6a, 0xe0, 0xbd, 0x3d, 0xbf, 0xca, 0x1f, 0xf1, 0x09, 0x6c, 0xab, 0xc3, 0xb2,
	0x94, 0xcb, 0x80, 0x87, 0xc9, 0xc2, 0x3c, 0xc5, 0x1b, 0xa2, 0x13, 0x13, 0xc8, 0xd7, 0x2f, 0xae,
	0x52, 0x2e, 0xb1, 0xd2, 0x60, 0x75, 0xad, 0x7c, 0xa7, 0x2c, 0xd5, 0x59, 0x25, 0xcb, 0xcd, 0xaf,
	0xb6, 0x8c, 0x84, 0xcc, 0x77, 0xfe, 0x5f, 0x1b, 0xe0, 0xdd, 0x8c, 0x8b, 0x3b, 0x1c, 0x83, 0x27,
	0x49, 0x16, 0x88, 0x55, 0x12, 0x08, 0x2a, 0xf5, 0x05, 0x3a, 0x2a, 0x16, 0x92, 0x64, 0xd7, 0xab,
	0xe4, 0x9a, 0x4a, 0xf4, 0x21, 0x6c, 0x39, 0x04, 0x89, 0x69, 0xc8, 0xf5, 0x51, 0x0a, 0xe3, 0x19,
	0xcc, 0x58, 0x09, 0x1d, 0x4f, 0x48, 0xee, 0x34, 0x4f, 0x5d, 0x63, 0x6a, 0x9a, 0x67, 0x44, 0xee,
	0x4a, 0x3c, 0x0a, 0x61, 0x78, 0x1a, 0x16, 0xe3, 0x19, 0x4c, 0x85, 0x67, 0xce, 0xcc, 0x7d, 0x9a,
	0x1a, 0xb3, 0xa9, 0x79, 0x5e, 0xb1, 0xf2, 0x7d, 0x14, 0xc2, 0xf0, 0xb4, 0x2c, 0xc6, 0x33, 0x98,
	0x0a, 0x0f, 0x17, 0x52, 0xf3, 0xb4, 0x35, 0xa6, 0xae, 0x79, 0xb0, 0x90, 0x25, 0x1e, 0x85, 0x30,
	0x3c, 0x1d, 0x8b, 0xf1, 0x0c, 0xa6, 0xc2, 0x73, 0xcf, 0x17, 0x9a, 0xa7, 0xab, 0x31, 0x0d, 0xcd,
	0xf3, 0x96, 0x2f, 0x4a, 0x3c, 0x0a, 0x61, 0x78, 0xc0, 0x62, 0x3c, 0x83, 0x31, 0x3c, 0x0f, 0x63,
	0xed, 0x7d, 0xe3, 0x58, 0xf7, 0xbe, 0x5e, 0xac, 0xcf, 0xba, 0xd0, 0xb6, 0x91, 0x73, 0xcb, 0x90,
	0xdc, 0xb9, 0xe5, 0x9c, 0xe5, 0x52, 0x2e, 0xa4, 0x5b, 0xde, 0xf3, 0x85, 0xff, 0x97, 0x1a, 0xf4,
	0xa6, 0xe3, 0x59, 0x91, 0x23, 0xdf, 0x81, 0x2e, 0x23, 0xcb, 0x2c, 0x20, 0x69, 0xe4, 0xaa, 0xad,
	0xa3, 0x04, 0xe3, 0x34, 0xa2, 0xe8, 0x43, 0xd8, 0xce, 0x95, 0xe5, 0x7a, 0xeb, 0x39, 0x84, 0xae,
	0x1a, 0x47, 0xa1, 0x0b, 0xb6, 0x5e, 0x50, 0xe8, 0x8a, 0x75, 0x14, 0x45, 0xc9, 0x36, 0x0a, 0x0a,
	0x57, 0xb3, 0xfe, 0x9f, 0xeb, 0x00, 0xd3, 0xe2, 0x52, 0xdf, 0x87, 0x26, 0xcb, 0x82, 0x70, 0xae,
	0x2f, 0xb4, 0x3d, 0xdc, 0xb7, 0xde, 0x98, 0x5e, 0x8d, 0xa2, 0x88, 0x53, 0x21, 0x5e, 0x85, 0x4b,
	0x16, 0xaf, 0x70, 0x83, 0x65, 0xa3, 0x39, 0x3a, 0x01, 0xd0, 0xde, 0xe7, 0x74, 0xce, 0xfe, 0x60,
	0x6b, 0x65, 0x27, 0xb7, 0xb8, 0xd2, 0x62, 0xdc, 0x55, 0x6e, 0xd7, 0x4b, 0x85, 0xd7, 0x3e, 0x37,
	0xf8, 0xfa, 0x57, 0xe0, 0x95, 0xb3, 0x0d, 0xfe, 0x05, 0x78, 0x2c, 0x0b, 0x74, 0xeb, 0x24, 0x69,
	0xac, 0xaf, 0xbf, 0x3d, 0x1c, 0x94, 0x0c, 0x8c, 0xe2, 0x62, 0x03, 0x03, 0xcb, 0xdc, 0x0e, 0x7d,
	0x02, 0x5b, 0xfa, 0xdd, 0xc2, 0xbe, 0x49, 0x67, 0xbb, 0x37, 0x1c, 0xe8, 0xce, 0x58, 0x8e, 0xc0,
	0xc5, 0x86, 0xf1, 0x45, 0xfe, 0xf8, 0x97, 0xd0, 0xbb, 0x8f, 0x4a, 0x86, 0x2d, 0x6d, 0xd8, 0xd7,
	0x86, 0xa5, 0x0e, 0xa3, 0x8a, 0xf4, 0x3e, 0xaa, 0x98, 0xe9, 0x84, 0x70, 0x66, 0xed, 0x92, 0x59,
	0xa9, 0x29, 0xb8, 0xda, 0xb6, 0xdb, 0xb3, 0x6d, 0xe8, 0xc5, 0x2f, 0x72, 0x2b, 0xe1, 0xff, 0xa7,
	0x06, 0xbb, 0x23, 0x12, 0x4f, 0xd5, 0x5f, 0x4a, 0x12, 0xc6, 0xe5, 0x3c, 0x99, 0xc7, 0xe9, 0x97,
	0xc1, 0x92, 0x09, 0x61, 0x3a, 0x09, 0xee, 0x28, 0xc1, 0x8c, 0x09, 0xa1, 0xda, 0x72, 0x7a, 0x2f,
	0x29, 0x0f, 0x5c, 0xf7, 0xdc, 0xd4, 0xfd, 0xd1, 0xd3, 0xc2, 0x73, 0xd3, 0x42, 0x9f, 0x02, 0xb0,
	0x2c, 0x48, 0x33, 0xc9, 0xd2, 0x44, 0x98, 0x1e, 0x82, 0xbb, 0x2c, 0xbb, 0x34, 0x02, 0xd5, 0x7a,
	0x59, 0x16, 0xcc, 0x79, 0xb8, 0x30, 0xbd, 0x03, 0xb7, 0x58, 0xf6, 0x8a, 0x87, 0x0b, 0xf4, 0x5d,
	0xf0, 0x22, 0x9e, 0x66, 0x01, 0xa7, 0xa1, 0x48, 0x13, 0xed, 0xc6, 0x36, 0x06, 0x25, 0xc2, 0x5a,
	0x82, 0x3e, 0x82, 0xbe, 0xbc, 0x4f, 0x12, 0x1a, 0x07, 0x92, 0xf2, 0x25, 0x4b, 0x42, 0x49, 0x4d,
	0xdb, 0xc0, 0x3b, 0x46, 0x7e, 0xe3, 0xc4, 0xe8, 0x7d, 0xe8, 0x46, 0x8c, 0x53, 0xa2, 0x8e, 0x34,
	0x6d, 0x03, 0x17, 0x02, 0xff, 0x5f, 0x35, 0xd8, 0x2b, 0x3d, 0x7d, 0xa4, 0xa5, 0xd3, 0x64, 0x9e,
	0xa2, 0x8f, 0x60, 0xa0, 0x5a, 0xbf, 0x08, 0x03, 0x4e, 0xbf, 0xe4, 0x4c, 0xd2, 0x80, 0x26, 0xd6,
	0x09, 0xdb, 0xcb, 0x90, 0x5c, 0x87, 0xd8, 0x88, 0x27, 0x09, 0xda, 0x83, 0x96, 0x81, 0x5a, 0x1f,
	0x34, 0xb5, 0xde, 0x31, 0x44, 0x15, 0x86, 0x7a, 0xce, 0x70, 0xfe, 0x90, 0x21, 0x0a, 0xed, 0x1f,
	0x54, 0x53, 0xeb, 0xd1, 0xfb, 0x00, 0x52, 0xc6, 0x41, 0x44, 0x89, 0x32, 0x6d, 0x9a, 0x08, 0x48,
	0x19, 0x9f, 0x53, 0x32, 0x49, 0xd4, 0xbf, 0x30, 0x4d, 0x48, 0x98, 0x05, 0x2c, 0x99, 0xa7, 0x79,
	0xca, 0x98, 0x1c, 0x9d, 0x28, 0x85, 0x7a, 0x07, 0xee, 0x52, 0xb7, 0xf4, 0xff, 0xd6, 0x00, 0x6f,
	0x44, 0x8a, 0xf8, 0x8e, 0x61, 0xa0, 0xaa, 0x88, 0xcd, 0x03, 0xf5, 0xe7, 0x5c, 0x1a, 0x09, 0xbc,
	0xe1, 0xe1, 0x09, 0x4b, 0xe4, 0xfc, 0x64, 0xea, 0xa6, 0x8c, 0x7c, 0x28, 0xc0, 0xaa, 0xed, 0x4d,
	0xe7, 0xc5, 0x90, 0x30, 0x86, 0x81, 0xca, 0x80, 0x2a, 0xc9, 0xe6, 0xbb, 0x48, 0x22, 0x21, 0xcb,
	0x24, 0x13, 0x18, 0x98, 0x19, 0xa8, 0x4c, 0x62, 0xca, 0xf4, 0xe0, 0xc4, 0x4e, 0x47, 0x37, 0xfa,
	0x27, 0xb7, 0xb9, 0xd8, 0xc0, 0x3b, 0xb2, 0x2a, 0x42, 0xbf, 0x86, 0xf7, 0xf2, 0xc1, 0xa7, 0xcc,
	0xd4, 0xd0, 0x4c, 0x4f, 0x4f, 0x8a, 0xa9, 0xe8, 0xf5, 0xf0, 0xda, 0xac, 0xca, 0x7c, 0x28, 0xd7,
	0x17, 0x94, 0x2f, 0xa1, 0xa7, 0xa6, 0x8f, 0xb5, 0x92, 0x36, 0x25, 0x56, 0x1a, 0x60, 0xd4, 0xdf,
	0x1e, 0x2d, 0xcd, 0x33, 0x43, 0xdd, 0x40, 0xd6, 0xea, 0x79, 0xc7, 0x34, 0x82, 0xab, 0x92, 0x11,
	0xb0, 0xa2, 0x9a, 0x7f, 0x06, 0x3d, 0x66, 0xf3, 0x50, 0x5d, 0xde, 0x56, 0xf3, 0xa1, 0x9b, 0xab,
	0xd6, 0xcb, 0x13, 0x7b, 0x0e, 0xfd, 0x39, 0x5d, 0xa1, 0x9f, 0xc3, 0x56, 0x6e, 0xac, 0x5b, 0x6e,
	0xe7, 0x1d, 0xd6, 0xf9, 0x59, 0xaa, 0x19, 0xab, 0x96, 0x20, 0xe8, 0x22, 0xbf, 0xb0, 0xda, 0x67,
	0x77, 0x32, 0xdf, 0xfb, 0x7f, 0xaf, 0xc3, 0xd6, 0x88, 0x94, 0xeb, 0xe3, 0x99, 0x1a, 0x0e, 0x75,
	0x51, 0x99, 0x86, 0x9d, 0xcf, 0x7f, 0x06, 0x83, 0xad, 0x56, 0xf5, 0x09, 0x96, 0x2c, 0x82, 0x25,
	0xe3, 0x3c, 0xe5, 0x2a, 0x8d, 0xf5, 0xb8, 0xa1, 0x2e, 0xbf, 0x98, 0x69, 0xd9, 0x24, 0x41, 0x9f,
	0xc2, 0x93, 0x12, 0x46, 0x50, 0x21, 0x58, 0x9a, 0x94, 0xd3, 0xa0, 0x85, 0xf7, 0x73, 0xfc, 0xb5,
	0x51, 0xdb, 0xf8, 0xa8, 0xe9, 0x70, 0xc1, 0x4b, 0xf4, 0xa6, 0x93, 0x78, 0x74, 0xc1, 0xcb, 0xf4,
	0x25, 0xcc, 0x1a, 0x7d, 0xd3, 0xd0, 0xe7, 0xf8, 0x2a, 0xfd, 0x09, 0xec, 0x92, 0x34, 0xcb, 0x82,
	0x2c, 0x8d, 0x19, 0xa1, 0x6e, 0x7c, 0xd5, 0xf1, 0x6c, 0xe1, 0x81, 0x52, 0x5d, 0x19, 0x8d, 0xc5,
	0xcf, 0x60, 0x9f, 0x53, 0xd3, 0x5e, 0xd6, 0x4a, 0xa2, 0xfd, 0x8e, 0x92, 0xd8, 0x75, 0x76, 0xd5,
	0xba, 0xe8, 0xe7, 0x51, 0x35, 0xfe, 0x14, 0x36, 0xb0, 0x47, 0xeb, 0x81, 0x2d, 0x42, 0x83, 0x77,
	0x58, 0x45, 0x26, 0xfc, 0x7f, 0xd6, 0xa0, 0xad, 0x0a, 0x3f, 0xa3, 0x04, 0x7d, 0x0f, 0x1a, 0x4b,
	0x2a, 0x43, 0x5b, 0xe7, 0xee, 0x3f, 0xed, 0xf2, 0x8b, 0xdf, 0x51, 0x22, 0x67, 0x54, 0x86, 0x58,
	0xab, 0xd1, 0xcb, 0xb5, 0x89, 0xdd, 0x96, 0xf4, 0xc0, 0x1d, 0x5b, 0x5c, 0xdc, 0xbb, 0xa3, 0xab,
	0x4b, 0xf7, 0xfe, 0x23, 0xe8, 0x64, 0x9c, 0xa5, 0x9c, 0xc9, 0x95, 0x1b, 0x0b, 0xdc, 0x1e, 0x3d,
	0x83, 0xe6, 0x32, 0x94, 0xe4, 0xd6, 0x96, 0x63, 0xdf, 0x51, 0xe5, 0x29, 0x69, 0xd4, 0xe8, 0xe3,
	0x3c, 0xb3, 0x9a, 0x76, 0x30, 0xaa, 0x64, 0x96, 0x7e, 0xa2, 0x45, 0xf8, 0x3f, 0xd1, 0x69, 0x89,
	0xe9, 0xef, 0xef, 0xa9, 0x90, 0x33, 0xb1, 0x40, 0xcf, 0xa0, 0xcd, 0xcd, 0xee, 0xb0, 0x76, 0x5c,
	0x7f, 0xee, 0x0d, 0x7b, 0xf9, 0x31, 0x19, 0x25, 0xd8, 0x29, 0xfd, 0x9f, 0xea, 0x0f, 0xa2, 0x6b,
	0x19, 0xca, 0x7b, 0x81, 0x7e, 0x58, 0xf9, 0x9e, 0xa9, 0x3d, 0xf6, 0x3d, 0x53, 0xfa, 0x9a, 0xf1,
	0xe7, 0xba, 0x8d, 0x62, 0x2a, 0xb2, 0x34, 0x11, 0x54, 0x7f, 0x0d, 0x65, 0x2c, 0x10, 0x9a, 0xcb,
	0x56, 0x83, 0xeb, 0xc3, 0xa3, 0x8c, 0x99, 0x33, 0x70, 0x37, 0x74, 0x4b, 0x55, 0x3a, 0x16, 0xbc,
	0xf6, 0xe9, 0x64, 0xa1, 0x56, 0xeb, 0xff, 0x02, 0xb6, 0x4b, 0xe7, 0xa8, 0xd7, 0xfd, 0x00, 0x3a,
	0xdc, 0x6e, 0xed, 0xf3, 0x72, 0x2f, 0x3a, 0x18, 0xce, 0x11, 0x7e, 0x06, 0xfd, 0x11, 0x89, 0xcf,
	0x69, 0x4c, 0x25, 0xb5, 0x2e, 0xfa, 0xff, 0x86, 0xdf, 0x7f, 0xa5, 0x07, 0x89, 0xca, 0x89, 0xea,
	0xda, 0xa7, 0xeb, 0x41, 0xd9, 0x73, 0x3c, 0x15, 0x68, 0x11, 0x9d, 0x73, 0x18, 0x94, 0x94, 0xdf,
	0xd0, 0xcf, 0xfe, 0xaf, 0xe0, 0xbd, 0x07, 0x2c, 0xea, 0x3a, 0xc3, 0x07, 0x5e, 0xdc, 0x5f, 0xbf,
	0xcf, 0x03, 0x5f, 0x2e, 0x75, 0xa2, 0x7d, 0x46, 0xe5, 0xb7, 0xe3, 0xc8, 0x5f, 0xea, 0xd0, 0x15,
	0xc7, 0x99, 0xe0, 0xaf, 0x79, 0x31, 0x2f, 0x8c, 0x02, 0x57, 0xb8, 0x10, 0xa0, 0x63, 0x33, 0x4a,
	0xf8, 0x7f, 0xd4, 0x89, 0xa4, 0x51, 0xd6, 0x97, 0xc7, 0xd0, 0x10, 0x19, 0x25, 0xf6, 0xf6, 0xd5,
	0x1a, 0xd1, 0x9a, 0xaf, 0x9b, 0xa4, 0xe8, 0x03, 0x68, 0xaa, 0x95, 0xb0, 0x7f, 0xd7, 0x5b, 0x65,
	0x98, 0xc0, 0x46, 0x67, 0xe3, 0x59, 0xba, 0x80, 0xc9, 0x8a, 0xf5, 0x30, 0xec, 0x56, 0x1e, 0xb4,
	0x1e, 0x83, 0x8f, 0x57, 0xba, 0x66, 0x4d, 0x17, 0x40, 0xbb, 0xb0, 0x33, 0x1a, 0xbf, 0x0e, 0x46,
	0xe3, 0x9b, 0xe9, 0xe5, 0x9b, 0xe0, 0xcd, 0xe5, 0x9b, 0x49, 0x7f, 0x03, 0xed, 0xc1, 0xa0, 0x24,
	0xbc, 0x9a, 0xe0, 0xd9, 0xf4, 0xa6, 0x5f, 0x43, 0x08, 0xb6, 0x4b, 0xe2, 0xd7, 0x97, 0x9f, 0xf5,
	0x37, 0xd7, 0xec, 0xcf, 0x27, 0x6f, 0x7e, 0xd3, 0xaf, 0xa3, 0x03, 0xd8, 0x2d, 0x09, 0xf1, 0xe4,
	0x7c, 0x8a, 0x27, 0xe3, 0x9b, 0x7e, 0x63, 0xf8, 0xef, 0x1a, 0xd4, 0x47, 0x24, 0x46, 0x3f, 0xd6,
	0x57, 0x18, 0x73, 0xaa, 0x46, 0x4b, 0x54, 0xd4, 0x9e, 0x0b, 0xd2, 0xd1, 0xee, 0x7a, 0x3d, 0xce,
	0xc4, 0xc2, 0xdf, 0xb0, 0x76, 0x6f, 0xb3, 0xe8, 0x7f, 0xb4, 0x3b, 0xd3, 0x76, 0x26, 0x2b, 0xd1,
	0xe1, 0xa3, 0x55, 0xa3, 0xac, 0x9f, 0x3c, 0x9e, 0xbf, 0x86, 0xe3, 0x53, 0x68, 0x19, 0x97, 0xa2,
	0xbd, 0x87, 0x09, 0xa3, 0xac, 0xf7, 0x1f, 0x71, 0xbb, 0x36, 0x3d, 0x83, 0xdf, 0x76, 0x6e, 0xc3,
	0x58, 0x7f, 0x07, 0x7d, 0xd1, 0xd2, 0x3f, 0x3f, 0xfa, 0x6f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x68,
	0x3f, 0x3c, 0x79, 0xda, 0x12, 0x00, 0x00,
}
