// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: nic/proto/hal/acl.proto

/*
	Package halproto is a generated protocol buffer package.

	It is generated from these files:
		nic/proto/hal/acl.proto
		nic/proto/hal/cpucb.proto
		nic/proto/hal/crypto_keys.proto
		nic/proto/hal/descriptor_aol.proto
		nic/proto/hal/endpoint.proto
		nic/proto/hal/events.proto
		nic/proto/hal/interface.proto
		nic/proto/hal/internal.proto
		nic/proto/hal/ipseccb.proto
		nic/proto/hal/l2segment.proto
		nic/proto/hal/l4lb.proto
		nic/proto/hal/multicast.proto
		nic/proto/hal/nic.proto
		nic/proto/hal/nw.proto
		nic/proto/hal/nwsec.proto
		nic/proto/hal/proxy.proto
		nic/proto/hal/qos.proto
		nic/proto/hal/rdma.proto
		nic/proto/hal/session.proto
		nic/proto/hal/system.proto
		nic/proto/hal/tcp_proxy_cb.proto
		nic/proto/hal/telemetry.proto
		nic/proto/hal/tenant.proto
		nic/proto/hal/tls_proxy_cb.proto
		nic/proto/hal/wring.proto
		nic/proto/types.proto

	It has these top-level messages:
		AclHandle
		AclKeyHandle
		EthSelector
		UDPSelector
		TCPSelector
		ICMPSelector
		IPSelector
		AclInternalSelector
		AclInternalActionInfo
		AclSelector
		AclActionInfo
		AclSpec
		AclRequestMsg
		AclStatus
		AclResponse
		AclResponseMsg
		AclDeleteRequest
		AclDeleteRequestMsg
		AclDeleteResponse
		AclDeleteResponseMsg
		AclGetRequest
		AclGetRequestMsg
		AclStats
		AclGetResponse
		AclGetResponseMsg
		CpuCbKeyHandle
		CpuCbSpec
		CpuCbRequestMsg
		CpuCbStatus
		CpuCbResponse
		CpuCbResponseMsg
		CpuCbDeleteRequest
		CpuCbDeleteRequestMsg
		CpuCbDeleteResponseMsg
		CpuCbGetRequest
		CpuCbGetRequestMsg
		CpuCbStats
		CpuCbGetResponse
		CpuCbGetResponseMsg
		CryptoKeyCreateRequest
		CryptoKeyCreateRequestMsg
		CryptoKeyCreateResponse
		CryptoKeyCreateResponseMsg
		CryptoKeySpec
		CryptoKeyReadRequest
		CryptoKeyReadRequestMsg
		CryptoKeyReadResponse
		CryptoKeyReadResponseMsg
		CryptoKeyUpdateRequest
		CryptoKeyUpdateRequestMsg
		CryptoKeyUpdateResponse
		CryptoKeyUpdateResponseMsg
		CryptoKeyDeleteRequest
		CryptoKeyDeleteRequestMsg
		CryptoKeyDeleteResponse
		CryptoKeyDeleteResponseMsg
		DescrAolRequest
		DescrAolRequestMsg
		DescrAolSpec
		DescrAolResponseMsg
		EndpointSpec
		EndpointRequestMsg
		EndpointStatus
		EndpointResponse
		EndpointResponseMsg
		EndpointL2Key
		EndpointL3Key
		EndpointKey
		EndpointKeyHandle
		EndpointUpdateRequest
		EndpointUpdateRequestMsg
		EndpointUpdateResponseMsg
		EndpointFilter
		EndpointDeleteRequest
		EndpointDeleteRequestMsg
		EndpointDeleteResponseMsg
		EndpointGetRequest
		EndpointGetRequestMsg
		EndpointGetByInterfaceRequestMsg
		EndpointGetAllRequestMsg
		EndpointStats
		EndpointGetResponse
		EndpointGetResponseMsg
		LifQStateMapEntry
		LifKeyHandle
		LifSpec
		LifRequestMsg
		LifStatus
		LifQState
		LifRdmaData
		LifResponse
		LifResponseMsg
		QStateGetReq
		GetQStateRequestMsg
		QStateGetResp
		GetQStateResponseMsg
		P4ProgLabel
		QStateSetReq
		SetQStateRequestMsg
		QStateSetResp
		SetQStateResponseMsg
		LifDeleteRequest
		LifDeleteRequestMsg
		LifDeleteResponseMsg
		LifTxStats
		LifRxStats
		LifStats
		LifGetRequest
		LifGetRequestMsg
		LifGetResponse
		LifGetResponseMsg
		IfEnicInfo
		TrafficClassInfo
		IfUplinkInfo
		IfUplinkPCInfo
		InterfaceKeyHandle
		IfTunnelVxlanInfo
		IfTunnelInfo
		IfCPUInfo
		InterfaceSpec
		InterfaceRequestMsg
		InterfaceStatus
		InterfaceResponse
		InterfaceResponseMsg
		InterfaceDeleteRequest
		InterfaceDeleteRequestMsg
		InterfaceDeleteResponseMsg
		InterfaceStats
		InterfaceGetRequest
		InterfaceGetRequestMsg
		InterfaceGetResponse
		InterfaceGetResponseMsg
		InterfaceL2SegmentSpec
		InterfaceL2SegmentRequestMsg
		InterfaceL2SegmentResponse
		InterfaceL2SegmentResponseMsg
		ProgramAddressReq
		ProgramAddressResp
		GetProgramAddressRequestMsg
		ProgramAddressResponseMsg
		HbmAddressReq
		HbmAddressResp
		AllocHbmAddressRequestMsg
		AllocHbmAddressResponseMsg
		IpsecCbKeyHandle
		IpsecCbSpec
		IpsecCbRequestMsg
		IpsecCbStatus
		IpsecCbResponse
		IpsecCbResponseMsg
		IpsecCbDeleteRequest
		IpsecCbDeleteRequestMsg
		IpsecCbDeleteResponseMsg
		IpsecCbGetRequest
		IpsecCbGetRequestMsg
		IpsecCbStats
		IpsecCbGetResponse
		IpsecCbGetResponseMsg
		L2SegmentKeyHandle
		L2SegmentSpec
		L2SegmentRequestMsg
		L2SegmentStatus
		L2SegmentResponse
		L2SegmentResponseMsg
		L2SegmentDeleteRequest
		L2SegmentDeleteRequestMsg
		L2SegmentDeleteResponseMsg
		L2SegmentGetRequest
		L2SegmentGetRequestMsg
		L2SegmentStats
		L2SegmentGetResponse
		L2SegmentGetResponseMsg
		LBMethod
		HealthCheck
		L4LbServiceKey
		L4LbServiceKeyHandle
		L4LbServiceSpec
		L4LbServiceRequestMsg
		L4LbServiceStatus
		L4LbServiceResponse
		L4LbServiceResponseMsg
		L4LbServiceDeleteRequest
		L4LbServiceDeleteRequestMsg
		L4LbServiceDeleteResponseMsg
		L4LbServiceStats
		L4LbBackendKey
		L4LbBackendKeyHandle
		L4LbBackendSpec
		L4LbBackendRequestMsg
		L4LbBackendStatus
		L4LbBackendResponse
		L4LbBackendResponseMsg
		L4LbBackendDeleteRequest
		L4LbBackendDeleteRequestMsg
		L4LbBackendDeleteResponseMsg
		L4LbBackendStats
		L4LbBackendGetRequest
		L4LbBackendGetRequestMsg
		L4LbBackendGetResponse
		L4LbBackendGetResponseMsg
		L4LbServiceGetRequest
		L4LbServiceGetRequestMsg
		L4LbServiceGetResponse
		L4LbServiceGetResponseMsg
		MulticastEntryKeyIP
		MulticastEntryKeyMac
		MulticastEntryKey
		MulticastEntryKeyHandle
		MulticastEntrySpec
		MulticastEntryRequestMsg
		MulticastEntryStatus
		MulticastEntryResponse
		MulticastEntryResponseMsg
		MulticastEntryDeleteRequest
		MulticastEntryDeleteRequestMsg
		MulticastEntryDeleteResponseMsg
		MulticastEntryGetRequest
		MulticastEntryGetRequestMsg
		MulticastEntryGetResponse
		MulticastEntryGetResponseMsg
		RootConfig
		NetworkKeyHandle
		NetworkSpec
		NetworkRequestMsg
		NetworkStatus
		NetworkResponse
		NetworkResponseMsg
		NetworkDeleteRequest
		NetworkDeleteRequestMsg
		NetworkDeleteResponseMsg
		NetworkStats
		NetworkGetRequest
		NetworkGetRequestMsg
		NetworkGetResponse
		NetworkGetResponseMsg
		SecurityProfileKeyHandle
		SecurityProfileSpec
		SecurityProfileRequestMsg
		SecurityProfileStatus
		SecurityProfileResponse
		SecurityProfileResponseMsg
		SecurityProfileDeleteRequest
		SecurityProfileDeleteRequestMsg
		SecurityProfileDeleteResponseMsg
		SecurityProfileGetRequest
		SecurityProfileGetRequestMsg
		SecurityProfileStats
		SecurityProfileGetResponse
		SecurityProfileGetResponseMsg
		Service
		FirewallRuleSpec
		IngressSGPolicy
		EgressSGPolicy
		SecurityGroupKeyHandle
		SecurityGroupSpec
		SecurityGroupRequestMsg
		SecurityGroupStatus
		SecurityGroupResponse
		SecurityGroupResponseMsg
		SecurityGroupDeleteRequest
		SecurityGroupDeleteRequestMsg
		SecurityGroupDeleteResponseMsg
		SecurityGroupGetRequest
		SecurityGroupGetRequestMsg
		SecurityGroupStats
		SecurityGroupGetResponse
		SecurityGroupGetResponseMsg
		DoSSessionLimits
		DoSPolicer
		DoSFloodLimits
		DoSProtectionSpec
		IngressDoSPolicy
		EgressDoSPolicy
		DoSKeyHandle
		DoSSpec
		DoSRequestMsg
		DoSStatus
		DoSResponse
		DoSResponseMsg
		DoSDeleteRequest
		DoSDeleteRequestMsg
		DoSDeleteResponseMsg
		DoSGetRequest
		DoSGetRequestMsg
		DoSStats
		DoSGetResponse
		DoSGetResponseMsg
		ProxyKeyHandle
		ProxySpec
		ProxyRequestMsg
		ProxyStatus
		ProxyResponse
		ProxyResponseMsg
		ProxyDisableRequest
		ProxyDisableRequestMsg
		ProxyDisableResponseMsg
		ProxyGetRequest
		ProxyGetRequestMsg
		ProxyStats
		ProxyGetResponse
		ProxyGetResponseMsg
		ProxyFlowConfigRequest
		ProxyFlowConfigRequestMsg
		ProxyGetFlowInfoRequest
		ProxyGetFlowInfoRequestMsg
		ProxyGetFlowInfoResponse
		ProxyGetFlowInfoResponseMsg
		MarkingActionSpec
		QOSActions
		TrafficClass
		TrafficClassQueueMap
		BufPoolHandle
		BufPoolKeyHandle
		BufPoolSpec
		BufPoolRequestMsg
		BufPoolStatus
		BufPoolResponse
		BufPoolResponseMsg
		BufPoolDeleteRequest
		BufPoolDeleteRequestMsg
		BufPoolDeleteResponseMsg
		BufPoolStats
		BufPoolGetRequest
		BufPoolGetRequestMsg
		BufPoolGetResponse
		BufPoolGetResponseMsg
		QueueHandle
		QueueKeyHandle
		DWRRInfo
		StrictPriorityInfo
		QueueSchedulerNode
		QueueInfo
		QueueSpec
		QueueRequestMsg
		QueueStatus
		QueueResponse
		QueueResponseMsg
		QueueDeleteRequest
		QueueDeleteRequestMsg
		QueueDeleteResponseMsg
		QueueStats
		QueueGetRequest
		QueueGetRequestMsg
		QueueGetResponse
		QueueGetResponseMsg
		PolicerHandle
		PolicerKeyHandle
		PolicerSpec
		PolicerRequestMsg
		PolicerStatus
		PolicerResponse
		PolicerResponseMsg
		PolicerDeleteRequest
		PolicerDeleteRequestMsg
		PolicerDeleteResponseMsg
		PolicerGetRequest
		PolicerGetRequestMsg
		PolicerStats
		PolicerGetResponse
		PolicerGetResponseMsg
		RdmaQpSpec
		RdmaQpRequestMsg
		RdmaQpResponse
		RdmaQpResponseMsg
		RdmaCqSpec
		RdmaCqRequestMsg
		RdmaCqResponse
		RdmaCqResponseMsg
		RdmaMemRegSpec
		RdmaMemRegRequestMsg
		RdmaMemRegResponse
		RdmaMemRegResponseMsg
		FlowKeyL2
		FlowKeyTcpUdpInfo
		FlowKeyICMPInfo
		FlowKeyESPInfo
		FlowKeyV4
		FlowKeyV6
		FlowKey
		FlowInfo
		ConnTrackInfo
		FlowData
		FlowSpec
		SessionSpec
		SessionRequestMsg
		FlowStatus
		SessionStatus
		SessionResponse
		SessionResponseMsg
		SessionDeleteRequest
		SessionDeleteRequestMsg
		SessionDeleteResponseMsg
		SessionGetRequest
		SessionGetRequestMsg
		FlowStats
		SessionStats
		SessionGetResponse
		SessionGetResponseMsg
		SystemResponse
		Stats
		DropStats
		DropStatsEntry
		TcpCbKeyHandle
		TcpCbSpec
		TcpCbRequestMsg
		TcpCbStatus
		TcpCbResponse
		TcpCbResponseMsg
		TcpCbDeleteRequest
		TcpCbDeleteRequestMsg
		TcpCbDeleteResponseMsg
		TcpCbGetRequest
		TcpCbGetRequestMsg
		TcpCbStats
		TcpCbGetResponse
		TcpCbGetResponseMsg
		L4Port
		MacAddress
		CollectorSpec
		CollectorStatus
		Collector
		CollectorConfigMsg
		CollectorResponseMsg
		ExportControlId
		ExportControlSpec
		ExportControlStatus
		ExportControl
		ExportControlConfigMsg
		ExportControlResponseMsg
		MonitorAction
		FlowMonitorRuleSpec
		FlowMonitorRuleStatus
		FlowMonitorRule
		FlowMonitorRuleConfigMsg
		FlowMonitorRuleResponseMsg
		RSpanSpec
		ERSpanSpec
		MirrorSessionId
		MirrorSessionSpec
		MirrorSessionStatus
		MirrorSession
		MirrorSessionConfigMsg
		MirrorSessionDeleteMsg
		MirrorSessionResponseMsg
		TenantKeyHandle
		TenantSpec
		TenantRequestMsg
		TenantStatus
		TenantResponse
		TenantResponseMsg
		TenantDeleteRequest
		TenantDeleteRequestMsg
		TenantDeleteResponseMsg
		TenantGetRequest
		TenantGetRequestMsg
		TenantStats
		TenantGetResponse
		TenantGetResponseMsg
		TlsCbKeyHandle
		TlsCbSpec
		TlsCbRequestMsg
		TlsCbStatus
		TlsCbResponse
		TlsCbResponseMsg
		TlsCbDeleteRequest
		TlsCbDeleteRequestMsg
		TlsCbDeleteResponseMsg
		TlsCbGetRequest
		TlsCbGetRequestMsg
		TlsCbStats
		TlsCbGetResponse
		TlsCbGetResponseMsg
		WRingKeyHandle
		WRingSpec
		WRingRequestMsg
		WRingStatus
		WRingResponse
		WRingResponseMsg
		WRingDeleteRequest
		WRingDeleteRequestMsg
		WRingDeleteResponseMsg
		WRingGetEntriesRequest
		WRingGetEntriesRequestMsg
		WRingStats
		WRingBarcoGCMDescMsg
		WRingGetEntriesResponse
		WRingGetEntriesResponseMsg
		WRingGetMetaResponse
		WRingGetMetaResponseMsg
		ObjectMeta
		EncapInfo
		IPAddress
		IPPrefix
		L4PortRange
		Empty
*/
package halproto

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// Ignoring public import of ObjectMeta from nic/proto/types.proto

// Ignoring public import of EncapInfo from nic/proto/types.proto

// Ignoring public import of IPAddress from nic/proto/types.proto

// Ignoring public import of IPPrefix from nic/proto/types.proto

// Ignoring public import of L4PortRange from nic/proto/types.proto

// Ignoring public import of Empty from nic/proto/types.proto

// Ignoring public import of IPProtocol from nic/proto/types.proto

// Ignoring public import of ICMPMsgType from nic/proto/types.proto

// Ignoring public import of ApiStatus from nic/proto/types.proto

// Ignoring public import of L2SegmentType from nic/proto/types.proto

// Ignoring public import of encapType from nic/proto/types.proto

// Ignoring public import of IPAddressFamily from nic/proto/types.proto

// Ignoring public import of WRingType from nic/proto/types.proto

// Ignoring public import of ProxyType from nic/proto/types.proto

// Ignoring public import of CryptoKeyType from nic/proto/types.proto

// DropReason enums
type DropReason int32

const (
	DropReason_INPUT_MAPPING__DROP                   DropReason = 0
	DropReason_INPUT_MAPPING_DEJAVU__DROP            DropReason = 1
	DropReason_FLOW_HIT__DROP                        DropReason = 2
	DropReason_FLOW_MISS__DROP                       DropReason = 3
	DropReason_IPSG__DROP                            DropReason = 4
	DropReason_INGRESS_POLICER__DROP                 DropReason = 5
	DropReason_EGRESS_POLICER__DROP                  DropReason = 6
	DropReason_NACL__DROP                            DropReason = 7
	DropReason_MALFORMED_PKT__DROP                   DropReason = 8
	DropReason_PING_OF_DEATH__DROP                   DropReason = 9
	DropReason_FRAGMENT_TOO_SMALL__DROP              DropReason = 10
	DropReason_IP_NORMALIZATION__DROP                DropReason = 11
	DropReason_TCP_NORMALIZATION__DROP               DropReason = 12
	DropReason_TCP_XMAS_TREE_PKT__DROP               DropReason = 13
	DropReason_TCP_NON_SYN_FIRST_PKT__DROP           DropReason = 14
	DropReason_ICMP_NORMALIZATION__DROP              DropReason = 15
	DropReason_ICMP_SRC_QUENCH_MSG__DROP             DropReason = 16
	DropReason_ICMP_REDIRECT_MSG__DROP               DropReason = 17
	DropReason_ICMP_INFO_REQ_MSG__DROP               DropReason = 18
	DropReason_ICMP_ADDR_REQ_MSG__DROP               DropReason = 19
	DropReason_ICMP_TRACEROUTE_MSG__DROP             DropReason = 20
	DropReason_ICMP_RSVD_TYPE_MSG__DROP              DropReason = 21
	DropReason_INPUT_PROPERTIES_MISS__DROP           DropReason = 22
	DropReason_TCP_OUT_OF_WINDOW__DROP               DropReason = 23
	DropReason_TCP_SPLIT_HANDSHAKE__DROP             DropReason = 24
	DropReason_TCP_WIN_ZERO_DROP__DROP               DropReason = 25
	DropReason_TCP_ACK_ERR__DROP                     DropReason = 26
	DropReason_TCP_DATA_AFTER_FIN__DROP              DropReason = 27
	DropReason_TCP_NON_RST_PKT_AFTER_RST__DROP       DropReason = 28
	DropReason_TCP_INVALID_RESPONDER_FIRST_PKT__DROP DropReason = 29
	DropReason_TCP_UNEXPECTED_SYN__DROP              DropReason = 30
)

var DropReason_name = map[int32]string{
	0:  "INPUT_MAPPING__DROP",
	1:  "INPUT_MAPPING_DEJAVU__DROP",
	2:  "FLOW_HIT__DROP",
	3:  "FLOW_MISS__DROP",
	4:  "IPSG__DROP",
	5:  "INGRESS_POLICER__DROP",
	6:  "EGRESS_POLICER__DROP",
	7:  "NACL__DROP",
	8:  "MALFORMED_PKT__DROP",
	9:  "PING_OF_DEATH__DROP",
	10: "FRAGMENT_TOO_SMALL__DROP",
	11: "IP_NORMALIZATION__DROP",
	12: "TCP_NORMALIZATION__DROP",
	13: "TCP_XMAS_TREE_PKT__DROP",
	14: "TCP_NON_SYN_FIRST_PKT__DROP",
	15: "ICMP_NORMALIZATION__DROP",
	16: "ICMP_SRC_QUENCH_MSG__DROP",
	17: "ICMP_REDIRECT_MSG__DROP",
	18: "ICMP_INFO_REQ_MSG__DROP",
	19: "ICMP_ADDR_REQ_MSG__DROP",
	20: "ICMP_TRACEROUTE_MSG__DROP",
	21: "ICMP_RSVD_TYPE_MSG__DROP",
	22: "INPUT_PROPERTIES_MISS__DROP",
	23: "TCP_OUT_OF_WINDOW__DROP",
	24: "TCP_SPLIT_HANDSHAKE__DROP",
	25: "TCP_WIN_ZERO_DROP__DROP",
	26: "TCP_ACK_ERR__DROP",
	27: "TCP_DATA_AFTER_FIN__DROP",
	28: "TCP_NON_RST_PKT_AFTER_RST__DROP",
	29: "TCP_INVALID_RESPONDER_FIRST_PKT__DROP",
	30: "TCP_UNEXPECTED_SYN__DROP",
}
var DropReason_value = map[string]int32{
	"INPUT_MAPPING__DROP":                   0,
	"INPUT_MAPPING_DEJAVU__DROP":            1,
	"FLOW_HIT__DROP":                        2,
	"FLOW_MISS__DROP":                       3,
	"IPSG__DROP":                            4,
	"INGRESS_POLICER__DROP":                 5,
	"EGRESS_POLICER__DROP":                  6,
	"NACL__DROP":                            7,
	"MALFORMED_PKT__DROP":                   8,
	"PING_OF_DEATH__DROP":                   9,
	"FRAGMENT_TOO_SMALL__DROP":              10,
	"IP_NORMALIZATION__DROP":                11,
	"TCP_NORMALIZATION__DROP":               12,
	"TCP_XMAS_TREE_PKT__DROP":               13,
	"TCP_NON_SYN_FIRST_PKT__DROP":           14,
	"ICMP_NORMALIZATION__DROP":              15,
	"ICMP_SRC_QUENCH_MSG__DROP":             16,
	"ICMP_REDIRECT_MSG__DROP":               17,
	"ICMP_INFO_REQ_MSG__DROP":               18,
	"ICMP_ADDR_REQ_MSG__DROP":               19,
	"ICMP_TRACEROUTE_MSG__DROP":             20,
	"ICMP_RSVD_TYPE_MSG__DROP":              21,
	"INPUT_PROPERTIES_MISS__DROP":           22,
	"TCP_OUT_OF_WINDOW__DROP":               23,
	"TCP_SPLIT_HANDSHAKE__DROP":             24,
	"TCP_WIN_ZERO_DROP__DROP":               25,
	"TCP_ACK_ERR__DROP":                     26,
	"TCP_DATA_AFTER_FIN__DROP":              27,
	"TCP_NON_RST_PKT_AFTER_RST__DROP":       28,
	"TCP_INVALID_RESPONDER_FIRST_PKT__DROP": 29,
	"TCP_UNEXPECTED_SYN__DROP":              30,
}

func (x DropReason) String() string {
	return proto.EnumName(DropReason_name, int32(x))
}
func (DropReason) EnumDescriptor() ([]byte, []int) { return fileDescriptorAcl, []int{0} }

// AclAction specifies all possible actions for ACL entries
type AclAction int32

const (
	AclAction_ACL_ACTION_NONE     AclAction = 0
	AclAction_ACL_ACTION_PERMIT   AclAction = 1
	AclAction_ACL_ACTION_LOG      AclAction = 2
	AclAction_ACL_ACTION_DENY     AclAction = 3
	AclAction_ACL_ACTION_REDIRECT AclAction = 4
)

var AclAction_name = map[int32]string{
	0: "ACL_ACTION_NONE",
	1: "ACL_ACTION_PERMIT",
	2: "ACL_ACTION_LOG",
	3: "ACL_ACTION_DENY",
	4: "ACL_ACTION_REDIRECT",
}
var AclAction_value = map[string]int32{
	"ACL_ACTION_NONE":     0,
	"ACL_ACTION_PERMIT":   1,
	"ACL_ACTION_LOG":      2,
	"ACL_ACTION_DENY":     3,
	"ACL_ACTION_REDIRECT": 4,
}

func (x AclAction) String() string {
	return proto.EnumName(AclAction_name, int32(x))
}
func (AclAction) EnumDescriptor() ([]byte, []int) { return fileDescriptorAcl, []int{1} }

// Handle of the acl
type AclHandle struct {
	Handle uint64 `protobuf:"fixed64,1,opt,name=handle,proto3" json:"handle,omitempty"`
}

func (m *AclHandle) Reset()                    { *m = AclHandle{} }
func (m *AclHandle) String() string            { return proto.CompactTextString(m) }
func (*AclHandle) ProtoMessage()               {}
func (*AclHandle) Descriptor() ([]byte, []int) { return fileDescriptorAcl, []int{0} }

func (m *AclHandle) GetHandle() uint64 {
	if m != nil {
		return m.Handle
	}
	return 0
}

// AclKeyHandle uniquely identifies a Acl
type AclKeyHandle struct {
	// Types that are valid to be assigned to KeyOrHandle:
	//	*AclKeyHandle_AclId
	//	*AclKeyHandle_AclHandle
	KeyOrHandle isAclKeyHandle_KeyOrHandle `protobuf_oneof:"key_or_handle"`
}

func (m *AclKeyHandle) Reset()                    { *m = AclKeyHandle{} }
func (m *AclKeyHandle) String() string            { return proto.CompactTextString(m) }
func (*AclKeyHandle) ProtoMessage()               {}
func (*AclKeyHandle) Descriptor() ([]byte, []int) { return fileDescriptorAcl, []int{1} }

type isAclKeyHandle_KeyOrHandle interface {
	isAclKeyHandle_KeyOrHandle()
	MarshalTo([]byte) (int, error)
	Size() int
}

type AclKeyHandle_AclId struct {
	AclId uint32 `protobuf:"fixed32,1,opt,name=acl_id,json=aclId,proto3,oneof"`
}
type AclKeyHandle_AclHandle struct {
	AclHandle *AclHandle `protobuf:"bytes,2,opt,name=acl_handle,json=aclHandle,oneof"`
}

func (*AclKeyHandle_AclId) isAclKeyHandle_KeyOrHandle()     {}
func (*AclKeyHandle_AclHandle) isAclKeyHandle_KeyOrHandle() {}

func (m *AclKeyHandle) GetKeyOrHandle() isAclKeyHandle_KeyOrHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

func (m *AclKeyHandle) GetAclId() uint32 {
	if x, ok := m.GetKeyOrHandle().(*AclKeyHandle_AclId); ok {
		return x.AclId
	}
	return 0
}

func (m *AclKeyHandle) GetAclHandle() *AclHandle {
	if x, ok := m.GetKeyOrHandle().(*AclKeyHandle_AclHandle); ok {
		return x.AclHandle
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*AclKeyHandle) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _AclKeyHandle_OneofMarshaler, _AclKeyHandle_OneofUnmarshaler, _AclKeyHandle_OneofSizer, []interface{}{
		(*AclKeyHandle_AclId)(nil),
		(*AclKeyHandle_AclHandle)(nil),
	}
}

func _AclKeyHandle_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*AclKeyHandle)
	// key_or_handle
	switch x := m.KeyOrHandle.(type) {
	case *AclKeyHandle_AclId:
		_ = b.EncodeVarint(1<<3 | proto.WireFixed32)
		_ = b.EncodeFixed32(uint64(x.AclId))
	case *AclKeyHandle_AclHandle:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.AclHandle); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("AclKeyHandle.KeyOrHandle has unexpected type %T", x)
	}
	return nil
}

func _AclKeyHandle_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*AclKeyHandle)
	switch tag {
	case 1: // key_or_handle.acl_id
		if wire != proto.WireFixed32 {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeFixed32()
		m.KeyOrHandle = &AclKeyHandle_AclId{uint32(x)}
		return true, err
	case 2: // key_or_handle.acl_handle
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(AclHandle)
		err := b.DecodeMessage(msg)
		m.KeyOrHandle = &AclKeyHandle_AclHandle{msg}
		return true, err
	default:
		return false, nil
	}
}

func _AclKeyHandle_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*AclKeyHandle)
	// key_or_handle
	switch x := m.KeyOrHandle.(type) {
	case *AclKeyHandle_AclId:
		n += proto.SizeVarint(1<<3 | proto.WireFixed32)
		n += 4
	case *AclKeyHandle_AclHandle:
		s := proto.Size(x.AclHandle)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// EthSelector has match criteria for non-IP packets
type EthSelector struct {
	EthType     uint32 `protobuf:"varint,1,opt,name=eth_type,json=ethType,proto3" json:"eth_type,omitempty"`
	EthTypeMask uint32 `protobuf:"varint,2,opt,name=eth_type_mask,json=ethTypeMask,proto3" json:"eth_type_mask,omitempty"`
	SrcMac      uint64 `protobuf:"varint,3,opt,name=src_mac,json=srcMac,proto3" json:"src_mac,omitempty"`
	SrcMacMask  uint64 `protobuf:"varint,4,opt,name=src_mac_mask,json=srcMacMask,proto3" json:"src_mac_mask,omitempty"`
	DstMac      uint64 `protobuf:"varint,5,opt,name=dst_mac,json=dstMac,proto3" json:"dst_mac,omitempty"`
	DstMacMask  uint64 `protobuf:"varint,6,opt,name=dst_mac_mask,json=dstMacMask,proto3" json:"dst_mac_mask,omitempty"`
}

func (m *EthSelector) Reset()                    { *m = EthSelector{} }
func (m *EthSelector) String() string            { return proto.CompactTextString(m) }
func (*EthSelector) ProtoMessage()               {}
func (*EthSelector) Descriptor() ([]byte, []int) { return fileDescriptorAcl, []int{2} }

func (m *EthSelector) GetEthType() uint32 {
	if m != nil {
		return m.EthType
	}
	return 0
}

func (m *EthSelector) GetEthTypeMask() uint32 {
	if m != nil {
		return m.EthTypeMask
	}
	return 0
}

func (m *EthSelector) GetSrcMac() uint64 {
	if m != nil {
		return m.SrcMac
	}
	return 0
}

func (m *EthSelector) GetSrcMacMask() uint64 {
	if m != nil {
		return m.SrcMacMask
	}
	return 0
}

func (m *EthSelector) GetDstMac() uint64 {
	if m != nil {
		return m.DstMac
	}
	return 0
}

func (m *EthSelector) GetDstMacMask() uint64 {
	if m != nil {
		return m.DstMacMask
	}
	return 0
}

// UDPSelector is used to specify match criteria for UDP traffic
type UDPSelector struct {
	SrcPortRange *L4PortRange `protobuf:"bytes,1,opt,name=src_port_range,json=srcPortRange" json:"src_port_range,omitempty"`
	DstPortRange *L4PortRange `protobuf:"bytes,2,opt,name=dst_port_range,json=dstPortRange" json:"dst_port_range,omitempty"`
}

func (m *UDPSelector) Reset()                    { *m = UDPSelector{} }
func (m *UDPSelector) String() string            { return proto.CompactTextString(m) }
func (*UDPSelector) ProtoMessage()               {}
func (*UDPSelector) Descriptor() ([]byte, []int) { return fileDescriptorAcl, []int{3} }

func (m *UDPSelector) GetSrcPortRange() *L4PortRange {
	if m != nil {
		return m.SrcPortRange
	}
	return nil
}

func (m *UDPSelector) GetDstPortRange() *L4PortRange {
	if m != nil {
		return m.DstPortRange
	}
	return nil
}

// TCPSelector is used to specify match criteria for TCP traffic
type TCPSelector struct {
	// Types that are valid to be assigned to TcpSyn:
	//	*TCPSelector_TcpSynSet
	//	*TCPSelector_TcpSynClear
	TcpSyn isTCPSelector_TcpSyn `protobuf_oneof:"tcp_syn"`
	// Types that are valid to be assigned to TcpAck:
	//	*TCPSelector_TcpAckSet
	//	*TCPSelector_TcpAckClear
	TcpAck isTCPSelector_TcpAck `protobuf_oneof:"tcp_ack"`
	// Types that are valid to be assigned to TcpFin:
	//	*TCPSelector_TcpFinSet
	//	*TCPSelector_TcpFinClear
	TcpFin isTCPSelector_TcpFin `protobuf_oneof:"tcp_fin"`
	// Types that are valid to be assigned to TcpRst:
	//	*TCPSelector_TcpRstSet
	//	*TCPSelector_TcpRstClear
	TcpRst isTCPSelector_TcpRst `protobuf_oneof:"tcp_rst"`
	// Types that are valid to be assigned to TcpUrg:
	//	*TCPSelector_TcpUrgSet
	//	*TCPSelector_TcpUrgClear
	TcpUrg       isTCPSelector_TcpUrg `protobuf_oneof:"tcp_urg"`
	SrcPortRange *L4PortRange         `protobuf:"bytes,11,opt,name=src_port_range,json=srcPortRange" json:"src_port_range,omitempty"`
	DstPortRange *L4PortRange         `protobuf:"bytes,12,opt,name=dst_port_range,json=dstPortRange" json:"dst_port_range,omitempty"`
}

func (m *TCPSelector) Reset()                    { *m = TCPSelector{} }
func (m *TCPSelector) String() string            { return proto.CompactTextString(m) }
func (*TCPSelector) ProtoMessage()               {}
func (*TCPSelector) Descriptor() ([]byte, []int) { return fileDescriptorAcl, []int{4} }

type isTCPSelector_TcpSyn interface {
	isTCPSelector_TcpSyn()
	MarshalTo([]byte) (int, error)
	Size() int
}
type isTCPSelector_TcpAck interface {
	isTCPSelector_TcpAck()
	MarshalTo([]byte) (int, error)
	Size() int
}
type isTCPSelector_TcpFin interface {
	isTCPSelector_TcpFin()
	MarshalTo([]byte) (int, error)
	Size() int
}
type isTCPSelector_TcpRst interface {
	isTCPSelector_TcpRst()
	MarshalTo([]byte) (int, error)
	Size() int
}
type isTCPSelector_TcpUrg interface {
	isTCPSelector_TcpUrg()
	MarshalTo([]byte) (int, error)
	Size() int
}

type TCPSelector_TcpSynSet struct {
	TcpSynSet bool `protobuf:"varint,1,opt,name=tcp_syn_set,json=tcpSynSet,proto3,oneof"`
}
type TCPSelector_TcpSynClear struct {
	TcpSynClear bool `protobuf:"varint,2,opt,name=tcp_syn_clear,json=tcpSynClear,proto3,oneof"`
}
type TCPSelector_TcpAckSet struct {
	TcpAckSet bool `protobuf:"varint,3,opt,name=tcp_ack_set,json=tcpAckSet,proto3,oneof"`
}
type TCPSelector_TcpAckClear struct {
	TcpAckClear bool `protobuf:"varint,4,opt,name=tcp_ack_clear,json=tcpAckClear,proto3,oneof"`
}
type TCPSelector_TcpFinSet struct {
	TcpFinSet bool `protobuf:"varint,5,opt,name=tcp_fin_set,json=tcpFinSet,proto3,oneof"`
}
type TCPSelector_TcpFinClear struct {
	TcpFinClear bool `protobuf:"varint,6,opt,name=tcp_fin_clear,json=tcpFinClear,proto3,oneof"`
}
type TCPSelector_TcpRstSet struct {
	TcpRstSet bool `protobuf:"varint,7,opt,name=tcp_rst_set,json=tcpRstSet,proto3,oneof"`
}
type TCPSelector_TcpRstClear struct {
	TcpRstClear bool `protobuf:"varint,8,opt,name=tcp_rst_clear,json=tcpRstClear,proto3,oneof"`
}
type TCPSelector_TcpUrgSet struct {
	TcpUrgSet bool `protobuf:"varint,9,opt,name=tcp_urg_set,json=tcpUrgSet,proto3,oneof"`
}
type TCPSelector_TcpUrgClear struct {
	TcpUrgClear bool `protobuf:"varint,10,opt,name=tcp_urg_clear,json=tcpUrgClear,proto3,oneof"`
}

func (*TCPSelector_TcpSynSet) isTCPSelector_TcpSyn()   {}
func (*TCPSelector_TcpSynClear) isTCPSelector_TcpSyn() {}
func (*TCPSelector_TcpAckSet) isTCPSelector_TcpAck()   {}
func (*TCPSelector_TcpAckClear) isTCPSelector_TcpAck() {}
func (*TCPSelector_TcpFinSet) isTCPSelector_TcpFin()   {}
func (*TCPSelector_TcpFinClear) isTCPSelector_TcpFin() {}
func (*TCPSelector_TcpRstSet) isTCPSelector_TcpRst()   {}
func (*TCPSelector_TcpRstClear) isTCPSelector_TcpRst() {}
func (*TCPSelector_TcpUrgSet) isTCPSelector_TcpUrg()   {}
func (*TCPSelector_TcpUrgClear) isTCPSelector_TcpUrg() {}

func (m *TCPSelector) GetTcpSyn() isTCPSelector_TcpSyn {
	if m != nil {
		return m.TcpSyn
	}
	return nil
}
func (m *TCPSelector) GetTcpAck() isTCPSelector_TcpAck {
	if m != nil {
		return m.TcpAck
	}
	return nil
}
func (m *TCPSelector) GetTcpFin() isTCPSelector_TcpFin {
	if m != nil {
		return m.TcpFin
	}
	return nil
}
func (m *TCPSelector) GetTcpRst() isTCPSelector_TcpRst {
	if m != nil {
		return m.TcpRst
	}
	return nil
}
func (m *TCPSelector) GetTcpUrg() isTCPSelector_TcpUrg {
	if m != nil {
		return m.TcpUrg
	}
	return nil
}

func (m *TCPSelector) GetTcpSynSet() bool {
	if x, ok := m.GetTcpSyn().(*TCPSelector_TcpSynSet); ok {
		return x.TcpSynSet
	}
	return false
}

func (m *TCPSelector) GetTcpSynClear() bool {
	if x, ok := m.GetTcpSyn().(*TCPSelector_TcpSynClear); ok {
		return x.TcpSynClear
	}
	return false
}

func (m *TCPSelector) GetTcpAckSet() bool {
	if x, ok := m.GetTcpAck().(*TCPSelector_TcpAckSet); ok {
		return x.TcpAckSet
	}
	return false
}

func (m *TCPSelector) GetTcpAckClear() bool {
	if x, ok := m.GetTcpAck().(*TCPSelector_TcpAckClear); ok {
		return x.TcpAckClear
	}
	return false
}

func (m *TCPSelector) GetTcpFinSet() bool {
	if x, ok := m.GetTcpFin().(*TCPSelector_TcpFinSet); ok {
		return x.TcpFinSet
	}
	return false
}

func (m *TCPSelector) GetTcpFinClear() bool {
	if x, ok := m.GetTcpFin().(*TCPSelector_TcpFinClear); ok {
		return x.TcpFinClear
	}
	return false
}

func (m *TCPSelector) GetTcpRstSet() bool {
	if x, ok := m.GetTcpRst().(*TCPSelector_TcpRstSet); ok {
		return x.TcpRstSet
	}
	return false
}

func (m *TCPSelector) GetTcpRstClear() bool {
	if x, ok := m.GetTcpRst().(*TCPSelector_TcpRstClear); ok {
		return x.TcpRstClear
	}
	return false
}

func (m *TCPSelector) GetTcpUrgSet() bool {
	if x, ok := m.GetTcpUrg().(*TCPSelector_TcpUrgSet); ok {
		return x.TcpUrgSet
	}
	return false
}

func (m *TCPSelector) GetTcpUrgClear() bool {
	if x, ok := m.GetTcpUrg().(*TCPSelector_TcpUrgClear); ok {
		return x.TcpUrgClear
	}
	return false
}

func (m *TCPSelector) GetSrcPortRange() *L4PortRange {
	if m != nil {
		return m.SrcPortRange
	}
	return nil
}

func (m *TCPSelector) GetDstPortRange() *L4PortRange {
	if m != nil {
		return m.DstPortRange
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*TCPSelector) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _TCPSelector_OneofMarshaler, _TCPSelector_OneofUnmarshaler, _TCPSelector_OneofSizer, []interface{}{
		(*TCPSelector_TcpSynSet)(nil),
		(*TCPSelector_TcpSynClear)(nil),
		(*TCPSelector_TcpAckSet)(nil),
		(*TCPSelector_TcpAckClear)(nil),
		(*TCPSelector_TcpFinSet)(nil),
		(*TCPSelector_TcpFinClear)(nil),
		(*TCPSelector_TcpRstSet)(nil),
		(*TCPSelector_TcpRstClear)(nil),
		(*TCPSelector_TcpUrgSet)(nil),
		(*TCPSelector_TcpUrgClear)(nil),
	}
}

func _TCPSelector_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*TCPSelector)
	// tcp_syn
	switch x := m.TcpSyn.(type) {
	case *TCPSelector_TcpSynSet:
		t := uint64(0)
		if x.TcpSynSet {
			t = 1
		}
		_ = b.EncodeVarint(1<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case *TCPSelector_TcpSynClear:
		t := uint64(0)
		if x.TcpSynClear {
			t = 1
		}
		_ = b.EncodeVarint(2<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case nil:
	default:
		return fmt.Errorf("TCPSelector.TcpSyn has unexpected type %T", x)
	}
	// tcp_ack
	switch x := m.TcpAck.(type) {
	case *TCPSelector_TcpAckSet:
		t := uint64(0)
		if x.TcpAckSet {
			t = 1
		}
		_ = b.EncodeVarint(3<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case *TCPSelector_TcpAckClear:
		t := uint64(0)
		if x.TcpAckClear {
			t = 1
		}
		_ = b.EncodeVarint(4<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case nil:
	default:
		return fmt.Errorf("TCPSelector.TcpAck has unexpected type %T", x)
	}
	// tcp_fin
	switch x := m.TcpFin.(type) {
	case *TCPSelector_TcpFinSet:
		t := uint64(0)
		if x.TcpFinSet {
			t = 1
		}
		_ = b.EncodeVarint(5<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case *TCPSelector_TcpFinClear:
		t := uint64(0)
		if x.TcpFinClear {
			t = 1
		}
		_ = b.EncodeVarint(6<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case nil:
	default:
		return fmt.Errorf("TCPSelector.TcpFin has unexpected type %T", x)
	}
	// tcp_rst
	switch x := m.TcpRst.(type) {
	case *TCPSelector_TcpRstSet:
		t := uint64(0)
		if x.TcpRstSet {
			t = 1
		}
		_ = b.EncodeVarint(7<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case *TCPSelector_TcpRstClear:
		t := uint64(0)
		if x.TcpRstClear {
			t = 1
		}
		_ = b.EncodeVarint(8<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case nil:
	default:
		return fmt.Errorf("TCPSelector.TcpRst has unexpected type %T", x)
	}
	// tcp_urg
	switch x := m.TcpUrg.(type) {
	case *TCPSelector_TcpUrgSet:
		t := uint64(0)
		if x.TcpUrgSet {
			t = 1
		}
		_ = b.EncodeVarint(9<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case *TCPSelector_TcpUrgClear:
		t := uint64(0)
		if x.TcpUrgClear {
			t = 1
		}
		_ = b.EncodeVarint(10<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case nil:
	default:
		return fmt.Errorf("TCPSelector.TcpUrg has unexpected type %T", x)
	}
	return nil
}

func _TCPSelector_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*TCPSelector)
	switch tag {
	case 1: // tcp_syn.tcp_syn_set
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.TcpSyn = &TCPSelector_TcpSynSet{x != 0}
		return true, err
	case 2: // tcp_syn.tcp_syn_clear
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.TcpSyn = &TCPSelector_TcpSynClear{x != 0}
		return true, err
	case 3: // tcp_ack.tcp_ack_set
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.TcpAck = &TCPSelector_TcpAckSet{x != 0}
		return true, err
	case 4: // tcp_ack.tcp_ack_clear
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.TcpAck = &TCPSelector_TcpAckClear{x != 0}
		return true, err
	case 5: // tcp_fin.tcp_fin_set
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.TcpFin = &TCPSelector_TcpFinSet{x != 0}
		return true, err
	case 6: // tcp_fin.tcp_fin_clear
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.TcpFin = &TCPSelector_TcpFinClear{x != 0}
		return true, err
	case 7: // tcp_rst.tcp_rst_set
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.TcpRst = &TCPSelector_TcpRstSet{x != 0}
		return true, err
	case 8: // tcp_rst.tcp_rst_clear
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.TcpRst = &TCPSelector_TcpRstClear{x != 0}
		return true, err
	case 9: // tcp_urg.tcp_urg_set
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.TcpUrg = &TCPSelector_TcpUrgSet{x != 0}
		return true, err
	case 10: // tcp_urg.tcp_urg_clear
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.TcpUrg = &TCPSelector_TcpUrgClear{x != 0}
		return true, err
	default:
		return false, nil
	}
}

func _TCPSelector_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*TCPSelector)
	// tcp_syn
	switch x := m.TcpSyn.(type) {
	case *TCPSelector_TcpSynSet:
		n += proto.SizeVarint(1<<3 | proto.WireVarint)
		n += 1
	case *TCPSelector_TcpSynClear:
		n += proto.SizeVarint(2<<3 | proto.WireVarint)
		n += 1
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// tcp_ack
	switch x := m.TcpAck.(type) {
	case *TCPSelector_TcpAckSet:
		n += proto.SizeVarint(3<<3 | proto.WireVarint)
		n += 1
	case *TCPSelector_TcpAckClear:
		n += proto.SizeVarint(4<<3 | proto.WireVarint)
		n += 1
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// tcp_fin
	switch x := m.TcpFin.(type) {
	case *TCPSelector_TcpFinSet:
		n += proto.SizeVarint(5<<3 | proto.WireVarint)
		n += 1
	case *TCPSelector_TcpFinClear:
		n += proto.SizeVarint(6<<3 | proto.WireVarint)
		n += 1
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// tcp_rst
	switch x := m.TcpRst.(type) {
	case *TCPSelector_TcpRstSet:
		n += proto.SizeVarint(7<<3 | proto.WireVarint)
		n += 1
	case *TCPSelector_TcpRstClear:
		n += proto.SizeVarint(8<<3 | proto.WireVarint)
		n += 1
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// tcp_urg
	switch x := m.TcpUrg.(type) {
	case *TCPSelector_TcpUrgSet:
		n += proto.SizeVarint(9<<3 | proto.WireVarint)
		n += 1
	case *TCPSelector_TcpUrgClear:
		n += proto.SizeVarint(10<<3 | proto.WireVarint)
		n += 1
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// ICMPSelector has match criteria for ICMP packets
type ICMPSelector struct {
	IcmpCode     uint32 `protobuf:"varint,1,opt,name=icmp_code,json=icmpCode,proto3" json:"icmp_code,omitempty"`
	IcmpCodeMask uint32 `protobuf:"varint,2,opt,name=icmp_code_mask,json=icmpCodeMask,proto3" json:"icmp_code_mask,omitempty"`
	IcmpType     uint32 `protobuf:"varint,3,opt,name=icmp_type,json=icmpType,proto3" json:"icmp_type,omitempty"`
	IcmpTypeMask uint32 `protobuf:"varint,4,opt,name=icmp_type_mask,json=icmpTypeMask,proto3" json:"icmp_type_mask,omitempty"`
}

func (m *ICMPSelector) Reset()                    { *m = ICMPSelector{} }
func (m *ICMPSelector) String() string            { return proto.CompactTextString(m) }
func (*ICMPSelector) ProtoMessage()               {}
func (*ICMPSelector) Descriptor() ([]byte, []int) { return fileDescriptorAcl, []int{5} }

func (m *ICMPSelector) GetIcmpCode() uint32 {
	if m != nil {
		return m.IcmpCode
	}
	return 0
}

func (m *ICMPSelector) GetIcmpCodeMask() uint32 {
	if m != nil {
		return m.IcmpCodeMask
	}
	return 0
}

func (m *ICMPSelector) GetIcmpType() uint32 {
	if m != nil {
		return m.IcmpType
	}
	return 0
}

func (m *ICMPSelector) GetIcmpTypeMask() uint32 {
	if m != nil {
		return m.IcmpTypeMask
	}
	return 0
}

// IPSelector has match criteria for selecting IP packets
type IPSelector struct {
	IpAf      IPAddressFamily `protobuf:"varint,1,opt,name=ip_af,json=ipAf,proto3,enum=types.IPAddressFamily" json:"ip_af,omitempty"`
	SrcPrefix *IPPrefix       `protobuf:"bytes,2,opt,name=src_prefix,json=srcPrefix" json:"src_prefix,omitempty"`
	DstPrefix *IPPrefix       `protobuf:"bytes,3,opt,name=dst_prefix,json=dstPrefix" json:"dst_prefix,omitempty"`
	// Types that are valid to be assigned to L4Selectors:
	//	*IPSelector_IpProtocol
	//	*IPSelector_IcmpSelector
	//	*IPSelector_UdpSelector
	//	*IPSelector_TcpSelector
	L4Selectors isIPSelector_L4Selectors `protobuf_oneof:"l4_selectors"`
}

func (m *IPSelector) Reset()                    { *m = IPSelector{} }
func (m *IPSelector) String() string            { return proto.CompactTextString(m) }
func (*IPSelector) ProtoMessage()               {}
func (*IPSelector) Descriptor() ([]byte, []int) { return fileDescriptorAcl, []int{6} }

type isIPSelector_L4Selectors interface {
	isIPSelector_L4Selectors()
	MarshalTo([]byte) (int, error)
	Size() int
}

type IPSelector_IpProtocol struct {
	IpProtocol IPProtocol `protobuf:"varint,4,opt,name=ip_protocol,json=ipProtocol,proto3,enum=types.IPProtocol,oneof"`
}
type IPSelector_IcmpSelector struct {
	IcmpSelector *ICMPSelector `protobuf:"bytes,5,opt,name=icmp_selector,json=icmpSelector,oneof"`
}
type IPSelector_UdpSelector struct {
	UdpSelector *UDPSelector `protobuf:"bytes,6,opt,name=udp_selector,json=udpSelector,oneof"`
}
type IPSelector_TcpSelector struct {
	TcpSelector *TCPSelector `protobuf:"bytes,7,opt,name=tcp_selector,json=tcpSelector,oneof"`
}

func (*IPSelector_IpProtocol) isIPSelector_L4Selectors()   {}
func (*IPSelector_IcmpSelector) isIPSelector_L4Selectors() {}
func (*IPSelector_UdpSelector) isIPSelector_L4Selectors()  {}
func (*IPSelector_TcpSelector) isIPSelector_L4Selectors()  {}

func (m *IPSelector) GetL4Selectors() isIPSelector_L4Selectors {
	if m != nil {
		return m.L4Selectors
	}
	return nil
}

func (m *IPSelector) GetIpAf() IPAddressFamily {
	if m != nil {
		return m.IpAf
	}
	return IPAddressFamily_IP_AF_NONE
}

func (m *IPSelector) GetSrcPrefix() *IPPrefix {
	if m != nil {
		return m.SrcPrefix
	}
	return nil
}

func (m *IPSelector) GetDstPrefix() *IPPrefix {
	if m != nil {
		return m.DstPrefix
	}
	return nil
}

func (m *IPSelector) GetIpProtocol() IPProtocol {
	if x, ok := m.GetL4Selectors().(*IPSelector_IpProtocol); ok {
		return x.IpProtocol
	}
	return IPProtocol_IPPROTO_NONE
}

func (m *IPSelector) GetIcmpSelector() *ICMPSelector {
	if x, ok := m.GetL4Selectors().(*IPSelector_IcmpSelector); ok {
		return x.IcmpSelector
	}
	return nil
}

func (m *IPSelector) GetUdpSelector() *UDPSelector {
	if x, ok := m.GetL4Selectors().(*IPSelector_UdpSelector); ok {
		return x.UdpSelector
	}
	return nil
}

func (m *IPSelector) GetTcpSelector() *TCPSelector {
	if x, ok := m.GetL4Selectors().(*IPSelector_TcpSelector); ok {
		return x.TcpSelector
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*IPSelector) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _IPSelector_OneofMarshaler, _IPSelector_OneofUnmarshaler, _IPSelector_OneofSizer, []interface{}{
		(*IPSelector_IpProtocol)(nil),
		(*IPSelector_IcmpSelector)(nil),
		(*IPSelector_UdpSelector)(nil),
		(*IPSelector_TcpSelector)(nil),
	}
}

func _IPSelector_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*IPSelector)
	// l4_selectors
	switch x := m.L4Selectors.(type) {
	case *IPSelector_IpProtocol:
		_ = b.EncodeVarint(4<<3 | proto.WireVarint)
		_ = b.EncodeVarint(uint64(x.IpProtocol))
	case *IPSelector_IcmpSelector:
		_ = b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.IcmpSelector); err != nil {
			return err
		}
	case *IPSelector_UdpSelector:
		_ = b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.UdpSelector); err != nil {
			return err
		}
	case *IPSelector_TcpSelector:
		_ = b.EncodeVarint(7<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.TcpSelector); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("IPSelector.L4Selectors has unexpected type %T", x)
	}
	return nil
}

func _IPSelector_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*IPSelector)
	switch tag {
	case 4: // l4_selectors.ip_protocol
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.L4Selectors = &IPSelector_IpProtocol{IPProtocol(x)}
		return true, err
	case 5: // l4_selectors.icmp_selector
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ICMPSelector)
		err := b.DecodeMessage(msg)
		m.L4Selectors = &IPSelector_IcmpSelector{msg}
		return true, err
	case 6: // l4_selectors.udp_selector
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(UDPSelector)
		err := b.DecodeMessage(msg)
		m.L4Selectors = &IPSelector_UdpSelector{msg}
		return true, err
	case 7: // l4_selectors.tcp_selector
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TCPSelector)
		err := b.DecodeMessage(msg)
		m.L4Selectors = &IPSelector_TcpSelector{msg}
		return true, err
	default:
		return false, nil
	}
}

func _IPSelector_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*IPSelector)
	// l4_selectors
	switch x := m.L4Selectors.(type) {
	case *IPSelector_IpProtocol:
		n += proto.SizeVarint(4<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.IpProtocol))
	case *IPSelector_IcmpSelector:
		s := proto.Size(x.IcmpSelector)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *IPSelector_UdpSelector:
		s := proto.Size(x.UdpSelector)
		n += proto.SizeVarint(6<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *IPSelector_TcpSelector:
		s := proto.Size(x.TcpSelector)
		n += proto.SizeVarint(7<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// AclInternalSelector has match criteria which are for internal use only with
// DOL/testing infra
// For production builds this needs to be removed
// TODO: REMOVE
type AclInternalSelector struct {
	FlowMiss        bool         `protobuf:"varint,1,opt,name=flow_miss,json=flowMiss,proto3" json:"flow_miss,omitempty"`
	OuterDstMac     uint64       `protobuf:"varint,2,opt,name=outer_dst_mac,json=outerDstMac,proto3" json:"outer_dst_mac,omitempty"`
	IpOptions       bool         `protobuf:"varint,3,opt,name=ip_options,json=ipOptions,proto3" json:"ip_options,omitempty"`
	IpFrag          bool         `protobuf:"varint,4,opt,name=ip_frag,json=ipFrag,proto3" json:"ip_frag,omitempty"`
	DropReason      []DropReason `protobuf:"varint,5,rep,packed,name=drop_reason,json=dropReason,enum=acl.DropReason" json:"drop_reason,omitempty"`
	TunnelTerminate bool         `protobuf:"varint,6,opt,name=tunnel_terminate,json=tunnelTerminate,proto3" json:"tunnel_terminate,omitempty"`
	Direction       bool         `protobuf:"varint,7,opt,name=direction,proto3" json:"direction,omitempty"`
}

func (m *AclInternalSelector) Reset()                    { *m = AclInternalSelector{} }
func (m *AclInternalSelector) String() string            { return proto.CompactTextString(m) }
func (*AclInternalSelector) ProtoMessage()               {}
func (*AclInternalSelector) Descriptor() ([]byte, []int) { return fileDescriptorAcl, []int{7} }

func (m *AclInternalSelector) GetFlowMiss() bool {
	if m != nil {
		return m.FlowMiss
	}
	return false
}

func (m *AclInternalSelector) GetOuterDstMac() uint64 {
	if m != nil {
		return m.OuterDstMac
	}
	return 0
}

func (m *AclInternalSelector) GetIpOptions() bool {
	if m != nil {
		return m.IpOptions
	}
	return false
}

func (m *AclInternalSelector) GetIpFrag() bool {
	if m != nil {
		return m.IpFrag
	}
	return false
}

func (m *AclInternalSelector) GetDropReason() []DropReason {
	if m != nil {
		return m.DropReason
	}
	return nil
}

func (m *AclInternalSelector) GetTunnelTerminate() bool {
	if m != nil {
		return m.TunnelTerminate
	}
	return false
}

func (m *AclInternalSelector) GetDirection() bool {
	if m != nil {
		return m.Direction
	}
	return false
}

// AclInternalActionInfo has action parameters for internal use only with
// DOL/testing infra
// For production builds this needs to be removed
// TODO: REMOVE
type AclInternalActionInfo struct {
	MacSaRewriteEn bool       `protobuf:"varint,1,opt,name=mac_sa_rewrite_en,json=macSaRewriteEn,proto3" json:"mac_sa_rewrite_en,omitempty"`
	MacSa          uint64     `protobuf:"varint,2,opt,name=mac_sa,json=macSa,proto3" json:"mac_sa,omitempty"`
	MacDaRewriteEn bool       `protobuf:"varint,3,opt,name=mac_da_rewrite_en,json=macDaRewriteEn,proto3" json:"mac_da_rewrite_en,omitempty"`
	MacDa          uint64     `protobuf:"varint,4,opt,name=mac_da,json=macDa,proto3" json:"mac_da,omitempty"`
	TtlDecEn       bool       `protobuf:"varint,5,opt,name=ttl_dec_en,json=ttlDecEn,proto3" json:"ttl_dec_en,omitempty"`
	EncapInfo      *EncapInfo `protobuf:"bytes,6,opt,name=encap_info,json=encapInfo" json:"encap_info,omitempty"`
}

func (m *AclInternalActionInfo) Reset()                    { *m = AclInternalActionInfo{} }
func (m *AclInternalActionInfo) String() string            { return proto.CompactTextString(m) }
func (*AclInternalActionInfo) ProtoMessage()               {}
func (*AclInternalActionInfo) Descriptor() ([]byte, []int) { return fileDescriptorAcl, []int{8} }

func (m *AclInternalActionInfo) GetMacSaRewriteEn() bool {
	if m != nil {
		return m.MacSaRewriteEn
	}
	return false
}

func (m *AclInternalActionInfo) GetMacSa() uint64 {
	if m != nil {
		return m.MacSa
	}
	return 0
}

func (m *AclInternalActionInfo) GetMacDaRewriteEn() bool {
	if m != nil {
		return m.MacDaRewriteEn
	}
	return false
}

func (m *AclInternalActionInfo) GetMacDa() uint64 {
	if m != nil {
		return m.MacDa
	}
	return 0
}

func (m *AclInternalActionInfo) GetTtlDecEn() bool {
	if m != nil {
		return m.TtlDecEn
	}
	return false
}

func (m *AclInternalActionInfo) GetEncapInfo() *EncapInfo {
	if m != nil {
		return m.EncapInfo
	}
	return nil
}

// AclSelector has all the match criteria for an ACL entry
type AclSelector struct {
	SrcIfKeyHandle *InterfaceKeyHandle `protobuf:"bytes,1,opt,name=src_if_key_handle,json=srcIfKeyHandle" json:"src_if_key_handle,omitempty"`
	DstIfKeyHandle *InterfaceKeyHandle `protobuf:"bytes,2,opt,name=dst_if_key_handle,json=dstIfKeyHandle" json:"dst_if_key_handle,omitempty"`
	// Types that are valid to be assigned to SegSelector:
	//	*AclSelector_TenantKeyHandle
	//	*AclSelector_L2SegmentKeyHandle
	SegSelector isAclSelector_SegSelector `protobuf_oneof:"seg_selector"`
	// Types that are valid to be assigned to PktSelector:
	//	*AclSelector_EthSelector
	//	*AclSelector_IpSelector
	PktSelector isAclSelector_PktSelector `protobuf_oneof:"pkt_selector"`
	// TODO: REMOVE
	InternalKey  *AclInternalSelector `protobuf:"bytes,7,opt,name=internal_key,json=internalKey" json:"internal_key,omitempty"`
	InternalMask *AclInternalSelector `protobuf:"bytes,8,opt,name=internal_mask,json=internalMask" json:"internal_mask,omitempty"`
}

func (m *AclSelector) Reset()                    { *m = AclSelector{} }
func (m *AclSelector) String() string            { return proto.CompactTextString(m) }
func (*AclSelector) ProtoMessage()               {}
func (*AclSelector) Descriptor() ([]byte, []int) { return fileDescriptorAcl, []int{9} }

type isAclSelector_SegSelector interface {
	isAclSelector_SegSelector()
	MarshalTo([]byte) (int, error)
	Size() int
}
type isAclSelector_PktSelector interface {
	isAclSelector_PktSelector()
	MarshalTo([]byte) (int, error)
	Size() int
}

type AclSelector_TenantKeyHandle struct {
	TenantKeyHandle *TenantKeyHandle `protobuf:"bytes,3,opt,name=tenant_key_handle,json=tenantKeyHandle,oneof"`
}
type AclSelector_L2SegmentKeyHandle struct {
	L2SegmentKeyHandle *L2SegmentKeyHandle `protobuf:"bytes,4,opt,name=l2segment_key_handle,json=l2segmentKeyHandle,oneof"`
}
type AclSelector_EthSelector struct {
	EthSelector *EthSelector `protobuf:"bytes,5,opt,name=eth_selector,json=ethSelector,oneof"`
}
type AclSelector_IpSelector struct {
	IpSelector *IPSelector `protobuf:"bytes,6,opt,name=ip_selector,json=ipSelector,oneof"`
}

func (*AclSelector_TenantKeyHandle) isAclSelector_SegSelector()    {}
func (*AclSelector_L2SegmentKeyHandle) isAclSelector_SegSelector() {}
func (*AclSelector_EthSelector) isAclSelector_PktSelector()        {}
func (*AclSelector_IpSelector) isAclSelector_PktSelector()         {}

func (m *AclSelector) GetSegSelector() isAclSelector_SegSelector {
	if m != nil {
		return m.SegSelector
	}
	return nil
}
func (m *AclSelector) GetPktSelector() isAclSelector_PktSelector {
	if m != nil {
		return m.PktSelector
	}
	return nil
}

func (m *AclSelector) GetSrcIfKeyHandle() *InterfaceKeyHandle {
	if m != nil {
		return m.SrcIfKeyHandle
	}
	return nil
}

func (m *AclSelector) GetDstIfKeyHandle() *InterfaceKeyHandle {
	if m != nil {
		return m.DstIfKeyHandle
	}
	return nil
}

func (m *AclSelector) GetTenantKeyHandle() *TenantKeyHandle {
	if x, ok := m.GetSegSelector().(*AclSelector_TenantKeyHandle); ok {
		return x.TenantKeyHandle
	}
	return nil
}

func (m *AclSelector) GetL2SegmentKeyHandle() *L2SegmentKeyHandle {
	if x, ok := m.GetSegSelector().(*AclSelector_L2SegmentKeyHandle); ok {
		return x.L2SegmentKeyHandle
	}
	return nil
}

func (m *AclSelector) GetEthSelector() *EthSelector {
	if x, ok := m.GetPktSelector().(*AclSelector_EthSelector); ok {
		return x.EthSelector
	}
	return nil
}

func (m *AclSelector) GetIpSelector() *IPSelector {
	if x, ok := m.GetPktSelector().(*AclSelector_IpSelector); ok {
		return x.IpSelector
	}
	return nil
}

func (m *AclSelector) GetInternalKey() *AclInternalSelector {
	if m != nil {
		return m.InternalKey
	}
	return nil
}

func (m *AclSelector) GetInternalMask() *AclInternalSelector {
	if m != nil {
		return m.InternalMask
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*AclSelector) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _AclSelector_OneofMarshaler, _AclSelector_OneofUnmarshaler, _AclSelector_OneofSizer, []interface{}{
		(*AclSelector_TenantKeyHandle)(nil),
		(*AclSelector_L2SegmentKeyHandle)(nil),
		(*AclSelector_EthSelector)(nil),
		(*AclSelector_IpSelector)(nil),
	}
}

func _AclSelector_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*AclSelector)
	// seg_selector
	switch x := m.SegSelector.(type) {
	case *AclSelector_TenantKeyHandle:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.TenantKeyHandle); err != nil {
			return err
		}
	case *AclSelector_L2SegmentKeyHandle:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.L2SegmentKeyHandle); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("AclSelector.SegSelector has unexpected type %T", x)
	}
	// pkt_selector
	switch x := m.PktSelector.(type) {
	case *AclSelector_EthSelector:
		_ = b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.EthSelector); err != nil {
			return err
		}
	case *AclSelector_IpSelector:
		_ = b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.IpSelector); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("AclSelector.PktSelector has unexpected type %T", x)
	}
	return nil
}

func _AclSelector_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*AclSelector)
	switch tag {
	case 3: // seg_selector.tenant_key_handle
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TenantKeyHandle)
		err := b.DecodeMessage(msg)
		m.SegSelector = &AclSelector_TenantKeyHandle{msg}
		return true, err
	case 4: // seg_selector.l2segment_key_handle
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(L2SegmentKeyHandle)
		err := b.DecodeMessage(msg)
		m.SegSelector = &AclSelector_L2SegmentKeyHandle{msg}
		return true, err
	case 5: // pkt_selector.eth_selector
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(EthSelector)
		err := b.DecodeMessage(msg)
		m.PktSelector = &AclSelector_EthSelector{msg}
		return true, err
	case 6: // pkt_selector.ip_selector
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(IPSelector)
		err := b.DecodeMessage(msg)
		m.PktSelector = &AclSelector_IpSelector{msg}
		return true, err
	default:
		return false, nil
	}
}

func _AclSelector_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*AclSelector)
	// seg_selector
	switch x := m.SegSelector.(type) {
	case *AclSelector_TenantKeyHandle:
		s := proto.Size(x.TenantKeyHandle)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *AclSelector_L2SegmentKeyHandle:
		s := proto.Size(x.L2SegmentKeyHandle)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// pkt_selector
	switch x := m.PktSelector.(type) {
	case *AclSelector_EthSelector:
		s := proto.Size(x.EthSelector)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *AclSelector_IpSelector:
		s := proto.Size(x.IpSelector)
		n += proto.SizeVarint(6<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type AclActionInfo struct {
	Action              AclAction           `protobuf:"varint,1,opt,name=action,proto3,enum=acl.AclAction" json:"action,omitempty"`
	IngMirrorSessions   []*MirrorSessionId  `protobuf:"bytes,2,rep,name=ing_mirror_sessions,json=ingMirrorSessions" json:"ing_mirror_sessions,omitempty"`
	EgrMirrorSessions   []*MirrorSessionId  `protobuf:"bytes,3,rep,name=egr_mirror_sessions,json=egrMirrorSessions" json:"egr_mirror_sessions,omitempty"`
	CoppPolicerHandle   uint64              `protobuf:"fixed64,4,opt,name=copp_policer_handle,json=coppPolicerHandle,proto3" json:"copp_policer_handle,omitempty"`
	RedirectIfKeyHandle *InterfaceKeyHandle `protobuf:"bytes,5,opt,name=redirect_if_key_handle,json=redirectIfKeyHandle" json:"redirect_if_key_handle,omitempty"`
	// TODO: REMOVE
	InternalActions *AclInternalActionInfo `protobuf:"bytes,6,opt,name=internal_actions,json=internalActions" json:"internal_actions,omitempty"`
}

func (m *AclActionInfo) Reset()                    { *m = AclActionInfo{} }
func (m *AclActionInfo) String() string            { return proto.CompactTextString(m) }
func (*AclActionInfo) ProtoMessage()               {}
func (*AclActionInfo) Descriptor() ([]byte, []int) { return fileDescriptorAcl, []int{10} }

func (m *AclActionInfo) GetAction() AclAction {
	if m != nil {
		return m.Action
	}
	return AclAction_ACL_ACTION_NONE
}

func (m *AclActionInfo) GetIngMirrorSessions() []*MirrorSessionId {
	if m != nil {
		return m.IngMirrorSessions
	}
	return nil
}

func (m *AclActionInfo) GetEgrMirrorSessions() []*MirrorSessionId {
	if m != nil {
		return m.EgrMirrorSessions
	}
	return nil
}

func (m *AclActionInfo) GetCoppPolicerHandle() uint64 {
	if m != nil {
		return m.CoppPolicerHandle
	}
	return 0
}

func (m *AclActionInfo) GetRedirectIfKeyHandle() *InterfaceKeyHandle {
	if m != nil {
		return m.RedirectIfKeyHandle
	}
	return nil
}

func (m *AclActionInfo) GetInternalActions() *AclInternalActionInfo {
	if m != nil {
		return m.InternalActions
	}
	return nil
}

// ACL entry configuration
type AclSpec struct {
	Meta *ObjectMeta `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	// key_or_handle is ACL's key or handle
	KeyOrHandle *AclKeyHandle `protobuf:"bytes,2,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty" venice:"key"`
	Priority    uint32        `protobuf:"varint,3,opt,name=priority,proto3" json:"priority,omitempty"`
	// TBD: is this per-tenant priority ? or global ?
	Match  *AclSelector   `protobuf:"bytes,4,opt,name=match" json:"match,omitempty"`
	Action *AclActionInfo `protobuf:"bytes,5,opt,name=action" json:"action,omitempty"`
}

func (m *AclSpec) Reset()                    { *m = AclSpec{} }
func (m *AclSpec) String() string            { return proto.CompactTextString(m) }
func (*AclSpec) ProtoMessage()               {}
func (*AclSpec) Descriptor() ([]byte, []int) { return fileDescriptorAcl, []int{11} }

func (m *AclSpec) GetMeta() *ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *AclSpec) GetKeyOrHandle() *AclKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

func (m *AclSpec) GetPriority() uint32 {
	if m != nil {
		return m.Priority
	}
	return 0
}

func (m *AclSpec) GetMatch() *AclSelector {
	if m != nil {
		return m.Match
	}
	return nil
}

func (m *AclSpec) GetAction() *AclActionInfo {
	if m != nil {
		return m.Action
	}
	return nil
}

// Batched requests to create/update acls
type AclRequestMsg struct {
	Request []*AclSpec `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *AclRequestMsg) Reset()                    { *m = AclRequestMsg{} }
func (m *AclRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*AclRequestMsg) ProtoMessage()               {}
func (*AclRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptorAcl, []int{12} }

func (m *AclRequestMsg) GetRequest() []*AclSpec {
	if m != nil {
		return m.Request
	}
	return nil
}

// AclStatus represents the operational status of an ACL entry
type AclStatus struct {
	AclHandle *AclHandle `protobuf:"bytes,1,opt,name=acl_handle,json=aclHandle" json:"acl_handle,omitempty"`
}

func (m *AclStatus) Reset()                    { *m = AclStatus{} }
func (m *AclStatus) String() string            { return proto.CompactTextString(m) }
func (*AclStatus) ProtoMessage()               {}
func (*AclStatus) Descriptor() ([]byte, []int) { return fileDescriptorAcl, []int{13} }

func (m *AclStatus) GetAclHandle() *AclHandle {
	if m != nil {
		return m.AclHandle
	}
	return nil
}

// AclResponse is response to one Acl
type AclResponse struct {
	ApiStatus ApiStatus  `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty"`
	Status    *AclStatus `protobuf:"bytes,2,opt,name=status" json:"status,omitempty"`
}

func (m *AclResponse) Reset()                    { *m = AclResponse{} }
func (m *AclResponse) String() string            { return proto.CompactTextString(m) }
func (*AclResponse) ProtoMessage()               {}
func (*AclResponse) Descriptor() ([]byte, []int) { return fileDescriptorAcl, []int{14} }

func (m *AclResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *AclResponse) GetStatus() *AclStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

// Batched responses to create/update acls
type AclResponseMsg struct {
	Response []*AclResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *AclResponseMsg) Reset()                    { *m = AclResponseMsg{} }
func (m *AclResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*AclResponseMsg) ProtoMessage()               {}
func (*AclResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptorAcl, []int{15} }

func (m *AclResponseMsg) GetResponse() []*AclResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

type AclDeleteRequest struct {
	Meta *ObjectMeta `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	// key_or_handle is unique identifier of ACL being deleted
	KeyOrHandle *AclKeyHandle `protobuf:"bytes,2,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty" venice:"key"`
}

func (m *AclDeleteRequest) Reset()                    { *m = AclDeleteRequest{} }
func (m *AclDeleteRequest) String() string            { return proto.CompactTextString(m) }
func (*AclDeleteRequest) ProtoMessage()               {}
func (*AclDeleteRequest) Descriptor() ([]byte, []int) { return fileDescriptorAcl, []int{16} }

func (m *AclDeleteRequest) GetMeta() *ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *AclDeleteRequest) GetKeyOrHandle() *AclKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

// Batched requests to delete acls
type AclDeleteRequestMsg struct {
	Request []*AclDeleteRequest `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *AclDeleteRequestMsg) Reset()                    { *m = AclDeleteRequestMsg{} }
func (m *AclDeleteRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*AclDeleteRequestMsg) ProtoMessage()               {}
func (*AclDeleteRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptorAcl, []int{17} }

func (m *AclDeleteRequestMsg) GetRequest() []*AclDeleteRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

// AclDeleteResponse is response to Acl delete request
type AclDeleteResponse struct {
	ApiStatus ApiStatus `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty"`
}

func (m *AclDeleteResponse) Reset()                    { *m = AclDeleteResponse{} }
func (m *AclDeleteResponse) String() string            { return proto.CompactTextString(m) }
func (*AclDeleteResponse) ProtoMessage()               {}
func (*AclDeleteResponse) Descriptor() ([]byte, []int) { return fileDescriptorAcl, []int{18} }

func (m *AclDeleteResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

// AclDeleteResponseMsg is batched response to AclDeleteRequestMsg
type AclDeleteResponseMsg struct {
	Response []*AclDeleteResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *AclDeleteResponseMsg) Reset()                    { *m = AclDeleteResponseMsg{} }
func (m *AclDeleteResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*AclDeleteResponseMsg) ProtoMessage()               {}
func (*AclDeleteResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptorAcl, []int{19} }

func (m *AclDeleteResponseMsg) GetResponse() []*AclDeleteResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

// AclGetRequest is used to get information about a acl
type AclGetRequest struct {
	Meta *ObjectMeta `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	// key_or_handle is ACL's identifier for retrieval
	KeyOrHandle *AclKeyHandle `protobuf:"bytes,2,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty" venice:"key"`
}

func (m *AclGetRequest) Reset()                    { *m = AclGetRequest{} }
func (m *AclGetRequest) String() string            { return proto.CompactTextString(m) }
func (*AclGetRequest) ProtoMessage()               {}
func (*AclGetRequest) Descriptor() ([]byte, []int) { return fileDescriptorAcl, []int{20} }

func (m *AclGetRequest) GetMeta() *ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *AclGetRequest) GetKeyOrHandle() *AclKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

type AclGetRequestMsg struct {
	Request []*AclGetRequest `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *AclGetRequestMsg) Reset()                    { *m = AclGetRequestMsg{} }
func (m *AclGetRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*AclGetRequestMsg) ProtoMessage()               {}
func (*AclGetRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptorAcl, []int{21} }

func (m *AclGetRequestMsg) GetRequest() []*AclGetRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

// AclStats captures all the statistics of a acl
type AclStats struct {
}

func (m *AclStats) Reset()                    { *m = AclStats{} }
func (m *AclStats) String() string            { return proto.CompactTextString(m) }
func (*AclStats) ProtoMessage()               {}
func (*AclStats) Descriptor() ([]byte, []int) { return fileDescriptorAcl, []int{22} }

// AclGetResponse captures all the information about a acl
type AclGetResponse struct {
	Spec   *AclSpec   `protobuf:"bytes,1,opt,name=spec" json:"spec,omitempty"`
	Status *AclStatus `protobuf:"bytes,2,opt,name=status" json:"status,omitempty"`
	Stats  *AclStats  `protobuf:"bytes,3,opt,name=stats" json:"stats,omitempty"`
}

func (m *AclGetResponse) Reset()                    { *m = AclGetResponse{} }
func (m *AclGetResponse) String() string            { return proto.CompactTextString(m) }
func (*AclGetResponse) ProtoMessage()               {}
func (*AclGetResponse) Descriptor() ([]byte, []int) { return fileDescriptorAcl, []int{23} }

func (m *AclGetResponse) GetSpec() *AclSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *AclGetResponse) GetStatus() *AclStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *AclGetResponse) GetStats() *AclStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

// AclGetResponseMsg is response to AclGetRequestMsg
type AclGetResponseMsg struct {
	Response []*AclGetResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *AclGetResponseMsg) Reset()                    { *m = AclGetResponseMsg{} }
func (m *AclGetResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*AclGetResponseMsg) ProtoMessage()               {}
func (*AclGetResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptorAcl, []int{24} }

func (m *AclGetResponseMsg) GetResponse() []*AclGetResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

func init() {
	proto.RegisterType((*AclHandle)(nil), "acl.AclHandle")
	proto.RegisterType((*AclKeyHandle)(nil), "acl.AclKeyHandle")
	proto.RegisterType((*EthSelector)(nil), "acl.EthSelector")
	proto.RegisterType((*UDPSelector)(nil), "acl.UDPSelector")
	proto.RegisterType((*TCPSelector)(nil), "acl.TCPSelector")
	proto.RegisterType((*ICMPSelector)(nil), "acl.ICMPSelector")
	proto.RegisterType((*IPSelector)(nil), "acl.IPSelector")
	proto.RegisterType((*AclInternalSelector)(nil), "acl.AclInternalSelector")
	proto.RegisterType((*AclInternalActionInfo)(nil), "acl.AclInternalActionInfo")
	proto.RegisterType((*AclSelector)(nil), "acl.AclSelector")
	proto.RegisterType((*AclActionInfo)(nil), "acl.AclActionInfo")
	proto.RegisterType((*AclSpec)(nil), "acl.AclSpec")
	proto.RegisterType((*AclRequestMsg)(nil), "acl.AclRequestMsg")
	proto.RegisterType((*AclStatus)(nil), "acl.AclStatus")
	proto.RegisterType((*AclResponse)(nil), "acl.AclResponse")
	proto.RegisterType((*AclResponseMsg)(nil), "acl.AclResponseMsg")
	proto.RegisterType((*AclDeleteRequest)(nil), "acl.AclDeleteRequest")
	proto.RegisterType((*AclDeleteRequestMsg)(nil), "acl.AclDeleteRequestMsg")
	proto.RegisterType((*AclDeleteResponse)(nil), "acl.AclDeleteResponse")
	proto.RegisterType((*AclDeleteResponseMsg)(nil), "acl.AclDeleteResponseMsg")
	proto.RegisterType((*AclGetRequest)(nil), "acl.AclGetRequest")
	proto.RegisterType((*AclGetRequestMsg)(nil), "acl.AclGetRequestMsg")
	proto.RegisterType((*AclStats)(nil), "acl.AclStats")
	proto.RegisterType((*AclGetResponse)(nil), "acl.AclGetResponse")
	proto.RegisterType((*AclGetResponseMsg)(nil), "acl.AclGetResponseMsg")
	proto.RegisterEnum("acl.DropReason", DropReason_name, DropReason_value)
	proto.RegisterEnum("acl.AclAction", AclAction_name, AclAction_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Acl service

type AclClient interface {
	// Acl related APIs
	AclCreate(ctx context.Context, in *AclRequestMsg, opts ...grpc.CallOption) (*AclResponseMsg, error)
	AclUpdate(ctx context.Context, in *AclRequestMsg, opts ...grpc.CallOption) (*AclResponseMsg, error)
	AclDelete(ctx context.Context, in *AclDeleteRequestMsg, opts ...grpc.CallOption) (*AclDeleteResponseMsg, error)
	AclGet(ctx context.Context, in *AclGetRequestMsg, opts ...grpc.CallOption) (*AclGetResponseMsg, error)
}

type aclClient struct {
	cc *grpc.ClientConn
}

func NewAclClient(cc *grpc.ClientConn) AclClient {
	return &aclClient{cc}
}

func (c *aclClient) AclCreate(ctx context.Context, in *AclRequestMsg, opts ...grpc.CallOption) (*AclResponseMsg, error) {
	out := new(AclResponseMsg)
	err := grpc.Invoke(ctx, "/acl.Acl/AclCreate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aclClient) AclUpdate(ctx context.Context, in *AclRequestMsg, opts ...grpc.CallOption) (*AclResponseMsg, error) {
	out := new(AclResponseMsg)
	err := grpc.Invoke(ctx, "/acl.Acl/AclUpdate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aclClient) AclDelete(ctx context.Context, in *AclDeleteRequestMsg, opts ...grpc.CallOption) (*AclDeleteResponseMsg, error) {
	out := new(AclDeleteResponseMsg)
	err := grpc.Invoke(ctx, "/acl.Acl/AclDelete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aclClient) AclGet(ctx context.Context, in *AclGetRequestMsg, opts ...grpc.CallOption) (*AclGetResponseMsg, error) {
	out := new(AclGetResponseMsg)
	err := grpc.Invoke(ctx, "/acl.Acl/AclGet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Acl service

type AclServer interface {
	// Acl related APIs
	AclCreate(context.Context, *AclRequestMsg) (*AclResponseMsg, error)
	AclUpdate(context.Context, *AclRequestMsg) (*AclResponseMsg, error)
	AclDelete(context.Context, *AclDeleteRequestMsg) (*AclDeleteResponseMsg, error)
	AclGet(context.Context, *AclGetRequestMsg) (*AclGetResponseMsg, error)
}

func RegisterAclServer(s *grpc.Server, srv AclServer) {
	s.RegisterService(&_Acl_serviceDesc, srv)
}

func _Acl_AclCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AclRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AclServer).AclCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/acl.Acl/AclCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AclServer).AclCreate(ctx, req.(*AclRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Acl_AclUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AclRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AclServer).AclUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/acl.Acl/AclUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AclServer).AclUpdate(ctx, req.(*AclRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Acl_AclDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AclDeleteRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AclServer).AclDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/acl.Acl/AclDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AclServer).AclDelete(ctx, req.(*AclDeleteRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Acl_AclGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AclGetRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AclServer).AclGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/acl.Acl/AclGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AclServer).AclGet(ctx, req.(*AclGetRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

var _Acl_serviceDesc = grpc.ServiceDesc{
	ServiceName: "acl.Acl",
	HandlerType: (*AclServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AclCreate",
			Handler:    _Acl_AclCreate_Handler,
		},
		{
			MethodName: "AclUpdate",
			Handler:    _Acl_AclUpdate_Handler,
		},
		{
			MethodName: "AclDelete",
			Handler:    _Acl_AclDelete_Handler,
		},
		{
			MethodName: "AclGet",
			Handler:    _Acl_AclGet_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "nic/proto/hal/acl.proto",
}

func (m *AclHandle) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AclHandle) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Handle != 0 {
		dAtA[i] = 0x9
		i++
		i = encodeFixed64Acl(dAtA, i, uint64(m.Handle))
	}
	return i, nil
}

func (m *AclKeyHandle) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AclKeyHandle) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.KeyOrHandle != nil {
		nn1, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn1
	}
	return i, nil
}

func (m *AclKeyHandle_AclId) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0xd
	i++
	i = encodeFixed32Acl(dAtA, i, uint32(m.AclId))
	return i, nil
}
func (m *AclKeyHandle_AclHandle) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.AclHandle != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAcl(dAtA, i, uint64(m.AclHandle.Size()))
		n2, err := m.AclHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}
func (m *EthSelector) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EthSelector) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.EthType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAcl(dAtA, i, uint64(m.EthType))
	}
	if m.EthTypeMask != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAcl(dAtA, i, uint64(m.EthTypeMask))
	}
	if m.SrcMac != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAcl(dAtA, i, uint64(m.SrcMac))
	}
	if m.SrcMacMask != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintAcl(dAtA, i, uint64(m.SrcMacMask))
	}
	if m.DstMac != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintAcl(dAtA, i, uint64(m.DstMac))
	}
	if m.DstMacMask != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintAcl(dAtA, i, uint64(m.DstMacMask))
	}
	return i, nil
}

func (m *UDPSelector) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UDPSelector) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SrcPortRange != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAcl(dAtA, i, uint64(m.SrcPortRange.Size()))
		n3, err := m.SrcPortRange.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.DstPortRange != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAcl(dAtA, i, uint64(m.DstPortRange.Size()))
		n4, err := m.DstPortRange.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	return i, nil
}

func (m *TCPSelector) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TCPSelector) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TcpSyn != nil {
		nn5, err := m.TcpSyn.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn5
	}
	if m.TcpAck != nil {
		nn6, err := m.TcpAck.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn6
	}
	if m.TcpFin != nil {
		nn7, err := m.TcpFin.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn7
	}
	if m.TcpRst != nil {
		nn8, err := m.TcpRst.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn8
	}
	if m.TcpUrg != nil {
		nn9, err := m.TcpUrg.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn9
	}
	if m.SrcPortRange != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintAcl(dAtA, i, uint64(m.SrcPortRange.Size()))
		n10, err := m.SrcPortRange.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.DstPortRange != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintAcl(dAtA, i, uint64(m.DstPortRange.Size()))
		n11, err := m.DstPortRange.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	return i, nil
}

func (m *TCPSelector_TcpSynSet) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x8
	i++
	if m.TcpSynSet {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	return i, nil
}
func (m *TCPSelector_TcpSynClear) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x10
	i++
	if m.TcpSynClear {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	return i, nil
}
func (m *TCPSelector_TcpAckSet) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x18
	i++
	if m.TcpAckSet {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	return i, nil
}
func (m *TCPSelector_TcpAckClear) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x20
	i++
	if m.TcpAckClear {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	return i, nil
}
func (m *TCPSelector_TcpFinSet) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x28
	i++
	if m.TcpFinSet {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	return i, nil
}
func (m *TCPSelector_TcpFinClear) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x30
	i++
	if m.TcpFinClear {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	return i, nil
}
func (m *TCPSelector_TcpRstSet) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x38
	i++
	if m.TcpRstSet {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	return i, nil
}
func (m *TCPSelector_TcpRstClear) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x40
	i++
	if m.TcpRstClear {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	return i, nil
}
func (m *TCPSelector_TcpUrgSet) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x48
	i++
	if m.TcpUrgSet {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	return i, nil
}
func (m *TCPSelector_TcpUrgClear) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x50
	i++
	if m.TcpUrgClear {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	return i, nil
}
func (m *ICMPSelector) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ICMPSelector) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.IcmpCode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAcl(dAtA, i, uint64(m.IcmpCode))
	}
	if m.IcmpCodeMask != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAcl(dAtA, i, uint64(m.IcmpCodeMask))
	}
	if m.IcmpType != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAcl(dAtA, i, uint64(m.IcmpType))
	}
	if m.IcmpTypeMask != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintAcl(dAtA, i, uint64(m.IcmpTypeMask))
	}
	return i, nil
}

func (m *IPSelector) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IPSelector) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.IpAf != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAcl(dAtA, i, uint64(m.IpAf))
	}
	if m.SrcPrefix != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAcl(dAtA, i, uint64(m.SrcPrefix.Size()))
		n12, err := m.SrcPrefix.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if m.DstPrefix != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAcl(dAtA, i, uint64(m.DstPrefix.Size()))
		n13, err := m.DstPrefix.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if m.L4Selectors != nil {
		nn14, err := m.L4Selectors.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn14
	}
	return i, nil
}

func (m *IPSelector_IpProtocol) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x20
	i++
	i = encodeVarintAcl(dAtA, i, uint64(m.IpProtocol))
	return i, nil
}
func (m *IPSelector_IcmpSelector) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.IcmpSelector != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintAcl(dAtA, i, uint64(m.IcmpSelector.Size()))
		n15, err := m.IcmpSelector.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	return i, nil
}
func (m *IPSelector_UdpSelector) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.UdpSelector != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintAcl(dAtA, i, uint64(m.UdpSelector.Size()))
		n16, err := m.UdpSelector.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	return i, nil
}
func (m *IPSelector_TcpSelector) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.TcpSelector != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintAcl(dAtA, i, uint64(m.TcpSelector.Size()))
		n17, err := m.TcpSelector.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	return i, nil
}
func (m *AclInternalSelector) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AclInternalSelector) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.FlowMiss {
		dAtA[i] = 0x8
		i++
		if m.FlowMiss {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.OuterDstMac != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAcl(dAtA, i, uint64(m.OuterDstMac))
	}
	if m.IpOptions {
		dAtA[i] = 0x18
		i++
		if m.IpOptions {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IpFrag {
		dAtA[i] = 0x20
		i++
		if m.IpFrag {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.DropReason) > 0 {
		dAtA19 := make([]byte, len(m.DropReason)*10)
		var j18 int
		for _, num := range m.DropReason {
			for num >= 1<<7 {
				dAtA19[j18] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j18++
			}
			dAtA19[j18] = uint8(num)
			j18++
		}
		dAtA[i] = 0x2a
		i++
		i = encodeVarintAcl(dAtA, i, uint64(j18))
		i += copy(dAtA[i:], dAtA19[:j18])
	}
	if m.TunnelTerminate {
		dAtA[i] = 0x30
		i++
		if m.TunnelTerminate {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Direction {
		dAtA[i] = 0x38
		i++
		if m.Direction {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *AclInternalActionInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AclInternalActionInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MacSaRewriteEn {
		dAtA[i] = 0x8
		i++
		if m.MacSaRewriteEn {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.MacSa != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAcl(dAtA, i, uint64(m.MacSa))
	}
	if m.MacDaRewriteEn {
		dAtA[i] = 0x18
		i++
		if m.MacDaRewriteEn {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.MacDa != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintAcl(dAtA, i, uint64(m.MacDa))
	}
	if m.TtlDecEn {
		dAtA[i] = 0x28
		i++
		if m.TtlDecEn {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.EncapInfo != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintAcl(dAtA, i, uint64(m.EncapInfo.Size()))
		n20, err := m.EncapInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	return i, nil
}

func (m *AclSelector) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AclSelector) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SrcIfKeyHandle != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAcl(dAtA, i, uint64(m.SrcIfKeyHandle.Size()))
		n21, err := m.SrcIfKeyHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	if m.DstIfKeyHandle != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAcl(dAtA, i, uint64(m.DstIfKeyHandle.Size()))
		n22, err := m.DstIfKeyHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	if m.SegSelector != nil {
		nn23, err := m.SegSelector.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn23
	}
	if m.PktSelector != nil {
		nn24, err := m.PktSelector.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn24
	}
	if m.InternalKey != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintAcl(dAtA, i, uint64(m.InternalKey.Size()))
		n25, err := m.InternalKey.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	if m.InternalMask != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintAcl(dAtA, i, uint64(m.InternalMask.Size()))
		n26, err := m.InternalMask.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n26
	}
	return i, nil
}

func (m *AclSelector_TenantKeyHandle) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.TenantKeyHandle != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAcl(dAtA, i, uint64(m.TenantKeyHandle.Size()))
		n27, err := m.TenantKeyHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n27
	}
	return i, nil
}
func (m *AclSelector_L2SegmentKeyHandle) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.L2SegmentKeyHandle != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAcl(dAtA, i, uint64(m.L2SegmentKeyHandle.Size()))
		n28, err := m.L2SegmentKeyHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n28
	}
	return i, nil
}
func (m *AclSelector_EthSelector) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.EthSelector != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintAcl(dAtA, i, uint64(m.EthSelector.Size()))
		n29, err := m.EthSelector.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n29
	}
	return i, nil
}
func (m *AclSelector_IpSelector) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.IpSelector != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintAcl(dAtA, i, uint64(m.IpSelector.Size()))
		n30, err := m.IpSelector.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n30
	}
	return i, nil
}
func (m *AclActionInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AclActionInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Action != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAcl(dAtA, i, uint64(m.Action))
	}
	if len(m.IngMirrorSessions) > 0 {
		for _, msg := range m.IngMirrorSessions {
			dAtA[i] = 0x12
			i++
			i = encodeVarintAcl(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.EgrMirrorSessions) > 0 {
		for _, msg := range m.EgrMirrorSessions {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintAcl(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.CoppPolicerHandle != 0 {
		dAtA[i] = 0x21
		i++
		i = encodeFixed64Acl(dAtA, i, uint64(m.CoppPolicerHandle))
	}
	if m.RedirectIfKeyHandle != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintAcl(dAtA, i, uint64(m.RedirectIfKeyHandle.Size()))
		n31, err := m.RedirectIfKeyHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n31
	}
	if m.InternalActions != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintAcl(dAtA, i, uint64(m.InternalActions.Size()))
		n32, err := m.InternalActions.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n32
	}
	return i, nil
}

func (m *AclSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AclSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAcl(dAtA, i, uint64(m.Meta.Size()))
		n33, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n33
	}
	if m.KeyOrHandle != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAcl(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n34, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n34
	}
	if m.Priority != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAcl(dAtA, i, uint64(m.Priority))
	}
	if m.Match != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAcl(dAtA, i, uint64(m.Match.Size()))
		n35, err := m.Match.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n35
	}
	if m.Action != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintAcl(dAtA, i, uint64(m.Action.Size()))
		n36, err := m.Action.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n36
	}
	return i, nil
}

func (m *AclRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AclRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintAcl(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *AclStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AclStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.AclHandle != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAcl(dAtA, i, uint64(m.AclHandle.Size()))
		n37, err := m.AclHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n37
	}
	return i, nil
}

func (m *AclResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AclResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAcl(dAtA, i, uint64(m.ApiStatus))
	}
	if m.Status != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAcl(dAtA, i, uint64(m.Status.Size()))
		n38, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n38
	}
	return i, nil
}

func (m *AclResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AclResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintAcl(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *AclDeleteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AclDeleteRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAcl(dAtA, i, uint64(m.Meta.Size()))
		n39, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n39
	}
	if m.KeyOrHandle != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAcl(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n40, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n40
	}
	return i, nil
}

func (m *AclDeleteRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AclDeleteRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintAcl(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *AclDeleteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AclDeleteResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAcl(dAtA, i, uint64(m.ApiStatus))
	}
	return i, nil
}

func (m *AclDeleteResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AclDeleteResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintAcl(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *AclGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AclGetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAcl(dAtA, i, uint64(m.Meta.Size()))
		n41, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n41
	}
	if m.KeyOrHandle != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAcl(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n42, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n42
	}
	return i, nil
}

func (m *AclGetRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AclGetRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintAcl(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *AclStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AclStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *AclGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AclGetResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Spec != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAcl(dAtA, i, uint64(m.Spec.Size()))
		n43, err := m.Spec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n43
	}
	if m.Status != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAcl(dAtA, i, uint64(m.Status.Size()))
		n44, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n44
	}
	if m.Stats != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAcl(dAtA, i, uint64(m.Stats.Size()))
		n45, err := m.Stats.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n45
	}
	return i, nil
}

func (m *AclGetResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AclGetResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintAcl(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func encodeFixed64Acl(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Acl(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintAcl(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *AclHandle) Size() (n int) {
	var l int
	_ = l
	if m.Handle != 0 {
		n += 9
	}
	return n
}

func (m *AclKeyHandle) Size() (n int) {
	var l int
	_ = l
	if m.KeyOrHandle != nil {
		n += m.KeyOrHandle.Size()
	}
	return n
}

func (m *AclKeyHandle_AclId) Size() (n int) {
	var l int
	_ = l
	n += 5
	return n
}
func (m *AclKeyHandle_AclHandle) Size() (n int) {
	var l int
	_ = l
	if m.AclHandle != nil {
		l = m.AclHandle.Size()
		n += 1 + l + sovAcl(uint64(l))
	}
	return n
}
func (m *EthSelector) Size() (n int) {
	var l int
	_ = l
	if m.EthType != 0 {
		n += 1 + sovAcl(uint64(m.EthType))
	}
	if m.EthTypeMask != 0 {
		n += 1 + sovAcl(uint64(m.EthTypeMask))
	}
	if m.SrcMac != 0 {
		n += 1 + sovAcl(uint64(m.SrcMac))
	}
	if m.SrcMacMask != 0 {
		n += 1 + sovAcl(uint64(m.SrcMacMask))
	}
	if m.DstMac != 0 {
		n += 1 + sovAcl(uint64(m.DstMac))
	}
	if m.DstMacMask != 0 {
		n += 1 + sovAcl(uint64(m.DstMacMask))
	}
	return n
}

func (m *UDPSelector) Size() (n int) {
	var l int
	_ = l
	if m.SrcPortRange != nil {
		l = m.SrcPortRange.Size()
		n += 1 + l + sovAcl(uint64(l))
	}
	if m.DstPortRange != nil {
		l = m.DstPortRange.Size()
		n += 1 + l + sovAcl(uint64(l))
	}
	return n
}

func (m *TCPSelector) Size() (n int) {
	var l int
	_ = l
	if m.TcpSyn != nil {
		n += m.TcpSyn.Size()
	}
	if m.TcpAck != nil {
		n += m.TcpAck.Size()
	}
	if m.TcpFin != nil {
		n += m.TcpFin.Size()
	}
	if m.TcpRst != nil {
		n += m.TcpRst.Size()
	}
	if m.TcpUrg != nil {
		n += m.TcpUrg.Size()
	}
	if m.SrcPortRange != nil {
		l = m.SrcPortRange.Size()
		n += 1 + l + sovAcl(uint64(l))
	}
	if m.DstPortRange != nil {
		l = m.DstPortRange.Size()
		n += 1 + l + sovAcl(uint64(l))
	}
	return n
}

func (m *TCPSelector_TcpSynSet) Size() (n int) {
	var l int
	_ = l
	n += 2
	return n
}
func (m *TCPSelector_TcpSynClear) Size() (n int) {
	var l int
	_ = l
	n += 2
	return n
}
func (m *TCPSelector_TcpAckSet) Size() (n int) {
	var l int
	_ = l
	n += 2
	return n
}
func (m *TCPSelector_TcpAckClear) Size() (n int) {
	var l int
	_ = l
	n += 2
	return n
}
func (m *TCPSelector_TcpFinSet) Size() (n int) {
	var l int
	_ = l
	n += 2
	return n
}
func (m *TCPSelector_TcpFinClear) Size() (n int) {
	var l int
	_ = l
	n += 2
	return n
}
func (m *TCPSelector_TcpRstSet) Size() (n int) {
	var l int
	_ = l
	n += 2
	return n
}
func (m *TCPSelector_TcpRstClear) Size() (n int) {
	var l int
	_ = l
	n += 2
	return n
}
func (m *TCPSelector_TcpUrgSet) Size() (n int) {
	var l int
	_ = l
	n += 2
	return n
}
func (m *TCPSelector_TcpUrgClear) Size() (n int) {
	var l int
	_ = l
	n += 2
	return n
}
func (m *ICMPSelector) Size() (n int) {
	var l int
	_ = l
	if m.IcmpCode != 0 {
		n += 1 + sovAcl(uint64(m.IcmpCode))
	}
	if m.IcmpCodeMask != 0 {
		n += 1 + sovAcl(uint64(m.IcmpCodeMask))
	}
	if m.IcmpType != 0 {
		n += 1 + sovAcl(uint64(m.IcmpType))
	}
	if m.IcmpTypeMask != 0 {
		n += 1 + sovAcl(uint64(m.IcmpTypeMask))
	}
	return n
}

func (m *IPSelector) Size() (n int) {
	var l int
	_ = l
	if m.IpAf != 0 {
		n += 1 + sovAcl(uint64(m.IpAf))
	}
	if m.SrcPrefix != nil {
		l = m.SrcPrefix.Size()
		n += 1 + l + sovAcl(uint64(l))
	}
	if m.DstPrefix != nil {
		l = m.DstPrefix.Size()
		n += 1 + l + sovAcl(uint64(l))
	}
	if m.L4Selectors != nil {
		n += m.L4Selectors.Size()
	}
	return n
}

func (m *IPSelector_IpProtocol) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovAcl(uint64(m.IpProtocol))
	return n
}
func (m *IPSelector_IcmpSelector) Size() (n int) {
	var l int
	_ = l
	if m.IcmpSelector != nil {
		l = m.IcmpSelector.Size()
		n += 1 + l + sovAcl(uint64(l))
	}
	return n
}
func (m *IPSelector_UdpSelector) Size() (n int) {
	var l int
	_ = l
	if m.UdpSelector != nil {
		l = m.UdpSelector.Size()
		n += 1 + l + sovAcl(uint64(l))
	}
	return n
}
func (m *IPSelector_TcpSelector) Size() (n int) {
	var l int
	_ = l
	if m.TcpSelector != nil {
		l = m.TcpSelector.Size()
		n += 1 + l + sovAcl(uint64(l))
	}
	return n
}
func (m *AclInternalSelector) Size() (n int) {
	var l int
	_ = l
	if m.FlowMiss {
		n += 2
	}
	if m.OuterDstMac != 0 {
		n += 1 + sovAcl(uint64(m.OuterDstMac))
	}
	if m.IpOptions {
		n += 2
	}
	if m.IpFrag {
		n += 2
	}
	if len(m.DropReason) > 0 {
		l = 0
		for _, e := range m.DropReason {
			l += sovAcl(uint64(e))
		}
		n += 1 + sovAcl(uint64(l)) + l
	}
	if m.TunnelTerminate {
		n += 2
	}
	if m.Direction {
		n += 2
	}
	return n
}

func (m *AclInternalActionInfo) Size() (n int) {
	var l int
	_ = l
	if m.MacSaRewriteEn {
		n += 2
	}
	if m.MacSa != 0 {
		n += 1 + sovAcl(uint64(m.MacSa))
	}
	if m.MacDaRewriteEn {
		n += 2
	}
	if m.MacDa != 0 {
		n += 1 + sovAcl(uint64(m.MacDa))
	}
	if m.TtlDecEn {
		n += 2
	}
	if m.EncapInfo != nil {
		l = m.EncapInfo.Size()
		n += 1 + l + sovAcl(uint64(l))
	}
	return n
}

func (m *AclSelector) Size() (n int) {
	var l int
	_ = l
	if m.SrcIfKeyHandle != nil {
		l = m.SrcIfKeyHandle.Size()
		n += 1 + l + sovAcl(uint64(l))
	}
	if m.DstIfKeyHandle != nil {
		l = m.DstIfKeyHandle.Size()
		n += 1 + l + sovAcl(uint64(l))
	}
	if m.SegSelector != nil {
		n += m.SegSelector.Size()
	}
	if m.PktSelector != nil {
		n += m.PktSelector.Size()
	}
	if m.InternalKey != nil {
		l = m.InternalKey.Size()
		n += 1 + l + sovAcl(uint64(l))
	}
	if m.InternalMask != nil {
		l = m.InternalMask.Size()
		n += 1 + l + sovAcl(uint64(l))
	}
	return n
}

func (m *AclSelector_TenantKeyHandle) Size() (n int) {
	var l int
	_ = l
	if m.TenantKeyHandle != nil {
		l = m.TenantKeyHandle.Size()
		n += 1 + l + sovAcl(uint64(l))
	}
	return n
}
func (m *AclSelector_L2SegmentKeyHandle) Size() (n int) {
	var l int
	_ = l
	if m.L2SegmentKeyHandle != nil {
		l = m.L2SegmentKeyHandle.Size()
		n += 1 + l + sovAcl(uint64(l))
	}
	return n
}
func (m *AclSelector_EthSelector) Size() (n int) {
	var l int
	_ = l
	if m.EthSelector != nil {
		l = m.EthSelector.Size()
		n += 1 + l + sovAcl(uint64(l))
	}
	return n
}
func (m *AclSelector_IpSelector) Size() (n int) {
	var l int
	_ = l
	if m.IpSelector != nil {
		l = m.IpSelector.Size()
		n += 1 + l + sovAcl(uint64(l))
	}
	return n
}
func (m *AclActionInfo) Size() (n int) {
	var l int
	_ = l
	if m.Action != 0 {
		n += 1 + sovAcl(uint64(m.Action))
	}
	if len(m.IngMirrorSessions) > 0 {
		for _, e := range m.IngMirrorSessions {
			l = e.Size()
			n += 1 + l + sovAcl(uint64(l))
		}
	}
	if len(m.EgrMirrorSessions) > 0 {
		for _, e := range m.EgrMirrorSessions {
			l = e.Size()
			n += 1 + l + sovAcl(uint64(l))
		}
	}
	if m.CoppPolicerHandle != 0 {
		n += 9
	}
	if m.RedirectIfKeyHandle != nil {
		l = m.RedirectIfKeyHandle.Size()
		n += 1 + l + sovAcl(uint64(l))
	}
	if m.InternalActions != nil {
		l = m.InternalActions.Size()
		n += 1 + l + sovAcl(uint64(l))
	}
	return n
}

func (m *AclSpec) Size() (n int) {
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovAcl(uint64(l))
	}
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovAcl(uint64(l))
	}
	if m.Priority != 0 {
		n += 1 + sovAcl(uint64(m.Priority))
	}
	if m.Match != nil {
		l = m.Match.Size()
		n += 1 + l + sovAcl(uint64(l))
	}
	if m.Action != nil {
		l = m.Action.Size()
		n += 1 + l + sovAcl(uint64(l))
	}
	return n
}

func (m *AclRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovAcl(uint64(l))
		}
	}
	return n
}

func (m *AclStatus) Size() (n int) {
	var l int
	_ = l
	if m.AclHandle != nil {
		l = m.AclHandle.Size()
		n += 1 + l + sovAcl(uint64(l))
	}
	return n
}

func (m *AclResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovAcl(uint64(m.ApiStatus))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovAcl(uint64(l))
	}
	return n
}

func (m *AclResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovAcl(uint64(l))
		}
	}
	return n
}

func (m *AclDeleteRequest) Size() (n int) {
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovAcl(uint64(l))
	}
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovAcl(uint64(l))
	}
	return n
}

func (m *AclDeleteRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovAcl(uint64(l))
		}
	}
	return n
}

func (m *AclDeleteResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovAcl(uint64(m.ApiStatus))
	}
	return n
}

func (m *AclDeleteResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovAcl(uint64(l))
		}
	}
	return n
}

func (m *AclGetRequest) Size() (n int) {
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovAcl(uint64(l))
	}
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovAcl(uint64(l))
	}
	return n
}

func (m *AclGetRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovAcl(uint64(l))
		}
	}
	return n
}

func (m *AclStats) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *AclGetResponse) Size() (n int) {
	var l int
	_ = l
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovAcl(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovAcl(uint64(l))
	}
	if m.Stats != nil {
		l = m.Stats.Size()
		n += 1 + l + sovAcl(uint64(l))
	}
	return n
}

func (m *AclGetResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovAcl(uint64(l))
		}
	}
	return n
}

func sovAcl(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozAcl(x uint64) (n int) {
	return sovAcl(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *AclHandle) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAcl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AclHandle: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AclHandle: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Handle", wireType)
			}
			m.Handle = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			m.Handle = uint64(dAtA[iNdEx-8])
			m.Handle |= uint64(dAtA[iNdEx-7]) << 8
			m.Handle |= uint64(dAtA[iNdEx-6]) << 16
			m.Handle |= uint64(dAtA[iNdEx-5]) << 24
			m.Handle |= uint64(dAtA[iNdEx-4]) << 32
			m.Handle |= uint64(dAtA[iNdEx-3]) << 40
			m.Handle |= uint64(dAtA[iNdEx-2]) << 48
			m.Handle |= uint64(dAtA[iNdEx-1]) << 56
		default:
			iNdEx = preIndex
			skippy, err := skipAcl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAcl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AclKeyHandle) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAcl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AclKeyHandle: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AclKeyHandle: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field AclId", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.KeyOrHandle = &AclKeyHandle_AclId{v}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AclHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAcl
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AclHandle{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.KeyOrHandle = &AclKeyHandle_AclHandle{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAcl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAcl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EthSelector) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAcl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EthSelector: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EthSelector: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EthType", wireType)
			}
			m.EthType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EthType |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EthTypeMask", wireType)
			}
			m.EthTypeMask = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EthTypeMask |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcMac", wireType)
			}
			m.SrcMac = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SrcMac |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcMacMask", wireType)
			}
			m.SrcMacMask = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SrcMacMask |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstMac", wireType)
			}
			m.DstMac = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DstMac |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstMacMask", wireType)
			}
			m.DstMacMask = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DstMacMask |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAcl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAcl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UDPSelector) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAcl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UDPSelector: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UDPSelector: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcPortRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAcl
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SrcPortRange == nil {
				m.SrcPortRange = &L4PortRange{}
			}
			if err := m.SrcPortRange.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstPortRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAcl
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DstPortRange == nil {
				m.DstPortRange = &L4PortRange{}
			}
			if err := m.DstPortRange.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAcl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAcl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TCPSelector) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAcl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TCPSelector: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TCPSelector: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpSynSet", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.TcpSyn = &TCPSelector_TcpSynSet{b}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpSynClear", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.TcpSyn = &TCPSelector_TcpSynClear{b}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpAckSet", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.TcpAck = &TCPSelector_TcpAckSet{b}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpAckClear", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.TcpAck = &TCPSelector_TcpAckClear{b}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpFinSet", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.TcpFin = &TCPSelector_TcpFinSet{b}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpFinClear", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.TcpFin = &TCPSelector_TcpFinClear{b}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpRstSet", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.TcpRst = &TCPSelector_TcpRstSet{b}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpRstClear", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.TcpRst = &TCPSelector_TcpRstClear{b}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpUrgSet", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.TcpUrg = &TCPSelector_TcpUrgSet{b}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpUrgClear", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.TcpUrg = &TCPSelector_TcpUrgClear{b}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcPortRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAcl
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SrcPortRange == nil {
				m.SrcPortRange = &L4PortRange{}
			}
			if err := m.SrcPortRange.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstPortRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAcl
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DstPortRange == nil {
				m.DstPortRange = &L4PortRange{}
			}
			if err := m.DstPortRange.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAcl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAcl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ICMPSelector) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAcl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ICMPSelector: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ICMPSelector: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IcmpCode", wireType)
			}
			m.IcmpCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IcmpCode |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IcmpCodeMask", wireType)
			}
			m.IcmpCodeMask = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IcmpCodeMask |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IcmpType", wireType)
			}
			m.IcmpType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IcmpType |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IcmpTypeMask", wireType)
			}
			m.IcmpTypeMask = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IcmpTypeMask |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAcl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAcl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IPSelector) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAcl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IPSelector: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IPSelector: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpAf", wireType)
			}
			m.IpAf = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IpAf |= (IPAddressFamily(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcPrefix", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAcl
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SrcPrefix == nil {
				m.SrcPrefix = &IPPrefix{}
			}
			if err := m.SrcPrefix.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstPrefix", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAcl
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DstPrefix == nil {
				m.DstPrefix = &IPPrefix{}
			}
			if err := m.DstPrefix.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpProtocol", wireType)
			}
			var v IPProtocol
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (IPProtocol(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.L4Selectors = &IPSelector_IpProtocol{v}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IcmpSelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAcl
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ICMPSelector{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.L4Selectors = &IPSelector_IcmpSelector{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UdpSelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAcl
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &UDPSelector{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.L4Selectors = &IPSelector_UdpSelector{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpSelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAcl
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TCPSelector{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.L4Selectors = &IPSelector_TcpSelector{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAcl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAcl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AclInternalSelector) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAcl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AclInternalSelector: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AclInternalSelector: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlowMiss", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FlowMiss = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OuterDstMac", wireType)
			}
			m.OuterDstMac = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OuterDstMac |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpOptions", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IpOptions = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpFrag", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IpFrag = bool(v != 0)
		case 5:
			if wireType == 0 {
				var v DropReason
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAcl
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (DropReason(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.DropReason = append(m.DropReason, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAcl
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthAcl
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v DropReason
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAcl
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (DropReason(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.DropReason = append(m.DropReason, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field DropReason", wireType)
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TunnelTerminate", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TunnelTerminate = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Direction", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Direction = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipAcl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAcl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AclInternalActionInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAcl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AclInternalActionInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AclInternalActionInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MacSaRewriteEn", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MacSaRewriteEn = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MacSa", wireType)
			}
			m.MacSa = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MacSa |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MacDaRewriteEn", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MacDaRewriteEn = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MacDa", wireType)
			}
			m.MacDa = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MacDa |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TtlDecEn", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TtlDecEn = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncapInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAcl
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EncapInfo == nil {
				m.EncapInfo = &EncapInfo{}
			}
			if err := m.EncapInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAcl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAcl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AclSelector) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAcl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AclSelector: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AclSelector: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcIfKeyHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAcl
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SrcIfKeyHandle == nil {
				m.SrcIfKeyHandle = &InterfaceKeyHandle{}
			}
			if err := m.SrcIfKeyHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstIfKeyHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAcl
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DstIfKeyHandle == nil {
				m.DstIfKeyHandle = &InterfaceKeyHandle{}
			}
			if err := m.DstIfKeyHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TenantKeyHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAcl
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TenantKeyHandle{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.SegSelector = &AclSelector_TenantKeyHandle{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field L2SegmentKeyHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAcl
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &L2SegmentKeyHandle{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.SegSelector = &AclSelector_L2SegmentKeyHandle{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EthSelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAcl
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &EthSelector{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PktSelector = &AclSelector_EthSelector{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpSelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAcl
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &IPSelector{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PktSelector = &AclSelector_IpSelector{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InternalKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAcl
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InternalKey == nil {
				m.InternalKey = &AclInternalSelector{}
			}
			if err := m.InternalKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InternalMask", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAcl
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InternalMask == nil {
				m.InternalMask = &AclInternalSelector{}
			}
			if err := m.InternalMask.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAcl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAcl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AclActionInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAcl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AclActionInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AclActionInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			m.Action = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Action |= (AclAction(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IngMirrorSessions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAcl
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IngMirrorSessions = append(m.IngMirrorSessions, &MirrorSessionId{})
			if err := m.IngMirrorSessions[len(m.IngMirrorSessions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EgrMirrorSessions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAcl
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EgrMirrorSessions = append(m.EgrMirrorSessions, &MirrorSessionId{})
			if err := m.EgrMirrorSessions[len(m.EgrMirrorSessions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CoppPolicerHandle", wireType)
			}
			m.CoppPolicerHandle = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			m.CoppPolicerHandle = uint64(dAtA[iNdEx-8])
			m.CoppPolicerHandle |= uint64(dAtA[iNdEx-7]) << 8
			m.CoppPolicerHandle |= uint64(dAtA[iNdEx-6]) << 16
			m.CoppPolicerHandle |= uint64(dAtA[iNdEx-5]) << 24
			m.CoppPolicerHandle |= uint64(dAtA[iNdEx-4]) << 32
			m.CoppPolicerHandle |= uint64(dAtA[iNdEx-3]) << 40
			m.CoppPolicerHandle |= uint64(dAtA[iNdEx-2]) << 48
			m.CoppPolicerHandle |= uint64(dAtA[iNdEx-1]) << 56
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RedirectIfKeyHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAcl
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RedirectIfKeyHandle == nil {
				m.RedirectIfKeyHandle = &InterfaceKeyHandle{}
			}
			if err := m.RedirectIfKeyHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InternalActions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAcl
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InternalActions == nil {
				m.InternalActions = &AclInternalActionInfo{}
			}
			if err := m.InternalActions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAcl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAcl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AclSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAcl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AclSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AclSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAcl
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &ObjectMeta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAcl
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &AclKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Priority", wireType)
			}
			m.Priority = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Priority |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Match", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAcl
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Match == nil {
				m.Match = &AclSelector{}
			}
			if err := m.Match.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAcl
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Action == nil {
				m.Action = &AclActionInfo{}
			}
			if err := m.Action.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAcl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAcl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AclRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAcl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AclRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AclRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAcl
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &AclSpec{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAcl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAcl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AclStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAcl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AclStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AclStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AclHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAcl
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AclHandle == nil {
				m.AclHandle = &AclHandle{}
			}
			if err := m.AclHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAcl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAcl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AclResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAcl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AclResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AclResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAcl
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &AclStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAcl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAcl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AclResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAcl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AclResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AclResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAcl
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &AclResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAcl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAcl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AclDeleteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAcl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AclDeleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AclDeleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAcl
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &ObjectMeta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAcl
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &AclKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAcl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAcl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AclDeleteRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAcl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AclDeleteRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AclDeleteRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAcl
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &AclDeleteRequest{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAcl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAcl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AclDeleteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAcl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AclDeleteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AclDeleteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAcl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAcl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AclDeleteResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAcl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AclDeleteResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AclDeleteResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAcl
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &AclDeleteResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAcl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAcl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AclGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAcl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AclGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AclGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAcl
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &ObjectMeta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAcl
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &AclKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAcl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAcl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AclGetRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAcl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AclGetRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AclGetRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAcl
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &AclGetRequest{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAcl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAcl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AclStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAcl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AclStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AclStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAcl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAcl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AclGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAcl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AclGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AclGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAcl
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &AclSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAcl
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &AclStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAcl
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = &AclStats{}
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAcl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAcl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AclGetResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAcl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AclGetResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AclGetResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAcl
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &AclGetResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAcl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAcl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipAcl(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowAcl
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthAcl
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowAcl
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipAcl(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthAcl = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowAcl   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("nic/proto/hal/acl.proto", fileDescriptorAcl) }

var fileDescriptorAcl = []byte{
	// 2315 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x58, 0xcb, 0x73, 0x1b, 0x49,
	0x19, 0xb7, 0xac, 0x87, 0xed, 0x4f, 0xb2, 0x6c, 0xb5, 0xe3, 0x47, 0x9c, 0xc4, 0xeb, 0x9a, 0x7d,
	0x54, 0x76, 0x01, 0x87, 0x12, 0x59, 0x58, 0x96, 0x82, 0x62, 0x2c, 0x8d, 0xac, 0x49, 0xac, 0x47,
	0x5a, 0xe3, 0x64, 0x93, 0x4b, 0xd7, 0xec, 0xa8, 0x25, 0x0f, 0x1e, 0x8d, 0x86, 0x99, 0x36, 0x8b,
	0x4e, 0x5b, 0x70, 0xa1, 0xb8, 0x43, 0x15, 0x47, 0xfe, 0x0c, 0xce, 0x9c, 0x38, 0xf2, 0x17, 0x50,
	0x54, 0x38, 0xc1, 0x91, 0xe2, 0xc0, 0x91, 0xea, 0xd7, 0x68, 0x24, 0x3b, 0x95, 0x65, 0x0f, 0x70,
	0xf2, 0xf4, 0xf7, 0xfb, 0xbe, 0x5f, 0x7f, 0xfd, 0xbd, 0xba, 0x65, 0xd8, 0x0f, 0x7d, 0xef, 0x51,
	0x14, 0x4f, 0xd9, 0xf4, 0xd1, 0xa5, 0x1b, 0x3c, 0x72, 0xbd, 0xe0, 0x44, 0xac, 0x50, 0xde, 0xf5,
	0x82, 0xc3, 0xdd, 0x39, 0xca, 0x66, 0x11, 0x4d, 0x24, 0x76, 0x78, 0xb8, 0x68, 0xc4, 0x68, 0xe8,
	0x86, 0x4c, 0x61, 0x0f, 0x16, 0x31, 0x3f, 0x64, 0x34, 0x1e, 0xb9, 0x1e, 0xbd, 0x1d, 0x0e, 0xea,
	0x09, 0x1d, 0x4f, 0xe8, 0x9b, 0xac, 0x19, 0x0d, 0xe8, 0x84, 0xb2, 0x78, 0x26, 0x61, 0xe3, 0x5d,
	0xd8, 0x30, 0xbd, 0xa0, 0xed, 0x86, 0xc3, 0x80, 0xa2, 0x3d, 0x28, 0x5d, 0x8a, 0xaf, 0x83, 0xdc,
	0x71, 0xee, 0x61, 0x09, 0xab, 0x95, 0xe1, 0x43, 0xc5, 0xf4, 0x82, 0xa7, 0x74, 0xa6, 0xf4, 0xf6,
	0xa1, 0xe4, 0x7a, 0x01, 0xf1, 0x87, 0x42, 0x6f, 0xad, 0xbd, 0x82, 0x8b, 0xae, 0x17, 0xd8, 0x43,
	0xf4, 0x08, 0x80, 0x03, 0x8a, 0x64, 0xf5, 0x38, 0xf7, 0xb0, 0x5c, 0xaf, 0x9e, 0xf0, 0x10, 0xa4,
	0x9b, 0xb4, 0x57, 0xf0, 0x86, 0xab, 0x17, 0xa7, 0x5b, 0xb0, 0x79, 0x45, 0x67, 0x64, 0x1a, 0x2b,
	0x1b, 0xe3, 0x8f, 0x39, 0x28, 0x5b, 0xec, 0x72, 0x40, 0x03, 0xea, 0xb1, 0x69, 0x8c, 0xee, 0xc2,
	0x3a, 0x65, 0x97, 0x84, 0xc7, 0x4a, 0x6c, 0xb6, 0x89, 0xd7, 0x28, 0xbb, 0x74, 0x66, 0x11, 0x45,
	0x06, 0x6c, 0x6a, 0x88, 0x4c, 0xdc, 0xe4, 0x4a, 0xec, 0xb7, 0x89, 0xcb, 0x0a, 0xef, 0xb8, 0xc9,
	0x15, 0xda, 0x87, 0xb5, 0x24, 0xf6, 0xc8, 0xc4, 0xf5, 0x0e, 0xf2, 0xc7, 0xb9, 0x87, 0x05, 0x5c,
	0x4a, 0x62, 0xaf, 0xe3, 0x7a, 0xe8, 0x18, 0x2a, 0x0a, 0x90, 0xb6, 0x05, 0x81, 0x82, 0x44, 0xb5,
	0xe9, 0x30, 0x61, 0xc2, 0xb4, 0x28, 0x4d, 0x87, 0x09, 0x53, 0xa6, 0x0a, 0x90, 0xa6, 0x25, 0x69,
	0x2a, 0x51, 0x6e, 0x6a, 0xfc, 0x22, 0x07, 0xe5, 0x8b, 0x66, 0x3f, 0x3d, 0xc4, 0x27, 0x50, 0xe5,
	0x9b, 0x45, 0xd3, 0x98, 0x91, 0xd8, 0x0d, 0xc7, 0xf2, 0x28, 0xe5, 0x3a, 0x3a, 0x91, 0x35, 0x70,
	0xfe, 0xb8, 0x3f, 0x8d, 0x19, 0xe6, 0x08, 0xe6, 0x6e, 0xa5, 0x2b, 0x6e, 0xc9, 0xf7, 0xca, 0x58,
	0xae, 0xbe, 0xd9, 0x72, 0x98, 0xb0, 0x74, 0x65, 0xfc, 0xbe, 0x00, 0x65, 0xa7, 0x31, 0xf7, 0xe1,
	0x18, 0xca, 0xcc, 0x8b, 0x48, 0x32, 0x0b, 0x49, 0x42, 0x99, 0x70, 0x60, 0x9d, 0xe7, 0x82, 0x79,
	0xd1, 0x60, 0x16, 0x0e, 0x28, 0x43, 0xef, 0xc1, 0xa6, 0xd6, 0xf0, 0x02, 0xea, 0xc6, 0x62, 0x2b,
	0xae, 0x53, 0x96, 0x3a, 0x0d, 0x2e, 0xd4, 0x3c, 0xae, 0x77, 0x25, 0x78, 0xf2, 0x42, 0x27, 0x27,
	0x78, 0x4c, 0xef, 0x2a, 0xc3, 0xc3, 0x35, 0x24, 0x4f, 0x41, 0xe9, 0x94, 0xa5, 0xce, 0x02, 0xcf,
	0xc8, 0x97, 0xfe, 0x14, 0x85, 0xce, 0xaa, 0xe0, 0x69, 0xf9, 0x59, 0x7f, 0xb8, 0x86, 0xe4, 0x29,
	0x29, 0x9d, 0xb2, 0xd4, 0x59, 0xe0, 0x89, 0x13, 0x26, 0x78, 0xd6, 0x84, 0x4e, 0x5e, 0xf0, 0xe0,
	0x84, 0x65, 0x78, 0xb8, 0x86, 0xe4, 0x59, 0x57, 0x3a, 0x65, 0xa9, 0xb3, 0xc0, 0x73, 0x1d, 0x8f,
	0x05, 0xcf, 0x86, 0xd0, 0x29, 0x08, 0x9e, 0x8b, 0x78, 0x9c, 0xe1, 0xe1, 0x1a, 0x92, 0x07, 0x94,
	0x4e, 0x59, 0xea, 0x48, 0x9e, 0x9b, 0xb9, 0x2e, 0x7f, 0xed, 0x5c, 0x57, 0xbe, 0x5a, 0xae, 0x4f,
	0x37, 0x60, 0x4d, 0x65, 0x4e, 0x7f, 0xba, 0xde, 0x95, 0xfe, 0x1c, 0xf9, 0xa9, 0x34, 0x4e, 0x98,
	0xfe, 0xbc, 0x8e, 0xc7, 0xc6, 0x6f, 0x72, 0x50, 0xb1, 0x1b, 0x9d, 0x79, 0x8d, 0xdc, 0x83, 0x0d,
	0xdf, 0x9b, 0x44, 0xc4, 0x9b, 0x0e, 0x75, 0xb7, 0xad, 0x73, 0x41, 0x63, 0x3a, 0xa4, 0xe8, 0x3d,
	0xa8, 0xa6, 0x60, 0xb6, 0xdf, 0x2a, 0x5a, 0x43, 0x74, 0x8d, 0xa6, 0x10, 0x0d, 0x9b, 0x9f, 0x53,
	0x88, 0x8e, 0xd5, 0x14, 0xf3, 0x96, 0x2d, 0xcc, 0x29, 0x74, 0xcf, 0x1a, 0xbf, 0xca, 0x03, 0xd8,
	0x73, 0xa7, 0xbe, 0x01, 0x45, 0x3f, 0x22, 0xee, 0x48, 0x38, 0x54, 0xad, 0xef, 0xa9, 0x68, 0xd8,
	0x7d, 0x73, 0x38, 0x8c, 0x69, 0x92, 0xb4, 0xdc, 0x89, 0x1f, 0xcc, 0x70, 0xc1, 0x8f, 0xcc, 0x11,
	0x3a, 0x01, 0x10, 0xd1, 0x8f, 0xe9, 0xc8, 0xff, 0xb9, 0xea, 0x95, 0xad, 0xd4, 0xa2, 0x2f, 0xc4,
	0x78, 0x83, 0x87, 0x5d, 0x7c, 0x72, 0x7d, 0x11, 0x73, 0xa9, 0x9f, 0x7f, 0x83, 0x3e, 0x0f, 0xb6,
	0xd4, 0x7f, 0x0c, 0x65, 0x3f, 0x22, 0x62, 0x74, 0x7a, 0xd3, 0x40, 0xb8, 0x5f, 0xad, 0xd7, 0x32,
	0x06, 0x12, 0x68, 0xaf, 0x60, 0xf0, 0x23, 0xbd, 0x42, 0x9f, 0xc0, 0xa6, 0x38, 0x77, 0xa2, 0xce,
	0x24, 0xaa, 0xbd, 0x5c, 0xaf, 0x89, 0xc9, 0x98, 0xcd, 0x40, 0x7b, 0x45, 0xc6, 0x22, 0x3d, 0xfc,
	0xc7, 0x50, 0xb9, 0x1e, 0x66, 0x0c, 0x4b, 0xc2, 0x70, 0x5b, 0x18, 0x66, 0x26, 0x0c, 0x6f, 0xd2,
	0xeb, 0xe1, 0x82, 0x99, 0x28, 0x08, 0x6d, 0xb6, 0x96, 0x31, 0xcb, 0x0c, 0x05, 0xdd, 0xdb, 0x6a,
	0x79, 0x5a, 0x85, 0x4a, 0xf0, 0x38, 0xb5, 0x4a, 0x8c, 0x5f, 0xaf, 0xc2, 0x8e, 0xe9, 0x05, 0x36,
	0xbf, 0x71, 0x42, 0x37, 0xc8, 0xd6, 0xc9, 0x28, 0x98, 0x7e, 0x41, 0x26, 0x7e, 0x92, 0xc8, 0x49,
	0x82, 0xd7, 0xb9, 0xa0, 0xe3, 0x27, 0x09, 0x1f, 0xcb, 0xd3, 0x6b, 0x46, 0x63, 0xa2, 0xa7, 0xe7,
	0xaa, 0x98, 0x8f, 0x65, 0x21, 0x6c, 0xca, 0x11, 0xfa, 0x00, 0xc0, 0x8f, 0xc8, 0x34, 0x62, 0xfe,
	0x34, 0x4c, 0xe4, 0x0c, 0xc1, 0x1b, 0x7e, 0xd4, 0x93, 0x02, 0x3e, 0x7a, 0xfd, 0x88, 0x8c, 0x62,
	0x77, 0x2c, 0x67, 0x07, 0x2e, 0xf9, 0x51, 0x2b, 0x76, 0xc7, 0xe8, 0xdb, 0x50, 0x1e, 0xc6, 0xd3,
	0x88, 0xc4, 0xd4, 0x4d, 0xa6, 0xe1, 0x41, 0xf1, 0x38, 0xff, 0xb0, 0x5a, 0xdf, 0x12, 0xc7, 0x6a,
	0xc6, 0xd3, 0x08, 0x0b, 0x31, 0x86, 0x61, 0xfa, 0x8d, 0x3e, 0x84, 0x6d, 0x76, 0x1d, 0x86, 0x34,
	0x20, 0x8c, 0xc6, 0x13, 0x3f, 0x74, 0x19, 0x95, 0x73, 0x04, 0x6f, 0x49, 0xb9, 0xa3, 0xc5, 0xe8,
	0x3e, 0x6c, 0x0c, 0xfd, 0x98, 0x7a, 0xdc, 0x07, 0x39, 0x47, 0xf0, 0x5c, 0x60, 0xfc, 0x23, 0x07,
	0xbb, 0x99, 0x58, 0x98, 0x42, 0x6a, 0x87, 0xa3, 0x29, 0xfa, 0x10, 0x6a, 0xfc, 0x2e, 0x48, 0x5c,
	0x12, 0xd3, 0x2f, 0x62, 0x9f, 0x51, 0x42, 0x43, 0x15, 0x95, 0xea, 0xc4, 0xf5, 0x06, 0x2e, 0x96,
	0x62, 0x2b, 0x44, 0xbb, 0x50, 0x92, 0xaa, 0x2a, 0x28, 0x45, 0x81, 0x6b, 0x86, 0xe1, 0x02, 0x43,
	0x3e, 0x65, 0x68, 0xde, 0x64, 0x18, 0xba, 0xea, 0xc6, 0x2a, 0x0a, 0x1c, 0xdd, 0x07, 0x60, 0x2c,
	0x20, 0x43, 0xea, 0x71, 0xd3, 0xa2, 0x4c, 0x09, 0x63, 0x41, 0x93, 0x7a, 0x56, 0xc8, 0xaf, 0x65,
	0x1a, 0x7a, 0x6e, 0x44, 0xfc, 0x70, 0x34, 0x4d, 0x6b, 0x48, 0x16, 0xad, 0xc5, 0x01, 0x7e, 0x0e,
	0xbc, 0x41, 0xf5, 0xa7, 0xf1, 0x87, 0x02, 0x94, 0x4d, 0x6f, 0x9e, 0xf0, 0x06, 0xd4, 0x78, 0x5b,
	0xf9, 0x23, 0xc2, 0x6f, 0xeb, 0xcc, 0x1b, 0xa1, 0x5c, 0x3f, 0x38, 0xf1, 0x43, 0x36, 0x3a, 0xb1,
	0xf5, 0xab, 0x24, 0x7d, 0x25, 0x60, 0x3e, 0x07, 0xed, 0xd1, 0xfc, 0xd5, 0xd0, 0x80, 0x1a, 0x2f,
	0x89, 0x45, 0x92, 0xd5, 0xb7, 0x91, 0x0c, 0x13, 0x96, 0x25, 0xb1, 0xa0, 0x26, 0x1f, 0x47, 0x59,
	0x12, 0xd9, 0xb7, 0xfb, 0x27, 0xea, 0xd9, 0xe4, 0x88, 0x3f, 0xa9, 0x4d, 0x7b, 0x05, 0x6f, 0xb1,
	0x45, 0x11, 0x7a, 0x06, 0x77, 0xd2, 0x87, 0x52, 0x96, 0xa9, 0x20, 0x98, 0x1e, 0x9c, 0xcc, 0x5f,
	0x51, 0xe7, 0xf5, 0x81, 0xfc, 0xca, 0xf2, 0xa1, 0x14, 0x9f, 0x53, 0x7e, 0x0c, 0x15, 0xfe, 0x1c,
	0x59, 0xea, 0x71, 0xd9, 0x73, 0x99, 0x17, 0x0d, 0xbf, 0x07, 0x69, 0xe6, 0x81, 0x53, 0x17, 0x13,
	0x65, 0xa9, 0xc1, 0x65, 0x49, 0xcf, 0x87, 0x60, 0x3b, 0xc7, 0xe7, 0x49, 0x6a, 0xf3, 0x03, 0xa8,
	0xf8, 0xaa, 0x0e, 0xb9, 0xf3, 0xaa, 0xbd, 0x0f, 0xf4, 0x43, 0x6b, 0xb9, 0x5f, 0x71, 0x59, 0x6b,
	0x3f, 0xa5, 0x33, 0xf4, 0x43, 0xd8, 0x4c, 0x8d, 0xc5, 0x0c, 0x5e, 0x7f, 0x8b, 0x75, 0xba, 0x17,
	0x9f, 0xce, 0x7c, 0x46, 0x24, 0x74, 0x9c, 0x3a, 0xcc, 0xd7, 0xd1, 0x15, 0x4b, 0xd7, 0xc6, 0x6f,
	0xf3, 0xb0, 0x69, 0x7a, 0xd9, 0xfe, 0xf8, 0x80, 0xbf, 0x16, 0x45, 0x53, 0xc9, 0x09, 0x9e, 0x3e,
	0x08, 0xa5, 0x0e, 0x56, 0x28, 0x7a, 0x02, 0x3b, 0x7e, 0x38, 0x26, 0x13, 0x3f, 0x8e, 0xa7, 0x31,
	0x49, 0x68, 0x92, 0x88, 0xe9, 0xb0, 0x7a, 0x9c, 0x7f, 0x58, 0xae, 0x1f, 0x9e, 0xcc, 0x5f, 0xae,
	0x1d, 0xa1, 0x31, 0x90, 0x0a, 0xf6, 0x10, 0xd7, 0xfc, 0x70, 0xbc, 0x20, 0x4b, 0x38, 0x17, 0x1d,
	0xc7, 0x37, 0xb8, 0xf2, 0x6f, 0xe7, 0xa2, 0xe3, 0x78, 0x89, 0xeb, 0x04, 0x76, 0xbc, 0x69, 0x14,
	0x91, 0x68, 0x1a, 0xf8, 0x1e, 0x8d, 0xb3, 0xa5, 0x52, 0xc2, 0x35, 0x0e, 0xf5, 0x25, 0xa2, 0x0a,
	0xa1, 0x03, 0x7b, 0x31, 0x95, 0x83, 0x63, 0xa9, 0xd8, 0x8b, 0x6f, 0x29, 0xf6, 0x1d, 0x6d, 0xb7,
	0x58, 0xf1, 0xdb, 0x69, 0xbe, 0x64, 0xa4, 0x12, 0x55, 0x25, 0x87, 0xcb, 0x29, 0x9b, 0x07, 0x1d,
	0x6f, 0xf9, 0x0b, 0xb2, 0xc4, 0xf8, 0x7b, 0x0e, 0xd6, 0x78, 0x4b, 0x47, 0xd4, 0x43, 0xef, 0x43,
	0x61, 0x42, 0x99, 0xab, 0x3a, 0x58, 0x5f, 0x5f, 0xbd, 0xcf, 0x7f, 0x42, 0x3d, 0xd6, 0xa1, 0xcc,
	0xc5, 0x02, 0x46, 0x67, 0x4b, 0x8f, 0x73, 0xd5, 0xac, 0x35, 0xbd, 0x6d, 0xea, 0xe3, 0xe9, 0xf6,
	0x3f, 0xff, 0xf2, 0x4e, 0xe5, 0x67, 0x34, 0xf4, 0x3d, 0xfa, 0xa9, 0x71, 0x45, 0x67, 0x06, 0x2e,
	0x5f, 0xd1, 0x59, 0x4f, 0x47, 0xe4, 0x10, 0xd6, 0xa3, 0xd8, 0x9f, 0xc6, 0x3e, 0x9b, 0xe9, 0x37,
	0x81, 0x5e, 0xa3, 0x0f, 0xa0, 0x38, 0x71, 0x99, 0x77, 0xa9, 0x5a, 0x6f, 0x5b, 0x93, 0xa7, 0xe5,
	0x27, 0x61, 0xf4, 0x51, 0x5a, 0x45, 0x45, 0xf5, 0x2a, 0x5a, 0xa8, 0x22, 0x71, 0x68, 0xa5, 0x61,
	0x7c, 0x4f, 0x94, 0x20, 0xa6, 0x3f, 0xbd, 0xa6, 0x09, 0xeb, 0x24, 0x63, 0xf4, 0x01, 0xac, 0xc5,
	0x72, 0x75, 0x90, 0x13, 0x25, 0x50, 0x49, 0xb7, 0x89, 0xa8, 0x87, 0x35, 0x68, 0x7c, 0x2a, 0x7e,
	0x0d, 0x0d, 0x98, 0xcb, 0xae, 0x13, 0xf4, 0xad, 0x85, 0x1f, 0x33, 0xb9, 0xdb, 0x7e, 0xcc, 0x64,
	0x7e, 0xca, 0x18, 0x23, 0x31, 0x32, 0x31, 0x4d, 0xa2, 0x69, 0x98, 0x50, 0xf1, 0x53, 0x28, 0xf2,
	0x49, 0x22, 0xb8, 0x54, 0xe5, 0xeb, 0x99, 0x6b, 0x46, 0xbe, 0xdc, 0x03, 0x6f, 0xb8, 0xfa, 0x93,
	0xb7, 0x89, 0x52, 0x5e, 0xfa, 0xdd, 0xa4, 0x54, 0x15, 0x6a, 0xfc, 0x08, 0xaa, 0x99, 0x7d, 0xf8,
	0xe9, 0xbe, 0x09, 0xeb, 0xb1, 0x5a, 0xaa, 0xe3, 0xa5, 0x51, 0xd4, 0x6a, 0x38, 0xd5, 0x30, 0x7e,
	0x99, 0x83, 0x6d, 0xd3, 0x0b, 0x9a, 0x34, 0xa0, 0x8c, 0xaa, 0x18, 0xfd, 0xaf, 0x2b, 0xc2, 0x68,
	0x89, 0x87, 0xc5, 0x82, 0x0f, 0xfc, 0x24, 0x8f, 0x96, 0xf3, 0xb4, 0xab, 0x99, 0x17, 0x54, 0xe7,
	0x09, 0x6b, 0x42, 0x2d, 0x03, 0x7e, 0xcd, 0xd0, 0x1b, 0x4f, 0xe0, 0xce, 0x0d, 0x16, 0xee, 0x4e,
	0xfd, 0x46, 0x60, 0xf7, 0x96, 0xfd, 0xb9, 0x11, 0xde, 0x2f, 0x45, 0xed, 0x9d, 0x51, 0xf6, 0xff,
	0x0a, 0xed, 0x8f, 0x45, 0x7a, 0xe7, 0x0e, 0xc8, 0x0a, 0x59, 0x8a, 0x6b, 0xda, 0x3d, 0x73, 0xbd,
	0x79, 0x50, 0x01, 0xd6, 0x55, 0xd9, 0x25, 0xc6, 0x97, 0xa2, 0xda, 0x84, 0x96, 0x8a, 0xee, 0x31,
	0x14, 0x92, 0x88, 0x7a, 0xea, 0x3c, 0x8b, 0x8d, 0x24, 0x90, 0xaf, 0x5a, 0xc9, 0xe8, 0x5d, 0x28,
	0xf2, 0xaf, 0x44, 0xdd, 0xdf, 0x9b, 0x59, 0xb5, 0x04, 0x4b, 0x4c, 0x65, 0x38, 0xe3, 0x80, 0xac,
	0x93, 0xe5, 0xc4, 0xec, 0x2c, 0x1c, 0x68, 0x39, 0x2b, 0x1f, 0xfd, 0xbb, 0x04, 0x30, 0x7f, 0x21,
	0xa2, 0x7d, 0xd8, 0xb1, 0xbb, 0xfd, 0x0b, 0x87, 0x74, 0xcc, 0x7e, 0xdf, 0xee, 0x9e, 0x11, 0xd2,
	0xc4, 0xbd, 0xfe, 0xf6, 0x0a, 0x3a, 0x82, 0xc3, 0x45, 0xa0, 0x69, 0x3d, 0x31, 0x9f, 0x5f, 0x28,
	0x3c, 0x87, 0x10, 0x54, 0x5b, 0xe7, 0xbd, 0x17, 0xa4, 0x6d, 0x3b, 0x4a, 0xb6, 0x8a, 0x76, 0x60,
	0x4b, 0xc8, 0x3a, 0xf6, 0x60, 0xa0, 0x84, 0x79, 0x54, 0x15, 0xbf, 0x61, 0x34, 0x71, 0x01, 0xdd,
	0x85, 0x5d, 0xbb, 0x7b, 0x86, 0xad, 0xc1, 0x80, 0xf4, 0x7b, 0xe7, 0x76, 0xc3, 0xc2, 0x0a, 0x2a,
	0xa2, 0x03, 0xb8, 0x63, 0xdd, 0x86, 0x94, 0x38, 0x49, 0xd7, 0x6c, 0x9c, 0xab, 0xf5, 0x1a, 0x77,
	0xbb, 0x63, 0x9e, 0xb7, 0x7a, 0xb8, 0x63, 0x35, 0x49, 0xff, 0xa9, 0x76, 0x61, 0x9d, 0x03, 0xc2,
	0xdb, 0x5e, 0x8b, 0x34, 0x2d, 0xd3, 0x69, 0x2b, 0x60, 0x03, 0xdd, 0x87, 0x83, 0x16, 0x36, 0xcf,
	0x3a, 0x56, 0xd7, 0x21, 0x4e, 0xaf, 0x47, 0x06, 0x1d, 0xf3, 0x5c, 0xf3, 0x01, 0x3a, 0x84, 0x3d,
	0xbb, 0x4f, 0xba, 0x3d, 0xdc, 0x31, 0xcf, 0xed, 0x57, 0xa6, 0x63, 0xf7, 0xba, 0x0a, 0x2b, 0xa3,
	0x7b, 0xb0, 0xef, 0x34, 0x6e, 0x07, 0x2b, 0x1a, 0xfc, 0xac, 0x63, 0x0e, 0x88, 0x83, 0x2d, 0x2b,
	0xe3, 0xcc, 0x26, 0x7a, 0x07, 0xee, 0x49, 0xcb, 0x2e, 0x19, 0xbc, 0xec, 0x92, 0x96, 0x8d, 0x07,
	0x4e, 0x46, 0xa1, 0xca, 0x9d, 0xe2, 0x3f, 0x7a, 0x6e, 0xe5, 0xde, 0x42, 0x0f, 0xe0, 0xae, 0x40,
	0x07, 0xb8, 0x41, 0x9e, 0x5d, 0x58, 0xdd, 0x46, 0x9b, 0x74, 0xd2, 0x40, 0x6e, 0xf3, 0xad, 0x05,
	0x8c, 0xad, 0xa6, 0x8d, 0xad, 0x86, 0x93, 0x01, 0x6b, 0x29, 0x68, 0x77, 0x5b, 0x3d, 0x82, 0xad,
	0x67, 0x19, 0x10, 0xa5, 0xa0, 0xd9, 0x6c, 0xe2, 0x25, 0x70, 0x27, 0xdd, 0xd5, 0xc1, 0x66, 0xc3,
	0xc2, 0xbd, 0x0b, 0xc7, 0xca, 0xc0, 0x77, 0x52, 0x97, 0xf1, 0xe0, 0x79, 0x93, 0x38, 0x2f, 0xfb,
	0x59, 0x74, 0x97, 0x9f, 0x58, 0x56, 0x4d, 0x1f, 0xf7, 0xfa, 0x16, 0x76, 0x6c, 0x6b, 0x90, 0xad,
	0x86, 0x3d, 0x1d, 0xaf, 0xde, 0x85, 0xc3, 0x53, 0xf4, 0xc2, 0xee, 0x36, 0x7b, 0x2f, 0x14, 0xb8,
	0xcf, 0xb7, 0xe6, 0xe0, 0xa0, 0x7f, 0x6e, 0x3b, 0xa4, 0x6d, 0x76, 0x9b, 0x83, 0xb6, 0xf9, 0xd4,
	0x52, 0xf0, 0x81, 0xb6, 0x7d, 0x61, 0x77, 0xc9, 0x2b, 0x0b, 0xf7, 0x84, 0x58, 0x81, 0x77, 0xd1,
	0x2e, 0xd4, 0x38, 0x68, 0x36, 0x9e, 0x12, 0x0b, 0xeb, 0xc2, 0x39, 0xe4, 0xee, 0x72, 0x71, 0xd3,
	0x74, 0x4c, 0x62, 0xb6, 0x1c, 0x0b, 0x93, 0x96, 0xad, 0x23, 0x7c, 0x0f, 0xbd, 0x0b, 0xef, 0xe8,
	0x04, 0xe9, 0xd4, 0x48, 0x25, 0xbe, 0x92, 0x4a, 0xf7, 0xd1, 0x87, 0xf0, 0x3e, 0x57, 0xb2, 0xbb,
	0xcf, 0xcd, 0x73, 0xbb, 0x49, 0xb0, 0x35, 0xe8, 0xf7, 0xba, 0x4d, 0xc1, 0xb4, 0x98, 0xcf, 0x07,
	0x7a, 0xb7, 0x8b, 0xae, 0xf5, 0x59, 0xdf, 0x6a, 0x38, 0x56, 0x53, 0xe4, 0x5d, 0xa2, 0x47, 0x1f,
	0xcd, 0xc4, 0x9d, 0x2a, 0x6f, 0x69, 0xde, 0x2b, 0xbc, 0xa0, 0xcd, 0x86, 0x48, 0x79, 0xb7, 0xd7,
	0xb5, 0xb6, 0x57, 0xf8, 0x21, 0x32, 0xc2, 0xbe, 0x85, 0x3b, 0xb6, 0x23, 0x7b, 0x2d, 0x23, 0x3e,
	0xef, 0x9d, 0xc9, 0x5e, 0xcb, 0xc8, 0x9a, 0x56, 0xf7, 0xe5, 0x76, 0x9e, 0x57, 0x7f, 0x46, 0xa8,
	0x0b, 0x63, 0xbb, 0x50, 0xff, 0x57, 0x0e, 0xf2, 0xa6, 0x17, 0xa0, 0xef, 0x0a, 0x17, 0x1a, 0x31,
	0xe5, 0x3f, 0xf3, 0xd0, 0xfc, 0x6e, 0xd4, 0xf3, 0xf1, 0x70, 0x67, 0xf9, 0xbe, 0xec, 0x24, 0x63,
	0x63, 0x45, 0xd9, 0x5d, 0x44, 0xc3, 0xff, 0xd2, 0xee, 0x54, 0xd8, 0xc9, 0x2b, 0x02, 0x1d, 0xdc,
	0x7a, 0x85, 0x71, 0xeb, 0xbb, 0xb7, 0x5f, 0x26, 0x92, 0xe3, 0xfb, 0x50, 0x92, 0xd3, 0x0c, 0xed,
	0xde, 0x9c, 0xd5, 0xdc, 0x7a, 0xef, 0x96, 0x89, 0x27, 0x4c, 0x4f, 0x0f, 0xff, 0xf4, 0xfa, 0x28,
	0xf7, 0xe7, 0xd7, 0x47, 0xb9, 0xbf, 0xbe, 0x3e, 0xca, 0xfd, 0xee, 0x6f, 0x47, 0x2b, 0xaf, 0xd6,
	0x2f, 0xdd, 0x40, 0xfc, 0xd3, 0xa2, 0xbf, 0xf2, 0x79, 0x49, 0x7c, 0x7c, 0xe7, 0x3f, 0x01, 0x00,
	0x00, 0xff, 0xff, 0x2d, 0x3b, 0xac, 0x70, 0xa8, 0x16, 0x00, 0x00,
}
