// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: acl.proto

package halproto

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import encoding_binary "encoding/binary"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// AclAction specifies all possible actions for ACL entries
type AclAction int32

const (
	AclAction_ACL_ACTION_NONE     AclAction = 0
	AclAction_ACL_ACTION_PERMIT   AclAction = 1
	AclAction_ACL_ACTION_LOG      AclAction = 2
	AclAction_ACL_ACTION_DENY     AclAction = 3
	AclAction_ACL_ACTION_REDIRECT AclAction = 4
)

var AclAction_name = map[int32]string{
	0: "ACL_ACTION_NONE",
	1: "ACL_ACTION_PERMIT",
	2: "ACL_ACTION_LOG",
	3: "ACL_ACTION_DENY",
	4: "ACL_ACTION_REDIRECT",
}
var AclAction_value = map[string]int32{
	"ACL_ACTION_NONE":     0,
	"ACL_ACTION_PERMIT":   1,
	"ACL_ACTION_LOG":      2,
	"ACL_ACTION_DENY":     3,
	"ACL_ACTION_REDIRECT": 4,
}

func (x AclAction) String() string {
	return proto.EnumName(AclAction_name, int32(x))
}
func (AclAction) EnumDescriptor() ([]byte, []int) { return fileDescriptorAcl, []int{0} }

// EthSelector has match criteria for non-IP packets
type EthSelector struct {
	EthType     uint32 `protobuf:"varint,1,opt,name=eth_type,json=ethType,proto3" json:"eth_type,omitempty" venice:constraints={range:0-65535}`
	EthTypeMask uint32 `protobuf:"varint,2,opt,name=eth_type_mask,json=ethTypeMask,proto3" json:"eth_type_mask,omitempty" venice:constraints={range:0-65535}`
	SrcMac      uint64 `protobuf:"varint,3,opt,name=src_mac,json=srcMac,proto3" json:"src_mac,omitempty" venice:constraints={range:0-0xffffffffffff}`
	SrcMacMask  uint64 `protobuf:"varint,4,opt,name=src_mac_mask,json=srcMacMask,proto3" json:"src_mac_mask,omitempty" venice:constraints={range:0-0xffffffffffff}`
	DstMac      uint64 `protobuf:"varint,5,opt,name=dst_mac,json=dstMac,proto3" json:"dst_mac,omitempty" venice:constraints={range:0-0xffffffffffff}`
	DstMacMask  uint64 `protobuf:"varint,6,opt,name=dst_mac_mask,json=dstMacMask,proto3" json:"dst_mac_mask,omitempty" venice:constraints={range:0-0xffffffffffff}`
}

func (m *EthSelector) Reset()                    { *m = EthSelector{} }
func (m *EthSelector) String() string            { return proto.CompactTextString(m) }
func (*EthSelector) ProtoMessage()               {}
func (*EthSelector) Descriptor() ([]byte, []int) { return fileDescriptorAcl, []int{0} }

func (m *EthSelector) GetEthType() uint32 {
	if m != nil {
		return m.EthType
	}
	return 0
}

func (m *EthSelector) GetEthTypeMask() uint32 {
	if m != nil {
		return m.EthTypeMask
	}
	return 0
}

func (m *EthSelector) GetSrcMac() uint64 {
	if m != nil {
		return m.SrcMac
	}
	return 0
}

func (m *EthSelector) GetSrcMacMask() uint64 {
	if m != nil {
		return m.SrcMacMask
	}
	return 0
}

func (m *EthSelector) GetDstMac() uint64 {
	if m != nil {
		return m.DstMac
	}
	return 0
}

func (m *EthSelector) GetDstMacMask() uint64 {
	if m != nil {
		return m.DstMacMask
	}
	return 0
}

// UDPSelector is used to specify match criteria for UDP traffic
type UDPSelector struct {
	SrcPortRange *L4PortRange `protobuf:"bytes,1,opt,name=src_port_range,json=srcPortRange" json:"src_port_range,omitempty"`
	DstPortRange *L4PortRange `protobuf:"bytes,2,opt,name=dst_port_range,json=dstPortRange" json:"dst_port_range,omitempty"`
}

func (m *UDPSelector) Reset()                    { *m = UDPSelector{} }
func (m *UDPSelector) String() string            { return proto.CompactTextString(m) }
func (*UDPSelector) ProtoMessage()               {}
func (*UDPSelector) Descriptor() ([]byte, []int) { return fileDescriptorAcl, []int{1} }

func (m *UDPSelector) GetSrcPortRange() *L4PortRange {
	if m != nil {
		return m.SrcPortRange
	}
	return nil
}

func (m *UDPSelector) GetDstPortRange() *L4PortRange {
	if m != nil {
		return m.DstPortRange
	}
	return nil
}

// TCPSelector is used to specify match criteria for TCP traffic
type TCPSelector struct {
	// Types that are valid to be assigned to TcpSyn:
	//	*TCPSelector_TcpSynSet
	//	*TCPSelector_TcpSynClear
	TcpSyn isTCPSelector_TcpSyn `protobuf_oneof:"tcp_syn"`
	// Types that are valid to be assigned to TcpAck:
	//	*TCPSelector_TcpAckSet
	//	*TCPSelector_TcpAckClear
	TcpAck isTCPSelector_TcpAck `protobuf_oneof:"tcp_ack"`
	// Types that are valid to be assigned to TcpFin:
	//	*TCPSelector_TcpFinSet
	//	*TCPSelector_TcpFinClear
	TcpFin isTCPSelector_TcpFin `protobuf_oneof:"tcp_fin"`
	// Types that are valid to be assigned to TcpRst:
	//	*TCPSelector_TcpRstSet
	//	*TCPSelector_TcpRstClear
	TcpRst isTCPSelector_TcpRst `protobuf_oneof:"tcp_rst"`
	// Types that are valid to be assigned to TcpUrg:
	//	*TCPSelector_TcpUrgSet
	//	*TCPSelector_TcpUrgClear
	TcpUrg       isTCPSelector_TcpUrg `protobuf_oneof:"tcp_urg"`
	SrcPortRange *L4PortRange         `protobuf:"bytes,11,opt,name=src_port_range,json=srcPortRange" json:"src_port_range,omitempty"`
	DstPortRange *L4PortRange         `protobuf:"bytes,12,opt,name=dst_port_range,json=dstPortRange" json:"dst_port_range,omitempty"`
}

func (m *TCPSelector) Reset()                    { *m = TCPSelector{} }
func (m *TCPSelector) String() string            { return proto.CompactTextString(m) }
func (*TCPSelector) ProtoMessage()               {}
func (*TCPSelector) Descriptor() ([]byte, []int) { return fileDescriptorAcl, []int{2} }

type isTCPSelector_TcpSyn interface {
	isTCPSelector_TcpSyn()
	MarshalTo([]byte) (int, error)
	Size() int
}
type isTCPSelector_TcpAck interface {
	isTCPSelector_TcpAck()
	MarshalTo([]byte) (int, error)
	Size() int
}
type isTCPSelector_TcpFin interface {
	isTCPSelector_TcpFin()
	MarshalTo([]byte) (int, error)
	Size() int
}
type isTCPSelector_TcpRst interface {
	isTCPSelector_TcpRst()
	MarshalTo([]byte) (int, error)
	Size() int
}
type isTCPSelector_TcpUrg interface {
	isTCPSelector_TcpUrg()
	MarshalTo([]byte) (int, error)
	Size() int
}

type TCPSelector_TcpSynSet struct {
	TcpSynSet bool `protobuf:"varint,1,opt,name=tcp_syn_set,json=tcpSynSet,proto3,oneof"`
}
type TCPSelector_TcpSynClear struct {
	TcpSynClear bool `protobuf:"varint,2,opt,name=tcp_syn_clear,json=tcpSynClear,proto3,oneof"`
}
type TCPSelector_TcpAckSet struct {
	TcpAckSet bool `protobuf:"varint,3,opt,name=tcp_ack_set,json=tcpAckSet,proto3,oneof"`
}
type TCPSelector_TcpAckClear struct {
	TcpAckClear bool `protobuf:"varint,4,opt,name=tcp_ack_clear,json=tcpAckClear,proto3,oneof"`
}
type TCPSelector_TcpFinSet struct {
	TcpFinSet bool `protobuf:"varint,5,opt,name=tcp_fin_set,json=tcpFinSet,proto3,oneof"`
}
type TCPSelector_TcpFinClear struct {
	TcpFinClear bool `protobuf:"varint,6,opt,name=tcp_fin_clear,json=tcpFinClear,proto3,oneof"`
}
type TCPSelector_TcpRstSet struct {
	TcpRstSet bool `protobuf:"varint,7,opt,name=tcp_rst_set,json=tcpRstSet,proto3,oneof"`
}
type TCPSelector_TcpRstClear struct {
	TcpRstClear bool `protobuf:"varint,8,opt,name=tcp_rst_clear,json=tcpRstClear,proto3,oneof"`
}
type TCPSelector_TcpUrgSet struct {
	TcpUrgSet bool `protobuf:"varint,9,opt,name=tcp_urg_set,json=tcpUrgSet,proto3,oneof"`
}
type TCPSelector_TcpUrgClear struct {
	TcpUrgClear bool `protobuf:"varint,10,opt,name=tcp_urg_clear,json=tcpUrgClear,proto3,oneof"`
}

func (*TCPSelector_TcpSynSet) isTCPSelector_TcpSyn()   {}
func (*TCPSelector_TcpSynClear) isTCPSelector_TcpSyn() {}
func (*TCPSelector_TcpAckSet) isTCPSelector_TcpAck()   {}
func (*TCPSelector_TcpAckClear) isTCPSelector_TcpAck() {}
func (*TCPSelector_TcpFinSet) isTCPSelector_TcpFin()   {}
func (*TCPSelector_TcpFinClear) isTCPSelector_TcpFin() {}
func (*TCPSelector_TcpRstSet) isTCPSelector_TcpRst()   {}
func (*TCPSelector_TcpRstClear) isTCPSelector_TcpRst() {}
func (*TCPSelector_TcpUrgSet) isTCPSelector_TcpUrg()   {}
func (*TCPSelector_TcpUrgClear) isTCPSelector_TcpUrg() {}

func (m *TCPSelector) GetTcpSyn() isTCPSelector_TcpSyn {
	if m != nil {
		return m.TcpSyn
	}
	return nil
}
func (m *TCPSelector) GetTcpAck() isTCPSelector_TcpAck {
	if m != nil {
		return m.TcpAck
	}
	return nil
}
func (m *TCPSelector) GetTcpFin() isTCPSelector_TcpFin {
	if m != nil {
		return m.TcpFin
	}
	return nil
}
func (m *TCPSelector) GetTcpRst() isTCPSelector_TcpRst {
	if m != nil {
		return m.TcpRst
	}
	return nil
}
func (m *TCPSelector) GetTcpUrg() isTCPSelector_TcpUrg {
	if m != nil {
		return m.TcpUrg
	}
	return nil
}

func (m *TCPSelector) GetTcpSynSet() bool {
	if x, ok := m.GetTcpSyn().(*TCPSelector_TcpSynSet); ok {
		return x.TcpSynSet
	}
	return false
}

func (m *TCPSelector) GetTcpSynClear() bool {
	if x, ok := m.GetTcpSyn().(*TCPSelector_TcpSynClear); ok {
		return x.TcpSynClear
	}
	return false
}

func (m *TCPSelector) GetTcpAckSet() bool {
	if x, ok := m.GetTcpAck().(*TCPSelector_TcpAckSet); ok {
		return x.TcpAckSet
	}
	return false
}

func (m *TCPSelector) GetTcpAckClear() bool {
	if x, ok := m.GetTcpAck().(*TCPSelector_TcpAckClear); ok {
		return x.TcpAckClear
	}
	return false
}

func (m *TCPSelector) GetTcpFinSet() bool {
	if x, ok := m.GetTcpFin().(*TCPSelector_TcpFinSet); ok {
		return x.TcpFinSet
	}
	return false
}

func (m *TCPSelector) GetTcpFinClear() bool {
	if x, ok := m.GetTcpFin().(*TCPSelector_TcpFinClear); ok {
		return x.TcpFinClear
	}
	return false
}

func (m *TCPSelector) GetTcpRstSet() bool {
	if x, ok := m.GetTcpRst().(*TCPSelector_TcpRstSet); ok {
		return x.TcpRstSet
	}
	return false
}

func (m *TCPSelector) GetTcpRstClear() bool {
	if x, ok := m.GetTcpRst().(*TCPSelector_TcpRstClear); ok {
		return x.TcpRstClear
	}
	return false
}

func (m *TCPSelector) GetTcpUrgSet() bool {
	if x, ok := m.GetTcpUrg().(*TCPSelector_TcpUrgSet); ok {
		return x.TcpUrgSet
	}
	return false
}

func (m *TCPSelector) GetTcpUrgClear() bool {
	if x, ok := m.GetTcpUrg().(*TCPSelector_TcpUrgClear); ok {
		return x.TcpUrgClear
	}
	return false
}

func (m *TCPSelector) GetSrcPortRange() *L4PortRange {
	if m != nil {
		return m.SrcPortRange
	}
	return nil
}

func (m *TCPSelector) GetDstPortRange() *L4PortRange {
	if m != nil {
		return m.DstPortRange
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*TCPSelector) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _TCPSelector_OneofMarshaler, _TCPSelector_OneofUnmarshaler, _TCPSelector_OneofSizer, []interface{}{
		(*TCPSelector_TcpSynSet)(nil),
		(*TCPSelector_TcpSynClear)(nil),
		(*TCPSelector_TcpAckSet)(nil),
		(*TCPSelector_TcpAckClear)(nil),
		(*TCPSelector_TcpFinSet)(nil),
		(*TCPSelector_TcpFinClear)(nil),
		(*TCPSelector_TcpRstSet)(nil),
		(*TCPSelector_TcpRstClear)(nil),
		(*TCPSelector_TcpUrgSet)(nil),
		(*TCPSelector_TcpUrgClear)(nil),
	}
}

func _TCPSelector_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*TCPSelector)
	// tcp_syn
	switch x := m.TcpSyn.(type) {
	case *TCPSelector_TcpSynSet:
		t := uint64(0)
		if x.TcpSynSet {
			t = 1
		}
		_ = b.EncodeVarint(1<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case *TCPSelector_TcpSynClear:
		t := uint64(0)
		if x.TcpSynClear {
			t = 1
		}
		_ = b.EncodeVarint(2<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case nil:
	default:
		return fmt.Errorf("TCPSelector.TcpSyn has unexpected type %T", x)
	}
	// tcp_ack
	switch x := m.TcpAck.(type) {
	case *TCPSelector_TcpAckSet:
		t := uint64(0)
		if x.TcpAckSet {
			t = 1
		}
		_ = b.EncodeVarint(3<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case *TCPSelector_TcpAckClear:
		t := uint64(0)
		if x.TcpAckClear {
			t = 1
		}
		_ = b.EncodeVarint(4<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case nil:
	default:
		return fmt.Errorf("TCPSelector.TcpAck has unexpected type %T", x)
	}
	// tcp_fin
	switch x := m.TcpFin.(type) {
	case *TCPSelector_TcpFinSet:
		t := uint64(0)
		if x.TcpFinSet {
			t = 1
		}
		_ = b.EncodeVarint(5<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case *TCPSelector_TcpFinClear:
		t := uint64(0)
		if x.TcpFinClear {
			t = 1
		}
		_ = b.EncodeVarint(6<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case nil:
	default:
		return fmt.Errorf("TCPSelector.TcpFin has unexpected type %T", x)
	}
	// tcp_rst
	switch x := m.TcpRst.(type) {
	case *TCPSelector_TcpRstSet:
		t := uint64(0)
		if x.TcpRstSet {
			t = 1
		}
		_ = b.EncodeVarint(7<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case *TCPSelector_TcpRstClear:
		t := uint64(0)
		if x.TcpRstClear {
			t = 1
		}
		_ = b.EncodeVarint(8<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case nil:
	default:
		return fmt.Errorf("TCPSelector.TcpRst has unexpected type %T", x)
	}
	// tcp_urg
	switch x := m.TcpUrg.(type) {
	case *TCPSelector_TcpUrgSet:
		t := uint64(0)
		if x.TcpUrgSet {
			t = 1
		}
		_ = b.EncodeVarint(9<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case *TCPSelector_TcpUrgClear:
		t := uint64(0)
		if x.TcpUrgClear {
			t = 1
		}
		_ = b.EncodeVarint(10<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case nil:
	default:
		return fmt.Errorf("TCPSelector.TcpUrg has unexpected type %T", x)
	}
	return nil
}

func _TCPSelector_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*TCPSelector)
	switch tag {
	case 1: // tcp_syn.tcp_syn_set
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.TcpSyn = &TCPSelector_TcpSynSet{x != 0}
		return true, err
	case 2: // tcp_syn.tcp_syn_clear
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.TcpSyn = &TCPSelector_TcpSynClear{x != 0}
		return true, err
	case 3: // tcp_ack.tcp_ack_set
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.TcpAck = &TCPSelector_TcpAckSet{x != 0}
		return true, err
	case 4: // tcp_ack.tcp_ack_clear
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.TcpAck = &TCPSelector_TcpAckClear{x != 0}
		return true, err
	case 5: // tcp_fin.tcp_fin_set
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.TcpFin = &TCPSelector_TcpFinSet{x != 0}
		return true, err
	case 6: // tcp_fin.tcp_fin_clear
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.TcpFin = &TCPSelector_TcpFinClear{x != 0}
		return true, err
	case 7: // tcp_rst.tcp_rst_set
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.TcpRst = &TCPSelector_TcpRstSet{x != 0}
		return true, err
	case 8: // tcp_rst.tcp_rst_clear
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.TcpRst = &TCPSelector_TcpRstClear{x != 0}
		return true, err
	case 9: // tcp_urg.tcp_urg_set
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.TcpUrg = &TCPSelector_TcpUrgSet{x != 0}
		return true, err
	case 10: // tcp_urg.tcp_urg_clear
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.TcpUrg = &TCPSelector_TcpUrgClear{x != 0}
		return true, err
	default:
		return false, nil
	}
}

func _TCPSelector_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*TCPSelector)
	// tcp_syn
	switch x := m.TcpSyn.(type) {
	case *TCPSelector_TcpSynSet:
		n += proto.SizeVarint(1<<3 | proto.WireVarint)
		n += 1
	case *TCPSelector_TcpSynClear:
		n += proto.SizeVarint(2<<3 | proto.WireVarint)
		n += 1
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// tcp_ack
	switch x := m.TcpAck.(type) {
	case *TCPSelector_TcpAckSet:
		n += proto.SizeVarint(3<<3 | proto.WireVarint)
		n += 1
	case *TCPSelector_TcpAckClear:
		n += proto.SizeVarint(4<<3 | proto.WireVarint)
		n += 1
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// tcp_fin
	switch x := m.TcpFin.(type) {
	case *TCPSelector_TcpFinSet:
		n += proto.SizeVarint(5<<3 | proto.WireVarint)
		n += 1
	case *TCPSelector_TcpFinClear:
		n += proto.SizeVarint(6<<3 | proto.WireVarint)
		n += 1
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// tcp_rst
	switch x := m.TcpRst.(type) {
	case *TCPSelector_TcpRstSet:
		n += proto.SizeVarint(7<<3 | proto.WireVarint)
		n += 1
	case *TCPSelector_TcpRstClear:
		n += proto.SizeVarint(8<<3 | proto.WireVarint)
		n += 1
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// tcp_urg
	switch x := m.TcpUrg.(type) {
	case *TCPSelector_TcpUrgSet:
		n += proto.SizeVarint(9<<3 | proto.WireVarint)
		n += 1
	case *TCPSelector_TcpUrgClear:
		n += proto.SizeVarint(10<<3 | proto.WireVarint)
		n += 1
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// ICMPSelector has match criteria for ICMP packets
type ICMPSelector struct {
	IcmpCode     uint32 `protobuf:"varint,1,opt,name=icmp_code,json=icmpCode,proto3" json:"icmp_code,omitempty" venice:constraints={range:0-0xff}`
	IcmpCodeMask uint32 `protobuf:"varint,2,opt,name=icmp_code_mask,json=icmpCodeMask,proto3" json:"icmp_code_mask,omitempty" venice:constraints={range:0-0xff}`
	IcmpType     uint32 `protobuf:"varint,3,opt,name=icmp_type,json=icmpType,proto3" json:"icmp_type,omitempty" venice:constraints={range:0-0xff}`
	IcmpTypeMask uint32 `protobuf:"varint,4,opt,name=icmp_type_mask,json=icmpTypeMask,proto3" json:"icmp_type_mask,omitempty" venice:constraints={range:0-0xff}`
}

func (m *ICMPSelector) Reset()                    { *m = ICMPSelector{} }
func (m *ICMPSelector) String() string            { return proto.CompactTextString(m) }
func (*ICMPSelector) ProtoMessage()               {}
func (*ICMPSelector) Descriptor() ([]byte, []int) { return fileDescriptorAcl, []int{3} }

func (m *ICMPSelector) GetIcmpCode() uint32 {
	if m != nil {
		return m.IcmpCode
	}
	return 0
}

func (m *ICMPSelector) GetIcmpCodeMask() uint32 {
	if m != nil {
		return m.IcmpCodeMask
	}
	return 0
}

func (m *ICMPSelector) GetIcmpType() uint32 {
	if m != nil {
		return m.IcmpType
	}
	return 0
}

func (m *ICMPSelector) GetIcmpTypeMask() uint32 {
	if m != nil {
		return m.IcmpTypeMask
	}
	return 0
}

// IPSelector has match criteria for selecting IP packets
type IPSelector struct {
	IpAf      IPAddressFamily `protobuf:"varint,1,opt,name=ip_af,json=ipAf,proto3,enum=types.IPAddressFamily" json:"ip_af,omitempty"`
	SrcPrefix *IPPrefix       `protobuf:"bytes,2,opt,name=src_prefix,json=srcPrefix" json:"src_prefix,omitempty"`
	DstPrefix *IPPrefix       `protobuf:"bytes,3,opt,name=dst_prefix,json=dstPrefix" json:"dst_prefix,omitempty"`
	// Types that are valid to be assigned to L4Selectors:
	//	*IPSelector_IpProtocol
	//	*IPSelector_IcmpSelector
	//	*IPSelector_UdpSelector
	//	*IPSelector_TcpSelector
	L4Selectors isIPSelector_L4Selectors `protobuf_oneof:"l4_selectors"`
}

func (m *IPSelector) Reset()                    { *m = IPSelector{} }
func (m *IPSelector) String() string            { return proto.CompactTextString(m) }
func (*IPSelector) ProtoMessage()               {}
func (*IPSelector) Descriptor() ([]byte, []int) { return fileDescriptorAcl, []int{4} }

type isIPSelector_L4Selectors interface {
	isIPSelector_L4Selectors()
	MarshalTo([]byte) (int, error)
	Size() int
}

type IPSelector_IpProtocol struct {
	IpProtocol IPProtocol `protobuf:"varint,4,opt,name=ip_protocol,json=ipProtocol,proto3,enum=types.IPProtocol,oneof"`
}
type IPSelector_IcmpSelector struct {
	IcmpSelector *ICMPSelector `protobuf:"bytes,5,opt,name=icmp_selector,json=icmpSelector,oneof"`
}
type IPSelector_UdpSelector struct {
	UdpSelector *UDPSelector `protobuf:"bytes,6,opt,name=udp_selector,json=udpSelector,oneof"`
}
type IPSelector_TcpSelector struct {
	TcpSelector *TCPSelector `protobuf:"bytes,7,opt,name=tcp_selector,json=tcpSelector,oneof"`
}

func (*IPSelector_IpProtocol) isIPSelector_L4Selectors()   {}
func (*IPSelector_IcmpSelector) isIPSelector_L4Selectors() {}
func (*IPSelector_UdpSelector) isIPSelector_L4Selectors()  {}
func (*IPSelector_TcpSelector) isIPSelector_L4Selectors()  {}

func (m *IPSelector) GetL4Selectors() isIPSelector_L4Selectors {
	if m != nil {
		return m.L4Selectors
	}
	return nil
}

func (m *IPSelector) GetIpAf() IPAddressFamily {
	if m != nil {
		return m.IpAf
	}
	return IPAddressFamily_IP_AF_NONE
}

func (m *IPSelector) GetSrcPrefix() *IPPrefix {
	if m != nil {
		return m.SrcPrefix
	}
	return nil
}

func (m *IPSelector) GetDstPrefix() *IPPrefix {
	if m != nil {
		return m.DstPrefix
	}
	return nil
}

func (m *IPSelector) GetIpProtocol() IPProtocol {
	if x, ok := m.GetL4Selectors().(*IPSelector_IpProtocol); ok {
		return x.IpProtocol
	}
	return IPProtocol_IPPROTO_NONE
}

func (m *IPSelector) GetIcmpSelector() *ICMPSelector {
	if x, ok := m.GetL4Selectors().(*IPSelector_IcmpSelector); ok {
		return x.IcmpSelector
	}
	return nil
}

func (m *IPSelector) GetUdpSelector() *UDPSelector {
	if x, ok := m.GetL4Selectors().(*IPSelector_UdpSelector); ok {
		return x.UdpSelector
	}
	return nil
}

func (m *IPSelector) GetTcpSelector() *TCPSelector {
	if x, ok := m.GetL4Selectors().(*IPSelector_TcpSelector); ok {
		return x.TcpSelector
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*IPSelector) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _IPSelector_OneofMarshaler, _IPSelector_OneofUnmarshaler, _IPSelector_OneofSizer, []interface{}{
		(*IPSelector_IpProtocol)(nil),
		(*IPSelector_IcmpSelector)(nil),
		(*IPSelector_UdpSelector)(nil),
		(*IPSelector_TcpSelector)(nil),
	}
}

func _IPSelector_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*IPSelector)
	// l4_selectors
	switch x := m.L4Selectors.(type) {
	case *IPSelector_IpProtocol:
		_ = b.EncodeVarint(4<<3 | proto.WireVarint)
		_ = b.EncodeVarint(uint64(x.IpProtocol))
	case *IPSelector_IcmpSelector:
		_ = b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.IcmpSelector); err != nil {
			return err
		}
	case *IPSelector_UdpSelector:
		_ = b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.UdpSelector); err != nil {
			return err
		}
	case *IPSelector_TcpSelector:
		_ = b.EncodeVarint(7<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.TcpSelector); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("IPSelector.L4Selectors has unexpected type %T", x)
	}
	return nil
}

func _IPSelector_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*IPSelector)
	switch tag {
	case 4: // l4_selectors.ip_protocol
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.L4Selectors = &IPSelector_IpProtocol{IPProtocol(x)}
		return true, err
	case 5: // l4_selectors.icmp_selector
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ICMPSelector)
		err := b.DecodeMessage(msg)
		m.L4Selectors = &IPSelector_IcmpSelector{msg}
		return true, err
	case 6: // l4_selectors.udp_selector
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(UDPSelector)
		err := b.DecodeMessage(msg)
		m.L4Selectors = &IPSelector_UdpSelector{msg}
		return true, err
	case 7: // l4_selectors.tcp_selector
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TCPSelector)
		err := b.DecodeMessage(msg)
		m.L4Selectors = &IPSelector_TcpSelector{msg}
		return true, err
	default:
		return false, nil
	}
}

func _IPSelector_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*IPSelector)
	// l4_selectors
	switch x := m.L4Selectors.(type) {
	case *IPSelector_IpProtocol:
		n += proto.SizeVarint(4<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.IpProtocol))
	case *IPSelector_IcmpSelector:
		s := proto.Size(x.IcmpSelector)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *IPSelector_UdpSelector:
		s := proto.Size(x.UdpSelector)
		n += proto.SizeVarint(6<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *IPSelector_TcpSelector:
		s := proto.Size(x.TcpSelector)
		n += proto.SizeVarint(7<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// AclInternalSelector has match criteria which are for internal use only with
// DOL/testing infra
// For production builds this needs to be removed
// TODO: REMOVE
type AclInternalSelector struct {
	FlowMiss        bool         `protobuf:"varint,1,opt,name=flow_miss,json=flowMiss,proto3" json:"flow_miss,omitempty"`
	OuterDstMac     uint64       `protobuf:"varint,2,opt,name=outer_dst_mac,json=outerDstMac,proto3" json:"outer_dst_mac,omitempty" venice:constraints={range:0-0xffffffffffff}`
	IpOptions       bool         `protobuf:"varint,3,opt,name=ip_options,json=ipOptions,proto3" json:"ip_options,omitempty"`
	IpFrag          bool         `protobuf:"varint,4,opt,name=ip_frag,json=ipFrag,proto3" json:"ip_frag,omitempty"`
	DropReasons     *DropReasons `protobuf:"bytes,5,opt,name=drop_reasons,json=dropReasons" json:"drop_reasons,omitempty"`
	TunnelTerminate bool         `protobuf:"varint,6,opt,name=tunnel_terminate,json=tunnelTerminate,proto3" json:"tunnel_terminate,omitempty"`
	Direction       bool         `protobuf:"varint,7,opt,name=direction,proto3" json:"direction,omitempty"`
	FromCpu         bool         `protobuf:"varint,8,opt,name=from_cpu,json=fromCpu,proto3" json:"from_cpu,omitempty"`
	NoDrop          bool         `protobuf:"varint,9,opt,name=no_drop,json=noDrop,proto3" json:"no_drop,omitempty"`
}

func (m *AclInternalSelector) Reset()                    { *m = AclInternalSelector{} }
func (m *AclInternalSelector) String() string            { return proto.CompactTextString(m) }
func (*AclInternalSelector) ProtoMessage()               {}
func (*AclInternalSelector) Descriptor() ([]byte, []int) { return fileDescriptorAcl, []int{5} }

func (m *AclInternalSelector) GetFlowMiss() bool {
	if m != nil {
		return m.FlowMiss
	}
	return false
}

func (m *AclInternalSelector) GetOuterDstMac() uint64 {
	if m != nil {
		return m.OuterDstMac
	}
	return 0
}

func (m *AclInternalSelector) GetIpOptions() bool {
	if m != nil {
		return m.IpOptions
	}
	return false
}

func (m *AclInternalSelector) GetIpFrag() bool {
	if m != nil {
		return m.IpFrag
	}
	return false
}

func (m *AclInternalSelector) GetDropReasons() *DropReasons {
	if m != nil {
		return m.DropReasons
	}
	return nil
}

func (m *AclInternalSelector) GetTunnelTerminate() bool {
	if m != nil {
		return m.TunnelTerminate
	}
	return false
}

func (m *AclInternalSelector) GetDirection() bool {
	if m != nil {
		return m.Direction
	}
	return false
}

func (m *AclInternalSelector) GetFromCpu() bool {
	if m != nil {
		return m.FromCpu
	}
	return false
}

func (m *AclInternalSelector) GetNoDrop() bool {
	if m != nil {
		return m.NoDrop
	}
	return false
}

// AclInternalActionInfo has action parameters for internal use only with
// DOL/testing infra
// For production builds this needs to be removed
// TODO: REMOVE
type AclInternalActionInfo struct {
	MacSaRewriteEn bool       `protobuf:"varint,1,opt,name=mac_sa_rewrite_en,json=macSaRewriteEn,proto3" json:"mac_sa_rewrite_en,omitempty"`
	MacSa          uint64     `protobuf:"varint,2,opt,name=mac_sa,json=macSa,proto3" json:"mac_sa,omitempty" venice:constraints={range:0-0xffffffffffff}`
	MacDaRewriteEn bool       `protobuf:"varint,3,opt,name=mac_da_rewrite_en,json=macDaRewriteEn,proto3" json:"mac_da_rewrite_en,omitempty"`
	MacDa          uint64     `protobuf:"varint,4,opt,name=mac_da,json=macDa,proto3" json:"mac_da,omitempty" venice:constraints={range:0-0xffffffffffff}`
	TtlDecEn       bool       `protobuf:"varint,5,opt,name=ttl_dec_en,json=ttlDecEn,proto3" json:"ttl_dec_en,omitempty"`
	EncapInfo      *EncapInfo `protobuf:"bytes,6,opt,name=encap_info,json=encapInfo" json:"encap_info,omitempty"`
	Qid            CpucbId    `protobuf:"varint,7,opt,name=qid,proto3,enum=types.CpucbId" json:"qid,omitempty"`
	QidValid       bool       `protobuf:"varint,8,opt,name=qid_valid,json=qidValid,proto3" json:"qid_valid,omitempty"`
}

func (m *AclInternalActionInfo) Reset()                    { *m = AclInternalActionInfo{} }
func (m *AclInternalActionInfo) String() string            { return proto.CompactTextString(m) }
func (*AclInternalActionInfo) ProtoMessage()               {}
func (*AclInternalActionInfo) Descriptor() ([]byte, []int) { return fileDescriptorAcl, []int{6} }

func (m *AclInternalActionInfo) GetMacSaRewriteEn() bool {
	if m != nil {
		return m.MacSaRewriteEn
	}
	return false
}

func (m *AclInternalActionInfo) GetMacSa() uint64 {
	if m != nil {
		return m.MacSa
	}
	return 0
}

func (m *AclInternalActionInfo) GetMacDaRewriteEn() bool {
	if m != nil {
		return m.MacDaRewriteEn
	}
	return false
}

func (m *AclInternalActionInfo) GetMacDa() uint64 {
	if m != nil {
		return m.MacDa
	}
	return 0
}

func (m *AclInternalActionInfo) GetTtlDecEn() bool {
	if m != nil {
		return m.TtlDecEn
	}
	return false
}

func (m *AclInternalActionInfo) GetEncapInfo() *EncapInfo {
	if m != nil {
		return m.EncapInfo
	}
	return nil
}

func (m *AclInternalActionInfo) GetQid() CpucbId {
	if m != nil {
		return m.Qid
	}
	return CpucbId_CPUCB_ID_FLOWMISS
}

func (m *AclInternalActionInfo) GetQidValid() bool {
	if m != nil {
		return m.QidValid
	}
	return false
}

// AclSelector has all the match criteria for an ACL entry
type AclSelector struct {
	SrcIfKeyHandle *InterfaceKeyHandle `protobuf:"bytes,1,opt,name=src_if_key_handle,json=srcIfKeyHandle" json:"src_if_key_handle,omitempty" venice:ref`
	DstIfKeyHandle *InterfaceKeyHandle `protobuf:"bytes,2,opt,name=dst_if_key_handle,json=dstIfKeyHandle" json:"dst_if_key_handle,omitempty" venice:ref`
	// Types that are valid to be assigned to SegSelector:
	//	*AclSelector_VrfKeyHandle
	//	*AclSelector_L2SegmentKeyHandle
	SegSelector isAclSelector_SegSelector `protobuf_oneof:"seg_selector"`
	// Types that are valid to be assigned to PktSelector:
	//	*AclSelector_EthSelector
	//	*AclSelector_IpSelector
	PktSelector isAclSelector_PktSelector `protobuf_oneof:"pkt_selector"`
	// TODO: REMOVE
	InternalKey  *AclInternalSelector `protobuf:"bytes,7,opt,name=internal_key,json=internalKey" json:"internal_key,omitempty"`
	InternalMask *AclInternalSelector `protobuf:"bytes,8,opt,name=internal_mask,json=internalMask" json:"internal_mask,omitempty"`
}

func (m *AclSelector) Reset()                    { *m = AclSelector{} }
func (m *AclSelector) String() string            { return proto.CompactTextString(m) }
func (*AclSelector) ProtoMessage()               {}
func (*AclSelector) Descriptor() ([]byte, []int) { return fileDescriptorAcl, []int{7} }

type isAclSelector_SegSelector interface {
	isAclSelector_SegSelector()
	MarshalTo([]byte) (int, error)
	Size() int
}
type isAclSelector_PktSelector interface {
	isAclSelector_PktSelector()
	MarshalTo([]byte) (int, error)
	Size() int
}

type AclSelector_VrfKeyHandle struct {
	VrfKeyHandle *VrfKeyHandle `protobuf:"bytes,3,opt,name=vrf_key_handle,json=vrfKeyHandle,oneof"`
}
type AclSelector_L2SegmentKeyHandle struct {
	L2SegmentKeyHandle *L2SegmentKeyHandle `protobuf:"bytes,4,opt,name=l2segment_key_handle,json=l2segmentKeyHandle,oneof"`
}
type AclSelector_EthSelector struct {
	EthSelector *EthSelector `protobuf:"bytes,5,opt,name=eth_selector,json=ethSelector,oneof"`
}
type AclSelector_IpSelector struct {
	IpSelector *IPSelector `protobuf:"bytes,6,opt,name=ip_selector,json=ipSelector,oneof"`
}

func (*AclSelector_VrfKeyHandle) isAclSelector_SegSelector()       {}
func (*AclSelector_L2SegmentKeyHandle) isAclSelector_SegSelector() {}
func (*AclSelector_EthSelector) isAclSelector_PktSelector()        {}
func (*AclSelector_IpSelector) isAclSelector_PktSelector()         {}

func (m *AclSelector) GetSegSelector() isAclSelector_SegSelector {
	if m != nil {
		return m.SegSelector
	}
	return nil
}
func (m *AclSelector) GetPktSelector() isAclSelector_PktSelector {
	if m != nil {
		return m.PktSelector
	}
	return nil
}

func (m *AclSelector) GetSrcIfKeyHandle() *InterfaceKeyHandle {
	if m != nil {
		return m.SrcIfKeyHandle
	}
	return nil
}

func (m *AclSelector) GetDstIfKeyHandle() *InterfaceKeyHandle {
	if m != nil {
		return m.DstIfKeyHandle
	}
	return nil
}

func (m *AclSelector) GetVrfKeyHandle() *VrfKeyHandle {
	if x, ok := m.GetSegSelector().(*AclSelector_VrfKeyHandle); ok {
		return x.VrfKeyHandle
	}
	return nil
}

func (m *AclSelector) GetL2SegmentKeyHandle() *L2SegmentKeyHandle {
	if x, ok := m.GetSegSelector().(*AclSelector_L2SegmentKeyHandle); ok {
		return x.L2SegmentKeyHandle
	}
	return nil
}

func (m *AclSelector) GetEthSelector() *EthSelector {
	if x, ok := m.GetPktSelector().(*AclSelector_EthSelector); ok {
		return x.EthSelector
	}
	return nil
}

func (m *AclSelector) GetIpSelector() *IPSelector {
	if x, ok := m.GetPktSelector().(*AclSelector_IpSelector); ok {
		return x.IpSelector
	}
	return nil
}

func (m *AclSelector) GetInternalKey() *AclInternalSelector {
	if m != nil {
		return m.InternalKey
	}
	return nil
}

func (m *AclSelector) GetInternalMask() *AclInternalSelector {
	if m != nil {
		return m.InternalMask
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*AclSelector) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _AclSelector_OneofMarshaler, _AclSelector_OneofUnmarshaler, _AclSelector_OneofSizer, []interface{}{
		(*AclSelector_VrfKeyHandle)(nil),
		(*AclSelector_L2SegmentKeyHandle)(nil),
		(*AclSelector_EthSelector)(nil),
		(*AclSelector_IpSelector)(nil),
	}
}

func _AclSelector_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*AclSelector)
	// seg_selector
	switch x := m.SegSelector.(type) {
	case *AclSelector_VrfKeyHandle:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.VrfKeyHandle); err != nil {
			return err
		}
	case *AclSelector_L2SegmentKeyHandle:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.L2SegmentKeyHandle); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("AclSelector.SegSelector has unexpected type %T", x)
	}
	// pkt_selector
	switch x := m.PktSelector.(type) {
	case *AclSelector_EthSelector:
		_ = b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.EthSelector); err != nil {
			return err
		}
	case *AclSelector_IpSelector:
		_ = b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.IpSelector); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("AclSelector.PktSelector has unexpected type %T", x)
	}
	return nil
}

func _AclSelector_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*AclSelector)
	switch tag {
	case 3: // seg_selector.vrf_key_handle
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(VrfKeyHandle)
		err := b.DecodeMessage(msg)
		m.SegSelector = &AclSelector_VrfKeyHandle{msg}
		return true, err
	case 4: // seg_selector.l2segment_key_handle
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(L2SegmentKeyHandle)
		err := b.DecodeMessage(msg)
		m.SegSelector = &AclSelector_L2SegmentKeyHandle{msg}
		return true, err
	case 5: // pkt_selector.eth_selector
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(EthSelector)
		err := b.DecodeMessage(msg)
		m.PktSelector = &AclSelector_EthSelector{msg}
		return true, err
	case 6: // pkt_selector.ip_selector
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(IPSelector)
		err := b.DecodeMessage(msg)
		m.PktSelector = &AclSelector_IpSelector{msg}
		return true, err
	default:
		return false, nil
	}
}

func _AclSelector_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*AclSelector)
	// seg_selector
	switch x := m.SegSelector.(type) {
	case *AclSelector_VrfKeyHandle:
		s := proto.Size(x.VrfKeyHandle)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *AclSelector_L2SegmentKeyHandle:
		s := proto.Size(x.L2SegmentKeyHandle)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// pkt_selector
	switch x := m.PktSelector.(type) {
	case *AclSelector_EthSelector:
		s := proto.Size(x.EthSelector)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *AclSelector_IpSelector:
		s := proto.Size(x.IpSelector)
		n += proto.SizeVarint(6<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type AclActionInfo struct {
	Action              AclAction                 `protobuf:"varint,1,opt,name=action,proto3,enum=acl.AclAction" json:"action,omitempty" venice:mandatory`
	IngMirrorSessions   []*MirrorSessionKeyHandle `protobuf:"bytes,2,rep,name=ing_mirror_sessions,json=ingMirrorSessions" json:"ing_mirror_sessions,omitempty" venice:constraints={range:0-7}`
	EgrMirrorSessions   []*MirrorSessionKeyHandle `protobuf:"bytes,3,rep,name=egr_mirror_sessions,json=egrMirrorSessions" json:"egr_mirror_sessions,omitempty" venice:constraints={range:0-7}`
	CoppKeyHandle       *CoppKeyHandle            `protobuf:"bytes,4,opt,name=copp_key_handle,json=coppKeyHandle" json:"copp_key_handle,omitempty" venice:ref`
	RedirectIfKeyHandle *InterfaceKeyHandle       `protobuf:"bytes,5,opt,name=redirect_if_key_handle,json=redirectIfKeyHandle" json:"redirect_if_key_handle,omitempty" venice:ref,venice:constraints={acl.AclActionInfo.action==acl_pb2.ACL_ACTION_REDIRECT}`
	// TODO: REMOVE
	InternalActions *AclInternalActionInfo `protobuf:"bytes,6,opt,name=internal_actions,json=internalActions" json:"internal_actions,omitempty" venice:constraints={acl.AclActionInfo.action!=acl_pb2.ACL_ACTION_DENY}`
}

func (m *AclActionInfo) Reset()                    { *m = AclActionInfo{} }
func (m *AclActionInfo) String() string            { return proto.CompactTextString(m) }
func (*AclActionInfo) ProtoMessage()               {}
func (*AclActionInfo) Descriptor() ([]byte, []int) { return fileDescriptorAcl, []int{8} }

func (m *AclActionInfo) GetAction() AclAction {
	if m != nil {
		return m.Action
	}
	return AclAction_ACL_ACTION_NONE
}

func (m *AclActionInfo) GetIngMirrorSessions() []*MirrorSessionKeyHandle {
	if m != nil {
		return m.IngMirrorSessions
	}
	return nil
}

func (m *AclActionInfo) GetEgrMirrorSessions() []*MirrorSessionKeyHandle {
	if m != nil {
		return m.EgrMirrorSessions
	}
	return nil
}

func (m *AclActionInfo) GetCoppKeyHandle() *CoppKeyHandle {
	if m != nil {
		return m.CoppKeyHandle
	}
	return nil
}

func (m *AclActionInfo) GetRedirectIfKeyHandle() *InterfaceKeyHandle {
	if m != nil {
		return m.RedirectIfKeyHandle
	}
	return nil
}

func (m *AclActionInfo) GetInternalActions() *AclInternalActionInfo {
	if m != nil {
		return m.InternalActions
	}
	return nil
}

// ACL entry configuration
type AclSpec struct {
	// key_or_handle is ACL's key or handle
	KeyOrHandle *AclKeyHandle `protobuf:"bytes,1,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty" venice:key`
	Priority    uint32        `protobuf:"varint,2,opt,name=priority,proto3" json:"priority,omitempty" venice:unique,venice:constraints={range:100-4294967295}`
	// TBD: is this per-vrf priority ? or global ?
	Match  *AclSelector   `protobuf:"bytes,3,opt,name=match" json:"match,omitempty"`
	Action *AclActionInfo `protobuf:"bytes,4,opt,name=action" json:"action,omitempty" venice:mandatory`
}

func (m *AclSpec) Reset()                    { *m = AclSpec{} }
func (m *AclSpec) String() string            { return proto.CompactTextString(m) }
func (*AclSpec) ProtoMessage()               {}
func (*AclSpec) Descriptor() ([]byte, []int) { return fileDescriptorAcl, []int{9} }

func (m *AclSpec) GetKeyOrHandle() *AclKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

func (m *AclSpec) GetPriority() uint32 {
	if m != nil {
		return m.Priority
	}
	return 0
}

func (m *AclSpec) GetMatch() *AclSelector {
	if m != nil {
		return m.Match
	}
	return nil
}

func (m *AclSpec) GetAction() *AclActionInfo {
	if m != nil {
		return m.Action
	}
	return nil
}

// Batched requests to create/update acls
type AclRequestMsg struct {
	Request []*AclSpec `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *AclRequestMsg) Reset()                    { *m = AclRequestMsg{} }
func (m *AclRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*AclRequestMsg) ProtoMessage()               {}
func (*AclRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptorAcl, []int{10} }

func (m *AclRequestMsg) GetRequest() []*AclSpec {
	if m != nil {
		return m.Request
	}
	return nil
}

// Acl oper state for enterprise pipeline
type AclStatusEpd struct {
	HwTcamIdx uint32 `protobuf:"varint,1,opt,name=hw_tcam_idx,json=hwTcamIdx,proto3" json:"hw_tcam_idx,omitempty"`
}

func (m *AclStatusEpd) Reset()                    { *m = AclStatusEpd{} }
func (m *AclStatusEpd) String() string            { return proto.CompactTextString(m) }
func (*AclStatusEpd) ProtoMessage()               {}
func (*AclStatusEpd) Descriptor() ([]byte, []int) { return fileDescriptorAcl, []int{11} }

func (m *AclStatusEpd) GetHwTcamIdx() uint32 {
	if m != nil {
		return m.HwTcamIdx
	}
	return 0
}

// Acl oper state for cloud pipeline
type AclStatusCpd struct {
}

func (m *AclStatusCpd) Reset()                    { *m = AclStatusCpd{} }
func (m *AclStatusCpd) String() string            { return proto.CompactTextString(m) }
func (*AclStatusCpd) ProtoMessage()               {}
func (*AclStatusCpd) Descriptor() ([]byte, []int) { return fileDescriptorAcl, []int{12} }

// AclStatus represents the operational status of an ACL entry
type AclStatus struct {
	AclHandle uint64 `protobuf:"fixed64,1,opt,name=acl_handle,json=aclHandle,proto3" json:"acl_handle,omitempty"`
	// Types that are valid to be assigned to QosClassPdStatus:
	//	*AclStatus_EpdStatus
	//	*AclStatus_CpdStatus
	QosClassPdStatus isAclStatus_QosClassPdStatus `protobuf_oneof:"qos_class_pd_status"`
}

func (m *AclStatus) Reset()                    { *m = AclStatus{} }
func (m *AclStatus) String() string            { return proto.CompactTextString(m) }
func (*AclStatus) ProtoMessage()               {}
func (*AclStatus) Descriptor() ([]byte, []int) { return fileDescriptorAcl, []int{13} }

type isAclStatus_QosClassPdStatus interface {
	isAclStatus_QosClassPdStatus()
	MarshalTo([]byte) (int, error)
	Size() int
}

type AclStatus_EpdStatus struct {
	EpdStatus *AclStatusEpd `protobuf:"bytes,2,opt,name=epd_status,json=epdStatus,oneof"`
}
type AclStatus_CpdStatus struct {
	CpdStatus *AclStatusCpd `protobuf:"bytes,3,opt,name=cpd_status,json=cpdStatus,oneof"`
}

func (*AclStatus_EpdStatus) isAclStatus_QosClassPdStatus() {}
func (*AclStatus_CpdStatus) isAclStatus_QosClassPdStatus() {}

func (m *AclStatus) GetQosClassPdStatus() isAclStatus_QosClassPdStatus {
	if m != nil {
		return m.QosClassPdStatus
	}
	return nil
}

func (m *AclStatus) GetAclHandle() uint64 {
	if m != nil {
		return m.AclHandle
	}
	return 0
}

func (m *AclStatus) GetEpdStatus() *AclStatusEpd {
	if x, ok := m.GetQosClassPdStatus().(*AclStatus_EpdStatus); ok {
		return x.EpdStatus
	}
	return nil
}

func (m *AclStatus) GetCpdStatus() *AclStatusCpd {
	if x, ok := m.GetQosClassPdStatus().(*AclStatus_CpdStatus); ok {
		return x.CpdStatus
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*AclStatus) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _AclStatus_OneofMarshaler, _AclStatus_OneofUnmarshaler, _AclStatus_OneofSizer, []interface{}{
		(*AclStatus_EpdStatus)(nil),
		(*AclStatus_CpdStatus)(nil),
	}
}

func _AclStatus_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*AclStatus)
	// qos_class_pd_status
	switch x := m.QosClassPdStatus.(type) {
	case *AclStatus_EpdStatus:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.EpdStatus); err != nil {
			return err
		}
	case *AclStatus_CpdStatus:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.CpdStatus); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("AclStatus.QosClassPdStatus has unexpected type %T", x)
	}
	return nil
}

func _AclStatus_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*AclStatus)
	switch tag {
	case 2: // qos_class_pd_status.epd_status
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(AclStatusEpd)
		err := b.DecodeMessage(msg)
		m.QosClassPdStatus = &AclStatus_EpdStatus{msg}
		return true, err
	case 3: // qos_class_pd_status.cpd_status
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(AclStatusCpd)
		err := b.DecodeMessage(msg)
		m.QosClassPdStatus = &AclStatus_CpdStatus{msg}
		return true, err
	default:
		return false, nil
	}
}

func _AclStatus_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*AclStatus)
	// qos_class_pd_status
	switch x := m.QosClassPdStatus.(type) {
	case *AclStatus_EpdStatus:
		s := proto.Size(x.EpdStatus)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *AclStatus_CpdStatus:
		s := proto.Size(x.CpdStatus)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// AclResponse is response to one Acl
type AclResponse struct {
	ApiStatus ApiStatus  `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty" venice:api_status`
	Status    *AclStatus `protobuf:"bytes,2,opt,name=status" json:"status,omitempty"`
}

func (m *AclResponse) Reset()                    { *m = AclResponse{} }
func (m *AclResponse) String() string            { return proto.CompactTextString(m) }
func (*AclResponse) ProtoMessage()               {}
func (*AclResponse) Descriptor() ([]byte, []int) { return fileDescriptorAcl, []int{14} }

func (m *AclResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *AclResponse) GetStatus() *AclStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

// Batched responses to create/update acls
type AclResponseMsg struct {
	Response []*AclResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *AclResponseMsg) Reset()                    { *m = AclResponseMsg{} }
func (m *AclResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*AclResponseMsg) ProtoMessage()               {}
func (*AclResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptorAcl, []int{15} }

func (m *AclResponseMsg) GetResponse() []*AclResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

type AclDeleteRequest struct {
	// key_or_handle is unique identifier of ACL being deleted
	KeyOrHandle *AclKeyHandle `protobuf:"bytes,1,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty" venice:key`
}

func (m *AclDeleteRequest) Reset()                    { *m = AclDeleteRequest{} }
func (m *AclDeleteRequest) String() string            { return proto.CompactTextString(m) }
func (*AclDeleteRequest) ProtoMessage()               {}
func (*AclDeleteRequest) Descriptor() ([]byte, []int) { return fileDescriptorAcl, []int{16} }

func (m *AclDeleteRequest) GetKeyOrHandle() *AclKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

// Batched requests to delete acls
type AclDeleteRequestMsg struct {
	Request []*AclDeleteRequest `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *AclDeleteRequestMsg) Reset()                    { *m = AclDeleteRequestMsg{} }
func (m *AclDeleteRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*AclDeleteRequestMsg) ProtoMessage()               {}
func (*AclDeleteRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptorAcl, []int{17} }

func (m *AclDeleteRequestMsg) GetRequest() []*AclDeleteRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

// AclDeleteResponse is response to Acl delete request
type AclDeleteResponse struct {
	ApiStatus ApiStatus `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty" venice:api_status`
}

func (m *AclDeleteResponse) Reset()                    { *m = AclDeleteResponse{} }
func (m *AclDeleteResponse) String() string            { return proto.CompactTextString(m) }
func (*AclDeleteResponse) ProtoMessage()               {}
func (*AclDeleteResponse) Descriptor() ([]byte, []int) { return fileDescriptorAcl, []int{18} }

func (m *AclDeleteResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

// AclDeleteResponseMsg is batched response to AclDeleteRequestMsg
type AclDeleteResponseMsg struct {
	Response []*AclDeleteResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *AclDeleteResponseMsg) Reset()                    { *m = AclDeleteResponseMsg{} }
func (m *AclDeleteResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*AclDeleteResponseMsg) ProtoMessage()               {}
func (*AclDeleteResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptorAcl, []int{19} }

func (m *AclDeleteResponseMsg) GetResponse() []*AclDeleteResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

// AclGetRequest is used to get information about a acl
type AclGetRequest struct {
	// key_or_handle is ACL's identifier for retrieval
	KeyOrHandle *AclKeyHandle `protobuf:"bytes,1,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty" venice:key`
}

func (m *AclGetRequest) Reset()                    { *m = AclGetRequest{} }
func (m *AclGetRequest) String() string            { return proto.CompactTextString(m) }
func (*AclGetRequest) ProtoMessage()               {}
func (*AclGetRequest) Descriptor() ([]byte, []int) { return fileDescriptorAcl, []int{20} }

func (m *AclGetRequest) GetKeyOrHandle() *AclKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

type AclGetRequestMsg struct {
	Request []*AclGetRequest `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *AclGetRequestMsg) Reset()                    { *m = AclGetRequestMsg{} }
func (m *AclGetRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*AclGetRequestMsg) ProtoMessage()               {}
func (*AclGetRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptorAcl, []int{21} }

func (m *AclGetRequestMsg) GetRequest() []*AclGetRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

// AclStats captures all the statistics of a acl
type AclStats struct {
}

func (m *AclStats) Reset()                    { *m = AclStats{} }
func (m *AclStats) String() string            { return proto.CompactTextString(m) }
func (*AclStats) ProtoMessage()               {}
func (*AclStats) Descriptor() ([]byte, []int) { return fileDescriptorAcl, []int{22} }

// AclGetResponse captures all the information about a acl
type AclGetResponse struct {
	ApiStatus ApiStatus  `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty" venice:api_status`
	Spec      *AclSpec   `protobuf:"bytes,2,opt,name=spec" json:"spec,omitempty"`
	Status    *AclStatus `protobuf:"bytes,3,opt,name=status" json:"status,omitempty"`
	Stats     *AclStats  `protobuf:"bytes,4,opt,name=stats" json:"stats,omitempty"`
}

func (m *AclGetResponse) Reset()                    { *m = AclGetResponse{} }
func (m *AclGetResponse) String() string            { return proto.CompactTextString(m) }
func (*AclGetResponse) ProtoMessage()               {}
func (*AclGetResponse) Descriptor() ([]byte, []int) { return fileDescriptorAcl, []int{23} }

func (m *AclGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *AclGetResponse) GetSpec() *AclSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *AclGetResponse) GetStatus() *AclStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *AclGetResponse) GetStats() *AclStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

// AclGetResponseMsg is response to AclGetRequestMsg
type AclGetResponseMsg struct {
	Response []*AclGetResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *AclGetResponseMsg) Reset()                    { *m = AclGetResponseMsg{} }
func (m *AclGetResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*AclGetResponseMsg) ProtoMessage()               {}
func (*AclGetResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptorAcl, []int{24} }

func (m *AclGetResponseMsg) GetResponse() []*AclGetResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

func init() {
	proto.RegisterType((*EthSelector)(nil), "acl.EthSelector")
	proto.RegisterType((*UDPSelector)(nil), "acl.UDPSelector")
	proto.RegisterType((*TCPSelector)(nil), "acl.TCPSelector")
	proto.RegisterType((*ICMPSelector)(nil), "acl.ICMPSelector")
	proto.RegisterType((*IPSelector)(nil), "acl.IPSelector")
	proto.RegisterType((*AclInternalSelector)(nil), "acl.AclInternalSelector")
	proto.RegisterType((*AclInternalActionInfo)(nil), "acl.AclInternalActionInfo")
	proto.RegisterType((*AclSelector)(nil), "acl.AclSelector")
	proto.RegisterType((*AclActionInfo)(nil), "acl.AclActionInfo")
	proto.RegisterType((*AclSpec)(nil), "acl.AclSpec")
	proto.RegisterType((*AclRequestMsg)(nil), "acl.AclRequestMsg")
	proto.RegisterType((*AclStatusEpd)(nil), "acl.AclStatusEpd")
	proto.RegisterType((*AclStatusCpd)(nil), "acl.AclStatusCpd")
	proto.RegisterType((*AclStatus)(nil), "acl.AclStatus")
	proto.RegisterType((*AclResponse)(nil), "acl.AclResponse")
	proto.RegisterType((*AclResponseMsg)(nil), "acl.AclResponseMsg")
	proto.RegisterType((*AclDeleteRequest)(nil), "acl.AclDeleteRequest")
	proto.RegisterType((*AclDeleteRequestMsg)(nil), "acl.AclDeleteRequestMsg")
	proto.RegisterType((*AclDeleteResponse)(nil), "acl.AclDeleteResponse")
	proto.RegisterType((*AclDeleteResponseMsg)(nil), "acl.AclDeleteResponseMsg")
	proto.RegisterType((*AclGetRequest)(nil), "acl.AclGetRequest")
	proto.RegisterType((*AclGetRequestMsg)(nil), "acl.AclGetRequestMsg")
	proto.RegisterType((*AclStats)(nil), "acl.AclStats")
	proto.RegisterType((*AclGetResponse)(nil), "acl.AclGetResponse")
	proto.RegisterType((*AclGetResponseMsg)(nil), "acl.AclGetResponseMsg")
	proto.RegisterEnum("acl.AclAction", AclAction_name, AclAction_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Acl service

type AclClient interface {
	// Acl related APIs
	AclCreate(ctx context.Context, in *AclRequestMsg, opts ...grpc.CallOption) (*AclResponseMsg, error)
	AclUpdate(ctx context.Context, in *AclRequestMsg, opts ...grpc.CallOption) (*AclResponseMsg, error)
	AclDelete(ctx context.Context, in *AclDeleteRequestMsg, opts ...grpc.CallOption) (*AclDeleteResponseMsg, error)
	AclGet(ctx context.Context, in *AclGetRequestMsg, opts ...grpc.CallOption) (*AclGetResponseMsg, error)
}

type aclClient struct {
	cc *grpc.ClientConn
}

func NewAclClient(cc *grpc.ClientConn) AclClient {
	return &aclClient{cc}
}

func (c *aclClient) AclCreate(ctx context.Context, in *AclRequestMsg, opts ...grpc.CallOption) (*AclResponseMsg, error) {
	out := new(AclResponseMsg)
	err := grpc.Invoke(ctx, "/acl.Acl/AclCreate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aclClient) AclUpdate(ctx context.Context, in *AclRequestMsg, opts ...grpc.CallOption) (*AclResponseMsg, error) {
	out := new(AclResponseMsg)
	err := grpc.Invoke(ctx, "/acl.Acl/AclUpdate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aclClient) AclDelete(ctx context.Context, in *AclDeleteRequestMsg, opts ...grpc.CallOption) (*AclDeleteResponseMsg, error) {
	out := new(AclDeleteResponseMsg)
	err := grpc.Invoke(ctx, "/acl.Acl/AclDelete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aclClient) AclGet(ctx context.Context, in *AclGetRequestMsg, opts ...grpc.CallOption) (*AclGetResponseMsg, error) {
	out := new(AclGetResponseMsg)
	err := grpc.Invoke(ctx, "/acl.Acl/AclGet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Acl service

type AclServer interface {
	// Acl related APIs
	AclCreate(context.Context, *AclRequestMsg) (*AclResponseMsg, error)
	AclUpdate(context.Context, *AclRequestMsg) (*AclResponseMsg, error)
	AclDelete(context.Context, *AclDeleteRequestMsg) (*AclDeleteResponseMsg, error)
	AclGet(context.Context, *AclGetRequestMsg) (*AclGetResponseMsg, error)
}

func RegisterAclServer(s *grpc.Server, srv AclServer) {
	s.RegisterService(&_Acl_serviceDesc, srv)
}

func _Acl_AclCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AclRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AclServer).AclCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/acl.Acl/AclCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AclServer).AclCreate(ctx, req.(*AclRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Acl_AclUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AclRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AclServer).AclUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/acl.Acl/AclUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AclServer).AclUpdate(ctx, req.(*AclRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Acl_AclDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AclDeleteRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AclServer).AclDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/acl.Acl/AclDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AclServer).AclDelete(ctx, req.(*AclDeleteRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Acl_AclGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AclGetRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AclServer).AclGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/acl.Acl/AclGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AclServer).AclGet(ctx, req.(*AclGetRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

var _Acl_serviceDesc = grpc.ServiceDesc{
	ServiceName: "acl.Acl",
	HandlerType: (*AclServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AclCreate",
			Handler:    _Acl_AclCreate_Handler,
		},
		{
			MethodName: "AclUpdate",
			Handler:    _Acl_AclUpdate_Handler,
		},
		{
			MethodName: "AclDelete",
			Handler:    _Acl_AclDelete_Handler,
		},
		{
			MethodName: "AclGet",
			Handler:    _Acl_AclGet_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "acl.proto",
}

func (m *EthSelector) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EthSelector) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.EthType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAcl(dAtA, i, uint64(m.EthType))
	}
	if m.EthTypeMask != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAcl(dAtA, i, uint64(m.EthTypeMask))
	}
	if m.SrcMac != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAcl(dAtA, i, uint64(m.SrcMac))
	}
	if m.SrcMacMask != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintAcl(dAtA, i, uint64(m.SrcMacMask))
	}
	if m.DstMac != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintAcl(dAtA, i, uint64(m.DstMac))
	}
	if m.DstMacMask != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintAcl(dAtA, i, uint64(m.DstMacMask))
	}
	return i, nil
}

func (m *UDPSelector) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UDPSelector) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SrcPortRange != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAcl(dAtA, i, uint64(m.SrcPortRange.Size()))
		n1, err := m.SrcPortRange.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.DstPortRange != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAcl(dAtA, i, uint64(m.DstPortRange.Size()))
		n2, err := m.DstPortRange.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}

func (m *TCPSelector) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TCPSelector) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TcpSyn != nil {
		nn3, err := m.TcpSyn.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn3
	}
	if m.TcpAck != nil {
		nn4, err := m.TcpAck.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn4
	}
	if m.TcpFin != nil {
		nn5, err := m.TcpFin.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn5
	}
	if m.TcpRst != nil {
		nn6, err := m.TcpRst.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn6
	}
	if m.TcpUrg != nil {
		nn7, err := m.TcpUrg.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn7
	}
	if m.SrcPortRange != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintAcl(dAtA, i, uint64(m.SrcPortRange.Size()))
		n8, err := m.SrcPortRange.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.DstPortRange != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintAcl(dAtA, i, uint64(m.DstPortRange.Size()))
		n9, err := m.DstPortRange.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	return i, nil
}

func (m *TCPSelector_TcpSynSet) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x8
	i++
	if m.TcpSynSet {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	return i, nil
}
func (m *TCPSelector_TcpSynClear) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x10
	i++
	if m.TcpSynClear {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	return i, nil
}
func (m *TCPSelector_TcpAckSet) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x18
	i++
	if m.TcpAckSet {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	return i, nil
}
func (m *TCPSelector_TcpAckClear) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x20
	i++
	if m.TcpAckClear {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	return i, nil
}
func (m *TCPSelector_TcpFinSet) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x28
	i++
	if m.TcpFinSet {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	return i, nil
}
func (m *TCPSelector_TcpFinClear) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x30
	i++
	if m.TcpFinClear {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	return i, nil
}
func (m *TCPSelector_TcpRstSet) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x38
	i++
	if m.TcpRstSet {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	return i, nil
}
func (m *TCPSelector_TcpRstClear) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x40
	i++
	if m.TcpRstClear {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	return i, nil
}
func (m *TCPSelector_TcpUrgSet) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x48
	i++
	if m.TcpUrgSet {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	return i, nil
}
func (m *TCPSelector_TcpUrgClear) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x50
	i++
	if m.TcpUrgClear {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	return i, nil
}
func (m *ICMPSelector) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ICMPSelector) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.IcmpCode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAcl(dAtA, i, uint64(m.IcmpCode))
	}
	if m.IcmpCodeMask != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAcl(dAtA, i, uint64(m.IcmpCodeMask))
	}
	if m.IcmpType != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAcl(dAtA, i, uint64(m.IcmpType))
	}
	if m.IcmpTypeMask != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintAcl(dAtA, i, uint64(m.IcmpTypeMask))
	}
	return i, nil
}

func (m *IPSelector) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IPSelector) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.IpAf != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAcl(dAtA, i, uint64(m.IpAf))
	}
	if m.SrcPrefix != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAcl(dAtA, i, uint64(m.SrcPrefix.Size()))
		n10, err := m.SrcPrefix.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.DstPrefix != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAcl(dAtA, i, uint64(m.DstPrefix.Size()))
		n11, err := m.DstPrefix.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if m.L4Selectors != nil {
		nn12, err := m.L4Selectors.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn12
	}
	return i, nil
}

func (m *IPSelector_IpProtocol) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x20
	i++
	i = encodeVarintAcl(dAtA, i, uint64(m.IpProtocol))
	return i, nil
}
func (m *IPSelector_IcmpSelector) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.IcmpSelector != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintAcl(dAtA, i, uint64(m.IcmpSelector.Size()))
		n13, err := m.IcmpSelector.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	return i, nil
}
func (m *IPSelector_UdpSelector) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.UdpSelector != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintAcl(dAtA, i, uint64(m.UdpSelector.Size()))
		n14, err := m.UdpSelector.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	return i, nil
}
func (m *IPSelector_TcpSelector) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.TcpSelector != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintAcl(dAtA, i, uint64(m.TcpSelector.Size()))
		n15, err := m.TcpSelector.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	return i, nil
}
func (m *AclInternalSelector) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AclInternalSelector) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.FlowMiss {
		dAtA[i] = 0x8
		i++
		if m.FlowMiss {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.OuterDstMac != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAcl(dAtA, i, uint64(m.OuterDstMac))
	}
	if m.IpOptions {
		dAtA[i] = 0x18
		i++
		if m.IpOptions {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IpFrag {
		dAtA[i] = 0x20
		i++
		if m.IpFrag {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DropReasons != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintAcl(dAtA, i, uint64(m.DropReasons.Size()))
		n16, err := m.DropReasons.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	if m.TunnelTerminate {
		dAtA[i] = 0x30
		i++
		if m.TunnelTerminate {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Direction {
		dAtA[i] = 0x38
		i++
		if m.Direction {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.FromCpu {
		dAtA[i] = 0x40
		i++
		if m.FromCpu {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.NoDrop {
		dAtA[i] = 0x48
		i++
		if m.NoDrop {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *AclInternalActionInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AclInternalActionInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MacSaRewriteEn {
		dAtA[i] = 0x8
		i++
		if m.MacSaRewriteEn {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.MacSa != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAcl(dAtA, i, uint64(m.MacSa))
	}
	if m.MacDaRewriteEn {
		dAtA[i] = 0x18
		i++
		if m.MacDaRewriteEn {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.MacDa != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintAcl(dAtA, i, uint64(m.MacDa))
	}
	if m.TtlDecEn {
		dAtA[i] = 0x28
		i++
		if m.TtlDecEn {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.EncapInfo != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintAcl(dAtA, i, uint64(m.EncapInfo.Size()))
		n17, err := m.EncapInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	if m.Qid != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintAcl(dAtA, i, uint64(m.Qid))
	}
	if m.QidValid {
		dAtA[i] = 0x40
		i++
		if m.QidValid {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *AclSelector) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AclSelector) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SrcIfKeyHandle != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAcl(dAtA, i, uint64(m.SrcIfKeyHandle.Size()))
		n18, err := m.SrcIfKeyHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	if m.DstIfKeyHandle != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAcl(dAtA, i, uint64(m.DstIfKeyHandle.Size()))
		n19, err := m.DstIfKeyHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	if m.SegSelector != nil {
		nn20, err := m.SegSelector.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn20
	}
	if m.PktSelector != nil {
		nn21, err := m.PktSelector.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn21
	}
	if m.InternalKey != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintAcl(dAtA, i, uint64(m.InternalKey.Size()))
		n22, err := m.InternalKey.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	if m.InternalMask != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintAcl(dAtA, i, uint64(m.InternalMask.Size()))
		n23, err := m.InternalMask.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	return i, nil
}

func (m *AclSelector_VrfKeyHandle) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.VrfKeyHandle != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAcl(dAtA, i, uint64(m.VrfKeyHandle.Size()))
		n24, err := m.VrfKeyHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	return i, nil
}
func (m *AclSelector_L2SegmentKeyHandle) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.L2SegmentKeyHandle != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAcl(dAtA, i, uint64(m.L2SegmentKeyHandle.Size()))
		n25, err := m.L2SegmentKeyHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	return i, nil
}
func (m *AclSelector_EthSelector) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.EthSelector != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintAcl(dAtA, i, uint64(m.EthSelector.Size()))
		n26, err := m.EthSelector.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n26
	}
	return i, nil
}
func (m *AclSelector_IpSelector) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.IpSelector != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintAcl(dAtA, i, uint64(m.IpSelector.Size()))
		n27, err := m.IpSelector.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n27
	}
	return i, nil
}
func (m *AclActionInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AclActionInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Action != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAcl(dAtA, i, uint64(m.Action))
	}
	if len(m.IngMirrorSessions) > 0 {
		for _, msg := range m.IngMirrorSessions {
			dAtA[i] = 0x12
			i++
			i = encodeVarintAcl(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.EgrMirrorSessions) > 0 {
		for _, msg := range m.EgrMirrorSessions {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintAcl(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.CoppKeyHandle != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAcl(dAtA, i, uint64(m.CoppKeyHandle.Size()))
		n28, err := m.CoppKeyHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n28
	}
	if m.RedirectIfKeyHandle != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintAcl(dAtA, i, uint64(m.RedirectIfKeyHandle.Size()))
		n29, err := m.RedirectIfKeyHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n29
	}
	if m.InternalActions != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintAcl(dAtA, i, uint64(m.InternalActions.Size()))
		n30, err := m.InternalActions.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n30
	}
	return i, nil
}

func (m *AclSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AclSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.KeyOrHandle != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAcl(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n31, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n31
	}
	if m.Priority != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAcl(dAtA, i, uint64(m.Priority))
	}
	if m.Match != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAcl(dAtA, i, uint64(m.Match.Size()))
		n32, err := m.Match.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n32
	}
	if m.Action != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAcl(dAtA, i, uint64(m.Action.Size()))
		n33, err := m.Action.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n33
	}
	return i, nil
}

func (m *AclRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AclRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintAcl(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *AclStatusEpd) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AclStatusEpd) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.HwTcamIdx != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAcl(dAtA, i, uint64(m.HwTcamIdx))
	}
	return i, nil
}

func (m *AclStatusCpd) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AclStatusCpd) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *AclStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AclStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.AclHandle != 0 {
		dAtA[i] = 0x9
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.AclHandle))
		i += 8
	}
	if m.QosClassPdStatus != nil {
		nn34, err := m.QosClassPdStatus.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn34
	}
	return i, nil
}

func (m *AclStatus_EpdStatus) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.EpdStatus != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAcl(dAtA, i, uint64(m.EpdStatus.Size()))
		n35, err := m.EpdStatus.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n35
	}
	return i, nil
}
func (m *AclStatus_CpdStatus) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.CpdStatus != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAcl(dAtA, i, uint64(m.CpdStatus.Size()))
		n36, err := m.CpdStatus.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n36
	}
	return i, nil
}
func (m *AclResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AclResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAcl(dAtA, i, uint64(m.ApiStatus))
	}
	if m.Status != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAcl(dAtA, i, uint64(m.Status.Size()))
		n37, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n37
	}
	return i, nil
}

func (m *AclResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AclResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintAcl(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *AclDeleteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AclDeleteRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.KeyOrHandle != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAcl(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n38, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n38
	}
	return i, nil
}

func (m *AclDeleteRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AclDeleteRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintAcl(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *AclDeleteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AclDeleteResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAcl(dAtA, i, uint64(m.ApiStatus))
	}
	return i, nil
}

func (m *AclDeleteResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AclDeleteResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintAcl(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *AclGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AclGetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.KeyOrHandle != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAcl(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n39, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n39
	}
	return i, nil
}

func (m *AclGetRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AclGetRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintAcl(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *AclStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AclStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *AclGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AclGetResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAcl(dAtA, i, uint64(m.ApiStatus))
	}
	if m.Spec != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAcl(dAtA, i, uint64(m.Spec.Size()))
		n40, err := m.Spec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n40
	}
	if m.Status != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAcl(dAtA, i, uint64(m.Status.Size()))
		n41, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n41
	}
	if m.Stats != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAcl(dAtA, i, uint64(m.Stats.Size()))
		n42, err := m.Stats.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n42
	}
	return i, nil
}

func (m *AclGetResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AclGetResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintAcl(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func encodeVarintAcl(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *EthSelector) Size() (n int) {
	var l int
	_ = l
	if m.EthType != 0 {
		n += 1 + sovAcl(uint64(m.EthType))
	}
	if m.EthTypeMask != 0 {
		n += 1 + sovAcl(uint64(m.EthTypeMask))
	}
	if m.SrcMac != 0 {
		n += 1 + sovAcl(uint64(m.SrcMac))
	}
	if m.SrcMacMask != 0 {
		n += 1 + sovAcl(uint64(m.SrcMacMask))
	}
	if m.DstMac != 0 {
		n += 1 + sovAcl(uint64(m.DstMac))
	}
	if m.DstMacMask != 0 {
		n += 1 + sovAcl(uint64(m.DstMacMask))
	}
	return n
}

func (m *UDPSelector) Size() (n int) {
	var l int
	_ = l
	if m.SrcPortRange != nil {
		l = m.SrcPortRange.Size()
		n += 1 + l + sovAcl(uint64(l))
	}
	if m.DstPortRange != nil {
		l = m.DstPortRange.Size()
		n += 1 + l + sovAcl(uint64(l))
	}
	return n
}

func (m *TCPSelector) Size() (n int) {
	var l int
	_ = l
	if m.TcpSyn != nil {
		n += m.TcpSyn.Size()
	}
	if m.TcpAck != nil {
		n += m.TcpAck.Size()
	}
	if m.TcpFin != nil {
		n += m.TcpFin.Size()
	}
	if m.TcpRst != nil {
		n += m.TcpRst.Size()
	}
	if m.TcpUrg != nil {
		n += m.TcpUrg.Size()
	}
	if m.SrcPortRange != nil {
		l = m.SrcPortRange.Size()
		n += 1 + l + sovAcl(uint64(l))
	}
	if m.DstPortRange != nil {
		l = m.DstPortRange.Size()
		n += 1 + l + sovAcl(uint64(l))
	}
	return n
}

func (m *TCPSelector_TcpSynSet) Size() (n int) {
	var l int
	_ = l
	n += 2
	return n
}
func (m *TCPSelector_TcpSynClear) Size() (n int) {
	var l int
	_ = l
	n += 2
	return n
}
func (m *TCPSelector_TcpAckSet) Size() (n int) {
	var l int
	_ = l
	n += 2
	return n
}
func (m *TCPSelector_TcpAckClear) Size() (n int) {
	var l int
	_ = l
	n += 2
	return n
}
func (m *TCPSelector_TcpFinSet) Size() (n int) {
	var l int
	_ = l
	n += 2
	return n
}
func (m *TCPSelector_TcpFinClear) Size() (n int) {
	var l int
	_ = l
	n += 2
	return n
}
func (m *TCPSelector_TcpRstSet) Size() (n int) {
	var l int
	_ = l
	n += 2
	return n
}
func (m *TCPSelector_TcpRstClear) Size() (n int) {
	var l int
	_ = l
	n += 2
	return n
}
func (m *TCPSelector_TcpUrgSet) Size() (n int) {
	var l int
	_ = l
	n += 2
	return n
}
func (m *TCPSelector_TcpUrgClear) Size() (n int) {
	var l int
	_ = l
	n += 2
	return n
}
func (m *ICMPSelector) Size() (n int) {
	var l int
	_ = l
	if m.IcmpCode != 0 {
		n += 1 + sovAcl(uint64(m.IcmpCode))
	}
	if m.IcmpCodeMask != 0 {
		n += 1 + sovAcl(uint64(m.IcmpCodeMask))
	}
	if m.IcmpType != 0 {
		n += 1 + sovAcl(uint64(m.IcmpType))
	}
	if m.IcmpTypeMask != 0 {
		n += 1 + sovAcl(uint64(m.IcmpTypeMask))
	}
	return n
}

func (m *IPSelector) Size() (n int) {
	var l int
	_ = l
	if m.IpAf != 0 {
		n += 1 + sovAcl(uint64(m.IpAf))
	}
	if m.SrcPrefix != nil {
		l = m.SrcPrefix.Size()
		n += 1 + l + sovAcl(uint64(l))
	}
	if m.DstPrefix != nil {
		l = m.DstPrefix.Size()
		n += 1 + l + sovAcl(uint64(l))
	}
	if m.L4Selectors != nil {
		n += m.L4Selectors.Size()
	}
	return n
}

func (m *IPSelector_IpProtocol) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovAcl(uint64(m.IpProtocol))
	return n
}
func (m *IPSelector_IcmpSelector) Size() (n int) {
	var l int
	_ = l
	if m.IcmpSelector != nil {
		l = m.IcmpSelector.Size()
		n += 1 + l + sovAcl(uint64(l))
	}
	return n
}
func (m *IPSelector_UdpSelector) Size() (n int) {
	var l int
	_ = l
	if m.UdpSelector != nil {
		l = m.UdpSelector.Size()
		n += 1 + l + sovAcl(uint64(l))
	}
	return n
}
func (m *IPSelector_TcpSelector) Size() (n int) {
	var l int
	_ = l
	if m.TcpSelector != nil {
		l = m.TcpSelector.Size()
		n += 1 + l + sovAcl(uint64(l))
	}
	return n
}
func (m *AclInternalSelector) Size() (n int) {
	var l int
	_ = l
	if m.FlowMiss {
		n += 2
	}
	if m.OuterDstMac != 0 {
		n += 1 + sovAcl(uint64(m.OuterDstMac))
	}
	if m.IpOptions {
		n += 2
	}
	if m.IpFrag {
		n += 2
	}
	if m.DropReasons != nil {
		l = m.DropReasons.Size()
		n += 1 + l + sovAcl(uint64(l))
	}
	if m.TunnelTerminate {
		n += 2
	}
	if m.Direction {
		n += 2
	}
	if m.FromCpu {
		n += 2
	}
	if m.NoDrop {
		n += 2
	}
	return n
}

func (m *AclInternalActionInfo) Size() (n int) {
	var l int
	_ = l
	if m.MacSaRewriteEn {
		n += 2
	}
	if m.MacSa != 0 {
		n += 1 + sovAcl(uint64(m.MacSa))
	}
	if m.MacDaRewriteEn {
		n += 2
	}
	if m.MacDa != 0 {
		n += 1 + sovAcl(uint64(m.MacDa))
	}
	if m.TtlDecEn {
		n += 2
	}
	if m.EncapInfo != nil {
		l = m.EncapInfo.Size()
		n += 1 + l + sovAcl(uint64(l))
	}
	if m.Qid != 0 {
		n += 1 + sovAcl(uint64(m.Qid))
	}
	if m.QidValid {
		n += 2
	}
	return n
}

func (m *AclSelector) Size() (n int) {
	var l int
	_ = l
	if m.SrcIfKeyHandle != nil {
		l = m.SrcIfKeyHandle.Size()
		n += 1 + l + sovAcl(uint64(l))
	}
	if m.DstIfKeyHandle != nil {
		l = m.DstIfKeyHandle.Size()
		n += 1 + l + sovAcl(uint64(l))
	}
	if m.SegSelector != nil {
		n += m.SegSelector.Size()
	}
	if m.PktSelector != nil {
		n += m.PktSelector.Size()
	}
	if m.InternalKey != nil {
		l = m.InternalKey.Size()
		n += 1 + l + sovAcl(uint64(l))
	}
	if m.InternalMask != nil {
		l = m.InternalMask.Size()
		n += 1 + l + sovAcl(uint64(l))
	}
	return n
}

func (m *AclSelector_VrfKeyHandle) Size() (n int) {
	var l int
	_ = l
	if m.VrfKeyHandle != nil {
		l = m.VrfKeyHandle.Size()
		n += 1 + l + sovAcl(uint64(l))
	}
	return n
}
func (m *AclSelector_L2SegmentKeyHandle) Size() (n int) {
	var l int
	_ = l
	if m.L2SegmentKeyHandle != nil {
		l = m.L2SegmentKeyHandle.Size()
		n += 1 + l + sovAcl(uint64(l))
	}
	return n
}
func (m *AclSelector_EthSelector) Size() (n int) {
	var l int
	_ = l
	if m.EthSelector != nil {
		l = m.EthSelector.Size()
		n += 1 + l + sovAcl(uint64(l))
	}
	return n
}
func (m *AclSelector_IpSelector) Size() (n int) {
	var l int
	_ = l
	if m.IpSelector != nil {
		l = m.IpSelector.Size()
		n += 1 + l + sovAcl(uint64(l))
	}
	return n
}
func (m *AclActionInfo) Size() (n int) {
	var l int
	_ = l
	if m.Action != 0 {
		n += 1 + sovAcl(uint64(m.Action))
	}
	if len(m.IngMirrorSessions) > 0 {
		for _, e := range m.IngMirrorSessions {
			l = e.Size()
			n += 1 + l + sovAcl(uint64(l))
		}
	}
	if len(m.EgrMirrorSessions) > 0 {
		for _, e := range m.EgrMirrorSessions {
			l = e.Size()
			n += 1 + l + sovAcl(uint64(l))
		}
	}
	if m.CoppKeyHandle != nil {
		l = m.CoppKeyHandle.Size()
		n += 1 + l + sovAcl(uint64(l))
	}
	if m.RedirectIfKeyHandle != nil {
		l = m.RedirectIfKeyHandle.Size()
		n += 1 + l + sovAcl(uint64(l))
	}
	if m.InternalActions != nil {
		l = m.InternalActions.Size()
		n += 1 + l + sovAcl(uint64(l))
	}
	return n
}

func (m *AclSpec) Size() (n int) {
	var l int
	_ = l
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovAcl(uint64(l))
	}
	if m.Priority != 0 {
		n += 1 + sovAcl(uint64(m.Priority))
	}
	if m.Match != nil {
		l = m.Match.Size()
		n += 1 + l + sovAcl(uint64(l))
	}
	if m.Action != nil {
		l = m.Action.Size()
		n += 1 + l + sovAcl(uint64(l))
	}
	return n
}

func (m *AclRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovAcl(uint64(l))
		}
	}
	return n
}

func (m *AclStatusEpd) Size() (n int) {
	var l int
	_ = l
	if m.HwTcamIdx != 0 {
		n += 1 + sovAcl(uint64(m.HwTcamIdx))
	}
	return n
}

func (m *AclStatusCpd) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *AclStatus) Size() (n int) {
	var l int
	_ = l
	if m.AclHandle != 0 {
		n += 9
	}
	if m.QosClassPdStatus != nil {
		n += m.QosClassPdStatus.Size()
	}
	return n
}

func (m *AclStatus_EpdStatus) Size() (n int) {
	var l int
	_ = l
	if m.EpdStatus != nil {
		l = m.EpdStatus.Size()
		n += 1 + l + sovAcl(uint64(l))
	}
	return n
}
func (m *AclStatus_CpdStatus) Size() (n int) {
	var l int
	_ = l
	if m.CpdStatus != nil {
		l = m.CpdStatus.Size()
		n += 1 + l + sovAcl(uint64(l))
	}
	return n
}
func (m *AclResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovAcl(uint64(m.ApiStatus))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovAcl(uint64(l))
	}
	return n
}

func (m *AclResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovAcl(uint64(l))
		}
	}
	return n
}

func (m *AclDeleteRequest) Size() (n int) {
	var l int
	_ = l
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovAcl(uint64(l))
	}
	return n
}

func (m *AclDeleteRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovAcl(uint64(l))
		}
	}
	return n
}

func (m *AclDeleteResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovAcl(uint64(m.ApiStatus))
	}
	return n
}

func (m *AclDeleteResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovAcl(uint64(l))
		}
	}
	return n
}

func (m *AclGetRequest) Size() (n int) {
	var l int
	_ = l
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovAcl(uint64(l))
	}
	return n
}

func (m *AclGetRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovAcl(uint64(l))
		}
	}
	return n
}

func (m *AclStats) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *AclGetResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovAcl(uint64(m.ApiStatus))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovAcl(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovAcl(uint64(l))
	}
	if m.Stats != nil {
		l = m.Stats.Size()
		n += 1 + l + sovAcl(uint64(l))
	}
	return n
}

func (m *AclGetResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovAcl(uint64(l))
		}
	}
	return n
}

func sovAcl(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozAcl(x uint64) (n int) {
	return sovAcl(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *EthSelector) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAcl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EthSelector: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EthSelector: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EthType", wireType)
			}
			m.EthType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EthType |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EthTypeMask", wireType)
			}
			m.EthTypeMask = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EthTypeMask |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcMac", wireType)
			}
			m.SrcMac = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SrcMac |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcMacMask", wireType)
			}
			m.SrcMacMask = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SrcMacMask |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstMac", wireType)
			}
			m.DstMac = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DstMac |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstMacMask", wireType)
			}
			m.DstMacMask = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DstMacMask |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAcl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAcl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UDPSelector) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAcl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UDPSelector: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UDPSelector: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcPortRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAcl
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SrcPortRange == nil {
				m.SrcPortRange = &L4PortRange{}
			}
			if err := m.SrcPortRange.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstPortRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAcl
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DstPortRange == nil {
				m.DstPortRange = &L4PortRange{}
			}
			if err := m.DstPortRange.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAcl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAcl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TCPSelector) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAcl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TCPSelector: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TCPSelector: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpSynSet", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.TcpSyn = &TCPSelector_TcpSynSet{b}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpSynClear", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.TcpSyn = &TCPSelector_TcpSynClear{b}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpAckSet", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.TcpAck = &TCPSelector_TcpAckSet{b}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpAckClear", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.TcpAck = &TCPSelector_TcpAckClear{b}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpFinSet", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.TcpFin = &TCPSelector_TcpFinSet{b}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpFinClear", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.TcpFin = &TCPSelector_TcpFinClear{b}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpRstSet", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.TcpRst = &TCPSelector_TcpRstSet{b}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpRstClear", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.TcpRst = &TCPSelector_TcpRstClear{b}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpUrgSet", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.TcpUrg = &TCPSelector_TcpUrgSet{b}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpUrgClear", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.TcpUrg = &TCPSelector_TcpUrgClear{b}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcPortRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAcl
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SrcPortRange == nil {
				m.SrcPortRange = &L4PortRange{}
			}
			if err := m.SrcPortRange.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstPortRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAcl
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DstPortRange == nil {
				m.DstPortRange = &L4PortRange{}
			}
			if err := m.DstPortRange.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAcl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAcl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ICMPSelector) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAcl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ICMPSelector: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ICMPSelector: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IcmpCode", wireType)
			}
			m.IcmpCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IcmpCode |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IcmpCodeMask", wireType)
			}
			m.IcmpCodeMask = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IcmpCodeMask |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IcmpType", wireType)
			}
			m.IcmpType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IcmpType |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IcmpTypeMask", wireType)
			}
			m.IcmpTypeMask = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IcmpTypeMask |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAcl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAcl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IPSelector) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAcl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IPSelector: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IPSelector: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpAf", wireType)
			}
			m.IpAf = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IpAf |= (IPAddressFamily(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcPrefix", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAcl
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SrcPrefix == nil {
				m.SrcPrefix = &IPPrefix{}
			}
			if err := m.SrcPrefix.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstPrefix", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAcl
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DstPrefix == nil {
				m.DstPrefix = &IPPrefix{}
			}
			if err := m.DstPrefix.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpProtocol", wireType)
			}
			var v IPProtocol
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (IPProtocol(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.L4Selectors = &IPSelector_IpProtocol{v}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IcmpSelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAcl
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ICMPSelector{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.L4Selectors = &IPSelector_IcmpSelector{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UdpSelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAcl
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &UDPSelector{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.L4Selectors = &IPSelector_UdpSelector{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpSelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAcl
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TCPSelector{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.L4Selectors = &IPSelector_TcpSelector{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAcl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAcl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AclInternalSelector) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAcl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AclInternalSelector: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AclInternalSelector: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlowMiss", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FlowMiss = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OuterDstMac", wireType)
			}
			m.OuterDstMac = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OuterDstMac |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpOptions", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IpOptions = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpFrag", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IpFrag = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropReasons", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAcl
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DropReasons == nil {
				m.DropReasons = &DropReasons{}
			}
			if err := m.DropReasons.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TunnelTerminate", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TunnelTerminate = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Direction", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Direction = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromCpu", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FromCpu = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoDrop", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NoDrop = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipAcl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAcl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AclInternalActionInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAcl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AclInternalActionInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AclInternalActionInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MacSaRewriteEn", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MacSaRewriteEn = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MacSa", wireType)
			}
			m.MacSa = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MacSa |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MacDaRewriteEn", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MacDaRewriteEn = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MacDa", wireType)
			}
			m.MacDa = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MacDa |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TtlDecEn", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TtlDecEn = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncapInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAcl
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EncapInfo == nil {
				m.EncapInfo = &EncapInfo{}
			}
			if err := m.EncapInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Qid", wireType)
			}
			m.Qid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Qid |= (CpucbId(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field QidValid", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.QidValid = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipAcl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAcl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AclSelector) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAcl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AclSelector: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AclSelector: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcIfKeyHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAcl
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SrcIfKeyHandle == nil {
				m.SrcIfKeyHandle = &InterfaceKeyHandle{}
			}
			if err := m.SrcIfKeyHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstIfKeyHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAcl
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DstIfKeyHandle == nil {
				m.DstIfKeyHandle = &InterfaceKeyHandle{}
			}
			if err := m.DstIfKeyHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VrfKeyHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAcl
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &VrfKeyHandle{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.SegSelector = &AclSelector_VrfKeyHandle{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field L2SegmentKeyHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAcl
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &L2SegmentKeyHandle{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.SegSelector = &AclSelector_L2SegmentKeyHandle{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EthSelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAcl
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &EthSelector{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PktSelector = &AclSelector_EthSelector{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpSelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAcl
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &IPSelector{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PktSelector = &AclSelector_IpSelector{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InternalKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAcl
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InternalKey == nil {
				m.InternalKey = &AclInternalSelector{}
			}
			if err := m.InternalKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InternalMask", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAcl
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InternalMask == nil {
				m.InternalMask = &AclInternalSelector{}
			}
			if err := m.InternalMask.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAcl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAcl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AclActionInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAcl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AclActionInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AclActionInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			m.Action = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Action |= (AclAction(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IngMirrorSessions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAcl
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IngMirrorSessions = append(m.IngMirrorSessions, &MirrorSessionKeyHandle{})
			if err := m.IngMirrorSessions[len(m.IngMirrorSessions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EgrMirrorSessions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAcl
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EgrMirrorSessions = append(m.EgrMirrorSessions, &MirrorSessionKeyHandle{})
			if err := m.EgrMirrorSessions[len(m.EgrMirrorSessions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CoppKeyHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAcl
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CoppKeyHandle == nil {
				m.CoppKeyHandle = &CoppKeyHandle{}
			}
			if err := m.CoppKeyHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RedirectIfKeyHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAcl
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RedirectIfKeyHandle == nil {
				m.RedirectIfKeyHandle = &InterfaceKeyHandle{}
			}
			if err := m.RedirectIfKeyHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InternalActions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAcl
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InternalActions == nil {
				m.InternalActions = &AclInternalActionInfo{}
			}
			if err := m.InternalActions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAcl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAcl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AclSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAcl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AclSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AclSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAcl
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &AclKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Priority", wireType)
			}
			m.Priority = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Priority |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Match", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAcl
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Match == nil {
				m.Match = &AclSelector{}
			}
			if err := m.Match.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAcl
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Action == nil {
				m.Action = &AclActionInfo{}
			}
			if err := m.Action.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAcl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAcl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AclRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAcl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AclRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AclRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAcl
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &AclSpec{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAcl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAcl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AclStatusEpd) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAcl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AclStatusEpd: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AclStatusEpd: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HwTcamIdx", wireType)
			}
			m.HwTcamIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HwTcamIdx |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAcl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAcl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AclStatusCpd) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAcl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AclStatusCpd: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AclStatusCpd: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAcl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAcl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AclStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAcl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AclStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AclStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field AclHandle", wireType)
			}
			m.AclHandle = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.AclHandle = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EpdStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAcl
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AclStatusEpd{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.QosClassPdStatus = &AclStatus_EpdStatus{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpdStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAcl
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AclStatusCpd{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.QosClassPdStatus = &AclStatus_CpdStatus{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAcl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAcl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AclResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAcl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AclResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AclResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAcl
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &AclStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAcl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAcl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AclResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAcl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AclResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AclResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAcl
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &AclResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAcl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAcl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AclDeleteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAcl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AclDeleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AclDeleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAcl
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &AclKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAcl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAcl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AclDeleteRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAcl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AclDeleteRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AclDeleteRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAcl
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &AclDeleteRequest{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAcl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAcl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AclDeleteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAcl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AclDeleteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AclDeleteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAcl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAcl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AclDeleteResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAcl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AclDeleteResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AclDeleteResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAcl
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &AclDeleteResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAcl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAcl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AclGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAcl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AclGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AclGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAcl
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &AclKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAcl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAcl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AclGetRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAcl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AclGetRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AclGetRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAcl
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &AclGetRequest{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAcl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAcl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AclStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAcl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AclStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AclStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAcl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAcl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AclGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAcl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AclGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AclGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAcl
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &AclSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAcl
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &AclStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAcl
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = &AclStats{}
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAcl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAcl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AclGetResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAcl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AclGetResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AclGetResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAcl
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &AclGetResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAcl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAcl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipAcl(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowAcl
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAcl
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthAcl
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowAcl
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipAcl(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthAcl = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowAcl   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("acl.proto", fileDescriptorAcl) }

var fileDescriptorAcl = []byte{
	// 2104 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x58, 0x4d, 0x73, 0x1b, 0xb7,
	0x19, 0x36, 0xc5, 0x0f, 0x91, 0xef, 0x4a, 0x94, 0x04, 0xc5, 0x8a, 0xe2, 0xa6, 0x96, 0xb2, 0x6d,
	0x3d, 0x4e, 0xe3, 0xc8, 0x2e, 0x63, 0xd9, 0x71, 0x52, 0x77, 0x42, 0x52, 0x52, 0x44, 0xdb, 0xb2,
	0x15, 0x48, 0x4e, 0x9b, 0xf4, 0xb0, 0xb3, 0xc6, 0x82, 0xe4, 0x0e, 0x97, 0xbb, 0x2b, 0x00, 0xb4,
	0xcd, 0xe9, 0xe8, 0xd0, 0x53, 0x0f, 0x3d, 0xb5, 0xbf, 0xa0, 0xa7, 0xce, 0xf4, 0xd6, 0x4b, 0x7f,
	0x43, 0x7b, 0xec, 0xa9, 0x47, 0x4d, 0xc6, 0x3f, 0x41, 0xed, 0x0f, 0xe8, 0xe0, 0x63, 0x97, 0x4b,
	0x4a, 0x56, 0x22, 0x8d, 0x7c, 0xf1, 0x02, 0x78, 0xde, 0x07, 0x2f, 0xde, 0x8f, 0x07, 0xa0, 0xa0,
	0xe2, 0x92, 0x60, 0x2d, 0x66, 0x91, 0x88, 0x50, 0xde, 0x25, 0xc1, 0x35, 0x4b, 0x0c, 0x63, 0xca,
	0xf5, 0xcc, 0xb5, 0x72, 0xaf, 0xab, 0xbf, 0xec, 0xff, 0xe4, 0xc1, 0xda, 0x14, 0xdd, 0x3d, 0x1a,
	0x50, 0x22, 0x22, 0x86, 0xea, 0x50, 0xa6, 0xa2, 0xeb, 0x48, 0xf0, 0x72, 0x6e, 0x35, 0x77, 0x73,
	0xb6, 0x71, 0xe3, 0xf8, 0x68, 0xc5, 0x7e, 0x49, 0x43, 0x9f, 0xd0, 0xcf, 0x48, 0x14, 0x72, 0xc1,
	0x5c, 0x3f, 0x14, 0xfc, 0xe1, 0xef, 0x98, 0x1b, 0x76, 0xe8, 0x67, 0x77, 0x3e, 0xbe, 0xb7, 0xbe,
	0xfe, 0xc9, 0xfa, 0x21, 0x9e, 0xa6, 0xa2, 0xbb, 0x3f, 0x8c, 0x29, 0x7a, 0x04, 0xb3, 0x09, 0x85,
	0xd3, 0x77, 0x79, 0x6f, 0x79, 0xea, 0x5c, 0x3c, 0x96, 0xe1, 0xd9, 0x71, 0x79, 0x0f, 0x6d, 0xc3,
	0x34, 0x67, 0xc4, 0xe9, 0xbb, 0x64, 0x39, 0xbf, 0x9a, 0xbb, 0x59, 0x68, 0xdc, 0x3e, 0x3e, 0x5a,
	0xf9, 0xe8, 0x2c, 0x96, 0x3b, 0xaf, 0xdb, 0x99, 0x7f, 0x87, 0xb8, 0xc4, 0x19, 0xd9, 0x71, 0x09,
	0xfa, 0x0a, 0x66, 0x0c, 0x93, 0x76, 0xaa, 0x70, 0x31, 0x3a, 0xd0, 0x74, 0x89, 0x73, 0x1e, 0x17,
	0xca, 0xb9, 0xe2, 0x05, 0x9d, 0xf3, 0xb8, 0x30, 0xce, 0x19, 0x26, 0xed, 0x5c, 0xe9, 0x82, 0xce,
	0x69, 0x3a, 0xe9, 0x9c, 0xfd, 0xfb, 0x1c, 0x58, 0xcf, 0x37, 0x76, 0xd3, 0xc4, 0x7e, 0x0a, 0x55,
	0x79, 0xfe, 0x38, 0x62, 0xc2, 0x51, 0xf6, 0x2a, 0xbd, 0x56, 0x0d, 0xad, 0xe9, 0xc2, 0x78, 0x72,
	0x77, 0x37, 0x62, 0x02, 0xcb, 0x15, 0x2c, 0x23, 0x95, 0x8e, 0xa4, 0xa5, 0x74, 0x2e, 0x63, 0x39,
	0xf5, 0x76, 0x4b, 0x8f, 0x8b, 0x74, 0x64, 0xff, 0xa5, 0x00, 0xd6, 0x7e, 0x73, 0xe4, 0xc3, 0x2a,
	0x58, 0x82, 0xc4, 0x0e, 0x1f, 0x86, 0x0e, 0xa7, 0x42, 0x39, 0x50, 0xde, 0xbe, 0x82, 0x2b, 0x82,
	0xc4, 0x7b, 0xc3, 0x70, 0x8f, 0x0a, 0xf4, 0x53, 0x98, 0x4d, 0x10, 0x24, 0xa0, 0x2e, 0x53, 0x5b,
	0x49, 0x8c, 0xa5, 0x31, 0x4d, 0x39, 0x99, 0xf0, 0xb8, 0xa4, 0xa7, 0x78, 0xf2, 0x0a, 0x93, 0x53,
	0x3c, 0x75, 0xd2, 0xcb, 0xf0, 0x48, 0x84, 0xe6, 0x29, 0x18, 0x8c, 0xa5, 0x31, 0x63, 0x3c, 0x6d,
	0x5f, 0xfb, 0x53, 0x54, 0x98, 0x29, 0xc5, 0xb3, 0xe5, 0x67, 0xfd, 0x91, 0x08, 0xcd, 0x53, 0x32,
	0x18, 0x4b, 0x63, 0xc6, 0x78, 0x18, 0x17, 0x8a, 0x67, 0x5a, 0x61, 0xf2, 0x8a, 0x07, 0x73, 0x91,
	0xe1, 0x91, 0x08, 0xcd, 0x53, 0x36, 0x18, 0x4b, 0x63, 0xc6, 0x78, 0x06, 0xac, 0xa3, 0x78, 0x2a,
	0x0a, 0x53, 0x50, 0x3c, 0xcf, 0x59, 0x27, 0xc3, 0x23, 0x11, 0x9a, 0x07, 0x0c, 0xc6, 0xd2, 0x18,
	0xcd, 0x73, 0x32, 0xd7, 0xd6, 0x85, 0x73, 0x3d, 0xf3, 0xc3, 0x72, 0xdd, 0xa8, 0xc0, 0xb4, 0xc9,
	0x5c, 0xf2, 0xe9, 0x92, 0x5e, 0xf2, 0xd9, 0xf6, 0xd3, 0x59, 0xc6, 0x45, 0xf2, 0x39, 0x60, 0x1d,
	0xfb, 0xef, 0x53, 0x30, 0xd3, 0x6a, 0xee, 0x8c, 0x6a, 0xa4, 0x01, 0x15, 0x9f, 0xf4, 0x63, 0x87,
	0x44, 0x5e, 0xa2, 0x40, 0x3f, 0x3b, 0x3e, 0x5a, 0xf9, 0xe0, 0xfb, 0xfa, 0xe0, 0x10, 0x97, 0xa5,
	0x5d, 0x33, 0xf2, 0x28, 0x7a, 0x0c, 0xd5, 0x94, 0x23, 0x2b, 0x41, 0x3f, 0x90, 0x68, 0x26, 0x21,
	0x52, 0x5d, 0x9e, 0x38, 0xa4, 0x24, 0x31, 0x7f, 0x6e, 0x87, 0x94, 0x24, 0x26, 0x0e, 0x8d, 0x34,
	0xb1, 0x70, 0x6e, 0x87, 0x12, 0x4d, 0xb4, 0xff, 0x90, 0x07, 0x68, 0x8d, 0x02, 0xf6, 0x11, 0x14,
	0xfd, 0xd8, 0x71, 0xdb, 0x2a, 0x58, 0xd5, 0xda, 0x92, 0xc9, 0x54, 0x6b, 0xb7, 0xee, 0x79, 0x8c,
	0x72, 0xbe, 0xe5, 0xf6, 0xfd, 0x60, 0x88, 0x0b, 0x7e, 0x5c, 0x6f, 0xa3, 0x35, 0x00, 0x55, 0x19,
	0x8c, 0xb6, 0xfd, 0xd7, 0xa6, 0x8f, 0xe7, 0x52, 0x8b, 0x5d, 0x35, 0x8d, 0x2b, 0xb2, 0x24, 0xd4,
	0xa7, 0xc4, 0xab, 0x7a, 0xd0, 0xf8, 0xfc, 0x5b, 0xf0, 0xb2, 0x10, 0x34, 0xfe, 0x2e, 0x58, 0x7e,
	0xec, 0xa8, 0xab, 0x85, 0x44, 0x81, 0x3a, 0x65, 0xb5, 0xb6, 0x90, 0x31, 0xd0, 0x0b, 0xdb, 0x57,
	0x30, 0xf8, 0x71, 0x32, 0x42, 0x9f, 0xc2, 0xac, 0x0a, 0x0f, 0x37, 0x67, 0x52, 0x9d, 0x68, 0xd5,
	0x16, 0xd6, 0xe4, 0x1d, 0x96, 0xad, 0x8e, 0xed, 0x2b, 0x3a, 0x16, 0xe9, 0xe1, 0xd7, 0x61, 0x66,
	0xe0, 0x65, 0x0c, 0x4b, 0xca, 0x70, 0x5e, 0x19, 0x66, 0xd4, 0x4f, 0x0a, 0xc8, 0xc0, 0x1b, 0x33,
	0x53, 0xc5, 0x9a, 0x98, 0x4d, 0x67, 0xcc, 0x32, 0x82, 0x95, 0xe8, 0x8e, 0x19, 0x36, 0xaa, 0x30,
	0x13, 0xdc, 0x4d, 0xad, 0xb8, 0xfd, 0xdf, 0x29, 0x58, 0xac, 0x93, 0xa0, 0x15, 0x0a, 0xca, 0x42,
	0x37, 0x48, 0xe9, 0x7f, 0x04, 0x95, 0x76, 0x10, 0xbd, 0x72, 0xfa, 0x3e, 0xe7, 0x5a, 0xe5, 0x70,
	0x59, 0x4e, 0xec, 0xf8, 0x9c, 0xa3, 0x3d, 0x98, 0x8d, 0x06, 0x82, 0x32, 0x27, 0xb9, 0x3b, 0xa6,
	0x2e, 0x26, 0xf6, 0x96, 0x62, 0xd9, 0xd0, 0x17, 0xc8, 0x8f, 0x01, 0xfc, 0xd8, 0x89, 0x62, 0xe1,
	0x47, 0x21, 0xd7, 0x82, 0x88, 0x2b, 0x7e, 0xfc, 0x4c, 0x4f, 0xa0, 0x77, 0x61, 0xda, 0x8f, 0x9d,
	0x36, 0x73, 0x3b, 0x5a, 0x08, 0x71, 0xc9, 0x8f, 0xb7, 0x98, 0xdb, 0x91, 0x81, 0xf0, 0x58, 0x14,
	0x3b, 0x8c, 0xba, 0x5c, 0x5a, 0x16, 0xc7, 0xba, 0x7d, 0x83, 0x45, 0x31, 0xd6, 0x2b, 0xd8, 0xf2,
	0x46, 0x03, 0xf4, 0x21, 0xcc, 0x8b, 0x41, 0x18, 0xd2, 0xc0, 0x11, 0x94, 0xf5, 0xfd, 0xd0, 0x15,
	0x54, 0x2b, 0x23, 0x9e, 0xd3, 0xf3, 0xfb, 0xc9, 0x34, 0x7a, 0x1f, 0x2a, 0x9e, 0xcf, 0x28, 0x91,
	0x8e, 0x68, 0x65, 0xc4, 0xa3, 0x09, 0xf4, 0x1e, 0x94, 0xdb, 0x2c, 0xea, 0x3b, 0x24, 0x1e, 0x68,
	0x49, 0xc4, 0xd3, 0x72, 0xdc, 0x8c, 0x07, 0xd2, 0xe7, 0x30, 0x72, 0xe4, 0xae, 0x5a, 0x08, 0x71,
	0x29, 0x8c, 0xa4, 0x43, 0xf6, 0x1f, 0xf3, 0x70, 0x35, 0x13, 0xf5, 0xba, 0x62, 0x6a, 0x85, 0xed,
	0x08, 0x7d, 0x08, 0x0b, 0xf2, 0x0a, 0xe5, 0xae, 0xc3, 0xe8, 0x2b, 0xe6, 0x0b, 0xea, 0xd0, 0xd0,
	0xc4, 0xbf, 0xda, 0x77, 0xc9, 0x9e, 0x8b, 0xf5, 0xf4, 0x66, 0x88, 0xb6, 0xa0, 0xa4, 0xa1, 0x17,
	0x0d, 0x7f, 0x51, 0x11, 0x26, 0x5b, 0x7a, 0x63, 0x5b, 0xe6, 0xd3, 0x2d, 0x37, 0x4e, 0x6e, 0xe9,
	0xb9, 0x17, 0x7d, 0x7b, 0x14, 0x15, 0x21, 0x7a, 0x1f, 0x40, 0x88, 0xc0, 0xf1, 0x28, 0x91, 0x7b,
	0x15, 0x75, 0x79, 0x09, 0x11, 0x6c, 0x50, 0xb2, 0x19, 0xa2, 0xdb, 0x00, 0x34, 0x24, 0x6e, 0xec,
	0xf8, 0x61, 0x3b, 0x4a, 0xfb, 0x41, 0xe7, 0x73, 0x53, 0x2e, 0xc8, 0x48, 0xe1, 0x0a, 0x4d, 0x3e,
	0xd1, 0x2a, 0xe4, 0x0f, 0x7c, 0x4f, 0xa5, 0xa6, 0x5a, 0xab, 0x1a, 0x64, 0x33, 0x1e, 0x90, 0x17,
	0x2d, 0x0f, 0xcb, 0x25, 0x59, 0xce, 0x07, 0xbe, 0xe7, 0xbc, 0x74, 0x03, 0xdf, 0x33, 0x59, 0x2a,
	0x1f, 0xf8, 0xde, 0xd7, 0x72, 0x6c, 0x7f, 0x57, 0x00, 0xab, 0x4e, 0x46, 0xb5, 0xff, 0x15, 0x2c,
	0x48, 0x85, 0xf1, 0xdb, 0x4e, 0x8f, 0x0e, 0x9d, 0xae, 0x1b, 0x7a, 0x41, 0xf2, 0xd4, 0x58, 0x5a,
	0xeb, 0x75, 0xd7, 0x54, 0xda, 0xda, 0x2e, 0xa1, 0x8f, 0xe9, 0x70, 0x5b, 0xad, 0x36, 0xaa, 0xc7,
	0x47, 0x2b, 0x60, 0x02, 0xc1, 0x68, 0x1b, 0xcb, 0xcb, 0xab, 0xd5, 0x4e, 0xd7, 0x25, 0xa5, 0xec,
	0x95, 0x71, 0xca, 0xa9, 0xf3, 0x51, 0x7a, 0x5c, 0x64, 0x29, 0xb7, 0xa1, 0xfa, 0x92, 0x8d, 0xf1,
	0xe5, 0x4d, 0xa4, 0x7a, 0xdd, 0xb5, 0xaf, 0x59, 0xfb, 0xad, 0x4c, 0x52, 0x81, 0x5e, 0x66, 0xd6,
	0xd1, 0xb7, 0xf0, 0x4e, 0x50, 0xe3, 0xb4, 0xd3, 0xa7, 0xa1, 0xc8, 0xf2, 0x15, 0x46, 0xfe, 0x3d,
	0xa9, 0xed, 0xe9, 0xf5, 0xb3, 0x58, 0x51, 0xca, 0x32, 0xe2, 0x5e, 0x87, 0x19, 0xf9, 0x92, 0x9e,
	0x90, 0x45, 0x2d, 0x53, 0x99, 0x47, 0xbb, 0x7c, 0xd6, 0xd0, 0xcc, 0x1b, 0xbe, 0xa6, 0x44, 0x78,
	0x42, 0x13, 0xe7, 0xb4, 0x98, 0xee, 0x66, 0x8c, 0xc0, 0x1f, 0x29, 0xe2, 0xe7, 0x30, 0xe3, 0x9b,
	0x86, 0x92, 0xa7, 0x30, 0x8a, 0xb8, 0xac, 0x8c, 0x4e, 0x91, 0x38, 0x6c, 0x25, 0xe8, 0xc7, 0x74,
	0x88, 0x1e, 0xc2, 0x6c, 0x6a, 0xac, 0x6e, 0xb7, 0xf2, 0xf7, 0x58, 0xa7, 0x7b, 0xc9, 0x0b, 0x4d,
	0xca, 0x2a, 0xa7, 0x9d, 0xd4, 0x61, 0x39, 0x8e, 0x7b, 0x22, 0x1d, 0xdb, 0xff, 0x28, 0xc2, 0x6c,
	0x9d, 0x64, 0x1b, 0xfd, 0x97, 0x50, 0x72, 0xb5, 0xa2, 0xe4, 0x4c, 0xd9, 0x9a, 0x9d, 0x34, 0xa6,
	0xf1, 0xce, 0xf1, 0xd1, 0xca, 0xbc, 0x09, 0x6f, 0xdf, 0x0d, 0x3d, 0x57, 0x44, 0x6c, 0x88, 0x8d,
	0x0d, 0x0a, 0x61, 0xd1, 0x0f, 0x3b, 0x4e, 0xdf, 0x67, 0x2c, 0x62, 0x0e, 0xa7, 0x9c, 0x2b, 0xd5,
	0x9c, 0x5a, 0xcd, 0xdf, 0xb4, 0x6a, 0xd7, 0x64, 0xc6, 0x76, 0xd4, 0xd2, 0x9e, 0x5e, 0x19, 0x65,
	0xcd, 0x3e, 0x3e, 0x5a, 0xb9, 0x7e, 0x56, 0xc7, 0xde, 0x3f, 0xc4, 0x0b, 0x7e, 0xd8, 0x19, 0x33,
	0xe7, 0x72, 0x3f, 0xda, 0x61, 0x27, 0xf6, 0xcb, 0x5f, 0xce, 0x7e, 0xb4, 0xc3, 0x26, 0xf6, 0x6b,
	0xc1, 0x1c, 0x89, 0xe2, 0xf8, 0x64, 0x35, 0x2e, 0xc8, 0xbd, 0x9a, 0x51, 0x1c, 0xbf, 0xbd, 0x51,
	0x66, 0x49, 0x76, 0x19, 0xfd, 0x35, 0x07, 0x4b, 0x8c, 0x6a, 0xbd, 0x9e, 0x68, 0xc0, 0xe2, 0x99,
	0x0d, 0xf8, 0xcd, 0xf1, 0xd1, 0xca, 0xf3, 0x11, 0xef, 0xad, 0xd3, 0x4e, 0x31, 0x96, 0x33, 0x99,
	0xd7, 0x35, 0x9d, 0xa0, 0x87, 0x0f, 0x5d, 0x12, 0x38, 0xf1, 0x8b, 0xda, 0x5a, 0xbd, 0xf9, 0xc4,
	0xa9, 0x37, 0xf7, 0x5b, 0xcf, 0x9e, 0x3a, 0x78, 0x73, 0xa3, 0x85, 0x37, 0x9b, 0xfb, 0x87, 0x78,
	0x31, 0x71, 0x28, 0xdb, 0xd0, 0x7f, 0xca, 0xc1, 0x7c, 0x5a, 0x83, 0x9a, 0x86, 0x9b, 0xca, 0xbf,
	0x36, 0x59, 0x86, 0xa3, 0x0d, 0x1b, 0x8f, 0x8e, 0x8f, 0x56, 0xb6, 0xce, 0xe3, 0xdb, 0x07, 0xa7,
	0xf9, 0xb6, 0xb1, 0xf9, 0xf4, 0x9b, 0x43, 0x3c, 0xe7, 0x8f, 0xf1, 0x73, 0xfb, 0xcf, 0x53, 0x30,
	0x2d, 0xa5, 0x31, 0xa6, 0x04, 0x6d, 0xc0, 0xac, 0x8c, 0x5d, 0xc4, 0xc6, 0x25, 0x51, 0xe9, 0x4d,
	0x9d, 0x04, 0xa7, 0x27, 0xa4, 0x47, 0x87, 0xd8, 0xea, 0xd1, 0xe1, 0x33, 0x66, 0x4e, 0xf9, 0x6b,
	0x28, 0xc7, 0xcc, 0x8f, 0x98, 0x2f, 0x86, 0xe6, 0x49, 0xfb, 0xf9, 0xf1, 0xd1, 0xca, 0x7d, 0x03,
	0x1f, 0x84, 0xfe, 0xc1, 0x80, 0xde, 0x7a, 0x7b, 0xc1, 0xfc, 0xe2, 0xce, 0x9d, 0x8f, 0xef, 0xd6,
	0x1e, 0xdc, 0x7d, 0x70, 0xef, 0x7e, 0xed, 0xc1, 0xfa, 0x21, 0x4e, 0xc9, 0xd0, 0x0d, 0x28, 0xf6,
	0x5d, 0x41, 0xba, 0xa9, 0x0c, 0x9a, 0xf3, 0xa7, 0x1d, 0xab, 0x97, 0xd1, 0x17, 0x69, 0xe3, 0x15,
	0xcc, 0x4b, 0xe1, 0x44, 0xa0, 0xce, 0x6e, 0x3e, 0xfb, 0xbe, 0xea, 0x65, 0x4c, 0x0f, 0x06, 0x94,
	0x8b, 0x1d, 0xde, 0x41, 0x37, 0x60, 0x9a, 0xe9, 0xd1, 0x72, 0x4e, 0x75, 0xc4, 0x4c, 0xba, 0x79,
	0x4c, 0x09, 0x4e, 0x16, 0xed, 0x35, 0x98, 0x91, 0x73, 0xc2, 0x15, 0x03, 0xbe, 0x19, 0x7b, 0xe8,
	0x3a, 0x58, 0xdd, 0x57, 0x8e, 0x20, 0x6e, 0xdf, 0xf1, 0xbd, 0xd7, 0xfa, 0xa7, 0x02, 0xae, 0x74,
	0x5f, 0xed, 0x13, 0xb7, 0xdf, 0xf2, 0x5e, 0xdb, 0xd5, 0x0c, 0xbe, 0x19, 0x7b, 0xf6, 0xdf, 0x72,
	0x50, 0x49, 0x27, 0xe4, 0x83, 0x49, 0x26, 0x32, 0x93, 0x8c, 0x12, 0xae, 0xb8, 0x24, 0x30, 0x81,
	0xae, 0x01, 0xd0, 0xd8, 0x73, 0xb8, 0x02, 0x9b, 0xbb, 0x66, 0x21, 0xf5, 0x2b, 0xf1, 0x41, 0xfe,
	0x76, 0xa5, 0xb1, 0x67, 0x28, 0x6b, 0x00, 0x64, 0x64, 0x93, 0x3f, 0xcd, 0xa6, 0xa9, 0x6d, 0x48,
	0x62, 0xd3, 0xb8, 0x0a, 0x8b, 0x07, 0x11, 0x77, 0x48, 0xe0, 0x72, 0xee, 0xa4, 0xc6, 0xf6, 0xa1,
	0xba, 0x53, 0x31, 0xe5, 0x71, 0x14, 0x72, 0x8a, 0xb6, 0x00, 0xdc, 0xd8, 0x4f, 0x98, 0xb5, 0xe4,
	0x25, 0x77, 0x7a, 0x3d, 0xf6, 0x13, 0xae, 0xe3, 0xa3, 0x95, 0x05, 0x13, 0xf7, 0x11, 0x1c, 0x57,
	0xdc, 0x04, 0x81, 0x6e, 0x40, 0x69, 0xec, 0x44, 0xd5, 0x71, 0xef, 0xb0, 0x59, 0xb5, 0x7f, 0x05,
	0xd5, 0xcc, 0xf6, 0x32, 0x49, 0xb7, 0xa0, 0xcc, 0xcc, 0xd0, 0x64, 0x29, 0x2d, 0x91, 0x04, 0x86,
	0x53, 0x84, 0xfd, 0x1b, 0x98, 0xaf, 0x93, 0x60, 0x83, 0x06, 0x54, 0x50, 0x93, 0xe9, 0xcb, 0x69,
	0x00, 0x7b, 0x4b, 0x3d, 0xb8, 0xc7, 0x98, 0xa5, 0x7b, 0xb7, 0x27, 0x6b, 0xe8, 0x6a, 0xe2, 0xdd,
	0x18, 0x74, 0x54, 0x4c, 0xbf, 0x85, 0x85, 0xcc, 0xe2, 0xe5, 0x86, 0xd9, 0x7e, 0x04, 0xef, 0x9c,
	0x20, 0x97, 0x5e, 0xd6, 0x4e, 0x04, 0x71, 0x69, 0xd2, 0xcd, 0x13, 0xa1, 0x7c, 0xae, 0xda, 0xe5,
	0x4b, 0x2a, 0x2e, 0x37, 0x8e, 0x5f, 0xa8, 0x0c, 0x8d, 0x68, 0x75, 0x8e, 0x27, 0x82, 0x98, 0x36,
	0xf7, 0x08, 0x37, 0x8a, 0x20, 0x40, 0xd9, 0x14, 0x0e, 0xb7, 0xff, 0x99, 0x53, 0x05, 0xa3, 0x60,
	0x97, 0x5c, 0xb2, 0xab, 0x50, 0xe0, 0x31, 0x25, 0xa6, 0x60, 0xc7, 0xa5, 0x41, 0xad, 0x64, 0x8a,
	0x3a, 0x7f, 0x56, 0x51, 0xa3, 0x9f, 0x40, 0x51, 0x7e, 0x71, 0xa3, 0x5c, 0xb3, 0x59, 0x18, 0xc7,
	0x7a, 0xcd, 0xde, 0x50, 0x75, 0x91, 0x39, 0x88, 0xae, 0xae, 0xc9, 0xbc, 0x2d, 0x8e, 0x45, 0x66,
	0x32, 0x69, 0x3f, 0x1f, 0x2a, 0xa5, 0xd1, 0x92, 0x88, 0x16, 0x61, 0x2e, 0x73, 0x55, 0x3c, 0x7d,
	0xf6, 0x74, 0x73, 0xfe, 0x0a, 0xba, 0x0a, 0x0b, 0x99, 0xc9, 0xdd, 0x4d, 0xbc, 0xd3, 0xda, 0x9f,
	0xcf, 0x21, 0x04, 0xd5, 0xcc, 0xf4, 0x93, 0x67, 0x5f, 0xce, 0x4f, 0x4d, 0xd8, 0xcb, 0xab, 0x66,
	0x3e, 0x8f, 0xde, 0x85, 0xc5, 0x53, 0xee, 0xc6, 0xf9, 0x42, 0xed, 0x7f, 0x39, 0xc8, 0xd7, 0x49,
	0x80, 0xee, 0x29, 0x17, 0x9a, 0x8c, 0xca, 0xdf, 0x60, 0x68, 0xd4, 0xab, 0x49, 0xb6, 0xaf, 0x2d,
	0x4e, 0xf6, 0xef, 0x0e, 0xef, 0xd8, 0x57, 0x8c, 0xdd, 0xf3, 0xd8, 0x3b, 0xa7, 0x5d, 0x43, 0xd9,
	0xe9, 0x32, 0x46, 0xcb, 0xa7, 0x76, 0x9f, 0xb4, 0x7e, 0xef, 0xf4, 0x82, 0xd7, 0x1c, 0x0f, 0xa0,
	0xa4, 0x43, 0x8a, 0xae, 0x9e, 0xac, 0x3c, 0x69, 0xbd, 0x74, 0x4a, 0xd8, 0x95, 0x69, 0x63, 0xe9,
	0x5f, 0x6f, 0xae, 0xe7, 0xfe, 0xfd, 0xe6, 0x7a, 0xee, 0xbb, 0x37, 0xd7, 0x73, 0xdf, 0x96, 0xbb,
	0x6e, 0xa0, 0xfe, 0x06, 0xf1, 0xa2, 0xa4, 0xfe, 0xfb, 0xe4, 0xff, 0x01, 0x00, 0x00, 0xff, 0xff,
	0x9e, 0x8a, 0xe7, 0x2c, 0x0e, 0x17, 0x00, 0x00,
}
