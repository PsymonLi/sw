// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: rdma.proto

package halproto

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import encoding_binary "encoding/binary"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// types of interfaces
type RdmaServiceType int32

const (
	RdmaServiceType_RDMA_SERV_TYPE_RC     RdmaServiceType = 0
	RdmaServiceType_RDMA_SERV_TYPE_UC     RdmaServiceType = 1
	RdmaServiceType_RDMA_SERV_TYPE_RD     RdmaServiceType = 2
	RdmaServiceType_RDMA_SERV_TYPE_UD     RdmaServiceType = 3
	RdmaServiceType_RDMA_SERV_TYPE_CNP    RdmaServiceType = 4
	RdmaServiceType_RDMA_SERV_TYPE_XRC    RdmaServiceType = 5
	RdmaServiceType_RDMA_SERV_TYPE_VEND_1 RdmaServiceType = 6
	RdmaServiceType_RDMA_SERV_TYPE_VEND_2 RdmaServiceType = 7
)

var RdmaServiceType_name = map[int32]string{
	0: "RDMA_SERV_TYPE_RC",
	1: "RDMA_SERV_TYPE_UC",
	2: "RDMA_SERV_TYPE_RD",
	3: "RDMA_SERV_TYPE_UD",
	4: "RDMA_SERV_TYPE_CNP",
	5: "RDMA_SERV_TYPE_XRC",
	6: "RDMA_SERV_TYPE_VEND_1",
	7: "RDMA_SERV_TYPE_VEND_2",
}
var RdmaServiceType_value = map[string]int32{
	"RDMA_SERV_TYPE_RC":     0,
	"RDMA_SERV_TYPE_UC":     1,
	"RDMA_SERV_TYPE_RD":     2,
	"RDMA_SERV_TYPE_UD":     3,
	"RDMA_SERV_TYPE_CNP":    4,
	"RDMA_SERV_TYPE_XRC":    5,
	"RDMA_SERV_TYPE_VEND_1": 6,
	"RDMA_SERV_TYPE_VEND_2": 7,
}

func (x RdmaServiceType) String() string {
	return proto.EnumName(RdmaServiceType_name, int32(x))
}
func (RdmaServiceType) EnumDescriptor() ([]byte, []int) { return fileDescriptorRdma, []int{0} }

// types of Update QP operations
type RdmaQpUpdateOper int32

const (
	RdmaQpUpdateOper_RDMA_UPDATE_QP_OPER_SET_STATE               RdmaQpUpdateOper = 0
	RdmaQpUpdateOper_RDMA_UPDATE_QP_OPER_SET_CUR_STATE           RdmaQpUpdateOper = 1
	RdmaQpUpdateOper_RDMA_UPDATE_QP_OPER_SET_EN_SQD_ASYNC_NOTIFY RdmaQpUpdateOper = 2
	RdmaQpUpdateOper_RDMA_UPDATE_QP_OPER_SET_ACCESS_FLAGS        RdmaQpUpdateOper = 3
	RdmaQpUpdateOper_RDMA_UPDATE_QP_OPER_SET_PKEY_INDEX          RdmaQpUpdateOper = 4
	RdmaQpUpdateOper_RDMA_UPDATE_QP_OPER_SET_PORT                RdmaQpUpdateOper = 5
	RdmaQpUpdateOper_RDMA_UPDATE_QP_OPER_SET_QKEY                RdmaQpUpdateOper = 6
	RdmaQpUpdateOper_RDMA_UPDATE_QP_OPER_SET_AV                  RdmaQpUpdateOper = 7
	RdmaQpUpdateOper_RDMA_UPDATE_QP_OPER_SET_PATH_MTU            RdmaQpUpdateOper = 8
	RdmaQpUpdateOper_RDMA_UPDATE_QP_OPER_SET_TIMEOUT             RdmaQpUpdateOper = 9
	RdmaQpUpdateOper_RDMA_UPDATE_QP_OPER_SET_RETRY_CNT           RdmaQpUpdateOper = 10
	RdmaQpUpdateOper_RDMA_UPDATE_QP_OPER_SET_RNR_RETRY           RdmaQpUpdateOper = 11
	RdmaQpUpdateOper_RDMA_UPDATE_QP_OPER_SET_RQ_PSN              RdmaQpUpdateOper = 12
	RdmaQpUpdateOper_RDMA_UPDATE_QP_OPER_SET_MAX_QP_RD_ATOMIC    RdmaQpUpdateOper = 13
	RdmaQpUpdateOper_RDMA_UPDATE_QP_OPER_SET_ALT_PATH            RdmaQpUpdateOper = 14
	RdmaQpUpdateOper_RDMA_UPDATE_QP_OPER_SET_MIN_RNR_TIMER       RdmaQpUpdateOper = 15
	RdmaQpUpdateOper_RDMA_UPDATE_QP_OPER_SET_SQ_PSN              RdmaQpUpdateOper = 16
	RdmaQpUpdateOper_RDMA_UPDATE_QP_OPER_SET_MAX_DEST_RD_ATOMIC  RdmaQpUpdateOper = 17
	RdmaQpUpdateOper_RDMA_UPDATE_QP_OPER_SET_PATH_MIG_STATE      RdmaQpUpdateOper = 18
	RdmaQpUpdateOper_RDMA_UPDATE_QP_OPER_SET_CAP                 RdmaQpUpdateOper = 19
	RdmaQpUpdateOper_RDMA_UPDATE_QP_OPER_SET_DEST_QPN            RdmaQpUpdateOper = 20
	RdmaQpUpdateOper_RDMA_UPDATE_QP_OPER_SET_RESERVED1           RdmaQpUpdateOper = 21
	RdmaQpUpdateOper_RDMA_UPDATE_QP_OPER_SET_RESERVED2           RdmaQpUpdateOper = 22
	RdmaQpUpdateOper_RDMA_UPDATE_QP_OPER_SET_RESERVED3           RdmaQpUpdateOper = 23
	RdmaQpUpdateOper_RDMA_UPDATE_QP_OPER_SET_RESERVED4           RdmaQpUpdateOper = 24
	RdmaQpUpdateOper_RDMA_UPDATE_QP_OPER_SET_RATE_LIMIT          RdmaQpUpdateOper = 25
)

var RdmaQpUpdateOper_name = map[int32]string{
	0:  "RDMA_UPDATE_QP_OPER_SET_STATE",
	1:  "RDMA_UPDATE_QP_OPER_SET_CUR_STATE",
	2:  "RDMA_UPDATE_QP_OPER_SET_EN_SQD_ASYNC_NOTIFY",
	3:  "RDMA_UPDATE_QP_OPER_SET_ACCESS_FLAGS",
	4:  "RDMA_UPDATE_QP_OPER_SET_PKEY_INDEX",
	5:  "RDMA_UPDATE_QP_OPER_SET_PORT",
	6:  "RDMA_UPDATE_QP_OPER_SET_QKEY",
	7:  "RDMA_UPDATE_QP_OPER_SET_AV",
	8:  "RDMA_UPDATE_QP_OPER_SET_PATH_MTU",
	9:  "RDMA_UPDATE_QP_OPER_SET_TIMEOUT",
	10: "RDMA_UPDATE_QP_OPER_SET_RETRY_CNT",
	11: "RDMA_UPDATE_QP_OPER_SET_RNR_RETRY",
	12: "RDMA_UPDATE_QP_OPER_SET_RQ_PSN",
	13: "RDMA_UPDATE_QP_OPER_SET_MAX_QP_RD_ATOMIC",
	14: "RDMA_UPDATE_QP_OPER_SET_ALT_PATH",
	15: "RDMA_UPDATE_QP_OPER_SET_MIN_RNR_TIMER",
	16: "RDMA_UPDATE_QP_OPER_SET_SQ_PSN",
	17: "RDMA_UPDATE_QP_OPER_SET_MAX_DEST_RD_ATOMIC",
	18: "RDMA_UPDATE_QP_OPER_SET_PATH_MIG_STATE",
	19: "RDMA_UPDATE_QP_OPER_SET_CAP",
	20: "RDMA_UPDATE_QP_OPER_SET_DEST_QPN",
	21: "RDMA_UPDATE_QP_OPER_SET_RESERVED1",
	22: "RDMA_UPDATE_QP_OPER_SET_RESERVED2",
	23: "RDMA_UPDATE_QP_OPER_SET_RESERVED3",
	24: "RDMA_UPDATE_QP_OPER_SET_RESERVED4",
	25: "RDMA_UPDATE_QP_OPER_SET_RATE_LIMIT",
}
var RdmaQpUpdateOper_value = map[string]int32{
	"RDMA_UPDATE_QP_OPER_SET_STATE":               0,
	"RDMA_UPDATE_QP_OPER_SET_CUR_STATE":           1,
	"RDMA_UPDATE_QP_OPER_SET_EN_SQD_ASYNC_NOTIFY": 2,
	"RDMA_UPDATE_QP_OPER_SET_ACCESS_FLAGS":        3,
	"RDMA_UPDATE_QP_OPER_SET_PKEY_INDEX":          4,
	"RDMA_UPDATE_QP_OPER_SET_PORT":                5,
	"RDMA_UPDATE_QP_OPER_SET_QKEY":                6,
	"RDMA_UPDATE_QP_OPER_SET_AV":                  7,
	"RDMA_UPDATE_QP_OPER_SET_PATH_MTU":            8,
	"RDMA_UPDATE_QP_OPER_SET_TIMEOUT":             9,
	"RDMA_UPDATE_QP_OPER_SET_RETRY_CNT":           10,
	"RDMA_UPDATE_QP_OPER_SET_RNR_RETRY":           11,
	"RDMA_UPDATE_QP_OPER_SET_RQ_PSN":              12,
	"RDMA_UPDATE_QP_OPER_SET_MAX_QP_RD_ATOMIC":    13,
	"RDMA_UPDATE_QP_OPER_SET_ALT_PATH":            14,
	"RDMA_UPDATE_QP_OPER_SET_MIN_RNR_TIMER":       15,
	"RDMA_UPDATE_QP_OPER_SET_SQ_PSN":              16,
	"RDMA_UPDATE_QP_OPER_SET_MAX_DEST_RD_ATOMIC":  17,
	"RDMA_UPDATE_QP_OPER_SET_PATH_MIG_STATE":      18,
	"RDMA_UPDATE_QP_OPER_SET_CAP":                 19,
	"RDMA_UPDATE_QP_OPER_SET_DEST_QPN":            20,
	"RDMA_UPDATE_QP_OPER_SET_RESERVED1":           21,
	"RDMA_UPDATE_QP_OPER_SET_RESERVED2":           22,
	"RDMA_UPDATE_QP_OPER_SET_RESERVED3":           23,
	"RDMA_UPDATE_QP_OPER_SET_RESERVED4":           24,
	"RDMA_UPDATE_QP_OPER_SET_RATE_LIMIT":          25,
}

func (x RdmaQpUpdateOper) String() string {
	return proto.EnumName(RdmaQpUpdateOper_name, int32(x))
}
func (RdmaQpUpdateOper) EnumDescriptor() ([]byte, []int) { return fileDescriptorRdma, []int{1} }

// In alignment with ib_access_flags
type RdmaQpAccessFlags int32

const (
	RdmaQpAccessFlags_RDMA_QP_ACCESS_NONE          RdmaQpAccessFlags = 0
	RdmaQpAccessFlags_RDMA_QP_ACCESS_LOCAL_WRITE   RdmaQpAccessFlags = 1
	RdmaQpAccessFlags_RDMA_QP_ACCESS_REMOTE_WRITE  RdmaQpAccessFlags = 2
	RdmaQpAccessFlags_RDMA_QP_ACCESS_REMOTE_READ   RdmaQpAccessFlags = 4
	RdmaQpAccessFlags_RDMA_QP_ACCESS_REMOTE_ATOMIC RdmaQpAccessFlags = 8
	RdmaQpAccessFlags_RDMA_QP_ACCESS_MW_BIND       RdmaQpAccessFlags = 16
	RdmaQpAccessFlags_RDMA_QP_ZERO_BASED           RdmaQpAccessFlags = 32
	RdmaQpAccessFlags_RDMA_QP_ACCESS_ON_DEMAND     RdmaQpAccessFlags = 64
	RdmaQpAccessFlags_RDMA_QP_ACCESS_HUGETLB       RdmaQpAccessFlags = 128
)

var RdmaQpAccessFlags_name = map[int32]string{
	0:   "RDMA_QP_ACCESS_NONE",
	1:   "RDMA_QP_ACCESS_LOCAL_WRITE",
	2:   "RDMA_QP_ACCESS_REMOTE_WRITE",
	4:   "RDMA_QP_ACCESS_REMOTE_READ",
	8:   "RDMA_QP_ACCESS_REMOTE_ATOMIC",
	16:  "RDMA_QP_ACCESS_MW_BIND",
	32:  "RDMA_QP_ZERO_BASED",
	64:  "RDMA_QP_ACCESS_ON_DEMAND",
	128: "RDMA_QP_ACCESS_HUGETLB",
}
var RdmaQpAccessFlags_value = map[string]int32{
	"RDMA_QP_ACCESS_NONE":          0,
	"RDMA_QP_ACCESS_LOCAL_WRITE":   1,
	"RDMA_QP_ACCESS_REMOTE_WRITE":  2,
	"RDMA_QP_ACCESS_REMOTE_READ":   4,
	"RDMA_QP_ACCESS_REMOTE_ATOMIC": 8,
	"RDMA_QP_ACCESS_MW_BIND":       16,
	"RDMA_QP_ZERO_BASED":           32,
	"RDMA_QP_ACCESS_ON_DEMAND":     64,
	"RDMA_QP_ACCESS_HUGETLB":       128,
}

func (x RdmaQpAccessFlags) String() string {
	return proto.EnumName(RdmaQpAccessFlags_name, int32(x))
}
func (RdmaQpAccessFlags) EnumDescriptor() ([]byte, []int) { return fileDescriptorRdma, []int{2} }

// **********************   Memory Window(MW)  *********************//
// RdmaMemWindow object
type RdmaMemoryWindowType int32

const (
	RdmaMemoryWindowType_RDMA_MEMORY_WINDOW_TYPE_NONE RdmaMemoryWindowType = 0
	RdmaMemoryWindowType_RDMA_MEMORY_WINDOW_TYPE1     RdmaMemoryWindowType = 1
	RdmaMemoryWindowType_RDMA_MEMORY_WINDOW_TYPE2     RdmaMemoryWindowType = 2
)

var RdmaMemoryWindowType_name = map[int32]string{
	0: "RDMA_MEMORY_WINDOW_TYPE_NONE",
	1: "RDMA_MEMORY_WINDOW_TYPE1",
	2: "RDMA_MEMORY_WINDOW_TYPE2",
}
var RdmaMemoryWindowType_value = map[string]int32{
	"RDMA_MEMORY_WINDOW_TYPE_NONE": 0,
	"RDMA_MEMORY_WINDOW_TYPE1":     1,
	"RDMA_MEMORY_WINDOW_TYPE2":     2,
}

func (x RdmaMemoryWindowType) String() string {
	return proto.EnumName(RdmaMemoryWindowType_name, int32(x))
}
func (RdmaMemoryWindowType) EnumDescriptor() ([]byte, []int) { return fileDescriptorRdma, []int{3} }

// **********************    Queue Pair  ********************************//
// RdmaQp object
type RdmaQpSpec struct {
	QpNum         uint32          `protobuf:"varint,1,opt,name=qp_num,json=qpNum,proto3" json:"qp_num,omitempty"`
	HwLifId       uint32          `protobuf:"varint,2,opt,name=hw_lif_id,json=hwLifId,proto3" json:"hw_lif_id,omitempty"`
	SqWqeSize     uint32          `protobuf:"varint,3,opt,name=sq_wqe_size,json=sqWqeSize,proto3" json:"sq_wqe_size,omitempty"`
	RqWqeSize     uint32          `protobuf:"varint,4,opt,name=rq_wqe_size,json=rqWqeSize,proto3" json:"rq_wqe_size,omitempty"`
	NumSqWqes     uint32          `protobuf:"varint,5,opt,name=num_sq_wqes,json=numSqWqes,proto3" json:"num_sq_wqes,omitempty"`
	NumRqWqes     uint32          `protobuf:"varint,6,opt,name=num_rq_wqes,json=numRqWqes,proto3" json:"num_rq_wqes,omitempty"`
	NumRsqWqes    uint32          `protobuf:"varint,7,opt,name=num_rsq_wqes,json=numRsqWqes,proto3" json:"num_rsq_wqes,omitempty"`
	NumRrqWqes    uint32          `protobuf:"varint,8,opt,name=num_rrq_wqes,json=numRrqWqes,proto3" json:"num_rrq_wqes,omitempty"`
	Pd            uint32          `protobuf:"varint,9,opt,name=pd,proto3" json:"pd,omitempty"`
	Pmtu          uint32          `protobuf:"varint,10,opt,name=pmtu,proto3" json:"pmtu,omitempty"`
	HostmemPgSize uint32          `protobuf:"varint,11,opt,name=hostmem_pg_size,json=hostmemPgSize,proto3" json:"hostmem_pg_size,omitempty"`
	Svc           RdmaServiceType `protobuf:"varint,12,opt,name=svc,proto3,enum=rdma.RdmaServiceType" json:"svc,omitempty"`
	AtomicEnabled bool            `protobuf:"varint,13,opt,name=atomic_enabled,json=atomicEnabled,proto3" json:"atomic_enabled,omitempty"`
	SqLkey        uint32          `protobuf:"varint,14,opt,name=sq_lkey,json=sqLkey,proto3" json:"sq_lkey,omitempty"`
	RqLkey        uint32          `protobuf:"varint,15,opt,name=rq_lkey,json=rqLkey,proto3" json:"rq_lkey,omitempty"`
	RqCqNum       uint32          `protobuf:"varint,16,opt,name=rq_cq_num,json=rqCqNum,proto3" json:"rq_cq_num,omitempty"`
	SqCqNum       uint32          `protobuf:"varint,17,opt,name=sq_cq_num,json=sqCqNum,proto3" json:"sq_cq_num,omitempty"`
	ImmdtAsDbell  bool            `protobuf:"varint,18,opt,name=immdt_as_dbell,json=immdtAsDbell,proto3" json:"immdt_as_dbell,omitempty"`
	SqInNicMemory bool            `protobuf:"varint,19,opt,name=sq_in_nic_memory,json=sqInNicMemory,proto3" json:"sq_in_nic_memory,omitempty"`
	// if sq_in_nic_memory and sq_base_addr == NULL, HAL will allocate
	SqBaseAddr    uint64 `protobuf:"varint,20,opt,name=sq_base_addr,json=sqBaseAddr,proto3" json:"sq_base_addr,omitempty"`
	RqInNicMemory bool   `protobuf:"varint,21,opt,name=rq_in_nic_memory,json=rqInNicMemory,proto3" json:"rq_in_nic_memory,omitempty"`
	// if rq_in_nic_memory and rq_base_addr == NULL, HAL will allocate
	RqBaseAddr uint64 `protobuf:"varint,22,opt,name=rq_base_addr,json=rqBaseAddr,proto3" json:"rq_base_addr,omitempty"`
	IfHandle   uint64 `protobuf:"fixed64,23,opt,name=if_handle,json=ifHandle,proto3" json:"if_handle,omitempty"`
	// handle
	VaPagesPhyAddr []uint64 `protobuf:"varint,24,rep,packed,name=va_pages_phy_addr,json=vaPagesPhyAddr" json:"va_pages_phy_addr,omitempty"`
	// phy addr
	NumSqPages uint32 `protobuf:"varint,25,opt,name=num_sq_pages,json=numSqPages,proto3" json:"num_sq_pages,omitempty"`
}

func (m *RdmaQpSpec) Reset()                    { *m = RdmaQpSpec{} }
func (m *RdmaQpSpec) String() string            { return proto.CompactTextString(m) }
func (*RdmaQpSpec) ProtoMessage()               {}
func (*RdmaQpSpec) Descriptor() ([]byte, []int) { return fileDescriptorRdma, []int{0} }

func (m *RdmaQpSpec) GetQpNum() uint32 {
	if m != nil {
		return m.QpNum
	}
	return 0
}

func (m *RdmaQpSpec) GetHwLifId() uint32 {
	if m != nil {
		return m.HwLifId
	}
	return 0
}

func (m *RdmaQpSpec) GetSqWqeSize() uint32 {
	if m != nil {
		return m.SqWqeSize
	}
	return 0
}

func (m *RdmaQpSpec) GetRqWqeSize() uint32 {
	if m != nil {
		return m.RqWqeSize
	}
	return 0
}

func (m *RdmaQpSpec) GetNumSqWqes() uint32 {
	if m != nil {
		return m.NumSqWqes
	}
	return 0
}

func (m *RdmaQpSpec) GetNumRqWqes() uint32 {
	if m != nil {
		return m.NumRqWqes
	}
	return 0
}

func (m *RdmaQpSpec) GetNumRsqWqes() uint32 {
	if m != nil {
		return m.NumRsqWqes
	}
	return 0
}

func (m *RdmaQpSpec) GetNumRrqWqes() uint32 {
	if m != nil {
		return m.NumRrqWqes
	}
	return 0
}

func (m *RdmaQpSpec) GetPd() uint32 {
	if m != nil {
		return m.Pd
	}
	return 0
}

func (m *RdmaQpSpec) GetPmtu() uint32 {
	if m != nil {
		return m.Pmtu
	}
	return 0
}

func (m *RdmaQpSpec) GetHostmemPgSize() uint32 {
	if m != nil {
		return m.HostmemPgSize
	}
	return 0
}

func (m *RdmaQpSpec) GetSvc() RdmaServiceType {
	if m != nil {
		return m.Svc
	}
	return RdmaServiceType_RDMA_SERV_TYPE_RC
}

func (m *RdmaQpSpec) GetAtomicEnabled() bool {
	if m != nil {
		return m.AtomicEnabled
	}
	return false
}

func (m *RdmaQpSpec) GetSqLkey() uint32 {
	if m != nil {
		return m.SqLkey
	}
	return 0
}

func (m *RdmaQpSpec) GetRqLkey() uint32 {
	if m != nil {
		return m.RqLkey
	}
	return 0
}

func (m *RdmaQpSpec) GetRqCqNum() uint32 {
	if m != nil {
		return m.RqCqNum
	}
	return 0
}

func (m *RdmaQpSpec) GetSqCqNum() uint32 {
	if m != nil {
		return m.SqCqNum
	}
	return 0
}

func (m *RdmaQpSpec) GetImmdtAsDbell() bool {
	if m != nil {
		return m.ImmdtAsDbell
	}
	return false
}

func (m *RdmaQpSpec) GetSqInNicMemory() bool {
	if m != nil {
		return m.SqInNicMemory
	}
	return false
}

func (m *RdmaQpSpec) GetSqBaseAddr() uint64 {
	if m != nil {
		return m.SqBaseAddr
	}
	return 0
}

func (m *RdmaQpSpec) GetRqInNicMemory() bool {
	if m != nil {
		return m.RqInNicMemory
	}
	return false
}

func (m *RdmaQpSpec) GetRqBaseAddr() uint64 {
	if m != nil {
		return m.RqBaseAddr
	}
	return 0
}

func (m *RdmaQpSpec) GetIfHandle() uint64 {
	if m != nil {
		return m.IfHandle
	}
	return 0
}

func (m *RdmaQpSpec) GetVaPagesPhyAddr() []uint64 {
	if m != nil {
		return m.VaPagesPhyAddr
	}
	return nil
}

func (m *RdmaQpSpec) GetNumSqPages() uint32 {
	if m != nil {
		return m.NumSqPages
	}
	return 0
}

// RdmaQpRequestMsg is batched request used to create/update of Rdma QPs
type RdmaQpRequestMsg struct {
	Request []*RdmaQpSpec `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *RdmaQpRequestMsg) Reset()                    { *m = RdmaQpRequestMsg{} }
func (m *RdmaQpRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*RdmaQpRequestMsg) ProtoMessage()               {}
func (*RdmaQpRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptorRdma, []int{1} }

func (m *RdmaQpRequestMsg) GetRequest() []*RdmaQpSpec {
	if m != nil {
		return m.Request
	}
	return nil
}

// RdmaQpResponse response to one RdmaQpSpec
type RdmaQpResponse struct {
	ApiStatus ApiStatus `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty"`
	// RdmaQpStatus        status           = 2;    // operational status
	RsqBaseAddr       uint64 `protobuf:"varint,3,opt,name=rsq_base_addr,json=rsqBaseAddr,proto3" json:"rsq_base_addr,omitempty"`
	RrqBaseAddr       uint64 `protobuf:"varint,4,opt,name=rrq_base_addr,json=rrqBaseAddr,proto3" json:"rrq_base_addr,omitempty"`
	NicSqBaseAddr     uint64 `protobuf:"varint,5,opt,name=nic_sq_base_addr,json=nicSqBaseAddr,proto3" json:"nic_sq_base_addr,omitempty"`
	NicRqBaseAddr     uint64 `protobuf:"varint,6,opt,name=nic_rq_base_addr,json=nicRqBaseAddr,proto3" json:"nic_rq_base_addr,omitempty"`
	RdmaAtomicResAddr uint64 `protobuf:"varint,7,opt,name=rdma_atomic_res_addr,json=rdmaAtomicResAddr,proto3" json:"rdma_atomic_res_addr,omitempty"`
}

func (m *RdmaQpResponse) Reset()                    { *m = RdmaQpResponse{} }
func (m *RdmaQpResponse) String() string            { return proto.CompactTextString(m) }
func (*RdmaQpResponse) ProtoMessage()               {}
func (*RdmaQpResponse) Descriptor() ([]byte, []int) { return fileDescriptorRdma, []int{2} }

func (m *RdmaQpResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *RdmaQpResponse) GetRsqBaseAddr() uint64 {
	if m != nil {
		return m.RsqBaseAddr
	}
	return 0
}

func (m *RdmaQpResponse) GetRrqBaseAddr() uint64 {
	if m != nil {
		return m.RrqBaseAddr
	}
	return 0
}

func (m *RdmaQpResponse) GetNicSqBaseAddr() uint64 {
	if m != nil {
		return m.NicSqBaseAddr
	}
	return 0
}

func (m *RdmaQpResponse) GetNicRqBaseAddr() uint64 {
	if m != nil {
		return m.NicRqBaseAddr
	}
	return 0
}

func (m *RdmaQpResponse) GetRdmaAtomicResAddr() uint64 {
	if m != nil {
		return m.RdmaAtomicResAddr
	}
	return 0
}

// RdmaQpResponseMsg is response to RdmaQpRequestMsg
type RdmaQpResponseMsg struct {
	Response []*RdmaQpResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *RdmaQpResponseMsg) Reset()                    { *m = RdmaQpResponseMsg{} }
func (m *RdmaQpResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*RdmaQpResponseMsg) ProtoMessage()               {}
func (*RdmaQpResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptorRdma, []int{3} }

func (m *RdmaQpResponseMsg) GetResponse() []*RdmaQpResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

// ****************   Update Queue Pair  ********************************//
// RdmaQpUpdate object
type RdmaQpUpdateSpec struct {
	QpNum            uint32           `protobuf:"varint,1,opt,name=qp_num,json=qpNum,proto3" json:"qp_num,omitempty"`
	HwLifId          uint32           `protobuf:"varint,2,opt,name=hw_lif_id,json=hwLifId,proto3" json:"hw_lif_id,omitempty"`
	Oper             RdmaQpUpdateOper `protobuf:"varint,3,opt,name=oper,proto3,enum=rdma.RdmaQpUpdateOper" json:"oper,omitempty"`
	DstQpNum         uint32           `protobuf:"varint,4,opt,name=dst_qp_num,json=dstQpNum,proto3" json:"dst_qp_num,omitempty"`
	HeaderTemplate   []byte           `protobuf:"bytes,5,opt,name=header_template,json=headerTemplate,proto3" json:"header_template,omitempty"`
	QKey             uint32           `protobuf:"varint,6,opt,name=q_key,json=qKey,proto3" json:"q_key,omitempty"`
	EPsn             uint32           `protobuf:"varint,7,opt,name=e_psn,json=ePsn,proto3" json:"e_psn,omitempty"`
	TxPsn            uint32           `protobuf:"varint,8,opt,name=tx_psn,json=txPsn,proto3" json:"tx_psn,omitempty"`
	Ahid             uint32           `protobuf:"varint,9,opt,name=ahid,proto3" json:"ahid,omitempty"`
	Pmtu             uint32           `protobuf:"varint,10,opt,name=pmtu,proto3" json:"pmtu,omitempty"`
	Qstate           uint32           `protobuf:"varint,11,opt,name=qstate,proto3" json:"qstate,omitempty"`
	CurState         uint32           `protobuf:"varint,12,opt,name=cur_state,json=curState,proto3" json:"cur_state,omitempty"`
	EnSqdAsyncNotify uint32           `protobuf:"varint,13,opt,name=en_sqd_async_notify,json=enSqdAsyncNotify,proto3" json:"en_sqd_async_notify,omitempty"`
	Timeout          uint32           `protobuf:"varint,14,opt,name=timeout,proto3" json:"timeout,omitempty"`
	RetryCnt         uint32           `protobuf:"varint,15,opt,name=retry_cnt,json=retryCnt,proto3" json:"retry_cnt,omitempty"`
	RnrRetry         uint32           `protobuf:"varint,16,opt,name=rnr_retry,json=rnrRetry,proto3" json:"rnr_retry,omitempty"`
	MaxQpRdAtomic    uint32           `protobuf:"varint,17,opt,name=max_qp_rd_atomic,json=maxQpRdAtomic,proto3" json:"max_qp_rd_atomic,omitempty"`
	MinRnrTimer      uint32           `protobuf:"varint,18,opt,name=min_rnr_timer,json=minRnrTimer,proto3" json:"min_rnr_timer,omitempty"`
	MaxDestRdAtomic  uint32           `protobuf:"varint,19,opt,name=max_dest_rd_atomic,json=maxDestRdAtomic,proto3" json:"max_dest_rd_atomic,omitempty"`
	AccessFlags      uint32           `protobuf:"varint,20,opt,name=access_flags,json=accessFlags,proto3" json:"access_flags,omitempty"`
	AttrMask         uint32           `protobuf:"varint,21,opt,name=attr_mask,json=attrMask,proto3" json:"attr_mask,omitempty"`
}

func (m *RdmaQpUpdateSpec) Reset()                    { *m = RdmaQpUpdateSpec{} }
func (m *RdmaQpUpdateSpec) String() string            { return proto.CompactTextString(m) }
func (*RdmaQpUpdateSpec) ProtoMessage()               {}
func (*RdmaQpUpdateSpec) Descriptor() ([]byte, []int) { return fileDescriptorRdma, []int{4} }

func (m *RdmaQpUpdateSpec) GetQpNum() uint32 {
	if m != nil {
		return m.QpNum
	}
	return 0
}

func (m *RdmaQpUpdateSpec) GetHwLifId() uint32 {
	if m != nil {
		return m.HwLifId
	}
	return 0
}

func (m *RdmaQpUpdateSpec) GetOper() RdmaQpUpdateOper {
	if m != nil {
		return m.Oper
	}
	return RdmaQpUpdateOper_RDMA_UPDATE_QP_OPER_SET_STATE
}

func (m *RdmaQpUpdateSpec) GetDstQpNum() uint32 {
	if m != nil {
		return m.DstQpNum
	}
	return 0
}

func (m *RdmaQpUpdateSpec) GetHeaderTemplate() []byte {
	if m != nil {
		return m.HeaderTemplate
	}
	return nil
}

func (m *RdmaQpUpdateSpec) GetQKey() uint32 {
	if m != nil {
		return m.QKey
	}
	return 0
}

func (m *RdmaQpUpdateSpec) GetEPsn() uint32 {
	if m != nil {
		return m.EPsn
	}
	return 0
}

func (m *RdmaQpUpdateSpec) GetTxPsn() uint32 {
	if m != nil {
		return m.TxPsn
	}
	return 0
}

func (m *RdmaQpUpdateSpec) GetAhid() uint32 {
	if m != nil {
		return m.Ahid
	}
	return 0
}

func (m *RdmaQpUpdateSpec) GetPmtu() uint32 {
	if m != nil {
		return m.Pmtu
	}
	return 0
}

func (m *RdmaQpUpdateSpec) GetQstate() uint32 {
	if m != nil {
		return m.Qstate
	}
	return 0
}

func (m *RdmaQpUpdateSpec) GetCurState() uint32 {
	if m != nil {
		return m.CurState
	}
	return 0
}

func (m *RdmaQpUpdateSpec) GetEnSqdAsyncNotify() uint32 {
	if m != nil {
		return m.EnSqdAsyncNotify
	}
	return 0
}

func (m *RdmaQpUpdateSpec) GetTimeout() uint32 {
	if m != nil {
		return m.Timeout
	}
	return 0
}

func (m *RdmaQpUpdateSpec) GetRetryCnt() uint32 {
	if m != nil {
		return m.RetryCnt
	}
	return 0
}

func (m *RdmaQpUpdateSpec) GetRnrRetry() uint32 {
	if m != nil {
		return m.RnrRetry
	}
	return 0
}

func (m *RdmaQpUpdateSpec) GetMaxQpRdAtomic() uint32 {
	if m != nil {
		return m.MaxQpRdAtomic
	}
	return 0
}

func (m *RdmaQpUpdateSpec) GetMinRnrTimer() uint32 {
	if m != nil {
		return m.MinRnrTimer
	}
	return 0
}

func (m *RdmaQpUpdateSpec) GetMaxDestRdAtomic() uint32 {
	if m != nil {
		return m.MaxDestRdAtomic
	}
	return 0
}

func (m *RdmaQpUpdateSpec) GetAccessFlags() uint32 {
	if m != nil {
		return m.AccessFlags
	}
	return 0
}

func (m *RdmaQpUpdateSpec) GetAttrMask() uint32 {
	if m != nil {
		return m.AttrMask
	}
	return 0
}

// RdmaQpRequestMsg is batched request used to create/update of Rdma QPs
type RdmaQpUpdateRequestMsg struct {
	Request []*RdmaQpUpdateSpec `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *RdmaQpUpdateRequestMsg) Reset()                    { *m = RdmaQpUpdateRequestMsg{} }
func (m *RdmaQpUpdateRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*RdmaQpUpdateRequestMsg) ProtoMessage()               {}
func (*RdmaQpUpdateRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptorRdma, []int{5} }

func (m *RdmaQpUpdateRequestMsg) GetRequest() []*RdmaQpUpdateSpec {
	if m != nil {
		return m.Request
	}
	return nil
}

// RdmaQpResponse response to one RdmaQpSpec
type RdmaQpUpdateResponse struct {
	ApiStatus ApiStatus `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty"`
}

func (m *RdmaQpUpdateResponse) Reset()                    { *m = RdmaQpUpdateResponse{} }
func (m *RdmaQpUpdateResponse) String() string            { return proto.CompactTextString(m) }
func (*RdmaQpUpdateResponse) ProtoMessage()               {}
func (*RdmaQpUpdateResponse) Descriptor() ([]byte, []int) { return fileDescriptorRdma, []int{6} }

func (m *RdmaQpUpdateResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

// RdmaQpUpdateResponseMsg is response to RdmaQpUpdateRequestMsg
type RdmaQpUpdateResponseMsg struct {
	Response []*RdmaQpUpdateResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *RdmaQpUpdateResponseMsg) Reset()                    { *m = RdmaQpUpdateResponseMsg{} }
func (m *RdmaQpUpdateResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*RdmaQpUpdateResponseMsg) ProtoMessage()               {}
func (*RdmaQpUpdateResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptorRdma, []int{7} }

func (m *RdmaQpUpdateResponseMsg) GetResponse() []*RdmaQpUpdateResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

// **********************    Address Handle  ********************************//
// RdmaAh object
type RdmaAhSpec struct {
	Ahid           uint64 `protobuf:"varint,1,opt,name=ahid,proto3" json:"ahid,omitempty"`
	HwLifId        uint32 `protobuf:"varint,2,opt,name=hw_lif_id,json=hwLifId,proto3" json:"hw_lif_id,omitempty"`
	HeaderTemplate []byte `protobuf:"bytes,3,opt,name=header_template,json=headerTemplate,proto3" json:"header_template,omitempty"`
}

func (m *RdmaAhSpec) Reset()                    { *m = RdmaAhSpec{} }
func (m *RdmaAhSpec) String() string            { return proto.CompactTextString(m) }
func (*RdmaAhSpec) ProtoMessage()               {}
func (*RdmaAhSpec) Descriptor() ([]byte, []int) { return fileDescriptorRdma, []int{8} }

func (m *RdmaAhSpec) GetAhid() uint64 {
	if m != nil {
		return m.Ahid
	}
	return 0
}

func (m *RdmaAhSpec) GetHwLifId() uint32 {
	if m != nil {
		return m.HwLifId
	}
	return 0
}

func (m *RdmaAhSpec) GetHeaderTemplate() []byte {
	if m != nil {
		return m.HeaderTemplate
	}
	return nil
}

// RdmaAhRequestmsg is batched request used to create/update of Rdma QPs
type RdmaAhRequestMsg struct {
	Request []*RdmaAhSpec `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *RdmaAhRequestMsg) Reset()                    { *m = RdmaAhRequestMsg{} }
func (m *RdmaAhRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*RdmaAhRequestMsg) ProtoMessage()               {}
func (*RdmaAhRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptorRdma, []int{9} }

func (m *RdmaAhRequestMsg) GetRequest() []*RdmaAhSpec {
	if m != nil {
		return m.Request
	}
	return nil
}

// RdmaAhResponse to one RdmaAhSpec
type RdmaAhResponse struct {
	ApiStatus ApiStatus `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty"`
}

func (m *RdmaAhResponse) Reset()                    { *m = RdmaAhResponse{} }
func (m *RdmaAhResponse) String() string            { return proto.CompactTextString(m) }
func (*RdmaAhResponse) ProtoMessage()               {}
func (*RdmaAhResponse) Descriptor() ([]byte, []int) { return fileDescriptorRdma, []int{10} }

func (m *RdmaAhResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

// RdmaAhResponseMsg is response to RdmaAhRequestmsg
type RdmaAhResponseMsg struct {
	Response []*RdmaAhResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *RdmaAhResponseMsg) Reset()                    { *m = RdmaAhResponseMsg{} }
func (m *RdmaAhResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*RdmaAhResponseMsg) ProtoMessage()               {}
func (*RdmaAhResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptorRdma, []int{11} }

func (m *RdmaAhResponseMsg) GetResponse() []*RdmaAhResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

// **********************   Completion Queue  *****************************//
// RdmaCq object
type RdmaCqSpec struct {
	CqNum            uint32   `protobuf:"varint,1,opt,name=cq_num,json=cqNum,proto3" json:"cq_num,omitempty"`
	HwLifId          uint32   `protobuf:"varint,2,opt,name=hw_lif_id,json=hwLifId,proto3" json:"hw_lif_id,omitempty"`
	CqWqeSize        uint32   `protobuf:"varint,3,opt,name=cq_wqe_size,json=cqWqeSize,proto3" json:"cq_wqe_size,omitempty"`
	NumCqWqes        uint32   `protobuf:"varint,4,opt,name=num_cq_wqes,json=numCqWqes,proto3" json:"num_cq_wqes,omitempty"`
	HostmemPgSize    uint32   `protobuf:"varint,5,opt,name=hostmem_pg_size,json=hostmemPgSize,proto3" json:"hostmem_pg_size,omitempty"`
	CqLkey           uint32   `protobuf:"varint,6,opt,name=cq_lkey,json=cqLkey,proto3" json:"cq_lkey,omitempty"`
	EqId             uint32   `protobuf:"varint,7,opt,name=eq_id,json=eqId,proto3" json:"eq_id,omitempty"`
	WakeupDpath      bool     `protobuf:"varint,8,opt,name=wakeup_dpath,json=wakeupDpath,proto3" json:"wakeup_dpath,omitempty"`
	WakeupLif        uint32   `protobuf:"varint,9,opt,name=wakeup_lif,json=wakeupLif,proto3" json:"wakeup_lif,omitempty"`
	WakeupQtype      uint32   `protobuf:"varint,10,opt,name=wakeup_qtype,json=wakeupQtype,proto3" json:"wakeup_qtype,omitempty"`
	WakeupQid        uint32   `protobuf:"varint,11,opt,name=wakeup_qid,json=wakeupQid,proto3" json:"wakeup_qid,omitempty"`
	WakeupRingId     uint32   `protobuf:"varint,12,opt,name=wakeup_ring_id,json=wakeupRingId,proto3" json:"wakeup_ring_id,omitempty"`
	HostAddr         bool     `protobuf:"varint,13,opt,name=host_addr,json=hostAddr,proto3" json:"host_addr,omitempty"`
	CqVaPagesPhyAddr []uint64 `protobuf:"varint,14,rep,packed,name=cq_va_pages_phy_addr,json=cqVaPagesPhyAddr" json:"cq_va_pages_phy_addr,omitempty"`
}

func (m *RdmaCqSpec) Reset()                    { *m = RdmaCqSpec{} }
func (m *RdmaCqSpec) String() string            { return proto.CompactTextString(m) }
func (*RdmaCqSpec) ProtoMessage()               {}
func (*RdmaCqSpec) Descriptor() ([]byte, []int) { return fileDescriptorRdma, []int{12} }

func (m *RdmaCqSpec) GetCqNum() uint32 {
	if m != nil {
		return m.CqNum
	}
	return 0
}

func (m *RdmaCqSpec) GetHwLifId() uint32 {
	if m != nil {
		return m.HwLifId
	}
	return 0
}

func (m *RdmaCqSpec) GetCqWqeSize() uint32 {
	if m != nil {
		return m.CqWqeSize
	}
	return 0
}

func (m *RdmaCqSpec) GetNumCqWqes() uint32 {
	if m != nil {
		return m.NumCqWqes
	}
	return 0
}

func (m *RdmaCqSpec) GetHostmemPgSize() uint32 {
	if m != nil {
		return m.HostmemPgSize
	}
	return 0
}

func (m *RdmaCqSpec) GetCqLkey() uint32 {
	if m != nil {
		return m.CqLkey
	}
	return 0
}

func (m *RdmaCqSpec) GetEqId() uint32 {
	if m != nil {
		return m.EqId
	}
	return 0
}

func (m *RdmaCqSpec) GetWakeupDpath() bool {
	if m != nil {
		return m.WakeupDpath
	}
	return false
}

func (m *RdmaCqSpec) GetWakeupLif() uint32 {
	if m != nil {
		return m.WakeupLif
	}
	return 0
}

func (m *RdmaCqSpec) GetWakeupQtype() uint32 {
	if m != nil {
		return m.WakeupQtype
	}
	return 0
}

func (m *RdmaCqSpec) GetWakeupQid() uint32 {
	if m != nil {
		return m.WakeupQid
	}
	return 0
}

func (m *RdmaCqSpec) GetWakeupRingId() uint32 {
	if m != nil {
		return m.WakeupRingId
	}
	return 0
}

func (m *RdmaCqSpec) GetHostAddr() bool {
	if m != nil {
		return m.HostAddr
	}
	return false
}

func (m *RdmaCqSpec) GetCqVaPagesPhyAddr() []uint64 {
	if m != nil {
		return m.CqVaPagesPhyAddr
	}
	return nil
}

// RdmaCqRequestMsg is batched request used to create/update of Rdma QPs
type RdmaCqRequestMsg struct {
	Request []*RdmaCqSpec `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *RdmaCqRequestMsg) Reset()                    { *m = RdmaCqRequestMsg{} }
func (m *RdmaCqRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*RdmaCqRequestMsg) ProtoMessage()               {}
func (*RdmaCqRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptorRdma, []int{13} }

func (m *RdmaCqRequestMsg) GetRequest() []*RdmaCqSpec {
	if m != nil {
		return m.Request
	}
	return nil
}

// RdmaCqResponse response to one RdmaCqSpec
type RdmaCqResponse struct {
	ApiStatus ApiStatus `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty"`
}

func (m *RdmaCqResponse) Reset()                    { *m = RdmaCqResponse{} }
func (m *RdmaCqResponse) String() string            { return proto.CompactTextString(m) }
func (*RdmaCqResponse) ProtoMessage()               {}
func (*RdmaCqResponse) Descriptor() ([]byte, []int) { return fileDescriptorRdma, []int{14} }

func (m *RdmaCqResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

// RdmaCqResponseMsg is response to RdmaCqRequestMsg
type RdmaCqResponseMsg struct {
	Response []*RdmaCqResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *RdmaCqResponseMsg) Reset()                    { *m = RdmaCqResponseMsg{} }
func (m *RdmaCqResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*RdmaCqResponseMsg) ProtoMessage()               {}
func (*RdmaCqResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptorRdma, []int{15} }

func (m *RdmaCqResponseMsg) GetResponse() []*RdmaCqResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

// **********************   Event Queue  *****************************//
// RdmaEq object
type RdmaEqSpec struct {
	EqId           uint32 `protobuf:"varint,1,opt,name=eq_id,json=eqId,proto3" json:"eq_id,omitempty"`
	HwLifId        uint32 `protobuf:"varint,2,opt,name=hw_lif_id,json=hwLifId,proto3" json:"hw_lif_id,omitempty"`
	EqWqeSize      uint32 `protobuf:"varint,3,opt,name=eq_wqe_size,json=eqWqeSize,proto3" json:"eq_wqe_size,omitempty"`
	NumEqWqes      uint32 `protobuf:"varint,4,opt,name=num_eq_wqes,json=numEqWqes,proto3" json:"num_eq_wqes,omitempty"`
	EqeBaseAddrPhy uint64 `protobuf:"varint,5,opt,name=eqe_base_addr_phy,json=eqeBaseAddrPhy,proto3" json:"eqe_base_addr_phy,omitempty"`
	IntNum         uint32 `protobuf:"varint,6,opt,name=int_num,json=intNum,proto3" json:"int_num,omitempty"`
}

func (m *RdmaEqSpec) Reset()                    { *m = RdmaEqSpec{} }
func (m *RdmaEqSpec) String() string            { return proto.CompactTextString(m) }
func (*RdmaEqSpec) ProtoMessage()               {}
func (*RdmaEqSpec) Descriptor() ([]byte, []int) { return fileDescriptorRdma, []int{16} }

func (m *RdmaEqSpec) GetEqId() uint32 {
	if m != nil {
		return m.EqId
	}
	return 0
}

func (m *RdmaEqSpec) GetHwLifId() uint32 {
	if m != nil {
		return m.HwLifId
	}
	return 0
}

func (m *RdmaEqSpec) GetEqWqeSize() uint32 {
	if m != nil {
		return m.EqWqeSize
	}
	return 0
}

func (m *RdmaEqSpec) GetNumEqWqes() uint32 {
	if m != nil {
		return m.NumEqWqes
	}
	return 0
}

func (m *RdmaEqSpec) GetEqeBaseAddrPhy() uint64 {
	if m != nil {
		return m.EqeBaseAddrPhy
	}
	return 0
}

func (m *RdmaEqSpec) GetIntNum() uint32 {
	if m != nil {
		return m.IntNum
	}
	return 0
}

// RdmaEqRequestMsg is batched request used to create/update of Rdma QPs
type RdmaEqRequestMsg struct {
	Request []*RdmaEqSpec `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *RdmaEqRequestMsg) Reset()                    { *m = RdmaEqRequestMsg{} }
func (m *RdmaEqRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*RdmaEqRequestMsg) ProtoMessage()               {}
func (*RdmaEqRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptorRdma, []int{17} }

func (m *RdmaEqRequestMsg) GetRequest() []*RdmaEqSpec {
	if m != nil {
		return m.Request
	}
	return nil
}

// RdmaEqResponse response to one RdmaEqSpec
type RdmaEqResponse struct {
	ApiStatus     ApiStatus `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty"`
	EqIntrTblAddr uint32    `protobuf:"varint,2,opt,name=eq_intr_tbl_addr,json=eqIntrTblAddr,proto3" json:"eq_intr_tbl_addr,omitempty"`
}

func (m *RdmaEqResponse) Reset()                    { *m = RdmaEqResponse{} }
func (m *RdmaEqResponse) String() string            { return proto.CompactTextString(m) }
func (*RdmaEqResponse) ProtoMessage()               {}
func (*RdmaEqResponse) Descriptor() ([]byte, []int) { return fileDescriptorRdma, []int{18} }

func (m *RdmaEqResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *RdmaEqResponse) GetEqIntrTblAddr() uint32 {
	if m != nil {
		return m.EqIntrTblAddr
	}
	return 0
}

// RdmaEqResponseMsg is response to RdmaEqRequestMsg
type RdmaEqResponseMsg struct {
	Response []*RdmaEqResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *RdmaEqResponseMsg) Reset()                    { *m = RdmaEqResponseMsg{} }
func (m *RdmaEqResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*RdmaEqResponseMsg) ProtoMessage()               {}
func (*RdmaEqResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptorRdma, []int{19} }

func (m *RdmaEqResponseMsg) GetResponse() []*RdmaEqResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

// **********************   Memory Registratin(MR)  *********************//
// RdmaMemReg object
type RdmaMemRegSpec struct {
	HwLifId        uint64   `protobuf:"varint,1,opt,name=hw_lif_id,json=hwLifId,proto3" json:"hw_lif_id,omitempty"`
	Pd             uint32   `protobuf:"varint,2,opt,name=pd,proto3" json:"pd,omitempty"`
	Va             uint64   `protobuf:"varint,3,opt,name=va,proto3" json:"va,omitempty"`
	Len            uint32   `protobuf:"varint,4,opt,name=len,proto3" json:"len,omitempty"`
	AcLocalWr      bool     `protobuf:"varint,5,opt,name=ac_local_wr,json=acLocalWr,proto3" json:"ac_local_wr,omitempty"`
	AcRemoteWr     bool     `protobuf:"varint,6,opt,name=ac_remote_wr,json=acRemoteWr,proto3" json:"ac_remote_wr,omitempty"`
	AcRemoteRd     bool     `protobuf:"varint,7,opt,name=ac_remote_rd,json=acRemoteRd,proto3" json:"ac_remote_rd,omitempty"`
	AcRemoteAtomic bool     `protobuf:"varint,8,opt,name=ac_remote_atomic,json=acRemoteAtomic,proto3" json:"ac_remote_atomic,omitempty"`
	Lkey           uint32   `protobuf:"varint,9,opt,name=lkey,proto3" json:"lkey,omitempty"`
	Rkey           uint32   `protobuf:"varint,10,opt,name=rkey,proto3" json:"rkey,omitempty"`
	HostmemPgSize  uint32   `protobuf:"varint,11,opt,name=hostmem_pg_size,json=hostmemPgSize,proto3" json:"hostmem_pg_size,omitempty"`
	OverrideLif    uint32   `protobuf:"varint,12,opt,name=override_lif,json=overrideLif,proto3" json:"override_lif,omitempty"`
	OverrideLifVld bool     `protobuf:"varint,13,opt,name=override_lif_vld,json=overrideLifVld,proto3" json:"override_lif_vld,omitempty"`
	HostAddr       bool     `protobuf:"varint,14,opt,name=host_addr,json=hostAddr,proto3" json:"host_addr,omitempty"`
	VaPagesPhyAddr []uint64 `protobuf:"varint,15,rep,packed,name=va_pages_phy_addr,json=vaPagesPhyAddr" json:"va_pages_phy_addr,omitempty"`
}

func (m *RdmaMemRegSpec) Reset()                    { *m = RdmaMemRegSpec{} }
func (m *RdmaMemRegSpec) String() string            { return proto.CompactTextString(m) }
func (*RdmaMemRegSpec) ProtoMessage()               {}
func (*RdmaMemRegSpec) Descriptor() ([]byte, []int) { return fileDescriptorRdma, []int{20} }

func (m *RdmaMemRegSpec) GetHwLifId() uint64 {
	if m != nil {
		return m.HwLifId
	}
	return 0
}

func (m *RdmaMemRegSpec) GetPd() uint32 {
	if m != nil {
		return m.Pd
	}
	return 0
}

func (m *RdmaMemRegSpec) GetVa() uint64 {
	if m != nil {
		return m.Va
	}
	return 0
}

func (m *RdmaMemRegSpec) GetLen() uint32 {
	if m != nil {
		return m.Len
	}
	return 0
}

func (m *RdmaMemRegSpec) GetAcLocalWr() bool {
	if m != nil {
		return m.AcLocalWr
	}
	return false
}

func (m *RdmaMemRegSpec) GetAcRemoteWr() bool {
	if m != nil {
		return m.AcRemoteWr
	}
	return false
}

func (m *RdmaMemRegSpec) GetAcRemoteRd() bool {
	if m != nil {
		return m.AcRemoteRd
	}
	return false
}

func (m *RdmaMemRegSpec) GetAcRemoteAtomic() bool {
	if m != nil {
		return m.AcRemoteAtomic
	}
	return false
}

func (m *RdmaMemRegSpec) GetLkey() uint32 {
	if m != nil {
		return m.Lkey
	}
	return 0
}

func (m *RdmaMemRegSpec) GetRkey() uint32 {
	if m != nil {
		return m.Rkey
	}
	return 0
}

func (m *RdmaMemRegSpec) GetHostmemPgSize() uint32 {
	if m != nil {
		return m.HostmemPgSize
	}
	return 0
}

func (m *RdmaMemRegSpec) GetOverrideLif() uint32 {
	if m != nil {
		return m.OverrideLif
	}
	return 0
}

func (m *RdmaMemRegSpec) GetOverrideLifVld() bool {
	if m != nil {
		return m.OverrideLifVld
	}
	return false
}

func (m *RdmaMemRegSpec) GetHostAddr() bool {
	if m != nil {
		return m.HostAddr
	}
	return false
}

func (m *RdmaMemRegSpec) GetVaPagesPhyAddr() []uint64 {
	if m != nil {
		return m.VaPagesPhyAddr
	}
	return nil
}

// RdmaMemRegRequestMsg is batched request used to create/update of Rdma QPs
type RdmaMemRegRequestMsg struct {
	Request []*RdmaMemRegSpec `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *RdmaMemRegRequestMsg) Reset()                    { *m = RdmaMemRegRequestMsg{} }
func (m *RdmaMemRegRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*RdmaMemRegRequestMsg) ProtoMessage()               {}
func (*RdmaMemRegRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptorRdma, []int{21} }

func (m *RdmaMemRegRequestMsg) GetRequest() []*RdmaMemRegSpec {
	if m != nil {
		return m.Request
	}
	return nil
}

// RdmaMemRegResponse response to one RdmaMemRegSpec
type RdmaMemRegResponse struct {
	ApiStatus ApiStatus `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty"`
}

func (m *RdmaMemRegResponse) Reset()                    { *m = RdmaMemRegResponse{} }
func (m *RdmaMemRegResponse) String() string            { return proto.CompactTextString(m) }
func (*RdmaMemRegResponse) ProtoMessage()               {}
func (*RdmaMemRegResponse) Descriptor() ([]byte, []int) { return fileDescriptorRdma, []int{22} }

func (m *RdmaMemRegResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

// RdmaMemRegResponseMsg is response to RdmaMemRegRequestMsg
type RdmaMemRegResponseMsg struct {
	Response []*RdmaMemRegResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *RdmaMemRegResponseMsg) Reset()                    { *m = RdmaMemRegResponseMsg{} }
func (m *RdmaMemRegResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*RdmaMemRegResponseMsg) ProtoMessage()               {}
func (*RdmaMemRegResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptorRdma, []int{23} }

func (m *RdmaMemRegResponseMsg) GetResponse() []*RdmaMemRegResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

// **********************   Allocate L_Key  *********************//
// RdmaAllocLkey object
type RdmaAllocLkeySpec struct {
	HwLifId          uint64 `protobuf:"varint,1,opt,name=hw_lif_id,json=hwLifId,proto3" json:"hw_lif_id,omitempty"`
	Pd               uint32 `protobuf:"varint,2,opt,name=pd,proto3" json:"pd,omitempty"`
	RemoteAccess     bool   `protobuf:"varint,3,opt,name=remote_access,json=remoteAccess,proto3" json:"remote_access,omitempty"`
	Lkey             uint32 `protobuf:"varint,4,opt,name=lkey,proto3" json:"lkey,omitempty"`
	Rkey             uint32 `protobuf:"varint,5,opt,name=rkey,proto3" json:"rkey,omitempty"`
	NumPtEntriesRsvd uint32 `protobuf:"varint,6,opt,name=num_pt_entries_rsvd,json=numPtEntriesRsvd,proto3" json:"num_pt_entries_rsvd,omitempty"`
	HostAddr         bool   `protobuf:"varint,7,opt,name=host_addr,json=hostAddr,proto3" json:"host_addr,omitempty"`
}

func (m *RdmaAllocLkeySpec) Reset()                    { *m = RdmaAllocLkeySpec{} }
func (m *RdmaAllocLkeySpec) String() string            { return proto.CompactTextString(m) }
func (*RdmaAllocLkeySpec) ProtoMessage()               {}
func (*RdmaAllocLkeySpec) Descriptor() ([]byte, []int) { return fileDescriptorRdma, []int{24} }

func (m *RdmaAllocLkeySpec) GetHwLifId() uint64 {
	if m != nil {
		return m.HwLifId
	}
	return 0
}

func (m *RdmaAllocLkeySpec) GetPd() uint32 {
	if m != nil {
		return m.Pd
	}
	return 0
}

func (m *RdmaAllocLkeySpec) GetRemoteAccess() bool {
	if m != nil {
		return m.RemoteAccess
	}
	return false
}

func (m *RdmaAllocLkeySpec) GetLkey() uint32 {
	if m != nil {
		return m.Lkey
	}
	return 0
}

func (m *RdmaAllocLkeySpec) GetRkey() uint32 {
	if m != nil {
		return m.Rkey
	}
	return 0
}

func (m *RdmaAllocLkeySpec) GetNumPtEntriesRsvd() uint32 {
	if m != nil {
		return m.NumPtEntriesRsvd
	}
	return 0
}

func (m *RdmaAllocLkeySpec) GetHostAddr() bool {
	if m != nil {
		return m.HostAddr
	}
	return false
}

// RdmaAllocLkeyRequestMsg is batched request used to create/update of Rdma QPs
type RdmaAllocLkeyRequestMsg struct {
	Request []*RdmaAllocLkeySpec `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *RdmaAllocLkeyRequestMsg) Reset()                    { *m = RdmaAllocLkeyRequestMsg{} }
func (m *RdmaAllocLkeyRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*RdmaAllocLkeyRequestMsg) ProtoMessage()               {}
func (*RdmaAllocLkeyRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptorRdma, []int{25} }

func (m *RdmaAllocLkeyRequestMsg) GetRequest() []*RdmaAllocLkeySpec {
	if m != nil {
		return m.Request
	}
	return nil
}

// RdmaAllocLkeyResponse response to one RdmaAllocLkeySpec
type RdmaAllocLkeyResponse struct {
	ApiStatus ApiStatus `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty"`
}

func (m *RdmaAllocLkeyResponse) Reset()                    { *m = RdmaAllocLkeyResponse{} }
func (m *RdmaAllocLkeyResponse) String() string            { return proto.CompactTextString(m) }
func (*RdmaAllocLkeyResponse) ProtoMessage()               {}
func (*RdmaAllocLkeyResponse) Descriptor() ([]byte, []int) { return fileDescriptorRdma, []int{26} }

func (m *RdmaAllocLkeyResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

// RdmaAllocLkeyResponseMsg is response to RdmaAllocLkeyRequestMsg
type RdmaAllocLkeyResponseMsg struct {
	Response []*RdmaAllocLkeyResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *RdmaAllocLkeyResponseMsg) Reset()                    { *m = RdmaAllocLkeyResponseMsg{} }
func (m *RdmaAllocLkeyResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*RdmaAllocLkeyResponseMsg) ProtoMessage()               {}
func (*RdmaAllocLkeyResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptorRdma, []int{27} }

func (m *RdmaAllocLkeyResponseMsg) GetResponse() []*RdmaAllocLkeyResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

type RdmaMemWindowSpec struct {
	HwLifId        uint64               `protobuf:"varint,1,opt,name=hw_lif_id,json=hwLifId,proto3" json:"hw_lif_id,omitempty"`
	Pd             uint32               `protobuf:"varint,2,opt,name=pd,proto3" json:"pd,omitempty"`
	MwType         RdmaMemoryWindowType `protobuf:"varint,3,opt,name=mw_type,json=mwType,proto3,enum=rdma.RdmaMemoryWindowType" json:"mw_type,omitempty"`
	AcRemoteWr     bool                 `protobuf:"varint,4,opt,name=ac_remote_wr,json=acRemoteWr,proto3" json:"ac_remote_wr,omitempty"`
	AcRemoteRd     bool                 `protobuf:"varint,5,opt,name=ac_remote_rd,json=acRemoteRd,proto3" json:"ac_remote_rd,omitempty"`
	AcRemoteAtomic bool                 `protobuf:"varint,6,opt,name=ac_remote_atomic,json=acRemoteAtomic,proto3" json:"ac_remote_atomic,omitempty"`
	Rkey           uint32               `protobuf:"varint,7,opt,name=rkey,proto3" json:"rkey,omitempty"`
	OverrideLif    uint32               `protobuf:"varint,8,opt,name=override_lif,json=overrideLif,proto3" json:"override_lif,omitempty"`
	OverrideLifVld bool                 `protobuf:"varint,9,opt,name=override_lif_vld,json=overrideLifVld,proto3" json:"override_lif_vld,omitempty"`
}

func (m *RdmaMemWindowSpec) Reset()                    { *m = RdmaMemWindowSpec{} }
func (m *RdmaMemWindowSpec) String() string            { return proto.CompactTextString(m) }
func (*RdmaMemWindowSpec) ProtoMessage()               {}
func (*RdmaMemWindowSpec) Descriptor() ([]byte, []int) { return fileDescriptorRdma, []int{28} }

func (m *RdmaMemWindowSpec) GetHwLifId() uint64 {
	if m != nil {
		return m.HwLifId
	}
	return 0
}

func (m *RdmaMemWindowSpec) GetPd() uint32 {
	if m != nil {
		return m.Pd
	}
	return 0
}

func (m *RdmaMemWindowSpec) GetMwType() RdmaMemoryWindowType {
	if m != nil {
		return m.MwType
	}
	return RdmaMemoryWindowType_RDMA_MEMORY_WINDOW_TYPE_NONE
}

func (m *RdmaMemWindowSpec) GetAcRemoteWr() bool {
	if m != nil {
		return m.AcRemoteWr
	}
	return false
}

func (m *RdmaMemWindowSpec) GetAcRemoteRd() bool {
	if m != nil {
		return m.AcRemoteRd
	}
	return false
}

func (m *RdmaMemWindowSpec) GetAcRemoteAtomic() bool {
	if m != nil {
		return m.AcRemoteAtomic
	}
	return false
}

func (m *RdmaMemWindowSpec) GetRkey() uint32 {
	if m != nil {
		return m.Rkey
	}
	return 0
}

func (m *RdmaMemWindowSpec) GetOverrideLif() uint32 {
	if m != nil {
		return m.OverrideLif
	}
	return 0
}

func (m *RdmaMemWindowSpec) GetOverrideLifVld() bool {
	if m != nil {
		return m.OverrideLifVld
	}
	return false
}

// RdmaMemWindowRequestMsg is batched request used to create/update of Rdma QPs
type RdmaMemWindowRequestMsg struct {
	Request []*RdmaMemWindowSpec `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *RdmaMemWindowRequestMsg) Reset()                    { *m = RdmaMemWindowRequestMsg{} }
func (m *RdmaMemWindowRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*RdmaMemWindowRequestMsg) ProtoMessage()               {}
func (*RdmaMemWindowRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptorRdma, []int{29} }

func (m *RdmaMemWindowRequestMsg) GetRequest() []*RdmaMemWindowSpec {
	if m != nil {
		return m.Request
	}
	return nil
}

// RdmaMemWindowResponse response to one RdmaMemWindowSpec
type RdmaMemWindowResponse struct {
	ApiStatus ApiStatus `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty"`
}

func (m *RdmaMemWindowResponse) Reset()                    { *m = RdmaMemWindowResponse{} }
func (m *RdmaMemWindowResponse) String() string            { return proto.CompactTextString(m) }
func (*RdmaMemWindowResponse) ProtoMessage()               {}
func (*RdmaMemWindowResponse) Descriptor() ([]byte, []int) { return fileDescriptorRdma, []int{30} }

func (m *RdmaMemWindowResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

// RdmaMemWindowResponseMsg is response to RdmaMemWindowRequestMsg
type RdmaMemWindowResponseMsg struct {
	Response []*RdmaMemWindowResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *RdmaMemWindowResponseMsg) Reset()                    { *m = RdmaMemWindowResponseMsg{} }
func (m *RdmaMemWindowResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*RdmaMemWindowResponseMsg) ProtoMessage()               {}
func (*RdmaMemWindowResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptorRdma, []int{31} }

func (m *RdmaMemWindowResponseMsg) GetResponse() []*RdmaMemWindowResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

type RdmaAqSpec struct {
	AqNum       uint32 `protobuf:"varint,1,opt,name=aq_num,json=aqNum,proto3" json:"aq_num,omitempty"`
	HwLifId     uint32 `protobuf:"varint,2,opt,name=hw_lif_id,json=hwLifId,proto3" json:"hw_lif_id,omitempty"`
	LogWqeSize  uint32 `protobuf:"varint,3,opt,name=log_wqe_size,json=logWqeSize,proto3" json:"log_wqe_size,omitempty"`
	LogNumWqes  uint32 `protobuf:"varint,4,opt,name=log_num_wqes,json=logNumWqes,proto3" json:"log_num_wqes,omitempty"`
	CqNum       uint32 `protobuf:"varint,5,opt,name=cq_num,json=cqNum,proto3" json:"cq_num,omitempty"`
	PhyBaseAddr uint64 `protobuf:"varint,6,opt,name=phy_base_addr,json=phyBaseAddr,proto3" json:"phy_base_addr,omitempty"`
}

func (m *RdmaAqSpec) Reset()                    { *m = RdmaAqSpec{} }
func (m *RdmaAqSpec) String() string            { return proto.CompactTextString(m) }
func (*RdmaAqSpec) ProtoMessage()               {}
func (*RdmaAqSpec) Descriptor() ([]byte, []int) { return fileDescriptorRdma, []int{32} }

func (m *RdmaAqSpec) GetAqNum() uint32 {
	if m != nil {
		return m.AqNum
	}
	return 0
}

func (m *RdmaAqSpec) GetHwLifId() uint32 {
	if m != nil {
		return m.HwLifId
	}
	return 0
}

func (m *RdmaAqSpec) GetLogWqeSize() uint32 {
	if m != nil {
		return m.LogWqeSize
	}
	return 0
}

func (m *RdmaAqSpec) GetLogNumWqes() uint32 {
	if m != nil {
		return m.LogNumWqes
	}
	return 0
}

func (m *RdmaAqSpec) GetCqNum() uint32 {
	if m != nil {
		return m.CqNum
	}
	return 0
}

func (m *RdmaAqSpec) GetPhyBaseAddr() uint64 {
	if m != nil {
		return m.PhyBaseAddr
	}
	return 0
}

// RdmaAQRequestMsg is batched request used to create of Rdma AQs
type RdmaAqRequestMsg struct {
	Request []*RdmaAqSpec `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *RdmaAqRequestMsg) Reset()                    { *m = RdmaAqRequestMsg{} }
func (m *RdmaAqRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*RdmaAqRequestMsg) ProtoMessage()               {}
func (*RdmaAqRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptorRdma, []int{33} }

func (m *RdmaAqRequestMsg) GetRequest() []*RdmaAqSpec {
	if m != nil {
		return m.Request
	}
	return nil
}

// RdmaQpResponse response to one RdmaAQSpec
type RdmaAqResponse struct {
	ApiStatus ApiStatus `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty"`
}

func (m *RdmaAqResponse) Reset()                    { *m = RdmaAqResponse{} }
func (m *RdmaAqResponse) String() string            { return proto.CompactTextString(m) }
func (*RdmaAqResponse) ProtoMessage()               {}
func (*RdmaAqResponse) Descriptor() ([]byte, []int) { return fileDescriptorRdma, []int{34} }

func (m *RdmaAqResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

// RdmaAQResponseMsg is response to RdmaAQRequestMsg
type RdmaAqResponseMsg struct {
	Response []*RdmaAqResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *RdmaAqResponseMsg) Reset()                    { *m = RdmaAqResponseMsg{} }
func (m *RdmaAqResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*RdmaAqResponseMsg) ProtoMessage()               {}
func (*RdmaAqResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptorRdma, []int{35} }

func (m *RdmaAqResponseMsg) GetResponse() []*RdmaAqResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

func init() {
	proto.RegisterType((*RdmaQpSpec)(nil), "rdma.RdmaQpSpec")
	proto.RegisterType((*RdmaQpRequestMsg)(nil), "rdma.RdmaQpRequestMsg")
	proto.RegisterType((*RdmaQpResponse)(nil), "rdma.RdmaQpResponse")
	proto.RegisterType((*RdmaQpResponseMsg)(nil), "rdma.RdmaQpResponseMsg")
	proto.RegisterType((*RdmaQpUpdateSpec)(nil), "rdma.RdmaQpUpdateSpec")
	proto.RegisterType((*RdmaQpUpdateRequestMsg)(nil), "rdma.RdmaQpUpdateRequestMsg")
	proto.RegisterType((*RdmaQpUpdateResponse)(nil), "rdma.RdmaQpUpdateResponse")
	proto.RegisterType((*RdmaQpUpdateResponseMsg)(nil), "rdma.RdmaQpUpdateResponseMsg")
	proto.RegisterType((*RdmaAhSpec)(nil), "rdma.RdmaAhSpec")
	proto.RegisterType((*RdmaAhRequestMsg)(nil), "rdma.RdmaAhRequestMsg")
	proto.RegisterType((*RdmaAhResponse)(nil), "rdma.RdmaAhResponse")
	proto.RegisterType((*RdmaAhResponseMsg)(nil), "rdma.RdmaAhResponseMsg")
	proto.RegisterType((*RdmaCqSpec)(nil), "rdma.RdmaCqSpec")
	proto.RegisterType((*RdmaCqRequestMsg)(nil), "rdma.RdmaCqRequestMsg")
	proto.RegisterType((*RdmaCqResponse)(nil), "rdma.RdmaCqResponse")
	proto.RegisterType((*RdmaCqResponseMsg)(nil), "rdma.RdmaCqResponseMsg")
	proto.RegisterType((*RdmaEqSpec)(nil), "rdma.RdmaEqSpec")
	proto.RegisterType((*RdmaEqRequestMsg)(nil), "rdma.RdmaEqRequestMsg")
	proto.RegisterType((*RdmaEqResponse)(nil), "rdma.RdmaEqResponse")
	proto.RegisterType((*RdmaEqResponseMsg)(nil), "rdma.RdmaEqResponseMsg")
	proto.RegisterType((*RdmaMemRegSpec)(nil), "rdma.RdmaMemRegSpec")
	proto.RegisterType((*RdmaMemRegRequestMsg)(nil), "rdma.RdmaMemRegRequestMsg")
	proto.RegisterType((*RdmaMemRegResponse)(nil), "rdma.RdmaMemRegResponse")
	proto.RegisterType((*RdmaMemRegResponseMsg)(nil), "rdma.RdmaMemRegResponseMsg")
	proto.RegisterType((*RdmaAllocLkeySpec)(nil), "rdma.RdmaAllocLkeySpec")
	proto.RegisterType((*RdmaAllocLkeyRequestMsg)(nil), "rdma.RdmaAllocLkeyRequestMsg")
	proto.RegisterType((*RdmaAllocLkeyResponse)(nil), "rdma.RdmaAllocLkeyResponse")
	proto.RegisterType((*RdmaAllocLkeyResponseMsg)(nil), "rdma.RdmaAllocLkeyResponseMsg")
	proto.RegisterType((*RdmaMemWindowSpec)(nil), "rdma.RdmaMemWindowSpec")
	proto.RegisterType((*RdmaMemWindowRequestMsg)(nil), "rdma.RdmaMemWindowRequestMsg")
	proto.RegisterType((*RdmaMemWindowResponse)(nil), "rdma.RdmaMemWindowResponse")
	proto.RegisterType((*RdmaMemWindowResponseMsg)(nil), "rdma.RdmaMemWindowResponseMsg")
	proto.RegisterType((*RdmaAqSpec)(nil), "rdma.RdmaAqSpec")
	proto.RegisterType((*RdmaAqRequestMsg)(nil), "rdma.RdmaAqRequestMsg")
	proto.RegisterType((*RdmaAqResponse)(nil), "rdma.RdmaAqResponse")
	proto.RegisterType((*RdmaAqResponseMsg)(nil), "rdma.RdmaAqResponseMsg")
	proto.RegisterEnum("rdma.RdmaServiceType", RdmaServiceType_name, RdmaServiceType_value)
	proto.RegisterEnum("rdma.RdmaQpUpdateOper", RdmaQpUpdateOper_name, RdmaQpUpdateOper_value)
	proto.RegisterEnum("rdma.RdmaQpAccessFlags", RdmaQpAccessFlags_name, RdmaQpAccessFlags_value)
	proto.RegisterEnum("rdma.RdmaMemoryWindowType", RdmaMemoryWindowType_name, RdmaMemoryWindowType_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Rdma service

type RdmaClient interface {
	// Queue Pair related APIs
	RdmaQpCreate(ctx context.Context, in *RdmaQpRequestMsg, opts ...grpc.CallOption) (*RdmaQpResponseMsg, error)
	RdmaQpUpdate(ctx context.Context, in *RdmaQpUpdateRequestMsg, opts ...grpc.CallOption) (*RdmaQpUpdateResponseMsg, error)
	RdmaAhCreate(ctx context.Context, in *RdmaAhRequestMsg, opts ...grpc.CallOption) (*RdmaAhResponseMsg, error)
	// Completion Q related APIs
	RdmaCqCreate(ctx context.Context, in *RdmaCqRequestMsg, opts ...grpc.CallOption) (*RdmaCqResponseMsg, error)
	// Completion Q related APIs
	RdmaEqCreate(ctx context.Context, in *RdmaEqRequestMsg, opts ...grpc.CallOption) (*RdmaEqResponseMsg, error)
	// Register Memory related APIs
	RdmaMemReg(ctx context.Context, in *RdmaMemRegRequestMsg, opts ...grpc.CallOption) (*RdmaMemRegResponseMsg, error)
	// Allocated Lkey  related APIs
	RdmaAllocLkey(ctx context.Context, in *RdmaAllocLkeyRequestMsg, opts ...grpc.CallOption) (*RdmaAllocLkeyResponseMsg, error)
	// Memory Window related APIs
	RdmaMemWindow(ctx context.Context, in *RdmaMemWindowRequestMsg, opts ...grpc.CallOption) (*RdmaMemWindowResponseMsg, error)
	// Create the admin queue
	RdmaAqCreate(ctx context.Context, in *RdmaAqRequestMsg, opts ...grpc.CallOption) (*RdmaAqResponseMsg, error)
}

type rdmaClient struct {
	cc *grpc.ClientConn
}

func NewRdmaClient(cc *grpc.ClientConn) RdmaClient {
	return &rdmaClient{cc}
}

func (c *rdmaClient) RdmaQpCreate(ctx context.Context, in *RdmaQpRequestMsg, opts ...grpc.CallOption) (*RdmaQpResponseMsg, error) {
	out := new(RdmaQpResponseMsg)
	err := grpc.Invoke(ctx, "/rdma.Rdma/RdmaQpCreate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rdmaClient) RdmaQpUpdate(ctx context.Context, in *RdmaQpUpdateRequestMsg, opts ...grpc.CallOption) (*RdmaQpUpdateResponseMsg, error) {
	out := new(RdmaQpUpdateResponseMsg)
	err := grpc.Invoke(ctx, "/rdma.Rdma/RdmaQpUpdate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rdmaClient) RdmaAhCreate(ctx context.Context, in *RdmaAhRequestMsg, opts ...grpc.CallOption) (*RdmaAhResponseMsg, error) {
	out := new(RdmaAhResponseMsg)
	err := grpc.Invoke(ctx, "/rdma.Rdma/RdmaAhCreate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rdmaClient) RdmaCqCreate(ctx context.Context, in *RdmaCqRequestMsg, opts ...grpc.CallOption) (*RdmaCqResponseMsg, error) {
	out := new(RdmaCqResponseMsg)
	err := grpc.Invoke(ctx, "/rdma.Rdma/RdmaCqCreate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rdmaClient) RdmaEqCreate(ctx context.Context, in *RdmaEqRequestMsg, opts ...grpc.CallOption) (*RdmaEqResponseMsg, error) {
	out := new(RdmaEqResponseMsg)
	err := grpc.Invoke(ctx, "/rdma.Rdma/RdmaEqCreate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rdmaClient) RdmaMemReg(ctx context.Context, in *RdmaMemRegRequestMsg, opts ...grpc.CallOption) (*RdmaMemRegResponseMsg, error) {
	out := new(RdmaMemRegResponseMsg)
	err := grpc.Invoke(ctx, "/rdma.Rdma/RdmaMemReg", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rdmaClient) RdmaAllocLkey(ctx context.Context, in *RdmaAllocLkeyRequestMsg, opts ...grpc.CallOption) (*RdmaAllocLkeyResponseMsg, error) {
	out := new(RdmaAllocLkeyResponseMsg)
	err := grpc.Invoke(ctx, "/rdma.Rdma/RdmaAllocLkey", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rdmaClient) RdmaMemWindow(ctx context.Context, in *RdmaMemWindowRequestMsg, opts ...grpc.CallOption) (*RdmaMemWindowResponseMsg, error) {
	out := new(RdmaMemWindowResponseMsg)
	err := grpc.Invoke(ctx, "/rdma.Rdma/RdmaMemWindow", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rdmaClient) RdmaAqCreate(ctx context.Context, in *RdmaAqRequestMsg, opts ...grpc.CallOption) (*RdmaAqResponseMsg, error) {
	out := new(RdmaAqResponseMsg)
	err := grpc.Invoke(ctx, "/rdma.Rdma/RdmaAqCreate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Rdma service

type RdmaServer interface {
	// Queue Pair related APIs
	RdmaQpCreate(context.Context, *RdmaQpRequestMsg) (*RdmaQpResponseMsg, error)
	RdmaQpUpdate(context.Context, *RdmaQpUpdateRequestMsg) (*RdmaQpUpdateResponseMsg, error)
	RdmaAhCreate(context.Context, *RdmaAhRequestMsg) (*RdmaAhResponseMsg, error)
	// Completion Q related APIs
	RdmaCqCreate(context.Context, *RdmaCqRequestMsg) (*RdmaCqResponseMsg, error)
	// Completion Q related APIs
	RdmaEqCreate(context.Context, *RdmaEqRequestMsg) (*RdmaEqResponseMsg, error)
	// Register Memory related APIs
	RdmaMemReg(context.Context, *RdmaMemRegRequestMsg) (*RdmaMemRegResponseMsg, error)
	// Allocated Lkey  related APIs
	RdmaAllocLkey(context.Context, *RdmaAllocLkeyRequestMsg) (*RdmaAllocLkeyResponseMsg, error)
	// Memory Window related APIs
	RdmaMemWindow(context.Context, *RdmaMemWindowRequestMsg) (*RdmaMemWindowResponseMsg, error)
	// Create the admin queue
	RdmaAqCreate(context.Context, *RdmaAqRequestMsg) (*RdmaAqResponseMsg, error)
}

func RegisterRdmaServer(s *grpc.Server, srv RdmaServer) {
	s.RegisterService(&_Rdma_serviceDesc, srv)
}

func _Rdma_RdmaQpCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RdmaQpRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RdmaServer).RdmaQpCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rdma.Rdma/RdmaQpCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RdmaServer).RdmaQpCreate(ctx, req.(*RdmaQpRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Rdma_RdmaQpUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RdmaQpUpdateRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RdmaServer).RdmaQpUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rdma.Rdma/RdmaQpUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RdmaServer).RdmaQpUpdate(ctx, req.(*RdmaQpUpdateRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Rdma_RdmaAhCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RdmaAhRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RdmaServer).RdmaAhCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rdma.Rdma/RdmaAhCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RdmaServer).RdmaAhCreate(ctx, req.(*RdmaAhRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Rdma_RdmaCqCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RdmaCqRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RdmaServer).RdmaCqCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rdma.Rdma/RdmaCqCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RdmaServer).RdmaCqCreate(ctx, req.(*RdmaCqRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Rdma_RdmaEqCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RdmaEqRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RdmaServer).RdmaEqCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rdma.Rdma/RdmaEqCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RdmaServer).RdmaEqCreate(ctx, req.(*RdmaEqRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Rdma_RdmaMemReg_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RdmaMemRegRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RdmaServer).RdmaMemReg(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rdma.Rdma/RdmaMemReg",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RdmaServer).RdmaMemReg(ctx, req.(*RdmaMemRegRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Rdma_RdmaAllocLkey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RdmaAllocLkeyRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RdmaServer).RdmaAllocLkey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rdma.Rdma/RdmaAllocLkey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RdmaServer).RdmaAllocLkey(ctx, req.(*RdmaAllocLkeyRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Rdma_RdmaMemWindow_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RdmaMemWindowRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RdmaServer).RdmaMemWindow(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rdma.Rdma/RdmaMemWindow",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RdmaServer).RdmaMemWindow(ctx, req.(*RdmaMemWindowRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Rdma_RdmaAqCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RdmaAqRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RdmaServer).RdmaAqCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rdma.Rdma/RdmaAqCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RdmaServer).RdmaAqCreate(ctx, req.(*RdmaAqRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

var _Rdma_serviceDesc = grpc.ServiceDesc{
	ServiceName: "rdma.Rdma",
	HandlerType: (*RdmaServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RdmaQpCreate",
			Handler:    _Rdma_RdmaQpCreate_Handler,
		},
		{
			MethodName: "RdmaQpUpdate",
			Handler:    _Rdma_RdmaQpUpdate_Handler,
		},
		{
			MethodName: "RdmaAhCreate",
			Handler:    _Rdma_RdmaAhCreate_Handler,
		},
		{
			MethodName: "RdmaCqCreate",
			Handler:    _Rdma_RdmaCqCreate_Handler,
		},
		{
			MethodName: "RdmaEqCreate",
			Handler:    _Rdma_RdmaEqCreate_Handler,
		},
		{
			MethodName: "RdmaMemReg",
			Handler:    _Rdma_RdmaMemReg_Handler,
		},
		{
			MethodName: "RdmaAllocLkey",
			Handler:    _Rdma_RdmaAllocLkey_Handler,
		},
		{
			MethodName: "RdmaMemWindow",
			Handler:    _Rdma_RdmaMemWindow_Handler,
		},
		{
			MethodName: "RdmaAqCreate",
			Handler:    _Rdma_RdmaAqCreate_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "rdma.proto",
}

func (m *RdmaQpSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RdmaQpSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.QpNum != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.QpNum))
	}
	if m.HwLifId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.HwLifId))
	}
	if m.SqWqeSize != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.SqWqeSize))
	}
	if m.RqWqeSize != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.RqWqeSize))
	}
	if m.NumSqWqes != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.NumSqWqes))
	}
	if m.NumRqWqes != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.NumRqWqes))
	}
	if m.NumRsqWqes != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.NumRsqWqes))
	}
	if m.NumRrqWqes != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.NumRrqWqes))
	}
	if m.Pd != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.Pd))
	}
	if m.Pmtu != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.Pmtu))
	}
	if m.HostmemPgSize != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.HostmemPgSize))
	}
	if m.Svc != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.Svc))
	}
	if m.AtomicEnabled {
		dAtA[i] = 0x68
		i++
		if m.AtomicEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.SqLkey != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.SqLkey))
	}
	if m.RqLkey != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.RqLkey))
	}
	if m.RqCqNum != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.RqCqNum))
	}
	if m.SqCqNum != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.SqCqNum))
	}
	if m.ImmdtAsDbell {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		if m.ImmdtAsDbell {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.SqInNicMemory {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x1
		i++
		if m.SqInNicMemory {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.SqBaseAddr != 0 {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.SqBaseAddr))
	}
	if m.RqInNicMemory {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x1
		i++
		if m.RqInNicMemory {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.RqBaseAddr != 0 {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.RqBaseAddr))
	}
	if m.IfHandle != 0 {
		dAtA[i] = 0xb9
		i++
		dAtA[i] = 0x1
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.IfHandle))
		i += 8
	}
	if len(m.VaPagesPhyAddr) > 0 {
		dAtA2 := make([]byte, len(m.VaPagesPhyAddr)*10)
		var j1 int
		for _, num := range m.VaPagesPhyAddr {
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		dAtA[i] = 0xc2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintRdma(dAtA, i, uint64(j1))
		i += copy(dAtA[i:], dAtA2[:j1])
	}
	if m.NumSqPages != 0 {
		dAtA[i] = 0xc8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.NumSqPages))
	}
	return i, nil
}

func (m *RdmaQpRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RdmaQpRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintRdma(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *RdmaQpResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RdmaQpResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.ApiStatus))
	}
	if m.RsqBaseAddr != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.RsqBaseAddr))
	}
	if m.RrqBaseAddr != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.RrqBaseAddr))
	}
	if m.NicSqBaseAddr != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.NicSqBaseAddr))
	}
	if m.NicRqBaseAddr != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.NicRqBaseAddr))
	}
	if m.RdmaAtomicResAddr != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.RdmaAtomicResAddr))
	}
	return i, nil
}

func (m *RdmaQpResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RdmaQpResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintRdma(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *RdmaQpUpdateSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RdmaQpUpdateSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.QpNum != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.QpNum))
	}
	if m.HwLifId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.HwLifId))
	}
	if m.Oper != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.Oper))
	}
	if m.DstQpNum != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.DstQpNum))
	}
	if len(m.HeaderTemplate) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintRdma(dAtA, i, uint64(len(m.HeaderTemplate)))
		i += copy(dAtA[i:], m.HeaderTemplate)
	}
	if m.QKey != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.QKey))
	}
	if m.EPsn != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.EPsn))
	}
	if m.TxPsn != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.TxPsn))
	}
	if m.Ahid != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.Ahid))
	}
	if m.Pmtu != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.Pmtu))
	}
	if m.Qstate != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.Qstate))
	}
	if m.CurState != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.CurState))
	}
	if m.EnSqdAsyncNotify != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.EnSqdAsyncNotify))
	}
	if m.Timeout != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.Timeout))
	}
	if m.RetryCnt != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.RetryCnt))
	}
	if m.RnrRetry != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.RnrRetry))
	}
	if m.MaxQpRdAtomic != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.MaxQpRdAtomic))
	}
	if m.MinRnrTimer != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.MinRnrTimer))
	}
	if m.MaxDestRdAtomic != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.MaxDestRdAtomic))
	}
	if m.AccessFlags != 0 {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.AccessFlags))
	}
	if m.AttrMask != 0 {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.AttrMask))
	}
	return i, nil
}

func (m *RdmaQpUpdateRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RdmaQpUpdateRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintRdma(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *RdmaQpUpdateResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RdmaQpUpdateResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.ApiStatus))
	}
	return i, nil
}

func (m *RdmaQpUpdateResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RdmaQpUpdateResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintRdma(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *RdmaAhSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RdmaAhSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Ahid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.Ahid))
	}
	if m.HwLifId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.HwLifId))
	}
	if len(m.HeaderTemplate) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintRdma(dAtA, i, uint64(len(m.HeaderTemplate)))
		i += copy(dAtA[i:], m.HeaderTemplate)
	}
	return i, nil
}

func (m *RdmaAhRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RdmaAhRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintRdma(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *RdmaAhResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RdmaAhResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.ApiStatus))
	}
	return i, nil
}

func (m *RdmaAhResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RdmaAhResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintRdma(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *RdmaCqSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RdmaCqSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CqNum != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.CqNum))
	}
	if m.HwLifId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.HwLifId))
	}
	if m.CqWqeSize != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.CqWqeSize))
	}
	if m.NumCqWqes != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.NumCqWqes))
	}
	if m.HostmemPgSize != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.HostmemPgSize))
	}
	if m.CqLkey != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.CqLkey))
	}
	if m.EqId != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.EqId))
	}
	if m.WakeupDpath {
		dAtA[i] = 0x40
		i++
		if m.WakeupDpath {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.WakeupLif != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.WakeupLif))
	}
	if m.WakeupQtype != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.WakeupQtype))
	}
	if m.WakeupQid != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.WakeupQid))
	}
	if m.WakeupRingId != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.WakeupRingId))
	}
	if m.HostAddr {
		dAtA[i] = 0x68
		i++
		if m.HostAddr {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.CqVaPagesPhyAddr) > 0 {
		dAtA4 := make([]byte, len(m.CqVaPagesPhyAddr)*10)
		var j3 int
		for _, num := range m.CqVaPagesPhyAddr {
			for num >= 1<<7 {
				dAtA4[j3] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j3++
			}
			dAtA4[j3] = uint8(num)
			j3++
		}
		dAtA[i] = 0x72
		i++
		i = encodeVarintRdma(dAtA, i, uint64(j3))
		i += copy(dAtA[i:], dAtA4[:j3])
	}
	return i, nil
}

func (m *RdmaCqRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RdmaCqRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintRdma(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *RdmaCqResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RdmaCqResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.ApiStatus))
	}
	return i, nil
}

func (m *RdmaCqResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RdmaCqResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintRdma(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *RdmaEqSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RdmaEqSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.EqId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.EqId))
	}
	if m.HwLifId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.HwLifId))
	}
	if m.EqWqeSize != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.EqWqeSize))
	}
	if m.NumEqWqes != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.NumEqWqes))
	}
	if m.EqeBaseAddrPhy != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.EqeBaseAddrPhy))
	}
	if m.IntNum != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.IntNum))
	}
	return i, nil
}

func (m *RdmaEqRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RdmaEqRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintRdma(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *RdmaEqResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RdmaEqResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.ApiStatus))
	}
	if m.EqIntrTblAddr != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.EqIntrTblAddr))
	}
	return i, nil
}

func (m *RdmaEqResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RdmaEqResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintRdma(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *RdmaMemRegSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RdmaMemRegSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.HwLifId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.HwLifId))
	}
	if m.Pd != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.Pd))
	}
	if m.Va != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.Va))
	}
	if m.Len != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.Len))
	}
	if m.AcLocalWr {
		dAtA[i] = 0x28
		i++
		if m.AcLocalWr {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.AcRemoteWr {
		dAtA[i] = 0x30
		i++
		if m.AcRemoteWr {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.AcRemoteRd {
		dAtA[i] = 0x38
		i++
		if m.AcRemoteRd {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.AcRemoteAtomic {
		dAtA[i] = 0x40
		i++
		if m.AcRemoteAtomic {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Lkey != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.Lkey))
	}
	if m.Rkey != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.Rkey))
	}
	if m.HostmemPgSize != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.HostmemPgSize))
	}
	if m.OverrideLif != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.OverrideLif))
	}
	if m.OverrideLifVld {
		dAtA[i] = 0x68
		i++
		if m.OverrideLifVld {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.HostAddr {
		dAtA[i] = 0x70
		i++
		if m.HostAddr {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.VaPagesPhyAddr) > 0 {
		dAtA6 := make([]byte, len(m.VaPagesPhyAddr)*10)
		var j5 int
		for _, num := range m.VaPagesPhyAddr {
			for num >= 1<<7 {
				dAtA6[j5] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j5++
			}
			dAtA6[j5] = uint8(num)
			j5++
		}
		dAtA[i] = 0x7a
		i++
		i = encodeVarintRdma(dAtA, i, uint64(j5))
		i += copy(dAtA[i:], dAtA6[:j5])
	}
	return i, nil
}

func (m *RdmaMemRegRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RdmaMemRegRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintRdma(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *RdmaMemRegResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RdmaMemRegResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.ApiStatus))
	}
	return i, nil
}

func (m *RdmaMemRegResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RdmaMemRegResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintRdma(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *RdmaAllocLkeySpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RdmaAllocLkeySpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.HwLifId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.HwLifId))
	}
	if m.Pd != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.Pd))
	}
	if m.RemoteAccess {
		dAtA[i] = 0x18
		i++
		if m.RemoteAccess {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Lkey != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.Lkey))
	}
	if m.Rkey != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.Rkey))
	}
	if m.NumPtEntriesRsvd != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.NumPtEntriesRsvd))
	}
	if m.HostAddr {
		dAtA[i] = 0x38
		i++
		if m.HostAddr {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *RdmaAllocLkeyRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RdmaAllocLkeyRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintRdma(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *RdmaAllocLkeyResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RdmaAllocLkeyResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.ApiStatus))
	}
	return i, nil
}

func (m *RdmaAllocLkeyResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RdmaAllocLkeyResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintRdma(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *RdmaMemWindowSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RdmaMemWindowSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.HwLifId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.HwLifId))
	}
	if m.Pd != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.Pd))
	}
	if m.MwType != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.MwType))
	}
	if m.AcRemoteWr {
		dAtA[i] = 0x20
		i++
		if m.AcRemoteWr {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.AcRemoteRd {
		dAtA[i] = 0x28
		i++
		if m.AcRemoteRd {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.AcRemoteAtomic {
		dAtA[i] = 0x30
		i++
		if m.AcRemoteAtomic {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Rkey != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.Rkey))
	}
	if m.OverrideLif != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.OverrideLif))
	}
	if m.OverrideLifVld {
		dAtA[i] = 0x48
		i++
		if m.OverrideLifVld {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *RdmaMemWindowRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RdmaMemWindowRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintRdma(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *RdmaMemWindowResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RdmaMemWindowResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.ApiStatus))
	}
	return i, nil
}

func (m *RdmaMemWindowResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RdmaMemWindowResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintRdma(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *RdmaAqSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RdmaAqSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.AqNum != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.AqNum))
	}
	if m.HwLifId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.HwLifId))
	}
	if m.LogWqeSize != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.LogWqeSize))
	}
	if m.LogNumWqes != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.LogNumWqes))
	}
	if m.CqNum != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.CqNum))
	}
	if m.PhyBaseAddr != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.PhyBaseAddr))
	}
	return i, nil
}

func (m *RdmaAqRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RdmaAqRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintRdma(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *RdmaAqResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RdmaAqResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.ApiStatus))
	}
	return i, nil
}

func (m *RdmaAqResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RdmaAqResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintRdma(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func encodeVarintRdma(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *RdmaQpSpec) Size() (n int) {
	var l int
	_ = l
	if m.QpNum != 0 {
		n += 1 + sovRdma(uint64(m.QpNum))
	}
	if m.HwLifId != 0 {
		n += 1 + sovRdma(uint64(m.HwLifId))
	}
	if m.SqWqeSize != 0 {
		n += 1 + sovRdma(uint64(m.SqWqeSize))
	}
	if m.RqWqeSize != 0 {
		n += 1 + sovRdma(uint64(m.RqWqeSize))
	}
	if m.NumSqWqes != 0 {
		n += 1 + sovRdma(uint64(m.NumSqWqes))
	}
	if m.NumRqWqes != 0 {
		n += 1 + sovRdma(uint64(m.NumRqWqes))
	}
	if m.NumRsqWqes != 0 {
		n += 1 + sovRdma(uint64(m.NumRsqWqes))
	}
	if m.NumRrqWqes != 0 {
		n += 1 + sovRdma(uint64(m.NumRrqWqes))
	}
	if m.Pd != 0 {
		n += 1 + sovRdma(uint64(m.Pd))
	}
	if m.Pmtu != 0 {
		n += 1 + sovRdma(uint64(m.Pmtu))
	}
	if m.HostmemPgSize != 0 {
		n += 1 + sovRdma(uint64(m.HostmemPgSize))
	}
	if m.Svc != 0 {
		n += 1 + sovRdma(uint64(m.Svc))
	}
	if m.AtomicEnabled {
		n += 2
	}
	if m.SqLkey != 0 {
		n += 1 + sovRdma(uint64(m.SqLkey))
	}
	if m.RqLkey != 0 {
		n += 1 + sovRdma(uint64(m.RqLkey))
	}
	if m.RqCqNum != 0 {
		n += 2 + sovRdma(uint64(m.RqCqNum))
	}
	if m.SqCqNum != 0 {
		n += 2 + sovRdma(uint64(m.SqCqNum))
	}
	if m.ImmdtAsDbell {
		n += 3
	}
	if m.SqInNicMemory {
		n += 3
	}
	if m.SqBaseAddr != 0 {
		n += 2 + sovRdma(uint64(m.SqBaseAddr))
	}
	if m.RqInNicMemory {
		n += 3
	}
	if m.RqBaseAddr != 0 {
		n += 2 + sovRdma(uint64(m.RqBaseAddr))
	}
	if m.IfHandle != 0 {
		n += 10
	}
	if len(m.VaPagesPhyAddr) > 0 {
		l = 0
		for _, e := range m.VaPagesPhyAddr {
			l += sovRdma(uint64(e))
		}
		n += 2 + sovRdma(uint64(l)) + l
	}
	if m.NumSqPages != 0 {
		n += 2 + sovRdma(uint64(m.NumSqPages))
	}
	return n
}

func (m *RdmaQpRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovRdma(uint64(l))
		}
	}
	return n
}

func (m *RdmaQpResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovRdma(uint64(m.ApiStatus))
	}
	if m.RsqBaseAddr != 0 {
		n += 1 + sovRdma(uint64(m.RsqBaseAddr))
	}
	if m.RrqBaseAddr != 0 {
		n += 1 + sovRdma(uint64(m.RrqBaseAddr))
	}
	if m.NicSqBaseAddr != 0 {
		n += 1 + sovRdma(uint64(m.NicSqBaseAddr))
	}
	if m.NicRqBaseAddr != 0 {
		n += 1 + sovRdma(uint64(m.NicRqBaseAddr))
	}
	if m.RdmaAtomicResAddr != 0 {
		n += 1 + sovRdma(uint64(m.RdmaAtomicResAddr))
	}
	return n
}

func (m *RdmaQpResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovRdma(uint64(l))
		}
	}
	return n
}

func (m *RdmaQpUpdateSpec) Size() (n int) {
	var l int
	_ = l
	if m.QpNum != 0 {
		n += 1 + sovRdma(uint64(m.QpNum))
	}
	if m.HwLifId != 0 {
		n += 1 + sovRdma(uint64(m.HwLifId))
	}
	if m.Oper != 0 {
		n += 1 + sovRdma(uint64(m.Oper))
	}
	if m.DstQpNum != 0 {
		n += 1 + sovRdma(uint64(m.DstQpNum))
	}
	l = len(m.HeaderTemplate)
	if l > 0 {
		n += 1 + l + sovRdma(uint64(l))
	}
	if m.QKey != 0 {
		n += 1 + sovRdma(uint64(m.QKey))
	}
	if m.EPsn != 0 {
		n += 1 + sovRdma(uint64(m.EPsn))
	}
	if m.TxPsn != 0 {
		n += 1 + sovRdma(uint64(m.TxPsn))
	}
	if m.Ahid != 0 {
		n += 1 + sovRdma(uint64(m.Ahid))
	}
	if m.Pmtu != 0 {
		n += 1 + sovRdma(uint64(m.Pmtu))
	}
	if m.Qstate != 0 {
		n += 1 + sovRdma(uint64(m.Qstate))
	}
	if m.CurState != 0 {
		n += 1 + sovRdma(uint64(m.CurState))
	}
	if m.EnSqdAsyncNotify != 0 {
		n += 1 + sovRdma(uint64(m.EnSqdAsyncNotify))
	}
	if m.Timeout != 0 {
		n += 1 + sovRdma(uint64(m.Timeout))
	}
	if m.RetryCnt != 0 {
		n += 1 + sovRdma(uint64(m.RetryCnt))
	}
	if m.RnrRetry != 0 {
		n += 2 + sovRdma(uint64(m.RnrRetry))
	}
	if m.MaxQpRdAtomic != 0 {
		n += 2 + sovRdma(uint64(m.MaxQpRdAtomic))
	}
	if m.MinRnrTimer != 0 {
		n += 2 + sovRdma(uint64(m.MinRnrTimer))
	}
	if m.MaxDestRdAtomic != 0 {
		n += 2 + sovRdma(uint64(m.MaxDestRdAtomic))
	}
	if m.AccessFlags != 0 {
		n += 2 + sovRdma(uint64(m.AccessFlags))
	}
	if m.AttrMask != 0 {
		n += 2 + sovRdma(uint64(m.AttrMask))
	}
	return n
}

func (m *RdmaQpUpdateRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovRdma(uint64(l))
		}
	}
	return n
}

func (m *RdmaQpUpdateResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovRdma(uint64(m.ApiStatus))
	}
	return n
}

func (m *RdmaQpUpdateResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovRdma(uint64(l))
		}
	}
	return n
}

func (m *RdmaAhSpec) Size() (n int) {
	var l int
	_ = l
	if m.Ahid != 0 {
		n += 1 + sovRdma(uint64(m.Ahid))
	}
	if m.HwLifId != 0 {
		n += 1 + sovRdma(uint64(m.HwLifId))
	}
	l = len(m.HeaderTemplate)
	if l > 0 {
		n += 1 + l + sovRdma(uint64(l))
	}
	return n
}

func (m *RdmaAhRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovRdma(uint64(l))
		}
	}
	return n
}

func (m *RdmaAhResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovRdma(uint64(m.ApiStatus))
	}
	return n
}

func (m *RdmaAhResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovRdma(uint64(l))
		}
	}
	return n
}

func (m *RdmaCqSpec) Size() (n int) {
	var l int
	_ = l
	if m.CqNum != 0 {
		n += 1 + sovRdma(uint64(m.CqNum))
	}
	if m.HwLifId != 0 {
		n += 1 + sovRdma(uint64(m.HwLifId))
	}
	if m.CqWqeSize != 0 {
		n += 1 + sovRdma(uint64(m.CqWqeSize))
	}
	if m.NumCqWqes != 0 {
		n += 1 + sovRdma(uint64(m.NumCqWqes))
	}
	if m.HostmemPgSize != 0 {
		n += 1 + sovRdma(uint64(m.HostmemPgSize))
	}
	if m.CqLkey != 0 {
		n += 1 + sovRdma(uint64(m.CqLkey))
	}
	if m.EqId != 0 {
		n += 1 + sovRdma(uint64(m.EqId))
	}
	if m.WakeupDpath {
		n += 2
	}
	if m.WakeupLif != 0 {
		n += 1 + sovRdma(uint64(m.WakeupLif))
	}
	if m.WakeupQtype != 0 {
		n += 1 + sovRdma(uint64(m.WakeupQtype))
	}
	if m.WakeupQid != 0 {
		n += 1 + sovRdma(uint64(m.WakeupQid))
	}
	if m.WakeupRingId != 0 {
		n += 1 + sovRdma(uint64(m.WakeupRingId))
	}
	if m.HostAddr {
		n += 2
	}
	if len(m.CqVaPagesPhyAddr) > 0 {
		l = 0
		for _, e := range m.CqVaPagesPhyAddr {
			l += sovRdma(uint64(e))
		}
		n += 1 + sovRdma(uint64(l)) + l
	}
	return n
}

func (m *RdmaCqRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovRdma(uint64(l))
		}
	}
	return n
}

func (m *RdmaCqResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovRdma(uint64(m.ApiStatus))
	}
	return n
}

func (m *RdmaCqResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovRdma(uint64(l))
		}
	}
	return n
}

func (m *RdmaEqSpec) Size() (n int) {
	var l int
	_ = l
	if m.EqId != 0 {
		n += 1 + sovRdma(uint64(m.EqId))
	}
	if m.HwLifId != 0 {
		n += 1 + sovRdma(uint64(m.HwLifId))
	}
	if m.EqWqeSize != 0 {
		n += 1 + sovRdma(uint64(m.EqWqeSize))
	}
	if m.NumEqWqes != 0 {
		n += 1 + sovRdma(uint64(m.NumEqWqes))
	}
	if m.EqeBaseAddrPhy != 0 {
		n += 1 + sovRdma(uint64(m.EqeBaseAddrPhy))
	}
	if m.IntNum != 0 {
		n += 1 + sovRdma(uint64(m.IntNum))
	}
	return n
}

func (m *RdmaEqRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovRdma(uint64(l))
		}
	}
	return n
}

func (m *RdmaEqResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovRdma(uint64(m.ApiStatus))
	}
	if m.EqIntrTblAddr != 0 {
		n += 1 + sovRdma(uint64(m.EqIntrTblAddr))
	}
	return n
}

func (m *RdmaEqResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovRdma(uint64(l))
		}
	}
	return n
}

func (m *RdmaMemRegSpec) Size() (n int) {
	var l int
	_ = l
	if m.HwLifId != 0 {
		n += 1 + sovRdma(uint64(m.HwLifId))
	}
	if m.Pd != 0 {
		n += 1 + sovRdma(uint64(m.Pd))
	}
	if m.Va != 0 {
		n += 1 + sovRdma(uint64(m.Va))
	}
	if m.Len != 0 {
		n += 1 + sovRdma(uint64(m.Len))
	}
	if m.AcLocalWr {
		n += 2
	}
	if m.AcRemoteWr {
		n += 2
	}
	if m.AcRemoteRd {
		n += 2
	}
	if m.AcRemoteAtomic {
		n += 2
	}
	if m.Lkey != 0 {
		n += 1 + sovRdma(uint64(m.Lkey))
	}
	if m.Rkey != 0 {
		n += 1 + sovRdma(uint64(m.Rkey))
	}
	if m.HostmemPgSize != 0 {
		n += 1 + sovRdma(uint64(m.HostmemPgSize))
	}
	if m.OverrideLif != 0 {
		n += 1 + sovRdma(uint64(m.OverrideLif))
	}
	if m.OverrideLifVld {
		n += 2
	}
	if m.HostAddr {
		n += 2
	}
	if len(m.VaPagesPhyAddr) > 0 {
		l = 0
		for _, e := range m.VaPagesPhyAddr {
			l += sovRdma(uint64(e))
		}
		n += 1 + sovRdma(uint64(l)) + l
	}
	return n
}

func (m *RdmaMemRegRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovRdma(uint64(l))
		}
	}
	return n
}

func (m *RdmaMemRegResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovRdma(uint64(m.ApiStatus))
	}
	return n
}

func (m *RdmaMemRegResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovRdma(uint64(l))
		}
	}
	return n
}

func (m *RdmaAllocLkeySpec) Size() (n int) {
	var l int
	_ = l
	if m.HwLifId != 0 {
		n += 1 + sovRdma(uint64(m.HwLifId))
	}
	if m.Pd != 0 {
		n += 1 + sovRdma(uint64(m.Pd))
	}
	if m.RemoteAccess {
		n += 2
	}
	if m.Lkey != 0 {
		n += 1 + sovRdma(uint64(m.Lkey))
	}
	if m.Rkey != 0 {
		n += 1 + sovRdma(uint64(m.Rkey))
	}
	if m.NumPtEntriesRsvd != 0 {
		n += 1 + sovRdma(uint64(m.NumPtEntriesRsvd))
	}
	if m.HostAddr {
		n += 2
	}
	return n
}

func (m *RdmaAllocLkeyRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovRdma(uint64(l))
		}
	}
	return n
}

func (m *RdmaAllocLkeyResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovRdma(uint64(m.ApiStatus))
	}
	return n
}

func (m *RdmaAllocLkeyResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovRdma(uint64(l))
		}
	}
	return n
}

func (m *RdmaMemWindowSpec) Size() (n int) {
	var l int
	_ = l
	if m.HwLifId != 0 {
		n += 1 + sovRdma(uint64(m.HwLifId))
	}
	if m.Pd != 0 {
		n += 1 + sovRdma(uint64(m.Pd))
	}
	if m.MwType != 0 {
		n += 1 + sovRdma(uint64(m.MwType))
	}
	if m.AcRemoteWr {
		n += 2
	}
	if m.AcRemoteRd {
		n += 2
	}
	if m.AcRemoteAtomic {
		n += 2
	}
	if m.Rkey != 0 {
		n += 1 + sovRdma(uint64(m.Rkey))
	}
	if m.OverrideLif != 0 {
		n += 1 + sovRdma(uint64(m.OverrideLif))
	}
	if m.OverrideLifVld {
		n += 2
	}
	return n
}

func (m *RdmaMemWindowRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovRdma(uint64(l))
		}
	}
	return n
}

func (m *RdmaMemWindowResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovRdma(uint64(m.ApiStatus))
	}
	return n
}

func (m *RdmaMemWindowResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovRdma(uint64(l))
		}
	}
	return n
}

func (m *RdmaAqSpec) Size() (n int) {
	var l int
	_ = l
	if m.AqNum != 0 {
		n += 1 + sovRdma(uint64(m.AqNum))
	}
	if m.HwLifId != 0 {
		n += 1 + sovRdma(uint64(m.HwLifId))
	}
	if m.LogWqeSize != 0 {
		n += 1 + sovRdma(uint64(m.LogWqeSize))
	}
	if m.LogNumWqes != 0 {
		n += 1 + sovRdma(uint64(m.LogNumWqes))
	}
	if m.CqNum != 0 {
		n += 1 + sovRdma(uint64(m.CqNum))
	}
	if m.PhyBaseAddr != 0 {
		n += 1 + sovRdma(uint64(m.PhyBaseAddr))
	}
	return n
}

func (m *RdmaAqRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovRdma(uint64(l))
		}
	}
	return n
}

func (m *RdmaAqResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovRdma(uint64(m.ApiStatus))
	}
	return n
}

func (m *RdmaAqResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovRdma(uint64(l))
		}
	}
	return n
}

func sovRdma(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozRdma(x uint64) (n int) {
	return sovRdma(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *RdmaQpSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRdma
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RdmaQpSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RdmaQpSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field QpNum", wireType)
			}
			m.QpNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.QpNum |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HwLifId", wireType)
			}
			m.HwLifId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HwLifId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SqWqeSize", wireType)
			}
			m.SqWqeSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SqWqeSize |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RqWqeSize", wireType)
			}
			m.RqWqeSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RqWqeSize |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumSqWqes", wireType)
			}
			m.NumSqWqes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumSqWqes |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumRqWqes", wireType)
			}
			m.NumRqWqes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumRqWqes |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumRsqWqes", wireType)
			}
			m.NumRsqWqes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumRsqWqes |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumRrqWqes", wireType)
			}
			m.NumRrqWqes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumRrqWqes |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pd", wireType)
			}
			m.Pd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pd |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pmtu", wireType)
			}
			m.Pmtu = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pmtu |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostmemPgSize", wireType)
			}
			m.HostmemPgSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HostmemPgSize |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Svc", wireType)
			}
			m.Svc = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Svc |= (RdmaServiceType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AtomicEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AtomicEnabled = bool(v != 0)
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SqLkey", wireType)
			}
			m.SqLkey = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SqLkey |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RqLkey", wireType)
			}
			m.RqLkey = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RqLkey |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RqCqNum", wireType)
			}
			m.RqCqNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RqCqNum |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SqCqNum", wireType)
			}
			m.SqCqNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SqCqNum |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImmdtAsDbell", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ImmdtAsDbell = bool(v != 0)
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SqInNicMemory", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SqInNicMemory = bool(v != 0)
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SqBaseAddr", wireType)
			}
			m.SqBaseAddr = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SqBaseAddr |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RqInNicMemory", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RqInNicMemory = bool(v != 0)
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RqBaseAddr", wireType)
			}
			m.RqBaseAddr = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RqBaseAddr |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field IfHandle", wireType)
			}
			m.IfHandle = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.IfHandle = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 24:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRdma
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.VaPagesPhyAddr = append(m.VaPagesPhyAddr, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRdma
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthRdma
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRdma
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.VaPagesPhyAddr = append(m.VaPagesPhyAddr, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field VaPagesPhyAddr", wireType)
			}
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumSqPages", wireType)
			}
			m.NumSqPages = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumSqPages |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRdma(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRdma
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RdmaQpRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRdma
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RdmaQpRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RdmaQpRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRdma
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &RdmaQpSpec{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRdma(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRdma
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RdmaQpResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRdma
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RdmaQpResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RdmaQpResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RsqBaseAddr", wireType)
			}
			m.RsqBaseAddr = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RsqBaseAddr |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RrqBaseAddr", wireType)
			}
			m.RrqBaseAddr = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RrqBaseAddr |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NicSqBaseAddr", wireType)
			}
			m.NicSqBaseAddr = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NicSqBaseAddr |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NicRqBaseAddr", wireType)
			}
			m.NicRqBaseAddr = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NicRqBaseAddr |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RdmaAtomicResAddr", wireType)
			}
			m.RdmaAtomicResAddr = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RdmaAtomicResAddr |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRdma(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRdma
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RdmaQpResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRdma
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RdmaQpResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RdmaQpResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRdma
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &RdmaQpResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRdma(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRdma
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RdmaQpUpdateSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRdma
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RdmaQpUpdateSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RdmaQpUpdateSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field QpNum", wireType)
			}
			m.QpNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.QpNum |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HwLifId", wireType)
			}
			m.HwLifId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HwLifId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Oper", wireType)
			}
			m.Oper = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Oper |= (RdmaQpUpdateOper(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstQpNum", wireType)
			}
			m.DstQpNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DstQpNum |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeaderTemplate", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRdma
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HeaderTemplate = append(m.HeaderTemplate[:0], dAtA[iNdEx:postIndex]...)
			if m.HeaderTemplate == nil {
				m.HeaderTemplate = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field QKey", wireType)
			}
			m.QKey = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.QKey |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EPsn", wireType)
			}
			m.EPsn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EPsn |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxPsn", wireType)
			}
			m.TxPsn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TxPsn |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ahid", wireType)
			}
			m.Ahid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ahid |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pmtu", wireType)
			}
			m.Pmtu = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pmtu |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Qstate", wireType)
			}
			m.Qstate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Qstate |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurState", wireType)
			}
			m.CurState = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurState |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnSqdAsyncNotify", wireType)
			}
			m.EnSqdAsyncNotify = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EnSqdAsyncNotify |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timeout", wireType)
			}
			m.Timeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timeout |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetryCnt", wireType)
			}
			m.RetryCnt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RetryCnt |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RnrRetry", wireType)
			}
			m.RnrRetry = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RnrRetry |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxQpRdAtomic", wireType)
			}
			m.MaxQpRdAtomic = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxQpRdAtomic |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinRnrTimer", wireType)
			}
			m.MinRnrTimer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinRnrTimer |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxDestRdAtomic", wireType)
			}
			m.MaxDestRdAtomic = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxDestRdAtomic |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessFlags", wireType)
			}
			m.AccessFlags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccessFlags |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttrMask", wireType)
			}
			m.AttrMask = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AttrMask |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRdma(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRdma
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RdmaQpUpdateRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRdma
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RdmaQpUpdateRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RdmaQpUpdateRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRdma
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &RdmaQpUpdateSpec{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRdma(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRdma
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RdmaQpUpdateResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRdma
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RdmaQpUpdateResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RdmaQpUpdateResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRdma(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRdma
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RdmaQpUpdateResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRdma
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RdmaQpUpdateResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RdmaQpUpdateResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRdma
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &RdmaQpUpdateResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRdma(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRdma
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RdmaAhSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRdma
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RdmaAhSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RdmaAhSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ahid", wireType)
			}
			m.Ahid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ahid |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HwLifId", wireType)
			}
			m.HwLifId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HwLifId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeaderTemplate", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRdma
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HeaderTemplate = append(m.HeaderTemplate[:0], dAtA[iNdEx:postIndex]...)
			if m.HeaderTemplate == nil {
				m.HeaderTemplate = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRdma(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRdma
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RdmaAhRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRdma
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RdmaAhRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RdmaAhRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRdma
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &RdmaAhSpec{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRdma(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRdma
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RdmaAhResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRdma
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RdmaAhResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RdmaAhResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRdma(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRdma
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RdmaAhResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRdma
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RdmaAhResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RdmaAhResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRdma
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &RdmaAhResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRdma(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRdma
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RdmaCqSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRdma
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RdmaCqSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RdmaCqSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CqNum", wireType)
			}
			m.CqNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CqNum |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HwLifId", wireType)
			}
			m.HwLifId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HwLifId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CqWqeSize", wireType)
			}
			m.CqWqeSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CqWqeSize |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumCqWqes", wireType)
			}
			m.NumCqWqes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumCqWqes |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostmemPgSize", wireType)
			}
			m.HostmemPgSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HostmemPgSize |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CqLkey", wireType)
			}
			m.CqLkey = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CqLkey |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EqId", wireType)
			}
			m.EqId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EqId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WakeupDpath", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.WakeupDpath = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WakeupLif", wireType)
			}
			m.WakeupLif = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WakeupLif |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WakeupQtype", wireType)
			}
			m.WakeupQtype = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WakeupQtype |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WakeupQid", wireType)
			}
			m.WakeupQid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WakeupQid |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WakeupRingId", wireType)
			}
			m.WakeupRingId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WakeupRingId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostAddr", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HostAddr = bool(v != 0)
		case 14:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRdma
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.CqVaPagesPhyAddr = append(m.CqVaPagesPhyAddr, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRdma
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthRdma
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRdma
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.CqVaPagesPhyAddr = append(m.CqVaPagesPhyAddr, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CqVaPagesPhyAddr", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRdma(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRdma
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RdmaCqRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRdma
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RdmaCqRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RdmaCqRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRdma
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &RdmaCqSpec{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRdma(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRdma
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RdmaCqResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRdma
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RdmaCqResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RdmaCqResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRdma(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRdma
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RdmaCqResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRdma
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RdmaCqResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RdmaCqResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRdma
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &RdmaCqResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRdma(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRdma
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RdmaEqSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRdma
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RdmaEqSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RdmaEqSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EqId", wireType)
			}
			m.EqId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EqId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HwLifId", wireType)
			}
			m.HwLifId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HwLifId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EqWqeSize", wireType)
			}
			m.EqWqeSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EqWqeSize |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumEqWqes", wireType)
			}
			m.NumEqWqes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumEqWqes |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EqeBaseAddrPhy", wireType)
			}
			m.EqeBaseAddrPhy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EqeBaseAddrPhy |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IntNum", wireType)
			}
			m.IntNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IntNum |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRdma(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRdma
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RdmaEqRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRdma
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RdmaEqRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RdmaEqRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRdma
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &RdmaEqSpec{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRdma(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRdma
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RdmaEqResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRdma
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RdmaEqResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RdmaEqResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EqIntrTblAddr", wireType)
			}
			m.EqIntrTblAddr = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EqIntrTblAddr |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRdma(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRdma
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RdmaEqResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRdma
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RdmaEqResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RdmaEqResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRdma
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &RdmaEqResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRdma(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRdma
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RdmaMemRegSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRdma
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RdmaMemRegSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RdmaMemRegSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HwLifId", wireType)
			}
			m.HwLifId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HwLifId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pd", wireType)
			}
			m.Pd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pd |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Va", wireType)
			}
			m.Va = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Va |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Len", wireType)
			}
			m.Len = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Len |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AcLocalWr", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AcLocalWr = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AcRemoteWr", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AcRemoteWr = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AcRemoteRd", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AcRemoteRd = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AcRemoteAtomic", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AcRemoteAtomic = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lkey", wireType)
			}
			m.Lkey = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Lkey |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rkey", wireType)
			}
			m.Rkey = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rkey |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostmemPgSize", wireType)
			}
			m.HostmemPgSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HostmemPgSize |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OverrideLif", wireType)
			}
			m.OverrideLif = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OverrideLif |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OverrideLifVld", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OverrideLifVld = bool(v != 0)
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostAddr", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HostAddr = bool(v != 0)
		case 15:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRdma
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.VaPagesPhyAddr = append(m.VaPagesPhyAddr, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRdma
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthRdma
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRdma
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.VaPagesPhyAddr = append(m.VaPagesPhyAddr, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field VaPagesPhyAddr", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRdma(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRdma
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RdmaMemRegRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRdma
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RdmaMemRegRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RdmaMemRegRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRdma
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &RdmaMemRegSpec{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRdma(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRdma
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RdmaMemRegResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRdma
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RdmaMemRegResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RdmaMemRegResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRdma(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRdma
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RdmaMemRegResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRdma
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RdmaMemRegResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RdmaMemRegResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRdma
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &RdmaMemRegResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRdma(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRdma
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RdmaAllocLkeySpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRdma
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RdmaAllocLkeySpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RdmaAllocLkeySpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HwLifId", wireType)
			}
			m.HwLifId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HwLifId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pd", wireType)
			}
			m.Pd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pd |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoteAccess", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RemoteAccess = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lkey", wireType)
			}
			m.Lkey = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Lkey |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rkey", wireType)
			}
			m.Rkey = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rkey |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumPtEntriesRsvd", wireType)
			}
			m.NumPtEntriesRsvd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumPtEntriesRsvd |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostAddr", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HostAddr = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipRdma(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRdma
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RdmaAllocLkeyRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRdma
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RdmaAllocLkeyRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RdmaAllocLkeyRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRdma
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &RdmaAllocLkeySpec{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRdma(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRdma
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RdmaAllocLkeyResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRdma
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RdmaAllocLkeyResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RdmaAllocLkeyResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRdma(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRdma
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RdmaAllocLkeyResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRdma
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RdmaAllocLkeyResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RdmaAllocLkeyResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRdma
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &RdmaAllocLkeyResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRdma(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRdma
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RdmaMemWindowSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRdma
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RdmaMemWindowSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RdmaMemWindowSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HwLifId", wireType)
			}
			m.HwLifId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HwLifId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pd", wireType)
			}
			m.Pd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pd |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MwType", wireType)
			}
			m.MwType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MwType |= (RdmaMemoryWindowType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AcRemoteWr", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AcRemoteWr = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AcRemoteRd", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AcRemoteRd = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AcRemoteAtomic", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AcRemoteAtomic = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rkey", wireType)
			}
			m.Rkey = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rkey |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OverrideLif", wireType)
			}
			m.OverrideLif = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OverrideLif |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OverrideLifVld", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OverrideLifVld = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipRdma(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRdma
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RdmaMemWindowRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRdma
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RdmaMemWindowRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RdmaMemWindowRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRdma
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &RdmaMemWindowSpec{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRdma(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRdma
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RdmaMemWindowResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRdma
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RdmaMemWindowResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RdmaMemWindowResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRdma(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRdma
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RdmaMemWindowResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRdma
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RdmaMemWindowResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RdmaMemWindowResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRdma
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &RdmaMemWindowResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRdma(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRdma
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RdmaAqSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRdma
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RdmaAqSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RdmaAqSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AqNum", wireType)
			}
			m.AqNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AqNum |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HwLifId", wireType)
			}
			m.HwLifId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HwLifId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogWqeSize", wireType)
			}
			m.LogWqeSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LogWqeSize |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogNumWqes", wireType)
			}
			m.LogNumWqes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LogNumWqes |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CqNum", wireType)
			}
			m.CqNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CqNum |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhyBaseAddr", wireType)
			}
			m.PhyBaseAddr = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PhyBaseAddr |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRdma(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRdma
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RdmaAqRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRdma
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RdmaAqRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RdmaAqRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRdma
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &RdmaAqSpec{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRdma(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRdma
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RdmaAqResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRdma
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RdmaAqResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RdmaAqResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRdma(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRdma
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RdmaAqResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRdma
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RdmaAqResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RdmaAqResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRdma
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &RdmaAqResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRdma(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRdma
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipRdma(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowRdma
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthRdma
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowRdma
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipRdma(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthRdma = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowRdma   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("rdma.proto", fileDescriptorRdma) }

var fileDescriptorRdma = []byte{
	// 2640 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x59, 0x4f, 0x73, 0xdb, 0xc6,
	0xf9, 0x36, 0x29, 0x92, 0xa2, 0x56, 0x22, 0xbd, 0x5a, 0x59, 0x12, 0x23, 0xdb, 0x8a, 0xcc, 0xfc,
	0x53, 0x94, 0x5f, 0x9c, 0x58, 0xc9, 0xfc, 0x7a, 0xeb, 0x14, 0x26, 0x61, 0x9b, 0x8d, 0xf8, 0x6f,
	0x49, 0x59, 0x51, 0x2e, 0x3b, 0x30, 0xb0, 0x12, 0x51, 0x13, 0x20, 0xb0, 0x00, 0x25, 0x33, 0xa7,
	0x9e, 0x3b, 0xbd, 0x74, 0x7a, 0xe9, 0xa9, 0x5f, 0xa1, 0xdf, 0xa0, 0x33, 0x9d, 0x5e, 0x7a, 0xe8,
	0xa1, 0x9d, 0x5e, 0x7a, 0xec, 0xa4, 0x5f, 0xa4, 0xb3, 0x7f, 0x40, 0x82, 0x24, 0x48, 0x33, 0xce,
	0x49, 0xe4, 0xfb, 0x3e, 0x7c, 0xb0, 0x78, 0xdf, 0x77, 0x1f, 0x3c, 0x0b, 0x01, 0xc0, 0x2c, 0xc7,
	0x78, 0xec, 0xb1, 0x41, 0x38, 0x40, 0x19, 0xfe, 0xf9, 0x60, 0x33, 0x1c, 0x79, 0x34, 0x90, 0xa1,
	0xf2, 0x9f, 0x72, 0x00, 0x60, 0xcb, 0x31, 0xda, 0x5e, 0xc7, 0xa3, 0x26, 0xda, 0x05, 0x39, 0xdf,
	0x23, 0xee, 0xd0, 0x29, 0xa5, 0x8e, 0x52, 0xc7, 0x05, 0x9c, 0xf5, 0xbd, 0xc6, 0xd0, 0x41, 0x07,
	0x60, 0xa3, 0x77, 0x4b, 0xfa, 0xf6, 0x15, 0xb1, 0xad, 0x52, 0x5a, 0x64, 0xd6, 0x7b, 0xb7, 0x67,
	0xf6, 0x55, 0xcd, 0x42, 0x87, 0x60, 0x33, 0xf0, 0xc9, 0xad, 0x4f, 0x49, 0x60, 0x7f, 0x4f, 0x4b,
	0x6b, 0x22, 0xbb, 0x11, 0xf8, 0x17, 0x3e, 0xed, 0xd8, 0xdf, 0x53, 0x9e, 0x67, 0xb1, 0x7c, 0x46,
	0xe6, 0x59, 0x3c, 0xef, 0x0e, 0x1d, 0x22, 0x39, 0x82, 0x52, 0x56, 0xe6, 0xdd, 0xa1, 0xd3, 0xe1,
	0x90, 0x20, 0xca, 0x33, 0x95, 0xcf, 0x8d, 0xf3, 0x58, 0xe6, 0x8f, 0xc0, 0x96, 0xc8, 0x47, 0x04,
	0xeb, 0x02, 0x00, 0x38, 0x20, 0x98, 0x46, 0x44, 0x14, 0xf9, 0x09, 0x82, 0x49, 0x44, 0x11, 0xa4,
	0x3d, 0xab, 0xb4, 0x21, 0xe2, 0x69, 0xcf, 0x42, 0x08, 0x64, 0x3c, 0x27, 0x1c, 0x96, 0x80, 0x88,
	0x88, 0xcf, 0xe8, 0x63, 0x70, 0xb7, 0x37, 0x08, 0x42, 0x87, 0x3a, 0xc4, 0xbb, 0x96, 0xf7, 0xb2,
	0x29, 0xd2, 0x05, 0x15, 0x6e, 0x5d, 0x8b, 0xfb, 0xf9, 0x04, 0xac, 0x05, 0x37, 0x66, 0x69, 0xeb,
	0x28, 0x75, 0x5c, 0x3c, 0xdd, 0x7d, 0x2c, 0xca, 0xcf, 0x2b, 0xdc, 0xa1, 0xec, 0xc6, 0x36, 0x69,
	0x77, 0xe4, 0x51, 0xcc, 0x11, 0xe8, 0x23, 0x50, 0x34, 0xc2, 0x81, 0x63, 0x9b, 0x84, 0xba, 0xc6,
	0xab, 0x3e, 0xb5, 0x4a, 0x85, 0xa3, 0xd4, 0x71, 0x1e, 0x17, 0x64, 0x54, 0x97, 0x41, 0xb4, 0x0f,
	0xd6, 0x03, 0x9f, 0xf4, 0x5f, 0xd3, 0x51, 0xa9, 0x28, 0xae, 0x97, 0x0b, 0xfc, 0xb3, 0xd7, 0x74,
	0xc4, 0x13, 0x4c, 0x25, 0xee, 0xca, 0x04, 0x93, 0x89, 0x03, 0xb0, 0xc1, 0x7c, 0x62, 0xfa, 0xa2,
	0x8f, 0x50, 0x76, 0x8b, 0xf9, 0x15, 0x5f, 0x75, 0x32, 0x18, 0xe7, 0xb6, 0x65, 0x2e, 0x50, 0xb9,
	0x0f, 0x41, 0xd1, 0x76, 0x1c, 0x2b, 0x24, 0x46, 0x40, 0xac, 0x57, 0xb4, 0xdf, 0x2f, 0x21, 0xb1,
	0xa0, 0x2d, 0x11, 0xd5, 0x82, 0x2a, 0x8f, 0xa1, 0x4f, 0x00, 0x0c, 0x7c, 0x62, 0xbb, 0xc4, 0xb5,
	0x4d, 0xe2, 0x50, 0x67, 0xc0, 0x46, 0xa5, 0x1d, 0xb9, 0xf0, 0xc0, 0xaf, 0xb9, 0x0d, 0xdb, 0xac,
	0x8b, 0x20, 0x2f, 0x7b, 0xe0, 0x93, 0x57, 0x46, 0x40, 0x89, 0x61, 0x59, 0xac, 0x74, 0xef, 0x28,
	0x75, 0x9c, 0xc1, 0x20, 0xf0, 0x9f, 0x1a, 0x01, 0xd5, 0x2c, 0x8b, 0x71, 0x2a, 0x36, 0x4b, 0xb5,
	0x2b, 0xa9, 0xd8, 0x2c, 0x15, 0x8b, 0x53, 0xed, 0x49, 0x2a, 0x36, 0xa1, 0xba, 0x0f, 0x36, 0xec,
	0x2b, 0xd2, 0x33, 0x5c, 0xab, 0x4f, 0x4b, 0xfb, 0x47, 0xa9, 0xe3, 0x1c, 0xce, 0xdb, 0x57, 0x2f,
	0xc4, 0x77, 0xf4, 0x29, 0xd8, 0xbe, 0x31, 0x88, 0x67, 0x5c, 0xd3, 0x80, 0x78, 0xbd, 0x91, 0xe4,
	0x28, 0x1d, 0xad, 0x1d, 0x67, 0x70, 0xf1, 0xc6, 0x68, 0xf1, 0x78, 0xab, 0x37, 0x12, 0x3c, 0x6a,
	0x56, 0x02, 0x5f, 0xc2, 0x4b, 0xef, 0x8d, 0x67, 0xa5, 0xe3, 0x0b, 0x60, 0xf9, 0xe7, 0x00, 0xca,
	0x0d, 0x83, 0xa9, 0x3f, 0xa4, 0x41, 0x58, 0x0f, 0xae, 0xd1, 0x09, 0x58, 0x67, 0xf2, 0x5b, 0x29,
	0x75, 0xb4, 0x76, 0xbc, 0x79, 0x0a, 0x27, 0x7d, 0x97, 0x3b, 0x0b, 0x47, 0x80, 0xf2, 0x6f, 0xd3,
	0xa0, 0x18, 0x11, 0x04, 0xde, 0xc0, 0x0d, 0x28, 0xfa, 0x02, 0x00, 0xc3, 0xb3, 0x49, 0x10, 0x1a,
	0xe1, 0x30, 0x10, 0x3b, 0xaf, 0x78, 0x0a, 0x1f, 0xcb, 0x6d, 0xaa, 0x79, 0x76, 0x47, 0xc4, 0xf1,
	0x86, 0x11, 0x7d, 0x44, 0x65, 0x50, 0x60, 0x53, 0xb5, 0x5d, 0x13, 0x05, 0xd9, 0x64, 0xb1, 0xe2,
	0x72, 0xcc, 0x54, 0xd1, 0x32, 0x0a, 0xc3, 0xa6, 0x1a, 0xc0, 0x4b, 0x3f, 0x45, 0x95, 0x15, 0xb0,
	0x82, 0x6b, 0x9b, 0x9d, 0x39, 0xe0, 0x14, 0x5f, 0x6e, 0x0c, 0xc4, 0x13, 0xe0, 0x17, 0xe0, 0x1e,
	0xbf, 0x73, 0xa2, 0x26, 0x9b, 0xd1, 0x40, 0x82, 0xd7, 0x05, 0x78, 0x9b, 0xe7, 0x34, 0x91, 0xc2,
	0x34, 0xe0, 0x3f, 0x28, 0xeb, 0x60, 0x7b, 0xba, 0x1a, 0xbc, 0x9e, 0x5f, 0x82, 0x3c, 0x53, 0x5f,
	0x55, 0x41, 0xef, 0xc5, 0x0b, 0x1a, 0x41, 0xf1, 0x18, 0x55, 0xfe, 0x7d, 0x36, 0x6a, 0xcb, 0xb9,
	0x67, 0x19, 0x21, 0x7d, 0x57, 0x35, 0x3b, 0x01, 0x99, 0x81, 0x47, 0x65, 0x41, 0x8b, 0xa7, 0x7b,
	0xf1, 0xab, 0x4a, 0xe2, 0xa6, 0x47, 0x19, 0x16, 0x18, 0xf4, 0x00, 0x00, 0x2b, 0x08, 0x89, 0xba,
	0x84, 0x14, 0xb6, 0xbc, 0x15, 0x84, 0x6d, 0x71, 0x95, 0x4f, 0xc0, 0xdd, 0x1e, 0x35, 0x2c, 0xca,
	0x48, 0x48, 0x1d, 0xaf, 0x6f, 0x84, 0x54, 0x94, 0x76, 0x0b, 0x17, 0x65, 0xb8, 0xab, 0xa2, 0x68,
	0x07, 0x64, 0x7d, 0xc2, 0x77, 0xb1, 0x94, 0xb6, 0x8c, 0xff, 0x0d, 0x1d, 0xf1, 0x20, 0x25, 0x5e,
	0xe0, 0x2a, 0x39, 0xcb, 0xd0, 0x56, 0xe0, 0xf2, 0xfb, 0x09, 0xdf, 0x88, 0xa8, 0x94, 0xb0, 0x6c,
	0xf8, 0x86, 0x87, 0x11, 0xc8, 0x18, 0x3d, 0x3b, 0xd2, 0x2f, 0xf1, 0x39, 0x51, 0xc1, 0xf6, 0x40,
	0xce, 0xe7, 0x33, 0x16, 0x09, 0x97, 0xfa, 0xc6, 0xf7, 0x8e, 0x39, 0x64, 0x44, 0xa6, 0xb6, 0xe4,
	0x6d, 0x98, 0x43, 0xd6, 0x11, 0xc9, 0xcf, 0xc1, 0x0e, 0x75, 0x49, 0xe0, 0x5b, 0xc4, 0x08, 0x46,
	0xae, 0x49, 0xdc, 0x41, 0x68, 0x5f, 0x8d, 0x84, 0x54, 0x15, 0x30, 0xa4, 0x6e, 0xc7, 0xb7, 0x34,
	0x9e, 0x68, 0x88, 0x38, 0x2a, 0x81, 0xf5, 0xd0, 0x76, 0xe8, 0x60, 0x18, 0x2a, 0xb5, 0x8a, 0xbe,
	0xf2, 0xab, 0x30, 0x1a, 0xb2, 0x11, 0x31, 0xdd, 0x50, 0x09, 0x56, 0x5e, 0x04, 0x2a, 0xae, 0x4c,
	0xba, 0x8c, 0x88, 0xef, 0x4a, 0xb2, 0xf2, 0xcc, 0x65, 0x98, 0x7f, 0xe7, 0xc3, 0xe7, 0x18, 0x6f,
	0x78, 0x9d, 0x99, 0xa5, 0x06, 0x4b, 0x49, 0x57, 0xc1, 0x31, 0xde, 0xb4, 0x3d, 0x6c, 0xc9, 0x91,
	0xe2, 0x23, 0xef, 0xd8, 0x2e, 0xe1, 0x4c, 0xfc, 0xaa, 0x4c, 0xe8, 0x57, 0x01, 0x6f, 0x3a, 0xb6,
	0x8b, 0x5d, 0xd6, 0xe5, 0x21, 0xf4, 0x19, 0x40, 0x9c, 0xcc, 0xa2, 0x41, 0x18, 0xa3, 0xdb, 0x11,
	0xc0, 0xbb, 0x8e, 0xf1, 0xa6, 0x4a, 0x83, 0x70, 0x4c, 0xf8, 0x08, 0x6c, 0x19, 0xa6, 0x49, 0x83,
	0x80, 0x5c, 0xf5, 0x8d, 0xeb, 0x40, 0x48, 0x58, 0x01, 0x6f, 0xca, 0xd8, 0x33, 0x1e, 0xe2, 0x2b,
	0x37, 0xc2, 0x90, 0x11, 0xc7, 0x08, 0x5e, 0x0b, 0xf1, 0x2a, 0xe0, 0x3c, 0x0f, 0xd4, 0x8d, 0xe0,
	0x75, 0xf9, 0x97, 0x60, 0x2f, 0x3e, 0x3b, 0x31, 0xc5, 0xf8, 0x72, 0x56, 0x31, 0x12, 0x46, 0x6d,
	0x5a, 0x37, 0x9e, 0x83, 0x7b, 0xd3, 0x5c, 0xef, 0x28, 0x1e, 0xe5, 0x36, 0xd8, 0x4f, 0x22, 0xe2,
	0xab, 0xfa, 0xff, 0xb9, 0x7d, 0x77, 0x30, 0xbf, 0xac, 0x84, 0xdd, 0x47, 0xa5, 0x89, 0xd0, 0x7a,
	0x62, 0xdb, 0x45, 0xf3, 0x98, 0x12, 0x7b, 0x5e, 0xce, 0xe3, 0xb2, 0x3d, 0x97, 0xb0, 0x53, 0xd6,
	0x92, 0x76, 0x4a, 0x24, 0xbd, 0x5a, 0x6f, 0x45, 0xe9, 0x95, 0xeb, 0x99, 0x94, 0x50, 0x93, 0xca,
	0xcb, 0x7f, 0xff, 0xae, 0xc5, 0x53, 0x72, 0x35, 0xa1, 0x78, 0xab, 0x5c, 0x4d, 0xa0, 0xb1, 0x82,
	0xfd, 0x7d, 0x4d, 0x56, 0xac, 0xe2, 0x47, 0x42, 0xa5, 0x1e, 0xc9, 0x4a, 0xa8, 0x4c, 0x7f, 0x05,
	0xdb, 0x65, 0xce, 0xdb, 0x2e, 0x73, 0xd6, 0x56, 0x99, 0xca, 0xf3, 0x64, 0xc6, 0xb6, 0xa9, 0x22,
	0x2d, 0x4f, 0x82, 0x9d, 0xc9, 0x26, 0xd9, 0x99, 0x7d, 0xb0, 0x6e, 0x2a, 0x97, 0x21, 0xf5, 0x29,
	0x67, 0x4a, 0x97, 0xc1, 0x15, 0xca, 0xe7, 0x0b, 0x8b, 0x14, 0xca, 0xaf, 0x59, 0x7c, 0xc3, 0xdc,
	0x1a, 0xaf, 0xe9, 0xd0, 0x23, 0x96, 0x67, 0x84, 0x3d, 0xa1, 0x53, 0x79, 0xbc, 0x29, 0x63, 0x55,
	0x1e, 0x42, 0x0f, 0x01, 0x50, 0x90, 0xbe, 0x7d, 0xa5, 0x34, 0x6b, 0x43, 0x46, 0xce, 0xec, 0xab,
	0x18, 0x83, 0xcf, 0xdb, 0xa0, 0x04, 0x4c, 0x31, 0xb4, 0x79, 0x28, 0xc6, 0xe0, 0xdb, 0x96, 0xd2,
	0x32, 0xc5, 0xd0, 0xb6, 0x2d, 0x6e, 0x63, 0x54, 0x9a, 0xd9, 0xee, 0x35, 0x5f, 0xa1, 0xd4, 0x34,
	0xc5, 0x8b, 0x6d, 0xf7, 0xba, 0x66, 0xf1, 0x7d, 0xcb, 0x6f, 0x54, 0x3e, 0x9d, 0xa4, 0xf1, 0xca,
	0xf3, 0x80, 0x78, 0x8a, 0x3d, 0x06, 0xf7, 0x4c, 0x9f, 0xcc, 0x7b, 0x86, 0xa2, 0xf0, 0x0c, 0xd0,
	0xf4, 0x5f, 0x4e, 0xb9, 0x86, 0x68, 0x30, 0x2b, 0xfe, 0x8a, 0x83, 0x29, 0xdb, 0x3e, 0x37, 0x98,
	0xfc, 0xf7, 0x3f, 0x71, 0x30, 0x27, 0x14, 0x6f, 0x1d, 0xcc, 0x09, 0x34, 0x36, 0x98, 0x7f, 0x49,
	0xc9, 0xc1, 0xd4, 0xe5, 0x60, 0x8e, 0x9b, 0x9c, 0x8a, 0x35, 0xf9, 0x2d, 0x63, 0x49, 0xe7, 0xc7,
	0x92, 0xce, 0x8e, 0x25, 0x9d, 0x1b, 0x4b, 0x5d, 0x8e, 0xe5, 0xa7, 0x60, 0x9b, 0xfa, 0x74, 0xe2,
	0x32, 0x78, 0xed, 0x95, 0x25, 0x29, 0x52, 0x9f, 0x46, 0x3e, 0xa3, 0xd5, 0x13, 0xfe, 0xd7, 0x76,
	0x43, 0xb1, 0x6b, 0xd4, 0x64, 0xda, 0x6e, 0xd8, 0x18, 0x3a, 0x51, 0x37, 0xf4, 0x55, 0xbb, 0xa1,
	0xcf, 0x74, 0xe3, 0x57, 0xb2, 0x1b, 0xfa, 0xbb, 0x77, 0x83, 0x3f, 0xb2, 0x78, 0xdd, 0xdc, 0x90,
	0x91, 0xf0, 0x55, 0x5f, 0x0e, 0x8f, 0xac, 0x54, 0x81, 0xfa, 0x35, 0x37, 0x64, 0xdd, 0x57, 0xfd,
	0xb8, 0xfd, 0xd1, 0x57, 0x6f, 0x9b, 0x9e, 0xd4, 0xb6, 0x7f, 0xae, 0xc9, 0x35, 0xd7, 0xa9, 0x83,
	0xe9, 0xb5, 0x68, 0xdd, 0x54, 0x97, 0xa4, 0x14, 0x8f, 0xbb, 0x24, 0xcf, 0x3b, 0xe9, 0xf1, 0x79,
	0xa7, 0x08, 0xd2, 0x37, 0x86, 0x32, 0x91, 0xe9, 0x1b, 0x03, 0x41, 0xb0, 0xd6, 0xa7, 0xae, 0xea,
	0x0e, 0xff, 0xc8, 0xfb, 0x66, 0x98, 0xa4, 0x3f, 0x30, 0x8d, 0x3e, 0xb9, 0x95, 0x26, 0x31, 0x8f,
	0x37, 0x0c, 0xf3, 0x8c, 0x47, 0x2e, 0x84, 0x6f, 0x36, 0xb8, 0xdd, 0x73, 0x06, 0x21, 0xe5, 0x80,
	0x9c, 0x00, 0x00, 0xc3, 0xc4, 0x22, 0x34, 0x8b, 0x60, 0x52, 0x36, 0x62, 0x08, 0x6c, 0xa1, 0x63,
	0x00, 0x27, 0x08, 0xf5, 0x60, 0x96, 0x02, 0x52, 0x8c, 0x50, 0xea, 0xb9, 0x8c, 0x40, 0x46, 0x28,
	0x92, 0x72, 0x3c, 0xfc, 0x33, 0x8f, 0x31, 0x1e, 0x53, 0x8e, 0x87, 0x7f, 0x5e, 0xf9, 0xcc, 0xf6,
	0x08, 0x6c, 0x0d, 0x6e, 0x28, 0x63, 0xb6, 0x45, 0x85, 0x2a, 0x49, 0xc1, 0xd8, 0x8c, 0x62, 0x5c,
	0x97, 0x8e, 0x01, 0x8c, 0x43, 0xc8, 0x4d, 0x3f, 0x3a, 0xaf, 0x15, 0x63, 0xb0, 0x97, 0xfd, 0x19,
	0x65, 0x29, 0xce, 0x28, 0x4b, 0xe2, 0x51, 0xe4, 0x6e, 0xd2, 0x51, 0xa4, 0xfc, 0x4c, 0x3e, 0xf0,
	0x65, 0x4b, 0x63, 0xa3, 0xfc, 0x78, 0x76, 0x94, 0x63, 0xc3, 0x31, 0xe9, 0xff, 0x64, 0x9c, 0x75,
	0x80, 0xe2, 0x3c, 0xef, 0x2a, 0x30, 0x75, 0xb0, 0x3b, 0x4f, 0xc3, 0xd7, 0xf3, 0xf5, 0xdc, 0xb4,
	0x96, 0x66, 0x17, 0x94, 0x30, 0xb1, 0xff, 0x4e, 0xa9, 0x27, 0x69, 0xbf, 0x3f, 0x30, 0xf9, 0x03,
	0xe5, 0x47, 0x0f, 0xed, 0x07, 0xa0, 0x10, 0xcd, 0x8a, 0xf0, 0x63, 0x62, 0x7e, 0xf3, 0x78, 0x4b,
	0x06, 0x35, 0x11, 0x1b, 0x4f, 0x4a, 0x26, 0x61, 0x52, 0xb2, 0xb1, 0x49, 0xf9, 0x1c, 0xec, 0x70,
	0x5d, 0xf2, 0x42, 0x42, 0xdd, 0x90, 0xd9, 0x34, 0x20, 0x2c, 0xb8, 0xb1, 0x94, 0xb0, 0x40, 0x77,
	0xe8, 0xb4, 0x42, 0x5d, 0x26, 0x70, 0x70, 0x33, 0xd3, 0xe3, 0xf5, 0xe9, 0x1e, 0x97, 0xcf, 0xa4,
	0xc1, 0x1a, 0xdf, 0x59, 0xac, 0x77, 0x4f, 0x66, 0x7b, 0xb7, 0x1f, 0x33, 0x0a, 0xf1, 0x4a, 0x4c,
	0xda, 0xf7, 0x42, 0xd6, 0x3d, 0xc6, 0xf6, 0xae, 0x1d, 0xec, 0x80, 0x52, 0x22, 0x13, 0x5f, 0xd8,
	0xcf, 0xe6, 0x9a, 0x78, 0x3f, 0x61, 0x65, 0x09, 0x7d, 0xfc, 0x6b, 0x5a, 0xf6, 0xb1, 0x4e, 0x9d,
	0x0b, 0xdb, 0xb5, 0x06, 0xb7, 0x3f, 0xba, 0x8f, 0x5f, 0x81, 0x75, 0xe7, 0x96, 0x88, 0x87, 0xbd,
	0x3c, 0x75, 0x1d, 0x4c, 0x8d, 0xcf, 0x80, 0x8d, 0x24, 0xb1, 0x78, 0x73, 0x92, 0x73, 0xc4, 0xdf,
	0x39, 0xbd, 0xc9, 0xbc, 0x55, 0x6f, 0xb2, 0x2b, 0xe9, 0x4d, 0x6e, 0x91, 0xde, 0x88, 0x89, 0x59,
	0x8f, 0x4d, 0xcc, 0xac, 0x66, 0xe4, 0x57, 0xd3, 0x8c, 0x8d, 0x24, 0xcd, 0x88, 0x46, 0x66, 0x5c,
	0xc4, 0x15, 0x47, 0x66, 0xaa, 0xe8, 0x73, 0x23, 0x13, 0x63, 0xfb, 0x89, 0x23, 0x33, 0xc7, 0xf4,
	0xd6, 0x91, 0x99, 0xfb, 0x45, 0x6c, 0x64, 0xfe, 0xac, 0x3c, 0x86, 0x36, 0x36, 0xbf, 0xc6, 0x94,
	0xf9, 0x35, 0xde, 0x6a, 0x7e, 0x8f, 0xc0, 0x56, 0x7f, 0x70, 0x3d, 0x6b, 0x33, 0x40, 0x7f, 0x70,
	0x1d, 0xf9, 0x0c, 0x85, 0xe0, 0x7b, 0x3a, 0x66, 0x34, 0x38, 0xa2, 0x31, 0x74, 0x84, 0xd3, 0x98,
	0x78, 0xee, 0x6c, 0xdc, 0x73, 0x97, 0x41, 0x81, 0xeb, 0xf2, 0xec, 0x6b, 0x8e, 0x4d, 0xaf, 0x37,
	0x8a, 0xcc, 0xc7, 0xf8, 0x1c, 0xb2, 0xaa, 0xc1, 0xd0, 0x92, 0xed, 0x9e, 0xf6, 0xd3, 0xed, 0x9e,
	0xb6, 0xba, 0x6f, 0xd0, 0x12, 0x7c, 0xc3, 0xc9, 0xbf, 0x52, 0xe0, 0xee, 0xcc, 0xcb, 0x49, 0xb4,
	0x0b, 0xb6, 0x71, 0xb5, 0xae, 0x91, 0x8e, 0x8e, 0x5f, 0x92, 0xee, 0x65, 0x4b, 0x27, 0xb8, 0x02,
	0xef, 0x24, 0x84, 0xcf, 0x2b, 0x30, 0x95, 0x84, 0xae, 0xc2, 0x74, 0x12, 0xba, 0x0a, 0xd7, 0xd0,
	0x1e, 0x40, 0x33, 0xe1, 0x4a, 0xa3, 0x05, 0x33, 0x09, 0xf1, 0x6f, 0x71, 0x05, 0x66, 0xd1, 0x7b,
	0x60, 0x77, 0x26, 0xfe, 0x52, 0x6f, 0x54, 0xc9, 0x13, 0x98, 0x5b, 0x94, 0x3a, 0x85, 0xeb, 0x27,
	0xbf, 0xc9, 0x4f, 0xbf, 0x0c, 0x6a, 0x7a, 0x94, 0xa1, 0x47, 0xe0, 0xa1, 0xc0, 0x9f, 0xb7, 0xaa,
	0x5a, 0x57, 0x27, 0xed, 0x16, 0x69, 0xb6, 0x74, 0x4c, 0x3a, 0x7a, 0x97, 0x74, 0xba, 0x5a, 0x57,
	0x87, 0x77, 0xd0, 0x47, 0xe0, 0xd1, 0x22, 0x48, 0xe5, 0x1c, 0x2b, 0x58, 0x0a, 0x7d, 0x01, 0x3e,
	0x5b, 0x04, 0xd3, 0x1b, 0xa4, 0xd3, 0xae, 0x12, 0xad, 0x73, 0xd9, 0xa8, 0x90, 0x46, 0xb3, 0x5b,
	0x7b, 0x76, 0x09, 0xd3, 0xe8, 0x18, 0x7c, 0xb8, 0xe8, 0x07, 0x5a, 0xa5, 0xa2, 0x77, 0x3a, 0xe4,
	0xd9, 0x99, 0xf6, 0xbc, 0x03, 0xd7, 0xd0, 0xc7, 0xa0, 0xbc, 0x08, 0xd9, 0xfa, 0x46, 0xbf, 0x24,
	0xb5, 0x46, 0x55, 0xff, 0x16, 0x66, 0xd0, 0x11, 0x78, 0xb0, 0x10, 0xd7, 0xc4, 0x5d, 0x98, 0x5d,
	0x86, 0x68, 0x7f, 0xa3, 0x5f, 0xc2, 0x1c, 0x3a, 0x04, 0x07, 0x0b, 0x57, 0xf5, 0x12, 0xae, 0xa3,
	0x0f, 0xc1, 0xd1, 0xc2, 0x6b, 0x68, 0xdd, 0x17, 0xa4, 0xde, 0x3d, 0x87, 0x79, 0xf4, 0x01, 0x78,
	0x7f, 0x11, 0xaa, 0x5b, 0xab, 0xeb, 0xcd, 0xf3, 0x2e, 0xdc, 0x58, 0x56, 0x58, 0xac, 0x77, 0xf1,
	0x25, 0xa9, 0x34, 0xba, 0x10, 0x2c, 0x85, 0x35, 0xb0, 0x84, 0xc2, 0x4d, 0x54, 0x06, 0x87, 0x0b,
	0x61, 0x6d, 0xd2, 0xea, 0x34, 0xe0, 0x16, 0xfa, 0x3f, 0x70, 0xbc, 0x08, 0x53, 0xd7, 0xbe, 0xe5,
	0xdf, 0x71, 0x95, 0x68, 0xdd, 0x66, 0xbd, 0x56, 0x81, 0x85, 0x65, 0xb7, 0xaa, 0x9d, 0xc9, 0xdb,
	0x85, 0x45, 0xf4, 0x29, 0xf8, 0x68, 0x21, 0x67, 0xad, 0x21, 0x96, 0xc8, 0x6f, 0x19, 0xc3, 0xbb,
	0xcb, 0x96, 0xd8, 0x91, 0x4b, 0x84, 0xe8, 0x31, 0x38, 0x59, 0xb6, 0xc4, 0xaa, 0xde, 0xe9, 0xc6,
	0x16, 0xb9, 0x8d, 0x4e, 0xc0, 0xc7, 0xcb, 0xfb, 0x51, 0x7b, 0xae, 0x46, 0x14, 0xa1, 0xf7, 0xc1,
	0xfd, 0x85, 0x93, 0xac, 0xb5, 0xe0, 0xce, 0xb2, 0x3b, 0x16, 0x17, 0x6e, 0xb7, 0x1a, 0xf0, 0xde,
	0xf2, 0xbe, 0xf1, 0x8d, 0xa7, 0x57, 0x9f, 0xc0, 0xdd, 0x55, 0x60, 0xa7, 0x70, 0x6f, 0x15, 0xd8,
	0x57, 0x70, 0x7f, 0x15, 0xd8, 0xd7, 0xb0, 0xb4, 0x6c, 0xab, 0x60, 0x1e, 0x38, 0xab, 0xd5, 0x6b,
	0x5d, 0xf8, 0xde, 0xc9, 0x1f, 0xd3, 0xd1, 0x1b, 0x66, 0x2d, 0xf6, 0xda, 0x6e, 0x1f, 0xec, 0x88,
	0x5f, 0xb7, 0x5b, 0xd1, 0x16, 0x6c, 0x34, 0x1b, 0x5c, 0x03, 0xa2, 0x5d, 0x31, 0x49, 0x9c, 0x35,
	0x2b, 0xda, 0x19, 0xb9, 0xc0, 0x35, 0xb1, 0xf9, 0xa3, 0xca, 0x4e, 0xf2, 0x58, 0xaf, 0x37, 0xbb,
	0xba, 0x02, 0xa4, 0x13, 0x08, 0x14, 0x00, 0xeb, 0x5a, 0x35, 0xb6, 0x75, 0xe7, 0xf2, 0xaa, 0xd1,
	0x79, 0x74, 0x00, 0xf6, 0x66, 0x10, 0xf5, 0x0b, 0xf2, 0xb4, 0xd6, 0xa8, 0x42, 0x38, 0x16, 0xca,
	0x76, 0x8b, 0x7c, 0xa7, 0xe3, 0x26, 0x79, 0xaa, 0x75, 0xf4, 0x2a, 0x3c, 0x42, 0x0f, 0x40, 0x69,
	0xe6, 0x37, 0xcd, 0x06, 0xa9, 0xea, 0x75, 0xad, 0x51, 0x85, 0xbf, 0x40, 0xf7, 0xe7, 0x18, 0x5f,
	0x9c, 0x3f, 0xd7, 0xbb, 0x67, 0x4f, 0xe1, 0xaf, 0x53, 0x27, 0xe1, 0xf8, 0x9c, 0x31, 0x65, 0xb5,
	0xc6, 0x0b, 0xad, 0xeb, 0xf5, 0x26, 0xbe, 0x24, 0x17, 0xb5, 0x46, 0xb5, 0x79, 0x21, 0x95, 0x56,
	0xd5, 0x2a, 0xba, 0xe8, 0x3c, 0xe2, 0x09, 0x4c, 0x2d, 0xc9, 0x9e, 0xc2, 0xf4, 0xe9, 0xef, 0xb2,
	0x20, 0xc3, 0x2f, 0x8b, 0x34, 0xb0, 0x25, 0xdb, 0x53, 0x61, 0xd4, 0x08, 0x29, 0xda, 0x9b, 0x7e,
	0xd3, 0x1f, 0x3d, 0x60, 0x0f, 0xf6, 0x93, 0xfe, 0x03, 0x50, 0x0f, 0xae, 0xcb, 0x77, 0x50, 0x3d,
	0xa2, 0x90, 0x72, 0x8f, 0x1e, 0x24, 0xbd, 0xb4, 0x1c, 0x13, 0x3d, 0x5c, 0xfc, 0x4a, 0x53, 0xd2,
	0xa9, 0x15, 0x69, 0xbd, 0xf9, 0x15, 0xc5, 0x5f, 0x3d, 0xc6, 0x57, 0x34, 0xf5, 0x3e, 0x70, 0x42,
	0x51, 0xf1, 0xe7, 0x29, 0xe2, 0x2f, 0x89, 0xe2, 0x14, 0x53, 0x6f, 0x6e, 0x26, 0x14, 0x7a, 0x02,
	0x85, 0xbe, 0x80, 0x42, 0x9f, 0xa1, 0x78, 0x2e, 0x7d, 0x96, 0x3c, 0x83, 0xa1, 0x83, 0xf9, 0x53,
	0xd9, 0x98, 0xe4, 0xfe, 0xa2, 0x13, 0x9b, 0x24, 0x6a, 0x81, 0xc2, 0xd4, 0x39, 0x00, 0x3d, 0x4c,
	0x3c, 0x1c, 0x8c, 0xe9, 0x0e, 0x97, 0x9c, 0x1d, 0xa6, 0x18, 0xc7, 0x36, 0x31, 0xce, 0x98, 0xe0,
	0x82, 0xe3, 0x8c, 0x49, 0x66, 0x34, 0xd6, 0xb5, 0x84, 0x7a, 0x69, 0x0b, 0xea, 0xa5, 0x4d, 0xd7,
	0xeb, 0xe9, 0xc1, 0xdf, 0x7e, 0x38, 0x4c, 0xfd, 0xe3, 0x87, 0xc3, 0xd4, 0x7f, 0x7e, 0x38, 0x4c,
	0xfd, 0xe1, 0xbf, 0x87, 0x77, 0xbe, 0xcb, 0xf7, 0x8c, 0xbe, 0xf8, 0x47, 0xf9, 0xab, 0x9c, 0xf8,
	0xf3, 0xd5, 0xff, 0x02, 0x00, 0x00, 0xff, 0xff, 0xdb, 0x32, 0x94, 0x92, 0x50, 0x1f, 0x00, 0x00,
}
