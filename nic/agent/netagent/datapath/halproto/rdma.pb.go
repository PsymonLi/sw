// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: rdma.proto

package halproto

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// types of interfaces
type RdmaServiceType int32

const (
	RdmaServiceType_RDMA_SERV_TYPE_RC     RdmaServiceType = 0
	RdmaServiceType_RDMA_SERV_TYPE_UC     RdmaServiceType = 1
	RdmaServiceType_RDMA_SERV_TYPE_RD     RdmaServiceType = 2
	RdmaServiceType_RDMA_SERV_TYPE_UD     RdmaServiceType = 3
	RdmaServiceType_RDMA_SERV_TYPE_CNP    RdmaServiceType = 4
	RdmaServiceType_RDMA_SERV_TYPE_XRC    RdmaServiceType = 5
	RdmaServiceType_RDMA_SERV_TYPE_VEND_1 RdmaServiceType = 6
	RdmaServiceType_RDMA_SERV_TYPE_VEND_2 RdmaServiceType = 7
)

var RdmaServiceType_name = map[int32]string{
	0: "RDMA_SERV_TYPE_RC",
	1: "RDMA_SERV_TYPE_UC",
	2: "RDMA_SERV_TYPE_RD",
	3: "RDMA_SERV_TYPE_UD",
	4: "RDMA_SERV_TYPE_CNP",
	5: "RDMA_SERV_TYPE_XRC",
	6: "RDMA_SERV_TYPE_VEND_1",
	7: "RDMA_SERV_TYPE_VEND_2",
}
var RdmaServiceType_value = map[string]int32{
	"RDMA_SERV_TYPE_RC":     0,
	"RDMA_SERV_TYPE_UC":     1,
	"RDMA_SERV_TYPE_RD":     2,
	"RDMA_SERV_TYPE_UD":     3,
	"RDMA_SERV_TYPE_CNP":    4,
	"RDMA_SERV_TYPE_XRC":    5,
	"RDMA_SERV_TYPE_VEND_1": 6,
	"RDMA_SERV_TYPE_VEND_2": 7,
}

func (x RdmaServiceType) String() string {
	return proto.EnumName(RdmaServiceType_name, int32(x))
}
func (RdmaServiceType) EnumDescriptor() ([]byte, []int) { return fileDescriptorRdma, []int{0} }

// types of Update QP operations
type RdmaQpUpdateOper int32

const (
	RdmaQpUpdateOper_RDMA_UPDATE_QP_OPER_SET_DEST_QP         RdmaQpUpdateOper = 0
	RdmaQpUpdateOper_RDMA_UPDATE_QP_OPER_SET_HEADER_TEMPLATE RdmaQpUpdateOper = 1
	RdmaQpUpdateOper_RDMA_UPDATE_QP_OPER_SET_Q_KEY           RdmaQpUpdateOper = 2
)

var RdmaQpUpdateOper_name = map[int32]string{
	0: "RDMA_UPDATE_QP_OPER_SET_DEST_QP",
	1: "RDMA_UPDATE_QP_OPER_SET_HEADER_TEMPLATE",
	2: "RDMA_UPDATE_QP_OPER_SET_Q_KEY",
}
var RdmaQpUpdateOper_value = map[string]int32{
	"RDMA_UPDATE_QP_OPER_SET_DEST_QP":         0,
	"RDMA_UPDATE_QP_OPER_SET_HEADER_TEMPLATE": 1,
	"RDMA_UPDATE_QP_OPER_SET_Q_KEY":           2,
}

func (x RdmaQpUpdateOper) String() string {
	return proto.EnumName(RdmaQpUpdateOper_name, int32(x))
}
func (RdmaQpUpdateOper) EnumDescriptor() ([]byte, []int) { return fileDescriptorRdma, []int{1} }

// **********************    Queue Pair  ********************************//
// RdmaQp object
type RdmaQpSpec struct {
	Meta          *ObjectMeta     `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	QpNum         uint32          `protobuf:"varint,2,opt,name=qp_num,json=qpNum,proto3" json:"qp_num,omitempty"`
	HwLifId       uint32          `protobuf:"varint,3,opt,name=hw_lif_id,json=hwLifId,proto3" json:"hw_lif_id,omitempty"`
	SqWqeSize     uint32          `protobuf:"varint,4,opt,name=sq_wqe_size,json=sqWqeSize,proto3" json:"sq_wqe_size,omitempty"`
	RqWqeSize     uint32          `protobuf:"varint,5,opt,name=rq_wqe_size,json=rqWqeSize,proto3" json:"rq_wqe_size,omitempty"`
	NumSqWqes     uint32          `protobuf:"varint,6,opt,name=num_sq_wqes,json=numSqWqes,proto3" json:"num_sq_wqes,omitempty"`
	NumRqWqes     uint32          `protobuf:"varint,7,opt,name=num_rq_wqes,json=numRqWqes,proto3" json:"num_rq_wqes,omitempty"`
	NumRsqWqes    uint32          `protobuf:"varint,8,opt,name=num_rsq_wqes,json=numRsqWqes,proto3" json:"num_rsq_wqes,omitempty"`
	NumRrqWqes    uint32          `protobuf:"varint,9,opt,name=num_rrq_wqes,json=numRrqWqes,proto3" json:"num_rrq_wqes,omitempty"`
	Pd            uint32          `protobuf:"varint,10,opt,name=pd,proto3" json:"pd,omitempty"`
	Pmtu          uint32          `protobuf:"varint,11,opt,name=pmtu,proto3" json:"pmtu,omitempty"`
	HostmemPgSize uint32          `protobuf:"varint,12,opt,name=hostmem_pg_size,json=hostmemPgSize,proto3" json:"hostmem_pg_size,omitempty"`
	Svc           RdmaServiceType `protobuf:"varint,13,opt,name=svc,proto3,enum=rdma.RdmaServiceType" json:"svc,omitempty"`
	AtomicEnabled bool            `protobuf:"varint,14,opt,name=atomic_enabled,json=atomicEnabled,proto3" json:"atomic_enabled,omitempty"`
	SqLkey        uint32          `protobuf:"varint,15,opt,name=sq_lkey,json=sqLkey,proto3" json:"sq_lkey,omitempty"`
	RqLkey        uint32          `protobuf:"varint,16,opt,name=rq_lkey,json=rqLkey,proto3" json:"rq_lkey,omitempty"`
	RqCqNum       uint32          `protobuf:"varint,17,opt,name=rq_cq_num,json=rqCqNum,proto3" json:"rq_cq_num,omitempty"`
	SqCqNum       uint32          `protobuf:"varint,18,opt,name=sq_cq_num,json=sqCqNum,proto3" json:"sq_cq_num,omitempty"`
	ImmdtAsDbell  bool            `protobuf:"varint,19,opt,name=immdt_as_dbell,json=immdtAsDbell,proto3" json:"immdt_as_dbell,omitempty"`
	IfHandle      uint64          `protobuf:"fixed64,20,opt,name=if_handle,json=ifHandle,proto3" json:"if_handle,omitempty"`
}

func (m *RdmaQpSpec) Reset()                    { *m = RdmaQpSpec{} }
func (m *RdmaQpSpec) String() string            { return proto.CompactTextString(m) }
func (*RdmaQpSpec) ProtoMessage()               {}
func (*RdmaQpSpec) Descriptor() ([]byte, []int) { return fileDescriptorRdma, []int{0} }

func (m *RdmaQpSpec) GetMeta() *ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *RdmaQpSpec) GetQpNum() uint32 {
	if m != nil {
		return m.QpNum
	}
	return 0
}

func (m *RdmaQpSpec) GetHwLifId() uint32 {
	if m != nil {
		return m.HwLifId
	}
	return 0
}

func (m *RdmaQpSpec) GetSqWqeSize() uint32 {
	if m != nil {
		return m.SqWqeSize
	}
	return 0
}

func (m *RdmaQpSpec) GetRqWqeSize() uint32 {
	if m != nil {
		return m.RqWqeSize
	}
	return 0
}

func (m *RdmaQpSpec) GetNumSqWqes() uint32 {
	if m != nil {
		return m.NumSqWqes
	}
	return 0
}

func (m *RdmaQpSpec) GetNumRqWqes() uint32 {
	if m != nil {
		return m.NumRqWqes
	}
	return 0
}

func (m *RdmaQpSpec) GetNumRsqWqes() uint32 {
	if m != nil {
		return m.NumRsqWqes
	}
	return 0
}

func (m *RdmaQpSpec) GetNumRrqWqes() uint32 {
	if m != nil {
		return m.NumRrqWqes
	}
	return 0
}

func (m *RdmaQpSpec) GetPd() uint32 {
	if m != nil {
		return m.Pd
	}
	return 0
}

func (m *RdmaQpSpec) GetPmtu() uint32 {
	if m != nil {
		return m.Pmtu
	}
	return 0
}

func (m *RdmaQpSpec) GetHostmemPgSize() uint32 {
	if m != nil {
		return m.HostmemPgSize
	}
	return 0
}

func (m *RdmaQpSpec) GetSvc() RdmaServiceType {
	if m != nil {
		return m.Svc
	}
	return RdmaServiceType_RDMA_SERV_TYPE_RC
}

func (m *RdmaQpSpec) GetAtomicEnabled() bool {
	if m != nil {
		return m.AtomicEnabled
	}
	return false
}

func (m *RdmaQpSpec) GetSqLkey() uint32 {
	if m != nil {
		return m.SqLkey
	}
	return 0
}

func (m *RdmaQpSpec) GetRqLkey() uint32 {
	if m != nil {
		return m.RqLkey
	}
	return 0
}

func (m *RdmaQpSpec) GetRqCqNum() uint32 {
	if m != nil {
		return m.RqCqNum
	}
	return 0
}

func (m *RdmaQpSpec) GetSqCqNum() uint32 {
	if m != nil {
		return m.SqCqNum
	}
	return 0
}

func (m *RdmaQpSpec) GetImmdtAsDbell() bool {
	if m != nil {
		return m.ImmdtAsDbell
	}
	return false
}

func (m *RdmaQpSpec) GetIfHandle() uint64 {
	if m != nil {
		return m.IfHandle
	}
	return 0
}

// RdmaQpRequestMsg is batched request used to create/update of Rdma QPs
type RdmaQpRequestMsg struct {
	Request []*RdmaQpSpec `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *RdmaQpRequestMsg) Reset()                    { *m = RdmaQpRequestMsg{} }
func (m *RdmaQpRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*RdmaQpRequestMsg) ProtoMessage()               {}
func (*RdmaQpRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptorRdma, []int{1} }

func (m *RdmaQpRequestMsg) GetRequest() []*RdmaQpSpec {
	if m != nil {
		return m.Request
	}
	return nil
}

// RdmaQpResponse response to one RdmaQpSpec
type RdmaQpResponse struct {
	ApiStatus ApiStatus `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty"`
	// RdmaQpStatus        status           = 2;    // operational status
	RsqBaseAddr    uint32 `protobuf:"varint,3,opt,name=rsq_base_addr,json=rsqBaseAddr,proto3" json:"rsq_base_addr,omitempty"`
	RrqBaseAddr    uint32 `protobuf:"varint,4,opt,name=rrq_base_addr,json=rrqBaseAddr,proto3" json:"rrq_base_addr,omitempty"`
	HeaderTempAddr uint32 `protobuf:"varint,5,opt,name=header_temp_addr,json=headerTempAddr,proto3" json:"header_temp_addr,omitempty"`
}

func (m *RdmaQpResponse) Reset()                    { *m = RdmaQpResponse{} }
func (m *RdmaQpResponse) String() string            { return proto.CompactTextString(m) }
func (*RdmaQpResponse) ProtoMessage()               {}
func (*RdmaQpResponse) Descriptor() ([]byte, []int) { return fileDescriptorRdma, []int{2} }

func (m *RdmaQpResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *RdmaQpResponse) GetRsqBaseAddr() uint32 {
	if m != nil {
		return m.RsqBaseAddr
	}
	return 0
}

func (m *RdmaQpResponse) GetRrqBaseAddr() uint32 {
	if m != nil {
		return m.RrqBaseAddr
	}
	return 0
}

func (m *RdmaQpResponse) GetHeaderTempAddr() uint32 {
	if m != nil {
		return m.HeaderTempAddr
	}
	return 0
}

// RdmaQpResponseMsg is response to RdmaQpRequestMsg
type RdmaQpResponseMsg struct {
	Response []*RdmaQpResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *RdmaQpResponseMsg) Reset()                    { *m = RdmaQpResponseMsg{} }
func (m *RdmaQpResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*RdmaQpResponseMsg) ProtoMessage()               {}
func (*RdmaQpResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptorRdma, []int{3} }

func (m *RdmaQpResponseMsg) GetResponse() []*RdmaQpResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

// ****************   Update Queue Pair  ********************************//
// RdmaQpUpdate object
type RdmaQpUpdateSpec struct {
	Meta           *ObjectMeta      `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	QpNum          uint32           `protobuf:"varint,2,opt,name=qp_num,json=qpNum,proto3" json:"qp_num,omitempty"`
	HwLifId        uint32           `protobuf:"varint,3,opt,name=hw_lif_id,json=hwLifId,proto3" json:"hw_lif_id,omitempty"`
	Oper           RdmaQpUpdateOper `protobuf:"varint,4,opt,name=oper,proto3,enum=rdma.RdmaQpUpdateOper" json:"oper,omitempty"`
	DstQpNum       uint32           `protobuf:"varint,5,opt,name=dst_qp_num,json=dstQpNum,proto3" json:"dst_qp_num,omitempty"`
	HeaderTemplate []byte           `protobuf:"bytes,6,opt,name=header_template,json=headerTemplate,proto3" json:"header_template,omitempty"`
	QKey           uint32           `protobuf:"varint,7,opt,name=q_key,json=qKey,proto3" json:"q_key,omitempty"`
}

func (m *RdmaQpUpdateSpec) Reset()                    { *m = RdmaQpUpdateSpec{} }
func (m *RdmaQpUpdateSpec) String() string            { return proto.CompactTextString(m) }
func (*RdmaQpUpdateSpec) ProtoMessage()               {}
func (*RdmaQpUpdateSpec) Descriptor() ([]byte, []int) { return fileDescriptorRdma, []int{4} }

func (m *RdmaQpUpdateSpec) GetMeta() *ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *RdmaQpUpdateSpec) GetQpNum() uint32 {
	if m != nil {
		return m.QpNum
	}
	return 0
}

func (m *RdmaQpUpdateSpec) GetHwLifId() uint32 {
	if m != nil {
		return m.HwLifId
	}
	return 0
}

func (m *RdmaQpUpdateSpec) GetOper() RdmaQpUpdateOper {
	if m != nil {
		return m.Oper
	}
	return RdmaQpUpdateOper_RDMA_UPDATE_QP_OPER_SET_DEST_QP
}

func (m *RdmaQpUpdateSpec) GetDstQpNum() uint32 {
	if m != nil {
		return m.DstQpNum
	}
	return 0
}

func (m *RdmaQpUpdateSpec) GetHeaderTemplate() []byte {
	if m != nil {
		return m.HeaderTemplate
	}
	return nil
}

func (m *RdmaQpUpdateSpec) GetQKey() uint32 {
	if m != nil {
		return m.QKey
	}
	return 0
}

// RdmaQpRequestMsg is batched request used to create/update of Rdma QPs
type RdmaQpUpdateRequestMsg struct {
	Request []*RdmaQpUpdateSpec `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *RdmaQpUpdateRequestMsg) Reset()                    { *m = RdmaQpUpdateRequestMsg{} }
func (m *RdmaQpUpdateRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*RdmaQpUpdateRequestMsg) ProtoMessage()               {}
func (*RdmaQpUpdateRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptorRdma, []int{5} }

func (m *RdmaQpUpdateRequestMsg) GetRequest() []*RdmaQpUpdateSpec {
	if m != nil {
		return m.Request
	}
	return nil
}

// RdmaQpResponse response to one RdmaQpSpec
type RdmaQpUpdateResponse struct {
	ApiStatus ApiStatus `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty"`
}

func (m *RdmaQpUpdateResponse) Reset()                    { *m = RdmaQpUpdateResponse{} }
func (m *RdmaQpUpdateResponse) String() string            { return proto.CompactTextString(m) }
func (*RdmaQpUpdateResponse) ProtoMessage()               {}
func (*RdmaQpUpdateResponse) Descriptor() ([]byte, []int) { return fileDescriptorRdma, []int{6} }

func (m *RdmaQpUpdateResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

// RdmaQpUpdateResponseMsg is response to RdmaQpUpdateRequestMsg
type RdmaQpUpdateResponseMsg struct {
	Response []*RdmaQpUpdateResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *RdmaQpUpdateResponseMsg) Reset()                    { *m = RdmaQpUpdateResponseMsg{} }
func (m *RdmaQpUpdateResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*RdmaQpUpdateResponseMsg) ProtoMessage()               {}
func (*RdmaQpUpdateResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptorRdma, []int{7} }

func (m *RdmaQpUpdateResponseMsg) GetResponse() []*RdmaQpUpdateResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

// **********************    Address Handle  ********************************//
// RdmaAh object
type RdmaAhSpec struct {
	Meta     *ObjectMeta `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	Smac     []byte      `protobuf:"bytes,2,opt,name=smac,proto3" json:"smac,omitempty"`
	Dmac     []byte      `protobuf:"bytes,3,opt,name=dmac,proto3" json:"dmac,omitempty"`
	Ethtype  uint32      `protobuf:"varint,4,opt,name=ethtype,proto3" json:"ethtype,omitempty"`
	Vlan     uint32      `protobuf:"varint,5,opt,name=vlan,proto3" json:"vlan,omitempty"`
	VlanPri  uint32      `protobuf:"varint,6,opt,name=vlan_pri,json=vlanPri,proto3" json:"vlan_pri,omitempty"`
	VlanCfi  uint32      `protobuf:"varint,7,opt,name=vlan_cfi,json=vlanCfi,proto3" json:"vlan_cfi,omitempty"`
	IpVer    uint32      `protobuf:"varint,8,opt,name=ip_ver,json=ipVer,proto3" json:"ip_ver,omitempty"`
	IpTos    uint32      `protobuf:"varint,9,opt,name=ip_tos,json=ipTos,proto3" json:"ip_tos,omitempty"`
	IpTtl    uint32      `protobuf:"varint,10,opt,name=ip_ttl,json=ipTtl,proto3" json:"ip_ttl,omitempty"`
	IpSaddr  *IPAddress  `protobuf:"bytes,11,opt,name=ip_saddr,json=ipSaddr" json:"ip_saddr,omitempty"`
	IpDaddr  *IPAddress  `protobuf:"bytes,12,opt,name=ip_daddr,json=ipDaddr" json:"ip_daddr,omitempty"`
	UdpSport uint32      `protobuf:"varint,13,opt,name=udp_sport,json=udpSport,proto3" json:"udp_sport,omitempty"`
	UdpDport uint32      `protobuf:"varint,14,opt,name=udp_dport,json=udpDport,proto3" json:"udp_dport,omitempty"`
}

func (m *RdmaAhSpec) Reset()                    { *m = RdmaAhSpec{} }
func (m *RdmaAhSpec) String() string            { return proto.CompactTextString(m) }
func (*RdmaAhSpec) ProtoMessage()               {}
func (*RdmaAhSpec) Descriptor() ([]byte, []int) { return fileDescriptorRdma, []int{8} }

func (m *RdmaAhSpec) GetMeta() *ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *RdmaAhSpec) GetSmac() []byte {
	if m != nil {
		return m.Smac
	}
	return nil
}

func (m *RdmaAhSpec) GetDmac() []byte {
	if m != nil {
		return m.Dmac
	}
	return nil
}

func (m *RdmaAhSpec) GetEthtype() uint32 {
	if m != nil {
		return m.Ethtype
	}
	return 0
}

func (m *RdmaAhSpec) GetVlan() uint32 {
	if m != nil {
		return m.Vlan
	}
	return 0
}

func (m *RdmaAhSpec) GetVlanPri() uint32 {
	if m != nil {
		return m.VlanPri
	}
	return 0
}

func (m *RdmaAhSpec) GetVlanCfi() uint32 {
	if m != nil {
		return m.VlanCfi
	}
	return 0
}

func (m *RdmaAhSpec) GetIpVer() uint32 {
	if m != nil {
		return m.IpVer
	}
	return 0
}

func (m *RdmaAhSpec) GetIpTos() uint32 {
	if m != nil {
		return m.IpTos
	}
	return 0
}

func (m *RdmaAhSpec) GetIpTtl() uint32 {
	if m != nil {
		return m.IpTtl
	}
	return 0
}

func (m *RdmaAhSpec) GetIpSaddr() *IPAddress {
	if m != nil {
		return m.IpSaddr
	}
	return nil
}

func (m *RdmaAhSpec) GetIpDaddr() *IPAddress {
	if m != nil {
		return m.IpDaddr
	}
	return nil
}

func (m *RdmaAhSpec) GetUdpSport() uint32 {
	if m != nil {
		return m.UdpSport
	}
	return 0
}

func (m *RdmaAhSpec) GetUdpDport() uint32 {
	if m != nil {
		return m.UdpDport
	}
	return 0
}

// RdmaAhRequestmsg is batched request used to create/update of Rdma QPs
type RdmaAhRequestMsg struct {
	Request []*RdmaAhSpec `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *RdmaAhRequestMsg) Reset()                    { *m = RdmaAhRequestMsg{} }
func (m *RdmaAhRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*RdmaAhRequestMsg) ProtoMessage()               {}
func (*RdmaAhRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptorRdma, []int{9} }

func (m *RdmaAhRequestMsg) GetRequest() []*RdmaAhSpec {
	if m != nil {
		return m.Request
	}
	return nil
}

// RdmaAhResponse to one RdmaAhSpec
type RdmaAhResponse struct {
	ApiStatus ApiStatus `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty"`
	AhHandle  uint32    `protobuf:"varint,2,opt,name=ah_handle,json=ahHandle,proto3" json:"ah_handle,omitempty"`
	AhSize    uint32    `protobuf:"varint,3,opt,name=ah_size,json=ahSize,proto3" json:"ah_size,omitempty"`
}

func (m *RdmaAhResponse) Reset()                    { *m = RdmaAhResponse{} }
func (m *RdmaAhResponse) String() string            { return proto.CompactTextString(m) }
func (*RdmaAhResponse) ProtoMessage()               {}
func (*RdmaAhResponse) Descriptor() ([]byte, []int) { return fileDescriptorRdma, []int{10} }

func (m *RdmaAhResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *RdmaAhResponse) GetAhHandle() uint32 {
	if m != nil {
		return m.AhHandle
	}
	return 0
}

func (m *RdmaAhResponse) GetAhSize() uint32 {
	if m != nil {
		return m.AhSize
	}
	return 0
}

// RdmaAhResponseMsg is response to RdmaAhRequestmsg
type RdmaAhResponseMsg struct {
	Response []*RdmaAhResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *RdmaAhResponseMsg) Reset()                    { *m = RdmaAhResponseMsg{} }
func (m *RdmaAhResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*RdmaAhResponseMsg) ProtoMessage()               {}
func (*RdmaAhResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptorRdma, []int{11} }

func (m *RdmaAhResponseMsg) GetResponse() []*RdmaAhResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

// **********************   Completion Queue  *****************************//
// RdmaCq object
type RdmaCqSpec struct {
	Meta          *ObjectMeta `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	CqNum         uint32      `protobuf:"varint,2,opt,name=cq_num,json=cqNum,proto3" json:"cq_num,omitempty"`
	HwLifId       uint32      `protobuf:"varint,3,opt,name=hw_lif_id,json=hwLifId,proto3" json:"hw_lif_id,omitempty"`
	CqWqeSize     uint32      `protobuf:"varint,4,opt,name=cq_wqe_size,json=cqWqeSize,proto3" json:"cq_wqe_size,omitempty"`
	NumCqWqes     uint32      `protobuf:"varint,5,opt,name=num_cq_wqes,json=numCqWqes,proto3" json:"num_cq_wqes,omitempty"`
	HostmemPgSize uint32      `protobuf:"varint,7,opt,name=hostmem_pg_size,json=hostmemPgSize,proto3" json:"hostmem_pg_size,omitempty"`
	CqLkey        uint32      `protobuf:"varint,8,opt,name=cq_lkey,json=cqLkey,proto3" json:"cq_lkey,omitempty"`
	EqId          uint32      `protobuf:"varint,9,opt,name=eq_id,json=eqId,proto3" json:"eq_id,omitempty"`
}

func (m *RdmaCqSpec) Reset()                    { *m = RdmaCqSpec{} }
func (m *RdmaCqSpec) String() string            { return proto.CompactTextString(m) }
func (*RdmaCqSpec) ProtoMessage()               {}
func (*RdmaCqSpec) Descriptor() ([]byte, []int) { return fileDescriptorRdma, []int{12} }

func (m *RdmaCqSpec) GetMeta() *ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *RdmaCqSpec) GetCqNum() uint32 {
	if m != nil {
		return m.CqNum
	}
	return 0
}

func (m *RdmaCqSpec) GetHwLifId() uint32 {
	if m != nil {
		return m.HwLifId
	}
	return 0
}

func (m *RdmaCqSpec) GetCqWqeSize() uint32 {
	if m != nil {
		return m.CqWqeSize
	}
	return 0
}

func (m *RdmaCqSpec) GetNumCqWqes() uint32 {
	if m != nil {
		return m.NumCqWqes
	}
	return 0
}

func (m *RdmaCqSpec) GetHostmemPgSize() uint32 {
	if m != nil {
		return m.HostmemPgSize
	}
	return 0
}

func (m *RdmaCqSpec) GetCqLkey() uint32 {
	if m != nil {
		return m.CqLkey
	}
	return 0
}

func (m *RdmaCqSpec) GetEqId() uint32 {
	if m != nil {
		return m.EqId
	}
	return 0
}

// RdmaCqRequestMsg is batched request used to create/update of Rdma QPs
type RdmaCqRequestMsg struct {
	Request []*RdmaCqSpec `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *RdmaCqRequestMsg) Reset()                    { *m = RdmaCqRequestMsg{} }
func (m *RdmaCqRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*RdmaCqRequestMsg) ProtoMessage()               {}
func (*RdmaCqRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptorRdma, []int{13} }

func (m *RdmaCqRequestMsg) GetRequest() []*RdmaCqSpec {
	if m != nil {
		return m.Request
	}
	return nil
}

// RdmaCqResponse response to one RdmaCqSpec
type RdmaCqResponse struct {
	ApiStatus ApiStatus `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty"`
}

func (m *RdmaCqResponse) Reset()                    { *m = RdmaCqResponse{} }
func (m *RdmaCqResponse) String() string            { return proto.CompactTextString(m) }
func (*RdmaCqResponse) ProtoMessage()               {}
func (*RdmaCqResponse) Descriptor() ([]byte, []int) { return fileDescriptorRdma, []int{14} }

func (m *RdmaCqResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

// RdmaCqResponseMsg is response to RdmaCqRequestMsg
type RdmaCqResponseMsg struct {
	Response []*RdmaCqResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *RdmaCqResponseMsg) Reset()                    { *m = RdmaCqResponseMsg{} }
func (m *RdmaCqResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*RdmaCqResponseMsg) ProtoMessage()               {}
func (*RdmaCqResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptorRdma, []int{15} }

func (m *RdmaCqResponseMsg) GetResponse() []*RdmaCqResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

// **********************   Event Queue  *****************************//
// RdmaEq object
type RdmaEqSpec struct {
	Meta           *ObjectMeta `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	EqId           uint32      `protobuf:"varint,2,opt,name=eq_id,json=eqId,proto3" json:"eq_id,omitempty"`
	HwLifId        uint32      `protobuf:"varint,3,opt,name=hw_lif_id,json=hwLifId,proto3" json:"hw_lif_id,omitempty"`
	EqWqeSize      uint32      `protobuf:"varint,4,opt,name=eq_wqe_size,json=eqWqeSize,proto3" json:"eq_wqe_size,omitempty"`
	NumEqWqes      uint32      `protobuf:"varint,5,opt,name=num_eq_wqes,json=numEqWqes,proto3" json:"num_eq_wqes,omitempty"`
	EqeBaseAddrPhy uint64      `protobuf:"varint,6,opt,name=eqe_base_addr_phy,json=eqeBaseAddrPhy,proto3" json:"eqe_base_addr_phy,omitempty"`
	IntNum         uint32      `protobuf:"varint,7,opt,name=int_num,json=intNum,proto3" json:"int_num,omitempty"`
}

func (m *RdmaEqSpec) Reset()                    { *m = RdmaEqSpec{} }
func (m *RdmaEqSpec) String() string            { return proto.CompactTextString(m) }
func (*RdmaEqSpec) ProtoMessage()               {}
func (*RdmaEqSpec) Descriptor() ([]byte, []int) { return fileDescriptorRdma, []int{16} }

func (m *RdmaEqSpec) GetMeta() *ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *RdmaEqSpec) GetEqId() uint32 {
	if m != nil {
		return m.EqId
	}
	return 0
}

func (m *RdmaEqSpec) GetHwLifId() uint32 {
	if m != nil {
		return m.HwLifId
	}
	return 0
}

func (m *RdmaEqSpec) GetEqWqeSize() uint32 {
	if m != nil {
		return m.EqWqeSize
	}
	return 0
}

func (m *RdmaEqSpec) GetNumEqWqes() uint32 {
	if m != nil {
		return m.NumEqWqes
	}
	return 0
}

func (m *RdmaEqSpec) GetEqeBaseAddrPhy() uint64 {
	if m != nil {
		return m.EqeBaseAddrPhy
	}
	return 0
}

func (m *RdmaEqSpec) GetIntNum() uint32 {
	if m != nil {
		return m.IntNum
	}
	return 0
}

// RdmaEqRequestMsg is batched request used to create/update of Rdma QPs
type RdmaEqRequestMsg struct {
	Request []*RdmaEqSpec `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *RdmaEqRequestMsg) Reset()                    { *m = RdmaEqRequestMsg{} }
func (m *RdmaEqRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*RdmaEqRequestMsg) ProtoMessage()               {}
func (*RdmaEqRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptorRdma, []int{17} }

func (m *RdmaEqRequestMsg) GetRequest() []*RdmaEqSpec {
	if m != nil {
		return m.Request
	}
	return nil
}

// RdmaEqResponse response to one RdmaEqSpec
type RdmaEqResponse struct {
	ApiStatus     ApiStatus `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty"`
	EqIntrTblAddr uint32    `protobuf:"varint,2,opt,name=eq_intr_tbl_addr,json=eqIntrTblAddr,proto3" json:"eq_intr_tbl_addr,omitempty"`
}

func (m *RdmaEqResponse) Reset()                    { *m = RdmaEqResponse{} }
func (m *RdmaEqResponse) String() string            { return proto.CompactTextString(m) }
func (*RdmaEqResponse) ProtoMessage()               {}
func (*RdmaEqResponse) Descriptor() ([]byte, []int) { return fileDescriptorRdma, []int{18} }

func (m *RdmaEqResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *RdmaEqResponse) GetEqIntrTblAddr() uint32 {
	if m != nil {
		return m.EqIntrTblAddr
	}
	return 0
}

// RdmaEqResponseMsg is response to RdmaEqRequestMsg
type RdmaEqResponseMsg struct {
	Response []*RdmaEqResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *RdmaEqResponseMsg) Reset()                    { *m = RdmaEqResponseMsg{} }
func (m *RdmaEqResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*RdmaEqResponseMsg) ProtoMessage()               {}
func (*RdmaEqResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptorRdma, []int{19} }

func (m *RdmaEqResponseMsg) GetResponse() []*RdmaEqResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

// **********************   Memory Registratin(MR)  *********************//
// RdmaMemReg object
type RdmaMemRegSpec struct {
	Meta           *ObjectMeta `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	HwLifId        uint64      `protobuf:"varint,2,opt,name=hw_lif_id,json=hwLifId,proto3" json:"hw_lif_id,omitempty"`
	Pd             uint32      `protobuf:"varint,3,opt,name=pd,proto3" json:"pd,omitempty"`
	Va             uint64      `protobuf:"varint,4,opt,name=va,proto3" json:"va,omitempty"`
	Len            uint32      `protobuf:"varint,5,opt,name=len,proto3" json:"len,omitempty"`
	AcLocalWr      bool        `protobuf:"varint,6,opt,name=ac_local_wr,json=acLocalWr,proto3" json:"ac_local_wr,omitempty"`
	AcRemoteWr     bool        `protobuf:"varint,7,opt,name=ac_remote_wr,json=acRemoteWr,proto3" json:"ac_remote_wr,omitempty"`
	AcRemoteRd     bool        `protobuf:"varint,8,opt,name=ac_remote_rd,json=acRemoteRd,proto3" json:"ac_remote_rd,omitempty"`
	AcRemoteAtomic bool        `protobuf:"varint,9,opt,name=ac_remote_atomic,json=acRemoteAtomic,proto3" json:"ac_remote_atomic,omitempty"`
	Lkey           uint32      `protobuf:"varint,10,opt,name=lkey,proto3" json:"lkey,omitempty"`
	Rkey           uint32      `protobuf:"varint,11,opt,name=rkey,proto3" json:"rkey,omitempty"`
	HostmemPgSize  uint32      `protobuf:"varint,12,opt,name=hostmem_pg_size,json=hostmemPgSize,proto3" json:"hostmem_pg_size,omitempty"`
	OverrideLif    uint32      `protobuf:"varint,13,opt,name=override_lif,json=overrideLif,proto3" json:"override_lif,omitempty"`
	OverrideLifVld bool        `protobuf:"varint,14,opt,name=override_lif_vld,json=overrideLifVld,proto3" json:"override_lif_vld,omitempty"`
	VaPagesPhyAddr []uint64    `protobuf:"varint,15,rep,packed,name=va_pages_phy_addr,json=vaPagesPhyAddr" json:"va_pages_phy_addr,omitempty"`
}

func (m *RdmaMemRegSpec) Reset()                    { *m = RdmaMemRegSpec{} }
func (m *RdmaMemRegSpec) String() string            { return proto.CompactTextString(m) }
func (*RdmaMemRegSpec) ProtoMessage()               {}
func (*RdmaMemRegSpec) Descriptor() ([]byte, []int) { return fileDescriptorRdma, []int{20} }

func (m *RdmaMemRegSpec) GetMeta() *ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *RdmaMemRegSpec) GetHwLifId() uint64 {
	if m != nil {
		return m.HwLifId
	}
	return 0
}

func (m *RdmaMemRegSpec) GetPd() uint32 {
	if m != nil {
		return m.Pd
	}
	return 0
}

func (m *RdmaMemRegSpec) GetVa() uint64 {
	if m != nil {
		return m.Va
	}
	return 0
}

func (m *RdmaMemRegSpec) GetLen() uint32 {
	if m != nil {
		return m.Len
	}
	return 0
}

func (m *RdmaMemRegSpec) GetAcLocalWr() bool {
	if m != nil {
		return m.AcLocalWr
	}
	return false
}

func (m *RdmaMemRegSpec) GetAcRemoteWr() bool {
	if m != nil {
		return m.AcRemoteWr
	}
	return false
}

func (m *RdmaMemRegSpec) GetAcRemoteRd() bool {
	if m != nil {
		return m.AcRemoteRd
	}
	return false
}

func (m *RdmaMemRegSpec) GetAcRemoteAtomic() bool {
	if m != nil {
		return m.AcRemoteAtomic
	}
	return false
}

func (m *RdmaMemRegSpec) GetLkey() uint32 {
	if m != nil {
		return m.Lkey
	}
	return 0
}

func (m *RdmaMemRegSpec) GetRkey() uint32 {
	if m != nil {
		return m.Rkey
	}
	return 0
}

func (m *RdmaMemRegSpec) GetHostmemPgSize() uint32 {
	if m != nil {
		return m.HostmemPgSize
	}
	return 0
}

func (m *RdmaMemRegSpec) GetOverrideLif() uint32 {
	if m != nil {
		return m.OverrideLif
	}
	return 0
}

func (m *RdmaMemRegSpec) GetOverrideLifVld() bool {
	if m != nil {
		return m.OverrideLifVld
	}
	return false
}

func (m *RdmaMemRegSpec) GetVaPagesPhyAddr() []uint64 {
	if m != nil {
		return m.VaPagesPhyAddr
	}
	return nil
}

// RdmaMemRegRequestMsg is batched request used to create/update of Rdma QPs
type RdmaMemRegRequestMsg struct {
	Request []*RdmaMemRegSpec `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *RdmaMemRegRequestMsg) Reset()                    { *m = RdmaMemRegRequestMsg{} }
func (m *RdmaMemRegRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*RdmaMemRegRequestMsg) ProtoMessage()               {}
func (*RdmaMemRegRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptorRdma, []int{21} }

func (m *RdmaMemRegRequestMsg) GetRequest() []*RdmaMemRegSpec {
	if m != nil {
		return m.Request
	}
	return nil
}

// RdmaMemRegResponse response to one RdmaMemRegSpec
type RdmaMemRegResponse struct {
	ApiStatus ApiStatus `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty"`
}

func (m *RdmaMemRegResponse) Reset()                    { *m = RdmaMemRegResponse{} }
func (m *RdmaMemRegResponse) String() string            { return proto.CompactTextString(m) }
func (*RdmaMemRegResponse) ProtoMessage()               {}
func (*RdmaMemRegResponse) Descriptor() ([]byte, []int) { return fileDescriptorRdma, []int{22} }

func (m *RdmaMemRegResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

// RdmaMemRegResponseMsg is response to RdmaMemRegRequestMsg
type RdmaMemRegResponseMsg struct {
	Response []*RdmaMemRegResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *RdmaMemRegResponseMsg) Reset()                    { *m = RdmaMemRegResponseMsg{} }
func (m *RdmaMemRegResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*RdmaMemRegResponseMsg) ProtoMessage()               {}
func (*RdmaMemRegResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptorRdma, []int{23} }

func (m *RdmaMemRegResponseMsg) GetResponse() []*RdmaMemRegResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

func init() {
	proto.RegisterType((*RdmaQpSpec)(nil), "rdma.RdmaQpSpec")
	proto.RegisterType((*RdmaQpRequestMsg)(nil), "rdma.RdmaQpRequestMsg")
	proto.RegisterType((*RdmaQpResponse)(nil), "rdma.RdmaQpResponse")
	proto.RegisterType((*RdmaQpResponseMsg)(nil), "rdma.RdmaQpResponseMsg")
	proto.RegisterType((*RdmaQpUpdateSpec)(nil), "rdma.RdmaQpUpdateSpec")
	proto.RegisterType((*RdmaQpUpdateRequestMsg)(nil), "rdma.RdmaQpUpdateRequestMsg")
	proto.RegisterType((*RdmaQpUpdateResponse)(nil), "rdma.RdmaQpUpdateResponse")
	proto.RegisterType((*RdmaQpUpdateResponseMsg)(nil), "rdma.RdmaQpUpdateResponseMsg")
	proto.RegisterType((*RdmaAhSpec)(nil), "rdma.RdmaAhSpec")
	proto.RegisterType((*RdmaAhRequestMsg)(nil), "rdma.RdmaAhRequestMsg")
	proto.RegisterType((*RdmaAhResponse)(nil), "rdma.RdmaAhResponse")
	proto.RegisterType((*RdmaAhResponseMsg)(nil), "rdma.RdmaAhResponseMsg")
	proto.RegisterType((*RdmaCqSpec)(nil), "rdma.RdmaCqSpec")
	proto.RegisterType((*RdmaCqRequestMsg)(nil), "rdma.RdmaCqRequestMsg")
	proto.RegisterType((*RdmaCqResponse)(nil), "rdma.RdmaCqResponse")
	proto.RegisterType((*RdmaCqResponseMsg)(nil), "rdma.RdmaCqResponseMsg")
	proto.RegisterType((*RdmaEqSpec)(nil), "rdma.RdmaEqSpec")
	proto.RegisterType((*RdmaEqRequestMsg)(nil), "rdma.RdmaEqRequestMsg")
	proto.RegisterType((*RdmaEqResponse)(nil), "rdma.RdmaEqResponse")
	proto.RegisterType((*RdmaEqResponseMsg)(nil), "rdma.RdmaEqResponseMsg")
	proto.RegisterType((*RdmaMemRegSpec)(nil), "rdma.RdmaMemRegSpec")
	proto.RegisterType((*RdmaMemRegRequestMsg)(nil), "rdma.RdmaMemRegRequestMsg")
	proto.RegisterType((*RdmaMemRegResponse)(nil), "rdma.RdmaMemRegResponse")
	proto.RegisterType((*RdmaMemRegResponseMsg)(nil), "rdma.RdmaMemRegResponseMsg")
	proto.RegisterEnum("rdma.RdmaServiceType", RdmaServiceType_name, RdmaServiceType_value)
	proto.RegisterEnum("rdma.RdmaQpUpdateOper", RdmaQpUpdateOper_name, RdmaQpUpdateOper_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Rdma service

type RdmaClient interface {
	// Queue Pair related APIs
	RdmaQpCreate(ctx context.Context, in *RdmaQpRequestMsg, opts ...grpc.CallOption) (*RdmaQpResponseMsg, error)
	RdmaQpUpdate(ctx context.Context, in *RdmaQpUpdateRequestMsg, opts ...grpc.CallOption) (*RdmaQpUpdateResponseMsg, error)
	RdmaAhCreate(ctx context.Context, in *RdmaAhRequestMsg, opts ...grpc.CallOption) (*RdmaAhResponseMsg, error)
	// Completion Q related APIs
	RdmaCqCreate(ctx context.Context, in *RdmaCqRequestMsg, opts ...grpc.CallOption) (*RdmaCqResponseMsg, error)
	// Completion Q related APIs
	RdmaEqCreate(ctx context.Context, in *RdmaEqRequestMsg, opts ...grpc.CallOption) (*RdmaEqResponseMsg, error)
	// Register Memory related APIs
	RdmaMemReg(ctx context.Context, in *RdmaMemRegRequestMsg, opts ...grpc.CallOption) (*RdmaMemRegResponseMsg, error)
}

type rdmaClient struct {
	cc *grpc.ClientConn
}

func NewRdmaClient(cc *grpc.ClientConn) RdmaClient {
	return &rdmaClient{cc}
}

func (c *rdmaClient) RdmaQpCreate(ctx context.Context, in *RdmaQpRequestMsg, opts ...grpc.CallOption) (*RdmaQpResponseMsg, error) {
	out := new(RdmaQpResponseMsg)
	err := grpc.Invoke(ctx, "/rdma.Rdma/RdmaQpCreate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rdmaClient) RdmaQpUpdate(ctx context.Context, in *RdmaQpUpdateRequestMsg, opts ...grpc.CallOption) (*RdmaQpUpdateResponseMsg, error) {
	out := new(RdmaQpUpdateResponseMsg)
	err := grpc.Invoke(ctx, "/rdma.Rdma/RdmaQpUpdate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rdmaClient) RdmaAhCreate(ctx context.Context, in *RdmaAhRequestMsg, opts ...grpc.CallOption) (*RdmaAhResponseMsg, error) {
	out := new(RdmaAhResponseMsg)
	err := grpc.Invoke(ctx, "/rdma.Rdma/RdmaAhCreate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rdmaClient) RdmaCqCreate(ctx context.Context, in *RdmaCqRequestMsg, opts ...grpc.CallOption) (*RdmaCqResponseMsg, error) {
	out := new(RdmaCqResponseMsg)
	err := grpc.Invoke(ctx, "/rdma.Rdma/RdmaCqCreate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rdmaClient) RdmaEqCreate(ctx context.Context, in *RdmaEqRequestMsg, opts ...grpc.CallOption) (*RdmaEqResponseMsg, error) {
	out := new(RdmaEqResponseMsg)
	err := grpc.Invoke(ctx, "/rdma.Rdma/RdmaEqCreate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rdmaClient) RdmaMemReg(ctx context.Context, in *RdmaMemRegRequestMsg, opts ...grpc.CallOption) (*RdmaMemRegResponseMsg, error) {
	out := new(RdmaMemRegResponseMsg)
	err := grpc.Invoke(ctx, "/rdma.Rdma/RdmaMemReg", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Rdma service

type RdmaServer interface {
	// Queue Pair related APIs
	RdmaQpCreate(context.Context, *RdmaQpRequestMsg) (*RdmaQpResponseMsg, error)
	RdmaQpUpdate(context.Context, *RdmaQpUpdateRequestMsg) (*RdmaQpUpdateResponseMsg, error)
	RdmaAhCreate(context.Context, *RdmaAhRequestMsg) (*RdmaAhResponseMsg, error)
	// Completion Q related APIs
	RdmaCqCreate(context.Context, *RdmaCqRequestMsg) (*RdmaCqResponseMsg, error)
	// Completion Q related APIs
	RdmaEqCreate(context.Context, *RdmaEqRequestMsg) (*RdmaEqResponseMsg, error)
	// Register Memory related APIs
	RdmaMemReg(context.Context, *RdmaMemRegRequestMsg) (*RdmaMemRegResponseMsg, error)
}

func RegisterRdmaServer(s *grpc.Server, srv RdmaServer) {
	s.RegisterService(&_Rdma_serviceDesc, srv)
}

func _Rdma_RdmaQpCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RdmaQpRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RdmaServer).RdmaQpCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rdma.Rdma/RdmaQpCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RdmaServer).RdmaQpCreate(ctx, req.(*RdmaQpRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Rdma_RdmaQpUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RdmaQpUpdateRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RdmaServer).RdmaQpUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rdma.Rdma/RdmaQpUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RdmaServer).RdmaQpUpdate(ctx, req.(*RdmaQpUpdateRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Rdma_RdmaAhCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RdmaAhRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RdmaServer).RdmaAhCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rdma.Rdma/RdmaAhCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RdmaServer).RdmaAhCreate(ctx, req.(*RdmaAhRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Rdma_RdmaCqCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RdmaCqRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RdmaServer).RdmaCqCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rdma.Rdma/RdmaCqCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RdmaServer).RdmaCqCreate(ctx, req.(*RdmaCqRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Rdma_RdmaEqCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RdmaEqRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RdmaServer).RdmaEqCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rdma.Rdma/RdmaEqCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RdmaServer).RdmaEqCreate(ctx, req.(*RdmaEqRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Rdma_RdmaMemReg_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RdmaMemRegRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RdmaServer).RdmaMemReg(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rdma.Rdma/RdmaMemReg",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RdmaServer).RdmaMemReg(ctx, req.(*RdmaMemRegRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

var _Rdma_serviceDesc = grpc.ServiceDesc{
	ServiceName: "rdma.Rdma",
	HandlerType: (*RdmaServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RdmaQpCreate",
			Handler:    _Rdma_RdmaQpCreate_Handler,
		},
		{
			MethodName: "RdmaQpUpdate",
			Handler:    _Rdma_RdmaQpUpdate_Handler,
		},
		{
			MethodName: "RdmaAhCreate",
			Handler:    _Rdma_RdmaAhCreate_Handler,
		},
		{
			MethodName: "RdmaCqCreate",
			Handler:    _Rdma_RdmaCqCreate_Handler,
		},
		{
			MethodName: "RdmaEqCreate",
			Handler:    _Rdma_RdmaEqCreate_Handler,
		},
		{
			MethodName: "RdmaMemReg",
			Handler:    _Rdma_RdmaMemReg_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "rdma.proto",
}

func (m *RdmaQpSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RdmaQpSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.Meta.Size()))
		n1, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.QpNum != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.QpNum))
	}
	if m.HwLifId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.HwLifId))
	}
	if m.SqWqeSize != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.SqWqeSize))
	}
	if m.RqWqeSize != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.RqWqeSize))
	}
	if m.NumSqWqes != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.NumSqWqes))
	}
	if m.NumRqWqes != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.NumRqWqes))
	}
	if m.NumRsqWqes != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.NumRsqWqes))
	}
	if m.NumRrqWqes != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.NumRrqWqes))
	}
	if m.Pd != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.Pd))
	}
	if m.Pmtu != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.Pmtu))
	}
	if m.HostmemPgSize != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.HostmemPgSize))
	}
	if m.Svc != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.Svc))
	}
	if m.AtomicEnabled {
		dAtA[i] = 0x70
		i++
		if m.AtomicEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.SqLkey != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.SqLkey))
	}
	if m.RqLkey != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.RqLkey))
	}
	if m.RqCqNum != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.RqCqNum))
	}
	if m.SqCqNum != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.SqCqNum))
	}
	if m.ImmdtAsDbell {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x1
		i++
		if m.ImmdtAsDbell {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IfHandle != 0 {
		dAtA[i] = 0xa1
		i++
		dAtA[i] = 0x1
		i++
		i = encodeFixed64Rdma(dAtA, i, uint64(m.IfHandle))
	}
	return i, nil
}

func (m *RdmaQpRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RdmaQpRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintRdma(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *RdmaQpResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RdmaQpResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.ApiStatus))
	}
	if m.RsqBaseAddr != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.RsqBaseAddr))
	}
	if m.RrqBaseAddr != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.RrqBaseAddr))
	}
	if m.HeaderTempAddr != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.HeaderTempAddr))
	}
	return i, nil
}

func (m *RdmaQpResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RdmaQpResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintRdma(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *RdmaQpUpdateSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RdmaQpUpdateSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.Meta.Size()))
		n2, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.QpNum != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.QpNum))
	}
	if m.HwLifId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.HwLifId))
	}
	if m.Oper != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.Oper))
	}
	if m.DstQpNum != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.DstQpNum))
	}
	if len(m.HeaderTemplate) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintRdma(dAtA, i, uint64(len(m.HeaderTemplate)))
		i += copy(dAtA[i:], m.HeaderTemplate)
	}
	if m.QKey != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.QKey))
	}
	return i, nil
}

func (m *RdmaQpUpdateRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RdmaQpUpdateRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintRdma(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *RdmaQpUpdateResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RdmaQpUpdateResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.ApiStatus))
	}
	return i, nil
}

func (m *RdmaQpUpdateResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RdmaQpUpdateResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintRdma(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *RdmaAhSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RdmaAhSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.Meta.Size()))
		n3, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if len(m.Smac) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRdma(dAtA, i, uint64(len(m.Smac)))
		i += copy(dAtA[i:], m.Smac)
	}
	if len(m.Dmac) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintRdma(dAtA, i, uint64(len(m.Dmac)))
		i += copy(dAtA[i:], m.Dmac)
	}
	if m.Ethtype != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.Ethtype))
	}
	if m.Vlan != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.Vlan))
	}
	if m.VlanPri != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.VlanPri))
	}
	if m.VlanCfi != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.VlanCfi))
	}
	if m.IpVer != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.IpVer))
	}
	if m.IpTos != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.IpTos))
	}
	if m.IpTtl != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.IpTtl))
	}
	if m.IpSaddr != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.IpSaddr.Size()))
		n4, err := m.IpSaddr.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.IpDaddr != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.IpDaddr.Size()))
		n5, err := m.IpDaddr.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.UdpSport != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.UdpSport))
	}
	if m.UdpDport != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.UdpDport))
	}
	return i, nil
}

func (m *RdmaAhRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RdmaAhRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintRdma(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *RdmaAhResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RdmaAhResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.ApiStatus))
	}
	if m.AhHandle != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.AhHandle))
	}
	if m.AhSize != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.AhSize))
	}
	return i, nil
}

func (m *RdmaAhResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RdmaAhResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintRdma(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *RdmaCqSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RdmaCqSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.Meta.Size()))
		n6, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.CqNum != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.CqNum))
	}
	if m.HwLifId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.HwLifId))
	}
	if m.CqWqeSize != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.CqWqeSize))
	}
	if m.NumCqWqes != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.NumCqWqes))
	}
	if m.HostmemPgSize != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.HostmemPgSize))
	}
	if m.CqLkey != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.CqLkey))
	}
	if m.EqId != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.EqId))
	}
	return i, nil
}

func (m *RdmaCqRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RdmaCqRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintRdma(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *RdmaCqResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RdmaCqResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.ApiStatus))
	}
	return i, nil
}

func (m *RdmaCqResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RdmaCqResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintRdma(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *RdmaEqSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RdmaEqSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.Meta.Size()))
		n7, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.EqId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.EqId))
	}
	if m.HwLifId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.HwLifId))
	}
	if m.EqWqeSize != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.EqWqeSize))
	}
	if m.NumEqWqes != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.NumEqWqes))
	}
	if m.EqeBaseAddrPhy != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.EqeBaseAddrPhy))
	}
	if m.IntNum != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.IntNum))
	}
	return i, nil
}

func (m *RdmaEqRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RdmaEqRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintRdma(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *RdmaEqResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RdmaEqResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.ApiStatus))
	}
	if m.EqIntrTblAddr != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.EqIntrTblAddr))
	}
	return i, nil
}

func (m *RdmaEqResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RdmaEqResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintRdma(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *RdmaMemRegSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RdmaMemRegSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.Meta.Size()))
		n8, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.HwLifId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.HwLifId))
	}
	if m.Pd != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.Pd))
	}
	if m.Va != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.Va))
	}
	if m.Len != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.Len))
	}
	if m.AcLocalWr {
		dAtA[i] = 0x30
		i++
		if m.AcLocalWr {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.AcRemoteWr {
		dAtA[i] = 0x38
		i++
		if m.AcRemoteWr {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.AcRemoteRd {
		dAtA[i] = 0x40
		i++
		if m.AcRemoteRd {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.AcRemoteAtomic {
		dAtA[i] = 0x48
		i++
		if m.AcRemoteAtomic {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Lkey != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.Lkey))
	}
	if m.Rkey != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.Rkey))
	}
	if m.HostmemPgSize != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.HostmemPgSize))
	}
	if m.OverrideLif != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.OverrideLif))
	}
	if m.OverrideLifVld {
		dAtA[i] = 0x70
		i++
		if m.OverrideLifVld {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.VaPagesPhyAddr) > 0 {
		dAtA10 := make([]byte, len(m.VaPagesPhyAddr)*10)
		var j9 int
		for _, num := range m.VaPagesPhyAddr {
			for num >= 1<<7 {
				dAtA10[j9] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j9++
			}
			dAtA10[j9] = uint8(num)
			j9++
		}
		dAtA[i] = 0x7a
		i++
		i = encodeVarintRdma(dAtA, i, uint64(j9))
		i += copy(dAtA[i:], dAtA10[:j9])
	}
	return i, nil
}

func (m *RdmaMemRegRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RdmaMemRegRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintRdma(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *RdmaMemRegResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RdmaMemRegResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.ApiStatus))
	}
	return i, nil
}

func (m *RdmaMemRegResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RdmaMemRegResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintRdma(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func encodeFixed64Rdma(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Rdma(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintRdma(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *RdmaQpSpec) Size() (n int) {
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovRdma(uint64(l))
	}
	if m.QpNum != 0 {
		n += 1 + sovRdma(uint64(m.QpNum))
	}
	if m.HwLifId != 0 {
		n += 1 + sovRdma(uint64(m.HwLifId))
	}
	if m.SqWqeSize != 0 {
		n += 1 + sovRdma(uint64(m.SqWqeSize))
	}
	if m.RqWqeSize != 0 {
		n += 1 + sovRdma(uint64(m.RqWqeSize))
	}
	if m.NumSqWqes != 0 {
		n += 1 + sovRdma(uint64(m.NumSqWqes))
	}
	if m.NumRqWqes != 0 {
		n += 1 + sovRdma(uint64(m.NumRqWqes))
	}
	if m.NumRsqWqes != 0 {
		n += 1 + sovRdma(uint64(m.NumRsqWqes))
	}
	if m.NumRrqWqes != 0 {
		n += 1 + sovRdma(uint64(m.NumRrqWqes))
	}
	if m.Pd != 0 {
		n += 1 + sovRdma(uint64(m.Pd))
	}
	if m.Pmtu != 0 {
		n += 1 + sovRdma(uint64(m.Pmtu))
	}
	if m.HostmemPgSize != 0 {
		n += 1 + sovRdma(uint64(m.HostmemPgSize))
	}
	if m.Svc != 0 {
		n += 1 + sovRdma(uint64(m.Svc))
	}
	if m.AtomicEnabled {
		n += 2
	}
	if m.SqLkey != 0 {
		n += 1 + sovRdma(uint64(m.SqLkey))
	}
	if m.RqLkey != 0 {
		n += 2 + sovRdma(uint64(m.RqLkey))
	}
	if m.RqCqNum != 0 {
		n += 2 + sovRdma(uint64(m.RqCqNum))
	}
	if m.SqCqNum != 0 {
		n += 2 + sovRdma(uint64(m.SqCqNum))
	}
	if m.ImmdtAsDbell {
		n += 3
	}
	if m.IfHandle != 0 {
		n += 10
	}
	return n
}

func (m *RdmaQpRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovRdma(uint64(l))
		}
	}
	return n
}

func (m *RdmaQpResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovRdma(uint64(m.ApiStatus))
	}
	if m.RsqBaseAddr != 0 {
		n += 1 + sovRdma(uint64(m.RsqBaseAddr))
	}
	if m.RrqBaseAddr != 0 {
		n += 1 + sovRdma(uint64(m.RrqBaseAddr))
	}
	if m.HeaderTempAddr != 0 {
		n += 1 + sovRdma(uint64(m.HeaderTempAddr))
	}
	return n
}

func (m *RdmaQpResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovRdma(uint64(l))
		}
	}
	return n
}

func (m *RdmaQpUpdateSpec) Size() (n int) {
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovRdma(uint64(l))
	}
	if m.QpNum != 0 {
		n += 1 + sovRdma(uint64(m.QpNum))
	}
	if m.HwLifId != 0 {
		n += 1 + sovRdma(uint64(m.HwLifId))
	}
	if m.Oper != 0 {
		n += 1 + sovRdma(uint64(m.Oper))
	}
	if m.DstQpNum != 0 {
		n += 1 + sovRdma(uint64(m.DstQpNum))
	}
	l = len(m.HeaderTemplate)
	if l > 0 {
		n += 1 + l + sovRdma(uint64(l))
	}
	if m.QKey != 0 {
		n += 1 + sovRdma(uint64(m.QKey))
	}
	return n
}

func (m *RdmaQpUpdateRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovRdma(uint64(l))
		}
	}
	return n
}

func (m *RdmaQpUpdateResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovRdma(uint64(m.ApiStatus))
	}
	return n
}

func (m *RdmaQpUpdateResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovRdma(uint64(l))
		}
	}
	return n
}

func (m *RdmaAhSpec) Size() (n int) {
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovRdma(uint64(l))
	}
	l = len(m.Smac)
	if l > 0 {
		n += 1 + l + sovRdma(uint64(l))
	}
	l = len(m.Dmac)
	if l > 0 {
		n += 1 + l + sovRdma(uint64(l))
	}
	if m.Ethtype != 0 {
		n += 1 + sovRdma(uint64(m.Ethtype))
	}
	if m.Vlan != 0 {
		n += 1 + sovRdma(uint64(m.Vlan))
	}
	if m.VlanPri != 0 {
		n += 1 + sovRdma(uint64(m.VlanPri))
	}
	if m.VlanCfi != 0 {
		n += 1 + sovRdma(uint64(m.VlanCfi))
	}
	if m.IpVer != 0 {
		n += 1 + sovRdma(uint64(m.IpVer))
	}
	if m.IpTos != 0 {
		n += 1 + sovRdma(uint64(m.IpTos))
	}
	if m.IpTtl != 0 {
		n += 1 + sovRdma(uint64(m.IpTtl))
	}
	if m.IpSaddr != nil {
		l = m.IpSaddr.Size()
		n += 1 + l + sovRdma(uint64(l))
	}
	if m.IpDaddr != nil {
		l = m.IpDaddr.Size()
		n += 1 + l + sovRdma(uint64(l))
	}
	if m.UdpSport != 0 {
		n += 1 + sovRdma(uint64(m.UdpSport))
	}
	if m.UdpDport != 0 {
		n += 1 + sovRdma(uint64(m.UdpDport))
	}
	return n
}

func (m *RdmaAhRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovRdma(uint64(l))
		}
	}
	return n
}

func (m *RdmaAhResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovRdma(uint64(m.ApiStatus))
	}
	if m.AhHandle != 0 {
		n += 1 + sovRdma(uint64(m.AhHandle))
	}
	if m.AhSize != 0 {
		n += 1 + sovRdma(uint64(m.AhSize))
	}
	return n
}

func (m *RdmaAhResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovRdma(uint64(l))
		}
	}
	return n
}

func (m *RdmaCqSpec) Size() (n int) {
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovRdma(uint64(l))
	}
	if m.CqNum != 0 {
		n += 1 + sovRdma(uint64(m.CqNum))
	}
	if m.HwLifId != 0 {
		n += 1 + sovRdma(uint64(m.HwLifId))
	}
	if m.CqWqeSize != 0 {
		n += 1 + sovRdma(uint64(m.CqWqeSize))
	}
	if m.NumCqWqes != 0 {
		n += 1 + sovRdma(uint64(m.NumCqWqes))
	}
	if m.HostmemPgSize != 0 {
		n += 1 + sovRdma(uint64(m.HostmemPgSize))
	}
	if m.CqLkey != 0 {
		n += 1 + sovRdma(uint64(m.CqLkey))
	}
	if m.EqId != 0 {
		n += 1 + sovRdma(uint64(m.EqId))
	}
	return n
}

func (m *RdmaCqRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovRdma(uint64(l))
		}
	}
	return n
}

func (m *RdmaCqResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovRdma(uint64(m.ApiStatus))
	}
	return n
}

func (m *RdmaCqResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovRdma(uint64(l))
		}
	}
	return n
}

func (m *RdmaEqSpec) Size() (n int) {
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovRdma(uint64(l))
	}
	if m.EqId != 0 {
		n += 1 + sovRdma(uint64(m.EqId))
	}
	if m.HwLifId != 0 {
		n += 1 + sovRdma(uint64(m.HwLifId))
	}
	if m.EqWqeSize != 0 {
		n += 1 + sovRdma(uint64(m.EqWqeSize))
	}
	if m.NumEqWqes != 0 {
		n += 1 + sovRdma(uint64(m.NumEqWqes))
	}
	if m.EqeBaseAddrPhy != 0 {
		n += 1 + sovRdma(uint64(m.EqeBaseAddrPhy))
	}
	if m.IntNum != 0 {
		n += 1 + sovRdma(uint64(m.IntNum))
	}
	return n
}

func (m *RdmaEqRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovRdma(uint64(l))
		}
	}
	return n
}

func (m *RdmaEqResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovRdma(uint64(m.ApiStatus))
	}
	if m.EqIntrTblAddr != 0 {
		n += 1 + sovRdma(uint64(m.EqIntrTblAddr))
	}
	return n
}

func (m *RdmaEqResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovRdma(uint64(l))
		}
	}
	return n
}

func (m *RdmaMemRegSpec) Size() (n int) {
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovRdma(uint64(l))
	}
	if m.HwLifId != 0 {
		n += 1 + sovRdma(uint64(m.HwLifId))
	}
	if m.Pd != 0 {
		n += 1 + sovRdma(uint64(m.Pd))
	}
	if m.Va != 0 {
		n += 1 + sovRdma(uint64(m.Va))
	}
	if m.Len != 0 {
		n += 1 + sovRdma(uint64(m.Len))
	}
	if m.AcLocalWr {
		n += 2
	}
	if m.AcRemoteWr {
		n += 2
	}
	if m.AcRemoteRd {
		n += 2
	}
	if m.AcRemoteAtomic {
		n += 2
	}
	if m.Lkey != 0 {
		n += 1 + sovRdma(uint64(m.Lkey))
	}
	if m.Rkey != 0 {
		n += 1 + sovRdma(uint64(m.Rkey))
	}
	if m.HostmemPgSize != 0 {
		n += 1 + sovRdma(uint64(m.HostmemPgSize))
	}
	if m.OverrideLif != 0 {
		n += 1 + sovRdma(uint64(m.OverrideLif))
	}
	if m.OverrideLifVld {
		n += 2
	}
	if len(m.VaPagesPhyAddr) > 0 {
		l = 0
		for _, e := range m.VaPagesPhyAddr {
			l += sovRdma(uint64(e))
		}
		n += 1 + sovRdma(uint64(l)) + l
	}
	return n
}

func (m *RdmaMemRegRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovRdma(uint64(l))
		}
	}
	return n
}

func (m *RdmaMemRegResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovRdma(uint64(m.ApiStatus))
	}
	return n
}

func (m *RdmaMemRegResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovRdma(uint64(l))
		}
	}
	return n
}

func sovRdma(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozRdma(x uint64) (n int) {
	return sovRdma(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *RdmaQpSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRdma
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RdmaQpSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RdmaQpSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRdma
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &ObjectMeta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field QpNum", wireType)
			}
			m.QpNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.QpNum |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HwLifId", wireType)
			}
			m.HwLifId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HwLifId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SqWqeSize", wireType)
			}
			m.SqWqeSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SqWqeSize |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RqWqeSize", wireType)
			}
			m.RqWqeSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RqWqeSize |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumSqWqes", wireType)
			}
			m.NumSqWqes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumSqWqes |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumRqWqes", wireType)
			}
			m.NumRqWqes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumRqWqes |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumRsqWqes", wireType)
			}
			m.NumRsqWqes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumRsqWqes |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumRrqWqes", wireType)
			}
			m.NumRrqWqes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumRrqWqes |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pd", wireType)
			}
			m.Pd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pd |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pmtu", wireType)
			}
			m.Pmtu = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pmtu |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostmemPgSize", wireType)
			}
			m.HostmemPgSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HostmemPgSize |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Svc", wireType)
			}
			m.Svc = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Svc |= (RdmaServiceType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AtomicEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AtomicEnabled = bool(v != 0)
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SqLkey", wireType)
			}
			m.SqLkey = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SqLkey |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RqLkey", wireType)
			}
			m.RqLkey = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RqLkey |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RqCqNum", wireType)
			}
			m.RqCqNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RqCqNum |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SqCqNum", wireType)
			}
			m.SqCqNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SqCqNum |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImmdtAsDbell", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ImmdtAsDbell = bool(v != 0)
		case 20:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field IfHandle", wireType)
			}
			m.IfHandle = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			m.IfHandle = uint64(dAtA[iNdEx-8])
			m.IfHandle |= uint64(dAtA[iNdEx-7]) << 8
			m.IfHandle |= uint64(dAtA[iNdEx-6]) << 16
			m.IfHandle |= uint64(dAtA[iNdEx-5]) << 24
			m.IfHandle |= uint64(dAtA[iNdEx-4]) << 32
			m.IfHandle |= uint64(dAtA[iNdEx-3]) << 40
			m.IfHandle |= uint64(dAtA[iNdEx-2]) << 48
			m.IfHandle |= uint64(dAtA[iNdEx-1]) << 56
		default:
			iNdEx = preIndex
			skippy, err := skipRdma(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRdma
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RdmaQpRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRdma
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RdmaQpRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RdmaQpRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRdma
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &RdmaQpSpec{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRdma(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRdma
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RdmaQpResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRdma
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RdmaQpResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RdmaQpResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RsqBaseAddr", wireType)
			}
			m.RsqBaseAddr = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RsqBaseAddr |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RrqBaseAddr", wireType)
			}
			m.RrqBaseAddr = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RrqBaseAddr |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeaderTempAddr", wireType)
			}
			m.HeaderTempAddr = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HeaderTempAddr |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRdma(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRdma
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RdmaQpResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRdma
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RdmaQpResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RdmaQpResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRdma
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &RdmaQpResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRdma(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRdma
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RdmaQpUpdateSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRdma
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RdmaQpUpdateSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RdmaQpUpdateSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRdma
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &ObjectMeta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field QpNum", wireType)
			}
			m.QpNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.QpNum |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HwLifId", wireType)
			}
			m.HwLifId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HwLifId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Oper", wireType)
			}
			m.Oper = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Oper |= (RdmaQpUpdateOper(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstQpNum", wireType)
			}
			m.DstQpNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DstQpNum |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeaderTemplate", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRdma
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HeaderTemplate = append(m.HeaderTemplate[:0], dAtA[iNdEx:postIndex]...)
			if m.HeaderTemplate == nil {
				m.HeaderTemplate = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field QKey", wireType)
			}
			m.QKey = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.QKey |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRdma(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRdma
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RdmaQpUpdateRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRdma
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RdmaQpUpdateRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RdmaQpUpdateRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRdma
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &RdmaQpUpdateSpec{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRdma(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRdma
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RdmaQpUpdateResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRdma
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RdmaQpUpdateResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RdmaQpUpdateResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRdma(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRdma
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RdmaQpUpdateResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRdma
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RdmaQpUpdateResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RdmaQpUpdateResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRdma
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &RdmaQpUpdateResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRdma(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRdma
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RdmaAhSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRdma
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RdmaAhSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RdmaAhSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRdma
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &ObjectMeta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Smac", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRdma
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Smac = append(m.Smac[:0], dAtA[iNdEx:postIndex]...)
			if m.Smac == nil {
				m.Smac = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dmac", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRdma
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Dmac = append(m.Dmac[:0], dAtA[iNdEx:postIndex]...)
			if m.Dmac == nil {
				m.Dmac = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ethtype", wireType)
			}
			m.Ethtype = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ethtype |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vlan", wireType)
			}
			m.Vlan = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Vlan |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VlanPri", wireType)
			}
			m.VlanPri = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VlanPri |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VlanCfi", wireType)
			}
			m.VlanCfi = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VlanCfi |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpVer", wireType)
			}
			m.IpVer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IpVer |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpTos", wireType)
			}
			m.IpTos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IpTos |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpTtl", wireType)
			}
			m.IpTtl = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IpTtl |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpSaddr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRdma
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IpSaddr == nil {
				m.IpSaddr = &IPAddress{}
			}
			if err := m.IpSaddr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpDaddr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRdma
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IpDaddr == nil {
				m.IpDaddr = &IPAddress{}
			}
			if err := m.IpDaddr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UdpSport", wireType)
			}
			m.UdpSport = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UdpSport |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UdpDport", wireType)
			}
			m.UdpDport = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UdpDport |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRdma(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRdma
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RdmaAhRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRdma
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RdmaAhRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RdmaAhRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRdma
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &RdmaAhSpec{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRdma(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRdma
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RdmaAhResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRdma
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RdmaAhResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RdmaAhResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AhHandle", wireType)
			}
			m.AhHandle = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AhHandle |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AhSize", wireType)
			}
			m.AhSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AhSize |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRdma(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRdma
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RdmaAhResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRdma
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RdmaAhResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RdmaAhResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRdma
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &RdmaAhResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRdma(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRdma
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RdmaCqSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRdma
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RdmaCqSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RdmaCqSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRdma
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &ObjectMeta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CqNum", wireType)
			}
			m.CqNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CqNum |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HwLifId", wireType)
			}
			m.HwLifId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HwLifId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CqWqeSize", wireType)
			}
			m.CqWqeSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CqWqeSize |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumCqWqes", wireType)
			}
			m.NumCqWqes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumCqWqes |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostmemPgSize", wireType)
			}
			m.HostmemPgSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HostmemPgSize |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CqLkey", wireType)
			}
			m.CqLkey = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CqLkey |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EqId", wireType)
			}
			m.EqId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EqId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRdma(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRdma
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RdmaCqRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRdma
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RdmaCqRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RdmaCqRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRdma
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &RdmaCqSpec{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRdma(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRdma
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RdmaCqResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRdma
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RdmaCqResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RdmaCqResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRdma(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRdma
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RdmaCqResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRdma
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RdmaCqResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RdmaCqResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRdma
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &RdmaCqResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRdma(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRdma
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RdmaEqSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRdma
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RdmaEqSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RdmaEqSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRdma
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &ObjectMeta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EqId", wireType)
			}
			m.EqId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EqId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HwLifId", wireType)
			}
			m.HwLifId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HwLifId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EqWqeSize", wireType)
			}
			m.EqWqeSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EqWqeSize |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumEqWqes", wireType)
			}
			m.NumEqWqes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumEqWqes |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EqeBaseAddrPhy", wireType)
			}
			m.EqeBaseAddrPhy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EqeBaseAddrPhy |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IntNum", wireType)
			}
			m.IntNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IntNum |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRdma(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRdma
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RdmaEqRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRdma
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RdmaEqRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RdmaEqRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRdma
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &RdmaEqSpec{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRdma(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRdma
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RdmaEqResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRdma
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RdmaEqResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RdmaEqResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EqIntrTblAddr", wireType)
			}
			m.EqIntrTblAddr = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EqIntrTblAddr |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRdma(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRdma
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RdmaEqResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRdma
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RdmaEqResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RdmaEqResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRdma
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &RdmaEqResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRdma(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRdma
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RdmaMemRegSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRdma
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RdmaMemRegSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RdmaMemRegSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRdma
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &ObjectMeta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HwLifId", wireType)
			}
			m.HwLifId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HwLifId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pd", wireType)
			}
			m.Pd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pd |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Va", wireType)
			}
			m.Va = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Va |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Len", wireType)
			}
			m.Len = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Len |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AcLocalWr", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AcLocalWr = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AcRemoteWr", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AcRemoteWr = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AcRemoteRd", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AcRemoteRd = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AcRemoteAtomic", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AcRemoteAtomic = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lkey", wireType)
			}
			m.Lkey = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Lkey |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rkey", wireType)
			}
			m.Rkey = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rkey |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostmemPgSize", wireType)
			}
			m.HostmemPgSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HostmemPgSize |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OverrideLif", wireType)
			}
			m.OverrideLif = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OverrideLif |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OverrideLifVld", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OverrideLifVld = bool(v != 0)
		case 15:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRdma
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.VaPagesPhyAddr = append(m.VaPagesPhyAddr, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRdma
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthRdma
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRdma
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.VaPagesPhyAddr = append(m.VaPagesPhyAddr, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field VaPagesPhyAddr", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRdma(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRdma
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RdmaMemRegRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRdma
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RdmaMemRegRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RdmaMemRegRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRdma
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &RdmaMemRegSpec{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRdma(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRdma
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RdmaMemRegResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRdma
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RdmaMemRegResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RdmaMemRegResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRdma(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRdma
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RdmaMemRegResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRdma
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RdmaMemRegResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RdmaMemRegResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRdma
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &RdmaMemRegResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRdma(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRdma
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipRdma(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowRdma
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthRdma
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowRdma
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipRdma(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthRdma = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowRdma   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("rdma.proto", fileDescriptorRdma) }

var fileDescriptorRdma = []byte{
	// 1646 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x58, 0x4f, 0x53, 0xdb, 0x46,
	0x14, 0x47, 0xfe, 0xef, 0xb5, 0x31, 0x62, 0x13, 0xc0, 0x81, 0x84, 0x3a, 0x6e, 0x53, 0x28, 0x99,
	0xa1, 0x29, 0xed, 0xf4, 0xd8, 0x19, 0xc7, 0x56, 0x13, 0x1a, 0x4c, 0x8c, 0xec, 0x90, 0xa6, 0x97,
	0x9d, 0x45, 0x5a, 0x90, 0x12, 0xc9, 0x96, 0x76, 0x65, 0x33, 0xe4, 0x0b, 0xf4, 0x2b, 0xe4, 0x33,
	0xf4, 0xda, 0x2f, 0xd1, 0x63, 0x67, 0x7a, 0xec, 0xa5, 0x93, 0x5e, 0x7a, 0x6f, 0x8f, 0x3d, 0x74,
	0x76, 0x57, 0xb2, 0xe4, 0x3f, 0x4c, 0x80, 0x99, 0x9e, 0x58, 0xbd, 0xf7, 0xf3, 0xd3, 0xdb, 0xfd,
	0xfd, 0xf6, 0xbd, 0x27, 0x00, 0xa0, 0xa6, 0x8b, 0x77, 0x3d, 0x3a, 0x08, 0x06, 0x30, 0xc3, 0xd7,
	0xeb, 0xa5, 0xe0, 0xc2, 0x23, 0x4c, 0x9a, 0xea, 0x7f, 0x67, 0x00, 0xd0, 0x4d, 0x17, 0x1f, 0x79,
	0x5d, 0x8f, 0x18, 0xf0, 0x01, 0xc8, 0xb8, 0x24, 0xc0, 0x55, 0xa5, 0xa6, 0x6c, 0x97, 0xf6, 0x96,
	0x77, 0x25, 0xf4, 0xf9, 0xc9, 0x6b, 0x62, 0x04, 0x6d, 0x12, 0x60, 0x5d, 0xb8, 0xe1, 0x0a, 0xc8,
	0xf9, 0x1e, 0xea, 0x0f, 0xdd, 0x6a, 0xaa, 0xa6, 0x6c, 0x2f, 0xea, 0x59, 0xdf, 0x3b, 0x1c, 0xba,
	0x70, 0x1d, 0x14, 0xad, 0x73, 0xe4, 0xd8, 0xa7, 0xc8, 0x36, 0xab, 0x69, 0xe1, 0xc9, 0x5b, 0xe7,
	0x07, 0xf6, 0xe9, 0xbe, 0x09, 0x37, 0x41, 0x89, 0xf9, 0xe8, 0xdc, 0x27, 0x88, 0xd9, 0x6f, 0x49,
	0x35, 0x23, 0xbc, 0x45, 0xe6, 0xbf, 0xf4, 0x49, 0xd7, 0x7e, 0x4b, 0xb8, 0x9f, 0x26, 0xfc, 0x59,
	0xe9, 0xa7, 0x49, 0x7f, 0x7f, 0xe8, 0x22, 0x19, 0x83, 0x55, 0x73, 0xd2, 0xdf, 0x1f, 0xba, 0x5d,
	0x0e, 0x61, 0x91, 0x9f, 0x86, 0xfe, 0xfc, 0xd8, 0xaf, 0x4b, 0x7f, 0x0d, 0x94, 0x85, 0x3f, 0x0a,
	0x50, 0x10, 0x00, 0xc0, 0x01, 0x6c, 0x12, 0x11, 0x85, 0x28, 0xc6, 0x08, 0x2a, 0x11, 0x15, 0x90,
	0xf2, 0xcc, 0x2a, 0x10, 0xf6, 0x94, 0x67, 0x42, 0x08, 0x32, 0x9e, 0x1b, 0x0c, 0xab, 0x25, 0x61,
	0x11, 0x6b, 0xf8, 0x29, 0x58, 0xb2, 0x06, 0x2c, 0x70, 0x89, 0x8b, 0xbc, 0x33, 0xb9, 0x97, 0xb2,
	0x70, 0x2f, 0x86, 0xe6, 0xce, 0x99, 0xd8, 0xcf, 0x16, 0x48, 0xb3, 0x91, 0x51, 0x5d, 0xac, 0x29,
	0xdb, 0x95, 0xbd, 0x95, 0x5d, 0xc1, 0x12, 0x27, 0xa2, 0x4b, 0xe8, 0xc8, 0x36, 0x48, 0xef, 0xc2,
	0x23, 0x3a, 0x47, 0xc0, 0x07, 0xa0, 0x82, 0x83, 0x81, 0x6b, 0x1b, 0x88, 0xf4, 0xf1, 0x89, 0x43,
	0xcc, 0x6a, 0xa5, 0xa6, 0x6c, 0x17, 0xf4, 0x45, 0x69, 0xd5, 0xa4, 0x11, 0xae, 0x81, 0x3c, 0xf3,
	0x91, 0xf3, 0x86, 0x5c, 0x54, 0x97, 0xc4, 0xfb, 0x72, 0xcc, 0x3f, 0x78, 0x43, 0x2e, 0xb8, 0x83,
	0x86, 0x0e, 0x55, 0x3a, 0xa8, 0x74, 0xac, 0x83, 0x22, 0xf5, 0x91, 0xe1, 0x0b, 0x1e, 0x97, 0x25,
	0x5b, 0xd4, 0x6f, 0xfa, 0x21, 0x93, 0x6c, 0xec, 0x83, 0xd2, 0xc7, 0x42, 0xdf, 0x27, 0xa0, 0x62,
	0xbb, 0xae, 0x19, 0x20, 0xcc, 0x90, 0x79, 0x42, 0x1c, 0xa7, 0x7a, 0x4b, 0x24, 0x54, 0x16, 0xd6,
	0x06, 0x6b, 0x71, 0x1b, 0xdc, 0x00, 0x45, 0xfb, 0x14, 0x59, 0xb8, 0x6f, 0x3a, 0xa4, 0x7a, 0xbb,
	0xa6, 0x6c, 0xe7, 0xf4, 0x82, 0x7d, 0xfa, 0x54, 0x3c, 0xd7, 0xbf, 0x01, 0xaa, 0x14, 0x9d, 0x4e,
	0xfc, 0x21, 0x61, 0x41, 0x9b, 0x9d, 0xc1, 0x1d, 0x90, 0xa7, 0xf2, 0xa9, 0xaa, 0xd4, 0xd2, 0xdb,
	0xa5, 0x3d, 0x35, 0x3e, 0x14, 0xa9, 0x4e, 0x3d, 0x02, 0xd4, 0x7f, 0x56, 0x40, 0x25, 0x0a, 0xc0,
	0xbc, 0x41, 0x9f, 0x11, 0xf8, 0x39, 0x00, 0xd8, 0xb3, 0x11, 0x0b, 0x70, 0x30, 0x64, 0x42, 0xbf,
	0x95, 0x3d, 0x35, 0xd4, 0x6f, 0xc3, 0xb3, 0xbb, 0xc2, 0xae, 0x17, 0x71, 0xb4, 0x84, 0x75, 0xb0,
	0xc8, 0xc5, 0x70, 0x82, 0x19, 0x41, 0xd8, 0x34, 0x69, 0x28, 0xd8, 0x12, 0x65, 0xfe, 0x63, 0xcc,
	0x48, 0xc3, 0x34, 0xa9, 0xc0, 0xd0, 0x24, 0x26, 0x13, 0x62, 0x68, 0x8c, 0xd9, 0x06, 0xaa, 0x45,
	0xb0, 0x49, 0x28, 0x0a, 0x88, 0xeb, 0x49, 0x98, 0x54, 0x6f, 0x45, 0xda, 0x7b, 0xc4, 0xf5, 0x38,
	0xb2, 0xae, 0x81, 0xe5, 0xc9, 0xa4, 0xf9, 0xb6, 0x1f, 0x81, 0x02, 0x0d, 0x1f, 0xc3, 0x7d, 0xdf,
	0x4e, 0xee, 0x3b, 0x82, 0xea, 0x63, 0x54, 0xfd, 0x1f, 0x25, 0x3a, 0xbd, 0x17, 0x9e, 0x89, 0x03,
	0xf2, 0x3f, 0x5f, 0xdc, 0x1d, 0x90, 0x19, 0x78, 0x44, 0x6e, 0xbd, 0xb2, 0xb7, 0x9a, 0x4c, 0x4e,
	0xbe, 0xff, 0xb9, 0x47, 0xa8, 0x2e, 0x30, 0xf0, 0x2e, 0x00, 0x26, 0x0b, 0x50, 0xf8, 0x0a, 0x79,
	0x0a, 0x05, 0x93, 0x05, 0x47, 0xe2, 0x2d, 0x5b, 0x60, 0x29, 0x71, 0x52, 0x0e, 0x0e, 0x88, 0xb8,
	0xc6, 0xe5, 0xe4, 0x41, 0x71, 0x2b, 0xbc, 0x05, 0xb2, 0x3e, 0xe2, 0x82, 0x95, 0xb7, 0x38, 0xe3,
	0x3f, 0x23, 0x17, 0xf5, 0xef, 0xc0, 0x6a, 0xf2, 0xad, 0x09, 0xe5, 0x3c, 0x9a, 0x56, 0xce, 0x9c,
	0x24, 0x27, 0xf5, 0xf3, 0x04, 0xdc, 0x9e, 0x8c, 0x75, 0x43, 0x11, 0xd5, 0x8f, 0xc0, 0xda, 0xbc,
	0x40, 0x3c, 0xab, 0xaf, 0x67, 0x88, 0x5d, 0x9f, 0x4d, 0x6b, 0x0e, 0xbd, 0xef, 0xd2, 0xb2, 0x22,
	0x37, 0xac, 0xeb, 0x10, 0x0b, 0x41, 0x86, 0xb9, 0xd8, 0x10, 0xb4, 0x96, 0x75, 0xb1, 0xe6, 0x36,
	0x93, 0xdb, 0xd2, 0xd2, 0xc6, 0xd7, 0xb0, 0x0a, 0xf2, 0x24, 0xb0, 0x78, 0x90, 0x50, 0xcb, 0xd1,
	0x23, 0x47, 0x8f, 0x1c, 0xdc, 0x0f, 0x59, 0x13, 0x6b, 0x78, 0x07, 0x14, 0xf8, 0x5f, 0xe4, 0x51,
	0x3b, 0xac, 0xb8, 0x79, 0xfe, 0xdc, 0xa1, 0xf6, 0xd8, 0x65, 0x9c, 0xda, 0x21, 0x4d, 0xc2, 0xd5,
	0x3c, 0xb5, 0xb9, 0xc8, 0x6c, 0x0f, 0x8d, 0x08, 0x0d, 0x8b, 0x6c, 0xd6, 0xf6, 0x8e, 0x09, 0x0d,
	0xcd, 0xc1, 0x20, 0xaa, 0xac, 0x59, 0xdb, 0xeb, 0x0d, 0x58, 0x64, 0x0e, 0x9c, 0xb0, 0xb0, 0x72,
	0x73, 0xe0, 0xc0, 0x87, 0xa0, 0x60, 0x7b, 0x88, 0x89, 0xeb, 0x54, 0x12, 0x7b, 0x8f, 0x88, 0xd8,
	0xef, 0xf0, 0xdb, 0x44, 0x18, 0xd3, 0xf3, 0xb6, 0xd7, 0xe5, 0x80, 0x10, 0x6c, 0x0a, 0x70, 0xf9,
	0x72, 0x70, 0x4b, 0x80, 0x37, 0x40, 0x71, 0x68, 0x7a, 0x88, 0x79, 0x03, 0x1a, 0x88, 0xfa, 0xbb,
	0xa8, 0x17, 0x86, 0xa6, 0xd7, 0xe5, 0xcf, 0x91, 0xd3, 0x14, 0xce, 0xca, 0xd8, 0xd9, 0xe2, 0xcf,
	0x51, 0xd9, 0x6a, 0x58, 0x57, 0x2c, 0x5b, 0x92, 0xc2, 0x58, 0x76, 0xe7, 0xb2, 0x6a, 0xf1, 0xdf,
	0xdf, 0xb4, 0x6a, 0x6d, 0x80, 0x22, 0xb6, 0xa2, 0xb2, 0x2a, 0xef, 0x70, 0x01, 0x5b, 0xb2, 0xac,
	0xf2, 0x52, 0x8f, 0x2d, 0xd9, 0x73, 0xe4, 0x25, 0xce, 0x61, 0x8b, 0x37, 0x9b, 0xa8, 0xf2, 0xc4,
	0x2f, 0xfe, 0x60, 0xe5, 0x89, 0xa1, 0x09, 0x69, 0xfe, 0xab, 0x48, 0x69, 0x36, 0xfd, 0x6b, 0xd6,
	0x9c, 0xb0, 0x91, 0x84, 0x35, 0xc7, 0xf0, 0xaf, 0x30, 0x2c, 0x18, 0xb3, 0xc3, 0x82, 0x31, 0x3d,
	0x0c, 0x18, 0x61, 0xa7, 0xce, 0x8e, 0x9b, 0x7d, 0x53, 0x36, 0xea, 0x39, 0x4d, 0x38, 0x3f, 0xaf,
	0x09, 0xaf, 0x81, 0xbc, 0x11, 0xf6, 0x46, 0x29, 0xd5, 0x9c, 0x21, 0x7b, 0xe3, 0x2d, 0x90, 0x25,
	0x3e, 0x4f, 0x4c, 0x4a, 0x35, 0x43, 0xfc, 0x7d, 0x33, 0xa2, 0xbf, 0xe9, 0x5f, 0x91, 0x7e, 0x79,
	0x4c, 0x31, 0xfd, 0x0d, 0x49, 0x3f, 0xff, 0xfd, 0x4d, 0xeb, 0x4d, 0x48, 0x64, 0x1c, 0xe2, 0x83,
	0x44, 0xc6, 0xd0, 0x04, 0x91, 0x7f, 0x85, 0x44, 0x6a, 0xd7, 0x22, 0x72, 0x7c, 0x28, 0xa9, 0xf8,
	0x50, 0x3e, 0x44, 0x23, 0x99, 0xa5, 0x91, 0x4c, 0xd3, 0x48, 0x66, 0x68, 0xd4, 0x24, 0x8d, 0x9f,
	0x81, 0x65, 0xe2, 0x93, 0xb8, 0xfd, 0x22, 0xcf, 0xba, 0x10, 0x75, 0x28, 0xa3, 0x57, 0x88, 0x4f,
	0xa2, 0x16, 0xdc, 0xb1, 0xc4, 0x94, 0x63, 0xf7, 0x03, 0xa1, 0x32, 0xc9, 0x74, 0xce, 0xee, 0x07,
	0x87, 0x43, 0x37, 0x22, 0x4d, 0xbb, 0x2a, 0x69, 0xda, 0x14, 0x69, 0xaf, 0x25, 0x69, 0xda, 0xcd,
	0x49, 0x83, 0x5b, 0x40, 0xe5, 0xe7, 0xd6, 0x0f, 0x28, 0x0a, 0x4e, 0x1c, 0x39, 0x21, 0xc8, 0x23,
	0x5c, 0x24, 0xfe, 0x7e, 0x3f, 0xa0, 0xbd, 0x13, 0x27, 0x39, 0x20, 0x68, 0x57, 0x67, 0x57, 0x9b,
	0xc7, 0xee, 0xef, 0x69, 0x99, 0x73, 0x9b, 0xb8, 0x3a, 0x39, 0xbb, 0x0e, 0xc3, 0x13, 0x64, 0xa6,
	0xc4, 0x41, 0x8f, 0xc9, 0x94, 0xc3, 0x6f, 0x7a, 0x3c, 0xfc, 0x56, 0x40, 0x6a, 0x84, 0x05, 0xa7,
	0x19, 0x3d, 0x35, 0xc2, 0x50, 0x05, 0x69, 0x87, 0x44, 0xed, 0x83, 0x2f, 0x39, 0xbd, 0xd8, 0x40,
	0xce, 0xc0, 0xc0, 0x0e, 0x3a, 0xa7, 0x82, 0xb8, 0x82, 0x5e, 0xc4, 0xc6, 0x01, 0xb7, 0xbc, 0xa4,
	0x7c, 0xe0, 0xc6, 0x06, 0xa2, 0xc4, 0x1d, 0x04, 0x84, 0x03, 0xf2, 0x02, 0x00, 0xb0, 0xa1, 0x0b,
	0xd3, 0x34, 0x82, 0x9a, 0xe2, 0x92, 0x26, 0x10, 0xba, 0xc9, 0xa7, 0xaf, 0x18, 0x21, 0x27, 0x62,
	0x71, 0x67, 0x0b, 0x7a, 0x25, 0x42, 0x35, 0x84, 0x95, 0xf7, 0x37, 0x71, 0xd1, 0x65, 0x97, 0x11,
	0x6b, 0x6e, 0xa3, 0xdc, 0x16, 0x0e, 0xf0, 0x7c, 0x7d, 0xe5, 0x01, 0xfe, 0x3e, 0x28, 0x0f, 0x46,
	0x84, 0x52, 0xdb, 0x24, 0xfc, 0xc4, 0xc2, 0x4e, 0x52, 0x8a, 0x6c, 0x07, 0xf6, 0x29, 0x4f, 0x2e,
	0x09, 0x41, 0x23, 0x27, 0x1a, 0xde, 0x2b, 0x09, 0xd8, 0xb1, 0x63, 0x72, 0xa5, 0x8f, 0x30, 0xf2,
	0xf0, 0x19, 0x61, 0x5c, 0xe4, 0x52, 0x23, 0x4b, 0xb5, 0x34, 0x57, 0xfa, 0x08, 0x77, 0xb8, 0xbd,
	0x63, 0x5d, 0x08, 0x91, 0x7c, 0x2b, 0x67, 0x17, 0x49, 0x6e, 0x42, 0xd4, 0xbb, 0xd3, 0xa2, 0x4e,
	0xc8, 0x24, 0x56, 0x42, 0x2c, 0x6c, 0x0d, 0xc0, 0x64, 0x9c, 0x9b, 0x56, 0xa4, 0x36, 0x58, 0x99,
	0x0d, 0xc3, 0xf3, 0xf9, 0x6a, 0x46, 0xb7, 0xd5, 0xe9, 0x84, 0x66, 0xb5, 0xbb, 0xf3, 0x9b, 0x02,
	0x96, 0xa6, 0x3e, 0x83, 0xe0, 0x0a, 0x58, 0xd6, 0x5b, 0xed, 0x06, 0xea, 0x6a, 0xfa, 0x31, 0xea,
	0xbd, 0xea, 0x68, 0x48, 0x6f, 0xaa, 0x0b, 0x73, 0xcc, 0x2f, 0x9a, 0xaa, 0x32, 0x0f, 0xdd, 0x52,
	0x53, 0xf3, 0xd0, 0x2d, 0x35, 0x0d, 0x57, 0x01, 0x9c, 0x32, 0x37, 0x0f, 0x3b, 0x6a, 0x66, 0x8e,
	0xfd, 0x7b, 0xbd, 0xa9, 0x66, 0xe1, 0x1d, 0xb0, 0x32, 0x65, 0x3f, 0xd6, 0x0e, 0x5b, 0xe8, 0x0b,
	0x35, 0x77, 0x99, 0x6b, 0x4f, 0xcd, 0xef, 0xfc, 0x38, 0x35, 0xb2, 0xf3, 0x91, 0x19, 0x7e, 0x0c,
	0x3e, 0x12, 0xf8, 0x17, 0x9d, 0x56, 0xa3, 0xa7, 0xa1, 0xa3, 0x0e, 0x7a, 0xde, 0xd1, 0x74, 0xd4,
	0xd5, 0x7a, 0xa8, 0xa5, 0x75, 0x7b, 0xe8, 0xa8, 0xa3, 0x2e, 0xc0, 0x87, 0x60, 0xeb, 0x32, 0xd0,
	0x53, 0xad, 0xd1, 0xd2, 0x74, 0xd4, 0xd3, 0xda, 0x9d, 0x83, 0x46, 0x4f, 0x53, 0x15, 0x78, 0x1f,
	0xdc, 0xbb, 0x0c, 0x7c, 0x84, 0x9e, 0x69, 0xaf, 0xd4, 0xd4, 0xde, 0x4f, 0x69, 0x90, 0xe1, 0x99,
	0xc0, 0x06, 0x28, 0xcb, 0x8c, 0x9a, 0x94, 0xf0, 0x99, 0x7b, 0x75, 0xf2, 0xab, 0x23, 0x92, 0xd5,
	0xfa, 0xda, 0xbc, 0xaf, 0x91, 0x36, 0x3b, 0xab, 0x2f, 0xc0, 0x76, 0x14, 0x42, 0x6e, 0x0a, 0xde,
	0x9d, 0x37, 0xdf, 0x8e, 0x03, 0xdd, 0xbb, 0x7c, 0xfa, 0x95, 0xe1, 0xc2, 0x8c, 0x1a, 0xd6, 0x6c,
	0x46, 0xc9, 0x89, 0x2b, 0x99, 0xd1, 0xc4, 0x40, 0x13, 0x87, 0x68, 0xfa, 0xb3, 0x21, 0x92, 0x5d,
	0x3b, 0x19, 0x62, 0xa2, 0x95, 0xc6, 0x21, 0xb4, 0x39, 0x21, 0xb4, 0x4b, 0x42, 0x68, 0x53, 0x21,
	0x9e, 0xc8, 0xe6, 0x2a, 0x35, 0x0e, 0xd7, 0x67, 0x55, 0x3f, 0x0e, 0xb2, 0x71, 0xd9, 0x8d, 0x10,
	0x81, 0x1e, 0xaf, 0xff, 0xf2, 0x7e, 0x53, 0xf9, 0xf5, 0xfd, 0xa6, 0xf2, 0xc7, 0xfb, 0x4d, 0xe5,
	0xdd, 0x9f, 0x9b, 0x0b, 0x3f, 0x14, 0x2c, 0xec, 0x88, 0x7f, 0xdc, 0x9c, 0xe4, 0xc4, 0x9f, 0x2f,
	0xff, 0x0b, 0x00, 0x00, 0xff, 0xff, 0x25, 0xda, 0xa9, 0xdb, 0xe0, 0x11, 0x00, 0x00,
}
