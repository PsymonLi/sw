// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: nic/proto/hal/rdma.proto

package halproto

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// Ignoring public import of ObjectMeta from nic/proto/types.proto

// Ignoring public import of EncapInfo from nic/proto/types.proto

// Ignoring public import of IPAddress from nic/proto/types.proto

// Ignoring public import of IPPrefix from nic/proto/types.proto

// Ignoring public import of L4PortRange from nic/proto/types.proto

// Ignoring public import of Empty from nic/proto/types.proto

// Ignoring public import of IPProtocol from nic/proto/types.proto

// Ignoring public import of ICMPMsgType from nic/proto/types.proto

// Ignoring public import of ApiStatus from nic/proto/types.proto

// Ignoring public import of L2SegmentType from nic/proto/types.proto

// Ignoring public import of encapType from nic/proto/types.proto

// Ignoring public import of IPAddressFamily from nic/proto/types.proto

// Ignoring public import of WRingType from nic/proto/types.proto

// Ignoring public import of ProxyType from nic/proto/types.proto

// Ignoring public import of CryptoKeyType from nic/proto/types.proto

// types of interfaces
type RdmaServiceType int32

const (
	RdmaServiceType_RDMA_SERV_TYPE_RC     RdmaServiceType = 0
	RdmaServiceType_RDMA_SERV_TYPE_UC     RdmaServiceType = 1
	RdmaServiceType_RDMA_SERV_TYPE_RD     RdmaServiceType = 2
	RdmaServiceType_RDMA_SERV_TYPE_UD     RdmaServiceType = 3
	RdmaServiceType_RDMA_SERV_TYPE_CNP    RdmaServiceType = 4
	RdmaServiceType_RDMA_SERV_TYPE_XRC    RdmaServiceType = 5
	RdmaServiceType_RDMA_SERV_TYPE_VEND_1 RdmaServiceType = 6
	RdmaServiceType_RDMA_SERV_TYPE_VEND_2 RdmaServiceType = 7
)

var RdmaServiceType_name = map[int32]string{
	0: "RDMA_SERV_TYPE_RC",
	1: "RDMA_SERV_TYPE_UC",
	2: "RDMA_SERV_TYPE_RD",
	3: "RDMA_SERV_TYPE_UD",
	4: "RDMA_SERV_TYPE_CNP",
	5: "RDMA_SERV_TYPE_XRC",
	6: "RDMA_SERV_TYPE_VEND_1",
	7: "RDMA_SERV_TYPE_VEND_2",
}
var RdmaServiceType_value = map[string]int32{
	"RDMA_SERV_TYPE_RC":     0,
	"RDMA_SERV_TYPE_UC":     1,
	"RDMA_SERV_TYPE_RD":     2,
	"RDMA_SERV_TYPE_UD":     3,
	"RDMA_SERV_TYPE_CNP":    4,
	"RDMA_SERV_TYPE_XRC":    5,
	"RDMA_SERV_TYPE_VEND_1": 6,
	"RDMA_SERV_TYPE_VEND_2": 7,
}

func (x RdmaServiceType) String() string {
	return proto.EnumName(RdmaServiceType_name, int32(x))
}
func (RdmaServiceType) EnumDescriptor() ([]byte, []int) { return fileDescriptorRdma, []int{0} }

// **********************    Queue Pair  ********************************//
// RdmaQp object
type RdmaQpSpec struct {
	Meta          *ObjectMeta     `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	QpNum         uint32          `protobuf:"varint,2,opt,name=qp_num,json=qpNum,proto3" json:"qp_num,omitempty"`
	HwLifId       uint32          `protobuf:"varint,3,opt,name=hw_lif_id,json=hwLifId,proto3" json:"hw_lif_id,omitempty"`
	SqWqeSize     uint32          `protobuf:"varint,4,opt,name=sq_wqe_size,json=sqWqeSize,proto3" json:"sq_wqe_size,omitempty"`
	RqWqeSize     uint32          `protobuf:"varint,5,opt,name=rq_wqe_size,json=rqWqeSize,proto3" json:"rq_wqe_size,omitempty"`
	NumSqWqes     uint32          `protobuf:"varint,6,opt,name=num_sq_wqes,json=numSqWqes,proto3" json:"num_sq_wqes,omitempty"`
	NumRqWqes     uint32          `protobuf:"varint,7,opt,name=num_rq_wqes,json=numRqWqes,proto3" json:"num_rq_wqes,omitempty"`
	NumRsqWqes    uint32          `protobuf:"varint,8,opt,name=num_rsq_wqes,json=numRsqWqes,proto3" json:"num_rsq_wqes,omitempty"`
	NumRrqWqes    uint32          `protobuf:"varint,9,opt,name=num_rrq_wqes,json=numRrqWqes,proto3" json:"num_rrq_wqes,omitempty"`
	Pd            uint32          `protobuf:"varint,10,opt,name=pd,proto3" json:"pd,omitempty"`
	Pmtu          uint32          `protobuf:"varint,11,opt,name=pmtu,proto3" json:"pmtu,omitempty"`
	HostmemPgSize uint32          `protobuf:"varint,12,opt,name=hostmem_pg_size,json=hostmemPgSize,proto3" json:"hostmem_pg_size,omitempty"`
	Svc           RdmaServiceType `protobuf:"varint,13,opt,name=svc,proto3,enum=rdma.RdmaServiceType" json:"svc,omitempty"`
	AtomicEnabled bool            `protobuf:"varint,14,opt,name=atomic_enabled,json=atomicEnabled,proto3" json:"atomic_enabled,omitempty"`
	SqLkey        uint32          `protobuf:"varint,15,opt,name=sq_lkey,json=sqLkey,proto3" json:"sq_lkey,omitempty"`
	RqLkey        uint32          `protobuf:"varint,16,opt,name=rq_lkey,json=rqLkey,proto3" json:"rq_lkey,omitempty"`
	RqCqNum       uint32          `protobuf:"varint,17,opt,name=rq_cq_num,json=rqCqNum,proto3" json:"rq_cq_num,omitempty"`
	SqCqNum       uint32          `protobuf:"varint,18,opt,name=sq_cq_num,json=sqCqNum,proto3" json:"sq_cq_num,omitempty"`
}

func (m *RdmaQpSpec) Reset()                    { *m = RdmaQpSpec{} }
func (m *RdmaQpSpec) String() string            { return proto.CompactTextString(m) }
func (*RdmaQpSpec) ProtoMessage()               {}
func (*RdmaQpSpec) Descriptor() ([]byte, []int) { return fileDescriptorRdma, []int{0} }

func (m *RdmaQpSpec) GetMeta() *ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *RdmaQpSpec) GetQpNum() uint32 {
	if m != nil {
		return m.QpNum
	}
	return 0
}

func (m *RdmaQpSpec) GetHwLifId() uint32 {
	if m != nil {
		return m.HwLifId
	}
	return 0
}

func (m *RdmaQpSpec) GetSqWqeSize() uint32 {
	if m != nil {
		return m.SqWqeSize
	}
	return 0
}

func (m *RdmaQpSpec) GetRqWqeSize() uint32 {
	if m != nil {
		return m.RqWqeSize
	}
	return 0
}

func (m *RdmaQpSpec) GetNumSqWqes() uint32 {
	if m != nil {
		return m.NumSqWqes
	}
	return 0
}

func (m *RdmaQpSpec) GetNumRqWqes() uint32 {
	if m != nil {
		return m.NumRqWqes
	}
	return 0
}

func (m *RdmaQpSpec) GetNumRsqWqes() uint32 {
	if m != nil {
		return m.NumRsqWqes
	}
	return 0
}

func (m *RdmaQpSpec) GetNumRrqWqes() uint32 {
	if m != nil {
		return m.NumRrqWqes
	}
	return 0
}

func (m *RdmaQpSpec) GetPd() uint32 {
	if m != nil {
		return m.Pd
	}
	return 0
}

func (m *RdmaQpSpec) GetPmtu() uint32 {
	if m != nil {
		return m.Pmtu
	}
	return 0
}

func (m *RdmaQpSpec) GetHostmemPgSize() uint32 {
	if m != nil {
		return m.HostmemPgSize
	}
	return 0
}

func (m *RdmaQpSpec) GetSvc() RdmaServiceType {
	if m != nil {
		return m.Svc
	}
	return RdmaServiceType_RDMA_SERV_TYPE_RC
}

func (m *RdmaQpSpec) GetAtomicEnabled() bool {
	if m != nil {
		return m.AtomicEnabled
	}
	return false
}

func (m *RdmaQpSpec) GetSqLkey() uint32 {
	if m != nil {
		return m.SqLkey
	}
	return 0
}

func (m *RdmaQpSpec) GetRqLkey() uint32 {
	if m != nil {
		return m.RqLkey
	}
	return 0
}

func (m *RdmaQpSpec) GetRqCqNum() uint32 {
	if m != nil {
		return m.RqCqNum
	}
	return 0
}

func (m *RdmaQpSpec) GetSqCqNum() uint32 {
	if m != nil {
		return m.SqCqNum
	}
	return 0
}

// RdmaQpRequestMsg is batched request used to create/update of Rdma QPs
type RdmaQpRequestMsg struct {
	Request []*RdmaQpSpec `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *RdmaQpRequestMsg) Reset()                    { *m = RdmaQpRequestMsg{} }
func (m *RdmaQpRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*RdmaQpRequestMsg) ProtoMessage()               {}
func (*RdmaQpRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptorRdma, []int{1} }

func (m *RdmaQpRequestMsg) GetRequest() []*RdmaQpSpec {
	if m != nil {
		return m.Request
	}
	return nil
}

// RdmaQpResponse response to one RdmaQpSpec
type RdmaQpResponse struct {
	ApiStatus ApiStatus `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty"`
	// RdmaQpStatus        status           = 2;    // operational status
	RsqBaseAddr    uint32 `protobuf:"varint,3,opt,name=rsq_base_addr,json=rsqBaseAddr,proto3" json:"rsq_base_addr,omitempty"`
	RrqBaseAddr    uint32 `protobuf:"varint,4,opt,name=rrq_base_addr,json=rrqBaseAddr,proto3" json:"rrq_base_addr,omitempty"`
	HeaderTempAddr uint32 `protobuf:"varint,5,opt,name=header_temp_addr,json=headerTempAddr,proto3" json:"header_temp_addr,omitempty"`
}

func (m *RdmaQpResponse) Reset()                    { *m = RdmaQpResponse{} }
func (m *RdmaQpResponse) String() string            { return proto.CompactTextString(m) }
func (*RdmaQpResponse) ProtoMessage()               {}
func (*RdmaQpResponse) Descriptor() ([]byte, []int) { return fileDescriptorRdma, []int{2} }

func (m *RdmaQpResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *RdmaQpResponse) GetRsqBaseAddr() uint32 {
	if m != nil {
		return m.RsqBaseAddr
	}
	return 0
}

func (m *RdmaQpResponse) GetRrqBaseAddr() uint32 {
	if m != nil {
		return m.RrqBaseAddr
	}
	return 0
}

func (m *RdmaQpResponse) GetHeaderTempAddr() uint32 {
	if m != nil {
		return m.HeaderTempAddr
	}
	return 0
}

// RdmaQpResponseMsg is response to RdmaQpRequestMsg
type RdmaQpResponseMsg struct {
	Response []*RdmaQpResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *RdmaQpResponseMsg) Reset()                    { *m = RdmaQpResponseMsg{} }
func (m *RdmaQpResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*RdmaQpResponseMsg) ProtoMessage()               {}
func (*RdmaQpResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptorRdma, []int{3} }

func (m *RdmaQpResponseMsg) GetResponse() []*RdmaQpResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

// **********************   Completion Queue  *****************************//
// RdmaCq object
type RdmaCqSpec struct {
	Meta          *ObjectMeta `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	CqNum         uint32      `protobuf:"varint,2,opt,name=cq_num,json=cqNum,proto3" json:"cq_num,omitempty"`
	HwLifId       uint32      `protobuf:"varint,3,opt,name=hw_lif_id,json=hwLifId,proto3" json:"hw_lif_id,omitempty"`
	CqWqeSize     uint32      `protobuf:"varint,4,opt,name=cq_wqe_size,json=cqWqeSize,proto3" json:"cq_wqe_size,omitempty"`
	NumCqWqes     uint32      `protobuf:"varint,5,opt,name=num_cq_wqes,json=numCqWqes,proto3" json:"num_cq_wqes,omitempty"`
	HostmemPgSize uint32      `protobuf:"varint,7,opt,name=hostmem_pg_size,json=hostmemPgSize,proto3" json:"hostmem_pg_size,omitempty"`
	CqLkey        uint32      `protobuf:"varint,8,opt,name=cq_lkey,json=cqLkey,proto3" json:"cq_lkey,omitempty"`
	EqNum         uint32      `protobuf:"varint,9,opt,name=eq_num,json=eqNum,proto3" json:"eq_num,omitempty"`
}

func (m *RdmaCqSpec) Reset()                    { *m = RdmaCqSpec{} }
func (m *RdmaCqSpec) String() string            { return proto.CompactTextString(m) }
func (*RdmaCqSpec) ProtoMessage()               {}
func (*RdmaCqSpec) Descriptor() ([]byte, []int) { return fileDescriptorRdma, []int{4} }

func (m *RdmaCqSpec) GetMeta() *ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *RdmaCqSpec) GetCqNum() uint32 {
	if m != nil {
		return m.CqNum
	}
	return 0
}

func (m *RdmaCqSpec) GetHwLifId() uint32 {
	if m != nil {
		return m.HwLifId
	}
	return 0
}

func (m *RdmaCqSpec) GetCqWqeSize() uint32 {
	if m != nil {
		return m.CqWqeSize
	}
	return 0
}

func (m *RdmaCqSpec) GetNumCqWqes() uint32 {
	if m != nil {
		return m.NumCqWqes
	}
	return 0
}

func (m *RdmaCqSpec) GetHostmemPgSize() uint32 {
	if m != nil {
		return m.HostmemPgSize
	}
	return 0
}

func (m *RdmaCqSpec) GetCqLkey() uint32 {
	if m != nil {
		return m.CqLkey
	}
	return 0
}

func (m *RdmaCqSpec) GetEqNum() uint32 {
	if m != nil {
		return m.EqNum
	}
	return 0
}

// RdmaCqRequestMsg is batched request used to create/update of Rdma QPs
type RdmaCqRequestMsg struct {
	Request []*RdmaCqSpec `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *RdmaCqRequestMsg) Reset()                    { *m = RdmaCqRequestMsg{} }
func (m *RdmaCqRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*RdmaCqRequestMsg) ProtoMessage()               {}
func (*RdmaCqRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptorRdma, []int{5} }

func (m *RdmaCqRequestMsg) GetRequest() []*RdmaCqSpec {
	if m != nil {
		return m.Request
	}
	return nil
}

// RdmaCqResponse response to one RdmaCqSpec
type RdmaCqResponse struct {
	ApiStatus ApiStatus `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty"`
}

func (m *RdmaCqResponse) Reset()                    { *m = RdmaCqResponse{} }
func (m *RdmaCqResponse) String() string            { return proto.CompactTextString(m) }
func (*RdmaCqResponse) ProtoMessage()               {}
func (*RdmaCqResponse) Descriptor() ([]byte, []int) { return fileDescriptorRdma, []int{6} }

func (m *RdmaCqResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

// RdmaCqResponseMsg is response to RdmaCqRequestMsg
type RdmaCqResponseMsg struct {
	Response []*RdmaCqResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *RdmaCqResponseMsg) Reset()                    { *m = RdmaCqResponseMsg{} }
func (m *RdmaCqResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*RdmaCqResponseMsg) ProtoMessage()               {}
func (*RdmaCqResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptorRdma, []int{7} }

func (m *RdmaCqResponseMsg) GetResponse() []*RdmaCqResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

// **********************   Memory Registratin(MR)  *********************//
// RdmaMemReg object
type RdmaMemRegSpec struct {
	Meta           *ObjectMeta `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	HwLifId        uint64      `protobuf:"varint,2,opt,name=hw_lif_id,json=hwLifId,proto3" json:"hw_lif_id,omitempty"`
	Pd             uint32      `protobuf:"varint,3,opt,name=pd,proto3" json:"pd,omitempty"`
	Va             uint64      `protobuf:"varint,4,opt,name=va,proto3" json:"va,omitempty"`
	Len            uint32      `protobuf:"varint,5,opt,name=len,proto3" json:"len,omitempty"`
	AcLocalWr      bool        `protobuf:"varint,6,opt,name=ac_local_wr,json=acLocalWr,proto3" json:"ac_local_wr,omitempty"`
	AcRemoteWr     bool        `protobuf:"varint,7,opt,name=ac_remote_wr,json=acRemoteWr,proto3" json:"ac_remote_wr,omitempty"`
	AcRemoteRd     bool        `protobuf:"varint,8,opt,name=ac_remote_rd,json=acRemoteRd,proto3" json:"ac_remote_rd,omitempty"`
	AcRemoteAtomic bool        `protobuf:"varint,9,opt,name=ac_remote_atomic,json=acRemoteAtomic,proto3" json:"ac_remote_atomic,omitempty"`
	Lkey           uint32      `protobuf:"varint,10,opt,name=lkey,proto3" json:"lkey,omitempty"`
	Rkey           uint32      `protobuf:"varint,11,opt,name=rkey,proto3" json:"rkey,omitempty"`
	HostmemPgSize  uint32      `protobuf:"varint,12,opt,name=hostmem_pg_size,json=hostmemPgSize,proto3" json:"hostmem_pg_size,omitempty"`
	VaPagesPhyAddr []uint64    `protobuf:"varint,13,rep,packed,name=va_pages_phy_addr,json=vaPagesPhyAddr" json:"va_pages_phy_addr,omitempty"`
}

func (m *RdmaMemRegSpec) Reset()                    { *m = RdmaMemRegSpec{} }
func (m *RdmaMemRegSpec) String() string            { return proto.CompactTextString(m) }
func (*RdmaMemRegSpec) ProtoMessage()               {}
func (*RdmaMemRegSpec) Descriptor() ([]byte, []int) { return fileDescriptorRdma, []int{8} }

func (m *RdmaMemRegSpec) GetMeta() *ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *RdmaMemRegSpec) GetHwLifId() uint64 {
	if m != nil {
		return m.HwLifId
	}
	return 0
}

func (m *RdmaMemRegSpec) GetPd() uint32 {
	if m != nil {
		return m.Pd
	}
	return 0
}

func (m *RdmaMemRegSpec) GetVa() uint64 {
	if m != nil {
		return m.Va
	}
	return 0
}

func (m *RdmaMemRegSpec) GetLen() uint32 {
	if m != nil {
		return m.Len
	}
	return 0
}

func (m *RdmaMemRegSpec) GetAcLocalWr() bool {
	if m != nil {
		return m.AcLocalWr
	}
	return false
}

func (m *RdmaMemRegSpec) GetAcRemoteWr() bool {
	if m != nil {
		return m.AcRemoteWr
	}
	return false
}

func (m *RdmaMemRegSpec) GetAcRemoteRd() bool {
	if m != nil {
		return m.AcRemoteRd
	}
	return false
}

func (m *RdmaMemRegSpec) GetAcRemoteAtomic() bool {
	if m != nil {
		return m.AcRemoteAtomic
	}
	return false
}

func (m *RdmaMemRegSpec) GetLkey() uint32 {
	if m != nil {
		return m.Lkey
	}
	return 0
}

func (m *RdmaMemRegSpec) GetRkey() uint32 {
	if m != nil {
		return m.Rkey
	}
	return 0
}

func (m *RdmaMemRegSpec) GetHostmemPgSize() uint32 {
	if m != nil {
		return m.HostmemPgSize
	}
	return 0
}

func (m *RdmaMemRegSpec) GetVaPagesPhyAddr() []uint64 {
	if m != nil {
		return m.VaPagesPhyAddr
	}
	return nil
}

// RdmaMemRegRequestMsg is batched request used to create/update of Rdma QPs
type RdmaMemRegRequestMsg struct {
	Request []*RdmaMemRegSpec `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *RdmaMemRegRequestMsg) Reset()                    { *m = RdmaMemRegRequestMsg{} }
func (m *RdmaMemRegRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*RdmaMemRegRequestMsg) ProtoMessage()               {}
func (*RdmaMemRegRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptorRdma, []int{9} }

func (m *RdmaMemRegRequestMsg) GetRequest() []*RdmaMemRegSpec {
	if m != nil {
		return m.Request
	}
	return nil
}

// RdmaMemRegResponse response to one RdmaMemRegSpec
type RdmaMemRegResponse struct {
	ApiStatus ApiStatus `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty"`
}

func (m *RdmaMemRegResponse) Reset()                    { *m = RdmaMemRegResponse{} }
func (m *RdmaMemRegResponse) String() string            { return proto.CompactTextString(m) }
func (*RdmaMemRegResponse) ProtoMessage()               {}
func (*RdmaMemRegResponse) Descriptor() ([]byte, []int) { return fileDescriptorRdma, []int{10} }

func (m *RdmaMemRegResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

// RdmaMemRegResponseMsg is response to RdmaMemRegRequestMsg
type RdmaMemRegResponseMsg struct {
	Response []*RdmaMemRegResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *RdmaMemRegResponseMsg) Reset()                    { *m = RdmaMemRegResponseMsg{} }
func (m *RdmaMemRegResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*RdmaMemRegResponseMsg) ProtoMessage()               {}
func (*RdmaMemRegResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptorRdma, []int{11} }

func (m *RdmaMemRegResponseMsg) GetResponse() []*RdmaMemRegResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

func init() {
	proto.RegisterType((*RdmaQpSpec)(nil), "rdma.RdmaQpSpec")
	proto.RegisterType((*RdmaQpRequestMsg)(nil), "rdma.RdmaQpRequestMsg")
	proto.RegisterType((*RdmaQpResponse)(nil), "rdma.RdmaQpResponse")
	proto.RegisterType((*RdmaQpResponseMsg)(nil), "rdma.RdmaQpResponseMsg")
	proto.RegisterType((*RdmaCqSpec)(nil), "rdma.RdmaCqSpec")
	proto.RegisterType((*RdmaCqRequestMsg)(nil), "rdma.RdmaCqRequestMsg")
	proto.RegisterType((*RdmaCqResponse)(nil), "rdma.RdmaCqResponse")
	proto.RegisterType((*RdmaCqResponseMsg)(nil), "rdma.RdmaCqResponseMsg")
	proto.RegisterType((*RdmaMemRegSpec)(nil), "rdma.RdmaMemRegSpec")
	proto.RegisterType((*RdmaMemRegRequestMsg)(nil), "rdma.RdmaMemRegRequestMsg")
	proto.RegisterType((*RdmaMemRegResponse)(nil), "rdma.RdmaMemRegResponse")
	proto.RegisterType((*RdmaMemRegResponseMsg)(nil), "rdma.RdmaMemRegResponseMsg")
	proto.RegisterEnum("rdma.RdmaServiceType", RdmaServiceType_name, RdmaServiceType_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Rdma service

type RdmaClient interface {
	// Queue Pair related APIs
	RdmaQpCreate(ctx context.Context, in *RdmaQpRequestMsg, opts ...grpc.CallOption) (*RdmaQpResponseMsg, error)
	RdmaQpUpdate(ctx context.Context, in *RdmaQpRequestMsg, opts ...grpc.CallOption) (*RdmaQpResponseMsg, error)
	// Completion Q related APIs
	RdmaCqCreate(ctx context.Context, in *RdmaCqRequestMsg, opts ...grpc.CallOption) (*RdmaCqResponseMsg, error)
	// Register Memory related APIs
	RdmaMemReg(ctx context.Context, in *RdmaMemRegRequestMsg, opts ...grpc.CallOption) (*RdmaMemRegResponseMsg, error)
}

type rdmaClient struct {
	cc *grpc.ClientConn
}

func NewRdmaClient(cc *grpc.ClientConn) RdmaClient {
	return &rdmaClient{cc}
}

func (c *rdmaClient) RdmaQpCreate(ctx context.Context, in *RdmaQpRequestMsg, opts ...grpc.CallOption) (*RdmaQpResponseMsg, error) {
	out := new(RdmaQpResponseMsg)
	err := grpc.Invoke(ctx, "/rdma.Rdma/RdmaQpCreate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rdmaClient) RdmaQpUpdate(ctx context.Context, in *RdmaQpRequestMsg, opts ...grpc.CallOption) (*RdmaQpResponseMsg, error) {
	out := new(RdmaQpResponseMsg)
	err := grpc.Invoke(ctx, "/rdma.Rdma/RdmaQpUpdate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rdmaClient) RdmaCqCreate(ctx context.Context, in *RdmaCqRequestMsg, opts ...grpc.CallOption) (*RdmaCqResponseMsg, error) {
	out := new(RdmaCqResponseMsg)
	err := grpc.Invoke(ctx, "/rdma.Rdma/RdmaCqCreate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rdmaClient) RdmaMemReg(ctx context.Context, in *RdmaMemRegRequestMsg, opts ...grpc.CallOption) (*RdmaMemRegResponseMsg, error) {
	out := new(RdmaMemRegResponseMsg)
	err := grpc.Invoke(ctx, "/rdma.Rdma/RdmaMemReg", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Rdma service

type RdmaServer interface {
	// Queue Pair related APIs
	RdmaQpCreate(context.Context, *RdmaQpRequestMsg) (*RdmaQpResponseMsg, error)
	RdmaQpUpdate(context.Context, *RdmaQpRequestMsg) (*RdmaQpResponseMsg, error)
	// Completion Q related APIs
	RdmaCqCreate(context.Context, *RdmaCqRequestMsg) (*RdmaCqResponseMsg, error)
	// Register Memory related APIs
	RdmaMemReg(context.Context, *RdmaMemRegRequestMsg) (*RdmaMemRegResponseMsg, error)
}

func RegisterRdmaServer(s *grpc.Server, srv RdmaServer) {
	s.RegisterService(&_Rdma_serviceDesc, srv)
}

func _Rdma_RdmaQpCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RdmaQpRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RdmaServer).RdmaQpCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rdma.Rdma/RdmaQpCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RdmaServer).RdmaQpCreate(ctx, req.(*RdmaQpRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Rdma_RdmaQpUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RdmaQpRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RdmaServer).RdmaQpUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rdma.Rdma/RdmaQpUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RdmaServer).RdmaQpUpdate(ctx, req.(*RdmaQpRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Rdma_RdmaCqCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RdmaCqRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RdmaServer).RdmaCqCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rdma.Rdma/RdmaCqCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RdmaServer).RdmaCqCreate(ctx, req.(*RdmaCqRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Rdma_RdmaMemReg_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RdmaMemRegRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RdmaServer).RdmaMemReg(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rdma.Rdma/RdmaMemReg",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RdmaServer).RdmaMemReg(ctx, req.(*RdmaMemRegRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

var _Rdma_serviceDesc = grpc.ServiceDesc{
	ServiceName: "rdma.Rdma",
	HandlerType: (*RdmaServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RdmaQpCreate",
			Handler:    _Rdma_RdmaQpCreate_Handler,
		},
		{
			MethodName: "RdmaQpUpdate",
			Handler:    _Rdma_RdmaQpUpdate_Handler,
		},
		{
			MethodName: "RdmaCqCreate",
			Handler:    _Rdma_RdmaCqCreate_Handler,
		},
		{
			MethodName: "RdmaMemReg",
			Handler:    _Rdma_RdmaMemReg_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "nic/proto/hal/rdma.proto",
}

func (m *RdmaQpSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RdmaQpSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.Meta.Size()))
		n1, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.QpNum != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.QpNum))
	}
	if m.HwLifId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.HwLifId))
	}
	if m.SqWqeSize != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.SqWqeSize))
	}
	if m.RqWqeSize != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.RqWqeSize))
	}
	if m.NumSqWqes != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.NumSqWqes))
	}
	if m.NumRqWqes != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.NumRqWqes))
	}
	if m.NumRsqWqes != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.NumRsqWqes))
	}
	if m.NumRrqWqes != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.NumRrqWqes))
	}
	if m.Pd != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.Pd))
	}
	if m.Pmtu != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.Pmtu))
	}
	if m.HostmemPgSize != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.HostmemPgSize))
	}
	if m.Svc != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.Svc))
	}
	if m.AtomicEnabled {
		dAtA[i] = 0x70
		i++
		if m.AtomicEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.SqLkey != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.SqLkey))
	}
	if m.RqLkey != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.RqLkey))
	}
	if m.RqCqNum != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.RqCqNum))
	}
	if m.SqCqNum != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.SqCqNum))
	}
	return i, nil
}

func (m *RdmaQpRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RdmaQpRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintRdma(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *RdmaQpResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RdmaQpResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.ApiStatus))
	}
	if m.RsqBaseAddr != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.RsqBaseAddr))
	}
	if m.RrqBaseAddr != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.RrqBaseAddr))
	}
	if m.HeaderTempAddr != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.HeaderTempAddr))
	}
	return i, nil
}

func (m *RdmaQpResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RdmaQpResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintRdma(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *RdmaCqSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RdmaCqSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.Meta.Size()))
		n2, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.CqNum != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.CqNum))
	}
	if m.HwLifId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.HwLifId))
	}
	if m.CqWqeSize != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.CqWqeSize))
	}
	if m.NumCqWqes != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.NumCqWqes))
	}
	if m.HostmemPgSize != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.HostmemPgSize))
	}
	if m.CqLkey != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.CqLkey))
	}
	if m.EqNum != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.EqNum))
	}
	return i, nil
}

func (m *RdmaCqRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RdmaCqRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintRdma(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *RdmaCqResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RdmaCqResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.ApiStatus))
	}
	return i, nil
}

func (m *RdmaCqResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RdmaCqResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintRdma(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *RdmaMemRegSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RdmaMemRegSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.Meta.Size()))
		n3, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.HwLifId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.HwLifId))
	}
	if m.Pd != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.Pd))
	}
	if m.Va != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.Va))
	}
	if m.Len != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.Len))
	}
	if m.AcLocalWr {
		dAtA[i] = 0x30
		i++
		if m.AcLocalWr {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.AcRemoteWr {
		dAtA[i] = 0x38
		i++
		if m.AcRemoteWr {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.AcRemoteRd {
		dAtA[i] = 0x40
		i++
		if m.AcRemoteRd {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.AcRemoteAtomic {
		dAtA[i] = 0x48
		i++
		if m.AcRemoteAtomic {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Lkey != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.Lkey))
	}
	if m.Rkey != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.Rkey))
	}
	if m.HostmemPgSize != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.HostmemPgSize))
	}
	if len(m.VaPagesPhyAddr) > 0 {
		dAtA5 := make([]byte, len(m.VaPagesPhyAddr)*10)
		var j4 int
		for _, num := range m.VaPagesPhyAddr {
			for num >= 1<<7 {
				dAtA5[j4] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j4++
			}
			dAtA5[j4] = uint8(num)
			j4++
		}
		dAtA[i] = 0x6a
		i++
		i = encodeVarintRdma(dAtA, i, uint64(j4))
		i += copy(dAtA[i:], dAtA5[:j4])
	}
	return i, nil
}

func (m *RdmaMemRegRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RdmaMemRegRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintRdma(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *RdmaMemRegResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RdmaMemRegResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRdma(dAtA, i, uint64(m.ApiStatus))
	}
	return i, nil
}

func (m *RdmaMemRegResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RdmaMemRegResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintRdma(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func encodeFixed64Rdma(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Rdma(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintRdma(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *RdmaQpSpec) Size() (n int) {
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovRdma(uint64(l))
	}
	if m.QpNum != 0 {
		n += 1 + sovRdma(uint64(m.QpNum))
	}
	if m.HwLifId != 0 {
		n += 1 + sovRdma(uint64(m.HwLifId))
	}
	if m.SqWqeSize != 0 {
		n += 1 + sovRdma(uint64(m.SqWqeSize))
	}
	if m.RqWqeSize != 0 {
		n += 1 + sovRdma(uint64(m.RqWqeSize))
	}
	if m.NumSqWqes != 0 {
		n += 1 + sovRdma(uint64(m.NumSqWqes))
	}
	if m.NumRqWqes != 0 {
		n += 1 + sovRdma(uint64(m.NumRqWqes))
	}
	if m.NumRsqWqes != 0 {
		n += 1 + sovRdma(uint64(m.NumRsqWqes))
	}
	if m.NumRrqWqes != 0 {
		n += 1 + sovRdma(uint64(m.NumRrqWqes))
	}
	if m.Pd != 0 {
		n += 1 + sovRdma(uint64(m.Pd))
	}
	if m.Pmtu != 0 {
		n += 1 + sovRdma(uint64(m.Pmtu))
	}
	if m.HostmemPgSize != 0 {
		n += 1 + sovRdma(uint64(m.HostmemPgSize))
	}
	if m.Svc != 0 {
		n += 1 + sovRdma(uint64(m.Svc))
	}
	if m.AtomicEnabled {
		n += 2
	}
	if m.SqLkey != 0 {
		n += 1 + sovRdma(uint64(m.SqLkey))
	}
	if m.RqLkey != 0 {
		n += 2 + sovRdma(uint64(m.RqLkey))
	}
	if m.RqCqNum != 0 {
		n += 2 + sovRdma(uint64(m.RqCqNum))
	}
	if m.SqCqNum != 0 {
		n += 2 + sovRdma(uint64(m.SqCqNum))
	}
	return n
}

func (m *RdmaQpRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovRdma(uint64(l))
		}
	}
	return n
}

func (m *RdmaQpResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovRdma(uint64(m.ApiStatus))
	}
	if m.RsqBaseAddr != 0 {
		n += 1 + sovRdma(uint64(m.RsqBaseAddr))
	}
	if m.RrqBaseAddr != 0 {
		n += 1 + sovRdma(uint64(m.RrqBaseAddr))
	}
	if m.HeaderTempAddr != 0 {
		n += 1 + sovRdma(uint64(m.HeaderTempAddr))
	}
	return n
}

func (m *RdmaQpResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovRdma(uint64(l))
		}
	}
	return n
}

func (m *RdmaCqSpec) Size() (n int) {
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovRdma(uint64(l))
	}
	if m.CqNum != 0 {
		n += 1 + sovRdma(uint64(m.CqNum))
	}
	if m.HwLifId != 0 {
		n += 1 + sovRdma(uint64(m.HwLifId))
	}
	if m.CqWqeSize != 0 {
		n += 1 + sovRdma(uint64(m.CqWqeSize))
	}
	if m.NumCqWqes != 0 {
		n += 1 + sovRdma(uint64(m.NumCqWqes))
	}
	if m.HostmemPgSize != 0 {
		n += 1 + sovRdma(uint64(m.HostmemPgSize))
	}
	if m.CqLkey != 0 {
		n += 1 + sovRdma(uint64(m.CqLkey))
	}
	if m.EqNum != 0 {
		n += 1 + sovRdma(uint64(m.EqNum))
	}
	return n
}

func (m *RdmaCqRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovRdma(uint64(l))
		}
	}
	return n
}

func (m *RdmaCqResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovRdma(uint64(m.ApiStatus))
	}
	return n
}

func (m *RdmaCqResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovRdma(uint64(l))
		}
	}
	return n
}

func (m *RdmaMemRegSpec) Size() (n int) {
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovRdma(uint64(l))
	}
	if m.HwLifId != 0 {
		n += 1 + sovRdma(uint64(m.HwLifId))
	}
	if m.Pd != 0 {
		n += 1 + sovRdma(uint64(m.Pd))
	}
	if m.Va != 0 {
		n += 1 + sovRdma(uint64(m.Va))
	}
	if m.Len != 0 {
		n += 1 + sovRdma(uint64(m.Len))
	}
	if m.AcLocalWr {
		n += 2
	}
	if m.AcRemoteWr {
		n += 2
	}
	if m.AcRemoteRd {
		n += 2
	}
	if m.AcRemoteAtomic {
		n += 2
	}
	if m.Lkey != 0 {
		n += 1 + sovRdma(uint64(m.Lkey))
	}
	if m.Rkey != 0 {
		n += 1 + sovRdma(uint64(m.Rkey))
	}
	if m.HostmemPgSize != 0 {
		n += 1 + sovRdma(uint64(m.HostmemPgSize))
	}
	if len(m.VaPagesPhyAddr) > 0 {
		l = 0
		for _, e := range m.VaPagesPhyAddr {
			l += sovRdma(uint64(e))
		}
		n += 1 + sovRdma(uint64(l)) + l
	}
	return n
}

func (m *RdmaMemRegRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovRdma(uint64(l))
		}
	}
	return n
}

func (m *RdmaMemRegResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovRdma(uint64(m.ApiStatus))
	}
	return n
}

func (m *RdmaMemRegResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovRdma(uint64(l))
		}
	}
	return n
}

func sovRdma(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozRdma(x uint64) (n int) {
	return sovRdma(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *RdmaQpSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRdma
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RdmaQpSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RdmaQpSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRdma
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &ObjectMeta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field QpNum", wireType)
			}
			m.QpNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.QpNum |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HwLifId", wireType)
			}
			m.HwLifId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HwLifId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SqWqeSize", wireType)
			}
			m.SqWqeSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SqWqeSize |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RqWqeSize", wireType)
			}
			m.RqWqeSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RqWqeSize |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumSqWqes", wireType)
			}
			m.NumSqWqes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumSqWqes |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumRqWqes", wireType)
			}
			m.NumRqWqes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumRqWqes |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumRsqWqes", wireType)
			}
			m.NumRsqWqes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumRsqWqes |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumRrqWqes", wireType)
			}
			m.NumRrqWqes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumRrqWqes |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pd", wireType)
			}
			m.Pd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pd |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pmtu", wireType)
			}
			m.Pmtu = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pmtu |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostmemPgSize", wireType)
			}
			m.HostmemPgSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HostmemPgSize |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Svc", wireType)
			}
			m.Svc = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Svc |= (RdmaServiceType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AtomicEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AtomicEnabled = bool(v != 0)
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SqLkey", wireType)
			}
			m.SqLkey = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SqLkey |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RqLkey", wireType)
			}
			m.RqLkey = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RqLkey |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RqCqNum", wireType)
			}
			m.RqCqNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RqCqNum |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SqCqNum", wireType)
			}
			m.SqCqNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SqCqNum |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRdma(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRdma
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RdmaQpRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRdma
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RdmaQpRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RdmaQpRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRdma
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &RdmaQpSpec{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRdma(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRdma
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RdmaQpResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRdma
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RdmaQpResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RdmaQpResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RsqBaseAddr", wireType)
			}
			m.RsqBaseAddr = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RsqBaseAddr |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RrqBaseAddr", wireType)
			}
			m.RrqBaseAddr = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RrqBaseAddr |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeaderTempAddr", wireType)
			}
			m.HeaderTempAddr = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HeaderTempAddr |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRdma(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRdma
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RdmaQpResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRdma
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RdmaQpResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RdmaQpResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRdma
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &RdmaQpResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRdma(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRdma
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RdmaCqSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRdma
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RdmaCqSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RdmaCqSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRdma
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &ObjectMeta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CqNum", wireType)
			}
			m.CqNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CqNum |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HwLifId", wireType)
			}
			m.HwLifId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HwLifId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CqWqeSize", wireType)
			}
			m.CqWqeSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CqWqeSize |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumCqWqes", wireType)
			}
			m.NumCqWqes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumCqWqes |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostmemPgSize", wireType)
			}
			m.HostmemPgSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HostmemPgSize |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CqLkey", wireType)
			}
			m.CqLkey = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CqLkey |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EqNum", wireType)
			}
			m.EqNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EqNum |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRdma(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRdma
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RdmaCqRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRdma
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RdmaCqRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RdmaCqRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRdma
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &RdmaCqSpec{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRdma(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRdma
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RdmaCqResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRdma
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RdmaCqResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RdmaCqResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRdma(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRdma
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RdmaCqResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRdma
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RdmaCqResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RdmaCqResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRdma
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &RdmaCqResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRdma(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRdma
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RdmaMemRegSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRdma
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RdmaMemRegSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RdmaMemRegSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRdma
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &ObjectMeta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HwLifId", wireType)
			}
			m.HwLifId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HwLifId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pd", wireType)
			}
			m.Pd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pd |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Va", wireType)
			}
			m.Va = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Va |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Len", wireType)
			}
			m.Len = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Len |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AcLocalWr", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AcLocalWr = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AcRemoteWr", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AcRemoteWr = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AcRemoteRd", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AcRemoteRd = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AcRemoteAtomic", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AcRemoteAtomic = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lkey", wireType)
			}
			m.Lkey = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Lkey |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rkey", wireType)
			}
			m.Rkey = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rkey |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostmemPgSize", wireType)
			}
			m.HostmemPgSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HostmemPgSize |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRdma
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.VaPagesPhyAddr = append(m.VaPagesPhyAddr, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRdma
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthRdma
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRdma
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.VaPagesPhyAddr = append(m.VaPagesPhyAddr, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field VaPagesPhyAddr", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRdma(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRdma
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RdmaMemRegRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRdma
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RdmaMemRegRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RdmaMemRegRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRdma
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &RdmaMemRegSpec{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRdma(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRdma
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RdmaMemRegResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRdma
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RdmaMemRegResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RdmaMemRegResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRdma(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRdma
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RdmaMemRegResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRdma
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RdmaMemRegResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RdmaMemRegResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRdma
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &RdmaMemRegResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRdma(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRdma
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipRdma(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowRdma
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRdma
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthRdma
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowRdma
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipRdma(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthRdma = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowRdma   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("nic/proto/hal/rdma.proto", fileDescriptorRdma) }

var fileDescriptorRdma = []byte{
	// 1012 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x56, 0xdf, 0x6e, 0xdb, 0xb6,
	0x1b, 0x8d, 0x6c, 0xc5, 0x7f, 0xbe, 0xc4, 0x8e, 0x42, 0xd4, 0x8d, 0x7e, 0xfe, 0x01, 0x81, 0x61,
	0xa0, 0x9b, 0xd7, 0x8b, 0x64, 0xf3, 0x76, 0x3d, 0xc0, 0x55, 0xbc, 0x61, 0x40, 0x9c, 0x79, 0x74,
	0xda, 0x6e, 0xbb, 0x21, 0x18, 0x89, 0xb5, 0xb5, 0x5a, 0xb6, 0x44, 0xca, 0x0e, 0xdc, 0x87, 0xd8,
	0x75, 0x1f, 0x63, 0xc0, 0x5e, 0x62, 0x97, 0x03, 0xf6, 0x02, 0x43, 0xf6, 0x1e, 0xc3, 0x40, 0x52,
	0xb2, 0x14, 0xdb, 0xc5, 0xd2, 0xee, 0x8e, 0x3a, 0xe7, 0xf4, 0x2b, 0x99, 0x73, 0xbe, 0x93, 0x80,
	0x3d, 0xf3, 0xdd, 0xf3, 0x90, 0xcf, 0xe3, 0xf9, 0xf9, 0x84, 0x4e, 0xcf, 0xb9, 0x17, 0xd0, 0x33,
	0xf5, 0x89, 0x4c, 0x79, 0x6e, 0x36, 0x32, 0x3e, 0x5e, 0x85, 0x4c, 0x68, 0xb2, 0xfd, 0x8b, 0x09,
	0x80, 0xbd, 0x80, 0x7e, 0x17, 0x8e, 0x42, 0xe6, 0xa2, 0x27, 0x60, 0x06, 0x2c, 0xa6, 0xb6, 0xd1,
	0x32, 0x3a, 0x07, 0xdd, 0xe3, 0x33, 0x2d, 0xfd, 0xf6, 0xe6, 0x27, 0xe6, 0xc6, 0x03, 0x16, 0x53,
	0xac, 0x68, 0xd4, 0x80, 0x52, 0x14, 0x92, 0xd9, 0x22, 0xb0, 0x0b, 0x2d, 0xa3, 0x53, 0xc3, 0xfb,
	0x51, 0x78, 0xb5, 0x08, 0x50, 0x13, 0xaa, 0x93, 0x5b, 0x32, 0xf5, 0x5f, 0x11, 0xdf, 0xb3, 0x8b,
	0x8a, 0x29, 0x4f, 0x6e, 0x2f, 0xfd, 0x57, 0xdf, 0x78, 0xe8, 0x14, 0x0e, 0x44, 0x44, 0x6e, 0x23,
	0x46, 0x84, 0xff, 0x86, 0xd9, 0xa6, 0x62, 0xab, 0x22, 0x7a, 0x19, 0xb1, 0x91, 0xff, 0x86, 0x49,
	0x9e, 0xe7, 0xf8, 0x7d, 0xcd, 0xf3, 0x3c, 0x3f, 0x5b, 0x04, 0x44, 0xcf, 0x10, 0x76, 0x49, 0xf3,
	0xb3, 0x45, 0x30, 0x92, 0x12, 0x91, 0xf2, 0x3c, 0xe1, 0xcb, 0x6b, 0x1e, 0x6b, 0xbe, 0x05, 0x87,
	0x8a, 0x4f, 0x07, 0x54, 0x94, 0x00, 0xa4, 0x40, 0xdc, 0x57, 0xa4, 0x23, 0xaa, 0x99, 0x82, 0x6b,
	0x45, 0x1d, 0x0a, 0xa1, 0x67, 0x83, 0xc2, 0x0b, 0xa1, 0x87, 0x10, 0x98, 0x61, 0x10, 0x2f, 0xec,
	0x03, 0x85, 0xa8, 0x33, 0xfa, 0x08, 0x8e, 0x26, 0x73, 0x11, 0x07, 0x2c, 0x20, 0xe1, 0x58, 0xbf,
	0xe5, 0x50, 0xd1, 0xb5, 0x04, 0x1e, 0x8e, 0xd5, 0x7b, 0x3e, 0x86, 0xa2, 0x58, 0xba, 0x76, 0xad,
	0x65, 0x74, 0xea, 0xdd, 0xc6, 0x99, 0xf2, 0x4b, 0x1a, 0x31, 0x62, 0x7c, 0xe9, 0xbb, 0xec, 0x7a,
	0x15, 0x32, 0x2c, 0x15, 0xe8, 0x09, 0xd4, 0x69, 0x3c, 0x0f, 0x7c, 0x97, 0xb0, 0x19, 0xbd, 0x99,
	0x32, 0xcf, 0xae, 0xb7, 0x8c, 0x4e, 0x05, 0xd7, 0x34, 0xda, 0xd7, 0x20, 0x3a, 0x81, 0xb2, 0x88,
	0xc8, 0xf4, 0x35, 0x5b, 0xd9, 0x47, 0xea, 0xff, 0x2b, 0x89, 0xe8, 0xf2, 0x35, 0x5b, 0x49, 0x82,
	0x27, 0x84, 0xa5, 0x09, 0xae, 0x89, 0x26, 0x54, 0x79, 0x44, 0xdc, 0x48, 0xf9, 0x78, 0xac, 0xdd,
	0xe2, 0x91, 0x13, 0x25, 0x4e, 0x8a, 0x35, 0x87, 0x34, 0x27, 0x34, 0xd7, 0xfe, 0x12, 0x2c, 0x9d,
	0x18, 0xcc, 0xa2, 0x05, 0x13, 0xf1, 0x40, 0x8c, 0xd1, 0x53, 0x28, 0x73, 0xfd, 0x65, 0x1b, 0xad,
	0x62, 0xe7, 0xa0, 0x6b, 0x65, 0x2f, 0xd2, 0xd1, 0xc2, 0xa9, 0xa0, 0xfd, 0xab, 0x01, 0xf5, 0x74,
	0x80, 0x08, 0xe7, 0x33, 0xc1, 0xd0, 0x39, 0x00, 0x0d, 0x7d, 0x22, 0x62, 0x1a, 0x2f, 0x84, 0x0a,
	0x5f, 0xbd, 0x6b, 0x25, 0xe1, 0xeb, 0x85, 0xfe, 0x48, 0xe1, 0xb8, 0x4a, 0xd3, 0x23, 0x6a, 0x43,
	0x4d, 0x3a, 0x79, 0x43, 0x05, 0x23, 0xd4, 0xf3, 0x78, 0x92, 0xb6, 0x03, 0x2e, 0xa2, 0x67, 0x54,
	0xb0, 0x9e, 0xe7, 0x71, 0xa5, 0xe1, 0x79, 0x8d, 0x99, 0x68, 0x78, 0xa6, 0xe9, 0x80, 0x35, 0x61,
	0xd4, 0x63, 0x9c, 0xc4, 0x2c, 0x08, 0xb5, 0x4c, 0x47, 0xaf, 0xae, 0xf1, 0x6b, 0x16, 0x84, 0x52,
	0xd9, 0xee, 0xc3, 0xf1, 0xfd, 0x4b, 0xcb, 0x67, 0x7f, 0x0a, 0x15, 0x9e, 0x7c, 0x26, 0xef, 0x7e,
	0x94, 0x7f, 0x77, 0x2a, 0xc5, 0x6b, 0x55, 0xfb, 0x6f, 0x43, 0xef, 0x9b, 0x13, 0xbd, 0xe7, 0xbe,
	0x25, 0x5e, 0x24, 0xfb, 0xe6, 0x46, 0x0f, 0xd8, 0x37, 0x77, 0x7b, 0xdf, 0xdc, 0xcd, 0x7d, 0x72,
	0x93, 0xb0, 0xef, 0xaf, 0xf7, 0xc5, 0xd1, 0x59, 0xdf, 0x91, 0xe3, 0xf2, 0xae, 0x1c, 0x9f, 0x40,
	0xd9, 0x4d, 0xe2, 0xa5, 0x57, 0xaa, 0xe4, 0xea, 0x78, 0x35, 0xa0, 0xc4, 0xf4, 0x9d, 0xf5, 0x22,
	0xed, 0xb3, 0x7c, 0x7a, 0x9c, 0xe8, 0x81, 0xe9, 0xd1, 0x3f, 0xa8, 0x2c, 0x3d, 0x3d, 0x1d, 0x1e,
	0xf9, 0xef, 0x3f, 0x30, 0x3c, 0xa9, 0x95, 0xd9, 0x88, 0x7f, 0xb5, 0x32, 0x93, 0xe6, 0xac, 0xfc,
	0xb9, 0xa8, 0xaf, 0x32, 0x60, 0x01, 0x66, 0xe3, 0xf7, 0xb1, 0xf3, 0x9e, 0x6f, 0xd2, 0x51, 0x33,
	0xf3, 0x4d, 0x77, 0x4c, 0x71, 0xdd, 0x31, 0x75, 0x28, 0x2c, 0xa9, 0xb2, 0xcf, 0xc4, 0x85, 0x25,
	0x45, 0x16, 0x14, 0xa7, 0x6c, 0x96, 0xf8, 0x25, 0x8f, 0xd2, 0x49, 0xea, 0x92, 0xe9, 0xdc, 0xa5,
	0x53, 0x72, 0xcb, 0x55, 0x33, 0x56, 0x70, 0x95, 0xba, 0x97, 0x12, 0x79, 0xc9, 0x65, 0xaf, 0x51,
	0x97, 0x70, 0x16, 0xcc, 0x63, 0x26, 0x05, 0x65, 0x25, 0x00, 0xea, 0x62, 0x05, 0x6d, 0x2a, 0xb8,
	0xa7, 0x8c, 0xcc, 0x29, 0xb0, 0x27, 0xf7, 0x24, 0x53, 0xe8, 0xe2, 0x51, 0xb6, 0x56, 0x70, 0x3d,
	0x55, 0xf5, 0x14, 0x2a, 0x3b, 0x51, 0x85, 0x41, 0xb7, 0xa4, 0x3a, 0x4b, 0x8c, 0x4b, 0x2c, 0xe9,
	0x49, 0x79, 0x7e, 0x70, 0x4f, 0x7e, 0x02, 0xc7, 0x4b, 0x4a, 0x42, 0x3a, 0x66, 0x82, 0x84, 0x93,
	0x95, 0x5e, 0xd1, 0x5a, 0xab, 0xd8, 0x31, 0x71, 0x7d, 0x49, 0x87, 0x12, 0x1f, 0x4e, 0x56, 0x6a,
	0x45, 0xbf, 0x82, 0x47, 0x99, 0x1f, 0xb9, 0x78, 0x9d, 0x6d, 0xc6, 0x2b, 0xe7, 0x6c, 0x66, 0x5e,
	0x16, 0xb1, 0x3e, 0xa0, 0xfc, 0x9c, 0x0f, 0x8d, 0xd9, 0x00, 0x1a, 0xdb, 0x63, 0xe4, 0x7d, 0xbe,
	0xd8, 0x8a, 0x9a, 0xbd, 0x79, 0xa1, 0xed, 0xb8, 0x3d, 0xfd, 0xc3, 0x80, 0xa3, 0x8d, 0x5f, 0x10,
	0xa8, 0x01, 0xc7, 0xf8, 0x62, 0xd0, 0x23, 0xa3, 0x3e, 0x7e, 0x41, 0xae, 0x7f, 0x18, 0xf6, 0x09,
	0x76, 0xac, 0xbd, 0x1d, 0xf0, 0x73, 0xc7, 0x32, 0x76, 0xa9, 0x2f, 0xac, 0xc2, 0x2e, 0xf5, 0x85,
	0x55, 0x44, 0x8f, 0x01, 0x6d, 0xc0, 0xce, 0xd5, 0xd0, 0x32, 0x77, 0xe0, 0xdf, 0x63, 0xc7, 0xda,
	0x47, 0xff, 0x83, 0xc6, 0x06, 0xfe, 0xa2, 0x7f, 0x75, 0x41, 0x3e, 0xb3, 0x4a, 0xef, 0xa2, 0xba,
	0x56, 0xb9, 0xfb, 0xb6, 0x00, 0xa6, 0x7c, 0x15, 0xea, 0xc1, 0xa1, 0x2e, 0x4d, 0x87, 0x33, 0x1a,
	0x33, 0xf4, 0xf8, 0x7e, 0x91, 0xa6, 0x66, 0x36, 0x4f, 0x76, 0x15, 0xec, 0x40, 0x8c, 0xdb, 0x7b,
	0xd9, 0x88, 0xe7, 0xa1, 0xf7, 0xdf, 0x46, 0x38, 0xd1, 0xf6, 0x2d, 0xf2, 0x8d, 0x95, 0x1f, 0x71,
	0xaf, 0x46, 0xda, 0x7b, 0xe8, 0x6b, 0x5d, 0xf0, 0xda, 0x47, 0xd4, 0xdc, 0x76, 0x76, 0x3d, 0xe4,
	0xff, 0xef, 0x72, 0x5d, 0x0d, 0x7a, 0xd6, 0xfc, 0xed, 0xee, 0xd4, 0xf8, 0xfd, 0xee, 0xd4, 0xf8,
	0xf3, 0xee, 0xd4, 0x78, 0xfb, 0xd7, 0xe9, 0xde, 0x8f, 0x95, 0x09, 0x9d, 0xaa, 0x3f, 0xdb, 0x86,
	0x7b, 0x37, 0x25, 0x75, 0xf8, 0xfc, 0x9f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x21, 0x41, 0xa3, 0xed,
	0xf8, 0x09, 0x00, 0x00,
}
