// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: telemetry.proto

package halproto

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// ExportFormat is a enumeration of export formats supported
type ExportFormat int32

const (
	ExportFormat_IPFIX     ExportFormat = 0
	ExportFormat_NETFLOWV9 ExportFormat = 1
)

var ExportFormat_name = map[int32]string{
	0: "IPFIX",
	1: "NETFLOWV9",
}
var ExportFormat_value = map[string]int32{
	"IPFIX":     0,
	"NETFLOWV9": 1,
}

func (x ExportFormat) String() string {
	return proto.EnumName(ExportFormat_name, int32(x))
}
func (ExportFormat) EnumDescriptor() ([]byte, []int) { return fileDescriptorTelemetry, []int{0} }

// RuleAction is an enumeration of support telemetry actions
type RuleAction int32

const (
	RuleAction_COLLECT_FLOW_STATS RuleAction = 0
	RuleAction_MIRROR             RuleAction = 1
)

var RuleAction_name = map[int32]string{
	0: "COLLECT_FLOW_STATS",
	1: "MIRROR",
}
var RuleAction_value = map[string]int32{
	"COLLECT_FLOW_STATS": 0,
	"MIRROR":             1,
}

func (x RuleAction) String() string {
	return proto.EnumName(RuleAction_name, int32(x))
}
func (RuleAction) EnumDescriptor() ([]byte, []int) { return fileDescriptorTelemetry, []int{1} }

// AggregationScheme is an enumeration of aggregation schemes supported
type AggregationScheme int32

const (
	AggregationScheme_NONE             AggregationScheme = 0
	AggregationScheme_IPSOURCE         AggregationScheme = 1
	AggregationScheme_IPDESTINATION    AggregationScheme = 2
	AggregationScheme_IPPAIR           AggregationScheme = 3
	AggregationScheme_SOURCE_PORT      AggregationScheme = 4
	AggregationScheme_DESTINATION_PORT AggregationScheme = 5
	AggregationScheme_SERVICE          AggregationScheme = 6
	AggregationScheme_IPPAIR_SERVICE   AggregationScheme = 7
	AggregationScheme_SOURCE_SEC_GROUP AggregationScheme = 8
	AggregationScheme_DEST_SEC_GROUP   AggregationScheme = 9
	AggregationScheme_SEC_GROUP_PAIR   AggregationScheme = 10
)

var AggregationScheme_name = map[int32]string{
	0:  "NONE",
	1:  "IPSOURCE",
	2:  "IPDESTINATION",
	3:  "IPPAIR",
	4:  "SOURCE_PORT",
	5:  "DESTINATION_PORT",
	6:  "SERVICE",
	7:  "IPPAIR_SERVICE",
	8:  "SOURCE_SEC_GROUP",
	9:  "DEST_SEC_GROUP",
	10: "SEC_GROUP_PAIR",
}
var AggregationScheme_value = map[string]int32{
	"NONE":             0,
	"IPSOURCE":         1,
	"IPDESTINATION":    2,
	"IPPAIR":           3,
	"SOURCE_PORT":      4,
	"DESTINATION_PORT": 5,
	"SERVICE":          6,
	"IPPAIR_SERVICE":   7,
	"SOURCE_SEC_GROUP": 8,
	"DEST_SEC_GROUP":   9,
	"SEC_GROUP_PAIR":   10,
}

func (x AggregationScheme) String() string {
	return proto.EnumName(AggregationScheme_name, int32(x))
}
func (AggregationScheme) EnumDescriptor() ([]byte, []int) { return fileDescriptorTelemetry, []int{2} }

// CollectorStatus Codes
type CollectorStatus_CollectorStatusCode int32

const (
	CollectorStatus_SUCCESS        CollectorStatus_CollectorStatusCode = 0
	CollectorStatus_INVALID_CONFIG CollectorStatus_CollectorStatusCode = 1
	CollectorStatus_TEMP_FAILURE   CollectorStatus_CollectorStatusCode = 2
	CollectorStatus_PERM_FAILURE   CollectorStatus_CollectorStatusCode = 3
)

var CollectorStatus_CollectorStatusCode_name = map[int32]string{
	0: "SUCCESS",
	1: "INVALID_CONFIG",
	2: "TEMP_FAILURE",
	3: "PERM_FAILURE",
}
var CollectorStatus_CollectorStatusCode_value = map[string]int32{
	"SUCCESS":        0,
	"INVALID_CONFIG": 1,
	"TEMP_FAILURE":   2,
	"PERM_FAILURE":   3,
}

func (x CollectorStatus_CollectorStatusCode) String() string {
	return proto.EnumName(CollectorStatus_CollectorStatusCode_name, int32(x))
}
func (CollectorStatus_CollectorStatusCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorTelemetry, []int{3, 0}
}

// Export control status codes
type ExportControlStatus_ExportControlStatusCode int32

const (
	ExportControlStatus_SUCCESS        ExportControlStatus_ExportControlStatusCode = 0
	ExportControlStatus_INVALID_CONFIG ExportControlStatus_ExportControlStatusCode = 1
	ExportControlStatus_TEMP_FAILURE   ExportControlStatus_ExportControlStatusCode = 2
	ExportControlStatus_PERM_FAILURE   ExportControlStatus_ExportControlStatusCode = 3
)

var ExportControlStatus_ExportControlStatusCode_name = map[int32]string{
	0: "SUCCESS",
	1: "INVALID_CONFIG",
	2: "TEMP_FAILURE",
	3: "PERM_FAILURE",
}
var ExportControlStatus_ExportControlStatusCode_value = map[string]int32{
	"SUCCESS":        0,
	"INVALID_CONFIG": 1,
	"TEMP_FAILURE":   2,
	"PERM_FAILURE":   3,
}

func (x ExportControlStatus_ExportControlStatusCode) String() string {
	return proto.EnumName(ExportControlStatus_ExportControlStatusCode_name, int32(x))
}
func (ExportControlStatus_ExportControlStatusCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorTelemetry, []int{9, 0}
}

// FlowMonitorRule status codes
type FlowMonitorRuleStatus_FlowMonitorRuleStatusCode int32

const (
	FlowMonitorRuleStatus_SUCCESS        FlowMonitorRuleStatus_FlowMonitorRuleStatusCode = 0
	FlowMonitorRuleStatus_INVALID_CONFIG FlowMonitorRuleStatus_FlowMonitorRuleStatusCode = 1
	FlowMonitorRuleStatus_TEMP_FAILURE   FlowMonitorRuleStatus_FlowMonitorRuleStatusCode = 2
	FlowMonitorRuleStatus_PERM_FAILURE   FlowMonitorRuleStatus_FlowMonitorRuleStatusCode = 3
)

var FlowMonitorRuleStatus_FlowMonitorRuleStatusCode_name = map[int32]string{
	0: "SUCCESS",
	1: "INVALID_CONFIG",
	2: "TEMP_FAILURE",
	3: "PERM_FAILURE",
}
var FlowMonitorRuleStatus_FlowMonitorRuleStatusCode_value = map[string]int32{
	"SUCCESS":        0,
	"INVALID_CONFIG": 1,
	"TEMP_FAILURE":   2,
	"PERM_FAILURE":   3,
}

func (x FlowMonitorRuleStatus_FlowMonitorRuleStatusCode) String() string {
	return proto.EnumName(FlowMonitorRuleStatus_FlowMonitorRuleStatusCode_name, int32(x))
}
func (FlowMonitorRuleStatus_FlowMonitorRuleStatusCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorTelemetry, []int{15, 0}
}

// Mirror Session  status codes
type MirrorSessionStatus_MirrorSessionStatusCode int32

const (
	MirrorSessionStatus_SUCCESS        MirrorSessionStatus_MirrorSessionStatusCode = 0
	MirrorSessionStatus_INVALID_CONFIG MirrorSessionStatus_MirrorSessionStatusCode = 1
	MirrorSessionStatus_TEMP_FAILURE   MirrorSessionStatus_MirrorSessionStatusCode = 2
	MirrorSessionStatus_PERM_FAILURE   MirrorSessionStatus_MirrorSessionStatusCode = 3
)

var MirrorSessionStatus_MirrorSessionStatusCode_name = map[int32]string{
	0: "SUCCESS",
	1: "INVALID_CONFIG",
	2: "TEMP_FAILURE",
	3: "PERM_FAILURE",
}
var MirrorSessionStatus_MirrorSessionStatusCode_value = map[string]int32{
	"SUCCESS":        0,
	"INVALID_CONFIG": 1,
	"TEMP_FAILURE":   2,
	"PERM_FAILURE":   3,
}

func (x MirrorSessionStatus_MirrorSessionStatusCode) String() string {
	return proto.EnumName(MirrorSessionStatus_MirrorSessionStatusCode_name, int32(x))
}
func (MirrorSessionStatus_MirrorSessionStatusCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorTelemetry, []int{23, 0}
}

// L4Port is a representation of the L4 port defined as a nested type for nullability
type L4Port struct {
	Port uint32 `protobuf:"varint,1,opt,name=port,proto3" json:"port,omitempty"`
}

func (m *L4Port) Reset()                    { *m = L4Port{} }
func (m *L4Port) String() string            { return proto.CompactTextString(m) }
func (*L4Port) ProtoMessage()               {}
func (*L4Port) Descriptor() ([]byte, []int) { return fileDescriptorTelemetry, []int{0} }

func (m *L4Port) GetPort() uint32 {
	if m != nil {
		return m.Port
	}
	return 0
}

// MacAddress is a represenation of the MAC address defined as a nested type for nullability
type MacAddress struct {
	Address uint64 `protobuf:"varint,1,opt,name=address,proto3" json:"address,omitempty"`
}

func (m *MacAddress) Reset()                    { *m = MacAddress{} }
func (m *MacAddress) String() string            { return proto.CompactTextString(m) }
func (*MacAddress) ProtoMessage()               {}
func (*MacAddress) Descriptor() ([]byte, []int) { return fileDescriptorTelemetry, []int{1} }

func (m *MacAddress) GetAddress() uint64 {
	if m != nil {
		return m.Address
	}
	return 0
}

// CollectorSpec is the configuration specification for a telemetry collector
type CollectorSpec struct {
	Meta            *ObjectMeta      `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	ExportControlId *ExportControlId `protobuf:"bytes,2,opt,name=export_controlId,json=exportControlId" json:"export_controlId,omitempty"`
	Encap           *EncapInfo       `protobuf:"bytes,3,opt,name=encap" json:"encap,omitempty"`
	L2SegHandle     uint64           `protobuf:"fixed64,4,opt,name=l2seg_handle,json=l2segHandle,proto3" json:"l2seg_handle,omitempty"`
	DestIp          *IPAddress       `protobuf:"bytes,5,opt,name=dest_ip,json=destIp" json:"dest_ip,omitempty"`
	SrcIp           *IPAddress       `protobuf:"bytes,6,opt,name=src_ip,json=srcIp" json:"src_ip,omitempty"`
	Protocol        IPProtocol       `protobuf:"varint,7,opt,name=protocol,proto3,enum=types.IPProtocol" json:"protocol,omitempty"`
	DestPort        *L4Port          `protobuf:"bytes,8,opt,name=dest_port,json=destPort" json:"dest_port,omitempty"`
	Format          ExportFormat     `protobuf:"varint,9,opt,name=format,proto3,enum=telemetry.ExportFormat" json:"format,omitempty"`
	TemplateId      uint32           `protobuf:"varint,10,opt,name=template_id,json=templateId,proto3" json:"template_id,omitempty"`
}

func (m *CollectorSpec) Reset()                    { *m = CollectorSpec{} }
func (m *CollectorSpec) String() string            { return proto.CompactTextString(m) }
func (*CollectorSpec) ProtoMessage()               {}
func (*CollectorSpec) Descriptor() ([]byte, []int) { return fileDescriptorTelemetry, []int{2} }

func (m *CollectorSpec) GetMeta() *ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *CollectorSpec) GetExportControlId() *ExportControlId {
	if m != nil {
		return m.ExportControlId
	}
	return nil
}

func (m *CollectorSpec) GetEncap() *EncapInfo {
	if m != nil {
		return m.Encap
	}
	return nil
}

func (m *CollectorSpec) GetL2SegHandle() uint64 {
	if m != nil {
		return m.L2SegHandle
	}
	return 0
}

func (m *CollectorSpec) GetDestIp() *IPAddress {
	if m != nil {
		return m.DestIp
	}
	return nil
}

func (m *CollectorSpec) GetSrcIp() *IPAddress {
	if m != nil {
		return m.SrcIp
	}
	return nil
}

func (m *CollectorSpec) GetProtocol() IPProtocol {
	if m != nil {
		return m.Protocol
	}
	return IPProtocol_IPPROTO_NONE
}

func (m *CollectorSpec) GetDestPort() *L4Port {
	if m != nil {
		return m.DestPort
	}
	return nil
}

func (m *CollectorSpec) GetFormat() ExportFormat {
	if m != nil {
		return m.Format
	}
	return ExportFormat_IPFIX
}

func (m *CollectorSpec) GetTemplateId() uint32 {
	if m != nil {
		return m.TemplateId
	}
	return 0
}

// CollectorSpec is the operational status of the collector
type CollectorStatus struct {
	Code   CollectorStatus_CollectorStatusCode `protobuf:"varint,1,opt,name=code,proto3,enum=telemetry.CollectorStatus_CollectorStatusCode" json:"code,omitempty"`
	Status string                              `protobuf:"bytes,2,opt,name=status,proto3" json:"status,omitempty"`
}

func (m *CollectorStatus) Reset()                    { *m = CollectorStatus{} }
func (m *CollectorStatus) String() string            { return proto.CompactTextString(m) }
func (*CollectorStatus) ProtoMessage()               {}
func (*CollectorStatus) Descriptor() ([]byte, []int) { return fileDescriptorTelemetry, []int{3} }

func (m *CollectorStatus) GetCode() CollectorStatus_CollectorStatusCode {
	if m != nil {
		return m.Code
	}
	return CollectorStatus_SUCCESS
}

func (m *CollectorStatus) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

// Collector is a container that holds both the configuration and the operational
//  state of the collector
type Collector struct {
	ApiStatus ApiStatus        `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty"`
	Spec      *CollectorSpec   `protobuf:"bytes,2,opt,name=spec" json:"spec,omitempty"`
	Status    *CollectorStatus `protobuf:"bytes,3,opt,name=status" json:"status,omitempty"`
}

func (m *Collector) Reset()                    { *m = Collector{} }
func (m *Collector) String() string            { return proto.CompactTextString(m) }
func (*Collector) ProtoMessage()               {}
func (*Collector) Descriptor() ([]byte, []int) { return fileDescriptorTelemetry, []int{4} }

func (m *Collector) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *Collector) GetSpec() *CollectorSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *Collector) GetStatus() *CollectorStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

// CollectorConfigsMsg is used in requests and is a batchable request message
type CollectorConfigMsg struct {
	Request []*CollectorSpec `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *CollectorConfigMsg) Reset()                    { *m = CollectorConfigMsg{} }
func (m *CollectorConfigMsg) String() string            { return proto.CompactTextString(m) }
func (*CollectorConfigMsg) ProtoMessage()               {}
func (*CollectorConfigMsg) Descriptor() ([]byte, []int) { return fileDescriptorTelemetry, []int{5} }

func (m *CollectorConfigMsg) GetRequest() []*CollectorSpec {
	if m != nil {
		return m.Request
	}
	return nil
}

// CollectorConfigsMsg message is used as response for API requests.
type CollectorResponseMsg struct {
	Status   ApiStatus    `protobuf:"varint,1,opt,name=status,proto3,enum=types.ApiStatus" json:"status,omitempty"`
	Response []*Collector `protobuf:"bytes,2,rep,name=response" json:"response,omitempty"`
}

func (m *CollectorResponseMsg) Reset()                    { *m = CollectorResponseMsg{} }
func (m *CollectorResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*CollectorResponseMsg) ProtoMessage()               {}
func (*CollectorResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptorTelemetry, []int{6} }

func (m *CollectorResponseMsg) GetStatus() ApiStatus {
	if m != nil {
		return m.Status
	}
	return ApiStatus_API_STATUS_OK
}

func (m *CollectorResponseMsg) GetResponse() []*Collector {
	if m != nil {
		return m.Response
	}
	return nil
}

// ExportControlId is a identifier for a ExportControl configuration
type ExportControlId struct {
	Meta *ObjectMeta `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	Id   uint64      `protobuf:"varint,2,opt,name=Id,proto3" json:"Id,omitempty"`
}

func (m *ExportControlId) Reset()                    { *m = ExportControlId{} }
func (m *ExportControlId) String() string            { return proto.CompactTextString(m) }
func (*ExportControlId) ProtoMessage()               {}
func (*ExportControlId) Descriptor() ([]byte, []int) { return fileDescriptorTelemetry, []int{7} }

func (m *ExportControlId) GetMeta() *ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *ExportControlId) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

// ExportControlId is the configuration specification for Export Control
type ExportControlSpec struct {
	Id              *ExportControlId `protobuf:"bytes,1,opt,name=Id" json:"Id,omitempty"`
	ActiveTimeout   uint32           `protobuf:"varint,2,opt,name=active_timeout,json=activeTimeout,proto3" json:"active_timeout,omitempty"`
	InactiveTimeout uint32           `protobuf:"varint,3,opt,name=inactive_timeout,json=inactiveTimeout,proto3" json:"inactive_timeout,omitempty"`
}

func (m *ExportControlSpec) Reset()                    { *m = ExportControlSpec{} }
func (m *ExportControlSpec) String() string            { return proto.CompactTextString(m) }
func (*ExportControlSpec) ProtoMessage()               {}
func (*ExportControlSpec) Descriptor() ([]byte, []int) { return fileDescriptorTelemetry, []int{8} }

func (m *ExportControlSpec) GetId() *ExportControlId {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *ExportControlSpec) GetActiveTimeout() uint32 {
	if m != nil {
		return m.ActiveTimeout
	}
	return 0
}

func (m *ExportControlSpec) GetInactiveTimeout() uint32 {
	if m != nil {
		return m.InactiveTimeout
	}
	return 0
}

// ExportControlStatus is the operational status of the Export Control configuration
type ExportControlStatus struct {
	Code   ExportControlStatus_ExportControlStatusCode `protobuf:"varint,1,opt,name=code,proto3,enum=telemetry.ExportControlStatus_ExportControlStatusCode" json:"code,omitempty"`
	Status string                                      `protobuf:"bytes,2,opt,name=status,proto3" json:"status,omitempty"`
}

func (m *ExportControlStatus) Reset()                    { *m = ExportControlStatus{} }
func (m *ExportControlStatus) String() string            { return proto.CompactTextString(m) }
func (*ExportControlStatus) ProtoMessage()               {}
func (*ExportControlStatus) Descriptor() ([]byte, []int) { return fileDescriptorTelemetry, []int{9} }

func (m *ExportControlStatus) GetCode() ExportControlStatus_ExportControlStatusCode {
	if m != nil {
		return m.Code
	}
	return ExportControlStatus_SUCCESS
}

func (m *ExportControlStatus) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

// ExportControl is a container for the configuration and the operational status for ExportControl
type ExportControl struct {
	Spec   *ExportControlSpec   `protobuf:"bytes,1,opt,name=spec" json:"spec,omitempty"`
	Status *ExportControlStatus `protobuf:"bytes,2,opt,name=status" json:"status,omitempty"`
}

func (m *ExportControl) Reset()                    { *m = ExportControl{} }
func (m *ExportControl) String() string            { return proto.CompactTextString(m) }
func (*ExportControl) ProtoMessage()               {}
func (*ExportControl) Descriptor() ([]byte, []int) { return fileDescriptorTelemetry, []int{10} }

func (m *ExportControl) GetSpec() *ExportControlSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *ExportControl) GetStatus() *ExportControlStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

// ExportControlConfigMsg is used as input to RPC call for ExportControl. It is a batchable message
type ExportControlConfigMsg struct {
	Configs []*ExportControlSpec `protobuf:"bytes,1,rep,name=configs" json:"configs,omitempty"`
}

func (m *ExportControlConfigMsg) Reset()                    { *m = ExportControlConfigMsg{} }
func (m *ExportControlConfigMsg) String() string            { return proto.CompactTextString(m) }
func (*ExportControlConfigMsg) ProtoMessage()               {}
func (*ExportControlConfigMsg) Descriptor() ([]byte, []int) { return fileDescriptorTelemetry, []int{11} }

func (m *ExportControlConfigMsg) GetConfigs() []*ExportControlSpec {
	if m != nil {
		return m.Configs
	}
	return nil
}

// ExportControlResponseMsg is used in responses for operations on the ExportControl configuration.
type ExportControlResponseMsg struct {
	Status        ApiStatus        `protobuf:"varint,1,opt,name=status,proto3,enum=types.ApiStatus" json:"status,omitempty"`
	ExportControl []*ExportControl `protobuf:"bytes,2,rep,name=export_control,json=exportControl" json:"export_control,omitempty"`
}

func (m *ExportControlResponseMsg) Reset()         { *m = ExportControlResponseMsg{} }
func (m *ExportControlResponseMsg) String() string { return proto.CompactTextString(m) }
func (*ExportControlResponseMsg) ProtoMessage()    {}
func (*ExportControlResponseMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorTelemetry, []int{12}
}

func (m *ExportControlResponseMsg) GetStatus() ApiStatus {
	if m != nil {
		return m.Status
	}
	return ApiStatus_API_STATUS_OK
}

func (m *ExportControlResponseMsg) GetExportControl() []*ExportControl {
	if m != nil {
		return m.ExportControl
	}
	return nil
}

// MonitorAction defines the action for a flow monitor rule
type MonitorAction struct {
	Action             []RuleAction        `protobuf:"varint,1,rep,packed,name=action,enum=telemetry.RuleAction" json:"action,omitempty"`
	AggScheme          []AggregationScheme `protobuf:"varint,2,rep,packed,name=agg_scheme,json=aggScheme,enum=telemetry.AggregationScheme" json:"agg_scheme,omitempty"`
	MirrorDestinations []uint32            `protobuf:"varint,3,rep,packed,name=mirror_destinations,json=mirrorDestinations" json:"mirror_destinations,omitempty"`
}

func (m *MonitorAction) Reset()                    { *m = MonitorAction{} }
func (m *MonitorAction) String() string            { return proto.CompactTextString(m) }
func (*MonitorAction) ProtoMessage()               {}
func (*MonitorAction) Descriptor() ([]byte, []int) { return fileDescriptorTelemetry, []int{13} }

func (m *MonitorAction) GetAction() []RuleAction {
	if m != nil {
		return m.Action
	}
	return nil
}

func (m *MonitorAction) GetAggScheme() []AggregationScheme {
	if m != nil {
		return m.AggScheme
	}
	return nil
}

func (m *MonitorAction) GetMirrorDestinations() []uint32 {
	if m != nil {
		return m.MirrorDestinations
	}
	return nil
}

// FlowMonitorRuleSpec flow monitor rule specification
type FlowMonitorRuleSpec struct {
	Meta           *ObjectMeta      `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	ExportConfigId *ExportControlId `protobuf:"bytes,2,opt,name=export_configId,json=exportConfigId" json:"export_configId,omitempty"`
	SourceMac      *MacAddress      `protobuf:"bytes,3,opt,name=source_mac,json=sourceMac" json:"source_mac,omitempty"`
	DestMac        *MacAddress      `protobuf:"bytes,4,opt,name=dest_mac,json=destMac" json:"dest_mac,omitempty"`
	Protocol       IPProtocol       `protobuf:"varint,5,opt,name=protocol,proto3,enum=types.IPProtocol" json:"protocol,omitempty"`
	SourceIp       *IPPrefix        `protobuf:"bytes,6,opt,name=source_ip,json=sourceIp" json:"source_ip,omitempty"`
	DestIp         *IPPrefix        `protobuf:"bytes,7,opt,name=dest_ip,json=destIp" json:"dest_ip,omitempty"`
	SourceL4Port   *L4Port          `protobuf:"bytes,8,opt,name=source_l4_port,json=sourceL4Port" json:"source_l4_port,omitempty"`
	DestL4Port     *L4Port          `protobuf:"bytes,9,opt,name=dest_l4_port,json=destL4Port" json:"dest_l4_port,omitempty"`
	SourceTags     []uint64         `protobuf:"varint,10,rep,packed,name=source_tags,json=sourceTags" json:"source_tags,omitempty"`
	DestTags       []uint64         `protobuf:"varint,11,rep,packed,name=dest_tags,json=destTags" json:"dest_tags,omitempty"`
	Action         *MonitorAction   `protobuf:"bytes,12,opt,name=action" json:"action,omitempty"`
}

func (m *FlowMonitorRuleSpec) Reset()                    { *m = FlowMonitorRuleSpec{} }
func (m *FlowMonitorRuleSpec) String() string            { return proto.CompactTextString(m) }
func (*FlowMonitorRuleSpec) ProtoMessage()               {}
func (*FlowMonitorRuleSpec) Descriptor() ([]byte, []int) { return fileDescriptorTelemetry, []int{14} }

func (m *FlowMonitorRuleSpec) GetMeta() *ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *FlowMonitorRuleSpec) GetExportConfigId() *ExportControlId {
	if m != nil {
		return m.ExportConfigId
	}
	return nil
}

func (m *FlowMonitorRuleSpec) GetSourceMac() *MacAddress {
	if m != nil {
		return m.SourceMac
	}
	return nil
}

func (m *FlowMonitorRuleSpec) GetDestMac() *MacAddress {
	if m != nil {
		return m.DestMac
	}
	return nil
}

func (m *FlowMonitorRuleSpec) GetProtocol() IPProtocol {
	if m != nil {
		return m.Protocol
	}
	return IPProtocol_IPPROTO_NONE
}

func (m *FlowMonitorRuleSpec) GetSourceIp() *IPPrefix {
	if m != nil {
		return m.SourceIp
	}
	return nil
}

func (m *FlowMonitorRuleSpec) GetDestIp() *IPPrefix {
	if m != nil {
		return m.DestIp
	}
	return nil
}

func (m *FlowMonitorRuleSpec) GetSourceL4Port() *L4Port {
	if m != nil {
		return m.SourceL4Port
	}
	return nil
}

func (m *FlowMonitorRuleSpec) GetDestL4Port() *L4Port {
	if m != nil {
		return m.DestL4Port
	}
	return nil
}

func (m *FlowMonitorRuleSpec) GetSourceTags() []uint64 {
	if m != nil {
		return m.SourceTags
	}
	return nil
}

func (m *FlowMonitorRuleSpec) GetDestTags() []uint64 {
	if m != nil {
		return m.DestTags
	}
	return nil
}

func (m *FlowMonitorRuleSpec) GetAction() *MonitorAction {
	if m != nil {
		return m.Action
	}
	return nil
}

// FlowMonitorRuleStatus is the operational status of the rule
type FlowMonitorRuleStatus struct {
	Code        FlowMonitorRuleStatus_FlowMonitorRuleStatusCode `protobuf:"varint,1,opt,name=code,proto3,enum=telemetry.FlowMonitorRuleStatus_FlowMonitorRuleStatusCode" json:"code,omitempty"`
	Status      string                                          `protobuf:"bytes,2,opt,name=status,proto3" json:"status,omitempty"`
	ActiveFlows uint32                                          `protobuf:"varint,3,opt,name=active_flows,json=activeFlows,proto3" json:"active_flows,omitempty"`
}

func (m *FlowMonitorRuleStatus) Reset()                    { *m = FlowMonitorRuleStatus{} }
func (m *FlowMonitorRuleStatus) String() string            { return proto.CompactTextString(m) }
func (*FlowMonitorRuleStatus) ProtoMessage()               {}
func (*FlowMonitorRuleStatus) Descriptor() ([]byte, []int) { return fileDescriptorTelemetry, []int{15} }

func (m *FlowMonitorRuleStatus) GetCode() FlowMonitorRuleStatus_FlowMonitorRuleStatusCode {
	if m != nil {
		return m.Code
	}
	return FlowMonitorRuleStatus_SUCCESS
}

func (m *FlowMonitorRuleStatus) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *FlowMonitorRuleStatus) GetActiveFlows() uint32 {
	if m != nil {
		return m.ActiveFlows
	}
	return 0
}

// FlowMonitorRule is a container for the configuration and operational status
type FlowMonitorRule struct {
	Spec   *FlowMonitorRuleSpec   `protobuf:"bytes,1,opt,name=spec" json:"spec,omitempty"`
	Status *FlowMonitorRuleStatus `protobuf:"bytes,2,opt,name=status" json:"status,omitempty"`
}

func (m *FlowMonitorRule) Reset()                    { *m = FlowMonitorRule{} }
func (m *FlowMonitorRule) String() string            { return proto.CompactTextString(m) }
func (*FlowMonitorRule) ProtoMessage()               {}
func (*FlowMonitorRule) Descriptor() ([]byte, []int) { return fileDescriptorTelemetry, []int{16} }

func (m *FlowMonitorRule) GetSpec() *FlowMonitorRuleSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *FlowMonitorRule) GetStatus() *FlowMonitorRuleStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

// FlowMonitorRuleConfigMsg is used in api requests for flow monitor configuration
type FlowMonitorRuleConfigMsg struct {
	Rules []*FlowMonitorRuleSpec `protobuf:"bytes,1,rep,name=rules" json:"rules,omitempty"`
}

func (m *FlowMonitorRuleConfigMsg) Reset()         { *m = FlowMonitorRuleConfigMsg{} }
func (m *FlowMonitorRuleConfigMsg) String() string { return proto.CompactTextString(m) }
func (*FlowMonitorRuleConfigMsg) ProtoMessage()    {}
func (*FlowMonitorRuleConfigMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorTelemetry, []int{17}
}

func (m *FlowMonitorRuleConfigMsg) GetRules() []*FlowMonitorRuleSpec {
	if m != nil {
		return m.Rules
	}
	return nil
}

// FlowMonitorRuleResponseMsg is used in responses for flow monitor rule operations
type FlowMonitorRuleResponseMsg struct {
	Status ApiStatus          `protobuf:"varint,1,opt,name=status,proto3,enum=types.ApiStatus" json:"status,omitempty"`
	Rules  []*FlowMonitorRule `protobuf:"bytes,2,rep,name=rules" json:"rules,omitempty"`
}

func (m *FlowMonitorRuleResponseMsg) Reset()         { *m = FlowMonitorRuleResponseMsg{} }
func (m *FlowMonitorRuleResponseMsg) String() string { return proto.CompactTextString(m) }
func (*FlowMonitorRuleResponseMsg) ProtoMessage()    {}
func (*FlowMonitorRuleResponseMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorTelemetry, []int{18}
}

func (m *FlowMonitorRuleResponseMsg) GetStatus() ApiStatus {
	if m != nil {
		return m.Status
	}
	return ApiStatus_API_STATUS_OK
}

func (m *FlowMonitorRuleResponseMsg) GetRules() []*FlowMonitorRule {
	if m != nil {
		return m.Rules
	}
	return nil
}

// RspanSpec is the configuration specification for RSPAN.
type RSpanSpec struct {
	Intf       *InterfaceKeyHandle `protobuf:"bytes,1,opt,name=intf" json:"intf,omitempty"`
	RspanEncap *EncapInfo          `protobuf:"bytes,2,opt,name=rspan_encap,json=rspanEncap" json:"rspan_encap,omitempty"`
}

func (m *RSpanSpec) Reset()                    { *m = RSpanSpec{} }
func (m *RSpanSpec) String() string            { return proto.CompactTextString(m) }
func (*RSpanSpec) ProtoMessage()               {}
func (*RSpanSpec) Descriptor() ([]byte, []int) { return fileDescriptorTelemetry, []int{19} }

func (m *RSpanSpec) GetIntf() *InterfaceKeyHandle {
	if m != nil {
		return m.Intf
	}
	return nil
}

func (m *RSpanSpec) GetRspanEncap() *EncapInfo {
	if m != nil {
		return m.RspanEncap
	}
	return nil
}

// ERSpanSpec is the configuration specification for ERSPAN
type ERSpanSpec struct {
	DestIp *IPAddress `protobuf:"bytes,1,opt,name=dest_ip,json=destIp" json:"dest_ip,omitempty"`
	SrcIp  *IPAddress `protobuf:"bytes,2,opt,name=src_ip,json=srcIp" json:"src_ip,omitempty"`
	Dscp   string     `protobuf:"bytes,3,opt,name=dscp,proto3" json:"dscp,omitempty"`
	SpanId uint32     `protobuf:"varint,4,opt,name=span_id,json=spanId,proto3" json:"span_id,omitempty"`
}

func (m *ERSpanSpec) Reset()                    { *m = ERSpanSpec{} }
func (m *ERSpanSpec) String() string            { return proto.CompactTextString(m) }
func (*ERSpanSpec) ProtoMessage()               {}
func (*ERSpanSpec) Descriptor() ([]byte, []int) { return fileDescriptorTelemetry, []int{20} }

func (m *ERSpanSpec) GetDestIp() *IPAddress {
	if m != nil {
		return m.DestIp
	}
	return nil
}

func (m *ERSpanSpec) GetSrcIp() *IPAddress {
	if m != nil {
		return m.SrcIp
	}
	return nil
}

func (m *ERSpanSpec) GetDscp() string {
	if m != nil {
		return m.Dscp
	}
	return ""
}

func (m *ERSpanSpec) GetSpanId() uint32 {
	if m != nil {
		return m.SpanId
	}
	return 0
}

// MirrorSessionId is a key for the SPAN session
type MirrorSessionId struct {
	SessionId uint32 `protobuf:"varint,1,opt,name=session_id,json=sessionId,proto3" json:"session_id,omitempty"`
}

func (m *MirrorSessionId) Reset()                    { *m = MirrorSessionId{} }
func (m *MirrorSessionId) String() string            { return proto.CompactTextString(m) }
func (*MirrorSessionId) ProtoMessage()               {}
func (*MirrorSessionId) Descriptor() ([]byte, []int) { return fileDescriptorTelemetry, []int{21} }

func (m *MirrorSessionId) GetSessionId() uint32 {
	if m != nil {
		return m.SessionId
	}
	return 0
}

// MirrorSessionSpec is the configuration specification for mirror config
type MirrorSessionSpec struct {
	Meta    *ObjectMeta      `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	Id      *MirrorSessionId `protobuf:"bytes,2,opt,name=id" json:"id,omitempty"`
	Snaplen uint32           `protobuf:"varint,3,opt,name=snaplen,proto3" json:"snaplen,omitempty"`
	// Types that are valid to be assigned to Destination:
	//	*MirrorSessionSpec_LocalSpanIf
	//	*MirrorSessionSpec_RspanSpec
	//	*MirrorSessionSpec_ErspanSpec
	Destination isMirrorSessionSpec_Destination `protobuf_oneof:"destination"`
}

func (m *MirrorSessionSpec) Reset()                    { *m = MirrorSessionSpec{} }
func (m *MirrorSessionSpec) String() string            { return proto.CompactTextString(m) }
func (*MirrorSessionSpec) ProtoMessage()               {}
func (*MirrorSessionSpec) Descriptor() ([]byte, []int) { return fileDescriptorTelemetry, []int{22} }

type isMirrorSessionSpec_Destination interface {
	isMirrorSessionSpec_Destination()
	MarshalTo([]byte) (int, error)
	Size() int
}

type MirrorSessionSpec_LocalSpanIf struct {
	LocalSpanIf *InterfaceKeyHandle `protobuf:"bytes,4,opt,name=local_span_if,json=localSpanIf,oneof"`
}
type MirrorSessionSpec_RspanSpec struct {
	RspanSpec *RSpanSpec `protobuf:"bytes,5,opt,name=rspan_spec,json=rspanSpec,oneof"`
}
type MirrorSessionSpec_ErspanSpec struct {
	ErspanSpec *ERSpanSpec `protobuf:"bytes,6,opt,name=erspan_spec,json=erspanSpec,oneof"`
}

func (*MirrorSessionSpec_LocalSpanIf) isMirrorSessionSpec_Destination() {}
func (*MirrorSessionSpec_RspanSpec) isMirrorSessionSpec_Destination()   {}
func (*MirrorSessionSpec_ErspanSpec) isMirrorSessionSpec_Destination()  {}

func (m *MirrorSessionSpec) GetDestination() isMirrorSessionSpec_Destination {
	if m != nil {
		return m.Destination
	}
	return nil
}

func (m *MirrorSessionSpec) GetMeta() *ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *MirrorSessionSpec) GetId() *MirrorSessionId {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *MirrorSessionSpec) GetSnaplen() uint32 {
	if m != nil {
		return m.Snaplen
	}
	return 0
}

func (m *MirrorSessionSpec) GetLocalSpanIf() *InterfaceKeyHandle {
	if x, ok := m.GetDestination().(*MirrorSessionSpec_LocalSpanIf); ok {
		return x.LocalSpanIf
	}
	return nil
}

func (m *MirrorSessionSpec) GetRspanSpec() *RSpanSpec {
	if x, ok := m.GetDestination().(*MirrorSessionSpec_RspanSpec); ok {
		return x.RspanSpec
	}
	return nil
}

func (m *MirrorSessionSpec) GetErspanSpec() *ERSpanSpec {
	if x, ok := m.GetDestination().(*MirrorSessionSpec_ErspanSpec); ok {
		return x.ErspanSpec
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*MirrorSessionSpec) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _MirrorSessionSpec_OneofMarshaler, _MirrorSessionSpec_OneofUnmarshaler, _MirrorSessionSpec_OneofSizer, []interface{}{
		(*MirrorSessionSpec_LocalSpanIf)(nil),
		(*MirrorSessionSpec_RspanSpec)(nil),
		(*MirrorSessionSpec_ErspanSpec)(nil),
	}
}

func _MirrorSessionSpec_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*MirrorSessionSpec)
	// destination
	switch x := m.Destination.(type) {
	case *MirrorSessionSpec_LocalSpanIf:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.LocalSpanIf); err != nil {
			return err
		}
	case *MirrorSessionSpec_RspanSpec:
		_ = b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.RspanSpec); err != nil {
			return err
		}
	case *MirrorSessionSpec_ErspanSpec:
		_ = b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ErspanSpec); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("MirrorSessionSpec.Destination has unexpected type %T", x)
	}
	return nil
}

func _MirrorSessionSpec_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*MirrorSessionSpec)
	switch tag {
	case 4: // destination.local_span_if
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(InterfaceKeyHandle)
		err := b.DecodeMessage(msg)
		m.Destination = &MirrorSessionSpec_LocalSpanIf{msg}
		return true, err
	case 5: // destination.rspan_spec
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(RSpanSpec)
		err := b.DecodeMessage(msg)
		m.Destination = &MirrorSessionSpec_RspanSpec{msg}
		return true, err
	case 6: // destination.erspan_spec
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ERSpanSpec)
		err := b.DecodeMessage(msg)
		m.Destination = &MirrorSessionSpec_ErspanSpec{msg}
		return true, err
	default:
		return false, nil
	}
}

func _MirrorSessionSpec_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*MirrorSessionSpec)
	// destination
	switch x := m.Destination.(type) {
	case *MirrorSessionSpec_LocalSpanIf:
		s := proto.Size(x.LocalSpanIf)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *MirrorSessionSpec_RspanSpec:
		s := proto.Size(x.RspanSpec)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *MirrorSessionSpec_ErspanSpec:
		s := proto.Size(x.ErspanSpec)
		n += proto.SizeVarint(6<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// MirrorSessionStatus is the operational status of the SPAN session.
type MirrorSessionStatus struct {
	Code        MirrorSessionStatus_MirrorSessionStatusCode `protobuf:"varint,1,opt,name=code,proto3,enum=telemetry.MirrorSessionStatus_MirrorSessionStatusCode" json:"code,omitempty"`
	Status      string                                      `protobuf:"bytes,2,opt,name=status,proto3" json:"status,omitempty"`
	ActiveFlows int32                                       `protobuf:"varint,3,opt,name=active_flows,json=activeFlows,proto3" json:"active_flows,omitempty"`
}

func (m *MirrorSessionStatus) Reset()                    { *m = MirrorSessionStatus{} }
func (m *MirrorSessionStatus) String() string            { return proto.CompactTextString(m) }
func (*MirrorSessionStatus) ProtoMessage()               {}
func (*MirrorSessionStatus) Descriptor() ([]byte, []int) { return fileDescriptorTelemetry, []int{23} }

func (m *MirrorSessionStatus) GetCode() MirrorSessionStatus_MirrorSessionStatusCode {
	if m != nil {
		return m.Code
	}
	return MirrorSessionStatus_SUCCESS
}

func (m *MirrorSessionStatus) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *MirrorSessionStatus) GetActiveFlows() int32 {
	if m != nil {
		return m.ActiveFlows
	}
	return 0
}

// MirrorSession is a container of the configuration and the operational status for mirror sessions.
type MirrorSession struct {
	ApiStatus ApiStatus            `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty"`
	Spec      *MirrorSessionSpec   `protobuf:"bytes,2,opt,name=spec" json:"spec,omitempty"`
	Status    *MirrorSessionStatus `protobuf:"bytes,3,opt,name=status" json:"status,omitempty"`
}

func (m *MirrorSession) Reset()                    { *m = MirrorSession{} }
func (m *MirrorSession) String() string            { return proto.CompactTextString(m) }
func (*MirrorSession) ProtoMessage()               {}
func (*MirrorSession) Descriptor() ([]byte, []int) { return fileDescriptorTelemetry, []int{24} }

func (m *MirrorSession) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *MirrorSession) GetSpec() *MirrorSessionSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *MirrorSession) GetStatus() *MirrorSessionStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

// MirrorSessionConfigMsg is a batchable message used for request messages for mirror session configuration.
type MirrorSessionConfigMsg struct {
	Request []*MirrorSessionSpec `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *MirrorSessionConfigMsg) Reset()                    { *m = MirrorSessionConfigMsg{} }
func (m *MirrorSessionConfigMsg) String() string            { return proto.CompactTextString(m) }
func (*MirrorSessionConfigMsg) ProtoMessage()               {}
func (*MirrorSessionConfigMsg) Descriptor() ([]byte, []int) { return fileDescriptorTelemetry, []int{25} }

func (m *MirrorSessionConfigMsg) GetRequest() []*MirrorSessionSpec {
	if m != nil {
		return m.Request
	}
	return nil
}

// MirrorSessionConfigMsg is a batchable message used for request messages for mirror session configuration.
type MirrorSessionDeleteMsg struct {
	Request []*MirrorSessionId `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *MirrorSessionDeleteMsg) Reset()                    { *m = MirrorSessionDeleteMsg{} }
func (m *MirrorSessionDeleteMsg) String() string            { return proto.CompactTextString(m) }
func (*MirrorSessionDeleteMsg) ProtoMessage()               {}
func (*MirrorSessionDeleteMsg) Descriptor() ([]byte, []int) { return fileDescriptorTelemetry, []int{26} }

func (m *MirrorSessionDeleteMsg) GetRequest() []*MirrorSessionId {
	if m != nil {
		return m.Request
	}
	return nil
}

// MirrorSessionResponseMsg is used as responses to the MirrorSession configuration APIs
type MirrorSessionResponseMsg struct {
	Status   ApiStatus        `protobuf:"varint,1,opt,name=status,proto3,enum=types.ApiStatus" json:"status,omitempty"`
	Response []*MirrorSession `protobuf:"bytes,2,rep,name=response" json:"response,omitempty"`
}

func (m *MirrorSessionResponseMsg) Reset()         { *m = MirrorSessionResponseMsg{} }
func (m *MirrorSessionResponseMsg) String() string { return proto.CompactTextString(m) }
func (*MirrorSessionResponseMsg) ProtoMessage()    {}
func (*MirrorSessionResponseMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorTelemetry, []int{27}
}

func (m *MirrorSessionResponseMsg) GetStatus() ApiStatus {
	if m != nil {
		return m.Status
	}
	return ApiStatus_API_STATUS_OK
}

func (m *MirrorSessionResponseMsg) GetResponse() []*MirrorSession {
	if m != nil {
		return m.Response
	}
	return nil
}

func init() {
	proto.RegisterType((*L4Port)(nil), "telemetry.L4Port")
	proto.RegisterType((*MacAddress)(nil), "telemetry.MacAddress")
	proto.RegisterType((*CollectorSpec)(nil), "telemetry.CollectorSpec")
	proto.RegisterType((*CollectorStatus)(nil), "telemetry.CollectorStatus")
	proto.RegisterType((*Collector)(nil), "telemetry.Collector")
	proto.RegisterType((*CollectorConfigMsg)(nil), "telemetry.CollectorConfigMsg")
	proto.RegisterType((*CollectorResponseMsg)(nil), "telemetry.CollectorResponseMsg")
	proto.RegisterType((*ExportControlId)(nil), "telemetry.ExportControlId")
	proto.RegisterType((*ExportControlSpec)(nil), "telemetry.ExportControlSpec")
	proto.RegisterType((*ExportControlStatus)(nil), "telemetry.ExportControlStatus")
	proto.RegisterType((*ExportControl)(nil), "telemetry.ExportControl")
	proto.RegisterType((*ExportControlConfigMsg)(nil), "telemetry.ExportControlConfigMsg")
	proto.RegisterType((*ExportControlResponseMsg)(nil), "telemetry.ExportControlResponseMsg")
	proto.RegisterType((*MonitorAction)(nil), "telemetry.MonitorAction")
	proto.RegisterType((*FlowMonitorRuleSpec)(nil), "telemetry.FlowMonitorRuleSpec")
	proto.RegisterType((*FlowMonitorRuleStatus)(nil), "telemetry.FlowMonitorRuleStatus")
	proto.RegisterType((*FlowMonitorRule)(nil), "telemetry.FlowMonitorRule")
	proto.RegisterType((*FlowMonitorRuleConfigMsg)(nil), "telemetry.FlowMonitorRuleConfigMsg")
	proto.RegisterType((*FlowMonitorRuleResponseMsg)(nil), "telemetry.FlowMonitorRuleResponseMsg")
	proto.RegisterType((*RSpanSpec)(nil), "telemetry.RSpanSpec")
	proto.RegisterType((*ERSpanSpec)(nil), "telemetry.ERSpanSpec")
	proto.RegisterType((*MirrorSessionId)(nil), "telemetry.MirrorSessionId")
	proto.RegisterType((*MirrorSessionSpec)(nil), "telemetry.MirrorSessionSpec")
	proto.RegisterType((*MirrorSessionStatus)(nil), "telemetry.MirrorSessionStatus")
	proto.RegisterType((*MirrorSession)(nil), "telemetry.MirrorSession")
	proto.RegisterType((*MirrorSessionConfigMsg)(nil), "telemetry.MirrorSessionConfigMsg")
	proto.RegisterType((*MirrorSessionDeleteMsg)(nil), "telemetry.MirrorSessionDeleteMsg")
	proto.RegisterType((*MirrorSessionResponseMsg)(nil), "telemetry.MirrorSessionResponseMsg")
	proto.RegisterEnum("telemetry.ExportFormat", ExportFormat_name, ExportFormat_value)
	proto.RegisterEnum("telemetry.RuleAction", RuleAction_name, RuleAction_value)
	proto.RegisterEnum("telemetry.AggregationScheme", AggregationScheme_name, AggregationScheme_value)
	proto.RegisterEnum("telemetry.CollectorStatus_CollectorStatusCode", CollectorStatus_CollectorStatusCode_name, CollectorStatus_CollectorStatusCode_value)
	proto.RegisterEnum("telemetry.ExportControlStatus_ExportControlStatusCode", ExportControlStatus_ExportControlStatusCode_name, ExportControlStatus_ExportControlStatusCode_value)
	proto.RegisterEnum("telemetry.FlowMonitorRuleStatus_FlowMonitorRuleStatusCode", FlowMonitorRuleStatus_FlowMonitorRuleStatusCode_name, FlowMonitorRuleStatus_FlowMonitorRuleStatusCode_value)
	proto.RegisterEnum("telemetry.MirrorSessionStatus_MirrorSessionStatusCode", MirrorSessionStatus_MirrorSessionStatusCode_name, MirrorSessionStatus_MirrorSessionStatusCode_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Telemetry service

type TelemetryClient interface {
	// Collector operations CRUD operations
	CollectorCreate(ctx context.Context, in *CollectorConfigMsg, opts ...grpc.CallOption) (*CollectorResponseMsg, error)
	CollectorUpdate(ctx context.Context, in *CollectorConfigMsg, opts ...grpc.CallOption) (*CollectorResponseMsg, error)
	CollectorList(ctx context.Context, in *ExportControlId, opts ...grpc.CallOption) (*CollectorResponseMsg, error)
	CollectorDelete(ctx context.Context, in *CollectorConfigMsg, opts ...grpc.CallOption) (*CollectorResponseMsg, error)
	// ExportConfig CRUD operations
	ExportControlCreate(ctx context.Context, in *ExportControlConfigMsg, opts ...grpc.CallOption) (*ExportControlResponseMsg, error)
	ExportControlUpdate(ctx context.Context, in *ExportControlConfigMsg, opts ...grpc.CallOption) (*ExportControlResponseMsg, error)
	ExportControlGet(ctx context.Context, in *ExportControlId, opts ...grpc.CallOption) (*ExportControlResponseMsg, error)
	ExportControlDelete(ctx context.Context, in *ExportControlId, opts ...grpc.CallOption) (*ExportControlResponseMsg, error)
	// FlowMonitorRules CRUD Operations
	FlowMonitorRuleCreate(ctx context.Context, in *FlowMonitorRuleConfigMsg, opts ...grpc.CallOption) (*FlowMonitorRuleResponseMsg, error)
	FlowMonitorRuleUpdate(ctx context.Context, in *FlowMonitorRuleConfigMsg, opts ...grpc.CallOption) (*FlowMonitorRuleResponseMsg, error)
	FlowMonitorRuleList(ctx context.Context, in *ExportControlId, opts ...grpc.CallOption) (*FlowMonitorRuleResponseMsg, error)
	FlowMonitorRuleGet(ctx context.Context, in *FlowMonitorRuleConfigMsg, opts ...grpc.CallOption) (*FlowMonitorRuleResponseMsg, error)
	FlowMonitorRuleDelete(ctx context.Context, in *FlowMonitorRuleConfigMsg, opts ...grpc.CallOption) (*FlowMonitorRuleResponseMsg, error)
	// MirrorSession CRUD Operations
	MirrorSessionCreate(ctx context.Context, in *MirrorSessionConfigMsg, opts ...grpc.CallOption) (*MirrorSessionResponseMsg, error)
	MirrorSessionUpdate(ctx context.Context, in *MirrorSessionConfigMsg, opts ...grpc.CallOption) (*MirrorSessionResponseMsg, error)
	MirrorSessionGet(ctx context.Context, in *MirrorSessionId, opts ...grpc.CallOption) (*MirrorSessionResponseMsg, error)
	MirrorSessionList(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*MirrorSessionResponseMsg, error)
	MirrorSessionDelete(ctx context.Context, in *MirrorSessionDeleteMsg, opts ...grpc.CallOption) (*MirrorSessionResponseMsg, error)
}

type telemetryClient struct {
	cc *grpc.ClientConn
}

func NewTelemetryClient(cc *grpc.ClientConn) TelemetryClient {
	return &telemetryClient{cc}
}

func (c *telemetryClient) CollectorCreate(ctx context.Context, in *CollectorConfigMsg, opts ...grpc.CallOption) (*CollectorResponseMsg, error) {
	out := new(CollectorResponseMsg)
	err := grpc.Invoke(ctx, "/telemetry.Telemetry/CollectorCreate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *telemetryClient) CollectorUpdate(ctx context.Context, in *CollectorConfigMsg, opts ...grpc.CallOption) (*CollectorResponseMsg, error) {
	out := new(CollectorResponseMsg)
	err := grpc.Invoke(ctx, "/telemetry.Telemetry/CollectorUpdate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *telemetryClient) CollectorList(ctx context.Context, in *ExportControlId, opts ...grpc.CallOption) (*CollectorResponseMsg, error) {
	out := new(CollectorResponseMsg)
	err := grpc.Invoke(ctx, "/telemetry.Telemetry/CollectorList", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *telemetryClient) CollectorDelete(ctx context.Context, in *CollectorConfigMsg, opts ...grpc.CallOption) (*CollectorResponseMsg, error) {
	out := new(CollectorResponseMsg)
	err := grpc.Invoke(ctx, "/telemetry.Telemetry/CollectorDelete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *telemetryClient) ExportControlCreate(ctx context.Context, in *ExportControlConfigMsg, opts ...grpc.CallOption) (*ExportControlResponseMsg, error) {
	out := new(ExportControlResponseMsg)
	err := grpc.Invoke(ctx, "/telemetry.Telemetry/ExportControlCreate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *telemetryClient) ExportControlUpdate(ctx context.Context, in *ExportControlConfigMsg, opts ...grpc.CallOption) (*ExportControlResponseMsg, error) {
	out := new(ExportControlResponseMsg)
	err := grpc.Invoke(ctx, "/telemetry.Telemetry/ExportControlUpdate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *telemetryClient) ExportControlGet(ctx context.Context, in *ExportControlId, opts ...grpc.CallOption) (*ExportControlResponseMsg, error) {
	out := new(ExportControlResponseMsg)
	err := grpc.Invoke(ctx, "/telemetry.Telemetry/ExportControlGet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *telemetryClient) ExportControlDelete(ctx context.Context, in *ExportControlId, opts ...grpc.CallOption) (*ExportControlResponseMsg, error) {
	out := new(ExportControlResponseMsg)
	err := grpc.Invoke(ctx, "/telemetry.Telemetry/ExportControlDelete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *telemetryClient) FlowMonitorRuleCreate(ctx context.Context, in *FlowMonitorRuleConfigMsg, opts ...grpc.CallOption) (*FlowMonitorRuleResponseMsg, error) {
	out := new(FlowMonitorRuleResponseMsg)
	err := grpc.Invoke(ctx, "/telemetry.Telemetry/FlowMonitorRuleCreate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *telemetryClient) FlowMonitorRuleUpdate(ctx context.Context, in *FlowMonitorRuleConfigMsg, opts ...grpc.CallOption) (*FlowMonitorRuleResponseMsg, error) {
	out := new(FlowMonitorRuleResponseMsg)
	err := grpc.Invoke(ctx, "/telemetry.Telemetry/FlowMonitorRuleUpdate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *telemetryClient) FlowMonitorRuleList(ctx context.Context, in *ExportControlId, opts ...grpc.CallOption) (*FlowMonitorRuleResponseMsg, error) {
	out := new(FlowMonitorRuleResponseMsg)
	err := grpc.Invoke(ctx, "/telemetry.Telemetry/FlowMonitorRuleList", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *telemetryClient) FlowMonitorRuleGet(ctx context.Context, in *FlowMonitorRuleConfigMsg, opts ...grpc.CallOption) (*FlowMonitorRuleResponseMsg, error) {
	out := new(FlowMonitorRuleResponseMsg)
	err := grpc.Invoke(ctx, "/telemetry.Telemetry/FlowMonitorRuleGet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *telemetryClient) FlowMonitorRuleDelete(ctx context.Context, in *FlowMonitorRuleConfigMsg, opts ...grpc.CallOption) (*FlowMonitorRuleResponseMsg, error) {
	out := new(FlowMonitorRuleResponseMsg)
	err := grpc.Invoke(ctx, "/telemetry.Telemetry/FlowMonitorRuleDelete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *telemetryClient) MirrorSessionCreate(ctx context.Context, in *MirrorSessionConfigMsg, opts ...grpc.CallOption) (*MirrorSessionResponseMsg, error) {
	out := new(MirrorSessionResponseMsg)
	err := grpc.Invoke(ctx, "/telemetry.Telemetry/MirrorSessionCreate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *telemetryClient) MirrorSessionUpdate(ctx context.Context, in *MirrorSessionConfigMsg, opts ...grpc.CallOption) (*MirrorSessionResponseMsg, error) {
	out := new(MirrorSessionResponseMsg)
	err := grpc.Invoke(ctx, "/telemetry.Telemetry/MirrorSessionUpdate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *telemetryClient) MirrorSessionGet(ctx context.Context, in *MirrorSessionId, opts ...grpc.CallOption) (*MirrorSessionResponseMsg, error) {
	out := new(MirrorSessionResponseMsg)
	err := grpc.Invoke(ctx, "/telemetry.Telemetry/MirrorSessionGet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *telemetryClient) MirrorSessionList(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*MirrorSessionResponseMsg, error) {
	out := new(MirrorSessionResponseMsg)
	err := grpc.Invoke(ctx, "/telemetry.Telemetry/MirrorSessionList", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *telemetryClient) MirrorSessionDelete(ctx context.Context, in *MirrorSessionDeleteMsg, opts ...grpc.CallOption) (*MirrorSessionResponseMsg, error) {
	out := new(MirrorSessionResponseMsg)
	err := grpc.Invoke(ctx, "/telemetry.Telemetry/MirrorSessionDelete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Telemetry service

type TelemetryServer interface {
	// Collector operations CRUD operations
	CollectorCreate(context.Context, *CollectorConfigMsg) (*CollectorResponseMsg, error)
	CollectorUpdate(context.Context, *CollectorConfigMsg) (*CollectorResponseMsg, error)
	CollectorList(context.Context, *ExportControlId) (*CollectorResponseMsg, error)
	CollectorDelete(context.Context, *CollectorConfigMsg) (*CollectorResponseMsg, error)
	// ExportConfig CRUD operations
	ExportControlCreate(context.Context, *ExportControlConfigMsg) (*ExportControlResponseMsg, error)
	ExportControlUpdate(context.Context, *ExportControlConfigMsg) (*ExportControlResponseMsg, error)
	ExportControlGet(context.Context, *ExportControlId) (*ExportControlResponseMsg, error)
	ExportControlDelete(context.Context, *ExportControlId) (*ExportControlResponseMsg, error)
	// FlowMonitorRules CRUD Operations
	FlowMonitorRuleCreate(context.Context, *FlowMonitorRuleConfigMsg) (*FlowMonitorRuleResponseMsg, error)
	FlowMonitorRuleUpdate(context.Context, *FlowMonitorRuleConfigMsg) (*FlowMonitorRuleResponseMsg, error)
	FlowMonitorRuleList(context.Context, *ExportControlId) (*FlowMonitorRuleResponseMsg, error)
	FlowMonitorRuleGet(context.Context, *FlowMonitorRuleConfigMsg) (*FlowMonitorRuleResponseMsg, error)
	FlowMonitorRuleDelete(context.Context, *FlowMonitorRuleConfigMsg) (*FlowMonitorRuleResponseMsg, error)
	// MirrorSession CRUD Operations
	MirrorSessionCreate(context.Context, *MirrorSessionConfigMsg) (*MirrorSessionResponseMsg, error)
	MirrorSessionUpdate(context.Context, *MirrorSessionConfigMsg) (*MirrorSessionResponseMsg, error)
	MirrorSessionGet(context.Context, *MirrorSessionId) (*MirrorSessionResponseMsg, error)
	MirrorSessionList(context.Context, *Empty) (*MirrorSessionResponseMsg, error)
	MirrorSessionDelete(context.Context, *MirrorSessionDeleteMsg) (*MirrorSessionResponseMsg, error)
}

func RegisterTelemetryServer(s *grpc.Server, srv TelemetryServer) {
	s.RegisterService(&_Telemetry_serviceDesc, srv)
}

func _Telemetry_CollectorCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CollectorConfigMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TelemetryServer).CollectorCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/telemetry.Telemetry/CollectorCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TelemetryServer).CollectorCreate(ctx, req.(*CollectorConfigMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Telemetry_CollectorUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CollectorConfigMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TelemetryServer).CollectorUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/telemetry.Telemetry/CollectorUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TelemetryServer).CollectorUpdate(ctx, req.(*CollectorConfigMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Telemetry_CollectorList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExportControlId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TelemetryServer).CollectorList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/telemetry.Telemetry/CollectorList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TelemetryServer).CollectorList(ctx, req.(*ExportControlId))
	}
	return interceptor(ctx, in, info, handler)
}

func _Telemetry_CollectorDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CollectorConfigMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TelemetryServer).CollectorDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/telemetry.Telemetry/CollectorDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TelemetryServer).CollectorDelete(ctx, req.(*CollectorConfigMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Telemetry_ExportControlCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExportControlConfigMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TelemetryServer).ExportControlCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/telemetry.Telemetry/ExportControlCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TelemetryServer).ExportControlCreate(ctx, req.(*ExportControlConfigMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Telemetry_ExportControlUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExportControlConfigMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TelemetryServer).ExportControlUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/telemetry.Telemetry/ExportControlUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TelemetryServer).ExportControlUpdate(ctx, req.(*ExportControlConfigMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Telemetry_ExportControlGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExportControlId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TelemetryServer).ExportControlGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/telemetry.Telemetry/ExportControlGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TelemetryServer).ExportControlGet(ctx, req.(*ExportControlId))
	}
	return interceptor(ctx, in, info, handler)
}

func _Telemetry_ExportControlDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExportControlId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TelemetryServer).ExportControlDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/telemetry.Telemetry/ExportControlDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TelemetryServer).ExportControlDelete(ctx, req.(*ExportControlId))
	}
	return interceptor(ctx, in, info, handler)
}

func _Telemetry_FlowMonitorRuleCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FlowMonitorRuleConfigMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TelemetryServer).FlowMonitorRuleCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/telemetry.Telemetry/FlowMonitorRuleCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TelemetryServer).FlowMonitorRuleCreate(ctx, req.(*FlowMonitorRuleConfigMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Telemetry_FlowMonitorRuleUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FlowMonitorRuleConfigMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TelemetryServer).FlowMonitorRuleUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/telemetry.Telemetry/FlowMonitorRuleUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TelemetryServer).FlowMonitorRuleUpdate(ctx, req.(*FlowMonitorRuleConfigMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Telemetry_FlowMonitorRuleList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExportControlId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TelemetryServer).FlowMonitorRuleList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/telemetry.Telemetry/FlowMonitorRuleList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TelemetryServer).FlowMonitorRuleList(ctx, req.(*ExportControlId))
	}
	return interceptor(ctx, in, info, handler)
}

func _Telemetry_FlowMonitorRuleGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FlowMonitorRuleConfigMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TelemetryServer).FlowMonitorRuleGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/telemetry.Telemetry/FlowMonitorRuleGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TelemetryServer).FlowMonitorRuleGet(ctx, req.(*FlowMonitorRuleConfigMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Telemetry_FlowMonitorRuleDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FlowMonitorRuleConfigMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TelemetryServer).FlowMonitorRuleDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/telemetry.Telemetry/FlowMonitorRuleDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TelemetryServer).FlowMonitorRuleDelete(ctx, req.(*FlowMonitorRuleConfigMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Telemetry_MirrorSessionCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MirrorSessionConfigMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TelemetryServer).MirrorSessionCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/telemetry.Telemetry/MirrorSessionCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TelemetryServer).MirrorSessionCreate(ctx, req.(*MirrorSessionConfigMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Telemetry_MirrorSessionUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MirrorSessionConfigMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TelemetryServer).MirrorSessionUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/telemetry.Telemetry/MirrorSessionUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TelemetryServer).MirrorSessionUpdate(ctx, req.(*MirrorSessionConfigMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Telemetry_MirrorSessionGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MirrorSessionId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TelemetryServer).MirrorSessionGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/telemetry.Telemetry/MirrorSessionGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TelemetryServer).MirrorSessionGet(ctx, req.(*MirrorSessionId))
	}
	return interceptor(ctx, in, info, handler)
}

func _Telemetry_MirrorSessionList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TelemetryServer).MirrorSessionList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/telemetry.Telemetry/MirrorSessionList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TelemetryServer).MirrorSessionList(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Telemetry_MirrorSessionDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MirrorSessionDeleteMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TelemetryServer).MirrorSessionDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/telemetry.Telemetry/MirrorSessionDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TelemetryServer).MirrorSessionDelete(ctx, req.(*MirrorSessionDeleteMsg))
	}
	return interceptor(ctx, in, info, handler)
}

var _Telemetry_serviceDesc = grpc.ServiceDesc{
	ServiceName: "telemetry.Telemetry",
	HandlerType: (*TelemetryServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CollectorCreate",
			Handler:    _Telemetry_CollectorCreate_Handler,
		},
		{
			MethodName: "CollectorUpdate",
			Handler:    _Telemetry_CollectorUpdate_Handler,
		},
		{
			MethodName: "CollectorList",
			Handler:    _Telemetry_CollectorList_Handler,
		},
		{
			MethodName: "CollectorDelete",
			Handler:    _Telemetry_CollectorDelete_Handler,
		},
		{
			MethodName: "ExportControlCreate",
			Handler:    _Telemetry_ExportControlCreate_Handler,
		},
		{
			MethodName: "ExportControlUpdate",
			Handler:    _Telemetry_ExportControlUpdate_Handler,
		},
		{
			MethodName: "ExportControlGet",
			Handler:    _Telemetry_ExportControlGet_Handler,
		},
		{
			MethodName: "ExportControlDelete",
			Handler:    _Telemetry_ExportControlDelete_Handler,
		},
		{
			MethodName: "FlowMonitorRuleCreate",
			Handler:    _Telemetry_FlowMonitorRuleCreate_Handler,
		},
		{
			MethodName: "FlowMonitorRuleUpdate",
			Handler:    _Telemetry_FlowMonitorRuleUpdate_Handler,
		},
		{
			MethodName: "FlowMonitorRuleList",
			Handler:    _Telemetry_FlowMonitorRuleList_Handler,
		},
		{
			MethodName: "FlowMonitorRuleGet",
			Handler:    _Telemetry_FlowMonitorRuleGet_Handler,
		},
		{
			MethodName: "FlowMonitorRuleDelete",
			Handler:    _Telemetry_FlowMonitorRuleDelete_Handler,
		},
		{
			MethodName: "MirrorSessionCreate",
			Handler:    _Telemetry_MirrorSessionCreate_Handler,
		},
		{
			MethodName: "MirrorSessionUpdate",
			Handler:    _Telemetry_MirrorSessionUpdate_Handler,
		},
		{
			MethodName: "MirrorSessionGet",
			Handler:    _Telemetry_MirrorSessionGet_Handler,
		},
		{
			MethodName: "MirrorSessionList",
			Handler:    _Telemetry_MirrorSessionList_Handler,
		},
		{
			MethodName: "MirrorSessionDelete",
			Handler:    _Telemetry_MirrorSessionDelete_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "telemetry.proto",
}

func (m *L4Port) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *L4Port) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Port != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.Port))
	}
	return i, nil
}

func (m *MacAddress) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MacAddress) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Address != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.Address))
	}
	return i, nil
}

func (m *CollectorSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CollectorSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.Meta.Size()))
		n1, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.ExportControlId != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.ExportControlId.Size()))
		n2, err := m.ExportControlId.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.Encap != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.Encap.Size()))
		n3, err := m.Encap.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.L2SegHandle != 0 {
		dAtA[i] = 0x21
		i++
		i = encodeFixed64Telemetry(dAtA, i, uint64(m.L2SegHandle))
	}
	if m.DestIp != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.DestIp.Size()))
		n4, err := m.DestIp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.SrcIp != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.SrcIp.Size()))
		n5, err := m.SrcIp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.Protocol != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.Protocol))
	}
	if m.DestPort != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.DestPort.Size()))
		n6, err := m.DestPort.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.Format != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.Format))
	}
	if m.TemplateId != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.TemplateId))
	}
	return i, nil
}

func (m *CollectorStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CollectorStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.Code))
	}
	if len(m.Status) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(len(m.Status)))
		i += copy(dAtA[i:], m.Status)
	}
	return i, nil
}

func (m *Collector) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Collector) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.ApiStatus))
	}
	if m.Spec != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.Spec.Size()))
		n7, err := m.Spec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.Status != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.Status.Size()))
		n8, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	return i, nil
}

func (m *CollectorConfigMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CollectorConfigMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTelemetry(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CollectorResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CollectorResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Status != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.Status))
	}
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0x12
			i++
			i = encodeVarintTelemetry(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ExportControlId) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExportControlId) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.Meta.Size()))
		n9, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.Id != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.Id))
	}
	return i, nil
}

func (m *ExportControlSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExportControlSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.Id.Size()))
		n10, err := m.Id.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.ActiveTimeout != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.ActiveTimeout))
	}
	if m.InactiveTimeout != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.InactiveTimeout))
	}
	return i, nil
}

func (m *ExportControlStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExportControlStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.Code))
	}
	if len(m.Status) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(len(m.Status)))
		i += copy(dAtA[i:], m.Status)
	}
	return i, nil
}

func (m *ExportControl) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExportControl) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Spec != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.Spec.Size()))
		n11, err := m.Spec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if m.Status != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.Status.Size()))
		n12, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	return i, nil
}

func (m *ExportControlConfigMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExportControlConfigMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Configs) > 0 {
		for _, msg := range m.Configs {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTelemetry(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ExportControlResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExportControlResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Status != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.Status))
	}
	if len(m.ExportControl) > 0 {
		for _, msg := range m.ExportControl {
			dAtA[i] = 0x12
			i++
			i = encodeVarintTelemetry(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *MonitorAction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MonitorAction) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Action) > 0 {
		dAtA14 := make([]byte, len(m.Action)*10)
		var j13 int
		for _, num := range m.Action {
			for num >= 1<<7 {
				dAtA14[j13] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j13++
			}
			dAtA14[j13] = uint8(num)
			j13++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(j13))
		i += copy(dAtA[i:], dAtA14[:j13])
	}
	if len(m.AggScheme) > 0 {
		dAtA16 := make([]byte, len(m.AggScheme)*10)
		var j15 int
		for _, num := range m.AggScheme {
			for num >= 1<<7 {
				dAtA16[j15] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j15++
			}
			dAtA16[j15] = uint8(num)
			j15++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(j15))
		i += copy(dAtA[i:], dAtA16[:j15])
	}
	if len(m.MirrorDestinations) > 0 {
		dAtA18 := make([]byte, len(m.MirrorDestinations)*10)
		var j17 int
		for _, num := range m.MirrorDestinations {
			for num >= 1<<7 {
				dAtA18[j17] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j17++
			}
			dAtA18[j17] = uint8(num)
			j17++
		}
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(j17))
		i += copy(dAtA[i:], dAtA18[:j17])
	}
	return i, nil
}

func (m *FlowMonitorRuleSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlowMonitorRuleSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.Meta.Size()))
		n19, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	if m.ExportConfigId != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.ExportConfigId.Size()))
		n20, err := m.ExportConfigId.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	if m.SourceMac != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.SourceMac.Size()))
		n21, err := m.SourceMac.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	if m.DestMac != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.DestMac.Size()))
		n22, err := m.DestMac.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	if m.Protocol != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.Protocol))
	}
	if m.SourceIp != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.SourceIp.Size()))
		n23, err := m.SourceIp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	if m.DestIp != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.DestIp.Size()))
		n24, err := m.DestIp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	if m.SourceL4Port != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.SourceL4Port.Size()))
		n25, err := m.SourceL4Port.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	if m.DestL4Port != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.DestL4Port.Size()))
		n26, err := m.DestL4Port.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n26
	}
	if len(m.SourceTags) > 0 {
		dAtA28 := make([]byte, len(m.SourceTags)*10)
		var j27 int
		for _, num := range m.SourceTags {
			for num >= 1<<7 {
				dAtA28[j27] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j27++
			}
			dAtA28[j27] = uint8(num)
			j27++
		}
		dAtA[i] = 0x52
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(j27))
		i += copy(dAtA[i:], dAtA28[:j27])
	}
	if len(m.DestTags) > 0 {
		dAtA30 := make([]byte, len(m.DestTags)*10)
		var j29 int
		for _, num := range m.DestTags {
			for num >= 1<<7 {
				dAtA30[j29] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j29++
			}
			dAtA30[j29] = uint8(num)
			j29++
		}
		dAtA[i] = 0x5a
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(j29))
		i += copy(dAtA[i:], dAtA30[:j29])
	}
	if m.Action != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.Action.Size()))
		n31, err := m.Action.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n31
	}
	return i, nil
}

func (m *FlowMonitorRuleStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlowMonitorRuleStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.Code))
	}
	if len(m.Status) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(len(m.Status)))
		i += copy(dAtA[i:], m.Status)
	}
	if m.ActiveFlows != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.ActiveFlows))
	}
	return i, nil
}

func (m *FlowMonitorRule) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlowMonitorRule) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Spec != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.Spec.Size()))
		n32, err := m.Spec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n32
	}
	if m.Status != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.Status.Size()))
		n33, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n33
	}
	return i, nil
}

func (m *FlowMonitorRuleConfigMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlowMonitorRuleConfigMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Rules) > 0 {
		for _, msg := range m.Rules {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTelemetry(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *FlowMonitorRuleResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlowMonitorRuleResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Status != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.Status))
	}
	if len(m.Rules) > 0 {
		for _, msg := range m.Rules {
			dAtA[i] = 0x12
			i++
			i = encodeVarintTelemetry(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *RSpanSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RSpanSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Intf != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.Intf.Size()))
		n34, err := m.Intf.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n34
	}
	if m.RspanEncap != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.RspanEncap.Size()))
		n35, err := m.RspanEncap.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n35
	}
	return i, nil
}

func (m *ERSpanSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ERSpanSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.DestIp != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.DestIp.Size()))
		n36, err := m.DestIp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n36
	}
	if m.SrcIp != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.SrcIp.Size()))
		n37, err := m.SrcIp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n37
	}
	if len(m.Dscp) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(len(m.Dscp)))
		i += copy(dAtA[i:], m.Dscp)
	}
	if m.SpanId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.SpanId))
	}
	return i, nil
}

func (m *MirrorSessionId) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MirrorSessionId) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SessionId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.SessionId))
	}
	return i, nil
}

func (m *MirrorSessionSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MirrorSessionSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.Meta.Size()))
		n38, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n38
	}
	if m.Id != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.Id.Size()))
		n39, err := m.Id.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n39
	}
	if m.Snaplen != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.Snaplen))
	}
	if m.Destination != nil {
		nn40, err := m.Destination.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn40
	}
	return i, nil
}

func (m *MirrorSessionSpec_LocalSpanIf) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.LocalSpanIf != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.LocalSpanIf.Size()))
		n41, err := m.LocalSpanIf.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n41
	}
	return i, nil
}
func (m *MirrorSessionSpec_RspanSpec) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.RspanSpec != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.RspanSpec.Size()))
		n42, err := m.RspanSpec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n42
	}
	return i, nil
}
func (m *MirrorSessionSpec_ErspanSpec) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ErspanSpec != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.ErspanSpec.Size()))
		n43, err := m.ErspanSpec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n43
	}
	return i, nil
}
func (m *MirrorSessionStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MirrorSessionStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.Code))
	}
	if len(m.Status) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(len(m.Status)))
		i += copy(dAtA[i:], m.Status)
	}
	if m.ActiveFlows != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.ActiveFlows))
	}
	return i, nil
}

func (m *MirrorSession) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MirrorSession) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.ApiStatus))
	}
	if m.Spec != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.Spec.Size()))
		n44, err := m.Spec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n44
	}
	if m.Status != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.Status.Size()))
		n45, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n45
	}
	return i, nil
}

func (m *MirrorSessionConfigMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MirrorSessionConfigMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTelemetry(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *MirrorSessionDeleteMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MirrorSessionDeleteMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTelemetry(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *MirrorSessionResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MirrorSessionResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Status != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.Status))
	}
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0x12
			i++
			i = encodeVarintTelemetry(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func encodeFixed64Telemetry(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Telemetry(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintTelemetry(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *L4Port) Size() (n int) {
	var l int
	_ = l
	if m.Port != 0 {
		n += 1 + sovTelemetry(uint64(m.Port))
	}
	return n
}

func (m *MacAddress) Size() (n int) {
	var l int
	_ = l
	if m.Address != 0 {
		n += 1 + sovTelemetry(uint64(m.Address))
	}
	return n
}

func (m *CollectorSpec) Size() (n int) {
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if m.ExportControlId != nil {
		l = m.ExportControlId.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if m.Encap != nil {
		l = m.Encap.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if m.L2SegHandle != 0 {
		n += 9
	}
	if m.DestIp != nil {
		l = m.DestIp.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if m.SrcIp != nil {
		l = m.SrcIp.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if m.Protocol != 0 {
		n += 1 + sovTelemetry(uint64(m.Protocol))
	}
	if m.DestPort != nil {
		l = m.DestPort.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if m.Format != 0 {
		n += 1 + sovTelemetry(uint64(m.Format))
	}
	if m.TemplateId != 0 {
		n += 1 + sovTelemetry(uint64(m.TemplateId))
	}
	return n
}

func (m *CollectorStatus) Size() (n int) {
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovTelemetry(uint64(m.Code))
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovTelemetry(uint64(l))
	}
	return n
}

func (m *Collector) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovTelemetry(uint64(m.ApiStatus))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	return n
}

func (m *CollectorConfigMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovTelemetry(uint64(l))
		}
	}
	return n
}

func (m *CollectorResponseMsg) Size() (n int) {
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovTelemetry(uint64(m.Status))
	}
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovTelemetry(uint64(l))
		}
	}
	return n
}

func (m *ExportControlId) Size() (n int) {
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if m.Id != 0 {
		n += 1 + sovTelemetry(uint64(m.Id))
	}
	return n
}

func (m *ExportControlSpec) Size() (n int) {
	var l int
	_ = l
	if m.Id != nil {
		l = m.Id.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if m.ActiveTimeout != 0 {
		n += 1 + sovTelemetry(uint64(m.ActiveTimeout))
	}
	if m.InactiveTimeout != 0 {
		n += 1 + sovTelemetry(uint64(m.InactiveTimeout))
	}
	return n
}

func (m *ExportControlStatus) Size() (n int) {
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovTelemetry(uint64(m.Code))
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovTelemetry(uint64(l))
	}
	return n
}

func (m *ExportControl) Size() (n int) {
	var l int
	_ = l
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	return n
}

func (m *ExportControlConfigMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Configs) > 0 {
		for _, e := range m.Configs {
			l = e.Size()
			n += 1 + l + sovTelemetry(uint64(l))
		}
	}
	return n
}

func (m *ExportControlResponseMsg) Size() (n int) {
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovTelemetry(uint64(m.Status))
	}
	if len(m.ExportControl) > 0 {
		for _, e := range m.ExportControl {
			l = e.Size()
			n += 1 + l + sovTelemetry(uint64(l))
		}
	}
	return n
}

func (m *MonitorAction) Size() (n int) {
	var l int
	_ = l
	if len(m.Action) > 0 {
		l = 0
		for _, e := range m.Action {
			l += sovTelemetry(uint64(e))
		}
		n += 1 + sovTelemetry(uint64(l)) + l
	}
	if len(m.AggScheme) > 0 {
		l = 0
		for _, e := range m.AggScheme {
			l += sovTelemetry(uint64(e))
		}
		n += 1 + sovTelemetry(uint64(l)) + l
	}
	if len(m.MirrorDestinations) > 0 {
		l = 0
		for _, e := range m.MirrorDestinations {
			l += sovTelemetry(uint64(e))
		}
		n += 1 + sovTelemetry(uint64(l)) + l
	}
	return n
}

func (m *FlowMonitorRuleSpec) Size() (n int) {
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if m.ExportConfigId != nil {
		l = m.ExportConfigId.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if m.SourceMac != nil {
		l = m.SourceMac.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if m.DestMac != nil {
		l = m.DestMac.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if m.Protocol != 0 {
		n += 1 + sovTelemetry(uint64(m.Protocol))
	}
	if m.SourceIp != nil {
		l = m.SourceIp.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if m.DestIp != nil {
		l = m.DestIp.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if m.SourceL4Port != nil {
		l = m.SourceL4Port.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if m.DestL4Port != nil {
		l = m.DestL4Port.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if len(m.SourceTags) > 0 {
		l = 0
		for _, e := range m.SourceTags {
			l += sovTelemetry(uint64(e))
		}
		n += 1 + sovTelemetry(uint64(l)) + l
	}
	if len(m.DestTags) > 0 {
		l = 0
		for _, e := range m.DestTags {
			l += sovTelemetry(uint64(e))
		}
		n += 1 + sovTelemetry(uint64(l)) + l
	}
	if m.Action != nil {
		l = m.Action.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	return n
}

func (m *FlowMonitorRuleStatus) Size() (n int) {
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovTelemetry(uint64(m.Code))
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if m.ActiveFlows != 0 {
		n += 1 + sovTelemetry(uint64(m.ActiveFlows))
	}
	return n
}

func (m *FlowMonitorRule) Size() (n int) {
	var l int
	_ = l
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	return n
}

func (m *FlowMonitorRuleConfigMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Rules) > 0 {
		for _, e := range m.Rules {
			l = e.Size()
			n += 1 + l + sovTelemetry(uint64(l))
		}
	}
	return n
}

func (m *FlowMonitorRuleResponseMsg) Size() (n int) {
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovTelemetry(uint64(m.Status))
	}
	if len(m.Rules) > 0 {
		for _, e := range m.Rules {
			l = e.Size()
			n += 1 + l + sovTelemetry(uint64(l))
		}
	}
	return n
}

func (m *RSpanSpec) Size() (n int) {
	var l int
	_ = l
	if m.Intf != nil {
		l = m.Intf.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if m.RspanEncap != nil {
		l = m.RspanEncap.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	return n
}

func (m *ERSpanSpec) Size() (n int) {
	var l int
	_ = l
	if m.DestIp != nil {
		l = m.DestIp.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if m.SrcIp != nil {
		l = m.SrcIp.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	l = len(m.Dscp)
	if l > 0 {
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if m.SpanId != 0 {
		n += 1 + sovTelemetry(uint64(m.SpanId))
	}
	return n
}

func (m *MirrorSessionId) Size() (n int) {
	var l int
	_ = l
	if m.SessionId != 0 {
		n += 1 + sovTelemetry(uint64(m.SessionId))
	}
	return n
}

func (m *MirrorSessionSpec) Size() (n int) {
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if m.Id != nil {
		l = m.Id.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if m.Snaplen != 0 {
		n += 1 + sovTelemetry(uint64(m.Snaplen))
	}
	if m.Destination != nil {
		n += m.Destination.Size()
	}
	return n
}

func (m *MirrorSessionSpec_LocalSpanIf) Size() (n int) {
	var l int
	_ = l
	if m.LocalSpanIf != nil {
		l = m.LocalSpanIf.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	return n
}
func (m *MirrorSessionSpec_RspanSpec) Size() (n int) {
	var l int
	_ = l
	if m.RspanSpec != nil {
		l = m.RspanSpec.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	return n
}
func (m *MirrorSessionSpec_ErspanSpec) Size() (n int) {
	var l int
	_ = l
	if m.ErspanSpec != nil {
		l = m.ErspanSpec.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	return n
}
func (m *MirrorSessionStatus) Size() (n int) {
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovTelemetry(uint64(m.Code))
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if m.ActiveFlows != 0 {
		n += 1 + sovTelemetry(uint64(m.ActiveFlows))
	}
	return n
}

func (m *MirrorSession) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovTelemetry(uint64(m.ApiStatus))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	return n
}

func (m *MirrorSessionConfigMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovTelemetry(uint64(l))
		}
	}
	return n
}

func (m *MirrorSessionDeleteMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovTelemetry(uint64(l))
		}
	}
	return n
}

func (m *MirrorSessionResponseMsg) Size() (n int) {
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovTelemetry(uint64(m.Status))
	}
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovTelemetry(uint64(l))
		}
	}
	return n
}

func sovTelemetry(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozTelemetry(x uint64) (n int) {
	return sovTelemetry(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *L4Port) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: L4Port: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: L4Port: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			m.Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Port |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MacAddress) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MacAddress: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MacAddress: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			m.Address = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Address |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CollectorSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CollectorSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CollectorSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &ObjectMeta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExportControlId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExportControlId == nil {
				m.ExportControlId = &ExportControlId{}
			}
			if err := m.ExportControlId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Encap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Encap == nil {
				m.Encap = &EncapInfo{}
			}
			if err := m.Encap.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field L2SegHandle", wireType)
			}
			m.L2SegHandle = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			m.L2SegHandle = uint64(dAtA[iNdEx-8])
			m.L2SegHandle |= uint64(dAtA[iNdEx-7]) << 8
			m.L2SegHandle |= uint64(dAtA[iNdEx-6]) << 16
			m.L2SegHandle |= uint64(dAtA[iNdEx-5]) << 24
			m.L2SegHandle |= uint64(dAtA[iNdEx-4]) << 32
			m.L2SegHandle |= uint64(dAtA[iNdEx-3]) << 40
			m.L2SegHandle |= uint64(dAtA[iNdEx-2]) << 48
			m.L2SegHandle |= uint64(dAtA[iNdEx-1]) << 56
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestIp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DestIp == nil {
				m.DestIp = &IPAddress{}
			}
			if err := m.DestIp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcIp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SrcIp == nil {
				m.SrcIp = &IPAddress{}
			}
			if err := m.SrcIp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			m.Protocol = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Protocol |= (IPProtocol(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestPort", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DestPort == nil {
				m.DestPort = &L4Port{}
			}
			if err := m.DestPort.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Format", wireType)
			}
			m.Format = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Format |= (ExportFormat(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TemplateId", wireType)
			}
			m.TemplateId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TemplateId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CollectorStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CollectorStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CollectorStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (CollectorStatus_CollectorStatusCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Collector) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Collector: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Collector: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &CollectorSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &CollectorStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CollectorConfigMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CollectorConfigMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CollectorConfigMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &CollectorSpec{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CollectorResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CollectorResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CollectorResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &Collector{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExportControlId) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExportControlId: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExportControlId: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &ObjectMeta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExportControlSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExportControlSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExportControlSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Id == nil {
				m.Id = &ExportControlId{}
			}
			if err := m.Id.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActiveTimeout", wireType)
			}
			m.ActiveTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ActiveTimeout |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InactiveTimeout", wireType)
			}
			m.InactiveTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InactiveTimeout |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExportControlStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExportControlStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExportControlStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (ExportControlStatus_ExportControlStatusCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExportControl) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExportControl: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExportControl: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &ExportControlSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &ExportControlStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExportControlConfigMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExportControlConfigMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExportControlConfigMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Configs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Configs = append(m.Configs, &ExportControlSpec{})
			if err := m.Configs[len(m.Configs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExportControlResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExportControlResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExportControlResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExportControl", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExportControl = append(m.ExportControl, &ExportControl{})
			if err := m.ExportControl[len(m.ExportControl)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MonitorAction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MonitorAction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MonitorAction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v RuleAction
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTelemetry
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (RuleAction(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Action = append(m.Action, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTelemetry
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTelemetry
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v RuleAction
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTelemetry
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (RuleAction(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Action = append(m.Action, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
		case 2:
			if wireType == 0 {
				var v AggregationScheme
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTelemetry
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (AggregationScheme(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.AggScheme = append(m.AggScheme, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTelemetry
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTelemetry
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v AggregationScheme
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTelemetry
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (AggregationScheme(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.AggScheme = append(m.AggScheme, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field AggScheme", wireType)
			}
		case 3:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTelemetry
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.MirrorDestinations = append(m.MirrorDestinations, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTelemetry
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTelemetry
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTelemetry
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.MirrorDestinations = append(m.MirrorDestinations, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field MirrorDestinations", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlowMonitorRuleSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlowMonitorRuleSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlowMonitorRuleSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &ObjectMeta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExportConfigId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExportConfigId == nil {
				m.ExportConfigId = &ExportControlId{}
			}
			if err := m.ExportConfigId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceMac", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SourceMac == nil {
				m.SourceMac = &MacAddress{}
			}
			if err := m.SourceMac.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestMac", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DestMac == nil {
				m.DestMac = &MacAddress{}
			}
			if err := m.DestMac.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			m.Protocol = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Protocol |= (IPProtocol(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceIp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SourceIp == nil {
				m.SourceIp = &IPPrefix{}
			}
			if err := m.SourceIp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestIp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DestIp == nil {
				m.DestIp = &IPPrefix{}
			}
			if err := m.DestIp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceL4Port", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SourceL4Port == nil {
				m.SourceL4Port = &L4Port{}
			}
			if err := m.SourceL4Port.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestL4Port", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DestL4Port == nil {
				m.DestL4Port = &L4Port{}
			}
			if err := m.DestL4Port.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTelemetry
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SourceTags = append(m.SourceTags, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTelemetry
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTelemetry
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTelemetry
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SourceTags = append(m.SourceTags, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceTags", wireType)
			}
		case 11:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTelemetry
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.DestTags = append(m.DestTags, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTelemetry
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTelemetry
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTelemetry
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.DestTags = append(m.DestTags, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field DestTags", wireType)
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Action == nil {
				m.Action = &MonitorAction{}
			}
			if err := m.Action.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlowMonitorRuleStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlowMonitorRuleStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlowMonitorRuleStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (FlowMonitorRuleStatus_FlowMonitorRuleStatusCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActiveFlows", wireType)
			}
			m.ActiveFlows = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ActiveFlows |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlowMonitorRule) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlowMonitorRule: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlowMonitorRule: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &FlowMonitorRuleSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &FlowMonitorRuleStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlowMonitorRuleConfigMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlowMonitorRuleConfigMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlowMonitorRuleConfigMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rules = append(m.Rules, &FlowMonitorRuleSpec{})
			if err := m.Rules[len(m.Rules)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlowMonitorRuleResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlowMonitorRuleResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlowMonitorRuleResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rules = append(m.Rules, &FlowMonitorRule{})
			if err := m.Rules[len(m.Rules)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RSpanSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RSpanSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RSpanSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Intf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Intf == nil {
				m.Intf = &InterfaceKeyHandle{}
			}
			if err := m.Intf.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RspanEncap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RspanEncap == nil {
				m.RspanEncap = &EncapInfo{}
			}
			if err := m.RspanEncap.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ERSpanSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ERSpanSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ERSpanSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestIp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DestIp == nil {
				m.DestIp = &IPAddress{}
			}
			if err := m.DestIp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcIp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SrcIp == nil {
				m.SrcIp = &IPAddress{}
			}
			if err := m.SrcIp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dscp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Dscp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpanId", wireType)
			}
			m.SpanId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SpanId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MirrorSessionId) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MirrorSessionId: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MirrorSessionId: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionId", wireType)
			}
			m.SessionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SessionId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MirrorSessionSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MirrorSessionSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MirrorSessionSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &ObjectMeta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Id == nil {
				m.Id = &MirrorSessionId{}
			}
			if err := m.Id.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Snaplen", wireType)
			}
			m.Snaplen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Snaplen |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalSpanIf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &InterfaceKeyHandle{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Destination = &MirrorSessionSpec_LocalSpanIf{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RspanSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RSpanSpec{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Destination = &MirrorSessionSpec_RspanSpec{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErspanSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ERSpanSpec{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Destination = &MirrorSessionSpec_ErspanSpec{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MirrorSessionStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MirrorSessionStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MirrorSessionStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (MirrorSessionStatus_MirrorSessionStatusCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActiveFlows", wireType)
			}
			m.ActiveFlows = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ActiveFlows |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MirrorSession) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MirrorSession: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MirrorSession: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &MirrorSessionSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &MirrorSessionStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MirrorSessionConfigMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MirrorSessionConfigMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MirrorSessionConfigMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &MirrorSessionSpec{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MirrorSessionDeleteMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MirrorSessionDeleteMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MirrorSessionDeleteMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &MirrorSessionId{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MirrorSessionResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MirrorSessionResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MirrorSessionResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &MirrorSession{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTelemetry(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthTelemetry
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowTelemetry
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipTelemetry(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthTelemetry = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTelemetry   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("telemetry.proto", fileDescriptorTelemetry) }

var fileDescriptorTelemetry = []byte{
	// 1883 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x58, 0xcd, 0x73, 0xe3, 0x48,
	0x15, 0x8f, 0x6c, 0xc7, 0x1f, 0xcf, 0xb1, 0xad, 0x74, 0x66, 0x67, 0x4c, 0x98, 0xcd, 0x64, 0xb5,
	0xb5, 0x4b, 0x36, 0xb5, 0x9b, 0x09, 0xde, 0x30, 0x7c, 0x56, 0x51, 0x1e, 0x8f, 0x33, 0x11, 0xc4,
	0x1f, 0xd5, 0x76, 0x86, 0xad, 0x39, 0xac, 0xd0, 0xc8, 0x6d, 0x47, 0xbb, 0xb2, 0x25, 0x24, 0x85,
	0x9d, 0x70, 0xe1, 0x02, 0xdc, 0x38, 0x70, 0xe3, 0xc4, 0x1f, 0x40, 0xf1, 0x37, 0x70, 0x86, 0x03,
	0xd4, 0x5c, 0xb9, 0x51, 0xc3, 0xbf, 0xc1, 0x81, 0x52, 0x77, 0x4b, 0x96, 0x64, 0xc9, 0x4e, 0x82,
	0xf7, 0x64, 0xf5, 0x7b, 0xbf, 0xf7, 0xd1, 0xaf, 0x5f, 0xbf, 0x7e, 0xcf, 0x50, 0x73, 0x89, 0x41,
	0xa6, 0xc4, 0xb5, 0xaf, 0x8f, 0x2c, 0xdb, 0x74, 0x4d, 0x54, 0x0a, 0x08, 0xbb, 0x65, 0xf7, 0xda,
	0x22, 0x0e, 0xa3, 0xef, 0x16, 0xbf, 0xbc, 0x64, 0x5f, 0xd2, 0x43, 0xc8, 0x9f, 0x9f, 0xf4, 0x4d,
	0xdb, 0x45, 0x08, 0x72, 0x96, 0x69, 0xbb, 0x75, 0x61, 0x5f, 0x38, 0xa8, 0x60, 0xfa, 0x2d, 0x7d,
	0x08, 0xd0, 0x51, 0xb5, 0xe6, 0x68, 0x64, 0x13, 0xc7, 0x41, 0x75, 0x28, 0xa8, 0xec, 0x93, 0x82,
	0x72, 0xd8, 0x5f, 0x4a, 0xff, 0xc8, 0x42, 0xa5, 0x65, 0x1a, 0x06, 0xd1, 0x5c, 0xd3, 0x1e, 0x58,
	0x44, 0x43, 0x1f, 0x40, 0x6e, 0x4a, 0x5c, 0x95, 0x02, 0xcb, 0x8d, 0xed, 0x23, 0x66, 0xbd, 0xf7,
	0xea, 0x0b, 0xa2, 0xb9, 0x1d, 0xe2, 0xaa, 0x98, 0xb2, 0x51, 0x1b, 0x44, 0xf2, 0xda, 0x33, 0xa5,
	0x68, 0xe6, 0xcc, 0xb5, 0x4d, 0x43, 0x1e, 0xd5, 0x33, 0x54, 0x64, 0xf7, 0x68, 0xbe, 0x99, 0x36,
	0x85, 0xb4, 0x7c, 0x04, 0xae, 0x91, 0x28, 0x01, 0x7d, 0x08, 0x9b, 0x64, 0xa6, 0xa9, 0x56, 0x3d,
	0x4b, 0x65, 0x45, 0x6e, 0xae, 0xed, 0xd1, 0xe4, 0xd9, 0xd8, 0xc4, 0x8c, 0x8d, 0xde, 0x83, 0x2d,
	0xa3, 0xe1, 0x90, 0x89, 0x72, 0xa9, 0xce, 0x46, 0x06, 0xa9, 0xe7, 0xf6, 0x85, 0x83, 0x3c, 0x2e,
	0x53, 0xda, 0x19, 0x25, 0xa1, 0x8f, 0xa0, 0x30, 0x22, 0x8e, 0xab, 0xe8, 0x56, 0x7d, 0x33, 0xa2,
	0x4c, 0xee, 0xf3, 0x38, 0xe0, 0xbc, 0x07, 0x90, 0x2d, 0xf4, 0x2d, 0xc8, 0x3b, 0xb6, 0xe6, 0x21,
	0xf3, 0x29, 0xc8, 0x4d, 0xc7, 0xd6, 0x64, 0x0b, 0x7d, 0x02, 0x45, 0x1a, 0x6d, 0xcd, 0x34, 0xea,
	0x85, 0x7d, 0xe1, 0xa0, 0x1a, 0x04, 0x44, 0xee, 0xf7, 0x39, 0x03, 0x07, 0x10, 0x74, 0x04, 0x25,
	0xea, 0x02, 0x3d, 0x8e, 0xa2, 0x1f, 0xc0, 0x20, 0x1a, 0xec, 0xbc, 0x70, 0xd1, 0xc3, 0xd0, 0x93,
	0x7b, 0x0c, 0xf9, 0xb1, 0x69, 0x4f, 0x55, 0xb7, 0x5e, 0xa2, 0xca, 0x1f, 0x2c, 0x84, 0xee, 0x94,
	0xb2, 0x31, 0x87, 0xa1, 0x47, 0x50, 0x76, 0xc9, 0xd4, 0x32, 0x54, 0x97, 0x28, 0xfa, 0xa8, 0x0e,
	0xf4, 0xc4, 0xc1, 0x27, 0xc9, 0x23, 0xe9, 0xef, 0x02, 0xd4, 0xe6, 0xe7, 0xe9, 0xaa, 0xee, 0x95,
	0x83, 0x9e, 0x42, 0x4e, 0x33, 0x47, 0x84, 0x9e, 0x68, 0xb5, 0x71, 0x14, 0xb2, 0x11, 0x43, 0xc6,
	0xd7, 0x2d, 0x73, 0x44, 0x30, 0x95, 0x45, 0xf7, 0x21, 0xef, 0x50, 0x1a, 0x3d, 0xe4, 0x12, 0xe6,
	0x2b, 0xe9, 0x25, 0xec, 0x24, 0x08, 0xa1, 0x32, 0x14, 0x06, 0x17, 0xad, 0x56, 0x7b, 0x30, 0x10,
	0x37, 0x10, 0x82, 0xaa, 0xdc, 0x7d, 0xd1, 0x3c, 0x97, 0x9f, 0x29, 0xad, 0x5e, 0xf7, 0x54, 0x7e,
	0x2e, 0x0a, 0x48, 0x84, 0xad, 0x61, 0xbb, 0xd3, 0x57, 0x4e, 0x9b, 0xf2, 0xf9, 0x05, 0x6e, 0x8b,
	0x19, 0x8f, 0xd2, 0x6f, 0xe3, 0x4e, 0x40, 0xc9, 0x4a, 0x7f, 0x12, 0xa0, 0x14, 0x28, 0x47, 0x8f,
	0x01, 0x54, 0x4b, 0x57, 0xb8, 0x17, 0x6c, 0x2f, 0xfe, 0xb9, 0x35, 0x2d, 0x9d, 0x19, 0xc7, 0x25,
	0xd5, 0xff, 0x44, 0x1f, 0x43, 0xce, 0xb1, 0x88, 0xc6, 0xb3, 0xb2, 0x9e, 0xb8, 0x6d, 0x8b, 0x68,
	0x98, 0xa2, 0x50, 0x23, 0xd8, 0x60, 0x76, 0x21, 0x8b, 0x63, 0x3b, 0x0c, 0x36, 0x7f, 0x06, 0x28,
	0x60, 0xb5, 0xcc, 0xd9, 0x58, 0x9f, 0x74, 0x9c, 0x09, 0x6a, 0x40, 0xc1, 0x26, 0xbf, 0xb8, 0x22,
	0x8e, 0x77, 0x23, 0xb3, 0x4b, 0x4d, 0xfb, 0x40, 0xc9, 0x86, 0x7b, 0x01, 0x07, 0x13, 0xc7, 0x32,
	0x67, 0x0e, 0xf1, 0x74, 0x1d, 0x04, 0x5e, 0xa5, 0x6d, 0x98, 0xf3, 0xd1, 0x31, 0x14, 0x6d, 0x2e,
	0x58, 0xcf, 0x50, 0xb3, 0xf7, 0x92, 0xcc, 0xe2, 0x00, 0x25, 0x9d, 0x41, 0x2d, 0x76, 0x3d, 0x6f,
	0x7a, 0xf7, 0xab, 0x90, 0xe1, 0xb7, 0x3d, 0x87, 0x33, 0xf2, 0x48, 0xfa, 0x83, 0x00, 0xdb, 0x11,
	0x55, 0xb4, 0x90, 0x1c, 0x52, 0x94, 0xb0, 0xb2, 0x26, 0x64, 0xa8, 0xe1, 0xaa, 0xaa, 0xb9, 0xfa,
	0x2f, 0x89, 0xe2, 0xea, 0x53, 0x62, 0x5e, 0xb9, 0x54, 0x7b, 0x05, 0x57, 0x18, 0x75, 0xc8, 0x88,
	0xe8, 0x23, 0x10, 0xf5, 0x59, 0x0c, 0x98, 0xa5, 0xc0, 0x9a, 0x4f, 0xe7, 0x50, 0xe9, 0x5f, 0x02,
	0xec, 0x44, 0x7d, 0x62, 0x71, 0xfa, 0x49, 0xe4, 0x32, 0x3c, 0x49, 0xf3, 0x8b, 0x5f, 0x88, 0x04,
	0xda, 0x0d, 0x2e, 0xc5, 0xe7, 0xf0, 0x20, 0x45, 0x70, 0x3d, 0x17, 0xe3, 0x1a, 0x2a, 0x11, 0xfd,
	0xe8, 0x98, 0xa7, 0x3a, 0x0b, 0xf6, 0xc3, 0xd4, 0x4d, 0xcd, 0xd3, 0xfd, 0x49, 0xc4, 0xf5, 0x72,
	0x63, 0x6f, 0x79, 0x20, 0x82, 0xad, 0xf5, 0xe1, 0x7e, 0x84, 0x3d, 0x4f, 0xfb, 0x27, 0x50, 0xd0,
	0xe8, 0xc2, 0xe1, 0x69, 0xbf, 0xdc, 0x0d, 0x1f, 0x2c, 0xfd, 0x56, 0x80, 0x7a, 0x84, 0x7d, 0xb7,
	0xfc, 0xff, 0x31, 0x54, 0xa3, 0xef, 0x11, 0xbf, 0x05, 0xf5, 0x34, 0x2f, 0x70, 0x25, 0xf2, 0x16,
	0x49, 0x7f, 0x11, 0xa0, 0xd2, 0x31, 0x67, 0xba, 0x6b, 0xda, 0x4d, 0xcd, 0xd5, 0xcd, 0x19, 0xfa,
	0x04, 0xf2, 0x2a, 0xfd, 0xa2, 0x1b, 0xaa, 0x36, 0xde, 0x09, 0xa9, 0xc2, 0x57, 0x06, 0x61, 0x30,
	0xcc, 0x41, 0xe8, 0x87, 0x00, 0xea, 0x64, 0xa2, 0x38, 0xda, 0x25, 0x99, 0xb2, 0x3b, 0x58, 0x8d,
	0xc4, 0xa0, 0x39, 0x99, 0xd8, 0x64, 0xa2, 0x7a, 0xd8, 0x01, 0xc5, 0xe0, 0x92, 0x3a, 0x99, 0xb0,
	0x4f, 0xf4, 0x18, 0x76, 0xa6, 0xba, 0x6d, 0x9b, 0xb6, 0xe2, 0x3d, 0x0e, 0xfa, 0x8c, 0xc2, 0xbc,
	0x5a, 0x94, 0x3d, 0xa8, 0x60, 0xc4, 0x58, 0xcf, 0x42, 0x1c, 0xe9, 0x9f, 0x39, 0xd8, 0x39, 0x35,
	0xcc, 0xaf, 0xb8, 0xcb, 0x9e, 0x3f, 0xb7, 0x79, 0xbe, 0x5b, 0x50, 0x9b, 0x87, 0x6b, 0xac, 0x4f,
	0x6e, 0xf4, 0x7a, 0x57, 0x83, 0x88, 0x51, 0x09, 0x74, 0x02, 0xe0, 0x98, 0x57, 0xb6, 0x46, 0x94,
	0xa9, 0xaa, 0xf1, 0xba, 0x19, 0x0e, 0xd2, 0xbc, 0x03, 0xc1, 0x25, 0x06, 0xec, 0xa8, 0x9a, 0x57,
	0xa9, 0xe8, 0x23, 0xe9, 0xc9, 0xe4, 0x96, 0xc9, 0xd0, 0xe7, 0xdc, 0x93, 0x08, 0xbf, 0xc2, 0x9b,
	0xab, 0x5f, 0xe1, 0x8f, 0x81, 0x5b, 0x9b, 0x3f, 0xf0, 0xb5, 0x10, 0x9e, 0x8c, 0xf5, 0xd7, 0xb8,
	0xc8, 0x10, 0xb2, 0x85, 0x0e, 0xe6, 0x6d, 0x43, 0x21, 0x19, 0xeb, 0x77, 0x0d, 0xdf, 0x85, 0x2a,
	0xd7, 0x6b, 0x9c, 0xac, 0x78, 0xe2, 0xb7, 0x18, 0x90, 0x37, 0x68, 0x9f, 0xc2, 0x16, 0x35, 0xe1,
	0x8b, 0x95, 0xd2, 0xc4, 0xc0, 0x83, 0x71, 0xa1, 0x47, 0x50, 0xe6, 0xd6, 0x5c, 0x75, 0xe2, 0xd4,
	0x61, 0x3f, 0x7b, 0x90, 0xc3, 0x3c, 0xde, 0x43, 0x75, 0xe2, 0xa0, 0x6f, 0xf2, 0x66, 0x83, 0xb2,
	0xcb, 0x94, 0x4d, 0x03, 0x4b, 0x99, 0xc7, 0x41, 0xee, 0x6e, 0x2d, 0x3c, 0x7f, 0x91, 0x2c, 0xf7,
	0xd3, 0x57, 0xfa, 0x4d, 0x06, 0xde, 0x89, 0x27, 0x14, 0xbb, 0x5a, 0xdd, 0x48, 0xc9, 0xfc, 0x41,
	0x48, 0x53, 0x22, 0x3e, 0x99, 0xba, 0xba, 0x6c, 0x7a, 0x3d, 0x1e, 0xaf, 0xed, 0x63, 0xc3, 0xfc,
	0xca, 0xe1, 0x95, 0xbd, 0xcc, 0x68, 0x9e, 0x52, 0x47, 0xfa, 0x39, 0x7c, 0x23, 0x55, 0xfb, 0x7a,
	0x6a, 0xeb, 0xaf, 0xa1, 0x16, 0xb3, 0x80, 0x1a, 0x91, 0xea, 0xba, 0xb7, 0x64, 0xff, 0xf3, 0xfa,
	0xfa, 0xbd, 0x58, 0x7d, 0xdd, 0x5f, 0x15, 0xb5, 0x50, 0x85, 0xad, 0xc7, 0x00, 0xf3, 0x1a, 0x7b,
	0x02, 0x9b, 0xf6, 0x95, 0x41, 0xfc, 0x0a, 0xbb, 0xca, 0x15, 0x06, 0x96, 0x5e, 0xc3, 0x6e, 0x8c,
	0x7b, 0xd7, 0x16, 0x83, 0x5b, 0x67, 0x95, 0x75, 0x37, 0xdd, 0xba, 0x6f, 0xf9, 0x0b, 0x28, 0xe1,
	0x81, 0xa5, 0xce, 0x78, 0x3f, 0x90, 0xd3, 0x67, 0xee, 0x98, 0x87, 0xf1, 0xfe, 0xd1, 0x97, 0x97,
	0x47, 0xf2, 0xcc, 0x25, 0xf6, 0x58, 0xd5, 0xc8, 0x4f, 0xc9, 0x35, 0xeb, 0xe2, 0x31, 0xc5, 0xa0,
	0x6f, 0x43, 0xd9, 0x76, 0x2c, 0x75, 0xa6, 0xb0, 0xe1, 0x20, 0x93, 0x32, 0x1c, 0x00, 0x05, 0xd1,
	0xb5, 0xf4, 0x7b, 0x01, 0xa0, 0x3d, 0xb7, 0x16, 0x9a, 0x06, 0x84, 0x1b, 0x4f, 0x03, 0x99, 0xe5,
	0xd3, 0x00, 0x82, 0xdc, 0xc8, 0xd1, 0xd8, 0xac, 0x52, 0xc2, 0xf4, 0x1b, 0x3d, 0x80, 0x02, 0x75,
	0x54, 0x1f, 0xd1, 0x62, 0x56, 0xc1, 0x79, 0x6f, 0x29, 0x8f, 0xa4, 0x63, 0xa8, 0x75, 0x68, 0xd9,
	0x1e, 0x10, 0xc7, 0xd1, 0xcd, 0x99, 0x3c, 0x42, 0xef, 0x02, 0x38, 0x6c, 0xe1, 0xc1, 0xd9, 0xb8,
	0x56, 0x72, 0x7c, 0xb6, 0xf4, 0xd7, 0x0c, 0x6c, 0x47, 0x44, 0x6e, 0x53, 0xd0, 0x0f, 0x21, 0xa3,
	0x27, 0xd5, 0xf0, 0x98, 0x0f, 0x38, 0xa3, 0x8f, 0xbc, 0x71, 0xd0, 0x99, 0xa9, 0x96, 0x41, 0x66,
	0xfc, 0x8e, 0xf9, 0x4b, 0xf4, 0x23, 0xa8, 0x18, 0xa6, 0xa6, 0x1a, 0x0a, 0xdb, 0xd3, 0x98, 0x17,
	0xe8, 0x94, 0xc3, 0x3a, 0xdb, 0xc0, 0x65, 0x0a, 0xf7, 0xa2, 0x2e, 0x8f, 0xd1, 0x77, 0x80, 0x1d,
	0x88, 0x42, 0xaf, 0x0b, 0x1b, 0xc2, 0xc2, 0x5d, 0x68, 0x70, 0x3a, 0x67, 0x1b, 0xb8, 0x44, 0x91,
	0x03, 0x76, 0x57, 0xca, 0x24, 0x24, 0x97, 0x5f, 0x78, 0x13, 0xda, 0x61, 0x41, 0x20, 0x81, 0xe4,
	0xd3, 0x0a, 0x94, 0x43, 0xcf, 0xa5, 0xf4, 0x5f, 0x01, 0x76, 0xa2, 0x01, 0x5c, 0xd5, 0xf3, 0x25,
	0xa0, 0x93, 0x68, 0x77, 0x2c, 0x5e, 0x9b, 0xd1, 0xe2, 0xf5, 0x39, 0x3c, 0x48, 0xd1, 0xbd, 0x9e,
	0xd2, 0xf5, 0x67, 0xaf, 0x83, 0x09, 0x1b, 0xb8, 0xfd, 0xcc, 0x74, 0x1c, 0x99, 0x99, 0x1e, 0xa6,
	0x46, 0x2a, 0xa9, 0x91, 0xcc, 0x2e, 0x94, 0xc7, 0x84, 0xdd, 0x86, 0x1b, 0xc9, 0x08, 0x3b, 0xd2,
	0x48, 0x46, 0xe7, 0xa7, 0xe5, 0x6e, 0x04, 0x33, 0x54, 0x37, 0xa6, 0xf1, 0x19, 0x31, 0x88, 0x4b,
	0x58, 0xd9, 0x8c, 0x69, 0x5c, 0x76, 0x41, 0x02, 0x7d, 0xbf, 0x82, 0x7a, 0x84, 0x77, 0xb7, 0xa2,
	0x79, 0xb2, 0x30, 0x97, 0xd5, 0xd3, 0x8c, 0xcf, 0x67, 0xb3, 0xc3, 0x03, 0xd8, 0x0a, 0xcf, 0xff,
	0xa8, 0x04, 0x9b, 0x72, 0xff, 0x54, 0xfe, 0x4c, 0xdc, 0x40, 0x15, 0x28, 0x75, 0xdb, 0xc3, 0xd3,
	0xf3, 0xde, 0xcf, 0x5e, 0x7c, 0x5f, 0x14, 0x0e, 0x8f, 0x01, 0xe6, 0xbd, 0x28, 0xba, 0x0f, 0xa8,
	0xd5, 0x3b, 0x3f, 0x6f, 0xb7, 0x86, 0x8a, 0x87, 0x50, 0x06, 0xc3, 0xe6, 0xd0, 0x4b, 0x29, 0x80,
	0x7c, 0x47, 0xc6, 0xb8, 0x87, 0x45, 0xe1, 0xf0, 0x8d, 0x00, 0xdb, 0x0b, 0xbd, 0x28, 0x2a, 0x42,
	0xae, 0xdb, 0xeb, 0xb6, 0xc5, 0x0d, 0xb4, 0x05, 0x45, 0xb9, 0x3f, 0xe8, 0x5d, 0xe0, 0x56, 0x5b,
	0x14, 0xd0, 0x36, 0x54, 0xe4, 0xfe, 0xb3, 0xf6, 0x60, 0x28, 0x77, 0x9b, 0x43, 0xb9, 0xd7, 0x15,
	0x33, 0x9e, 0x32, 0xb9, 0xdf, 0x6f, 0xca, 0x58, 0xcc, 0xa2, 0x1a, 0x94, 0x19, 0x54, 0xe9, 0xf7,
	0xf0, 0x50, 0xcc, 0xa1, 0x7b, 0x20, 0x86, 0xd0, 0x8c, 0xba, 0x49, 0xf3, 0xbb, 0x8d, 0x5f, 0xc8,
	0xad, 0xb6, 0x98, 0xa7, 0xf9, 0x4d, 0xe5, 0x15, 0x9f, 0x56, 0xf0, 0xc4, 0xb8, 0x9e, 0x41, 0xbb,
	0xa5, 0x3c, 0xc7, 0xbd, 0x8b, 0xbe, 0x58, 0xf4, 0x90, 0x9e, 0xb2, 0x10, 0xad, 0xe4, 0xd1, 0x82,
	0xa5, 0x42, 0xbd, 0x80, 0xc6, 0xef, 0x2a, 0x50, 0x1a, 0xfa, 0x41, 0x45, 0x83, 0xd0, 0x5f, 0x20,
	0x2d, 0x9b, 0xa8, 0x2e, 0x41, 0xef, 0x26, 0xcd, 0xc2, 0x41, 0xca, 0xed, 0x3e, 0x4a, 0x1c, 0x95,
	0xe7, 0xe7, 0x2d, 0x6d, 0x44, 0x94, 0x5e, 0x58, 0xa3, 0xf5, 0x28, 0xed, 0x86, 0xfe, 0x7c, 0x3b,
	0xd7, 0x1d, 0x17, 0x2d, 0xe9, 0xbe, 0x6f, 0xeb, 0x24, 0x4b, 0xff, 0x35, 0x38, 0xa9, 0xc4, 0x06,
	0x69, 0x1e, 0xd2, 0xf7, 0xd2, 0x5c, 0x9d, 0x2b, 0x7f, 0x3f, 0x75, 0xf6, 0x5a, 0x6a, 0x80, 0x87,
	0x77, 0x7d, 0x06, 0x2e, 0x40, 0x8c, 0x70, 0x9f, 0x93, 0xe5, 0x91, 0xbe, 0xa1, 0xda, 0xcf, 0x62,
	0x7e, 0xf3, 0x88, 0xaf, 0x41, 0x33, 0x59, 0x68, 0xc5, 0x79, 0xd0, 0xdf, 0x4f, 0xef, 0xb9, 0xe6,
	0x51, 0xf9, 0x60, 0x49, 0x63, 0xb6, 0xc2, 0x0c, 0x0f, 0xfd, 0x7a, 0xcd, 0xbc, 0x5c, 0x98, 0x54,
	0x57, 0xe6, 0xfa, 0x8d, 0x75, 0xbf, 0x02, 0x14, 0xe3, 0x7b, 0x87, 0xfb, 0x75, 0x87, 0x89, 0x9f,
	0xf4, 0x7a, 0xcd, 0x28, 0xb1, 0xe6, 0x25, 0xe1, 0x9e, 0x25, 0xbf, 0x98, 0x91, 0xac, 0x4a, 0x7b,
	0xb2, 0x12, 0x0c, 0x24, 0xdc, 0xb3, 0xff, 0xcf, 0xc0, 0x05, 0x88, 0x11, 0x6e, 0xfc, 0x9e, 0xc5,
	0x9e, 0xda, 0x9b, 0xaa, 0x3d, 0x8b, 0xb5, 0xc5, 0x34, 0x7b, 0xb6, 0xfc, 0x61, 0x60, 0x6a, 0xb9,
	0xd7, 0x77, 0x8d, 0x00, 0x3f, 0xc7, 0xd4, 0x08, 0x04, 0x2d, 0xc4, 0x0d, 0x0d, 0x3c, 0xdd, 0xfd,
	0xdb, 0xdb, 0x3d, 0xe1, 0xcd, 0xdb, 0x3d, 0xe1, 0xdf, 0x6f, 0xf7, 0x84, 0x3f, 0xfe, 0x67, 0x6f,
	0xe3, 0x65, 0xf1, 0x52, 0x35, 0xe8, 0x3f, 0x13, 0xaf, 0xf2, 0xf4, 0xe7, 0xd3, 0xff, 0x05, 0x00,
	0x00, 0xff, 0xff, 0xe8, 0x8f, 0xf9, 0xb6, 0xec, 0x19, 0x00, 0x00,
}
