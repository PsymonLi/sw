// Code generated by protoc-gen-go. DO NOT EDIT.
// source: nic/proto/hal/telemetry.proto

package halproto

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// ExportFormat is a enumeration of export formats supported
type ExportFormat int32

const (
	ExportFormat_IPFIX     ExportFormat = 0
	ExportFormat_NETFLOWV9 ExportFormat = 1
)

var ExportFormat_name = map[int32]string{
	0: "IPFIX",
	1: "NETFLOWV9",
}
var ExportFormat_value = map[string]int32{
	"IPFIX":     0,
	"NETFLOWV9": 1,
}

func (x ExportFormat) String() string {
	return proto.EnumName(ExportFormat_name, int32(x))
}
func (ExportFormat) EnumDescriptor() ([]byte, []int) { return fileDescriptor20, []int{0} }

// RuleAction is an enumeration of support telemetry actions
type RuleAction int32

const (
	RuleAction_COLLECT_FLOW_STATS RuleAction = 0
	RuleAction_MIRROR             RuleAction = 1
)

var RuleAction_name = map[int32]string{
	0: "COLLECT_FLOW_STATS",
	1: "MIRROR",
}
var RuleAction_value = map[string]int32{
	"COLLECT_FLOW_STATS": 0,
	"MIRROR":             1,
}

func (x RuleAction) String() string {
	return proto.EnumName(RuleAction_name, int32(x))
}
func (RuleAction) EnumDescriptor() ([]byte, []int) { return fileDescriptor20, []int{1} }

// AggregationScheme is an enumeration of aggregation schemes supported
type AggregationScheme int32

const (
	AggregationScheme_NONE             AggregationScheme = 0
	AggregationScheme_IPSOURCE         AggregationScheme = 1
	AggregationScheme_IPDESTINATION    AggregationScheme = 2
	AggregationScheme_IPPAIR           AggregationScheme = 3
	AggregationScheme_SOURCE_PORT      AggregationScheme = 4
	AggregationScheme_DESTINATION_PORT AggregationScheme = 5
	AggregationScheme_SERVICE          AggregationScheme = 6
	AggregationScheme_IPPAIR_SERVICE   AggregationScheme = 7
	AggregationScheme_SOURCE_SEC_GROUP AggregationScheme = 8
	AggregationScheme_DEST_SEC_GROUP   AggregationScheme = 9
	AggregationScheme_SEC_GROUP_PAIR   AggregationScheme = 10
)

var AggregationScheme_name = map[int32]string{
	0:  "NONE",
	1:  "IPSOURCE",
	2:  "IPDESTINATION",
	3:  "IPPAIR",
	4:  "SOURCE_PORT",
	5:  "DESTINATION_PORT",
	6:  "SERVICE",
	7:  "IPPAIR_SERVICE",
	8:  "SOURCE_SEC_GROUP",
	9:  "DEST_SEC_GROUP",
	10: "SEC_GROUP_PAIR",
}
var AggregationScheme_value = map[string]int32{
	"NONE":             0,
	"IPSOURCE":         1,
	"IPDESTINATION":    2,
	"IPPAIR":           3,
	"SOURCE_PORT":      4,
	"DESTINATION_PORT": 5,
	"SERVICE":          6,
	"IPPAIR_SERVICE":   7,
	"SOURCE_SEC_GROUP": 8,
	"DEST_SEC_GROUP":   9,
	"SEC_GROUP_PAIR":   10,
}

func (x AggregationScheme) String() string {
	return proto.EnumName(AggregationScheme_name, int32(x))
}
func (AggregationScheme) EnumDescriptor() ([]byte, []int) { return fileDescriptor20, []int{2} }

// CollectorStatus Codes
type CollectorStatus_CollectorStatusCode int32

const (
	CollectorStatus_SUCCESS        CollectorStatus_CollectorStatusCode = 0
	CollectorStatus_INVALID_CONFIG CollectorStatus_CollectorStatusCode = 1
	CollectorStatus_TEMP_FAILURE   CollectorStatus_CollectorStatusCode = 2
	CollectorStatus_PERM_FAILURE   CollectorStatus_CollectorStatusCode = 3
)

var CollectorStatus_CollectorStatusCode_name = map[int32]string{
	0: "SUCCESS",
	1: "INVALID_CONFIG",
	2: "TEMP_FAILURE",
	3: "PERM_FAILURE",
}
var CollectorStatus_CollectorStatusCode_value = map[string]int32{
	"SUCCESS":        0,
	"INVALID_CONFIG": 1,
	"TEMP_FAILURE":   2,
	"PERM_FAILURE":   3,
}

func (x CollectorStatus_CollectorStatusCode) String() string {
	return proto.EnumName(CollectorStatus_CollectorStatusCode_name, int32(x))
}
func (CollectorStatus_CollectorStatusCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor20, []int{3, 0}
}

// Export control status codes
type ExportControlStatus_ExportControlStatusCode int32

const (
	ExportControlStatus_SUCCESS        ExportControlStatus_ExportControlStatusCode = 0
	ExportControlStatus_INVALID_CONFIG ExportControlStatus_ExportControlStatusCode = 1
	ExportControlStatus_TEMP_FAILURE   ExportControlStatus_ExportControlStatusCode = 2
	ExportControlStatus_PERM_FAILURE   ExportControlStatus_ExportControlStatusCode = 3
)

var ExportControlStatus_ExportControlStatusCode_name = map[int32]string{
	0: "SUCCESS",
	1: "INVALID_CONFIG",
	2: "TEMP_FAILURE",
	3: "PERM_FAILURE",
}
var ExportControlStatus_ExportControlStatusCode_value = map[string]int32{
	"SUCCESS":        0,
	"INVALID_CONFIG": 1,
	"TEMP_FAILURE":   2,
	"PERM_FAILURE":   3,
}

func (x ExportControlStatus_ExportControlStatusCode) String() string {
	return proto.EnumName(ExportControlStatus_ExportControlStatusCode_name, int32(x))
}
func (ExportControlStatus_ExportControlStatusCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor20, []int{9, 0}
}

// FlowMonitorRule status codes
type FlowMonitorRuleStatus_FlowMonitorRuleStatusCode int32

const (
	FlowMonitorRuleStatus_SUCCESS        FlowMonitorRuleStatus_FlowMonitorRuleStatusCode = 0
	FlowMonitorRuleStatus_INVALID_CONFIG FlowMonitorRuleStatus_FlowMonitorRuleStatusCode = 1
	FlowMonitorRuleStatus_TEMP_FAILURE   FlowMonitorRuleStatus_FlowMonitorRuleStatusCode = 2
	FlowMonitorRuleStatus_PERM_FAILURE   FlowMonitorRuleStatus_FlowMonitorRuleStatusCode = 3
)

var FlowMonitorRuleStatus_FlowMonitorRuleStatusCode_name = map[int32]string{
	0: "SUCCESS",
	1: "INVALID_CONFIG",
	2: "TEMP_FAILURE",
	3: "PERM_FAILURE",
}
var FlowMonitorRuleStatus_FlowMonitorRuleStatusCode_value = map[string]int32{
	"SUCCESS":        0,
	"INVALID_CONFIG": 1,
	"TEMP_FAILURE":   2,
	"PERM_FAILURE":   3,
}

func (x FlowMonitorRuleStatus_FlowMonitorRuleStatusCode) String() string {
	return proto.EnumName(FlowMonitorRuleStatus_FlowMonitorRuleStatusCode_name, int32(x))
}
func (FlowMonitorRuleStatus_FlowMonitorRuleStatusCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor20, []int{15, 0}
}

// Mirror Session  status codes
type MirrorSessionStatus_MirrorSessionStatusCode int32

const (
	MirrorSessionStatus_SUCCESS        MirrorSessionStatus_MirrorSessionStatusCode = 0
	MirrorSessionStatus_INVALID_CONFIG MirrorSessionStatus_MirrorSessionStatusCode = 1
	MirrorSessionStatus_TEMP_FAILURE   MirrorSessionStatus_MirrorSessionStatusCode = 2
	MirrorSessionStatus_PERM_FAILURE   MirrorSessionStatus_MirrorSessionStatusCode = 3
)

var MirrorSessionStatus_MirrorSessionStatusCode_name = map[int32]string{
	0: "SUCCESS",
	1: "INVALID_CONFIG",
	2: "TEMP_FAILURE",
	3: "PERM_FAILURE",
}
var MirrorSessionStatus_MirrorSessionStatusCode_value = map[string]int32{
	"SUCCESS":        0,
	"INVALID_CONFIG": 1,
	"TEMP_FAILURE":   2,
	"PERM_FAILURE":   3,
}

func (x MirrorSessionStatus_MirrorSessionStatusCode) String() string {
	return proto.EnumName(MirrorSessionStatus_MirrorSessionStatusCode_name, int32(x))
}
func (MirrorSessionStatus_MirrorSessionStatusCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor20, []int{23, 0}
}

// L4Port is a representation of the L4 port defined as a nested type for nullability
type L4Port struct {
	Port uint32 `protobuf:"varint,1,opt,name=port" json:"port,omitempty"`
}

func (m *L4Port) Reset()                    { *m = L4Port{} }
func (m *L4Port) String() string            { return proto.CompactTextString(m) }
func (*L4Port) ProtoMessage()               {}
func (*L4Port) Descriptor() ([]byte, []int) { return fileDescriptor20, []int{0} }

func (m *L4Port) GetPort() uint32 {
	if m != nil {
		return m.Port
	}
	return 0
}

// MacAddress is a represenation of the MAC address defined as a nested type for nullability
type MacAddress struct {
	Address uint64 `protobuf:"varint,1,opt,name=address" json:"address,omitempty"`
}

func (m *MacAddress) Reset()                    { *m = MacAddress{} }
func (m *MacAddress) String() string            { return proto.CompactTextString(m) }
func (*MacAddress) ProtoMessage()               {}
func (*MacAddress) Descriptor() ([]byte, []int) { return fileDescriptor20, []int{1} }

func (m *MacAddress) GetAddress() uint64 {
	if m != nil {
		return m.Address
	}
	return 0
}

// CollectorSpec is the configuration specification for a telemetry collector
type CollectorSpec struct {
	Meta            *ObjectMeta      `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	ExportControlId *ExportControlId `protobuf:"bytes,2,opt,name=export_controlId,json=exportControlId" json:"export_controlId,omitempty"`
	DestIp          *IPAddress       `protobuf:"bytes,3,opt,name=dest_ip,json=destIp" json:"dest_ip,omitempty"`
	Protocol        IPProtocol       `protobuf:"varint,4,opt,name=protocol,enum=types.IPProtocol" json:"protocol,omitempty"`
	DestPort        *L4Port          `protobuf:"bytes,5,opt,name=dest_port,json=destPort" json:"dest_port,omitempty"`
	Format          ExportFormat     `protobuf:"varint,6,opt,name=format,enum=telemetry.ExportFormat" json:"format,omitempty"`
	TemplateId      uint32           `protobuf:"varint,7,opt,name=template_id,json=templateId" json:"template_id,omitempty"`
}

func (m *CollectorSpec) Reset()                    { *m = CollectorSpec{} }
func (m *CollectorSpec) String() string            { return proto.CompactTextString(m) }
func (*CollectorSpec) ProtoMessage()               {}
func (*CollectorSpec) Descriptor() ([]byte, []int) { return fileDescriptor20, []int{2} }

func (m *CollectorSpec) GetMeta() *ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *CollectorSpec) GetExportControlId() *ExportControlId {
	if m != nil {
		return m.ExportControlId
	}
	return nil
}

func (m *CollectorSpec) GetDestIp() *IPAddress {
	if m != nil {
		return m.DestIp
	}
	return nil
}

func (m *CollectorSpec) GetProtocol() IPProtocol {
	if m != nil {
		return m.Protocol
	}
	return IPProtocol_IPPROTO_NONE
}

func (m *CollectorSpec) GetDestPort() *L4Port {
	if m != nil {
		return m.DestPort
	}
	return nil
}

func (m *CollectorSpec) GetFormat() ExportFormat {
	if m != nil {
		return m.Format
	}
	return ExportFormat_IPFIX
}

func (m *CollectorSpec) GetTemplateId() uint32 {
	if m != nil {
		return m.TemplateId
	}
	return 0
}

// CollectorSpec is the operational status of the collector
type CollectorStatus struct {
	Code   CollectorStatus_CollectorStatusCode `protobuf:"varint,1,opt,name=code,enum=telemetry.CollectorStatus_CollectorStatusCode" json:"code,omitempty"`
	Status string                              `protobuf:"bytes,2,opt,name=status" json:"status,omitempty"`
}

func (m *CollectorStatus) Reset()                    { *m = CollectorStatus{} }
func (m *CollectorStatus) String() string            { return proto.CompactTextString(m) }
func (*CollectorStatus) ProtoMessage()               {}
func (*CollectorStatus) Descriptor() ([]byte, []int) { return fileDescriptor20, []int{3} }

func (m *CollectorStatus) GetCode() CollectorStatus_CollectorStatusCode {
	if m != nil {
		return m.Code
	}
	return CollectorStatus_SUCCESS
}

func (m *CollectorStatus) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

// Collector is a container that holds both the configuration and the operational
//  state of the collector
type Collector struct {
	Spec   *CollectorSpec   `protobuf:"bytes,1,opt,name=spec" json:"spec,omitempty"`
	Status *CollectorStatus `protobuf:"bytes,2,opt,name=status" json:"status,omitempty"`
}

func (m *Collector) Reset()                    { *m = Collector{} }
func (m *Collector) String() string            { return proto.CompactTextString(m) }
func (*Collector) ProtoMessage()               {}
func (*Collector) Descriptor() ([]byte, []int) { return fileDescriptor20, []int{4} }

func (m *Collector) GetSpec() *CollectorSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *Collector) GetStatus() *CollectorStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

// CollectorConfigsMsg is used in requests and is a batchable request message
type CollectorConfigMsg struct {
	Specs []*CollectorSpec `protobuf:"bytes,1,rep,name=specs" json:"specs,omitempty"`
}

func (m *CollectorConfigMsg) Reset()                    { *m = CollectorConfigMsg{} }
func (m *CollectorConfigMsg) String() string            { return proto.CompactTextString(m) }
func (*CollectorConfigMsg) ProtoMessage()               {}
func (*CollectorConfigMsg) Descriptor() ([]byte, []int) { return fileDescriptor20, []int{5} }

func (m *CollectorConfigMsg) GetSpecs() []*CollectorSpec {
	if m != nil {
		return m.Specs
	}
	return nil
}

// CollectorConfigsMsg message is used as response for API requests.
type CollectorResponseMsg struct {
	Status     ApiStatus    `protobuf:"varint,1,opt,name=status,enum=types.ApiStatus" json:"status,omitempty"`
	Collectors []*Collector `protobuf:"bytes,2,rep,name=collectors" json:"collectors,omitempty"`
}

func (m *CollectorResponseMsg) Reset()                    { *m = CollectorResponseMsg{} }
func (m *CollectorResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*CollectorResponseMsg) ProtoMessage()               {}
func (*CollectorResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptor20, []int{6} }

func (m *CollectorResponseMsg) GetStatus() ApiStatus {
	if m != nil {
		return m.Status
	}
	return ApiStatus_API_STATUS_OK
}

func (m *CollectorResponseMsg) GetCollectors() []*Collector {
	if m != nil {
		return m.Collectors
	}
	return nil
}

// ExportControlId is a identifier for a ExportControl configuration
type ExportControlId struct {
	Meta *ObjectMeta `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	Id   uint64      `protobuf:"varint,2,opt,name=Id" json:"Id,omitempty"`
}

func (m *ExportControlId) Reset()                    { *m = ExportControlId{} }
func (m *ExportControlId) String() string            { return proto.CompactTextString(m) }
func (*ExportControlId) ProtoMessage()               {}
func (*ExportControlId) Descriptor() ([]byte, []int) { return fileDescriptor20, []int{7} }

func (m *ExportControlId) GetMeta() *ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *ExportControlId) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

// ExportControlId is the configuration specification for Export Control
type ExportControlSpec struct {
	Id              *ExportControlId `protobuf:"bytes,1,opt,name=Id" json:"Id,omitempty"`
	ActiveTimeout   uint32           `protobuf:"varint,2,opt,name=active_timeout,json=activeTimeout" json:"active_timeout,omitempty"`
	InactiveTimeout uint32           `protobuf:"varint,3,opt,name=inactive_timeout,json=inactiveTimeout" json:"inactive_timeout,omitempty"`
}

func (m *ExportControlSpec) Reset()                    { *m = ExportControlSpec{} }
func (m *ExportControlSpec) String() string            { return proto.CompactTextString(m) }
func (*ExportControlSpec) ProtoMessage()               {}
func (*ExportControlSpec) Descriptor() ([]byte, []int) { return fileDescriptor20, []int{8} }

func (m *ExportControlSpec) GetId() *ExportControlId {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *ExportControlSpec) GetActiveTimeout() uint32 {
	if m != nil {
		return m.ActiveTimeout
	}
	return 0
}

func (m *ExportControlSpec) GetInactiveTimeout() uint32 {
	if m != nil {
		return m.InactiveTimeout
	}
	return 0
}

// ExportControlStatus is the operational status of the Export Control configuration
type ExportControlStatus struct {
	Code   ExportControlStatus_ExportControlStatusCode `protobuf:"varint,1,opt,name=code,enum=telemetry.ExportControlStatus_ExportControlStatusCode" json:"code,omitempty"`
	Status string                                      `protobuf:"bytes,2,opt,name=status" json:"status,omitempty"`
}

func (m *ExportControlStatus) Reset()                    { *m = ExportControlStatus{} }
func (m *ExportControlStatus) String() string            { return proto.CompactTextString(m) }
func (*ExportControlStatus) ProtoMessage()               {}
func (*ExportControlStatus) Descriptor() ([]byte, []int) { return fileDescriptor20, []int{9} }

func (m *ExportControlStatus) GetCode() ExportControlStatus_ExportControlStatusCode {
	if m != nil {
		return m.Code
	}
	return ExportControlStatus_SUCCESS
}

func (m *ExportControlStatus) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

// ExportControl is a container for the configuration and the operational status for ExportControl
type ExportControl struct {
	Spec   *ExportControlSpec   `protobuf:"bytes,1,opt,name=spec" json:"spec,omitempty"`
	Status *ExportControlStatus `protobuf:"bytes,2,opt,name=status" json:"status,omitempty"`
}

func (m *ExportControl) Reset()                    { *m = ExportControl{} }
func (m *ExportControl) String() string            { return proto.CompactTextString(m) }
func (*ExportControl) ProtoMessage()               {}
func (*ExportControl) Descriptor() ([]byte, []int) { return fileDescriptor20, []int{10} }

func (m *ExportControl) GetSpec() *ExportControlSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *ExportControl) GetStatus() *ExportControlStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

// ExportControlConfigMsg is used as input to RPC call for ExportControl. It is a batchable message
type ExportControlConfigMsg struct {
	Configs []*ExportControlSpec `protobuf:"bytes,1,rep,name=configs" json:"configs,omitempty"`
}

func (m *ExportControlConfigMsg) Reset()                    { *m = ExportControlConfigMsg{} }
func (m *ExportControlConfigMsg) String() string            { return proto.CompactTextString(m) }
func (*ExportControlConfigMsg) ProtoMessage()               {}
func (*ExportControlConfigMsg) Descriptor() ([]byte, []int) { return fileDescriptor20, []int{11} }

func (m *ExportControlConfigMsg) GetConfigs() []*ExportControlSpec {
	if m != nil {
		return m.Configs
	}
	return nil
}

// ExportControlResponseMsg is used in responses for operations on the ExportControl configuration.
type ExportControlResponseMsg struct {
	Status        ApiStatus        `protobuf:"varint,1,opt,name=status,enum=types.ApiStatus" json:"status,omitempty"`
	ExportControl []*ExportControl `protobuf:"bytes,2,rep,name=export_control,json=exportControl" json:"export_control,omitempty"`
}

func (m *ExportControlResponseMsg) Reset()                    { *m = ExportControlResponseMsg{} }
func (m *ExportControlResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*ExportControlResponseMsg) ProtoMessage()               {}
func (*ExportControlResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptor20, []int{12} }

func (m *ExportControlResponseMsg) GetStatus() ApiStatus {
	if m != nil {
		return m.Status
	}
	return ApiStatus_API_STATUS_OK
}

func (m *ExportControlResponseMsg) GetExportControl() []*ExportControl {
	if m != nil {
		return m.ExportControl
	}
	return nil
}

// MonitorAction defines the action for a flow monitor rule
type MonitorAction struct {
	Action             []RuleAction        `protobuf:"varint,1,rep,packed,name=action,enum=telemetry.RuleAction" json:"action,omitempty"`
	AggScheme          []AggregationScheme `protobuf:"varint,2,rep,packed,name=agg_scheme,json=aggScheme,enum=telemetry.AggregationScheme" json:"agg_scheme,omitempty"`
	MirrorDestinations []uint32            `protobuf:"varint,3,rep,packed,name=mirror_destinations,json=mirrorDestinations" json:"mirror_destinations,omitempty"`
}

func (m *MonitorAction) Reset()                    { *m = MonitorAction{} }
func (m *MonitorAction) String() string            { return proto.CompactTextString(m) }
func (*MonitorAction) ProtoMessage()               {}
func (*MonitorAction) Descriptor() ([]byte, []int) { return fileDescriptor20, []int{13} }

func (m *MonitorAction) GetAction() []RuleAction {
	if m != nil {
		return m.Action
	}
	return nil
}

func (m *MonitorAction) GetAggScheme() []AggregationScheme {
	if m != nil {
		return m.AggScheme
	}
	return nil
}

func (m *MonitorAction) GetMirrorDestinations() []uint32 {
	if m != nil {
		return m.MirrorDestinations
	}
	return nil
}

// FlowMonitorRuleSpec flow monitor rule specification
type FlowMonitorRuleSpec struct {
	Meta           *ObjectMeta      `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	ExportConfigId *ExportControlId `protobuf:"bytes,2,opt,name=export_configId,json=exportConfigId" json:"export_configId,omitempty"`
	SourceMac      *MacAddress      `protobuf:"bytes,3,opt,name=source_mac,json=sourceMac" json:"source_mac,omitempty"`
	DestMac        *MacAddress      `protobuf:"bytes,4,opt,name=dest_mac,json=destMac" json:"dest_mac,omitempty"`
	Protocol       IPProtocol       `protobuf:"varint,5,opt,name=protocol,enum=types.IPProtocol" json:"protocol,omitempty"`
	SourceIp       *IPPrefix        `protobuf:"bytes,6,opt,name=source_ip,json=sourceIp" json:"source_ip,omitempty"`
	DestIp         *IPPrefix        `protobuf:"bytes,7,opt,name=dest_ip,json=destIp" json:"dest_ip,omitempty"`
	SourceL4Port   *L4Port          `protobuf:"bytes,8,opt,name=source_l4_port,json=sourceL4Port" json:"source_l4_port,omitempty"`
	DestL4Port     *L4Port          `protobuf:"bytes,9,opt,name=dest_l4_port,json=destL4Port" json:"dest_l4_port,omitempty"`
	SourceTags     []uint64         `protobuf:"varint,10,rep,packed,name=source_tags,json=sourceTags" json:"source_tags,omitempty"`
	DestTags       []uint64         `protobuf:"varint,11,rep,packed,name=dest_tags,json=destTags" json:"dest_tags,omitempty"`
	Action         *MonitorAction   `protobuf:"bytes,12,opt,name=action" json:"action,omitempty"`
}

func (m *FlowMonitorRuleSpec) Reset()                    { *m = FlowMonitorRuleSpec{} }
func (m *FlowMonitorRuleSpec) String() string            { return proto.CompactTextString(m) }
func (*FlowMonitorRuleSpec) ProtoMessage()               {}
func (*FlowMonitorRuleSpec) Descriptor() ([]byte, []int) { return fileDescriptor20, []int{14} }

func (m *FlowMonitorRuleSpec) GetMeta() *ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *FlowMonitorRuleSpec) GetExportConfigId() *ExportControlId {
	if m != nil {
		return m.ExportConfigId
	}
	return nil
}

func (m *FlowMonitorRuleSpec) GetSourceMac() *MacAddress {
	if m != nil {
		return m.SourceMac
	}
	return nil
}

func (m *FlowMonitorRuleSpec) GetDestMac() *MacAddress {
	if m != nil {
		return m.DestMac
	}
	return nil
}

func (m *FlowMonitorRuleSpec) GetProtocol() IPProtocol {
	if m != nil {
		return m.Protocol
	}
	return IPProtocol_IPPROTO_NONE
}

func (m *FlowMonitorRuleSpec) GetSourceIp() *IPPrefix {
	if m != nil {
		return m.SourceIp
	}
	return nil
}

func (m *FlowMonitorRuleSpec) GetDestIp() *IPPrefix {
	if m != nil {
		return m.DestIp
	}
	return nil
}

func (m *FlowMonitorRuleSpec) GetSourceL4Port() *L4Port {
	if m != nil {
		return m.SourceL4Port
	}
	return nil
}

func (m *FlowMonitorRuleSpec) GetDestL4Port() *L4Port {
	if m != nil {
		return m.DestL4Port
	}
	return nil
}

func (m *FlowMonitorRuleSpec) GetSourceTags() []uint64 {
	if m != nil {
		return m.SourceTags
	}
	return nil
}

func (m *FlowMonitorRuleSpec) GetDestTags() []uint64 {
	if m != nil {
		return m.DestTags
	}
	return nil
}

func (m *FlowMonitorRuleSpec) GetAction() *MonitorAction {
	if m != nil {
		return m.Action
	}
	return nil
}

// FlowMonitorRuleStatus is the operational status of the rule
type FlowMonitorRuleStatus struct {
	Code        FlowMonitorRuleStatus_FlowMonitorRuleStatusCode `protobuf:"varint,1,opt,name=code,enum=telemetry.FlowMonitorRuleStatus_FlowMonitorRuleStatusCode" json:"code,omitempty"`
	Status      string                                          `protobuf:"bytes,2,opt,name=status" json:"status,omitempty"`
	ActiveFlows uint32                                          `protobuf:"varint,3,opt,name=active_flows,json=activeFlows" json:"active_flows,omitempty"`
}

func (m *FlowMonitorRuleStatus) Reset()                    { *m = FlowMonitorRuleStatus{} }
func (m *FlowMonitorRuleStatus) String() string            { return proto.CompactTextString(m) }
func (*FlowMonitorRuleStatus) ProtoMessage()               {}
func (*FlowMonitorRuleStatus) Descriptor() ([]byte, []int) { return fileDescriptor20, []int{15} }

func (m *FlowMonitorRuleStatus) GetCode() FlowMonitorRuleStatus_FlowMonitorRuleStatusCode {
	if m != nil {
		return m.Code
	}
	return FlowMonitorRuleStatus_SUCCESS
}

func (m *FlowMonitorRuleStatus) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *FlowMonitorRuleStatus) GetActiveFlows() uint32 {
	if m != nil {
		return m.ActiveFlows
	}
	return 0
}

// FlowMonitorRule is a container for the configuration and operational status
type FlowMonitorRule struct {
	Spec   *FlowMonitorRuleSpec   `protobuf:"bytes,1,opt,name=spec" json:"spec,omitempty"`
	Status *FlowMonitorRuleStatus `protobuf:"bytes,2,opt,name=status" json:"status,omitempty"`
}

func (m *FlowMonitorRule) Reset()                    { *m = FlowMonitorRule{} }
func (m *FlowMonitorRule) String() string            { return proto.CompactTextString(m) }
func (*FlowMonitorRule) ProtoMessage()               {}
func (*FlowMonitorRule) Descriptor() ([]byte, []int) { return fileDescriptor20, []int{16} }

func (m *FlowMonitorRule) GetSpec() *FlowMonitorRuleSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *FlowMonitorRule) GetStatus() *FlowMonitorRuleStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

// FlowMonitorRuleConfigMsg is used in api requests for flow monitor configuration
type FlowMonitorRuleConfigMsg struct {
	Rules []*FlowMonitorRuleSpec `protobuf:"bytes,1,rep,name=rules" json:"rules,omitempty"`
}

func (m *FlowMonitorRuleConfigMsg) Reset()                    { *m = FlowMonitorRuleConfigMsg{} }
func (m *FlowMonitorRuleConfigMsg) String() string            { return proto.CompactTextString(m) }
func (*FlowMonitorRuleConfigMsg) ProtoMessage()               {}
func (*FlowMonitorRuleConfigMsg) Descriptor() ([]byte, []int) { return fileDescriptor20, []int{17} }

func (m *FlowMonitorRuleConfigMsg) GetRules() []*FlowMonitorRuleSpec {
	if m != nil {
		return m.Rules
	}
	return nil
}

// FlowMonitorRuleResponseMsg is used in responses for flow monitor rule operations
type FlowMonitorRuleResponseMsg struct {
	Status ApiStatus          `protobuf:"varint,1,opt,name=status,enum=types.ApiStatus" json:"status,omitempty"`
	Rules  []*FlowMonitorRule `protobuf:"bytes,2,rep,name=rules" json:"rules,omitempty"`
}

func (m *FlowMonitorRuleResponseMsg) Reset()                    { *m = FlowMonitorRuleResponseMsg{} }
func (m *FlowMonitorRuleResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*FlowMonitorRuleResponseMsg) ProtoMessage()               {}
func (*FlowMonitorRuleResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptor20, []int{18} }

func (m *FlowMonitorRuleResponseMsg) GetStatus() ApiStatus {
	if m != nil {
		return m.Status
	}
	return ApiStatus_API_STATUS_OK
}

func (m *FlowMonitorRuleResponseMsg) GetRules() []*FlowMonitorRule {
	if m != nil {
		return m.Rules
	}
	return nil
}

// RspanSpec is the configuration specification for RSPAN.
type RSpanSpec struct {
	Intf       *InterfaceKeyHandle `protobuf:"bytes,1,opt,name=intf" json:"intf,omitempty"`
	RspanEncap *EncapInfo          `protobuf:"bytes,2,opt,name=rspan_encap,json=rspanEncap" json:"rspan_encap,omitempty"`
}

func (m *RSpanSpec) Reset()                    { *m = RSpanSpec{} }
func (m *RSpanSpec) String() string            { return proto.CompactTextString(m) }
func (*RSpanSpec) ProtoMessage()               {}
func (*RSpanSpec) Descriptor() ([]byte, []int) { return fileDescriptor20, []int{19} }

func (m *RSpanSpec) GetIntf() *InterfaceKeyHandle {
	if m != nil {
		return m.Intf
	}
	return nil
}

func (m *RSpanSpec) GetRspanEncap() *EncapInfo {
	if m != nil {
		return m.RspanEncap
	}
	return nil
}

// ERSpanSpec is the configuration specification for ERSPAN
type ERSpanSpec struct {
	DestIp *IPAddress `protobuf:"bytes,1,opt,name=dest_ip,json=destIp" json:"dest_ip,omitempty"`
	Dscp   string     `protobuf:"bytes,2,opt,name=dscp" json:"dscp,omitempty"`
	SpanId uint32     `protobuf:"varint,3,opt,name=span_id,json=spanId" json:"span_id,omitempty"`
}

func (m *ERSpanSpec) Reset()                    { *m = ERSpanSpec{} }
func (m *ERSpanSpec) String() string            { return proto.CompactTextString(m) }
func (*ERSpanSpec) ProtoMessage()               {}
func (*ERSpanSpec) Descriptor() ([]byte, []int) { return fileDescriptor20, []int{20} }

func (m *ERSpanSpec) GetDestIp() *IPAddress {
	if m != nil {
		return m.DestIp
	}
	return nil
}

func (m *ERSpanSpec) GetDscp() string {
	if m != nil {
		return m.Dscp
	}
	return ""
}

func (m *ERSpanSpec) GetSpanId() uint32 {
	if m != nil {
		return m.SpanId
	}
	return 0
}

// MirrorSessionId is a key for the SPAN session
type MirrorSessionId struct {
	SessionId uint32 `protobuf:"varint,1,opt,name=session_id,json=sessionId" json:"session_id,omitempty"`
}

func (m *MirrorSessionId) Reset()                    { *m = MirrorSessionId{} }
func (m *MirrorSessionId) String() string            { return proto.CompactTextString(m) }
func (*MirrorSessionId) ProtoMessage()               {}
func (*MirrorSessionId) Descriptor() ([]byte, []int) { return fileDescriptor20, []int{21} }

func (m *MirrorSessionId) GetSessionId() uint32 {
	if m != nil {
		return m.SessionId
	}
	return 0
}

// MirrorSessionSpec is the configuration specification for mirror config
type MirrorSessionSpec struct {
	Id      *MirrorSessionId `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Snaplen uint32           `protobuf:"varint,2,opt,name=snaplen" json:"snaplen,omitempty"`
	// Types that are valid to be assigned to Destination:
	//	*MirrorSessionSpec_LocalSpanIf
	//	*MirrorSessionSpec_RspanSpec
	//	*MirrorSessionSpec_ErspanSpec
	Destination isMirrorSessionSpec_Destination `protobuf_oneof:"destination"`
}

func (m *MirrorSessionSpec) Reset()                    { *m = MirrorSessionSpec{} }
func (m *MirrorSessionSpec) String() string            { return proto.CompactTextString(m) }
func (*MirrorSessionSpec) ProtoMessage()               {}
func (*MirrorSessionSpec) Descriptor() ([]byte, []int) { return fileDescriptor20, []int{22} }

type isMirrorSessionSpec_Destination interface {
	isMirrorSessionSpec_Destination()
}

type MirrorSessionSpec_LocalSpanIf struct {
	LocalSpanIf *InterfaceKeyHandle `protobuf:"bytes,3,opt,name=local_span_if,json=localSpanIf,oneof"`
}
type MirrorSessionSpec_RspanSpec struct {
	RspanSpec *RSpanSpec `protobuf:"bytes,4,opt,name=rspan_spec,json=rspanSpec,oneof"`
}
type MirrorSessionSpec_ErspanSpec struct {
	ErspanSpec *ERSpanSpec `protobuf:"bytes,5,opt,name=erspan_spec,json=erspanSpec,oneof"`
}

func (*MirrorSessionSpec_LocalSpanIf) isMirrorSessionSpec_Destination() {}
func (*MirrorSessionSpec_RspanSpec) isMirrorSessionSpec_Destination()   {}
func (*MirrorSessionSpec_ErspanSpec) isMirrorSessionSpec_Destination()  {}

func (m *MirrorSessionSpec) GetDestination() isMirrorSessionSpec_Destination {
	if m != nil {
		return m.Destination
	}
	return nil
}

func (m *MirrorSessionSpec) GetId() *MirrorSessionId {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *MirrorSessionSpec) GetSnaplen() uint32 {
	if m != nil {
		return m.Snaplen
	}
	return 0
}

func (m *MirrorSessionSpec) GetLocalSpanIf() *InterfaceKeyHandle {
	if x, ok := m.GetDestination().(*MirrorSessionSpec_LocalSpanIf); ok {
		return x.LocalSpanIf
	}
	return nil
}

func (m *MirrorSessionSpec) GetRspanSpec() *RSpanSpec {
	if x, ok := m.GetDestination().(*MirrorSessionSpec_RspanSpec); ok {
		return x.RspanSpec
	}
	return nil
}

func (m *MirrorSessionSpec) GetErspanSpec() *ERSpanSpec {
	if x, ok := m.GetDestination().(*MirrorSessionSpec_ErspanSpec); ok {
		return x.ErspanSpec
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*MirrorSessionSpec) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _MirrorSessionSpec_OneofMarshaler, _MirrorSessionSpec_OneofUnmarshaler, _MirrorSessionSpec_OneofSizer, []interface{}{
		(*MirrorSessionSpec_LocalSpanIf)(nil),
		(*MirrorSessionSpec_RspanSpec)(nil),
		(*MirrorSessionSpec_ErspanSpec)(nil),
	}
}

func _MirrorSessionSpec_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*MirrorSessionSpec)
	// destination
	switch x := m.Destination.(type) {
	case *MirrorSessionSpec_LocalSpanIf:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.LocalSpanIf); err != nil {
			return err
		}
	case *MirrorSessionSpec_RspanSpec:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.RspanSpec); err != nil {
			return err
		}
	case *MirrorSessionSpec_ErspanSpec:
		b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ErspanSpec); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("MirrorSessionSpec.Destination has unexpected type %T", x)
	}
	return nil
}

func _MirrorSessionSpec_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*MirrorSessionSpec)
	switch tag {
	case 3: // destination.local_span_if
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(InterfaceKeyHandle)
		err := b.DecodeMessage(msg)
		m.Destination = &MirrorSessionSpec_LocalSpanIf{msg}
		return true, err
	case 4: // destination.rspan_spec
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(RSpanSpec)
		err := b.DecodeMessage(msg)
		m.Destination = &MirrorSessionSpec_RspanSpec{msg}
		return true, err
	case 5: // destination.erspan_spec
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ERSpanSpec)
		err := b.DecodeMessage(msg)
		m.Destination = &MirrorSessionSpec_ErspanSpec{msg}
		return true, err
	default:
		return false, nil
	}
}

func _MirrorSessionSpec_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*MirrorSessionSpec)
	// destination
	switch x := m.Destination.(type) {
	case *MirrorSessionSpec_LocalSpanIf:
		s := proto.Size(x.LocalSpanIf)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *MirrorSessionSpec_RspanSpec:
		s := proto.Size(x.RspanSpec)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *MirrorSessionSpec_ErspanSpec:
		s := proto.Size(x.ErspanSpec)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// MirrorSessionStatus is the operational status of the SPAN session.
type MirrorSessionStatus struct {
	Code        MirrorSessionStatus_MirrorSessionStatusCode `protobuf:"varint,1,opt,name=code,enum=telemetry.MirrorSessionStatus_MirrorSessionStatusCode" json:"code,omitempty"`
	Status      string                                      `protobuf:"bytes,2,opt,name=status" json:"status,omitempty"`
	ActiveFlows int32                                       `protobuf:"varint,3,opt,name=active_flows,json=activeFlows" json:"active_flows,omitempty"`
}

func (m *MirrorSessionStatus) Reset()                    { *m = MirrorSessionStatus{} }
func (m *MirrorSessionStatus) String() string            { return proto.CompactTextString(m) }
func (*MirrorSessionStatus) ProtoMessage()               {}
func (*MirrorSessionStatus) Descriptor() ([]byte, []int) { return fileDescriptor20, []int{23} }

func (m *MirrorSessionStatus) GetCode() MirrorSessionStatus_MirrorSessionStatusCode {
	if m != nil {
		return m.Code
	}
	return MirrorSessionStatus_SUCCESS
}

func (m *MirrorSessionStatus) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *MirrorSessionStatus) GetActiveFlows() int32 {
	if m != nil {
		return m.ActiveFlows
	}
	return 0
}

// MirrorSession is a container of the configuration and the operational status for mirror sessions.
type MirrorSession struct {
	ApiStatus ApiStatus            `protobuf:"varint,1,opt,name=api_status,json=apiStatus,enum=types.ApiStatus" json:"api_status,omitempty"`
	Spec      *MirrorSessionSpec   `protobuf:"bytes,2,opt,name=spec" json:"spec,omitempty"`
	Status    *MirrorSessionStatus `protobuf:"bytes,3,opt,name=status" json:"status,omitempty"`
}

func (m *MirrorSession) Reset()                    { *m = MirrorSession{} }
func (m *MirrorSession) String() string            { return proto.CompactTextString(m) }
func (*MirrorSession) ProtoMessage()               {}
func (*MirrorSession) Descriptor() ([]byte, []int) { return fileDescriptor20, []int{24} }

func (m *MirrorSession) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *MirrorSession) GetSpec() *MirrorSessionSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *MirrorSession) GetStatus() *MirrorSessionStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

// MirrorSessionConfigMsg is a batchable message used for request messages for mirror session configuration.
type MirrorSessionConfigMsg struct {
	Request []*MirrorSessionSpec `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *MirrorSessionConfigMsg) Reset()                    { *m = MirrorSessionConfigMsg{} }
func (m *MirrorSessionConfigMsg) String() string            { return proto.CompactTextString(m) }
func (*MirrorSessionConfigMsg) ProtoMessage()               {}
func (*MirrorSessionConfigMsg) Descriptor() ([]byte, []int) { return fileDescriptor20, []int{25} }

func (m *MirrorSessionConfigMsg) GetRequest() []*MirrorSessionSpec {
	if m != nil {
		return m.Request
	}
	return nil
}

// MirrorSessionConfigMsg is a batchable message used for request messages for mirror session configuration.
type MirrorSessionDeleteMsg struct {
	Request []*MirrorSessionId `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *MirrorSessionDeleteMsg) Reset()                    { *m = MirrorSessionDeleteMsg{} }
func (m *MirrorSessionDeleteMsg) String() string            { return proto.CompactTextString(m) }
func (*MirrorSessionDeleteMsg) ProtoMessage()               {}
func (*MirrorSessionDeleteMsg) Descriptor() ([]byte, []int) { return fileDescriptor20, []int{26} }

func (m *MirrorSessionDeleteMsg) GetRequest() []*MirrorSessionId {
	if m != nil {
		return m.Request
	}
	return nil
}

// MirrorSessionResponseMsg is used as responses to the MirrorSession configuration APIs
type MirrorSessionResponseMsg struct {
	Status   ApiStatus        `protobuf:"varint,1,opt,name=status,enum=types.ApiStatus" json:"status,omitempty"`
	Response []*MirrorSession `protobuf:"bytes,2,rep,name=response" json:"response,omitempty"`
}

func (m *MirrorSessionResponseMsg) Reset()                    { *m = MirrorSessionResponseMsg{} }
func (m *MirrorSessionResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*MirrorSessionResponseMsg) ProtoMessage()               {}
func (*MirrorSessionResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptor20, []int{27} }

func (m *MirrorSessionResponseMsg) GetStatus() ApiStatus {
	if m != nil {
		return m.Status
	}
	return ApiStatus_API_STATUS_OK
}

func (m *MirrorSessionResponseMsg) GetResponse() []*MirrorSession {
	if m != nil {
		return m.Response
	}
	return nil
}

func init() {
	proto.RegisterType((*L4Port)(nil), "telemetry.L4Port")
	proto.RegisterType((*MacAddress)(nil), "telemetry.MacAddress")
	proto.RegisterType((*CollectorSpec)(nil), "telemetry.CollectorSpec")
	proto.RegisterType((*CollectorStatus)(nil), "telemetry.CollectorStatus")
	proto.RegisterType((*Collector)(nil), "telemetry.Collector")
	proto.RegisterType((*CollectorConfigMsg)(nil), "telemetry.CollectorConfigMsg")
	proto.RegisterType((*CollectorResponseMsg)(nil), "telemetry.CollectorResponseMsg")
	proto.RegisterType((*ExportControlId)(nil), "telemetry.ExportControlId")
	proto.RegisterType((*ExportControlSpec)(nil), "telemetry.ExportControlSpec")
	proto.RegisterType((*ExportControlStatus)(nil), "telemetry.ExportControlStatus")
	proto.RegisterType((*ExportControl)(nil), "telemetry.ExportControl")
	proto.RegisterType((*ExportControlConfigMsg)(nil), "telemetry.ExportControlConfigMsg")
	proto.RegisterType((*ExportControlResponseMsg)(nil), "telemetry.ExportControlResponseMsg")
	proto.RegisterType((*MonitorAction)(nil), "telemetry.MonitorAction")
	proto.RegisterType((*FlowMonitorRuleSpec)(nil), "telemetry.FlowMonitorRuleSpec")
	proto.RegisterType((*FlowMonitorRuleStatus)(nil), "telemetry.FlowMonitorRuleStatus")
	proto.RegisterType((*FlowMonitorRule)(nil), "telemetry.FlowMonitorRule")
	proto.RegisterType((*FlowMonitorRuleConfigMsg)(nil), "telemetry.FlowMonitorRuleConfigMsg")
	proto.RegisterType((*FlowMonitorRuleResponseMsg)(nil), "telemetry.FlowMonitorRuleResponseMsg")
	proto.RegisterType((*RSpanSpec)(nil), "telemetry.RSpanSpec")
	proto.RegisterType((*ERSpanSpec)(nil), "telemetry.ERSpanSpec")
	proto.RegisterType((*MirrorSessionId)(nil), "telemetry.MirrorSessionId")
	proto.RegisterType((*MirrorSessionSpec)(nil), "telemetry.MirrorSessionSpec")
	proto.RegisterType((*MirrorSessionStatus)(nil), "telemetry.MirrorSessionStatus")
	proto.RegisterType((*MirrorSession)(nil), "telemetry.MirrorSession")
	proto.RegisterType((*MirrorSessionConfigMsg)(nil), "telemetry.MirrorSessionConfigMsg")
	proto.RegisterType((*MirrorSessionDeleteMsg)(nil), "telemetry.MirrorSessionDeleteMsg")
	proto.RegisterType((*MirrorSessionResponseMsg)(nil), "telemetry.MirrorSessionResponseMsg")
	proto.RegisterEnum("telemetry.ExportFormat", ExportFormat_name, ExportFormat_value)
	proto.RegisterEnum("telemetry.RuleAction", RuleAction_name, RuleAction_value)
	proto.RegisterEnum("telemetry.AggregationScheme", AggregationScheme_name, AggregationScheme_value)
	proto.RegisterEnum("telemetry.CollectorStatus_CollectorStatusCode", CollectorStatus_CollectorStatusCode_name, CollectorStatus_CollectorStatusCode_value)
	proto.RegisterEnum("telemetry.ExportControlStatus_ExportControlStatusCode", ExportControlStatus_ExportControlStatusCode_name, ExportControlStatus_ExportControlStatusCode_value)
	proto.RegisterEnum("telemetry.FlowMonitorRuleStatus_FlowMonitorRuleStatusCode", FlowMonitorRuleStatus_FlowMonitorRuleStatusCode_name, FlowMonitorRuleStatus_FlowMonitorRuleStatusCode_value)
	proto.RegisterEnum("telemetry.MirrorSessionStatus_MirrorSessionStatusCode", MirrorSessionStatus_MirrorSessionStatusCode_name, MirrorSessionStatus_MirrorSessionStatusCode_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Telemetry service

type TelemetryClient interface {
	// Collector operations CRUD operations
	CollectorCreate(ctx context.Context, in *CollectorConfigMsg, opts ...grpc.CallOption) (*CollectorResponseMsg, error)
	CollectorUpdate(ctx context.Context, in *CollectorConfigMsg, opts ...grpc.CallOption) (*CollectorResponseMsg, error)
	CollectorList(ctx context.Context, in *ExportControlId, opts ...grpc.CallOption) (*CollectorResponseMsg, error)
	CollectorDelete(ctx context.Context, in *CollectorConfigMsg, opts ...grpc.CallOption) (*CollectorResponseMsg, error)
	// ExportConfig CRUD operations
	ExportControlCreate(ctx context.Context, in *ExportControlConfigMsg, opts ...grpc.CallOption) (*ExportControlResponseMsg, error)
	ExportControlUpdate(ctx context.Context, in *ExportControlConfigMsg, opts ...grpc.CallOption) (*ExportControlResponseMsg, error)
	ExportControlGet(ctx context.Context, in *ExportControlId, opts ...grpc.CallOption) (*ExportControlResponseMsg, error)
	ExportControlDelete(ctx context.Context, in *ExportControlId, opts ...grpc.CallOption) (*ExportControlResponseMsg, error)
	// FlowMonitorRules CRUD Operations
	FlowMonitorRuleCreate(ctx context.Context, in *FlowMonitorRuleConfigMsg, opts ...grpc.CallOption) (*FlowMonitorRuleResponseMsg, error)
	FlowMonitorRuleUpdate(ctx context.Context, in *FlowMonitorRuleConfigMsg, opts ...grpc.CallOption) (*FlowMonitorRuleResponseMsg, error)
	FlowMonitorRuleList(ctx context.Context, in *ExportControlId, opts ...grpc.CallOption) (*FlowMonitorRuleResponseMsg, error)
	FlowMonitorRuleGet(ctx context.Context, in *FlowMonitorRuleConfigMsg, opts ...grpc.CallOption) (*FlowMonitorRuleResponseMsg, error)
	FlowMonitorRuleDelete(ctx context.Context, in *FlowMonitorRuleConfigMsg, opts ...grpc.CallOption) (*FlowMonitorRuleResponseMsg, error)
	// MirrorSession CRUD Operations
	MirrorSessionCreate(ctx context.Context, in *MirrorSessionConfigMsg, opts ...grpc.CallOption) (*MirrorSessionResponseMsg, error)
	MirrorSessionUpdate(ctx context.Context, in *MirrorSessionConfigMsg, opts ...grpc.CallOption) (*MirrorSessionResponseMsg, error)
	MirrorSessionGet(ctx context.Context, in *MirrorSessionId, opts ...grpc.CallOption) (*MirrorSessionResponseMsg, error)
	MirrorSessionList(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*MirrorSessionResponseMsg, error)
	MirrorSessionDelete(ctx context.Context, in *MirrorSessionDeleteMsg, opts ...grpc.CallOption) (*MirrorSessionResponseMsg, error)
}

type telemetryClient struct {
	cc *grpc.ClientConn
}

func NewTelemetryClient(cc *grpc.ClientConn) TelemetryClient {
	return &telemetryClient{cc}
}

func (c *telemetryClient) CollectorCreate(ctx context.Context, in *CollectorConfigMsg, opts ...grpc.CallOption) (*CollectorResponseMsg, error) {
	out := new(CollectorResponseMsg)
	err := grpc.Invoke(ctx, "/telemetry.Telemetry/CollectorCreate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *telemetryClient) CollectorUpdate(ctx context.Context, in *CollectorConfigMsg, opts ...grpc.CallOption) (*CollectorResponseMsg, error) {
	out := new(CollectorResponseMsg)
	err := grpc.Invoke(ctx, "/telemetry.Telemetry/CollectorUpdate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *telemetryClient) CollectorList(ctx context.Context, in *ExportControlId, opts ...grpc.CallOption) (*CollectorResponseMsg, error) {
	out := new(CollectorResponseMsg)
	err := grpc.Invoke(ctx, "/telemetry.Telemetry/CollectorList", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *telemetryClient) CollectorDelete(ctx context.Context, in *CollectorConfigMsg, opts ...grpc.CallOption) (*CollectorResponseMsg, error) {
	out := new(CollectorResponseMsg)
	err := grpc.Invoke(ctx, "/telemetry.Telemetry/CollectorDelete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *telemetryClient) ExportControlCreate(ctx context.Context, in *ExportControlConfigMsg, opts ...grpc.CallOption) (*ExportControlResponseMsg, error) {
	out := new(ExportControlResponseMsg)
	err := grpc.Invoke(ctx, "/telemetry.Telemetry/ExportControlCreate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *telemetryClient) ExportControlUpdate(ctx context.Context, in *ExportControlConfigMsg, opts ...grpc.CallOption) (*ExportControlResponseMsg, error) {
	out := new(ExportControlResponseMsg)
	err := grpc.Invoke(ctx, "/telemetry.Telemetry/ExportControlUpdate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *telemetryClient) ExportControlGet(ctx context.Context, in *ExportControlId, opts ...grpc.CallOption) (*ExportControlResponseMsg, error) {
	out := new(ExportControlResponseMsg)
	err := grpc.Invoke(ctx, "/telemetry.Telemetry/ExportControlGet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *telemetryClient) ExportControlDelete(ctx context.Context, in *ExportControlId, opts ...grpc.CallOption) (*ExportControlResponseMsg, error) {
	out := new(ExportControlResponseMsg)
	err := grpc.Invoke(ctx, "/telemetry.Telemetry/ExportControlDelete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *telemetryClient) FlowMonitorRuleCreate(ctx context.Context, in *FlowMonitorRuleConfigMsg, opts ...grpc.CallOption) (*FlowMonitorRuleResponseMsg, error) {
	out := new(FlowMonitorRuleResponseMsg)
	err := grpc.Invoke(ctx, "/telemetry.Telemetry/FlowMonitorRuleCreate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *telemetryClient) FlowMonitorRuleUpdate(ctx context.Context, in *FlowMonitorRuleConfigMsg, opts ...grpc.CallOption) (*FlowMonitorRuleResponseMsg, error) {
	out := new(FlowMonitorRuleResponseMsg)
	err := grpc.Invoke(ctx, "/telemetry.Telemetry/FlowMonitorRuleUpdate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *telemetryClient) FlowMonitorRuleList(ctx context.Context, in *ExportControlId, opts ...grpc.CallOption) (*FlowMonitorRuleResponseMsg, error) {
	out := new(FlowMonitorRuleResponseMsg)
	err := grpc.Invoke(ctx, "/telemetry.Telemetry/FlowMonitorRuleList", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *telemetryClient) FlowMonitorRuleGet(ctx context.Context, in *FlowMonitorRuleConfigMsg, opts ...grpc.CallOption) (*FlowMonitorRuleResponseMsg, error) {
	out := new(FlowMonitorRuleResponseMsg)
	err := grpc.Invoke(ctx, "/telemetry.Telemetry/FlowMonitorRuleGet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *telemetryClient) FlowMonitorRuleDelete(ctx context.Context, in *FlowMonitorRuleConfigMsg, opts ...grpc.CallOption) (*FlowMonitorRuleResponseMsg, error) {
	out := new(FlowMonitorRuleResponseMsg)
	err := grpc.Invoke(ctx, "/telemetry.Telemetry/FlowMonitorRuleDelete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *telemetryClient) MirrorSessionCreate(ctx context.Context, in *MirrorSessionConfigMsg, opts ...grpc.CallOption) (*MirrorSessionResponseMsg, error) {
	out := new(MirrorSessionResponseMsg)
	err := grpc.Invoke(ctx, "/telemetry.Telemetry/MirrorSessionCreate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *telemetryClient) MirrorSessionUpdate(ctx context.Context, in *MirrorSessionConfigMsg, opts ...grpc.CallOption) (*MirrorSessionResponseMsg, error) {
	out := new(MirrorSessionResponseMsg)
	err := grpc.Invoke(ctx, "/telemetry.Telemetry/MirrorSessionUpdate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *telemetryClient) MirrorSessionGet(ctx context.Context, in *MirrorSessionId, opts ...grpc.CallOption) (*MirrorSessionResponseMsg, error) {
	out := new(MirrorSessionResponseMsg)
	err := grpc.Invoke(ctx, "/telemetry.Telemetry/MirrorSessionGet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *telemetryClient) MirrorSessionList(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*MirrorSessionResponseMsg, error) {
	out := new(MirrorSessionResponseMsg)
	err := grpc.Invoke(ctx, "/telemetry.Telemetry/MirrorSessionList", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *telemetryClient) MirrorSessionDelete(ctx context.Context, in *MirrorSessionDeleteMsg, opts ...grpc.CallOption) (*MirrorSessionResponseMsg, error) {
	out := new(MirrorSessionResponseMsg)
	err := grpc.Invoke(ctx, "/telemetry.Telemetry/MirrorSessionDelete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Telemetry service

type TelemetryServer interface {
	// Collector operations CRUD operations
	CollectorCreate(context.Context, *CollectorConfigMsg) (*CollectorResponseMsg, error)
	CollectorUpdate(context.Context, *CollectorConfigMsg) (*CollectorResponseMsg, error)
	CollectorList(context.Context, *ExportControlId) (*CollectorResponseMsg, error)
	CollectorDelete(context.Context, *CollectorConfigMsg) (*CollectorResponseMsg, error)
	// ExportConfig CRUD operations
	ExportControlCreate(context.Context, *ExportControlConfigMsg) (*ExportControlResponseMsg, error)
	ExportControlUpdate(context.Context, *ExportControlConfigMsg) (*ExportControlResponseMsg, error)
	ExportControlGet(context.Context, *ExportControlId) (*ExportControlResponseMsg, error)
	ExportControlDelete(context.Context, *ExportControlId) (*ExportControlResponseMsg, error)
	// FlowMonitorRules CRUD Operations
	FlowMonitorRuleCreate(context.Context, *FlowMonitorRuleConfigMsg) (*FlowMonitorRuleResponseMsg, error)
	FlowMonitorRuleUpdate(context.Context, *FlowMonitorRuleConfigMsg) (*FlowMonitorRuleResponseMsg, error)
	FlowMonitorRuleList(context.Context, *ExportControlId) (*FlowMonitorRuleResponseMsg, error)
	FlowMonitorRuleGet(context.Context, *FlowMonitorRuleConfigMsg) (*FlowMonitorRuleResponseMsg, error)
	FlowMonitorRuleDelete(context.Context, *FlowMonitorRuleConfigMsg) (*FlowMonitorRuleResponseMsg, error)
	// MirrorSession CRUD Operations
	MirrorSessionCreate(context.Context, *MirrorSessionConfigMsg) (*MirrorSessionResponseMsg, error)
	MirrorSessionUpdate(context.Context, *MirrorSessionConfigMsg) (*MirrorSessionResponseMsg, error)
	MirrorSessionGet(context.Context, *MirrorSessionId) (*MirrorSessionResponseMsg, error)
	MirrorSessionList(context.Context, *Empty) (*MirrorSessionResponseMsg, error)
	MirrorSessionDelete(context.Context, *MirrorSessionDeleteMsg) (*MirrorSessionResponseMsg, error)
}

func RegisterTelemetryServer(s *grpc.Server, srv TelemetryServer) {
	s.RegisterService(&_Telemetry_serviceDesc, srv)
}

func _Telemetry_CollectorCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CollectorConfigMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TelemetryServer).CollectorCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/telemetry.Telemetry/CollectorCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TelemetryServer).CollectorCreate(ctx, req.(*CollectorConfigMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Telemetry_CollectorUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CollectorConfigMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TelemetryServer).CollectorUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/telemetry.Telemetry/CollectorUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TelemetryServer).CollectorUpdate(ctx, req.(*CollectorConfigMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Telemetry_CollectorList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExportControlId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TelemetryServer).CollectorList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/telemetry.Telemetry/CollectorList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TelemetryServer).CollectorList(ctx, req.(*ExportControlId))
	}
	return interceptor(ctx, in, info, handler)
}

func _Telemetry_CollectorDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CollectorConfigMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TelemetryServer).CollectorDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/telemetry.Telemetry/CollectorDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TelemetryServer).CollectorDelete(ctx, req.(*CollectorConfigMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Telemetry_ExportControlCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExportControlConfigMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TelemetryServer).ExportControlCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/telemetry.Telemetry/ExportControlCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TelemetryServer).ExportControlCreate(ctx, req.(*ExportControlConfigMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Telemetry_ExportControlUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExportControlConfigMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TelemetryServer).ExportControlUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/telemetry.Telemetry/ExportControlUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TelemetryServer).ExportControlUpdate(ctx, req.(*ExportControlConfigMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Telemetry_ExportControlGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExportControlId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TelemetryServer).ExportControlGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/telemetry.Telemetry/ExportControlGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TelemetryServer).ExportControlGet(ctx, req.(*ExportControlId))
	}
	return interceptor(ctx, in, info, handler)
}

func _Telemetry_ExportControlDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExportControlId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TelemetryServer).ExportControlDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/telemetry.Telemetry/ExportControlDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TelemetryServer).ExportControlDelete(ctx, req.(*ExportControlId))
	}
	return interceptor(ctx, in, info, handler)
}

func _Telemetry_FlowMonitorRuleCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FlowMonitorRuleConfigMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TelemetryServer).FlowMonitorRuleCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/telemetry.Telemetry/FlowMonitorRuleCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TelemetryServer).FlowMonitorRuleCreate(ctx, req.(*FlowMonitorRuleConfigMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Telemetry_FlowMonitorRuleUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FlowMonitorRuleConfigMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TelemetryServer).FlowMonitorRuleUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/telemetry.Telemetry/FlowMonitorRuleUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TelemetryServer).FlowMonitorRuleUpdate(ctx, req.(*FlowMonitorRuleConfigMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Telemetry_FlowMonitorRuleList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExportControlId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TelemetryServer).FlowMonitorRuleList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/telemetry.Telemetry/FlowMonitorRuleList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TelemetryServer).FlowMonitorRuleList(ctx, req.(*ExportControlId))
	}
	return interceptor(ctx, in, info, handler)
}

func _Telemetry_FlowMonitorRuleGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FlowMonitorRuleConfigMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TelemetryServer).FlowMonitorRuleGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/telemetry.Telemetry/FlowMonitorRuleGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TelemetryServer).FlowMonitorRuleGet(ctx, req.(*FlowMonitorRuleConfigMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Telemetry_FlowMonitorRuleDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FlowMonitorRuleConfigMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TelemetryServer).FlowMonitorRuleDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/telemetry.Telemetry/FlowMonitorRuleDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TelemetryServer).FlowMonitorRuleDelete(ctx, req.(*FlowMonitorRuleConfigMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Telemetry_MirrorSessionCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MirrorSessionConfigMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TelemetryServer).MirrorSessionCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/telemetry.Telemetry/MirrorSessionCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TelemetryServer).MirrorSessionCreate(ctx, req.(*MirrorSessionConfigMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Telemetry_MirrorSessionUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MirrorSessionConfigMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TelemetryServer).MirrorSessionUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/telemetry.Telemetry/MirrorSessionUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TelemetryServer).MirrorSessionUpdate(ctx, req.(*MirrorSessionConfigMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Telemetry_MirrorSessionGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MirrorSessionId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TelemetryServer).MirrorSessionGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/telemetry.Telemetry/MirrorSessionGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TelemetryServer).MirrorSessionGet(ctx, req.(*MirrorSessionId))
	}
	return interceptor(ctx, in, info, handler)
}

func _Telemetry_MirrorSessionList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TelemetryServer).MirrorSessionList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/telemetry.Telemetry/MirrorSessionList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TelemetryServer).MirrorSessionList(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Telemetry_MirrorSessionDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MirrorSessionDeleteMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TelemetryServer).MirrorSessionDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/telemetry.Telemetry/MirrorSessionDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TelemetryServer).MirrorSessionDelete(ctx, req.(*MirrorSessionDeleteMsg))
	}
	return interceptor(ctx, in, info, handler)
}

var _Telemetry_serviceDesc = grpc.ServiceDesc{
	ServiceName: "telemetry.Telemetry",
	HandlerType: (*TelemetryServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CollectorCreate",
			Handler:    _Telemetry_CollectorCreate_Handler,
		},
		{
			MethodName: "CollectorUpdate",
			Handler:    _Telemetry_CollectorUpdate_Handler,
		},
		{
			MethodName: "CollectorList",
			Handler:    _Telemetry_CollectorList_Handler,
		},
		{
			MethodName: "CollectorDelete",
			Handler:    _Telemetry_CollectorDelete_Handler,
		},
		{
			MethodName: "ExportControlCreate",
			Handler:    _Telemetry_ExportControlCreate_Handler,
		},
		{
			MethodName: "ExportControlUpdate",
			Handler:    _Telemetry_ExportControlUpdate_Handler,
		},
		{
			MethodName: "ExportControlGet",
			Handler:    _Telemetry_ExportControlGet_Handler,
		},
		{
			MethodName: "ExportControlDelete",
			Handler:    _Telemetry_ExportControlDelete_Handler,
		},
		{
			MethodName: "FlowMonitorRuleCreate",
			Handler:    _Telemetry_FlowMonitorRuleCreate_Handler,
		},
		{
			MethodName: "FlowMonitorRuleUpdate",
			Handler:    _Telemetry_FlowMonitorRuleUpdate_Handler,
		},
		{
			MethodName: "FlowMonitorRuleList",
			Handler:    _Telemetry_FlowMonitorRuleList_Handler,
		},
		{
			MethodName: "FlowMonitorRuleGet",
			Handler:    _Telemetry_FlowMonitorRuleGet_Handler,
		},
		{
			MethodName: "FlowMonitorRuleDelete",
			Handler:    _Telemetry_FlowMonitorRuleDelete_Handler,
		},
		{
			MethodName: "MirrorSessionCreate",
			Handler:    _Telemetry_MirrorSessionCreate_Handler,
		},
		{
			MethodName: "MirrorSessionUpdate",
			Handler:    _Telemetry_MirrorSessionUpdate_Handler,
		},
		{
			MethodName: "MirrorSessionGet",
			Handler:    _Telemetry_MirrorSessionGet_Handler,
		},
		{
			MethodName: "MirrorSessionList",
			Handler:    _Telemetry_MirrorSessionList_Handler,
		},
		{
			MethodName: "MirrorSessionDelete",
			Handler:    _Telemetry_MirrorSessionDelete_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "nic/proto/hal/telemetry.proto",
}

func init() { proto.RegisterFile("nic/proto/hal/telemetry.proto", fileDescriptor20) }

var fileDescriptor20 = []byte{
	// 1807 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x58, 0x5b, 0x73, 0xe3, 0x48,
	0x15, 0x8e, 0x6c, 0xc7, 0xb1, 0x8f, 0x6f, 0x4a, 0x67, 0x2e, 0x26, 0xec, 0xec, 0x64, 0xb5, 0xb5,
	0x54, 0x76, 0x6a, 0x36, 0x09, 0xd9, 0x30, 0xdc, 0xaa, 0xa0, 0x3c, 0x8e, 0x32, 0x11, 0xc4, 0x97,
	0x6a, 0x3b, 0xc3, 0xd6, 0x3c, 0xac, 0xd0, 0x48, 0x6d, 0x8f, 0x28, 0x59, 0x12, 0x92, 0xb2, 0x3b,
	0xe1, 0x85, 0x17, 0xe0, 0x9d, 0x47, 0xfe, 0x02, 0xc5, 0x1f, 0xe1, 0x85, 0xe2, 0x75, 0xff, 0x0b,
	0x0f, 0x54, 0xb7, 0x5a, 0xb2, 0x24, 0xcb, 0x76, 0x26, 0x98, 0xa7, 0xa8, 0xcf, 0xf9, 0xce, 0xa5,
	0x3f, 0x9f, 0x3e, 0x7d, 0x3a, 0xf0, 0xc4, 0x36, 0xf5, 0x63, 0xd7, 0x73, 0x02, 0xe7, 0xf8, 0x9d,
	0x66, 0x1d, 0x07, 0xc4, 0x22, 0x33, 0x12, 0x78, 0xb7, 0x47, 0x4c, 0x86, 0xaa, 0xb1, 0x60, 0xff,
	0xe1, 0x1c, 0x19, 0xdc, 0xba, 0xc4, 0x0f, 0x11, 0xfb, 0x19, 0x07, 0xa6, 0x1d, 0x10, 0x6f, 0xa2,
	0xe9, 0x24, 0x54, 0x4b, 0x1f, 0x41, 0xf9, 0xea, 0x6c, 0xe8, 0x78, 0x01, 0x42, 0x50, 0x72, 0x1d,
	0x2f, 0x68, 0x0b, 0x07, 0xc2, 0x61, 0x03, 0xb3, 0x6f, 0xe9, 0x07, 0x00, 0x3d, 0x4d, 0xef, 0x18,
	0x86, 0x47, 0x7c, 0x1f, 0xb5, 0x61, 0x47, 0x0b, 0x3f, 0x19, 0xa8, 0x84, 0xa3, 0xa5, 0xf4, 0x5d,
	0x01, 0x1a, 0x5d, 0xc7, 0xb2, 0x88, 0x1e, 0x38, 0xde, 0xc8, 0x25, 0x3a, 0xfa, 0x0c, 0x4a, 0x33,
	0x12, 0x68, 0x0c, 0x58, 0x3b, 0xdd, 0x3d, 0x0a, 0x53, 0x1a, 0xbc, 0xfd, 0x1d, 0xd1, 0x83, 0x1e,
	0x09, 0x34, 0xcc, 0xd4, 0x48, 0x06, 0x91, 0xbc, 0xa7, 0xa1, 0x54, 0xdd, 0xb1, 0x03, 0xcf, 0xb1,
	0x14, 0xa3, 0x5d, 0x60, 0x26, 0xfb, 0x47, 0xf3, 0xbd, 0xca, 0x0c, 0xd2, 0x8d, 0x10, 0xb8, 0x45,
	0xd2, 0x02, 0xf4, 0x39, 0xec, 0x18, 0xc4, 0x0f, 0x54, 0xd3, 0x6d, 0x17, 0x99, 0xb5, 0xc8, 0x03,
	0x2a, 0x43, 0x9e, 0x3c, 0x2e, 0x53, 0x80, 0xe2, 0xa2, 0x2f, 0xa0, 0xc2, 0x76, 0xae, 0x3b, 0x56,
	0xbb, 0x74, 0x20, 0x1c, 0x36, 0xe3, 0xe4, 0x94, 0xe1, 0x90, 0x2b, 0x70, 0x0c, 0x41, 0x47, 0x50,
	0x65, 0x9e, 0x19, 0x35, 0xdb, 0xd1, 0x66, 0xe2, 0xcc, 0x42, 0xee, 0x70, 0x85, 0x62, 0x18, 0x8b,
	0xc7, 0x50, 0x9e, 0x38, 0xde, 0x4c, 0x0b, 0xda, 0x65, 0xe6, 0xfc, 0xf1, 0xc2, 0x36, 0x2e, 0x98,
	0x1a, 0x73, 0x18, 0x7a, 0x0a, 0xb5, 0x80, 0xcc, 0x5c, 0x4b, 0x0b, 0x88, 0x6a, 0x1a, 0xed, 0x1d,
	0xc6, 0x3e, 0x44, 0x22, 0xc5, 0x90, 0xfe, 0x29, 0x40, 0x6b, 0xce, 0x6d, 0xa0, 0x05, 0x37, 0x3e,
	0x7a, 0x09, 0x25, 0xdd, 0x31, 0x08, 0x63, 0xb7, 0x79, 0x7a, 0x94, 0x88, 0x91, 0x41, 0x66, 0xd7,
	0x5d, 0xc7, 0x20, 0x98, 0xd9, 0xa2, 0x47, 0x50, 0xf6, 0x99, 0x8c, 0x11, 0x5e, 0xc5, 0x7c, 0x25,
	0xbd, 0x81, 0xbd, 0x1c, 0x23, 0x54, 0x83, 0x9d, 0xd1, 0x75, 0xb7, 0x2b, 0x8f, 0x46, 0xe2, 0x16,
	0x42, 0xd0, 0x54, 0xfa, 0xaf, 0x3b, 0x57, 0xca, 0xb9, 0xda, 0x1d, 0xf4, 0x2f, 0x94, 0x57, 0xa2,
	0x80, 0x44, 0xa8, 0x8f, 0xe5, 0xde, 0x50, 0xbd, 0xe8, 0x28, 0x57, 0xd7, 0x58, 0x16, 0x0b, 0x54,
	0x32, 0x94, 0x71, 0x2f, 0x96, 0x14, 0xa5, 0x19, 0x54, 0x63, 0xdf, 0xe8, 0x39, 0x94, 0x7c, 0x97,
	0xe8, 0xbc, 0x44, 0xda, 0xb9, 0x9b, 0x70, 0x89, 0x8e, 0x19, 0x0a, 0x9d, 0xa6, 0xd2, 0x4d, 0xd7,
	0x47, 0x26, 0xdf, 0x78, 0x2b, 0xe7, 0x80, 0x62, 0x55, 0xd7, 0xb1, 0x27, 0xe6, 0xb4, 0xe7, 0x4f,
	0xd1, 0x11, 0x6c, 0x53, 0x8f, 0xb4, 0x88, 0x8b, 0x2b, 0x03, 0x87, 0x30, 0xe9, 0x1b, 0x78, 0x10,
	0xcb, 0x31, 0xf1, 0x5d, 0xc7, 0xf6, 0x09, 0xf5, 0x73, 0x18, 0x67, 0x14, 0xfe, 0x0c, 0x51, 0xcd,
	0x75, 0x5c, 0x33, 0x9d, 0x07, 0x3a, 0x03, 0xd0, 0x23, 0x0f, 0x34, 0x7f, 0x1a, 0xf6, 0x41, 0x5e,
	0x58, 0x9c, 0xc0, 0x49, 0x97, 0xd0, 0xca, 0x14, 0xfe, 0x5d, 0x4f, 0x55, 0x13, 0x0a, 0xfc, 0x1c,
	0x95, 0x70, 0x41, 0x31, 0xa4, 0xbf, 0x0a, 0xb0, 0x9b, 0x72, 0xc5, 0x8e, 0xe8, 0x33, 0x86, 0x12,
	0xd6, 0x9e, 0xb6, 0x02, 0x0b, 0xdc, 0xd4, 0xf4, 0xc0, 0xfc, 0x86, 0xa8, 0x81, 0x39, 0x23, 0xce,
	0x4d, 0xc0, 0xbc, 0x37, 0x70, 0x23, 0x94, 0x8e, 0x43, 0x21, 0xfa, 0x1c, 0x44, 0xd3, 0xce, 0x00,
	0x8b, 0x0c, 0xd8, 0x8a, 0xe4, 0x1c, 0x2a, 0x7d, 0x27, 0xc0, 0x5e, 0x3a, 0xa7, 0x90, 0xab, 0x5f,
	0xa5, 0x4a, 0xfb, 0xc5, 0xb2, 0xbc, 0x78, 0x79, 0xe7, 0xc8, 0xee, 0x50, 0xe2, 0x5f, 0xc3, 0xe3,
	0x25, 0x86, 0x9b, 0x29, 0xf3, 0x5b, 0x68, 0xa4, 0xfc, 0xa3, 0x93, 0x54, 0xa9, 0x7f, 0xb4, 0x74,
	0x53, 0xf3, 0x72, 0x7f, 0x91, 0x29, 0xf7, 0x8f, 0x57, 0x13, 0x11, 0x6f, 0x6d, 0x08, 0x8f, 0x52,
	0xea, 0x79, 0xd9, 0xbf, 0x80, 0x1d, 0x9d, 0x2d, 0xa2, 0xc2, 0x5f, 0x9d, 0x46, 0x04, 0x96, 0xfe,
	0x2c, 0x40, 0x3b, 0xa5, 0xbe, 0xdf, 0x19, 0xf8, 0x25, 0x34, 0xd3, 0x9d, 0x9e, 0x9f, 0x83, 0xf6,
	0xb2, 0x2c, 0x70, 0x23, 0xd5, 0xe5, 0xa5, 0x7f, 0x08, 0xd0, 0xe8, 0x39, 0xb6, 0x19, 0x38, 0x5e,
	0x47, 0x0f, 0x4c, 0xc7, 0x46, 0x5f, 0x40, 0x59, 0x63, 0x5f, 0x6c, 0x43, 0xcd, 0xd3, 0x87, 0x09,
	0x57, 0xf8, 0xc6, 0x22, 0x21, 0x0c, 0x73, 0x10, 0xfa, 0x39, 0x80, 0x36, 0x9d, 0xaa, 0xbe, 0xfe,
	0x8e, 0xcc, 0x08, 0x8b, 0xde, 0x4c, 0x71, 0xd0, 0x99, 0x4e, 0x3d, 0x32, 0xd5, 0x28, 0x76, 0xc4,
	0x30, 0xb8, 0xaa, 0x4d, 0xa7, 0xe1, 0x27, 0x3a, 0x86, 0xbd, 0x99, 0xe9, 0x79, 0x8e, 0xa7, 0xd2,
	0x56, 0x6f, 0xda, 0x0c, 0xe6, 0xb7, 0x8b, 0x07, 0xc5, 0xc3, 0x06, 0x46, 0xa1, 0xea, 0x3c, 0xa1,
	0x91, 0xfe, 0x55, 0x82, 0xbd, 0x0b, 0xcb, 0xf9, 0x96, 0xa7, 0x4c, 0xf3, 0xf9, 0x90, 0x8b, 0xb1,
	0x0b, 0xad, 0x39, 0x5d, 0x13, 0x73, 0x7a, 0xa7, 0x7b, 0xb1, 0x19, 0x33, 0xc6, 0x2c, 0x68, 0xdf,
	0xf1, 0x9d, 0x1b, 0x4f, 0x27, 0xea, 0x4c, 0xd3, 0xf9, 0xcd, 0x98, 0x24, 0x69, 0x7e, 0xb7, 0xe3,
	0x6a, 0x08, 0xec, 0x69, 0x3a, 0x3a, 0x01, 0x76, 0x9d, 0x31, 0x9b, 0xd2, 0x2a, 0x1b, 0x76, 0xe7,
	0x52, 0x8b, 0xe4, 0x9d, 0xba, 0xbd, 0xfe, 0x4e, 0x7d, 0x0e, 0x3c, 0x1a, 0xbd, 0xaf, 0xcb, 0x2c,
	0x42, 0x2b, 0x81, 0x27, 0x13, 0xf3, 0x3d, 0xae, 0x84, 0x08, 0xc5, 0x45, 0x87, 0xf3, 0xbb, 0x7d,
	0x27, 0x1f, 0x1b, 0x5d, 0xed, 0x3f, 0x86, 0x26, 0xf7, 0x6b, 0x9d, 0x85, 0x17, 0x76, 0x65, 0xd9,
	0x85, 0x5d, 0x0f, 0x81, 0x7c, 0xf4, 0xf9, 0x12, 0xea, 0x2c, 0x44, 0x64, 0x56, 0x5d, 0x66, 0x06,
	0x14, 0xc6, 0x8d, 0x9e, 0x42, 0x8d, 0x47, 0x0b, 0xb4, 0xa9, 0xdf, 0x86, 0x83, 0xe2, 0x61, 0x09,
	0x73, 0xbe, 0xc7, 0xda, 0xd4, 0x47, 0xdf, 0xe7, 0xa3, 0x03, 0x53, 0xd7, 0x98, 0x9a, 0x11, 0xcb,
	0x94, 0x27, 0x71, 0xed, 0xd6, 0x17, 0xae, 0xbf, 0x54, 0x95, 0x47, 0xe5, 0x2b, 0xfd, 0xa9, 0x00,
	0x0f, 0xb3, 0x05, 0x15, 0x1e, 0xad, 0x7e, 0xaa, 0x65, 0xfe, 0x2c, 0xe1, 0x29, 0x17, 0x9f, 0x2f,
	0x5d, 0xdf, 0x36, 0xd1, 0x27, 0x50, 0xe7, 0xbd, 0x7d, 0x62, 0x39, 0xdf, 0xfa, 0xbc, 0xb3, 0xd7,
	0x42, 0x19, 0x75, 0xea, 0x4b, 0xbf, 0x85, 0xef, 0x2d, 0xf5, 0xbe, 0x99, 0xde, 0xfa, 0x47, 0x68,
	0x65, 0x22, 0xa0, 0xd3, 0x54, 0x77, 0xfd, 0x78, 0xc5, 0xfe, 0xe7, 0xfd, 0xf5, 0x27, 0x99, 0xfe,
	0x7a, 0xb0, 0x8e, 0xb5, 0x44, 0x87, 0x6d, 0x67, 0x00, 0xf3, 0x1e, 0x7b, 0x06, 0xdb, 0xde, 0x8d,
	0x45, 0xa2, 0x0e, 0xbb, 0x2e, 0x95, 0x10, 0x2c, 0xbd, 0x87, 0xfd, 0x8c, 0xf6, 0x7e, 0x2d, 0xf6,
	0x24, 0x8a, 0x1e, 0x76, 0xd6, 0xfd, 0xe5, 0xd1, 0xa3, 0xc8, 0x16, 0x54, 0xf1, 0xc8, 0xd5, 0x6c,
	0xd6, 0x99, 0x9e, 0x43, 0xc9, 0xb4, 0x83, 0x49, 0x3c, 0x8f, 0xd1, 0xc5, 0x91, 0x12, 0xbd, 0x17,
	0x7e, 0x4d, 0x6e, 0x2f, 0x35, 0xdb, 0xb0, 0x08, 0x66, 0x28, 0xf4, 0x43, 0xa8, 0x79, 0xbe, 0xab,
	0xd9, 0x2a, 0xb1, 0x75, 0xcd, 0xe5, 0x2c, 0x46, 0xb9, 0xc9, 0x54, 0xa6, 0xd8, 0x13, 0x07, 0x03,
	0x03, 0xb1, 0xb5, 0x64, 0x00, 0xc8, 0xf3, 0x70, 0x89, 0x99, 0x5d, 0x58, 0x33, 0xb3, 0x23, 0x28,
	0x19, 0xbe, 0xee, 0xf2, 0x72, 0x64, 0xdf, 0xe8, 0x31, 0xec, 0xb0, 0xf0, 0xa6, 0xc1, 0xeb, 0xb0,
	0x4c, 0x97, 0x8a, 0x21, 0x9d, 0x40, 0xab, 0xc7, 0xda, 0xf1, 0x88, 0xf8, 0xbe, 0xe9, 0xd8, 0x8a,
	0x81, 0x9e, 0x00, 0xf8, 0xe1, 0x82, 0xc2, 0xc3, 0x07, 0x4e, 0xd5, 0x8f, 0xd4, 0xd2, 0xdf, 0x0a,
	0xb0, 0x9b, 0x32, 0x89, 0xc6, 0x23, 0x33, 0x6f, 0x3c, 0xca, 0x38, 0xc7, 0x05, 0xd3, 0xa0, 0x2f,
	0x23, 0xdf, 0xd6, 0x5c, 0x8b, 0xd8, 0x7c, 0x2e, 0x8a, 0x96, 0xe8, 0x17, 0xd0, 0xb0, 0x1c, 0x5d,
	0xb3, 0xd4, 0x30, 0xd9, 0x09, 0xef, 0xc2, 0x4b, 0xd9, 0xbd, 0xdc, 0xc2, 0x35, 0x66, 0x40, 0x79,
	0x52, 0x26, 0xe8, 0x47, 0x10, 0x32, 0xa8, 0xb2, 0x0a, 0x0f, 0xdb, 0x71, 0x72, 0x74, 0x8c, 0xf9,
	0xbc, 0xdc, 0xc2, 0x55, 0x86, 0x1c, 0x85, 0xe5, 0x5d, 0x23, 0x09, 0xbb, 0xed, 0x85, 0x36, 0x2e,
	0x27, 0x0d, 0x81, 0xc4, 0x96, 0x2f, 0x1b, 0x50, 0x4b, 0xdc, 0x70, 0xd2, 0x7f, 0x04, 0xd8, 0x4b,
	0x73, 0xb3, 0x6e, 0x4c, 0xcb, 0x41, 0xe7, 0xc9, 0xee, 0xd9, 0x6f, 0xb6, 0xd3, 0xfd, 0xe6, 0x6b,
	0x78, 0xbc, 0xc4, 0xf7, 0x66, 0xba, 0xcd, 0xdf, 0xe9, 0xd0, 0x91, 0x0c, 0x80, 0x8e, 0x01, 0x34,
	0xd7, 0x54, 0xd7, 0x1c, 0xc9, 0xaa, 0x16, 0x7d, 0xc6, 0xb3, 0x5f, 0x61, 0x61, 0xf6, 0x5b, 0xa8,
	0xb9, 0x85, 0xd9, 0xaf, 0xb8, 0xd0, 0xd1, 0x72, 0x76, 0x9b, 0x9c, 0xfd, 0x52, 0xea, 0xd4, 0xec,
	0xe7, 0x91, 0xdf, 0xdf, 0x10, 0x3f, 0xc8, 0x99, 0xfd, 0x16, 0xd3, 0x88, 0xc0, 0x52, 0x3f, 0xe3,
	0xf1, 0x9c, 0x58, 0x24, 0x20, 0x61, 0xa7, 0xcb, 0x78, 0x5c, 0x75, 0x44, 0x62, 0x7f, 0x7f, 0x80,
	0x76, 0x4a, 0x77, 0xdf, 0xe7, 0x54, 0xc5, 0xe3, 0x86, 0x39, 0x43, 0x64, 0x3a, 0x40, 0x8c, 0x7c,
	0x76, 0x08, 0xf5, 0xe4, 0x03, 0x1c, 0x55, 0x61, 0x5b, 0x19, 0x5e, 0x28, 0x5f, 0x89, 0x5b, 0xa8,
	0x01, 0xd5, 0xbe, 0x3c, 0xbe, 0xb8, 0x1a, 0xfc, 0xe6, 0xf5, 0x4f, 0x45, 0xe1, 0xd9, 0x09, 0xc0,
	0x7c, 0x7c, 0x44, 0x8f, 0x00, 0x75, 0x07, 0x57, 0x57, 0x72, 0x77, 0xac, 0x52, 0x84, 0x3a, 0x1a,
	0x77, 0xc6, 0xb4, 0xa4, 0x00, 0xca, 0x3d, 0x05, 0xe3, 0x01, 0x16, 0x85, 0x67, 0xff, 0x16, 0x60,
	0x77, 0x61, 0x7c, 0x44, 0x15, 0x28, 0xf5, 0x07, 0x7d, 0x59, 0xdc, 0x42, 0x75, 0xa8, 0x28, 0xc3,
	0xd1, 0xe0, 0x1a, 0x77, 0x65, 0x51, 0x40, 0xbb, 0xd0, 0x50, 0x86, 0xe7, 0xf2, 0x68, 0xac, 0xf4,
	0x3b, 0x63, 0x65, 0xd0, 0x17, 0x0b, 0xd4, 0x99, 0x32, 0x1c, 0x76, 0x14, 0x2c, 0x16, 0x51, 0x0b,
	0x6a, 0x21, 0x54, 0x1d, 0x0e, 0xf0, 0x58, 0x2c, 0xa1, 0x07, 0x20, 0x26, 0xd0, 0xa1, 0x74, 0x9b,
	0xd5, 0xb7, 0x8c, 0x5f, 0x2b, 0x5d, 0x59, 0x2c, 0xb3, 0xfa, 0x66, 0xf6, 0x6a, 0x24, 0xdb, 0xa1,
	0x66, 0xdc, 0xcf, 0x48, 0xee, 0xaa, 0xaf, 0xf0, 0xe0, 0x7a, 0x28, 0x56, 0x28, 0x92, 0x3a, 0x4b,
	0xc8, 0xaa, 0x54, 0x16, 0x2f, 0x55, 0x96, 0x05, 0x9c, 0xfe, 0xa5, 0x01, 0xd5, 0x71, 0x44, 0x2a,
	0x1a, 0x25, 0xfe, 0x07, 0xd1, 0xf5, 0x88, 0x16, 0x10, 0xf4, 0x24, 0xef, 0x01, 0x1b, 0x97, 0xdc,
	0xfe, 0xd3, 0xdc, 0xf7, 0xed, 0xfc, 0xf7, 0x96, 0xb6, 0x52, 0x4e, 0xaf, 0x5d, 0x63, 0x33, 0x4e,
	0xfb, 0x89, 0xff, 0x44, 0x5d, 0x99, 0x7e, 0x80, 0x56, 0x0c, 0xcc, 0x1f, 0x9a, 0x64, 0x58, 0xfe,
	0x1b, 0x48, 0x52, 0xcd, 0xbc, 0x7d, 0x39, 0xa5, 0x9f, 0x2c, 0x4b, 0x75, 0xee, 0xfc, 0xd3, 0xa5,
	0xcf, 0xa5, 0x95, 0x01, 0x38, 0xbd, 0x9b, 0x0b, 0x70, 0x0d, 0x62, 0x4a, 0xfb, 0x8a, 0xac, 0x66,
	0xfa, 0x8e, 0x6e, 0xbf, 0xca, 0xe4, 0xcd, 0x19, 0xdf, 0x80, 0x67, 0xb2, 0x30, 0x3d, 0x73, 0xd2,
	0x3f, 0x5d, 0x3e, 0x26, 0xcd, 0x59, 0xf9, 0x6c, 0xc5, 0x2c, 0xb5, 0x26, 0x0c, 0xa7, 0x7e, 0xb3,
	0x61, 0xde, 0x2c, 0x3c, 0x2e, 0xd7, 0xd6, 0xfa, 0x9d, 0x7d, 0xbf, 0x05, 0x94, 0xd1, 0xd3, 0x1f,
	0xf7, 0xff, 0x4d, 0x13, 0xff, 0xa5, 0x37, 0x1b, 0x46, 0xcd, 0x0c, 0x2f, 0x39, 0xe7, 0x2c, 0xff,
	0xc6, 0x4c, 0x55, 0xd5, 0xb2, 0x2b, 0x2b, 0x27, 0x40, 0xce, 0x39, 0xfb, 0xdf, 0x02, 0x5c, 0x83,
	0x98, 0xd2, 0x66, 0xcf, 0x59, 0xe6, 0xaa, 0xbd, 0xab, 0xdb, 0xcb, 0xcc, 0xc4, 0xcb, 0xaa, 0xa7,
	0x1e, 0x4d, 0xef, 0x33, 0x37, 0xb8, 0xbd, 0x2f, 0x03, 0xfc, 0x77, 0x5c, 0xca, 0x40, 0x3c, 0x42,
	0xdc, 0x31, 0xc0, 0x4b, 0x78, 0x53, 0x79, 0xa7, 0x59, 0xec, 0x9f, 0x07, 0x6f, 0xcb, 0xec, 0xcf,
	0x97, 0xff, 0x0d, 0x00, 0x00, 0xff, 0xff, 0x6c, 0xb9, 0x5e, 0xd4, 0x16, 0x19, 0x00, 0x00,
}
